[
    {
        "content": "<p>A couple of questions:<br>\n1/ This is how I generate binary strings of length n.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.range</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">strings</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">strings</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">string</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">string</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">string</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]]))</span><span class=\"bp\">.</span><span class=\"n\">join</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">strings</span> <span class=\"mi\">3</span>\n</code></pre></div>\n<p>But it takes forever for this code to generate strings of length 20 (and it happens to gobble up my RAM too, <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span>) even though this C++ can generate strings perfectly fine:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;bits/stdc++.h&gt;</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">20</span><span class=\"p\">;</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">mask</span> <span class=\"o\">&lt;</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">n</span><span class=\"p\">);</span> <span class=\"n\">mask</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">--</span><span class=\"p\">)</span>\n            <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">mask</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>How can I optimize the Lean code?<br>\n2/ How do I generate binary strings of length n (again) that are lexicographically less than or equal to a certain binary string (also of length n)? Should I just kind of 'filter' the binary strings? Or are there more elegant approaches?</p>",
        "id": 223024072,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610858415
    },
    {
        "content": "<p>As usual, thanks in advance!</p>",
        "id": 223024094,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610858515
    },
    {
        "content": "<p>Is it important that they are actually strings? Mathlib has some code on bitvectors: <a href=\"https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html\">https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html</a></p>",
        "id": 223024197,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1610858661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!/near/223024197\">said</a>:</p>\n<blockquote>\n<p>Is it important that they are actually strings? Mathlib has some code on bitvectors: <a href=\"https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html\">https://leanprover-community.github.io/mathlib_docs/data/bitvec/core.html</a></p>\n</blockquote>\n<p>No, they can be bitvectors. I didn't know that mathlib has bitvectors.</p>",
        "id": 223024211,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610858708
    },
    {
        "content": "<p>First of all, your code isn't tail call optimized (does Lean have TCO?). Additionally, appending to the end of a list is O(N). If you're constructing the lists, either place in the front (using cons), or use a different data structure</p>",
        "id": 223024670,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1610859539
    },
    {
        "content": "<blockquote>\n<p>does Lean have TCO?</p>\n</blockquote>\n<p>No, but it doesn't hurt to pretend that it did</p>",
        "id": 223024759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610859692
    },
    {
        "content": "<p>Regarding optimizing this, it depends on what you want to generate the strings for. It's probably a bad idea to construct a list of all exponentially-many strings lexicographically less than a given string, you want some more implicit representation that generates the strings on demand</p>",
        "id": 223024854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610859823
    },
    {
        "content": "<p>A cheat to construct the lists would be some combination on list.range with nat.digits with a base of 2.</p>",
        "id": 223024894,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1610859858
    },
    {
        "content": "<p>That said, your <code>strings</code> function isn't bad if the point is to have a reference implementation that the efficient one is refining</p>",
        "id": 223024897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610859877
    },
    {
        "content": "<p>it's important to distinguish \"program you can easily reason about\" from \"program that runs fast\". Although lean programs can to some extent satisfy both criteria they pull in opposite directions and it's usually best to keep them separate</p>",
        "id": 223024968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610859981
    },
    {
        "content": "<p>For <code>strings</code>, assuming you want that exact type signature (which in particular implies that you have to construct the entire list of lists in memory before printing it, unlike the C++ version), I would suggest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">selections_aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">l.foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">selections_aux</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">selections</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">selections_aux</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"n\">id</span> <span class=\"o\">[]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">selections</span> <span class=\"mi\">3</span> <span class=\"o\">[</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 223025432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610860921
    },
    {
        "content": "<p>and you can use that as the basis for a program to compute those less than a given binary string:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">below_aux</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">t</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span> <span class=\"c1\">-- impossible</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">below_aux</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"n\">ff</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">]</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n  <span class=\"n\">below_aux</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">below</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">below_aux</span> <span class=\"n\">l.length</span> <span class=\"n\">l</span> <span class=\"n\">id</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">below</span> <span class=\"o\">[</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 223025707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610861419
    },
    {
        "content": "<p>So this function composition trick is a way to append to a linked list in O(1) right? Or am I missing something?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">iota</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iota</span> <span class=\"n\">n</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 223034387,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610876172
    },
    {
        "content": "<p>So it seems that in the <code>(list ℕ → list ℕ)</code> encoding, the identity function is the empty list and <code>list.cons some_value</code> is a list with one element.</p>",
        "id": 223034538,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610876474
    },
    {
        "content": "<p>Indeed. In fact, we have a type for this encoding, called <code>dlist</code></p>",
        "id": 223034600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610876574
    },
    {
        "content": "<p>it's a technique cribbed from haskell</p>",
        "id": 223034604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610876589
    },
    {
        "content": "<p>The version just above is a slightly more advanced version of the trick where we have built both mapping and appending into the recursive function</p>",
        "id": 223034657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610876672
    },
    {
        "content": "<p>The usual way you would prove theorems about that function is to prove that <code>selections_aux n l f r = map f (selections_aux n l id []) ++ r</code>, so that you only have to worry about the case where the last two parameters are <code>id</code> and <code>[]</code></p>",
        "id": 223034715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610876770
    },
    {
        "content": "<p>take a look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.sublists'_aux_eq_sublists'\">docs#list.sublists'_aux_eq_sublists'</a> for example</p>",
        "id": 223034728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610876825
    },
    {
        "content": "<p>After hours of poring over documentation I still couldn't understand how your code works. I have absolutely no functional programming experience. If you or someone else could explain both the <code>selections</code> and the <code>below</code> function I would really appreciate it.</p>",
        "id": 223045570,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610894190
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270523\">@Huỳnh Trần Khanh</span> a nice property of purely functional programming languages like lean is that you can substitute a name for the thing it's defined as. sounds very reasonable if you are a mathematician, but this is crazy talk in C++</p>",
        "id": 223063957,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610918735
    },
    {
        "content": "<p>eg if i have the C++ program <code>int x = 0; int c = ++x, return c + c;</code> i can't just inline the definition of <code>c</code> --- <code>int x = 0; return ++x + ++x</code> is a very differnet program</p>",
        "id": 223064034,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610918805
    },
    {
        "content": "<p>my point being that a great way to understand functional programs is to just substitute definitions to get a feeling for how the execution of a program works</p>",
        "id": 223064074,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610918860
    },
    {
        "content": "<p>when you don't have variable mutation (like in lean), a common trick is to define a new <code>_aux</code> function that takes the current-state of your variables as arguments</p>",
        "id": 223064158,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610918918
    },
    {
        "content": "<p>that function is usually recursive, and by changing the arguments you call yourself with, you emulate statefully mutating your variables</p>",
        "id": 223064193,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610918963
    },
    {
        "content": "<p>so <code>selections</code> above is the entry point, which calls <code>selections_aux</code> with the initial values of its arguments</p>",
        "id": 223064257,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919019
    },
    {
        "content": "<p>that is to say, <code>selections</code> is just a convenience function for calling <code>selections_aux</code>, so it suffices to understand the latter</p>",
        "id": 223064287,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919069
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">selections_aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">l.foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">selections_aux</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>here we are pattern matching on the last three arguments of the function</p>",
        "id": 223064322,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919115
    },
    {
        "content": "<p>the <code>| 0     f r :=</code> syntax denotes a pattern match, which is sorta like a C++ case statement on steroids</p>",
        "id": 223064391,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919173
    },
    {
        "content": "<p>since the type of the function is <code>:  ℕ → (list α → β) → list β → list β</code>, that means there are three arguments of types:  <br>\n1) <code>ℕ</code> <br>\n2) a function <code>(list α → β)</code> -- taking a list of alphas and returning a beta <br>\n3) <code>list β</code> </p>\n<p>and then this function finally returns a <code>list β</code></p>",
        "id": 223064429,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919222
    },
    {
        "content": "<p>with this in mind, we return to <code>| 0     f r := ...</code>, which does the <code>...</code> ONLY when the <code>ℕ</code> argument is <code>0</code></p>",
        "id": 223064513,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919286
    },
    {
        "content": "<p>and it binds the <code>(list α → β)</code> parameter to the name <code>f</code>, likewise the <code>list β</code> to <code>r</code></p>",
        "id": 223064536,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919331
    },
    {
        "content": "<p>after the <code>:=</code> comes the return value. it needs to be of type <code>list β</code></p>",
        "id": 223064593,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919367
    },
    {
        "content": "<p><code>f []</code> is a function call to <code>f</code> with an empty list, and <code>::</code> puts an element at the begining of a list.</p>",
        "id": 223064611,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919407
    },
    {
        "content": "<p>so this expression inserts <code>f []</code> at the beginning of <code>r</code></p>",
        "id": 223064619,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919420
    },
    {
        "content": "<p>it's not immediately clear to me what's happening here, so let's look at the next pattern match</p>",
        "id": 223064653,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919478
    },
    {
        "content": "<p>patterns are tried from top to bottom, so  <code>| (n+1) f r :</code> is tried only when the <code>ℕ</code> is NOT zero (otherwise the first case would have run already)</p>",
        "id": 223064706,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919507
    },
    {
        "content": "<p>it binds the same <code>f</code> and <code>r</code> parameters, but additionally now binds <code>n</code> to be one less than the <code>ℕ</code> argument</p>",
        "id": 223064719,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919534
    },
    {
        "content": "<p>(why? because it's saying that <code>n + 1</code> is the argument that was passed, so <code>n</code> is one less than that)</p>",
        "id": 223064730,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919552
    },
    {
        "content": "<p>let's ignore the <code>foldr</code> bit for a second, and look at the recursive call. <code>selections_aux n (f ∘ list.cons a)</code></p>",
        "id": 223064755,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919592
    },
    {
        "content": "<p>notice that we're calling <code>selections_aux</code> with <code>n</code> --- that is, one less than the argument we started with</p>",
        "id": 223064821,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919625
    },
    {
        "content": "<p>as such you can sort of reimagine the execution of this function as a while loop of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"bp\">//</span> <span class=\"k\">do</span> <span class=\"n\">something</span>\n  <span class=\"n\">n</span> <span class=\"c1\">--;</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 223064855,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919671
    },
    {
        "content": "<p>sorry to leave you hanging here, but i need to run</p>",
        "id": 223064949,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919760
    },
    {
        "content": "<p>one last thing to point out before i do is that not only is <code>n</code> getting smaller in this loop</p>",
        "id": 223064963,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919787
    },
    {
        "content": "<p>but also <code>f</code> is being expanded to <code>(f ∘ list.cons a)</code></p>",
        "id": 223064970,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919796
    },
    {
        "content": "<p>so in our mock C program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"bp\">//</span> <span class=\"k\">do</span> <span class=\"n\">something</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"n\">a</span><span class=\"bp\">;</span>\n  <span class=\"n\">n</span> <span class=\"c1\">--;</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 223064984,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919828
    },
    {
        "content": "<p>(this isn't exactly true due to the <code>foldr</code>, but it's a good mental approximation of the recursive transformation)</p>",
        "id": 223065069,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919913
    },
    {
        "content": "<p>happy to help dig through this furrther with you later</p>",
        "id": 223065135,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610919987
    },
    {
        "content": "<p>you got thrown a doozy for your first glimpse at functional programming!</p>",
        "id": 223065382,
        "sender_full_name": "Sandy Maguire",
        "timestamp": 1610920358
    },
    {
        "content": "<p>Okay, so here's the idea behind <code>selections</code>. The goal, slightly generalized from your original statement of producing all binary strings of length n, is to produce a list of all lists of length n consisting of the elements of the input list. These are going to have the first element of the list varying the most slowly, and the last element of the list varies on each consecutive item. So for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">[[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]]</span>\n</code></pre></div>\n<p>The key to computing this is to first figure out a recursive formula for doing so. The n=0 case is just <code>[[]]</code>, that is, there is one string and it has length 0, and (n+1) long string is obtained by appending <code>a</code> to each element of the list, and concatenating it with adding <code>b</code>, and so on, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">++</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">++</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>We can write this directly as a definition, it's a bit simpler than the one I gave:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">selections'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.join</span> <span class=\"bp\">$</span> <span class=\"n\">l.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">selections'</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">selections'</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"mi\">2</span>\n<span class=\"c1\">-- [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]</span>\n</code></pre></div>\n<p>This version is also correct, and you can check that it has the same behavior as <code>selections</code>. Just to go over the recursive case here a bit, we can write the append of a bunch of lists <code>l1 ++ l2 ++ l3 ++ []</code> as <code>list.join [l1, l2, l3]</code>, and each list is like <code>map (λ x, a::x) (selections [a,b,c] 1)</code> that I mentioned before (The <code>[a,b,c]</code> part is omitted in lean because it's a parameter in the recursion).</p>",
        "id": 223076629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610938483
    },
    {
        "content": "<p>However, this method of producing lists is inefficient, because in each step of the recursion we are constructing a bunch of lists, mapping over them (which involves making a new copy of each list), and then appending them (which involves making a bunch of intermediate lists). So we're going to be allocating new lists many times before we're done. The key observation here is that each recursive call to <code>selections</code> is in a context of a map and an append, so if we had a function <code>selections_aux l a f r</code> that was defined as <code>map f (selections l a) ++ r</code>, then we could express the recursive case from before as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span>\n  <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n  <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n  <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>The neat thing about mapping and appending is that both of these are associative in the sense that a map of a map is a map and an append of an append is an append, so we can generalize this equation to if we also had to map more things:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">r</span> <span class=\"bp\">=</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">++</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">++</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>so that if we write this with <code>selections_aux</code>, we get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">2</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">=</span>\n  <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">$</span>\n  <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">$</span>\n  <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>which is a proper recursive equation for <code>selections_aux</code>.</p>\n<p>Since we aren't appending lists directly anymore, we can't use <code>list.join</code> as before; we actually want to use <code>list.foldr</code> here, which does the operation</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">foldr</span> <span class=\"n\">g</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>We have to provide a function <code>g</code> which will be applied with the arguments <code>a</code>, <code>b</code>, <code>c</code> in turn and the result from the remainder of the list, which is the same structure as above. So rewriting our example equation one more time we get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">2</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">selections_aux</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>and now if we just generalize <code>[a,b,c]</code> and <code>1</code> in this equation we get the actual recursive equation for <code>selections_aux</code>.</p>\n<p>The base case was previously <code>selections 0 l = [[]]</code>, but now that we have to map and append, we need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">selections</span> <span class=\"mi\">0</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">r</span>\n<span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">[[]]</span> <span class=\"bp\">++</span> <span class=\"n\">r</span>\n<span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"o\">[]]</span> <span class=\"bp\">++</span> <span class=\"n\">r</span>\n<span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>so that's why the zero case is <code>f [] :: r</code>.</p>\n<p>The result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">selections_aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">l.foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">selections_aux</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>and we can rewrite the lambda into a composition for the original version.</p>",
        "id": 223077229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610939502
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"375678\">@Sandy Maguire</span>, this function is really a recursive function, it's not a while loop in disguise because it calls itself recursively m times where m is the length of the input list (2 in the case of binary strings) in each recursive call. The recursion has depth exactly n, which is why you get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>m</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">m^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> elements in the list in the end - the call tree a perfectly balanced m-way tree of depth n. If you were to render it in C++, you would still need a recursion. (There are ways to do it iteratively but that's a really different algorithm than the one here.) Here's a Rust version of the algorithm, with variables named analogously to the lean version:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">selections_aux</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Clone</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">l</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">r</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">checked_sub</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">n2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">f2</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">selections_aux</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">selections</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Clone</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">l</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[];</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">selections_aux</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[],</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">selections</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 223077841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610940499
    },
    {
        "content": "<p>(btw, you can use the button in the top left of the code snippet to test/edit this code)</p>",
        "id": 223078211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610941144
    },
    {
        "content": "<p>Just for fun, here's an iterative implementation with O(n) memory usage:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">selections_foreach</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">l</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">T</span><span class=\"p\">]))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[])</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">it1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">first</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">it1</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"n\">it1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">cur</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"n\">first</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">'</span><span class=\"na\">next</span>: <span class=\"nc\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">cur</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">iter_mut</span><span class=\"p\">().</span><span class=\"n\">rev</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">cur</span><span class=\"p\">.</span><span class=\"n\">iter_mut</span><span class=\"p\">().</span><span class=\"n\">rev</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">continue</span><span class=\"w\"> </span><span class=\"nl\">'next</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">selections_foreach</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">c</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 223080795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610945311
    },
    {
        "content": "<p>So the <code>β</code> type parameter represents both the <code>list ℕ</code> type and the <code>ℕ</code> type right?</p>",
        "id": 223127172,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610980620
    },
    {
        "content": "<p>which one?</p>",
        "id": 223127506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610980789
    },
    {
        "content": "<p>In the <code>selections_aux</code> function</p>",
        "id": 223127600,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610980824
    },
    {
        "content": "<p>in <code>selections_aux</code>, the beta type parameter only needs to be <code>list A</code> in order to be useful for <code>selections</code>, but it can be generalized so why not</p>",
        "id": 223127688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610980873
    },
    {
        "content": "<p>since <code>selections</code> uses <code>id</code> for the function <code>f</code> that implies that <code>list A = B</code></p>",
        "id": 223127721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610980903
    },
    {
        "content": "<p>and when using <code>selections</code> to produce a list of bools you need <code>A = bool</code>, or to make a list of nat you need <code>A = nat</code></p>",
        "id": 223127833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610980951
    },
    {
        "content": "<p>Thanks a lot! Now I understand how the <code>selections</code> function works. I substituted polymorphic stuff with concrete types and the <code>foldr</code> function with ordinary function composition and the <code>selections</code> function now makes total sense!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">selections_aux</span> <span class=\"o\">(</span><span class=\"n\">alphabet</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">current_string</span> <span class=\"n\">accumulated_list</span> <span class=\"o\">:=</span> <span class=\"n\">current_string</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"n\">accumulated_list</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">current_string</span> <span class=\"n\">accumulated_list</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">selections_aux</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">current_string</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">selections_aux</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">current_string</span> <span class=\"bp\">∘</span> <span class=\"n\">list.cons</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">accumulated_list</span>\n</code></pre></div>",
        "id": 223138339,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610985946
    },
    {
        "content": "<p>It feels a lot like solving cryptograms.</p>",
        "id": 223138444,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1610985982
    },
    {
        "content": "<p>Going the other way (finding the general thing which can apply in more than one situation) is called abstraction, and it seems to be a common feature of both maths and computer science. Spotting  underlying patterns is something mathematicians can get excited about.</p>",
        "id": 223147009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610990890
    },
    {
        "content": "<p>Tomorrow I will implement the \"digit dynamic programming\" algorithm in Lean. But I want to make sure that my definitions are alright first.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">strings</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">nat.to_digits</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">popcount</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">string.foldl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">accumulated</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">digit</span><span class=\"o\">,</span> <span class=\"n\">accumulated</span> <span class=\"bp\">+</span> <span class=\"n\">digit</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">total_popcount</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">strings</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">accumulated</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">current_string</span><span class=\"o\">,</span> <span class=\"n\">accumulated</span> <span class=\"bp\">+</span> <span class=\"n\">popcount</span> <span class=\"n\">current_string</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Are the definitions alright? Any suggestions?</p>",
        "id": 223245514,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611071212
    },
    {
        "content": "<p>The <code>total_popcount</code> function computes the number of <code>1</code> digits in the binary representations of numbers from 0 to n - 1.</p>",
        "id": 223245727,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611071302
    },
    {
        "content": "<p>So again, <a href=\"https://cses.fi/paste/ace3f13c3d25a24513f457/\">here is the code I'm going to port to Lean</a>.</p>",
        "id": 223247568,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611072087
    },
    {
        "content": "<p>Not relevant to your porting, but <code>λ accumulated, λ digit, _</code> is long for <code>λ accumulated digit, _</code>, and <code>(λ accumulated, λ digit, accumulated + digit)</code> is long for <code>(+)</code>.</p>",
        "id": 223250372,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611073260
    },
    {
        "content": "<p>Alright, ported! Now how do I prove that the <code>dp</code> function is equivalent to the <code>total_popcount</code> function?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.range</span>\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">strings</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">nat.to_digits</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">popcount</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">string.foldl</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">total_popcount</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">strings</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">accumulated</span> <span class=\"n\">current_string</span><span class=\"o\">,</span> <span class=\"n\">accumulated</span> <span class=\"bp\">+</span> <span class=\"n\">popcount</span> <span class=\"n\">current_string</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dp_cardinality</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dp_popcount</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.reverse</span> <span class=\"o\">((</span><span class=\"n\">nat.to_digits</span> <span class=\"mi\">2</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">ff</span> <span class=\"k\">else</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dp</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"o\">(</span><span class=\"n\">to_bool</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ff</span>\n</code></pre></div>",
        "id": 223346814,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611133446
    },
    {
        "content": "<p>Memoizing the parameters would yield an algorithm that runs in logarithmic time!</p>",
        "id": 223346882,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611133502
    },
    {
        "content": "<p>Another tip: your <code>popcount</code> is just <code>string.sum</code>, which will make the proof marginally easier. It's tempting in fact to just define <code>total_popcount</code> as <code>(((range n).map $ nat.to_digits 2).map list.sum).sum</code>, which eliminates the other two definitions.</p>",
        "id": 223347417,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611133827
    },
    {
        "content": "<p>I am genuinely stuck. I have never proved something like this before. Can anyone please help me out, thanks in advance. I guess there would be some sort of plumbing to convert between different representations right?</p>",
        "id": 223379860,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611153288
    },
    {
        "content": "<p>Why don't you start by formalising your question and adding it to the MWE above? People like explicit <code>sorry</code>ed proofs.</p>",
        "id": 223379956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611153342
    },
    {
        "content": "<p>Also, why not sketch a (non-Lean) proof of what you want to do?</p>",
        "id": 223380119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611153415
    },
    {
        "content": "<p>Alright so here is the MWE with an explicit <code>sorry</code>'d proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.range</span>\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">popcount</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(((</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"bp\">$</span> <span class=\"n\">nat.to_digits</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">list.sum</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dp_cardinality</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dp_popcount</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_binary</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.reverse</span> <span class=\"o\">((</span><span class=\"n\">nat.to_digits</span> <span class=\"mi\">2</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">ff</span> <span class=\"k\">else</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dp</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"o\">(</span><span class=\"n\">to_binary</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ff</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">equivalent</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">dp</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">popcount</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 223380348,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611153523
    },
    {
        "content": "<p><code>slim_check</code> can't find any counterexamples so that's a good start :D</p>",
        "id": 223380622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611153644
    },
    {
        "content": "<p>So what's the proof sketch you have in mind? Lean won't do anything automatically, it needs to be guided.</p>",
        "id": 223380697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611153677
    },
    {
        "content": "<p>Why did you use <code>(range n).map (nat.to_digits 2)</code> instead of <code>selections</code>? You're going to need a bunch of theorems about digits that don't really matter here</p>",
        "id": 223380722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611153690
    },
    {
        "content": "<p><code>to_binary</code> also looks a little painful</p>",
        "id": 223380858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611153738
    },
    {
        "content": "<p>Here are some lemmas that should help you along the way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eval_binary</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dp_cardinality_tt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">l</span> <span class=\"n\">tt</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dp_cardinality_ff</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">l</span> <span class=\"n\">ff</span> <span class=\"bp\">=</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l.reverse</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dp_popcount_tt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"k\">in</span>\n  <span class=\"n\">dp_popcount</span> <span class=\"n\">l</span> <span class=\"n\">tt</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_binary_to_binary</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">eval_binary</span> <span class=\"o\">(</span><span class=\"n\">to_binary</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 223386122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611155527
    },
    {
        "content": "<p>The algorithm that is being implemented is called <a href=\"https://www.geeksforgeeks.org/digit-dp-introduction/\">\"digit DP\"</a>. The \"digit DP\" algorithm tries to construct every possible string that satisfies a given condition, for example in this case lexicographically less than the binary representation of n.</p>\n<p>The first parameter of the two <code>dp</code> functions represents the current digit that is being probed. It's somewhat similar to the <code>selections</code> function: the first digit is probed first, then the second, then the third, then the nth. And the second parameter indicates whether or not the current number is already less than <code>n</code>. If every number with the already probed digits is less than <code>n</code> then the digits that are yet to be probed can be anything, otherwise the next digit must be &lt;= the corresponding digit of the number <code>n</code>.</p>\n<p>The <code>dp_cardinality</code> function counts numbers that start with the already probed digits and are less than <code>n</code>. The <code>dp_popcount</code> function counts the number of set bits.</p>\n<p>Let me dissect the two functions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dp_cardinality</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"c1\">-- No more digits to probe. The final number is less than `n` so there is exactly 1 number that can be formed.</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- No more digits to probe. The final number is &gt;= `n`. No number can be formed.</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"c1\">-- If the corresponding digit of `n` is zero, the only possible value for the current digit is 0. Not every number with the already probed digits is less than `n`, therefore the second parameter is ff.</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"c1\">-- The corresponding digit of `n` is one. The current digit can be either 0 or 1. If the current digit is 0 then every number with the already probed digits is less than `n`, therefore the second parameter is tt. Otherwise, the second parameter is ff.</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n<span class=\"c1\">-- The second parameter indicates that the rest of the number can be anything and the number is still less than `n`.</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dp_popcount</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"c1\">-- No more digits, 1 number can be formed.</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- The current digit is 0.</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span>\n\n<span class=\"c1\">-- The current digit can either be 0 or 1. When the current digit is 1, the total number of set bits increases by the # of numbers with the already probed digits that are less than `n`.</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">ff</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">the_rest</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">dp_popcount</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span> <span class=\"bp\">+</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">the_rest</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>As I don't have a math background, I don't really have a proof sketch. But I think the description of the algorithm somewhat serves as a justification for its correctness.</p>",
        "id": 223386772,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611155788
    },
    {
        "content": "<p>Apologies if the explanation is confusing, I am not really good with words.</p>",
        "id": 223386897,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611155852
    },
    {
        "content": "<blockquote>\n<p>The dp_cardinality function counts numbers that start with the already probed digits and are less than n. The dp_popcount function counts the number of set bits.</p>\n</blockquote>\n<p>Those sound like excellent lemmas</p>",
        "id": 223387446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611156090
    },
    {
        "content": "<p>I had a very quick attempt by just throwing <code>simp</code> at the problem, and found a missing lemma about range, which I've PR'd as <a href=\"https://github.com/leanprover-community/mathlib/issues/5821\">#5821</a></p>",
        "id": 223388883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611156641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> You mean <a href=\"https://github.com/leanprover-community/mathlib/pull/5821\">https://github.com/leanprover-community/mathlib/pull/5821</a> right?</p>",
        "id": 223394424,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611158844
    },
    {
        "content": "<p>Whoops, my clipboard has been betraying me today</p>",
        "id": 223394600,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611158907
    },
    {
        "content": "<p>Here's a more directed proof sketch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">range_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">range</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set_bits</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">nat.digits</span> <span class=\"mi\">2</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">set_bits_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set_bits</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set_bits</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eval_binary</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_binary_to_binary</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">eval_binary</span> <span class=\"o\">(</span><span class=\"n\">to_binary</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">eval_binary_lt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">l.length</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eval_binary'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">l.length</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">eval_binary</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eval_binary_rev</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">eval_binary</span> <span class=\"o\">(</span><span class=\"n\">reverse</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">eval_binary'</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">eval_binary_rev_lt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">eval_binary'</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">l.length</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eval_binary'_to_binary</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">eval_binary'</span> <span class=\"o\">(</span><span class=\"n\">to_binary</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">range_binary</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">tt</span> <span class=\"bp\">++</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">ff</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">tt</span> <span class=\"bp\">++</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">range_binary_range_tt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">tt</span> <span class=\"bp\">=</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">range_binary_range_ff</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">ff</span> <span class=\"bp\">=</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">eval_binary'</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">range_binary_length</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">dp_cardinality</span> <span class=\"n\">l</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">range_binary_set_bits</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">((</span><span class=\"n\">range_binary</span> <span class=\"n\">l</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">set_bits</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"n\">dp_popcount</span> <span class=\"n\">l</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">equivalent</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">dp</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">popcount</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dp</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">range_binary_set_bits</span><span class=\"o\">,</span> <span class=\"n\">popcount</span><span class=\"o\">,</span> <span class=\"n\">map_map</span><span class=\"o\">,</span>\n    <span class=\"n\">range_binary_range_ff</span><span class=\"o\">,</span> <span class=\"n\">eval_binary'_to_binary</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 223397096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611159841
    },
    {
        "content": "<p>also you should be using <code>nat.digits</code> (from <code>data.nat.digits</code>) instead of <code>nat.to_digits</code>. It's basically the same thing but it has a lot more lemmas</p>",
        "id": 223398451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611160408
    },
    {
        "content": "<p>Lightning quick question: how do I use <code>slim_check</code>?</p>",
        "id": 223486491,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611222163
    },
    {
        "content": "<p>Is <code>import tactic.slim_check</code> the answer you're looking for?</p>",
        "id": 223486511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611222183
    },
    {
        "content": "<p>So deterministic timeout means that slim_check fails to find a counterexample right?</p>",
        "id": 223486546,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611222228
    },
    {
        "content": "<p>Thanks for the quick response, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span aria-label=\"raised hands\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"raised hands\">:raised_hands:</span></p>",
        "id": 223486695,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611222337
    },
    {
        "content": "<p>How would you prove this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">coerce_bool</span> <span class=\"o\">(</span><span class=\"n\">digits</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.reverse</span> <span class=\"o\">(</span><span class=\"n\">digits.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">ff</span> <span class=\"k\">else</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">coerce_digits</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.reverse</span> <span class=\"o\">(</span><span class=\"n\">string.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_identity</span> <span class=\"o\">{</span> <span class=\"n\">string</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">string</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">coerce_digits</span> <span class=\"o\">(</span><span class=\"n\">coerce_bool</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It is equivalent to the <code>eval_binary'_to_binary</code> lemma in the Lean proof sketch.</p>",
        "id": 223529673,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1611245113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113489-new-members/topic/I.20want.20to.20generate.20binary.20strings.20and.20reason.20about.20them!/near/223486546\">said</a>:</p>\n<blockquote>\n<p>So deterministic timeout means that slim_check fails to find a counterexample right?</p>\n</blockquote>\n<p>I think <code>slim_check</code> will tell you explicitly if it fails to find a counterexample after a certain number of tries; a deterministic timeout might mean that something else is failing before <code>slim_check</code> is able to run (e.g. <code>slim_check</code> does a search for a <code>testable</code> instance and this could time out). The documentation and some examples can be found <a href=\"https://leanprover-community.github.io/mathlib_docs/tactic/slim_check.html\">here</a>; you can try those out to see what the normal behavior is.</p>",
        "id": 223530121,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1611245312
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coerce_bool</span> <span class=\"o\">(</span><span class=\"n\">digits</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.reverse</span> <span class=\"o\">(</span><span class=\"n\">digits.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">ff</span> <span class=\"k\">else</span> <span class=\"n\">tt</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">coerce_digits</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.reverse</span> <span class=\"o\">(</span><span class=\"n\">string.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_identity</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">coerce_digits</span> <span class=\"o\">(</span><span class=\"n\">coerce_bool</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">coerce_digits</span><span class=\"o\">,</span> <span class=\"n\">coerce_bool</span><span class=\"o\">,</span> <span class=\"n\">list.map_reverse</span><span class=\"o\">,</span>\n    <span class=\"n\">list.reverse_reverse</span><span class=\"o\">,</span> <span class=\"n\">list.map_map</span><span class=\"o\">,</span> <span class=\"n\">list.map_congr</span><span class=\"o\">,</span> <span class=\"n\">list.map_id</span><span class=\"o\">],</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 223533064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611246314
    }
]
[
    {
        "content": "<p>Why does the tactic <code>super</code> fail in the following code?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">super</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">option_to_subfunc</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">option.is_some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)}</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">option.get</span> <span class=\"n\">h</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">subfunc_to_option</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"c1\">--[decidable_pred c]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"n\">option.some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩)</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inv2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">subfunc_to_option</span> <span class=\"o\">(</span><span class=\"n\">option_to_subfunc</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">super</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 277500996,
        "sender_full_name": "Victor Porton",
        "timestamp": 1648867439
    },
    {
        "content": "<p>The idea is to go from a function to option monad to a function on a subset and back.</p>",
        "id": 277501040,
        "sender_full_name": "Victor Porton",
        "timestamp": 1648867485
    },
    {
        "content": "<p>Does <code>super</code> know about functional  extensionality? I have no idea</p>",
        "id": 277511840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648883111
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">inv2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subfunc_to_option</span> <span class=\"o\">(</span><span class=\"n\">option_to_subfunc</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"c1\">-- Two functions are equal if their results are equal for all arguments</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">subfunc_to_option</span><span class=\"o\">],</span> <span class=\"c1\">-- Unfold the definition of `subfunc_to_option` and simplify</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span> <span class=\"c1\">-- Split into two cases</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">option_to_subfunc</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- For the `some` case, simplifier can handle that</span>\n  <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- Unfold the definition of set membership</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">option.is_some_iff_exists</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- Simplify and push negation</span>\n    <span class=\"n\">by_contra</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"c1\">-- Proof by contradiction</span>\n    <span class=\"n\">cases</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">val</span> <span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">contradiction</span> <span class=\"o\">},</span> <span class=\"c1\">-- Split `f x` into cases</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 277519408,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1648893160
    },
    {
        "content": "<p>Conclusion: <code>super</code> is not all-powerful and proofs still need to be done manually picking tactics.</p>",
        "id": 277522163,
        "sender_full_name": "Victor Porton",
        "timestamp": 1648896726
    },
    {
        "content": "<p>Proving a theorem is NP-hard. There is no \"all-powerful\" tactic and there will never be. Isabelle theorem prover, for instance, has more automation, but it's far from proving any theorem using a single tactic.</p>",
        "id": 277525425,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1648900836
    },
    {
        "content": "<p>proving a theorem is undecidable</p>",
        "id": 277526583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648902451
    },
    {
        "content": "<p>The <code>zulip</code> tactic is pretty good though</p>",
        "id": 277537640,
        "sender_full_name": "Julian Berman",
        "timestamp": 1648915716
    },
    {
        "content": "<p>I think one of the complexities here is that there was a subtle misuse of the <code>set</code> API. The <code>subfunc_to_option</code> function was being applied to something that used a predicate directly rather than something that was strictly a set.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">option_to_subfunc</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">option.is_some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)}</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">option.get</span> <span class=\"n\">h</span>\n<span class=\"c1\">--                ^--- this is not a `set`, instead it's defining a predicate</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">subfunc_to_option</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"c1\">-- switched to predicate rather than `set`</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">c</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">option.some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩)</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inv2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">subfunc_to_option</span> <span class=\"o\">(</span><span class=\"n\">option_to_subfunc</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">;</span>  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">subfunc_to_option</span><span class=\"o\">,</span> <span class=\"n\">option_to_subfunc</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 277545288,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648925589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113489-new-members/topic/failed.20tactic.20super/near/277525425\">said</a>:</p>\n<blockquote>\n<p>Proving a theorem is NP-hard. There is no \"all-powerful\" tactic and there will never be. Isabelle theorem prover, for instance, has more automation, but it's far from proving any theorem using a single tactic.</p>\n</blockquote>\n<p>I know. But for a human <code>inv2</code> theorem is obvious.</p>",
        "id": 277551608,
        "sender_full_name": "Victor Porton",
        "timestamp": 1648933526
    },
    {
        "content": "<p>When theorem provers are as good at humans at closing obvious goals quickly it will be a great relief. Until then I learn the tactics.</p>",
        "id": 277558022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648942125
    },
    {
        "content": "<p>If you want to write a new tactic that solves all trivial goals, I'm sure that would be a very welcomed addition to mathlib.</p>",
        "id": 277558538,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1648942847
    }
]
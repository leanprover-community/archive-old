[
    {
        "content": "<p>Sorry, I'm afraid I'm stuck again. I have a class of normed lattices for which I can prove that the inf and sup operations are continuous. As these proofs are long and similar, I want to prove one and then infer the other from the equivalent property for the dual:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.ordered</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">notation</span> <span class=\"bp\">`|`</span><span class=\"n\">a</span><span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"c1\">-- temporary notation within this definition</span>\n<span class=\"o\">(</span><span class=\"n\">solid'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"bp\">|</span><span class=\"n\">b</span><span class=\"bp\">|</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_inf</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">continuous_inf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">×</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">⊓</span> <span class=\"n\">p.2</span><span class=\"o\">))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_continuous_sup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_sup</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">continuous_sup</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">×</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">⊔</span> <span class=\"n\">p.2</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- If α is a normed lattice ordered group, so is order_dual α</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"c1\">-- Proof omitted for brevity</span>\n<span class=\"kd\">instance</span> <span class=\"n\">normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_continuous_inf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- If the inf is continuous in the order dual then the sup is continuous</span>\n<span class=\"kd\">instance</span> <span class=\"n\">has_continuous_inf_dual_has_continuous_sup</span>\n<span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_sup</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">L</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_continuous_sup</span>  <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">continuous_sup</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">has_continuous_inf.continuous_inf</span>  <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">-- If the order dual is a normed lattice ordered group, it has continuous inf</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">normed_lattice_add_comm_group_has_continuous_inf</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">has_continuous_inf_dual_has_continuous_sup</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"n\">α</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>\n\n  <span class=\"c1\">-- ⊢ @eq.{u+1}</span>\n  <span class=\"c1\">-- (has_inf.{u} (order_dual.{u} α))</span>\n  <span class=\"c1\">-- (@order_dual.has_inf.{u} α (@semilattice_sup.to_has_sup.{u} α (@lattice.to_semilattice_sup.{u} α (@normed_lattice_add_comm_group.to_lattice.{u} α h))))</span>\n  <span class=\"c1\">-- (@semilattice_inf.to_has_inf.{u} (order_dual.{u} α) (@lattice.to_semilattice_inf.{u} (order_dual.{u} α) (@normed_lattice_add_comm_group.to_lattice.{u} (order_dual.{u} α) h)))</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I've tried various permutations, but I always end up being asked to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">order_dual.has_inf</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">semilattice_inf.to_has_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and at this point I get stuck.</p>\n<p>Thanks,</p>\n<p>Christopher</p>",
        "id": 243363696,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624271523
    },
    {
        "content": "<p>This looks wrong:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n</code></pre></div>\n<p>this says <code>order_dual α</code> has the same lattice structure as <code>α</code>, not the dual structure</p>",
        "id": 243364222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624271922
    },
    {
        "content": "<p>I adapted that line from <a href=\"https://github.com/leanprover-community/mathlib/blob/c7d094da6d3ced93ab034ba9d77519b4f9147124/src/topology/algebra/ordered/basic.lean#L109\">this line</a> in Mathlib</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n</code></pre></div>\n<p>I think that line says that the dual of a topological space is also a topological space, so I assume my line says that the dual of a normed lattice ordered group is a normed lattice ordered group?</p>",
        "id": 243371914,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624276923
    },
    {
        "content": "<p>Yes, but the difference is a topological space has nothing to take the dual of</p>",
        "id": 243372015,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624276986
    },
    {
        "content": "<p>\"Instance\" is like \"definition\", not \"theorem\". This line in mathlib says \"we <em>define</em> the topology on the dual space to be the same as the topology on the original space\".</p>",
        "id": 243372019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624276988
    },
    {
        "content": "<p>What you want to do here is copy the topology unmodified, and fill in the remaining fields using the existing instance for <code>lattice (order_dual α)</code></p>",
        "id": 243372161,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624277073
    },
    {
        "content": "<p>Thank you. So, something more like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">solid'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>where the sorry remain to be proved?</p>",
        "id": 243375202,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624278877
    },
    {
        "content": "<p><code>..h</code> is no good, that will give you the wrong lattice structure.</p>",
        "id": 243375386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624278990
    },
    {
        "content": "<p>I think this also copies the definition of <code>le</code> from <code>h</code> to the order dual</p>",
        "id": 243375393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624278993
    },
    {
        "content": "<p>You want <code>.. order_dual.lattice h</code>, or something like that.</p>",
        "id": 243375427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624279026
    },
    {
        "content": "<p>Presumably</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n</code></pre></div>\n<p>is okay, as, like <code>topological_space</code>, the definition of <code>normed_group</code> is independent of order?</p>",
        "id": 243376661,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624279761
    },
    {
        "content": "<p>Yes, this part looks fine.</p>",
        "id": 243376895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624279878
    },
    {
        "content": "<p>Okay, I think I have the proof that the order dual of a <code>normed_lattice_add_comm_group</code> is also a <code>normed_lattice_add_comm_group</code> correct now?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.ordered</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ordered_group</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">notation</span> <span class=\"bp\">`|`</span><span class=\"n\">a</span><span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"c1\">-- temporary notation within this definition</span>\n<span class=\"o\">(</span><span class=\"n\">solid'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"bp\">|</span><span class=\"n\">b</span><span class=\"bp\">|</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Every (normed) lattice additive commutative group is also an ordered additive commutative group</span>\n<span class=\"c1\">-- @[priority 100] -- see Note [lower instance priority]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">normed_lattice_add_comm_group.to_ordered_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ordered_add_comm_group</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">s.add</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">s</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_inf</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">continuous_inf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">×</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">⊓</span> <span class=\"n\">p.2</span><span class=\"o\">))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_continuous_sup</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_sup</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">continuous_sup</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">×</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">⊔</span> <span class=\"n\">p.2</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"c1\">-- Special case of Bourbaki A.VI.9 (2)</span>\n<span class=\"c1\">-- (Actually this is true for a lattice_add_comm_group, but omit that for simplicity)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">neg_join_eq_neg_meet_neg</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⊔</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">=</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">⊓</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">le_antisymm_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">le_inf_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">neg_le_neg_iff</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">le_sup_left</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">neg_le_neg_iff</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">le_sup_right</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">neg_le_neg_iff</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">neg_le_neg_iff</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">neg_le_neg_iff</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">join_neg_eq_neg_meet</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⊓</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">neg_neg</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"bp\">⊔-</span><span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">neg_join_eq_neg_meet_neg</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">neg_neg</span><span class=\"o\">,</span> <span class=\"n\">neg_neg</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">opsolid</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⊓-</span><span class=\"n\">a</span> <span class=\"bp\">≥</span> <span class=\"n\">b</span><span class=\"bp\">⊓-</span><span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h.solid'</span><span class=\"o\">,</span>\n  <span class=\"n\">nth_rewrite</span> <span class=\"mi\">0</span> <span class=\"bp\">←</span> <span class=\"n\">neg_neg</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">join_neg_eq_neg_meet</span><span class=\"o\">,</span>\n  <span class=\"n\">nth_rewrite</span> <span class=\"mi\">0</span> <span class=\"bp\">←</span> <span class=\"n\">neg_neg</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">join_neg_eq_neg_meet</span><span class=\"o\">,</span>\n  <span class=\"n\">finish</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- If α is a normed lattice ordered group, so is order_dual α</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h₁</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">order_dual.dual_le</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">order_dual.dual_le</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h.add_le_add_left</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">solid'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">opsolid</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">order_dual.dual_le</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>However, I still get asked to prove <code>order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Proof omitted for brevity</span>\n<span class=\"kd\">instance</span> <span class=\"n\">normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_continuous_inf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- If the inf is continuous in the order dual then the sup is continuous</span>\n<span class=\"kd\">instance</span> <span class=\"n\">has_continuous_inf_dual_has_continuous_sup</span>\n<span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_sup</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">L</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_continuous_sup</span>  <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">continuous_sup</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">has_continuous_inf.continuous_inf</span>  <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">-- If the order dual is a normed lattice ordered group, it has continuous inf</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">normed_lattice_add_comm_group_has_continuous_inf</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"n\">α</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>\n\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Thanks very much for all your help!</p>",
        "id": 243399107,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624289136
    },
    {
        "content": "<p>Do I need:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>in order to make this work? In Mathlib <code>order/bounded_lattices.lean</code>, <code>bounded_lattice</code> extends <code>lattice</code> and some other classes, and I notice it uses <code>set_option old_structure_cmd true</code>.</p>",
        "id": 243539583,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624378143
    },
    {
        "content": "<p>That option is for when you extend two typeclasses which have overlapping fields. I suspect <code>normed_group</code> and <code>lattice</code> don't have any overlapping fields so I don't think it will help.</p>",
        "id": 243541608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624379089
    },
    {
        "content": "<p>I should add that I'm quite surprised this proof isn't <code>refl</code> (but it isn't)</p>",
        "id": 243542127,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624379365
    },
    {
        "content": "<p>In fact this goal seems to be false :-(</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"n\">α</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">order_dual.has_inf</span><span class=\"o\">,</span>\n  <span class=\"n\">delta</span> <span class=\"n\">semilattice_inf.to_has_inf</span><span class=\"o\">,</span>\n  <span class=\"n\">congr'</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- cheat by assuming false thing</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"c1\">-- unfortunately this now works</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works :-(</span>\n</code></pre></div>",
        "id": 243542763,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624379632
    },
    {
        "content": "<p>Actually your proof looks wrong to me, maybe this is expected behaviour. You've proved that NLACGs have a continuous_inf. Your <code>convert</code> line is claiming that what you're trying to prove (dual has continuous inf) follows from <code>dual_normed_lattice_add_comm_group_has_continuous_inf</code> but you're giving it the wrong <code>h</code>, if you give it <code>h</code> then it will identify alpha with its dual and now you're in trouble.</p>",
        "id": 243545531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624380791
    },
    {
        "content": "<p>If you put <code>attribute [irreducible] order_dual</code> before <code>normed_lattice_add_comm_group_dual_has_continuous_inf</code> you'll see an error on the convert line, because now Lean cannot unify <code>alpha</code> and <code>order_dual alpha</code>, which is not what you want it to do anyway.</p>",
        "id": 243545908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624380954
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>OK I see where I was going wrong with my examples. It looks to me like we're back on track.</p>",
        "id": 243547707,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624381692
    },
    {
        "content": "<p>So, now I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">order_dual</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">exact</span> <span class=\"n\">order_dual.normed_lattice_add_comm_group</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"n\">α</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- ⊢ order_dual.topological_space = uniform_space.to_topological_space</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- ⊢ order_dual.has_inf α = semilattice_inf.to_has_inf (order_dual α)</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>?</p>",
        "id": 243551020,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624383034
    },
    {
        "content": "<p>Better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">dual_normed_lattice_add_comm_group_has_continuous_inf</span> <span class=\"n\">α</span> <span class=\"n\">order_dual.normed_lattice_add_comm_group</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ order_dual.topological_space = uniform_space.to_topological_space</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243551398,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1624383178
    },
    {
        "content": "<p>That goal looks true!</p>",
        "id": 243582163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624397781
    },
    {
        "content": "<p>Your <code>convert</code> closes the goal for me. Don't put the irreducibility attribute on order_dual, that was just to show you where your abuse of definitional equality was not what you wanted. Abuse of defeq gives you <code>alpha = order_dual alpha</code> which is bad because then an inf or a sup might slip over that equality and become hard to work with.</p>",
        "id": 243582381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624397976
    },
    {
        "content": "<p>The way which I would argue was the \"correct\" way to do this would be to make <code>order_dual</code> irreducible, define a map <code>to_dual : alpha -&gt; order_dual alpha</code> which was <code>id</code> but defined before <code>order_dual</code> was made irreducible, and then prove a ton of lemmas about to_dual being an order-reversing isomorphism. But the CS people are too lazy to use this principled approach because they are more used to defeq abuse and it makes for shorter code. It's quite a knack to get it right though.</p>",
        "id": 243582551,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624398094
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">normed_lattice_add_comm_group_dual_has_continuous_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">normed_lattice_add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_continuous_inf</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>It just follows from the two other instances you've made.</p>",
        "id": 243582643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624398149
    }
]
[
    {
        "content": "<p>Hello:)</p>\n<p>I am trying to make a finite set of pairs/tuples where the first element of the tuple is unique. I am trying different solutions such as using finite sets, finsets and making a subtype of finsets. The context where I need this is as follows. Suppose I have a map (or dictionary in Python terms) that is modeled as a list of \"tuples\" (see the inductive type <code>map</code> below) and the latest addition to the map is the key/value pair. I am trying to prove the property that the cardinality of the key is equal to the cardinality of  the set of tuples (where the first element was unique).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">map</span>\n<span class=\"bp\">|</span> <span class=\"n\">build</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">map</span><span class=\"o\">):</span> <span class=\"n\">map</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">tuple</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"n\">create</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"n\">tuple</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fst</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">tuple</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tuple.create</span> <span class=\"n\">a</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">snd</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">tuple</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tuple.create</span> <span class=\"n\">_</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>My latest approach is using a subtype of \"a finset of tuple\" where I then lift all the functions over the subtype (I hope that that sentence is correct).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finsettuple_unique_key</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fs</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">$</span> <span class=\"bp\">@</span><span class=\"n\">tuple</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">t1</span> <span class=\"bp\">∈</span> <span class=\"n\">fs</span><span class=\"o\">,</span>  <span class=\"bp\">∀</span> <span class=\"n\">t2</span> <span class=\"bp\">∈</span> <span class=\"n\">fs</span><span class=\"o\">,</span> <span class=\"n\">t1</span> <span class=\"bp\">≠</span> <span class=\"n\">t2</span> <span class=\"bp\">→</span> <span class=\"n\">fst</span> <span class=\"n\">t1</span> <span class=\"bp\">≠</span> <span class=\"n\">fst</span> <span class=\"n\">t2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fintupleset</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">fs</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">tuple</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">//</span> <span class=\"n\">finsettuple_unique_key</span> <span class=\"n\">fs</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>With this subtype of finset, I can make a function that insert a value into the items set and a function that returns me the key/value pairs of a map (see below):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fintupleset_insert</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"bp\">$</span> <span class=\"bp\">@</span><span class=\"n\">tuple</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">tuple</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs</span><span class=\"o\">:</span> <span class=\"n\">fintupleset</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"n\">fintupleset</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">subtype.mk</span> <span class=\"o\">(</span>\n    <span class=\"n\">insert</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">finset.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">t1</span><span class=\"o\">,</span> <span class=\"n\">fst</span> <span class=\"n\">t</span> <span class=\"bp\">≠</span> <span class=\"n\">fst</span> <span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subtype.val</span> <span class=\"n\">fs</span><span class=\"o\">))</span>\n    <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>   <span class=\"c1\">-- leaving out the proof as it is very long</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">items</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"bp\">$</span> <span class=\"bp\">@</span><span class=\"n\">tuple</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">fintupleset</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"n\">fintupleset_empty</span> <span class=\"c1\">-- this is basically \\empty</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">fintupleset_insert</span> <span class=\"o\">(</span><span class=\"n\">tuple.create</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tmpitems</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now I have the problem that if I want to reason about the cardinality of this fintupleset, I cannot do that easily because if I use the fintupleset_insert I defined, it uses the insert and filter functions defined in the finset namespace and no lemmas seem to be defined that use both those functions (I also cannot seem to prove it, maybe due to inexperience).</p>\n<p>Now my question is, is this approach using the fintupleset subtype a good approach? Or is there an approach I could take that would be easier?</p>",
        "id": 223549729,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611253319
    },
    {
        "content": "<p>You should take a look at the <code>alist</code> type</p>",
        "id": 223549940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611253428
    },
    {
        "content": "<p>it implements essentially this idea, with a <code>list (A x B)</code> where the elements of <code>A</code> must be nodup</p>",
        "id": 223550023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611253461
    },
    {
        "content": "<p><code>tuple</code> is just <code>prod</code> btw</p>",
        "id": 223550137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611253532
    },
    {
        "content": "<p>I think the reason I have my own tuple type is simply as practice (very simple practice, but I forgot about to do some basic stuff).</p>",
        "id": 223551427,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611254078
    },
    {
        "content": "<p>I can't seem to easily find something on  <code>alist</code> like documentation or its definition. Is it part of mathlib?</p>",
        "id": 223551494,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611254108
    },
    {
        "content": "<p>Yes its in mathlib, docs at  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/alist\">docs#alist</a></p>",
        "id": 223551655,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1611254174
    },
    {
        "content": "<p>Aa, yes this is exactly what I was looking for. Thank you!</p>",
        "id": 223551968,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611254319
    },
    {
        "content": "<p>Maybe I was a bit too enhousiastic, how does one use alist? I am trying to say that my <code>items</code> function returns an alist, but I cannot seem to construct it.</p>\n<p>I would expect this to work, but I see that the types are not entirely correct:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">items</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">alist</span> <span class=\"n\">γ</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">items</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Maybe I can phrase the question differently, how do I insert a key/value pair a\\-&gt;b into an alist <code>al</code>?</p>",
        "id": 223558676,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611257322
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.alist</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">map</span>\n<span class=\"bp\">|</span> <span class=\"n\">build</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">map</span><span class=\"o\">):</span> <span class=\"n\">map</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map_to_alist_keep</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">alist</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">map_to_alist_keep</span> <span class=\"n\">m</span>\n  <span class=\"k\">then</span> <span class=\"n\">map_to_alist_keep</span> <span class=\"n\">m</span>\n  <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">map_to_alist_keep</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map_to_alist_overwrite</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">alist</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">map_to_alist_overwrite</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 223560075,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611257953
    },
    {
        "content": "<p>Your <code>map</code> is isomorphic to <code>list (α × β)</code></p>",
        "id": 223560620,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611258178
    },
    {
        "content": "<p>Yes, that was the idea:) but that was before I knew of the existence of alist. But I now see me misreading the argument of alist. It is a function from \\a to the type \\b. Thank you again:)</p>",
        "id": 223560948,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611258319
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list_to_alist_keep</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">alist</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"n\">al</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">al</span> <span class=\"k\">then</span> <span class=\"n\">al</span> <span class=\"k\">else</span> <span class=\"n\">al.insert</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∅</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list_to_alist_overwrite</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">alist</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"n\">al</span><span class=\"o\">,</span> <span class=\"n\">al.insert</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∅</span>\n</code></pre></div>",
        "id": 223560966,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611258327
    },
    {
        "content": "<p>Yes, <code>alist</code> can be dependently typed on the value, based on the key. But in your case, they're independent.</p>",
        "id": 223561085,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611258376
    },
    {
        "content": "<p>(of course, foldr or foldl will depend on how you construct your list of tuples)</p>",
        "id": 223561111,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611258393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/A.20finite.20set.20of.20tuples.20with.20unique.20first.20element/near/223561085\">said</a>:</p>\n<blockquote>\n<p>Yes, <code>alist</code> can be dependently typed on the value, based on the key. But in your case, they're independent.</p>\n</blockquote>\n<p>Yes, I forgot that it can be dependently typed.</p>",
        "id": 223561345,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611258510
    },
    {
        "content": "<p>Is it correct that you cannot reason about the length of this alist? So, that probably means you have to use the underlying list I guess</p>",
        "id": 223561427,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611258554
    },
    {
        "content": "<p>I'm not sure what you are getting at - the length of the alist is <code>l.entries.length</code>, although there should be a function for that</p>",
        "id": 223567567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611261707
    },
    {
        "content": "<p>Hmm, there does not seem to be a function, but I can just use l.entries.length (sorry for the late reply, forgot to check Zulip)</p>",
        "id": 224236716,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611776480
    }
]
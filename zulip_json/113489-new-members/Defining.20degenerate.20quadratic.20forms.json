[
    {
        "content": "<p>I have a definition which needs a proof that a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_form\">docs#quadratic_form</a> is non-degenerate. While I can write that as <code>∀ m, Q m = 0 → m = 0</code>, it would be nice if I could write it as <code>¬Q.degenerate</code> (since we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_form.pos_def\">docs#quadratic_form.pos_def</a>).</p>\n<p>I tried to define <code>degenerate</code>, but the proof I needed to get back to the form that's actually useful is ugly </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.quadratic_form</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">degenerate</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A degenerate quadratic form is zero on some nonzero vectors. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">degenerate</span> <span class=\"o\">(</span><span class=\"n\">Q₂</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Q₂</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">non_degenerate_iff</span> <span class=\"o\">(</span><span class=\"n\">Q₂</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">degenerate</span> <span class=\"n\">Q₂</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Q₂</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">degenerate</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">forall_not_of_not_exists</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">mt</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"o\">},</span>  <span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"n\">what</span> <span class=\"n\">a</span> <span class=\"n\">mess</span><span class=\"bp\">!</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">quadratic_form.map_zero</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">ha</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hqx</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx</span> <span class=\"o\">((</span><span class=\"n\">ha</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hqx</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">degenerate</span>\n</code></pre></div>\n<p>Would it make more sense to define <code>non_degenerate</code>? It would make it much easier to use, but then <code>¬non_degenerate</code> is pretty ugly if that ever shows up.</p>\n<p>Can anyone suggest how to golf the mess above?</p>",
        "id": 217315724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605812899
    },
    {
        "content": "<p>My intuition says that it will be useful to define <code>nondegenerate</code> directly, yes.</p>",
        "id": 217315966,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605813024
    },
    {
        "content": "<p><code>push_neg</code> should help somehow</p>",
        "id": 217316005,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813046
    },
    {
        "content": "<p>It's a very common assumption. More common then assuming that something is degenerate.</p>",
        "id": 217316011,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605813051
    },
    {
        "content": "<p>Indeed - it just seems unfortunate to me to use <code>not</code> in a name when we already have a symbol for it</p>",
        "id": 217316037,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813071
    },
    {
        "content": "<p>Maybe we should call them <code>smooth</code>?</p>",
        "id": 217316159,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605813139
    },
    {
        "content": "<p><code>smooth</code> = <code>nonsingular</code> = <code>nondegenerate</code></p>",
        "id": 217316177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605813150
    },
    {
        "content": "<p>oh I see, part of the problem is you have an iff on the nondegenerate side</p>",
        "id": 217316179,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813151
    },
    {
        "content": "<p>I can remove that iff</p>",
        "id": 217316194,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813161
    },
    {
        "content": "<p>Since the reverse direction is obvious and holds for all <code>Q</code> anyway (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_form.map_zero\">docs#quadratic_form.map_zero</a>)</p>",
        "id": 217316204,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813165
    },
    {
        "content": "<p>I still think it's best to define <code>nondegenerate</code> with that name</p>",
        "id": 217316676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813324
    },
    {
        "content": "<p>compare <code>set.nonempty</code></p>",
        "id": 217316687,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813330
    },
    {
        "content": "<p>Well, presumably <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.empty\">docs#set.empty</a> is taken by ∅</p>",
        "id": 217316759,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813364
    },
    {
        "content": "<p>It's just a historical accident that things like nondegenerate and nonempty have the non- prefix while things like injective don't</p>",
        "id": 217316789,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813377
    },
    {
        "content": "<p>With an underscore to match <code>pos_def</code>?</p>",
        "id": 217316853,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813416
    },
    {
        "content": "<p>No, nondegenerate is one word, positive definite is two words</p>",
        "id": 217316920,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813447
    },
    {
        "content": "<p>Oh, I assumed it was <code>non-degenerate</code> vs <code>positive-definite</code></p>",
        "id": 217316944,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813462
    },
    {
        "content": "<p>Yeah, math English is weird <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 217317041,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813502
    },
    {
        "content": "<p>Wait, isn't my claim correct? The two random webpages I had open confirmed my spelling</p>",
        "id": 217317066,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813521
    },
    {
        "content": "<p>Or is it non-nonwerid?</p>",
        "id": 217317069,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605813524
    },
    {
        "content": "<p>+1 for <code>nondegenerate</code> btw</p>",
        "id": 217317090,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605813542
    },
    {
        "content": "<p>Never in my life have I ever assumed explicitly that a quadratic form was degenerate!</p>",
        "id": 217317130,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605813566
    },
    {
        "content": "<p>I think positive definite could have a hyphen but it would be weird in nondegenerate</p>",
        "id": 217317138,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605813569
    },
    {
        "content": "<p>Alright, will do that</p>",
        "id": 217317176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813593
    },
    {
        "content": "<p>I guess I should keep the lemma but in reverse?</p>",
        "id": 217317191,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813599
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A non-degenerate quadratic form is zero only on zero vectors. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">nondegenerate</span> <span class=\"o\">(</span><span class=\"n\">Q₂</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Q₂</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">not_nondegenerate_iff</span> <span class=\"o\">(</span><span class=\"n\">Q₂</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">nondegenerate</span> <span class=\"n\">Q₂</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Q₂</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">nondegenerate</span><span class=\"o\">,</span>\n  <span class=\"n\">push_neg</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hqx</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hqx</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hqx</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hqx</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 217317579,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813752
    },
    {
        "content": "<p>Thanks for the push_neg tip.</p>",
        "id": 217317641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605813777
    },
    {
        "content": "<p><del>(docstring is wrong)</del></p>",
        "id": 217317699,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605813800
    },
    {
        "content": "<p>Do you even need the split? Or will something like <code>simp only [and_comm]</code> close it after <code>push_neg</code>?</p>",
        "id": 217317934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605813901
    },
    {
        "content": "<p>should nondegenerate be a class?</p>",
        "id": 217318120,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605813977
    },
    {
        "content": "<p><code>simp only [and_comm, exists_prop]</code> does the trick</p>",
        "id": 217318203,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605814020
    },
    {
        "content": "<p>Since <code>pos_def</code> isn't, I'd say <code>nondegenerate</code> shouldn't be either</p>",
        "id": 217318535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605814166
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5045\">#5045</a></p>",
        "id": 217319371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605814483
    },
    {
        "content": "<p>Proving that <code>nondegenerate Q ↔ Q.discr ≠ 0</code> (given sufficient constraints for <code>discr</code> to exist) is an exercise left to the reviewer</p>",
        "id": 217319419,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605814503
    },
    {
        "content": "<p>Is this definitely the standard terminology?</p>\n<p>Ignoring characteristic 2 for simplicity, I would refer to a quadratic form as non-degenerate when its associated bilinear form is non-degenerate.</p>\n<p>E.g., I would say <code>Q(x, y) = x² - y²</code> is non-degenerate (in two dimensions) even though <code>Q(1, 1) = 0</code>.</p>",
        "id": 217389247,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1605871652
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>.  I would say that <code>nondegenerate</code> is the condition that the appropriate determinant does not vanish, while not having a non-trivial zero I would call <code>anisotropic</code>.</p>",
        "id": 217389524,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605871845
    },
    {
        "content": "<p>If I'm reading that correctly, is my claim <code>nondegenerate Q ↔ Q.discr ≠ 0</code> untrue in the current definition?</p>",
        "id": 217390058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605872222
    },
    {
        "content": "<p>Yes it's untrue.</p>",
        "id": 217390067,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605872232
    },
    {
        "content": "<p>Whoops</p>",
        "id": 217390107,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605872258
    },
    {
        "content": "<p>That's unfortunate, because my lemma  that needed <code>Q.nondegenerate</code>  is <del>probably harder to prove than I thought</del> also untrue for the case I had in mind</p>",
        "id": 217390668,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605872656
    },
    {
        "content": "<p>As Damiano says, the condition that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is nowhere-vanishing (except at zero) is called anisotropic and is far more subtle than being nondegenerate (for example it is not preserved if you change the base field: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">x^2+y^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> is anisotropic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> but not over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span>).</p>",
        "id": 217391163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605873036
    },
    {
        "content": "<p>My apologies for hitting the merge button too quickly <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 217391322,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605873130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Are you working on a PR that updates the terminology? If not, then I will do it.</p>",
        "id": 217391687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605873409
    },
    {
        "content": "<p>Please go ahead</p>",
        "id": 217391724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605873447
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5050\">#5050</a></p>",
        "id": 217392191,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605873771
    },
    {
        "content": "<p>Is the definition I should have used <code>∀ x, (∀ y, polar Q x y = 0) → x = 0</code>?</p>",
        "id": 217392528,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605874018
    },
    {
        "content": "<p>Is <code>polar Q</code> the associated bilinear form? There are subtleties in characteristic 2 which I am not really on top of, but away from char 2 if <code>polar Q x y = Q (x + y) - Q x - Q y</code> then what you posted is the definition of nondegenerate. In char 2, x^2 would be degenerate here because <code>polar Q</code> would be identically zero.</p>",
        "id": 217393545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605874710
    },
    {
        "content": "<p>My (poor) understanding of char 2 is that there are two words for bilinear forms (perhaps alternating and antisymmetric?) which are the same in general but have distinct meanings in char 2 (one implies the other), and perhaps it's the case that people don't really study quadratic forms at all in char 2?</p>",
        "id": 217393780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605874898
    },
    {
        "content": "<p><code>polar Q x y</code> is what you say it is</p>",
        "id": 217396023,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605876380
    },
    {
        "content": "<p>Which is _not_ the associated bilinear form, but twice it</p>",
        "id": 217396031,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605876389
    },
    {
        "content": "<p>A statement that works regardless of the characteristic is that the quadratic form is nondegenerate iff the corresponding quadric is smooth.  You can compute the singular locus using the jacobian criterion.  In turn, this means that the determinant of the hessian matrix must be nonzero <em>at all points where the quadratic form vanishes</em>.  In characteristic different from 2, it suffices to check non-vanishing of the determinant, thanks to Euler's identity.  In characteristic 2, the extra condition is needed.  However, it is all that needs to be checked.  This can be further computed explicitly: let me know if there is any reason for wanting to do this explicitly!</p>",
        "id": 217401863,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605879746
    },
    {
        "content": "<p>That definition sounds like a lot more work than the one I give above...</p>",
        "id": 217402094,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605879856
    },
    {
        "content": "<p>it is simply requiring a polynomial not to vanish.  I am not sure how hard it would be to implement this.  If determinants are available, you can compute the formula using cramer's rule</p>",
        "id": 217402172,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605879912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> What would you propose as Lean definition of <code>quadratic_form.nondegenerate</code>?</p>",
        "id": 217402180,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605879916
    },
    {
        "content": "<p>We have determinants and Cramer's rule</p>",
        "id": 217402213,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605879937
    },
    {
        "content": "<p>Not in characteristic 2 we don't, the conversion to matrix doesn't exist there</p>",
        "id": 217402310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605879973
    },
    {
        "content": "<p>Aah, snap</p>",
        "id": 217402360,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605880016
    },
    {
        "content": "<p>Ok, so here is what is true mathematically: if the dimension of the kernel of the hessian is at least 2, the quadratic form is degenerate always.  If the dimension of the kernel is at most one, then use cramer's rule to find a generator of the kernel, evaluate the quadratic form on this vector and check that you get a non-zero result</p>",
        "id": 217402394,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605880037
    },
    {
        "content": "<p>by hessian, i really mean the matrix of second derivatives.  explicitly, with <code>0</code> along the diagonal...</p>",
        "id": 217402455,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605880074
    },
    {
        "content": "<p>Are you perhaps describing <code>decidable Q.nondegenerate</code>?</p>",
        "id": 217402533,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605880115
    },
    {
        "content": "<p>very likely what i described is decidable, or should at least assume <code>classical</code>!</p>",
        "id": 217402579,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605880145
    },
    {
        "content": "<p>What you have sounds like an algorithm for determining if Q is degenerate</p>",
        "id": 217402608,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605880172
    },
    {
        "content": "<p>And less like a definition of degeneracy</p>",
        "id": 217402635,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605880190
    },
    {
        "content": "<p>my definition is that the vanishing set in <code>P^n</code> is smooth.  in turn, i can compute this via the method described</p>\n<p>so, i guess that my definition would be via smoothness, but this seems less accessible in lean than computing determinants</p>",
        "id": 217402764,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605880244
    },
    {
        "content": "<p>Oops! I should have looked at the definitions more carefully yesterday :(</p>\n<p>If you want a coordinate-free way to define nondegeneracy for a quadratic form, you can say that it's regular over every field extension of the base (it's enough to check it for an algebraic closure, but it's presumably easier to write down the definition with every field extension), where \"regular\" can be defined with a simple linear-algebraic condition in terms of the quadratic form and the associated polar form. But it seems that quadratic forms in mathlib are defined over arbitrary rings, not just fields, and I don't know what the correct definition is in general (without going into more complicated algebraic geometry).</p>",
        "id": 217410472,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884072
    },
    {
        "content": "<p>Working over a field, you only need to check it over purely inseparable extensions of degree a power of 2: when the characteristic is different from 2, the singular locus has a point over the algebraic closure iff it has a point over the ground field.</p>",
        "id": 217410850,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605884273
    },
    {
        "content": "<p>Sure, I agree. But it feels unnatural to <strong>define</strong> something by saying \"if the characteristic is 2, do this, and if not, then do that.\"</p>",
        "id": 217411043,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884367
    },
    {
        "content": "<p>I think it makes more sense to give a uniform definition at the start, and prove a theorem later saying that if the characteristic is not 2, then you can use a simpler condition, and if it's 2, use another condition</p>",
        "id": 217411169,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884410
    },
    {
        "content": "<p>Of course!  Although the statement \"check it over purely inseparable extensions of degree a power of 2\" was my hack for not separating cases!</p>",
        "id": 217411198,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605884419
    },
    {
        "content": "<p>Ah I see :) The type of purely inseparable extensions of degree 2 can be empty <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 217411256,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884447
    },
    {
        "content": "<p>rather than empty, just trivial!</p>",
        "id": 217411286,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605884461
    },
    {
        "content": "<p>Oh right, power of 2 :)</p>",
        "id": 217411342,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884481
    },
    {
        "content": "<p>(sorry, the ones of degree 2 can be empty: the ones of degree a power of two always contains one element)</p>",
        "id": 217411360,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605884490
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Do you know of a simple definition over an arbitrary ring? The only one I can think of is to work with the family of quadrics over spec of the base ring.</p>",
        "id": 217411558,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884585
    },
    {
        "content": "<p>(And to be honest I've never actually seen such a definition in the literature)</p>",
        "id": 217411684,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884639
    },
    {
        "content": "<p>Of course another option is that we can assume that the base ring is a field when defining <code>quadratic_form.nondegenerate</code>.</p>",
        "id": 217411944,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605884750
    },
    {
        "content": "<p>or maybe an integral domain?</p>",
        "id": 217412320,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605884898
    },
    {
        "content": "<p>I don't think it works over an arbitrary domain, you can have bad reduction at some primes</p>",
        "id": 217412392,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884930
    },
    {
        "content": "<p>Well... it depends on how you define it.</p>",
        "id": 217412413,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605884943
    },
    {
        "content": "<p>OK, I don't really know what I'm talking about, but it seems awkward to exclude the case of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span></p>",
        "id": 217412441,
        "sender_full_name": "Reid Barton",
        "timestamp": 1605884955
    },
    {
        "content": "<p>Yeah, I agree it would be nice to have a definition that works (At least) over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span></span></span></span></p>",
        "id": 217412883,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605885129
    },
    {
        "content": "<p>I think that as soon as you start wondering about quadratic forms over arbitrary rings, a little of language from algebraic geometry makes life much simpler.  I would say that the \"correct\" generalization is to use smoothness of the morphism to the base ring/scheme.  However, it is hard to find a quadratic form smooth over Z: the requirement becomes that the discriminant should be \"almost 1\" (you have some extra freedom coming from 2, of all places).  For instance, xy=0 is smooth in two variables over Z and you get \"for free\" that xy-z^2=0 is also smooth over Z.  You can construct further examples using E_8 in 8 or 9 dimensions, but integral, unimodular lattices are hard to come by.</p>",
        "id": 217413278,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605885294
    },
    {
        "content": "<p>it might be easier to say that a form over an integral domain is nondegenerate if it is so over the field of fractions and then think about revising this definition later on, once you really need to deduce properties of reductions modulo primes of the base ring</p>",
        "id": 217413542,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605885405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Defining.20degenerate.20quadratic.20forms/near/217413542\">said</a>:</p>\n<blockquote>\n<p>it might be easier to say that a form over an integral domain is nondegenerate if it is so over the field of fractions and then think about revising this definition later one, once you really need to deduce properties of reductions modulo primes of the base ring</p>\n</blockquote>\n<p>This should be more appropriately called \"generically nondegenerate\"</p>",
        "id": 217413600,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605885434
    },
    {
        "content": "<p>I agree, but it might be helpful to save the \"generically\" until you also have a \"specially\" in the picture!</p>",
        "id": 217413662,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605885467
    },
    {
        "content": "<p>for instance, even thinking about the hasse-minkowski theorem, it may not be too useful to have the \"special\" point of view.  certainly not for the statement, but possibly not even for the proof...</p>",
        "id": 217413837,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605885552
    },
    {
        "content": "<p>Wait.... I think the following is true: A quadratic form over a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is nondegenerate (in the correct sense) if its base-change with respect to every morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">A \\to K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is a field, is nondegenerate (or just regular)</p>",
        "id": 217413911,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605885598
    },
    {
        "content": "<p>i vote for \"nondegenerate\" to mean \"generically nondegenerate over an integral domain\".  once people really want to use quadratic forms over more general rings and really deal with reduction types, then they might want to start using different names, like smooth, conic/quadric bundle, brauer-severi variety,...</p>",
        "id": 217414084,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605885684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Defining.20degenerate.20quadratic.20forms/near/217413911\">said</a>:</p>\n<blockquote>\n<p>Wait.... I think the following is true: A quadratic form over a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is nondegenerate (in the correct sense) if its base-change with respect to every morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">A \\to K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is a field, is nondegenerate (or just regular)</p>\n</blockquote>\n<p>I believe that this can be proved using that smoothness is local on the base.  you can get away with regularity, since you allow field extensions, and geometrically regular means smooth.</p>",
        "id": 217414330,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605885800
    },
    {
        "content": "<p>It would be good if someone could capture this fruitful dialogue in a lean file <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 217414978,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605886106
    },
    {
        "content": "<p>All this just tells me that we really need more algebraic geometry in mathlib</p>",
        "id": 217414992,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605886114
    },
    {
        "content": "<p>(And PR the result to mathlib)</p>",
        "id": 217415001,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605886117
    },
    {
        "content": "<p>But we can't really start doing more AG if we don't have the definition of a flat module... that's what has been stopping me</p>",
        "id": 217415069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605886146
    },
    {
        "content": "<p>A more hands on approach to this issue is to compute the \"universal determinant\":</p>\n<p>det (hessian matrix)</p>\n<p>as a polynomial with integer coefficients.  Note that there are lots of 2's along the diagonal.  Remove the largest power of 2 that divides the polynomial above and define a form to be non-degenerate if this polynomial does not vanish when evaluated on the coefficients of the quadratic form.  does this seem like a reasonable point of view?</p>",
        "id": 217415101,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605886164
    },
    {
        "content": "<p>Does mathlib even have base-change of vectorspaces w.r.t. field extensions?</p>",
        "id": 217416226,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605886622
    },
    {
        "content": "<p>Not yet, see the base change PR <a href=\"https://github.com/leanprover-community/mathlib/issues/4773\">#4773</a></p>",
        "id": 217417129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605886999
    },
    {
        "content": "<p>Well, modulo the missing stuff about base-change (and some pseudocode), here is what I propose as a definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.quadratic_form</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">quadratic_form</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">radical</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"bp\">|</span> <span class=\"n\">Q</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">polar</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- nondegenerate Q := ∀ (L : field extensions of K), radical (base_change L Q) = ⊥</span>\n</code></pre></div>",
        "id": 217420637,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605888355
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> does this look right to you?</p>",
        "id": 217420785,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605888412
    },
    {
        "content": "<p>But when actually making this definition, we will need to quantify over all field extensions, and in particular over some types, so some universe annotations will be necessary as well..</p>",
        "id": 217421154,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605888592
    },
    {
        "content": "<p>Looks like the following is equivalent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.quadratic_form</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">quadratic_form</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">radical</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"bp\">|</span> <span class=\"n\">Q</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">polar</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polar_radical</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">polar</span> <span class=\"n\">Q</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nondegenerate</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">radical</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">vector_space.dim</span> <span class=\"o\">(</span><span class=\"n\">polar_radical</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 217422016,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605888868
    },
    {
        "content": "<p>Apparently quadratic forms in characteristic 2 <a href=\"https://en.wikipedia.org/wiki/Arf_invariant\">deserve their own theory</a>!</p>",
        "id": 217424001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1605889694
    },
    {
        "content": "<p>The equivalence with the second definition I mentioned above comes from a theorem in the book by Elman, Karpenko and Merkurjev. They do a lot with quadratic forms in arbitrary characteristic, whereas most texts tacitly assume characteristic not 2.</p>",
        "id": 217424441,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605889856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Defining.20degenerate.20quadratic.20forms/near/217420785\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> does this look right to you?</p>\n</blockquote>\n<p>If I understand this correctly, this means that you are requiring <code>m</code> to be a root of the quadratic form <em>and</em> in the kernel of the hessian matrix.  I would call this a correct definition of nondegenerate , once you extend to all extensions (or, alternatively, all purely inseparable extensions of degree a power of 2).</p>",
        "id": 217425214,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605890131
    },
    {
        "content": "<p>(being in the kernel of the hessian matrix implies the vanishing of <code>Q</code> over fields of characteristic different from 2, by Euler's identity.)</p>",
        "id": 217425420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605890186
    },
    {
        "content": "<p>I think with the second definition it's not required to extend the base.</p>",
        "id": 217425442,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605890194
    },
    {
        "content": "<p>See lemma 7.16 on page 43 here:<br>\n<a href=\"https://sites.ualberta.ca/~karpenko/publ/Kniga.pdf\">https://sites.ualberta.ca/~karpenko/publ/Kniga.pdf</a></p>",
        "id": 217425551,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605890233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Defining.20degenerate.20quadratic.20forms/near/217425551\">said</a>:</p>\n<blockquote>\n<p>See lemma 7.16 on page 43 here:<br>\n<a href=\"https://sites.ualberta.ca/~karpenko/publ/Kniga.pdf\">https://sites.ualberta.ca/~karpenko/publ/Kniga.pdf</a></p>\n</blockquote>\n<p>I agree that this is indeed equivalent!  This should be the argument with cramer's rule.</p>",
        "id": 217426027,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605890399
    },
    {
        "content": "<p>Alright, I should go back to writing notes for my class now :)</p>",
        "id": 217426341,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1605890516
    },
    {
        "content": "<p>thank you for the formalization!</p>",
        "id": 217426846,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605890709
    }
]
[
    {
        "content": "<p>hi all. I'm diving head first into Lean and would like to use it to assist in my math education. particularly, I want to get real handy with it for proofs and for programming applications. But I don't see the point in trying to pick up lean3 when lean4 is already in the milestone phase. So I'm diving into lean4. Unfortunately, it doesn't have a rational type yet, so I figured that some proficiency with lean will come if I attempt to construct them myself. I am using <a href=\"https://www.researchgate.net/publication/220367791_Simple_canonical_representation_of_rational_numbers\">this paper</a> as a model of how to construct canonical rationals with inductive types. It uses Coq, but the syntax is similar enough that I don't see why the model Bertot is using can't be adapted to Lean's syntax. In trying to do this ostensibly simple task, I'm seeing how bad the learning curve really is for my current level of knowledge. But I'm willing to chip away at it. I have some simple questions, that if I can't figure out I can hardly begin the work at all.</p>\n<p>One of the inductive types defined for an initial type, Qplus (strictly positive rationals) contains as one of its inductive type defs <a href=\"http://Qplus.one\">Qplus.one</a>, which represents unity in this system. The others are Qplus.num and Qplus.denom which are Qplus -&gt; Qplus types. The idea is that you chain together expressions using recursion to define unique expressions ('words') in Qplus that represent canonical quotients interpretable as expressions of p/q. Okay, so far so good. In the paper, it specifies a few different ways of constructing such expressions.  One involves a function <em>c(x) : Qplus -&gt; Qplus</em> (this is how I interpret its type, at least), which maps expressions in Qplus to other expressions in Qplus. Okay. So for <em>c(one)</em> we get one. That's simple enough. But then this function is intended, for example, to be able to specify for x &gt; 1 that we return <em>num c (x-1)</em>. Fine. But as far as I can tell lean has no idea what it means to do arithmetic involving expressions with Qplus, nor how to judge inequalities, because of course that's my job. So as far as I can tell I can't use this method. I thought about the idea of trying to define <a href=\"http://Qplus.one\">Qplus.one</a> as an expression of the ordered pair (1,1) <em>Nat x Nat</em>, and then translating expressions from Qplus so that I can tell lean how to handle cases where the arithmetic is identical to natural number arithmetic (I.e. <a href=\"http://Qplus.one\">Qplus.one</a> + <a href=\"http://Qplus.one\">Qplus.one</a> = 2, which is also (2,1) if we take Nat x Nat to be a valid representation of a quotient).</p>\n<p>I get some strange errors when I try to define a function like <em>Nat x Nat</em> -&gt; Qplus involving ConSort. So that tells me I'm just thinking about things the wrong way perhaps, and trying to take advantage of the defined natural number arithmetic might be the wrong approach. I guess my mental stumbling block here is that I'm used to recursive functions in traditional programming cases where the underlying number system and representation is already defined. So for example, in a factorial in C or the like, we can use the function call because at each call the function is returning elements of the total product which are each integers, while the argument eventually terminates when it returns 1 returning a completely defined product expression. This idea of recursion just isn't making any sense for me in lean, where its not easy to see just at what stage the definition of the expression is occurring. I have some sense that the uniqueness of the expression formed by these recursive types has to do with the unique signature of the compositions expressing them. I feel like I'm close to coming to grips with what I need to do, but I need some guidance on where to look or how to go about things.</p>",
        "id": 272459060,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645219301
    },
    {
        "content": "<p>Have you done the Natural Numbers Game? #NNG</p>",
        "id": 272461370,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645220561
    },
    {
        "content": "<p>That shows exactly how one might go about constructing a number system (in that case, naturals) from scratch, mathlib style</p>",
        "id": 272461420,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645220596
    },
    {
        "content": "<p>This is a very idiosyncratic way to define rationals; one natural way to define them is as a quotient but because quotients seem to get computer scientists all hot and bothered for some reason they come up with crazy ideas like this. The idiomatic and quick way to define the rationals in lean would just be as the localisation of the integers. But this isn't your question, and there's nothing stopping you formalising this idiosyncratic definition anyway.</p>\n<p>However, you don't say anything about your background, and you don't post any code, and hence your questions are basically impossible to answer right now. If you want to know how to make progress, show us what you've done -- and you might want to start another thread in the <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> stream because right now most people here are using lean 3 until the maths library is ported (and when it is, we'll have the rationals so won't have to make them ;-) )</p>",
        "id": 272462015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645220909
    },
    {
        "content": "<p>Yes, I've gotten fairly far in it which inspired me to take this on. But I feel like what I need to do in my project involves something fundamental which is already given to you when you begin the natural numbers game. I.e. \"import mynat.definition -- imports the natural numbers {0,1,2,3,4,...}.\"</p>",
        "id": 272462063,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645220946
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> my background is that I'm an amateur programmer, familiar with the traditional imperative languages C, Python, Java, etc. and to a lesser extent languages like Julia, and a current math undergrad (at Calc III level (i.e. beginnings of vector calculus, lin alg, multi-variable calc and so on)). I am currently working through the HoTT book and excited to pick up type theory. The Natural Numbers game convinced me that Lean is my best target to learn how to work with all of this practically. I don't have any code to post for this example because this is how far I've gotten:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Qplus</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span>\n<span class=\"bp\">|</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span> <span class=\"bp\">→</span> <span class=\"n\">Qplus</span>\n<span class=\"bp\">|</span> <span class=\"n\">denom</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span> <span class=\"bp\">→</span> <span class=\"n\">Qplus</span>\n</code></pre></div>\n<p>Even the most general direction as far as an approach would give me something to wrap my head around. I've done a lot of reading in the documentation in the Logic and Proof and Theorem Proving with Lean guides and I am catching hints of how I might need to think about it, but any guidance is well appreciated.</p>",
        "id": 272463207,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645221508
    },
    {
        "content": "<p>also <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> as an aside, thank you very much for your work in making #NNG and your general work in this community. This journey I'm on was started basically after encountering the game, it singlehandedly put me into firm contact with one the most exciting subjects I've had the pleasure to investigate in a long, long time. I look forward to bootstrapping myself to contribute alongside everyone here.</p>",
        "id": 272466559,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645223156
    },
    {
        "content": "<p>For those who didn't click through, <code>num</code> and <code>denom</code> don't stand for numerator and denominator; <code>num x</code> is <code>x + 1</code> and <code>denom x</code> is <code>x/(1+x)</code>. The theory of continued fractions shows pretty easily that this gives a bijection to the positive rationals, however <span class=\"user-mention\" data-user-id=\"475347\">@Lane Biocini</span> my feeling is that now defining addition and multiplication on this monstrosity is just the kind of thing which a computer scientist might get quite excited about but which is not something I'd like to sink time into without a good excuse, because I can define the positive naturals really easily by putting an equivalence relation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><msub><mi mathvariant=\"double-struck\">N</mi><mrow><mo>&gt;</mo><mn mathvariant=\"double-struck\">0</mn></mrow></msub><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N_{&gt;0}}^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0703em;vertical-align:-0.1774em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">&gt;</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8929em;\"><span style=\"top:-3.1418em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> and then addition and multiplication are extremely easy to define <em>assuming you've already defined them on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">N</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}_{&gt;0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8663em;vertical-align:-0.1774em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">&gt;</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span></span></span></span></em>.</p>",
        "id": 272473183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645227034
    },
    {
        "content": "<p>You've seen how much hard work it is defining them on the naturals, it looks ten times as hard to define them on this monstrosity representation of the positive rationals. Why not reuse the work? In a system like Lean where quotients are easy to manipulate there are many much easier ways to define a working copy of the rationals.</p>",
        "id": 272473383,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645227178
    },
    {
        "content": "<p>Also, don't go thinking that this is a <em>good</em> representation of rationals. Natural numbers are represented in unary here</p>",
        "id": 272489308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645241575
    },
    {
        "content": "<p>The fact that a tree representation of the positive rationals is possible is useful for some applications (I think this is the <a href=\"https://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree\">Stern–Brocot tree</a>) but Kevin is right that the arithmetic ops are horrible in this form</p>",
        "id": 272489493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645241786
    },
    {
        "content": "<p>hm, actually it's closer to the <a href=\"https://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree\">Calkin–Wilf tree</a> but it's not exactly that either. There are apparently quite a few variations on that concept that work</p>",
        "id": 272489623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645241954
    },
    {
        "content": "<p>well, regardless it has been a fun project to work on and I've made a lot of progress. I've learned a lot about Lean's syntax and inner workings in the process. Particularly I've been able to define inversion, constructions of Qplus instances from Nat x Nat, interpretation from Qplus instances to Nat x Nat, as well as quality of life code that defines coercions between Naturals and Qplus. arithmetic operations of addition and multiplication are also defined. So I can write something like (2/3 : Qplus) and I get the corresponding representation in a neat form</p>",
        "id": 272747745,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645489543
    },
    {
        "content": "<p>I've been having an issue with defining the order. Mainly, I expected that I would be able to use recursion to define a proposition that judges whether a given instance of Qplus is less than another.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">w'</span> <span class=\"o\">:</span> <span class=\"n\">Qword</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Qword</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">w'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">w'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.denom</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">w'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the compiler complains that the matching expression is supposed to be of type <code>Sort ?m</code>. This isn't an error I get on any other function that I define with a very similar recursive technique. Observe this function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mk_mod</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Qplus.one</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Qplus.num</span> <span class=\"o\">(</span><span class=\"n\">mk_mod</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">-</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Qplus.one</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Qplus.den</span> <span class=\"o\">(</span><span class=\"n\">mk_mod</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">interpret</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">w</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"n\">interpret</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">interpret</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">interpret</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"n\">interpret</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">interpret</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">interpret</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Both of these work just fine. Is this a special property of a def which returns Prop?</p>",
        "id": 272748301,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645490188
    },
    {
        "content": "<p>Whether or not this is the \"right\" way to implement rationals, it seems like a nice project, and I'm happy to have learned about this representation of positive rationals.  I didn't realize you could store continued fractions with positive terms like this.  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mi>a</mi></msup><msup><mi>D</mi><mi>b</mi></msup><msup><mi>N</mi><mi>c</mi></msup><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>=</mo><mi>a</mi><mo>+</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo>+</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo>+</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mo>…</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">N^a D^b N^c ... = a + 1/(b + 1/(c + 1/\\ldots))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mord\">...</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mclose\">))</span></span></span></span></p>\n<p>I've heard about Gosper's algorithms for arithmetic operations on continued fractions -- I was under the impression these weren't so horrible, but I've never seen running times.</p>",
        "id": 272748654,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645490598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"475347\">@Lane Biocini</span> It tends to be hard to debug errors without a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, something that we can paste into an editor and see an error for ourselves.</p>",
        "id": 272748854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645490814
    },
    {
        "content": "<p>I can guess what <code>Qplus</code> is, but I'm not sure about <code>Qword</code>.  If I assume it's a typo for <code>Qplus</code>, then after replacing it I get no errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Qplus</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span>\n<span class=\"bp\">|</span> <span class=\"n\">num</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">den</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">w'</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Qplus</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">w'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">w'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">w'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.one</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.num</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Qplus.den</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 272749042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645491022
    },
    {
        "content": "<p>wow <span class=\"user-mention\" data-user-id=\"371649\">@Kyle Williams</span> ! I've clearly been staring at this code for too long thank you so much</p>",
        "id": 272749274,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645491315
    },
    {
        "content": "<p>Now as it turns out, my error is now something along the lines of \"Failed to synthesize Decidable\". When I finish implementing all the parts of this paper I will be uploading to github</p>",
        "id": 272749655,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645491702
    },
    {
        "content": "<p>A stretch goal for me is to be able to define exact arithmetic on the Calkin-Wilf numbers, but at the very least I have working functions that allow me to both construct and interpret rational number representations in it to and from their integer quotient equivalents. A secondary goal for me is to be able to construct paths from Calkin-Wilf numbers to their equivalents in Stern-Brocot and vice versa, because there are many nice properties the latter has and the translation from one to the other is trivial.</p>\n<p>When I examine how the Rationals are constructed in mathlib, it uses a struct that includes the numerator, denominator, as well as two proofs that the denominator is non-zero and that both sides of the quotient are coprime. I see the wisdom in being able to carry out more efficient arithmetic on such integer representations. </p>\n<p>I would like to then expand my approach, and construct my library such that it serves as a collection of translations between these rational representations. I can construct a similar struct as is implemented in mathlib; the advantage, as I see it, of building support for these binary representations of the rationals is that the construction of a number in either the Stern-Brocot or Calkin-Wilf representations is itself a proof that they are reduced and defined expressions in Q, because there is a bijection that exists between all three representations and a quotient is reduced when it is constructed in either binary representation. So the struct would simply be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Rational</span> <span class=\"n\">where</span>\n  <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">Int</span>\n  <span class=\"n\">den</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"n\">BinaryRat</span>\n</code></pre></div>\n<p>Where in constructing it, one does math in integer form for arithmetic then constructs the binary representation which then supplies the values for numerator and denominator that are thereafter stored in the struct. For now I would focus on a chosen representative of BinaryRat, but eventually I would like to make a class which may be implemented by SternBrocot or CalkinWilk types.</p>",
        "id": 273124740,
        "sender_full_name": "Lane Biocini",
        "timestamp": 1645724977
    }
]
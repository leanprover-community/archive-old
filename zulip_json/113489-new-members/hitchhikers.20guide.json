[
    {
        "content": "<p>Some questions referring to <a href=\"https://raw.githubusercontent.com/blanchette/logical_verification_2020/master/hitchhikers_guide.pdf\">https://raw.githubusercontent.com/blanchette/logical_verification_2020/master/hitchhikers_guide.pdf</a></p>\n<p>On page 6: \"The local context gives the types of the variables in t that are not bound by any λ.\" Does variables in this statement refer to the formal definition of a variable given by the second rule below this statement?</p>\n<p>How does a variable get added to the local context? For instance, how did x : Z get added to the local context at the top of the example below? I don't see a rule for adding a variable to the local context. Do we just declare whatever variables of whatever type we want to be in the local context at the start like we do with hypotheses?</p>\n<p>On page 7: \"Given a type σ, the type inhabitation problem consists of finding an “inhabitant” of that type—i.e., a term of type σ\". Should the phrase \"given a fixed local context\" be added to this statement? Why can't we just declare a constant of the given type?</p>",
        "id": 207303432,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1597778423
    },
    {
        "content": "<p>The lam rule on page 6 shows how variables get added to the context (you read the rule from bottom to top)</p>",
        "id": 207304577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597779075
    },
    {
        "content": "<p>you usually construct derivation trees by starting with the statement of what you want to prove and the context you want to prove it in (usually initially empty), i.e. <code>|- ? : my theorem</code>, and then you work backwards applying rules, including the <code>lam</code> rule that adds a variable to the context. Eventually you get to a point where the thing you want to prove is in the context, and then the <code>var</code> rule allows you to deduce <code>..., x : A, ... |- x : A</code></p>",
        "id": 207304857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597779215
    },
    {
        "content": "<p>If you read rules from top to bottom, then the <code>var</code> rule appears to pull a context out of nowhere to prove <code>x : A</code>. The context is a set of assumptions, so this is fine</p>",
        "id": 207305060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597779306
    },
    {
        "content": "<p>depending on how you set things up, you can either require that the context is always valid, in which case the <code>var</code> rule would need a proof that <code>C</code> is a valid context, or you can only ensure this when adding variables (reading backwards), i.e. in the <code>lam</code> rule, in which case you would have a hypothesis <code>C |- A : Type</code> and <code>C, x : A |- e : B</code> yields <code>C |- (\\lam x : A, e) : A -&gt; B</code></p>",
        "id": 207305310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597779447
    },
    {
        "content": "<blockquote>\n<p>On page 7: \"Given a type σ, the type inhabitation problem consists of finding an “inhabitant” of that type—i.e., a term of type σ\". Should the phrase \"given a fixed local context\" be added to this statement?</p>\n</blockquote>\n<p>Yes, it is given a fixed local context, although WLOG you can assume the context is empty, by universally closing over all variables in the context.</p>\n<blockquote>\n<p>Why can't we just declare a constant of the given type?</p>\n</blockquote>\n<p>That is also known as adding an axiom. You can do it, but you have extended the system and now more things are provable</p>",
        "id": 207305611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597779578
    },
    {
        "content": "<p>I'm not sure how to read <code>C |- A : Type</code>? This is saying that <code>A</code> is a well formed type? And this is produced by going backwards from the lambda rule? Would there also be <code>C |- B : Type</code> then?</p>",
        "id": 207310293,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1597781714
    },
    {
        "content": "<p>\"Yes, it is given a fixed local context, although WLOG you can assume the context is empty, by universally closing over all variables in the context.\"<br>\nIf you are going backwards following steps 1 and 2 in the text, then you end up determining what the context needs to be for the type to be inhabited right?</p>",
        "id": 207311154,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1597782160
    },
    {
        "content": "<p>well generally the type is just given, i.e. the theorem statement</p>",
        "id": 207315273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597784203
    },
    {
        "content": "<p>and it should be a closed term, meaning it is valid in the empty context</p>",
        "id": 207315313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597784218
    },
    {
        "content": "<p><code>C |- A : Type</code> means that <code>A</code> is a type that can refer to variables in <code>C</code>. For example <code>A : Type, B : Type |- (A -&gt; B) -&gt; B : Type</code></p>",
        "id": 207315409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597784271
    },
    {
        "content": "<blockquote>\n<p>Would there also be <code>C |- B : Type</code> then?</p>\n</blockquote>\n<p>That also depends on how you set up the theory. It is often implied from <code>C, x : A |- e : B</code>. It should also be <code>C, x : A |- B : Type</code> btw, this is one of the things that makes dependent type theory dependent</p>",
        "id": 207315757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597784436
    },
    {
        "content": "<p>although in that case you would write <code>Pi x : A, B</code> instead of <code>A -&gt; B</code> for the type of the lambda</p>",
        "id": 207315832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597784480
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 207347351,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1597787876
    },
    {
        "content": "<p>I've clarified the text a bit based on Patrick's initial comments. (Patrick, I'd like to add your name to the acknowledgments, if you don't object.)</p>\n<p>Concerning your very first question, the answer is no. Variables are defined on p. 4, in italics. (What you see on p. 6 is a typing rule called \"Var\".) Concerning your second question, \"I don't see a rule for adding a variable to the local context\", well that's exactly what <code>Lam</code> does. On p. 7, what I had in mind was an empty context. I think that's how inhabitation is usually defined, and indeed if one isn't careful, one can say that every type is trivially inhabited, in some context.</p>",
        "id": 207510784,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1597921577
    },
    {
        "content": "<p>One more comment, perhaps as much to Mario as to Patrick: Our typing rules are deliberately simplistic and don't attempt to check that types are well typed. The whole section is about the simply typed fragment of DTT anyway, so we're following the HOL tradition of ignoring ill-formed (= ill-aried or undeclared) types altogether.</p>",
        "id": 207511227,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1597921964
    },
    {
        "content": "<p>Ah, yes I was aware of this, but realized during the explanation that I had to refer to concepts like <code>C |- A : Type</code> and <code>|- C ok</code> that weren't explained in the provided rules, so I ended up talking about some hybrid of STT and DTT which may have been more confusing. :/</p>",
        "id": 207550919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597944831
    },
    {
        "content": "<p>\"Patrick, I'd like to add your name to the acknowledgments, if you don't object.\" I have no objections, I'd be honored.</p>\n<p>Sorry, I was reading it from top to bottom instead of from bottom to top.</p>\n<p>\"if one isn't careful, one can say that every type is trivially inhabited, in some context.\" I think that is true? In the same sense that every proposition is trivially true under the right assumptions? If type inhabitation is usually defined as requiring an empty context, and you haven't already, would it help to add that to the text?</p>\n<p>An unrelated question: On page 27 we have: \"The eq.subst instance we use has ?a := a,?b := a’, and?p := (λx, f x b)\". Should it be \"?p := (λx, f a b = f x b)\"?</p>",
        "id": 207802564,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598236197
    },
    {
        "content": "<p>I think you are right about the last bit. That p looks like an argument to <code>congr_arg</code>, not <code>eq.subst</code></p>",
        "id": 207803109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598237191
    },
    {
        "content": "<p>Ok. Thank you.</p>",
        "id": 207803177,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598237376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/hitchhikers.20guide/near/207802564\">said</a>:</p>\n<blockquote>\n<p>An unrelated question: On page 27 we have: \"The eq.subst instance we use has ?a := a,?b := a’, and?p := (λx, f x b)\". Should it be \"?p := (λx, f a b = f x b)\"</p>\n</blockquote>\n<p>Yes, it should be <code>(λ x, f a b = f x b)</code>, as is also correctly substituted in the next line.</p>",
        "id": 207820863,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1598259585
    },
    {
        "content": "<p>I have committed a fix to the guide, thank you!</p>",
        "id": 207821934,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1598260341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/hitchhikers.20guide/near/207802564\">said</a>:</p>\n<blockquote>\n<p>If type inhabitation is usually defined as requiring an empty context, and you haven't already, would it help to add that to the text?</p>\n</blockquote>\n<p>I completely agree. I fixed that in the text last week as well. ;)</p>",
        "id": 207829832,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1598266596
    },
    {
        "content": "<p>On page 54, should fact 0 = 1?</p>",
        "id": 208294460,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598576866
    },
    {
        "content": "<p>Ha ha you're not the first person to fall for this :-)</p>",
        "id": 208312965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598599663
    },
    {
        "content": "<p>Yes and no</p>",
        "id": 208312980,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598599677
    },
    {
        "content": "<p>?</p>",
        "id": 208392569,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598647120
    },
    {
        "content": "<p>read more</p>",
        "id": 208392760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598647255
    },
    {
        "content": "<p>By the way, I recognized a name here: <a href=\"https://www.quantamagazine.org/how-close-are-computers-to-automating-mathematical-reasoning-20200827/\">https://www.quantamagazine.org/how-close-are-computers-to-automating-mathematical-reasoning-20200827/</a></p>",
        "id": 208392809,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598647288
    },
    {
        "content": "<p>I see, last paragraph.</p>",
        "id": 208393104,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598647466
    },
    {
        "content": "<p>On page 65, in the definition of <code>zip</code>, I was curious why it was <code>| (_ :: _)  [] := []</code> instead of <code>| _ [] := []</code>?</p>",
        "id": 208500488,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598815894
    },
    {
        "content": "<p>I see. I am guessing it is because <code>| _ []</code> allows for <code>| [] []</code> which is already an instance of the previous case and <code>| (_ :: _)  []</code> does not.</p>",
        "id": 208513049,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598836851
    },
    {
        "content": "<p>they are equivalent. You will have to ask Jasmin</p>",
        "id": 208513453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598837632
    },
    {
        "content": "<p>The answer is given on p. 67:</p>\n<blockquote>\n<p>In the definition of zip and in the proof of map_zip, we were careful to specify three nonoverlapping patterns. It is also possible to write equations with overlap- ping patterns, as in</p>\n</blockquote>\n<p>I know chat makes it attractive to ask questions or write comments immediately, but a case could be made for reading until the end of a subsection before doing so. ;)</p>",
        "id": 208604671,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1598902289
    },
    {
        "content": "<p>A few lines below:</p>\n<blockquote>\n<p>We generally recommend the latter, more explicit style, because it leads to fewer surprises, especially in proofs.</p>\n</blockquote>",
        "id": 208604736,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1598902322
    },
    {
        "content": "<p>I'm sorry, you're right.</p>",
        "id": 208623664,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1598913206
    },
    {
        "content": "<p>No worries. ;) I'm just warning you that I'm an old-fashioned author who expects his readers to keep on reading...</p>",
        "id": 208653041,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1598945591
    },
    {
        "content": "<p>I'm actually very happy when somebody, anybody, writes about the guide. I have no idea how many readers we have for it (10? 100? 1000?), how far they get, or what they think along the way.</p>",
        "id": 208653304,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1598945675
    },
    {
        "content": "<p>That is, apart from a few exceptions like you. Keep on reading, and keep on commenting (in that order I guess? ;)).</p>",
        "id": 208653384,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1598945710
    },
    {
        "content": "<p>A Jasmin, you must be some dinosaur from the last century. These days you have to package your story in 3-minute video clips on youtube.</p>",
        "id": 208653748,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598945893
    },
    {
        "content": "<p>What does 8791 mean?</p>",
        "id": 208849744,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599063394
    },
    {
        "content": "<p>Good question. I entered 1978 but Zulip decided to turn it around.</p>",
        "id": 208852607,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599064725
    },
    {
        "content": "<p>It's a reference to \"some dinosaur from the last century\".</p>",
        "id": 208852632,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599064735
    },
    {
        "content": "<p>Ah. Only one year older than me :)</p>",
        "id": 208852718,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599064771
    },
    {
        "content": "<p>I hope you're a Smashing Pumpkins fan then.</p>",
        "id": 208852771,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599064794
    },
    {
        "content": "<p>:)</p>",
        "id": 208852844,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599064810
    },
    {
        "content": "<p>Hey everyone, I’ve been reading over the guide and have been implementing the work under program semantics, such as big step and small step. I’ve implemented the state type as <code>def state := \\Pi (v : string), \\nat</code> . I tried <code>constant</code> first, and Lean reported errors when I used state in the definition of big step, such as <code>... : string -&gt; (state -&gt; \\nat) -&gt; stmt</code>. Does anyone have any advice about the differences in using keywords constant, def, and axiom?</p>",
        "id": 208973255,
        "sender_full_name": "Ian Riley",
        "timestamp": 1599142466
    },
    {
        "content": "<p>Hi! Indeed, it would not work if you use <code>constant state : Type</code>, for the reason that a constant creates a new, unspecified, term of a given type which is a priori different from the other values of that type.</p>",
        "id": 208981162,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599145491
    },
    {
        "content": "<p>When you write <code>def state := \\Pi (v : string), \\nat</code>, then Lean will remember the definition of <code>state</code>. So when it typechecks for example <code>λ x, 0 : state</code>, it will unfold the definition of <code>state</code>, and to get <code>λ x, 0 : string -&gt; nat</code>, which does typecheck. If <code>state</code> was a constant, it does not know how to unfold and it gives up with an error.</p>",
        "id": 208981282,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599145550
    },
    {
        "content": "<p>There is a short discussion about <code>axiom</code> and <code>constant</code> when they are introduced in section 1.4 in the Guide.</p>",
        "id": 208982269,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599145939
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> . That helps a lot actually,</p>",
        "id": 208996234,
        "sender_full_name": "Ian Riley",
        "timestamp": 1599151370
    },
    {
        "content": "<p>In the guide, it provides an inductive type for aexp. How would I define a function to reduce <code>(aexp.var “x”)</code> to “x”?</p>",
        "id": 209036801,
        "sender_full_name": "Ian Riley",
        "timestamp": 1599172108
    },
    {
        "content": "<p>And also how to define the notation such that <code>s{x -&gt; n}</code> := (lambda ...)</p>",
        "id": 209043733,
        "sender_full_name": "Ian Riley",
        "timestamp": 1599178570
    },
    {
        "content": "<p>What do you want things other than <code>aexp.var</code> to reduce to?</p>",
        "id": 209044008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599178899
    },
    {
        "content": "<p>It might help to post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with your work since it serves as a useful framing device</p>",
        "id": 209044083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599178941
    },
    {
        "content": "<p>I'm not sure exactly what you mean by <code>s{x -&gt; n}</code>, but I would guess it is something like <code>function.update</code>, that is, <code>s{x -&gt; n} y := if x = y then n else s y</code></p>",
        "id": 209044136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599179001
    },
    {
        "content": "<p>To make sure I understand. We have to do this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>and cannot do this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">vec</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">vec</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>because we need to use different terms of type ℕ in the definition?</p>",
        "id": 209131950,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599247366
    },
    {
        "content": "<p>yes</p>",
        "id": 209132390,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599247680
    },
    {
        "content": "<p>Thank you. What does the <code>{}</code> refer to after <code>nil</code>? It seems to still compile without it.</p>",
        "id": 209132687,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599247863
    },
    {
        "content": "<p>Does it just mean all the arguments are implied?</p>",
        "id": 209132826,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599247960
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 209139374,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599252575
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 209139467,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599252613
    },
    {
        "content": "<p>I have another question related to inductive types. Let's say that we have the following inductive type</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">aexp</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">aexp</span>\n<span class=\"bp\">|</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"n\">int</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">aexp</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">aexp</span>\n</code></pre></div>\n\n\n<p>We would like to show</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>without having to define add and equality for aexp. How would that be done?</p>",
        "id": 209142146,
        "sender_full_name": "Ian Riley",
        "timestamp": 1599254334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/hitchhikers.20guide/near/209132826\">said</a>:</p>\n<blockquote>\n<p>Does it just mean all the arguments are implied?</p>\n</blockquote>\n<p>See p. 67.</p>",
        "id": 209142287,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599254430
    },
    {
        "content": "<p>This time I did read it, I just forgot it and couldn't find it again :) Does not putting <code>{}</code> in default to <code>{}</code>?</p>",
        "id": 209142479,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599254624
    },
    {
        "content": "<p><code>#print</code> shows the same result for both.</p>",
        "id": 209142547,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599254655
    },
    {
        "content": "<p>I'm pretty sure it's different but I can't check now.</p>",
        "id": 209142630,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599254727
    },
    {
        "content": "<p>No problem, not important, just curious. Thank you.</p>",
        "id": 209142651,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599254752
    },
    {
        "content": "<p>I'd think without <code>{}</code> you'd have to write <code>tree.empty nat</code> instead of <code>tree.empty</code>, etc.</p>",
        "id": 209143930,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599255910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"335850\">Ian Riley</span> <a href=\"#narrow/stream/113489-new-members/topic/hitchhikers.20guide/near/209142146\">said</a>:</p>\n<blockquote>\n<p>We would like to show</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>without having to define add and equality for aexp. How would that be done?</p>\n</blockquote>\n<p>The only way I can think of is just  splitting the definition of addition into  a coercion to nat/int and making a has_add instance. But it would be easier to just define addition for the whole type. For example, if I wanted to use integer addition I would write </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">to_int</span> <span class=\"o\">:</span> <span class=\"n\">aexp</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">aexp</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">to_int</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">to_int</span> <span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">aexp</span><span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"mi\">6</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 209152670,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1599265933
    },
    {
        "content": "<p>In the game of tennis on page 75, is it correct that the defined inductive predicate terminates at <code>adv.srv</code> and <code>adv.rcv</code>? That is, it does not allow for returns to 40-40 or advances to <code>game.srv</code> and <code>game.rcv</code> as described in the informal rules?</p>",
        "id": 209808103,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599844110
    },
    {
        "content": "<p>Is there a way to change the number in the browser tab to only reflect selected topics?</p>",
        "id": 209813941,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599847019
    },
    {
        "content": "<p>You mean in zulip? I guess you can \"unsubscribe\" from certain streams.</p>",
        "id": 209826537,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599853520
    },
    {
        "content": "<p>Yeah in Zulip. I was hoping there might be an option I wasn't seeing.</p>",
        "id": 209826791,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599853627
    },
    {
        "content": "<p>You can also mute streams or topics--I think this would affect the unread count but I haven't tried it</p>",
        "id": 209826874,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599853680
    },
    {
        "content": "<p>It's not quite what I was hoping for, but it helps. Thank you.</p>",
        "id": 209828767,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599854704
    },
    {
        "content": "<p>(If you don't mind the number in your browser tab being a bit larger, you can subscribe to the zulip meta stream too...)</p>",
        "id": 209829305,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599855036
    },
    {
        "content": "<p>Looks like it has already been brought up in the meta.</p>",
        "id": 209838366,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1599860317
    },
    {
        "content": "<p>Chapter 3 introduces the <code>fix</code> proof command. The Lean version I am using does not recognize this command. It seems that it is the same of <code>assume</code>. Does anyone know the origin of this command in the hitchhikers guide?</p>",
        "id": 209911918,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1599968454
    },
    {
        "content": "<p>It was a conscious choice on Jasmin's part</p>",
        "id": 209912457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599969603
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60/near/194764067\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60/near/194764067</a></p>",
        "id": 209912477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599969652
    },
    {
        "content": "<p>In the next edition of the guide, this will be more clearly identified as a private extension.</p>",
        "id": 209920739,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599986448
    },
    {
        "content": "<p>The guide was designed for in-class use, not as a Lean tutorial. I never expected it would be so popular as a tutorial.</p>",
        "id": 209920802,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1599986558
    },
    {
        "content": "<p>It is a very nice material, thank you for making it. But how do you define <code>fix</code>? Do you have any list of definitions besides <code>fix</code> that you share with students?</p>",
        "id": 209933972,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1600007288
    },
    {
        "content": "<p><code>fix</code> is just a synonym for <code>\\lam</code> or <code>assume</code> in standard lean</p>",
        "id": 209933999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600007385
    },
    {
        "content": "<p>It's called LoVelib. See footnote 3 in the preface for a URL.</p>",
        "id": 209938220,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1600013855
    },
    {
        "content": "<p>We do:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">list_of_vec</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">vec</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">list_of_vec</span> <span class=\"n\">v</span>\n</code></pre></div>\n\n\n<p>instead of</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">list_of_vec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">},</span> <span class=\"n\">vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">vec</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">list_of_vec</span> <span class=\"n\">v</span>\n</code></pre></div>\n\n\n<p>because <code>α</code> is a type and not a term?</p>",
        "id": 209958043,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600046131
    },
    {
        "content": "<p>No, it is because <code>α</code> is a parameter of the recursion</p>",
        "id": 209958399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600046864
    },
    {
        "content": "<p>Also the second version would need an extra underscore in the patterns</p>",
        "id": 209958441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600046895
    },
    {
        "content": "<p>Oh. Ok.</p>",
        "id": 209958575,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600047161
    },
    {
        "content": "<p>What precisely are the rules for figuring out what you are matching against based on the type? Everything after the <code>:</code>?</p>",
        "id": 209958627,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600047255
    },
    {
        "content": "<p>Yes, there is one argument to be matched for every pi/arrow after the colon</p>",
        "id": 209972242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600068416
    },
    {
        "content": "<p>See p. 15 of HG.</p>",
        "id": 209974756,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1600070418
    },
    {
        "content": "<p>On page 75:<br>\n\"In contrast, the inductive definition guarantees that we obtain the least (i.e., the most false) predicate that satisfies the introduction rules even.zero and even.add_two , and provides elimination and induction principles that allow us to prove ¬ even 1 , ¬ even 17 , or ¬ even (2 * n + 1) .\"<br>\nIs there a way in Lean to see all the rules and principles that are generated?</p>",
        "id": 210055948,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600113792
    },
    {
        "content": "<p>Probably <code>#print prefix even</code></p>",
        "id": 210058519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600115212
    },
    {
        "content": "<p>I think that just shows the declared constructors?</p>",
        "id": 210059327,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600115637
    },
    {
        "content": "<p>Is there an example of proving something like ¬ even 1?</p>",
        "id": 210075945,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600126900
    },
    {
        "content": "<p>Or <code>0 = 1 → false</code>?</p>",
        "id": 210083526,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600135011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/hitchhikers.20guide/near/210075945\">said</a>:</p>\n<blockquote>\n<p>Is there an example of proving something like ¬ even 1 without tactics?</p>\n</blockquote>\n<p>Maybe it's a little disappointing, but this works:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">add_two</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">even</span> <span class=\"mi\">1</span>\n<span class=\"bp\">.</span>\n</code></pre></div>\n\n\n<p>The dot means \"no more patterns\" for the equation compiler.  Somehow it knows <code>even 1</code> cannot be constructed.  This is the term mode proof that the equation compiler generates:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">dcases_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">a_1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a_k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_a</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">a_k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a_k</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">),</span>\n       <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">a_1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a_k</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">),</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"n\">a_1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">heq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>(I changed <code>example</code> to <code>lemma foo</code> then did <code>#print foo</code>.)</p>",
        "id": 210084839,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600136819
    },
    {
        "content": "<p>Hmm. Ok. Are inductive data types defined in lambda calculus or are they something that functional programming languages tack on somehow?</p>",
        "id": 210085768,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600138164
    },
    {
        "content": "<p>Everything is encoded as a function I guess? So an inductive data type must be encoded as a function?</p>",
        "id": 210086198,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600138836
    },
    {
        "content": "<p>Is there a way to see that function?</p>",
        "id": 210086228,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600138891
    },
    {
        "content": "<p>Like <code>and</code> reduces to <code>lx.ly.xyx</code>?</p>",
        "id": 210086420,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600139139
    },
    {
        "content": "<p>Inductive types are primitive, they are not defined as anything, they are constants, with rules (constructors, recursors, computation rules) postulated for them.</p>",
        "id": 210086782,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1600139715
    },
    {
        "content": "<p>See Mario's thesis for the precise rules: <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>",
        "id": 210086866,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1600139871
    },
    {
        "content": "<p>It appears to be over my head at present, but thank you.</p>",
        "id": 210087549,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600140951
    },
    {
        "content": "<p>A much better introduction is <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html\">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html</a></p>",
        "id": 210088681,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1600142795
    },
    {
        "content": "<p>Are definitions like <code>and = lx.ly.xyx</code> used at any level or are they replaced by other methods in languages like Lean? Because honestly those definitions are pretty cool :)</p>",
        "id": 210191597,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600204452
    },
    {
        "content": "<p>In lean <code>bool</code> is an inductive type in lean with two constructors, <code>tt</code> and <code>ff</code>, so any term you construct of bool is one of the two, and then boolean functions can just be defined by matching against those constructors. As we have types its not necessary to encode everything as a function in some clever way to get the desired behaviour, as Floris says inductive types themselves are a primitive notion. Its like how in set theory naturals can be encoded via von Neumann ordinals as sets of sets, but in type theories such as lean's we can make an inductive type to represent naturals instead of having to define everything as a set.</p>",
        "id": 210195330,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1600206474
    },
    {
        "content": "<p>I see. Thank you.</p>",
        "id": 210195529,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1600206572
    },
    {
        "content": "<p>I'm not sure if <code>tactic.any_goals</code> was changed since the book was written, but  when trying to typecheck the first custom tactic example </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">add_two</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">intro_and_even</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">),</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">any_goals</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">solve1</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">repeat</span>\n    <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">even</span><span class=\"bp\">.</span><span class=\"n\">add_two</span>\n     <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">even</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)))</span>\n</code></pre></div>\n\n\n<p>it seems the return type is <code> tactic (list (option unit))</code> rather than <code>tactic unit</code>. Is there a way to get this to the  type <code>tactic unit</code>? (Just starting to learn metaprogramming now)</p>",
        "id": 210303251,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1600281869
    },
    {
        "content": "<p>By the way, I've found the HG to be a very useful supplement to TPiL, so my thanks to the authors!</p>",
        "id": 210303980,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1600282226
    },
    {
        "content": "<p>You can put</p>\n<div class=\"codehilite\"><pre><span></span><code>     <span class=\"n\">return</span> <span class=\"bp\">⟨⟩</span>\n</code></pre></div>\n\n\n<p>on a newline after any_goals</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">intro_and_even</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">),</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">any_goals</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">solve1</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">repeat</span>\n    <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">even</span><span class=\"bp\">.</span><span class=\"n\">add_two</span>\n     <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">even</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">))),</span>\n     <span class=\"n\">return</span> <span class=\"bp\">⟨⟩</span>\n</code></pre></div>\n\n\n<p>to get the right type</p>",
        "id": 210304452,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1600282456
    },
    {
        "content": "<p>The typical way to throw out a result it to write <code>&gt;&gt; skip</code> after a tactic. In this case, you can do</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">intro_and_even</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">),</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">any_goals</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">solve1</span> <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">repeat</span>\n    <span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">even</span><span class=\"bp\">.</span><span class=\"n\">add_two</span>\n     <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">applyc</span> <span class=\"bp\">``</span><span class=\"n\">even</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">))),</span>\n  <span class=\"n\">skip</span>\n</code></pre></div>",
        "id": 210304458,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1600282461
    },
    {
        "content": "<p>(Alex's suggestion is basically the same, since <code>skip</code> is defined to be <code>return ⟨⟩</code>)</p>",
        "id": 210304560,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1600282532
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 210304668,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1600282584
    },
    {
        "content": "<p>Although my using angle braces instead of brackets is a bit idiosyncratic I guess!</p>",
        "id": 210304747,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1600282633
    },
    {
        "content": "<p><code>return ()</code> is used in mathlib way more often.</p>",
        "id": 210304778,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1600282658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319223\">Logan Murphy</span> <a href=\"#narrow/stream/113489-new-members/topic/hitchhikers.20guide/near/210303251\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if <code>tactic.any_goals</code> was changed since the book was written</p>\n</blockquote>\n<p>It has. We've updated our private version of the book but have yet to update the PDF. Expect a new version within one month or so, in time for my course.</p>",
        "id": 210364230,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1600333289
    }
]
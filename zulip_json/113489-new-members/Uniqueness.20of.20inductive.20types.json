[
    {
        "content": "<p>Given two definitions of inductive types, can we prove that the types are distinct? For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk1</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk1</span> <span class=\"o\">:</span> <span class=\"n\">B</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk2</span> <span class=\"o\">:</span> <span class=\"n\">B</span>\n</code></pre></div>\n<p>Can we always prove something like <code>lemma a_ne_b : A ≠ B</code>? In this particular case it can be proved using heterogeneous equality, because they have different cardinalities. But is it possible in general?</p>",
        "id": 261508535,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1636988645
    },
    {
        "content": "<p>You can only prove it if they have different cardinalities</p>",
        "id": 261508996,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636988839
    },
    {
        "content": "<p>The mental model I have is that Lean is only promising that it's able to implement the type for you in some way.  Since everything is typechecked, elements don't need to know what type they're from, so in principle it could reuse representations between different types.</p>\n<p>For example, it wouldn't be wrong for Lean to take</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">my_list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">my_list</span> <span class=\"bp\">→</span> <span class=\"n\">my_list</span>\n</code></pre></div>\n<p>and compile it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_list.nil</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">list.nil</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_list.cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">list.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_list.rec</span> <span class=\"bp\">...</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>Lean only lets you prove things that are independent of how it might be implementing things behind the scenes, which is why <code>list α = my_list α</code> is neither provable nor disprovable.</p>",
        "id": 261520984,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636993363
    },
    {
        "content": "<p>Also, it turns out that even if the arguments to a type constructor are different, the resulting types might be the same.  In fact, there must be cases where this happens by a diagonalization argument: <a href=\"#narrow/stream/113489-new-members/topic/disjointness.20of.20inductive.20type.20constructors.2C.20heq/near/204877510\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/disjointness.20of.20inductive.20type.20constructors.2C.20heq/near/204877510</a></p>",
        "id": 261521850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636993697
    },
    {
        "content": "<p>Could we prove a weaker relation between <code>list</code> and <code>my_list</code> in this case?  Is there a suitable notion of isomorphism or equivalence?</p>",
        "id": 261525507,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1636995283
    },
    {
        "content": "<p>You could create an <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv\">docs#equiv</a> and show it carries <code>my_list.nil</code> to <code>list.nil</code> and <code>my_list.cons</code> to <code>list.cons</code> (i.e., show it's an isomorphism)</p>",
        "id": 261527140,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636995965
    },
    {
        "content": "<p>Ok.  And since we don't have univalence we couldn't derive from this isomorphism that they're equal.  :)</p>",
        "id": 261527590,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1636996155
    },
    {
        "content": "<p>Just to be completely explicit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">my_list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">my_list</span> <span class=\"bp\">→</span> <span class=\"n\">my_list</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_list.to_list</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">my_list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">list.nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">my_list.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs.to_list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list.to_my_list</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">my_list.nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">list.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">my_list.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs.to_my_list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_list_equiv</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">my_list.to_list</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">list.to_my_list</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">my_list_equiv.nil</span> <span class=\"o\">:</span> <span class=\"n\">my_list_equiv</span> <span class=\"o\">(</span><span class=\"n\">my_list.nil</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">list.nil</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">my_list_equiv.cons</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">my_list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_list_equiv</span> <span class=\"o\">(</span><span class=\"n\">my_list.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">list.cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">my_list_equiv</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Forgetting the definition of `my_list_equiv`, similar lemmas for `my_list_equiv.symm` follow.</span>\n</code></pre></div>",
        "id": 261528043,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636996334
    }
]
[
    {
        "content": "<p>I'm working on this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span><span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">domain</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">codomain</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">β</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span>  <span class=\"n\">β</span> <span class=\"n\">domain</span> <span class=\"n\">codomain</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I am trying to say that a random variable is a measurable function from a probability space to a measurable space.  Even though the function is declared α → β and I have proofs that <code>domain</code> is a <code>probability_space</code> and <code>codomain</code> is a <code>measurable_space</code>, I still guess that I need to add a proof that <code>outcome</code> is a measurable function.  Or is it obvious?  I'm unsure.</p>\n<p>Anyway, if I do have to do the extra step of proving that <code>outcome</code> is <code>measurable</code>, I need to get this type right:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">α</span>  <span class=\"n\">β</span> <span class=\"n\">domain</span> <span class=\"n\">codomain</span> <span class=\"n\">outcome</span>\n</code></pre></div>\n<p>However, it is complaining</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">measurable</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">domain</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">probability_space</span> <span class=\"n\">α</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">measurable_space</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>even though</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">measure_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>How do I tell Lean that a subclass is a kind of the superclass?</p>",
        "id": 220269994,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608224238
    },
    {
        "content": "<p>I would use something approximately like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span><span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 220271001,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608224657
    },
    {
        "content": "<p>Thanks!  Why <code>structure</code> and not <code>class</code> in this case?  <code>random_variable</code> is a class of function, it seems possible people might want to create instances.</p>",
        "id": 220271258,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608224785
    },
    {
        "content": "<p>This is more sensible yes, but also in the original formulation you can just write <code>is_measurable_outcome : measurable outcome</code>--if you don't try to do Lean's work for it, it will do it correctly.</p>",
        "id": 220271292,
        "sender_full_name": "Reid Barton",
        "timestamp": 1608224803
    },
    {
        "content": "<p>Oh it looks like <code>measurable</code> is not a class, so I should use regular parens. (fixed code)</p>",
        "id": 220271512,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608224914
    },
    {
        "content": "<p>Does mathlib have bundled measurable functions?</p>",
        "id": 220271785,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608225042
    },
    {
        "content": "<p>Please help me take it a little further.  To the random variable I want to add an inverse.  So if <code>X(ω)</code> is a random variable, then<br>\n<code>inverse(y) = {ω : X(ω) = y}</code>.   I tried this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inverse</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">outcome</span> <span class=\"n\">ω</span> <span class=\"o\">})</span> <span class=\"bp\">//</span> <span class=\"n\">ERROR</span>\n</code></pre></div>\n<p>I got this error message, which I don't know how to fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"k\">let</span><span class=\"bp\">-</span><span class=\"n\">expression</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">outcome</span> <span class=\"n\">ω</span><span class=\"o\">}</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span> <span class=\"bp\">?</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>From there I want to do this, to say that the distribution space is a probability space induced by <code>X</code> with probability measure <code>volumeX : β→ [0,1]</code> such that <code>volumeX = volume  ∘ (X^-1)</code> is the <a href=\"https://en.wikipedia.org/wiki/Pushforward_measure\">pushforward measure</a> and <code>volumeX</code> is called the distribution of <code>X</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">distribution_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span><span class=\"n\">AP</span><span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">α</span> <span class=\"o\">):</span>  <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"n\">AP.volume</span> <span class=\"bp\">∘</span> <span class=\"n\">V.generalize_inverse</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm not sure how to get this all right in Lean, but the ideas are there.</p>\n<p>\"pushforward\"  sounds categorical.  If there were a category <code>Prob</code> there may be some categorical  way to express what I'm trying to do here.  I don't know category theory though.  For now I'm just trying to get this part right.</p>",
        "id": 220277921,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608227513
    },
    {
        "content": "<p>OK I found something in the guts of <code>measure_space</code> but it doesn't show up in  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pushforward\">docs#pushforward</a>  for in Lean which is all category theory related:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The pushforward of a measure. It is defined to be `0` if `f` is not a measurable function. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ennreal</span><span class=\"o\">]</span> <span class=\"n\">measure</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span> <span class=\"k\">then</span>\n  <span class=\"n\">lift_linear</span> <span class=\"o\">(</span><span class=\"n\">outer_measure.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">μ</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">le_to_outer_measure_caratheodory</span> <span class=\"n\">μ</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">hs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 220287424,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608232073
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X.outcome</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">X.is_measurable_outcome</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">probability_space.is_probability_measure.measure_univ</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>One thing to note, as we discussed somewhere before, one should really make an API for <code>probability_space</code> so that the proof in <code>is_probability_measure</code> becomes essentially a one-liner.</p>",
        "id": 220296608,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608236417
    },
    {
        "content": "<p>The structure <code>random_variable</code> needs an API as well.</p>",
        "id": 220296691,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608236465
    },
    {
        "content": "<p>But I hope the code above helps you get started :)</p>",
        "id": 220296724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608236480
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> that is extremely helpful.  I have been looking at the API of  <code>measure.map</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"kd\">variable</span> <span class=\"n\">MS1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span>\n<span class=\"kd\">variable</span> <span class=\"n\">MS2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">β</span>\n<span class=\"kd\">variable</span> <span class=\"n\">μ_α</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"kd\">variable</span> <span class=\"n\">m_α</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">measure_theory.measure.map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">MS1</span> <span class=\"n\">MS2</span> <span class=\"n\">μ_α</span> <span class=\"n\">m_α</span>\n<span class=\"k\">#check</span> <span class=\"n\">measure_theory.measure.map</span> <span class=\"n\">μ_α</span> <span class=\"n\">m_α</span>\n</code></pre></div>\n<p>This is the pushforward measure in Wikipedia: <a href=\"https://en.wikipedia.org/wiki/Pushforward_measure\">https://en.wikipedia.org/wiki/Pushforward_measure</a></p>\n<p>There is also a <code>comap</code> in <code>measure_space</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Pullback of a `measure`. If `f` sends each `measurable` set to a `measurable` set, then for each</span>\n<span class=\"sd\">measurable set `s` we have `comap f μ s = μ (f '' s)`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">β</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ennreal</span><span class=\"o\">]</span> <span class=\"n\">measure</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>What are the aesthetics of calling these <code>map</code> and <code>comap</code> versus <code>pushforward</code> and <code>pullback</code>?  This would provide a conceptual link to various pushforward definitions in <code>Top</code>and <code>category_theory</code>: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pushforward\">docs#pushforward</a>.  I'm just asking, pure curiosity, not a criticism.</p>",
        "id": 220300706,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608238334
    },
    {
        "content": "<p>Here is the last bit I want to get to before thinking about the overall API.  Please take a look at <a href=\"http://www.columbia.edu/~md3405/DT_Risk_2_15.pdf\">Definition 7</a>:</p>\n<p><a href=\"/user_uploads/3121/Ie07uINmXJry5GnERH22y-wz/Screenshot-from-2020-12-17-18-23-57.png\">Screenshot-from-2020-12-17-18-23-57.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Ie07uINmXJry5GnERH22y-wz/Screenshot-from-2020-12-17-18-23-57.png\" title=\"Screenshot-from-2020-12-17-18-23-57.png\"><img src=\"/user_uploads/3121/Ie07uINmXJry5GnERH22y-wz/Screenshot-from-2020-12-17-18-23-57.png\"></a></div>",
        "id": 220317646,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608247492
    },
    {
        "content": "<p>Now take a look at <a href=\"https://smile.amazon.com/Numerical-Solution-Computer-Experiments-Universitext/dp/3540570748/ref=sr_1_1?dchild=1&amp;keywords=numerical+solution+of+sde+with+computer&amp;qid=1608247382&amp;sr=8-1\">section 1.1 B</a>:<br>\n<a href=\"/user_uploads/3121/xNqyyQoq3m2Aoh-L1AEJOOtm/Screenshot-from-2020-12-17-18-24-10.png\">Screenshot-from-2020-12-17-18-24-10.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/xNqyyQoq3m2Aoh-L1AEJOOtm/Screenshot-from-2020-12-17-18-24-10.png\" title=\"Screenshot-from-2020-12-17-18-24-10.png\"><img src=\"/user_uploads/3121/xNqyyQoq3m2Aoh-L1AEJOOtm/Screenshot-from-2020-12-17-18-24-10.png\"></a></div>",
        "id": 220317703,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608247536
    },
    {
        "content": "<p>What's the question? What is it precisely you want to get?</p>",
        "id": 220317819,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608247603
    },
    {
        "content": "<p>Are you asking about inverses? You could have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">surj</span><span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and for the inverse use<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.surj_inv\">docs#function.surj_inv</a></p>",
        "id": 220318056,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1608247803
    },
    {
        "content": "<p>Here it comes, trying to type faster.  Here's the first part:</p>\n<p>So Mark Dean defines a notion of a distribution and a distribution function (when the random variable is into ℝ).  Kloeden&amp;co give an expression for the distribution function:  <code>FX(x) = PX((-∞ ,x)) = P({ω ∈ Ω : X(ω) ≤ x})</code>.</p>\n<p>They are both assuming that the random variable is into ℝ.   I don't see any reason for this, because this: <code>X(ω) ≤ x</code> only requires that there be a preorder ≤  on the type β that the preorder is into.</p>",
        "id": 220318097,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608247825
    },
    {
        "content": "<p>Oh so you want the distribution then?</p>",
        "id": 220318107,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608247840
    },
    {
        "content": "<p>No, we have the <code>distribution</code>, I want to define the <code>distribution_function</code> in case <code>β</code> has a preorder in this sketch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">probability_space.distribution</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ps</span><span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ps.volume</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">probability_space.distribution_function</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ps</span><span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sorry</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">distribution_space</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X.outcome</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">X.is_measurable_outcome</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">probability_space.is_probability_measure.measure_univ</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.comap</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">volume</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">subtype.volume_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">volume</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">volume</span> <span class=\"o\">((</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">measure.comap_apply</span> <span class=\"n\">_</span> <span class=\"n\">subtype.coe_injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">is_measurable.subtype_image</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">hs</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Steinhaus</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">measure_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">subtype.volume_apply</span> <span class=\"n\">is_measurable_Icc</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">simpa</span><span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">real.volume_Icc</span><span class=\"o\">],</span> <span class=\"n\">simp</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"bp\">Ω</span><span class=\"n\">AP</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"n\">Steinhaus.P</span> <span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Steinhaus.</span><span class=\"bp\">Ω</span><span class=\"n\">AP</span>\n<span class=\"k\">#check</span> <span class=\"n\">Steinhaus.</span><span class=\"bp\">Ω</span><span class=\"n\">AP.volume</span> <span class=\"c1\">-- volume : measure ↥(set.Icc 0 1)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Steinhaus</span>\n</code></pre></div>",
        "id": 220318171,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608247902
    },
    {
        "content": "<p>So we have probability space, random variable, distribution space induced by random variable on probability space, and the final icing on the cake is to show that if I have a preorder on the measurable space that the random variable is into, then I have a distribution function.</p>",
        "id": 220318266,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608247965
    },
    {
        "content": "<p>Why this is at all interesting is because everybody in the world only defines <code>distribution_function</code> when the random variable is into <code>ℝ</code>.  Nobody seems to care about the case where it is into a measurable space with a preorder.  I just think it's an interesting generalization.</p>",
        "id": 220318351,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248028
    },
    {
        "content": "<p>But it's only possible for me to talk about whether it is interesting or definable in the presence of something like Lean.</p>",
        "id": 220318410,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> There aren't any inverses involved in those snippets. That's a <code>preimage</code> you see</p>",
        "id": 220318472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248114
    },
    {
        "content": "<p>What I'm working on is this generalization of the distribution function in the Kloeden snippet, which Dean defines only if the RV is into the reals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">probability_space.distribution_function</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span>  <span class=\"bp\">\\</span><span class=\"o\">[</span><span class=\"n\">ps</span><span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ps.volume</span><span class=\"o\">({</span><span class=\"n\">ω</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">(</span><span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">})</span>\n</code></pre></div>",
        "id": 220318616,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248227
    },
    {
        "content": "<p>Ah, misread. Gotcha. So the clean wya to state that is outcome.preimage?</p>",
        "id": 220318638,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1608248249
    },
    {
        "content": "<p>Well, the whole measure is <code>measure.comap</code> I think</p>",
        "id": 220318663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248279
    },
    {
        "content": "<p>actually <code>measure.map</code></p>",
        "id": 220318746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248336
    },
    {
        "content": "<p>That's another question I had about terminology, why <code>measure_space</code> uses <code>map</code> and <code>comap</code> but in the comments it uses <code>pushforward</code> and <code>pullback</code> which comments match terminology used in <code>Top</code> and <code>category_theory</code>.</p>",
        "id": 220318850,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248403
    },
    {
        "content": "<p>so there isn't really anything to do in definition 7. <code>measure.map x volume</code> is a measure, check</p>",
        "id": 220318861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248408
    },
    {
        "content": "<p>because there is a clash of terminology from multiple fields</p>",
        "id": 220318888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248437
    },
    {
        "content": "<p>lean uses <code>map</code> and <code>comap</code> for regularity, but this gets instantiated in category theory and topology and algebra and measure theory and mathematicians in these areas all have their own ideas about what to call it</p>",
        "id": 220318948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248493
    },
    {
        "content": "<p>OK thanks.  The above sketch works fine.  <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> worked out how to derive a distribution space from a random variable on a probability space:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">distribution_space</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X.outcome</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">X.is_measurable_outcome</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">probability_space.is_probability_measure.measure_univ</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The only thing I have left to complete the functionality is generalized distribution function.</p>",
        "id": 220318966,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248508
    },
    {
        "content": "<p>I think you are missing a lemma there</p>",
        "id": 220319037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248552
    },
    {
        "content": "<p>you just proved the <code>map</code> of a probability measure is a probability measure</p>",
        "id": 220319053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248571
    },
    {
        "content": "<p>that's a lemma</p>",
        "id": 220319058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248577
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span>\n  <span class=\"n\">volume</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">X.measurable</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">is_measurable_Iic</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 220319074,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608248591
    },
    {
        "content": "<p>why is <code>prob</code> an <code>ennreal</code>?</p>",
        "id": 220319112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248631
    },
    {
        "content": "<p>Because I'm lazy</p>",
        "id": 220319119,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608248639
    },
    {
        "content": "<p>One should change it to <code>\\R</code>.</p>",
        "id": 220319172,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608248651
    },
    {
        "content": "<p>Same with <code>distribtion_function</code>.</p>",
        "id": 220319187,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608248667
    },
    {
        "content": "<p>Well that's what I'm trying to generalize.  I want to replace ℝ with β where β has a <code>preorder</code>. What do you think?</p>",
        "id": 220319213,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248690
    },
    {
        "content": "<p>Sure you could do that.</p>",
        "id": 220319262,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608248725
    },
    {
        "content": "<p>I don't think that's a good idea, it's not general enough</p>",
        "id": 220319277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248739
    },
    {
        "content": "<p>the sets <code>{c | c ≤ x}</code> in a preorder don't generate all borel sets</p>",
        "id": 220319350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248768
    },
    {
        "content": "<p>you will have to work with the preimages of general sets, at which point it's not clear what the CDF gets you</p>",
        "id": 220319384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608248810
    },
    {
        "content": "<p>It would be a really wonderful solution to a <a href=\"https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009?noredirect=1#comment7787969_3782009\">Math StackExchange question I posed in August</a>, i.e. exactly what kind of order does β have to have for this to go through in Lean.</p>",
        "id": 220319422,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248854
    },
    {
        "content": "<p>For one thing you know by construction of the <code>random_variable</code> that β is a <code>measurable_space</code>.</p>",
        "id": 220319521,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608248911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20tell.20Lean.20that.20a.20subclass.20is.20a.20kind.20of.20the.20supercla/near/220319053\">said</a>:</p>\n<blockquote>\n<p>you just proved the <code>map</code> of a probability measure is a probability measure, that's a lemma</p>\n</blockquote>\n<p>It could be that makes it a category, which is something to think about.  I.e. if you were building a probability library from scratch would you want to make it as category theory-ish as possible or just express the main ideas on their own.  There seems to be big interest in category theory here, but it seems that using it in practice like for GCD/Fibonacci example is quite hard.  So then the question is whether the generalization that it provides is productive for particular applications, or is it just nice to think about on its own. The fact that there is map/comap and pullback/pushthrough in different parts of the library shows that there is not a unified view among all the mathlib contributors.  Not that there should be, I'm just slowly learning the \"style guide\" and \"make it a category\" doesn't seem to be one of the style imperatives.</p>",
        "id": 220324418,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608252694
    },
    {
        "content": "<p>Regarding this expression for the <code>distribution_function</code>, which is on single points in the codomain of the RV, as opposed to the <code>distribution</code>, which is on subsets of the domain of the RV:  <code>F(x) = P({ω ∈ Ω : X(ω) ≤ x})</code>.  We can see by inspection, since <code>P</code> is a probability measure, that it will be in <code>[0,1]</code>.  If the codomain of the RV is some kind of partially ordered set, the distribution function might not behave in the same way as if it were a linearly ordered dense set.  But the result will still be a CDF.   I will Google \"generalized distribution function\" and see what I come up with.  In any event, it seems well defined for any order relation <code>≤ </code>.</p>",
        "id": 220324993,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608253191
    },
    {
        "content": "<blockquote>\n<p>The fact that there is map/comap and pullback/pushthrough in different parts of the library shows that there is not a unified view among all the mathlib contributors</p>\n</blockquote>\n<p>To clarify: <code>map</code> and <code>comap</code> are used consistently in lean names, while \"pullback\" and \"pushforward\" are used in comments to help connect names to things in the literature (which are all over the place, as one would expect)</p>",
        "id": 220325248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608253385
    },
    {
        "content": "<blockquote>\n<p>It could be that makes it a category, which is something to think about. I.e. if you were building a probability library from scratch would you want to make it as category theory-ish as possible or just express the main ideas on their own.</p>\n</blockquote>\n<p>I would not suggest adding additional layers unless it gives you an advantage in proving theorems. Instantiating a category is a thing you can do, but it's not particularly helpful on its own. There are lots of things in mathlib that could potentially be instantiations of the category library, but generally it's just another layer on an existing theorem. I would say prove the theorem and add the instantiation if and when you need it for a theorem</p>",
        "id": 220325458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608253569
    },
    {
        "content": "<p>OK so my main concern, all abstraction aside, is whether any <code>measurable_set</code> <code>S</code> with ≤  for which this expression: <code>F(x: S) = P({ω ∈ Ω : X(ω) ≤ x})</code> makes sense is necessarily linearly ordered, dense and isomorphic to ℝ, or whether any <code>measurable_set</code> with any ≤ defined on it will do.</p>",
        "id": 220325607,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608253726
    },
    {
        "content": "<p>Just to clarify, whenever you have a random variable <code>X</code> with codomain <code>A</code>, and some function from <code>A</code> to the type of all measurable sets in <code>A</code>, you can define something like a distribution function on <code>A</code>. The question is whether this function determines the probability density on <code>A</code> induced by <code>X</code>, and this is certainly not true in general.</p>",
        "id": 220325620,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608253742
    },
    {
        "content": "<p>I think instead of formalizing definitions, you should try to get to the actual theorems, because we can work backward from there to the abstractions that are useful for formalizing the theorem. So far, I don't see any value in the definition <code>random_variable</code>, or <code>distribution</code>, or <code>prob</code> or <code>distribution_function</code>, they are all just wrappers around other things. So let's get to theorems where you really <em>need</em> some probability vocabulary to prove the theorem effectively</p>",
        "id": 220325734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608253809
    },
    {
        "content": "<p>Random variable, distribution, distribution function and probability space <em>are</em> probability vocabulary.</p>",
        "id": 220325787,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608253863
    },
    {
        "content": "<p>yes I'm aware</p>",
        "id": 220325799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608253872
    },
    {
        "content": "<p>a wrapper doesn't help you prove theorems</p>",
        "id": 220325818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608253900
    },
    {
        "content": "<p>Google gave me this, maybe it's of some use: <a href=\"https://www.ams.org/journals/tran/1957-084-02/S0002-9947-1957-0085326-5/S0002-9947-1957-0085326-5.pdf\">https://www.ams.org/journals/tran/1957-084-02/S0002-9947-1957-0085326-5/S0002-9947-1957-0085326-5.pdf</a></p>",
        "id": 220325824,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608253908
    },
    {
        "content": "<p>more words to express things you could already express are not helpful. The power of a definition is when it abbreviates a nontrivial combination of things, like \"group\" meaning \"associative binary operation with a neutral element\"</p>",
        "id": 220325914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608253986
    },
    {
        "content": "<p>the latter expression is more cumbersome than the former, so the definition pulls its weight</p>",
        "id": 220325947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254028
    },
    {
        "content": "<p>there are also a bunch of theorems about groups that are not theorems about monoids or associative operations on their own</p>",
        "id": 220326001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254061
    },
    {
        "content": "<p>I'm not really trying to prove a theorem, I'm just trying to get the type classes straight to describe the usual vocabulary of probability theory.  That's all.  Because even though that vocabulary is just sugar for things that are already in<code>mathlib</code> in one way or another, they are still challenging for me.  I can't go to<code>mathlib</code> and see the usual vocabulary of probability theory.  It's a modest exercise.</p>",
        "id": 220326020,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608254082
    },
    {
        "content": "<p>So what's the raison d'etre of probability vocabulary? What fact about probability measures is not true about general measures? I have no doubt that such theorems <em>exist</em>, but nothing interesting will happen until you start trying to prove one of them</p>",
        "id": 220326066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254128
    },
    {
        "content": "<p>It is really important to find and at least start trying to prove one of these theorems because it guides the structure of definitions around the whole topic. Without it I see all these definitions and they are all useless cruft with negative utility</p>",
        "id": 220326289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254314
    },
    {
        "content": "<p>My longer range goal is to understand say the construction of the stochastic Taylor series approximation of the Ito or Stratonovich integral.  I am not trying to prove any new theorems about this topic.  I'm trying to build up the language used in a textbook that goes through that topic.  The textbook doesn't use the measure-theoretic equivalent of <code>probability_space</code>.  It uses <code>probability_space</code>.  I don't think I should feel bad about, for my own purposes in reading that book, providing a definition of <code>probability_space</code>.</p>\n<p>Along the way I noticed that <code>F(x: S) = P({ω ∈ Ω : X(ω) ≤ x}</code> could possibly be generalized.  <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> expresses this as whether the random variable <code>X</code> \"determines the probability density on A induced by X\".  It seems that \"determines the probability density on A induced by X\" is something that could be written in Lean and expressed as a condition that the order relation ≤ has to satisfy.  So, for my own tastes and ambitions, I think it would be interesting to say formalize \"determines the probability density on A induced by X\" and see where that leads.  It could lead to the requirement that the codomain of the random variable be isomorphic to the reals, which would be an interesting and natural explanation for why every text I can find restricts <code>distribution_function</code> to random variables into the reals.</p>",
        "id": 220326458,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608254462
    },
    {
        "content": "<blockquote>\n<p>The textbook doesn't use the measure-theoretic equivalent of probability_space. It uses probability_space. I don't think I should feel bad about, for my own purposes in reading that book, providing a definition of probability_space.</p>\n</blockquote>\n<p>The point isn't to feel bad about it, it is to build the theory of probability spaces by looking at how it is <em>used</em></p>",
        "id": 220326568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254554
    },
    {
        "content": "<p>The question to answer isn't <em>what is a probability space</em>, it is <em>what do people do with probability spaces</em></p>",
        "id": 220326600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254587
    },
    {
        "content": "<p>the purpose of a library is to make it easier to write proofs in the area</p>",
        "id": 220326707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254660
    },
    {
        "content": "<p>so you have to look at the proofs to understand how to help</p>",
        "id": 220326729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254677
    },
    {
        "content": "<p>Regarding what you would need to make the exact definition <code>F(x: S) = P({ω ∈ Ω : X(ω) ≤ x})</code> generalize, I would expect that you need the sets <code>{a | a &lt; x}</code> to generate the topology and hence the entire borel algebra. That is, you need an <code>orderable_topology</code> on the codomain</p>",
        "id": 220326958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254870
    },
    {
        "content": "<p>oops it's called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_closed_topology\">docs#order_closed_topology</a> now</p>",
        "id": 220327065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608254974
    },
    {
        "content": "<p>I think you will need to get to some really interesting theorems before the codomain starts to be constrained to look anything like the reals</p>",
        "id": 220327171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608255049
    },
    {
        "content": "<p>Law of large numbers might be a nice goal.</p>",
        "id": 220328111,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608255945
    },
    {
        "content": "<p>In terms of \"what do people do with probability spaces\", and the book I am reading, I have some very simple applications that I want to proof-check in Lean:</p>\n<ul>\n<li>A one-size-fits-all probability space:([0,1], B([0,1]), [a,b] -&gt; b-a). That's done.  Cruft is to name this the Steinhaus space</li>\n<li>Some basic language: Random variable, distribution, distribution function</li>\n<li>Distribution function for a two-point RV with codomain {0,1} and probabilities p and 1-p</li>\n<li>Uniform distribution U[a,b]</li>\n<li>Exponential distribution </li>\n<li>Gaussian distribution</li>\n</ul>\n<p>For each of these I want to:</p>\n<ul>\n<li>Start with Steinhaus as the domain of the random variable X, </li>\n<li>Define the codomain as either a finite measurable space for a continuous random variable or the appropriate continuous codomain which could be ereal or ennreal or a real interval</li>\n<li>Define the corresponding random variable X</li>\n<li>From X derive the distribution function FX</li>\n</ul>\n<p>This is not the usual order.  The book and most presentations tend to start with the distribution function.  I just like doing it in this order because it appeals to me.  I'm not proving theorems really, just trying to create language for a sequence that appeals to me for presenting these different discrete and continuous distributions in a consistent kind of top-down way.  Also, I am annoyed that the book introduces <code>probability_space</code> on page 3 and then drops it thereafter and just presents the <code>distribution_function</code> for each distribution.  I think if you define something you should use it, so I'm spending my time doing it in this direction.   It's just a personal choice.</p>",
        "id": 220329514,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608257398
    },
    {
        "content": "<p>well the main issue I have with that list is that every single one is a definition, there are no theorems</p>",
        "id": 220329934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608257796
    },
    {
        "content": "<p>you need at least some sanity checks on the definitions</p>",
        "id": 220329945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608257821
    },
    {
        "content": "<p>Perhaps your goal might be to have a way to prove that a real function (which is what the books will give in order to define a distribution) yields a probability distribution, that's not completely obvious from the definitions</p>",
        "id": 220330111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608258003
    },
    {
        "content": "<p>you can then use that to get the exponential distribution and gaussian distribution</p>",
        "id": 220330221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608258153
    },
    {
        "content": "<p>I think you already did the uniform distribution earlier</p>",
        "id": 220330234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608258182
    },
    {
        "content": "<p>The interesting (to me) part, which I already did by hand, is when they give a distribution function, to back out what the random variable is that has that distribution function.  It's not always easy to get it right.  So my work is to take the RV that I backed out and prove that if you grind it through the Lean <code>distribution_function</code> construction, that I get the same function.  So that's a proof.</p>\n<p>Regarding the generalized disrtibution function, I am trying to generalize</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>Adam's distribution function full definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">is_measurable_Iic</span>\n</code></pre></div>\n<p>I am trying to understand the application of <code>@probability_space.prob</code>.   I've got this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span>\n  <span class=\"n\">volume</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">X.measurable</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">MSα</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span>\n<span class=\"kd\">variable</span> <span class=\"n\">Pα</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">α</span>\n<span class=\"kd\">variable</span> <span class=\"n\">Pβ</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span>  <span class=\"n\">β</span>\n<span class=\"kd\">variable</span> <span class=\"n\">Sα</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span>\n<span class=\"kd\">variable</span> <span class=\"n\">Sβ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">SMα</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">Sα</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">SMβ</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">Sβ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">Xαβ</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Xαβ.induced</span> <span class=\"c1\">-- X.induced : probability_space β</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">α</span> <span class=\"n\">Pα</span> <span class=\"n\">Sα</span> <span class=\"o\">(</span><span class=\"n\">SMα</span> <span class=\"n\">Sα</span> <span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">Pβ</span> <span class=\"n\">Sβ</span> <span class=\"o\">(</span><span class=\"n\">SMβ</span> <span class=\"n\">Sβ</span><span class=\"o\">)</span> <span class=\"c1\">-- FAILS</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">sorry</span>\n<span class=\"c1\">--  @probability_space.prob _ X.induced {c | c ≤ x} is_measurable_Iic</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>\n<p>Even though the one before it works, this fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">Pβ</span> <span class=\"n\">Sβ</span> <span class=\"o\">(</span><span class=\"n\">SMβ</span> <span class=\"n\">Sβ</span><span class=\"o\">)</span> <span class=\"c1\">-- FAILS</span>\n</code></pre></div>\n<p>I don't fully understand why the type of <code>SMα</code> is <code>Mα : ∀ (Sα : set ?M_1), is_measurable Sα</code>, so I have to re-supply Sα when I use it even though it's declared</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">SMα</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">Sα</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>So </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">α</span> <span class=\"n\">Pα</span> <span class=\"n\">Sα</span> <span class=\"o\">(</span><span class=\"n\">SMα</span> <span class=\"n\">Sα</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>works with type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span>\n</code></pre></div>\n<p>But </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">Pβ</span> <span class=\"n\">Sβ</span> <span class=\"o\">(</span><span class=\"n\">SMβ</span> <span class=\"n\">Sβ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>gives </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">_inst_2</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">measure_space.to_measurable_space</span>\n</code></pre></div>\n<p>I am using @ to avoid this kind of mystery but it's not helping in this case.  Any suggestions?  This is a problem because in this line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">is_measurable_Iic</span>\n</code></pre></div>\n<p>the term <code>X.induced</code> is going to have type <code>probability_space β</code>.  So I need to understand how to fill out each of the arguments to <code>@probability_space.prob</code> but I can't even <code>#check</code> it in the β case, it only works for α.</p>\n<p>The other minor issue is that <code>probability_space.prob</code> has return type <code>ennreal</code> when I know that in the end it will be constrained to <code> (set.Icc (0 : ℝ) 1)</code> by <code>probability_measure volume</code>.  I'd rather just say it in the return type rather than <code>ennreal</code>, but that doesn't go through.</p>",
        "id": 220332584,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608260857
    },
    {
        "content": "<blockquote>\n<p>So my work is to take the RV that I backed out and prove that if you grind it through the Lean distribution_function construction, that I get the same function. So that's a proof.</p>\n</blockquote>\n<p>Can you state this theorem?</p>",
        "id": 220332956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608261298
    },
    {
        "content": "<p>it's not entirely clear to me what you mean by it</p>",
        "id": 220332974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608261343
    },
    {
        "content": "<p>I'm not sure there is anything to be gained with the <code>#check</code>s, all those variables are tripping you up. Just state a def or theorem and try to get the assumptions and the statement of the theorem right</p>",
        "id": 220333053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608261463
    },
    {
        "content": "<p><code>lemma SMα</code> is false, it asserts all sets are measurable</p>",
        "id": 220333096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608261485
    },
    {
        "content": "<p><code>lemma SMβ</code> is the same as <code>lemma SMα</code></p>",
        "id": 220333107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608261504
    },
    {
        "content": "<p>The point of the <code>#check</code>s was simply to check the type of the arguments to the expression, I was trying to figure out what kind of thing to fill in the blank for each of the slots in <code>probability_space.prob</code>.  I know that it just applies the volume function, but in the explicit @ form there are a lot of things that need to be in place for the application to go through, and I was trying to understand their types.</p>\n<p>The theorem to prove is as follows (for the type of random variables in the text, which is the usual type, not the generalized type I want):</p>\n<ul>\n<li>We are given, in the text <code>F_X: ℝ → [0,1] </code>, the <code>distribution_function</code> for the <code>random_variable</code> named <code>X: [0,1] → ℝ</code>.</li>\n<li>I construct, by inspection, a definition <code>myX</code> for the random variable<code>X</code>.</li>\n<li>There is a  <code>distribution</code>, <code>μ_X : borel ℝ → [0,1]</code>, which is implicit.</li>\n<li>In the Steinhaus space we have uniform probability measure 'P: borel ℝ → [0,1]`.</li>\n<li>By construction (this is already proven out of the by the machinery in the cruft above), we have that <code>μ_X = P ∘ X⁻¹ </code></li>\n<li><strong>To prove</strong>: that <code>myX = λ x, μ_X (set.Icc -∞ x)</code></li>\n</ul>\n<p>For example, consider the two point distribution:<br>\n<a href=\"/user_uploads/3121/0yPq8rVnb_Ww4uJBC_dwPmbb/Screenshot-from-2020-12-18-00-03-15.png\">Screenshot-from-2020-12-18-00-03-15.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/0yPq8rVnb_Ww4uJBC_dwPmbb/Screenshot-from-2020-12-18-00-03-15.png\" title=\"Screenshot-from-2020-12-18-00-03-15.png\"><img src=\"/user_uploads/3121/0yPq8rVnb_Ww4uJBC_dwPmbb/Screenshot-from-2020-12-18-00-03-15.png\"></a></div>",
        "id": 220337225,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608267818
    },
    {
        "content": "<p>Let <code>x₁, x₂ ∈ ℝ</code> and <code>p₁</code> be the probability of drawing <code>x₁</code>.  Then we can define <code>X(ω) = if ω &lt; p₁ then x₁ else x₂ </code> or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myX</span><span class=\"o\">(</span><span class=\"n\">ω</span><span class=\"o\">:</span> <span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">ω</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₁</span> <span class=\"k\">then</span> <span class=\"n\">x₁</span> <span class=\"k\">else</span> <span class=\"n\">x₂</span>\n</code></pre></div>\n<p>also, the text is telling us that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FX</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">x</span><span class=\"bp\">&lt;</span><span class=\"n\">x₁</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x₁</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x₂</span> <span class=\"k\">then</span> <span class=\"n\">p₁</span> <span class=\"k\">else</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>and then the proof to achieve is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">FX</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Steinhaus.volume</span> <span class=\"bp\">∘</span> <span class=\"n\">myX.induced</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"bp\">∞</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>I find this interesting and a little bit tricky.   It's not rocket science but it does seem to take some effort to get all the pieces in place.  It's also not the generalized distribution function I was going on about, but it sketches out the path through the woods I am looking to take.</p>",
        "id": 220338104,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608268916
    },
    {
        "content": "<p>I don't think <code>X(ω) = if ω &lt; p₁ then x₁ else x₂</code> is correct. What you need is for the probability that <code>X = x1</code> to equal <code>p1</code>, meaning that the event space is <code>bool</code> or perhaps a general probability space on which you posit an event <code>A</code> whose probability is <code>p1</code></p>",
        "id": 220338309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608269182
    },
    {
        "content": "<p>On the index space <code>[0,1]</code> I am defining an event<code>A=[0,p1)</code>.  According to Kloeden et al's book, <code>I(A)(ω)= if ω∈A then x₁ else x₂</code> is a random variable on this space, for <code>x₁=0</code> and <code>x₂=1</code>.   Please let me know if I'm reading this wrong:<br>\n<a href=\"/user_uploads/3121/xzE2GNwzbdTfRDxJbnuvHXOn/Screenshot-from-2020-12-18-09-43-54.png\">Screenshot-from-2020-12-18-09-43-54.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/xzE2GNwzbdTfRDxJbnuvHXOn/Screenshot-from-2020-12-18-09-43-54.png\" title=\"Screenshot-from-2020-12-18-09-43-54.png\"><img src=\"/user_uploads/3121/xzE2GNwzbdTfRDxJbnuvHXOn/Screenshot-from-2020-12-18-09-43-54.png\"></a></div>",
        "id": 220379618,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608302723
    },
    {
        "content": "<p>Note instead of clumping the events in <code>[0,p1)</code> I could have defined <code>A</code> to be the union of a bunch of more randomly scattered subsets.  That's not necessary for the definitions to work.  There is no inherent \"randomness\" in <code>random_variable</code> in that sense.   A <code>random_variable</code> is a fully determined function from a sample space to a measurable space.</p>",
        "id": 220381267,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608303517
    },
    {
        "content": "<p>You don't need to define <code>A</code> to be anything in particular, it can be a hypothesis</p>",
        "id": 220396165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608309846
    },
    {
        "content": "<p>it's more general this way anyway because you don't know what event space is needed in order to match all the other constraints in a downstream theorem</p>",
        "id": 220396244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608309887
    },
    {
        "content": "<p>The Kloeden book brings in (briefly) the idea of probability space, so I want to demonstrate it when explaining things to myself.  I can use <code>(Ω,A,P)= ([0,1],B([0,1]),[a,b]↦ b-a)</code> as a \"one sits fits all\" probability space.  Then I want to define a random variable on that space, obtain it's distribution <code>D</code>, and then obtain the distribution function <code>F</code>, which results in a new distribution (probability) space like <code>(S,Σ,D)=(R, B(R), D)</code> with CDF <code>F</code>.  I want to do that in Lean for the 6 particular cases in the book.  I'm not trying to make the most general Lean probability theory module, or prove old or new theorems.  I'm just trying to demonstrate a little piece of mechanism, to myself, because it seems pretty to me.   I don't expect anybody else to find it interesting.  Think of it as me doing beginner-level gardening in my back yard.  It's a hobby, not a calling.</p>\n<p>On the task of describing stochastic integration at a Lean level of detail, Wilfrid Kendall has done a lot of work, 21 years ago, which seems easily adaptable.  (Adapting old stuff to new contexts is also more hobby gardening, not necessarily of general interest.)  Kendall worked in <a href=\"https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/abstracts/#203\">Reduce,</a> then <a href=\"https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/abstracts/#327\">Axiom</a> with <a href=\"https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/abstracts/#328\">fine details</a>, then <a href=\"https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/kendall/personal/ppt/333.pdf\">Mathematica</a>.  (Note, his .ps.gz files are really just .ps files, they aren't zipped.)  His Axiom papers provide the most detail. Axiom has a much richer type system than Mathematica, so the Axiom implementation is an improvement on it's successor.</p>",
        "id": 220403837,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608313059
    },
    {
        "content": "<blockquote>\n<p>I can use (Ω,A,P)= ([0,1],B([0,1]),[a,b]↦ b-a) as a \"one sits fits all\" probability space.</p>\n</blockquote>\n<p>It's not, though, as soon as you have more than one variable. What if you have two {0,1} variables <code>X</code> and <code>Y</code> with probabilities <code>p</code> and <code>q</code> to be 1, which are independent? This model will not help there.</p>",
        "id": 220405377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608313753
    },
    {
        "content": "<p>These 6 examples are all univariate.  Steinhaus space is a good enough indexing space for univariate examples whether continuous or discrete.   I'm not sure that what's in the sketch above (aside from my desire to generalize <code>distribution_function</code>) excludes <a href=\"https://en.wikipedia.org/wiki/Product_measure\">product measures</a>.  Baby steps!</p>",
        "id": 220413401,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608317565
    },
    {
        "content": "<p>it's generally easier to not commit to particular example spaces if you can help it. Define a gaussian distributed RV over any event space</p>",
        "id": 220414385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608318024
    },
    {
        "content": "<p>you are doing lean on hard mode for some reason I don't understand</p>",
        "id": 220414447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608318051
    },
    {
        "content": "<p>The use of [0,1] is AFAICT entirely superfluous, and your proofs and definitions will be smaller and easier without it</p>",
        "id": 220414577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608318118
    },
    {
        "content": "<p>certainly the book you are reading from has made no such commitment to an event space</p>",
        "id": 220414779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608318188
    },
    {
        "content": "<p>These are toy examples for exposition of a small point.  Before I can generalize these toy examples I have to be able to do them first.  I'm not there yet.  I can't generalize something I don't  know how to do in  a smaller context.</p>\n<p>In terms of a grander design, the above sketch has</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span>\n  <span class=\"n\">volume</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>I would like to be able to say </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">volume</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>because probability measures by definition have as codomain <code>[0,1]</code>.  Here's something I need to prove, but I don't know how to say it correctly in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">volume_type_01</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">volume</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>I can say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">volume_gt_0_lt_1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>but that doesn't give me a way to replace <code>ennreal</code> with <code>(set.Icc (0 : ℝ) 1)</code>.</p>",
        "id": 220419102,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608320459
    },
    {
        "content": "<p>I suggest using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ennreal.to_real\">docs#ennreal.to_real</a></p>",
        "id": 220419481,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608320622
    },
    {
        "content": "<blockquote>\n<p>These are toy examples for exposition of a small point. Before I can generalize these toy examples I have to be able to do them first.</p>\n</blockquote>\n<p>The general case is easier than the specific case. I know this is counterintuitive, but it's true. The toy examples are way harder than general theorems about all measure spaces or all probability spaces, because the contingent details of the example don't get in the way</p>",
        "id": 220420985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608321456
    },
    {
        "content": "<p>OK. The other thing I want to prove, to get the generalized distribution function, is something I at least know how to state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_measurable_measurable_with_le</span> <span class=\"o\">(</span><span class=\"n\">xx</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">xx</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>With this, the following #check works fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"n\">XX</span><span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n<span class=\"kd\">variable</span> <span class=\"n\">xx</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n<span class=\"kd\">variable</span> <span class=\"n\">Xlte</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">β</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">XX.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">xx</span><span class=\"o\">}</span> <span class=\"n\">_</span>  <span class=\"c1\">-- probability_space.prob ?M_1 : ennreal</span>\n</code></pre></div>\n<p>However the exact same expression preceded by a <code>def f :=</code> instead of a <code>#check</code> results in a fail:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">generalized_distribution_function</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">XX.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">xx</span><span class=\"o\">}</span> <span class=\"n\">_</span> <span class=\"c1\">-- ERROR</span>\n</code></pre></div>\n<p>The fail is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n<span class=\"n\">XX</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n<span class=\"n\">xx</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_le</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>where the whole file is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span>\n  <span class=\"n\">volume</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">X.measurable</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">is_measurable_Iic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_measurable_measurable_with_le</span> <span class=\"o\">(</span><span class=\"n\">xx</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">xx</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">XX</span><span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n<span class=\"kd\">variable</span> <span class=\"n\">xx</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n<span class=\"kd\">variable</span> <span class=\"n\">Xlte</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">β</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">XX.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">xx</span><span class=\"o\">}</span> <span class=\"n\">_</span>  <span class=\"c1\">-- probability_space.prob ?M_1 : ennreal</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">generalized_distribution_function</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">XX.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">xx</span><span class=\"o\">}</span> <span class=\"n\">_</span> <span class=\"c1\">-- ERROR</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 220424039,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608323081
    },
    {
        "content": "<p>As you can see, your variable <code>Xlte</code> is nowhere in your local context. <code>has_le</code> is a typeclass, so you need to use square brackets. Note that <code>has_le</code> is just an arbitrary relation, and whilst I know nothing about probability theory or measure theory, assuming <code>[has_le \\beta]</code> is a very weak statement.</p>",
        "id": 220424271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608323220
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I figured out how to state things in a way that typechecks.  Not quite done yet, I want to replace <code>ennreal</code> with real interval <code>[0,1]</code> following <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> 's hint.  Here is how it is with <code>ennreal</code>.  There is just no <code>sorry</code>. Instead I introduced a new structure <code>is_measurable_with_le</code> to hold the proof that the set is measurable.  It's a punt, but a more well-defined punt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span>\n  <span class=\"n\">volume</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">X.measurable</span> <span class=\"n\">is_measurable.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">is_measurable_Iic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_measurable_with_le</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n <span class=\"o\">(</span><span class=\"n\">proof</span><span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">generalized_distribution_function</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mb</span><span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n          <span class=\"o\">[</span><span class=\"n\">po</span><span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">im</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable_with_le</span> <span class=\"n\">β</span> <span class=\"n\">b</span> <span class=\"n\">mb</span> <span class=\"n\">po</span><span class=\"o\">]</span>  <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"n\">im.proof</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 220444096,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608338318
    },
    {
        "content": "<p>Here are some theorems. Try filling the sorries at the end.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">volume_univ</span> <span class=\"n\">α</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">measure_mono</span> <span class=\"o\">(</span><span class=\"n\">set.subset_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_real</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_nnreal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">volume_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ennreal.coe_to_nnreal</span> <span class=\"bp\">$</span> <span class=\"n\">ne_top_of_le_ne_top</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩)</span> <span class=\"o\">(</span><span class=\"n\">volume_le_one</span> <span class=\"n\">S</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">volume_le_one</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">nnprob_le_one</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">nnreal.zero_le_coe</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">nnprob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">measure_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">nnreal.coe_le_coe.2</span> <span class=\"bp\">$</span> <span class=\"n\">nnprob_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">measurable.map_probability_measure</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">measure.map</span> <span class=\"n\">f</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">hf</span> <span class=\"n\">is_measurable.univ</span><span class=\"bp\">;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"n\">X.measurable.map_probability_measure</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_le_one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_mono</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_closed_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">opens_measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">is_closed.is_measurable</span> <span class=\"n\">is_closed_Iic</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 220447077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608342369
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I will work on that.</p>",
        "id": 220448291,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608344084
    },
    {
        "content": "<p>I was able to prove <code>zero_le_CDF</code> and <code>CDF_le_one</code>.  I am stuck on <code>CDF_mono</code>.  I have it reduced to a proposition of form A implies B where I know B.   I have a lemma for A.  I don't know how to introduce the results of A into the hypothesis set.  That's a simple Lean thing but I don't know how to do it.  Then if I had that I could finish.   Also I have to prove A which also seems simple but I don't know how to get started.   Where</p>\n<ul>\n<li><code>A</code> is<code>{c : β | c ≤ x} ⊆ {c : β | c ≤ y} </code></li>\n<li><code>B</code> is <code>@probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</code></li>\n</ul>\n<p>Here is the sketch so far.  The part where I'm stuck as at the bottom:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">volume_univ</span> <span class=\"n\">α</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">measure_mono</span> <span class=\"o\">(</span><span class=\"n\">set.subset_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_real</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_nnreal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">volume_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ennreal.coe_to_nnreal</span> <span class=\"bp\">$</span> <span class=\"n\">ne_top_of_le_ne_top</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩)</span> <span class=\"o\">(</span><span class=\"n\">volume_le_one</span> <span class=\"n\">S</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">volume_le_one</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">nnprob_le_one</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">nnreal.zero_le_coe</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">nnprob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">measure_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">nnreal.coe_le_coe.2</span> <span class=\"bp\">$</span> <span class=\"n\">nnprob_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">measurable.map_probability_measure</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">measure.map</span> <span class=\"n\">f</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">hf</span> <span class=\"n\">is_measurable.univ</span><span class=\"bp\">;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"n\">X.measurable.map_probability_measure</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_closed_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">opens_measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">is_closed.is_measurable</span> <span class=\"n\">is_closed_Iic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_eq_CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">probability_space.zero_le_prob</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_le_one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">probability_space.prob_le_one</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">factoid</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">):</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>   <span class=\"c1\">-- STUCK</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_mono</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- introduce hp: factoid(x y)  -- STUCK</span>\n  <span class=\"c1\">-- apply @probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 220481139,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608402227
    },
    {
        "content": "<p>The <code>factoid</code> is false, because you forgot the essential assumption <code>x &lt;= y</code>! Do you see why this theorem should be true mathematically?</p>",
        "id": 220481383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608402667
    },
    {
        "content": "<p>also you changed the theorems I wrote by moving them after the <code>variables [topological_space beta]...</code> line. They were written before that line because they don't require any of that stuff to be proven</p>",
        "id": 220481575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608403028
    },
    {
        "content": "<p>In fact, I think that line is wrong; indeed there shouldn't be any measurable space structure on beta, because the theorems are all about <code>X.induced</code> which uses only the measurable structure on alpha</p>",
        "id": 220481659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608403156
    },
    {
        "content": "<p>I moved those up just to put the <code>sorry</code> parts the bottom.  I will move back down.   How is this for <code>factoid</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">factoid</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Given <code>factoid</code> what's the proof language to introduce the result of a <code>lemma</code> into the hypothesis set?  If I have revised <code>factoid</code> then I need that to apply here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">CDF_mono</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- introduce hp: factoid(x y)</span>\n  <span class=\"c1\">-- apply @probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The revised sketch is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">volume_univ</span> <span class=\"n\">α</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">measure_mono</span> <span class=\"o\">(</span><span class=\"n\">set.subset_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_real</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_nnreal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">volume_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ennreal.coe_to_nnreal</span> <span class=\"bp\">$</span> <span class=\"n\">ne_top_of_le_ne_top</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩)</span> <span class=\"o\">(</span><span class=\"n\">volume_le_one</span> <span class=\"n\">S</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">volume_le_one</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">nnprob_le_one</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">nnreal.zero_le_coe</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">nnprob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">measure_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">nnreal.coe_le_coe.2</span> <span class=\"bp\">$</span> <span class=\"n\">nnprob_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">measurable.map_probability_measure</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">measure.map</span> <span class=\"n\">f</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">hf</span> <span class=\"n\">is_measurable.univ</span><span class=\"bp\">;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"n\">X.measurable.map_probability_measure</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_eq_CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">probability_space.zero_le_prob</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_le_one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">probability_space.prob_le_one</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">factoid</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_mono</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- introduce hp: factoid(x y)</span>\n  <span class=\"c1\">-- apply @probability_space.prob_mono β X.induced {c : β | c ≤ x} {c : β | c ≤ y}  to hp</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_closed_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">opens_measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">is_closed.is_measurable</span> <span class=\"n\">is_closed_Iic</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 220482560,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608404602
    },
    {
        "content": "<p>Have you read <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> or played the <a href=\"https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/\">natural number game</a>? They introduce all the tools you need to write proofs. In this case, you need <code>have := factoid x y h</code>.</p>",
        "id": 220483690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608406342
    },
    {
        "content": "<p>Yes I did both but in their examples the <code>have</code> is usually something like <code>have hp : p, from h.left</code> so a labelled proposition from a tactic applied to the existing goal state.  I didn't find any examples in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a>  of <code>have := </code> with a term.  In <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> and the number game, lemmas and theorems are used into introduce equalities that get applied with <code>rw</code> tactic or implications that get applied with <code>apply</code> or <code>exact</code>.</p>",
        "id": 220484882,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608407979
    },
    {
        "content": "<p>Anyway, DONE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.lebesgue_measure</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">probability_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">:</span>  <span class=\"n\">probability_measure</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">probability_space</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_univ</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_probability_measure.measure_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">volume_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">volume_univ</span> <span class=\"n\">α</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">measure_mono</span> <span class=\"o\">(</span><span class=\"n\">set.subset_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_real</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_nnreal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">volume_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">volume</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ennreal.coe_to_nnreal</span> <span class=\"bp\">$</span> <span class=\"n\">ne_top_of_le_ne_top</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩)</span> <span class=\"o\">(</span><span class=\"n\">volume_le_one</span> <span class=\"n\">S</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_eq_nnprob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">volume_le_one</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">nnprob_le_one</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_prob</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">nnreal.zero_le_coe</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nnprob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nnprob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">nnprob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">ennreal.coe_le_coe.1</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">volume_eq_nnprob</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">measure_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prob</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">nnreal.coe_le_coe.2</span> <span class=\"bp\">$</span> <span class=\"n\">nnprob_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">probability_space</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">measurable.map_probability_measure</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">measure.map</span> <span class=\"n\">f</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">measure_theory.measure.map_apply</span> <span class=\"n\">hf</span> <span class=\"n\">is_measurable.univ</span><span class=\"bp\">;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">probability_space.volume_univ</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">random_variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">outcome</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_outcome</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">outcome</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">probability_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">random_variable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">outcome</span><span class=\"o\">⟩</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_measurable_outcome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induced</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">probability_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">volume</span><span class=\"o\">,</span>\n  <span class=\"n\">is_probability_measure</span> <span class=\"o\">:=</span> <span class=\"n\">X.measurable.map_probability_measure</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">_</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_eq_CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le_CDF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">probability_space.zero_le_prob</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_le_one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">probability_space.prob_le_one</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">factoid</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"n\">set.Iic_subset_Iic.mpr</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">CDF_mono</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X.CDF</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">X.CDF</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">prob_eq_CDF</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">factoid</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">probability_space.prob_mono</span> <span class=\"n\">β</span> <span class=\"n\">X.induced</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h2</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_closed_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">opens_measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">is_closed.is_measurable</span> <span class=\"n\">is_closed_Iic</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">random_variable</span>\n</code></pre></div>",
        "id": 220484887,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608407989
    },
    {
        "content": "<p>In your example <code>h.left</code> is a term</p>",
        "id": 220485717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608409275
    },
    {
        "content": "<p>Note that <code>have :=</code> (which is part of the less abbreviated <code>have h : t := term</code>) is the tactic mode version; the term mode version is <code>have h : t, from term,</code>.</p>",
        "id": 220485773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608409350
    },
    {
        "content": "<p>It looks like <code>have</code> is introduced in <a href=\"https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/?world=5&amp;level=3\">https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/?world=5&amp;level=3</a></p>",
        "id": 220485901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608409574
    },
    {
        "content": "<p>Thanks you are correct!  In terms of my original generalized <code>distribution_function</code> goal, the above can be trimmed down to the assumption that  a random variable is from a probability space α  to a measurable space  β which is a preorder.  <code>CDF</code> is from β to ℝ.  Ideally it should be to <code>set.Icc (0: ℝ) 1</code>.  I guess the additional theorems will help me prove that and restate <code>def CDF (x : β) : ℝ </code> as <code>def CDF (x : β) : set.Icc (0: ℝ) 1</code>?  The example at the end shows how to prove that <code>{c | c ≤ b}</code> is measurable for a type which is a topological space, an order closed topology and a measurable space.  Bu those don't seem to be conditions required by the <code>factoid</code>, which only needs <code>preorder</code>.  Are all these properties needed for anything or just measurable space with preorder?</p>",
        "id": 220486264,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608410191
    },
    {
        "content": "<blockquote>\n<p>Ideally it should be to set.Icc (0: ℝ) 1.</p>\n</blockquote>\n<p>As you can see, we have theorems that it is between zero and one. This is generally preferable up until you actually need to put it into a structure that expects <code>set.Icc (0: ℝ) 1</code>, which you don't currently have</p>",
        "id": 220486919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608411305
    },
    {
        "content": "<blockquote>\n<p>The example at the end shows how to prove that {c | c ≤ b} is measurable for a type which is a topological space, an order closed topology and a measurable space. Bu those don't seem to be conditions required by the factoid, which only needs preorder. Are all these properties needed for anything or just measurable space with preorder?</p>\n</blockquote>\n<p>I put it as an <code>example</code> to show that it is derivable, but so far nothing actually needs those assumptions. You haven't done anything that requires <code>{c | c ≤ b}</code> to be measurable yet, but if you do those are the assumptions you will need (at that point, and not before)</p>",
        "id": 220486981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608411446
    },
    {
        "content": "<p>Can you help me with the mechanics of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">distribution_function</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CDF</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_set_Icc_01</span>\n</code></pre></div>\n<p>It seems I would need to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nat.to_set_Icc_01</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n<p>but that doesn't use the 0/1 theorems and doesn't seem right.</p>",
        "id": 220487082,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608411612
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">CDF_in_01</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">X.CDF</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">X.zero_le_CDF</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">X.CDF_le_one</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 220487159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608411741
    },
    {
        "content": "<p>to reiterate, don't use this unless you need it</p>",
        "id": 220487162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608411764
    },
    {
        "content": "<p>It's in the nature of CDF, what would be the aesthetic or practical reason not to constrain the codomain in this way?</p>",
        "id": 220487190,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608411827
    },
    {
        "content": "<p>because <code>real</code> has operations on it, like addition, while <code>set.Icc 0 1</code> doesn't</p>",
        "id": 220487239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608411867
    },
    {
        "content": "<p>Anyway isn't it exciting to know that CDF can be generalized to any measurable space with a preorder?  It's maybe a useless fact but I've never seen it in any presentation of CDF.</p>",
        "id": 220487262,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608411927
    },
    {
        "content": "<p>Sure, this kind of \"trivial generalization\" comes up all the time in mathlib. It makes you consider questions the original authors hadn't thought about, like what closure properties are needed to prove that the CDF is left-continuous?</p>",
        "id": 220487317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608411995
    },
    {
        "content": "<p>You just read what the authors say, delete all the assumptions, and then just add the assumptions if they become necessary and not before</p>",
        "id": 220487342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608412062
    },
    {
        "content": "<p>A nonzero proportion of the time you never add some of them back</p>",
        "id": 220487383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608412088
    },
    {
        "content": "<p>In fact mathlib has a linter which will do this for you</p>",
        "id": 220487407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608412137
    },
    {
        "content": "<p>If you don't mind my quoting your proof above, I can now close <a href=\"https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009?noredirect=1#comment7787969_3782009\">my old Stack Exchange question</a>  with a definitive answer. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 220487541,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608412346
    },
    {
        "content": "<p>It seems that you got an answer in that question already:</p>\n<blockquote>\n<p>CDFs are defined only for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> (even for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>) and are used for convenience. The push-forward is of a measure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span> by a Random variable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Ω</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">F</mi><mo separator=\"true\">,</mo><mi>μ</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X:(\\Omega,\\mathscr{F},\\mu)\\rightarrow(S,\\Sigma)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">Ω</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.13634em;\">F</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">Σ</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><mi>μ</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo>∈</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mu_X(A):=\\mu(X\\in A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> is the object of interest and it is as general as it can be, since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>S</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(S,\\Sigma)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">Σ</span><span class=\"mclose\">)</span></span></span></span> has no structure other than being a measurable space.</p>\n</blockquote>",
        "id": 220487688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608412653
    },
    {
        "content": "<p>This is another way to say that in a more general context we stop talking about the CDF because the pushforward measure is more general</p>",
        "id": 220487735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608412715
    },
    {
        "content": "<p>A CDF is only useful to the extent that it determines the pushforward measure</p>",
        "id": 220487761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608412777
    },
    {
        "content": "<p>CDF is defined on points in <code>S</code>.  The convention is that only the case <code>S=R</code> has any use.  What we showed is that if <code>S</code> is any measurable space with a preorder, <code>CDF</code> can still be computed and give back a number in <code>[0,1]</code>.  So  I can define a preorder on a domain like binary expression trees of depth at most <code>n</code> and compute the <code>CDF</code> of a tree in the space of all binary trees depth at most <code>n</code>.  I can say that and say that it is interesting to me because it is.  This has nothing to do with using <code>CDF</code> to determine the pushforward measure.  So that comment doesn't make any sense to me.  I got the result I was looking for, and it doesn't seem to be relevant to that comment.  That or it's not possible to put a preorder on binary trees, and continuing on in the vein, maybe the claim is that any measurable set with preorder is isomorphic to  <code>ℝ</code>.  Is that the case?</p>",
        "id": 220488052,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608413235
    },
    {
        "content": "<p>Yes you can compute a number, but the question is what does that number mean? It's not true for a general preorder that giving the CDF of the random variable uniquely determines the distribution of the variable</p>",
        "id": 220488108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413321
    },
    {
        "content": "<blockquote>\n<p>maybe the claim is that any measurable set with preorder is isomorphic to ℝ. Is that the case?</p>\n</blockquote>\n<p>This is certainly not the case</p>",
        "id": 220488122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413372
    },
    {
        "content": "<p>you have a function called CDF, but that doesn't on its own mean much. Here's another function called CDF:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">CDF'</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">random_variable</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>This one doesn't even need a preorder structure on beta, so it's a clear improvement. It's also monotone, between 0 and 1, and right continuous</p>",
        "id": 220488215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413487
    },
    {
        "content": "<p>Except our CDF is proven to be a <code>probability_measure</code> on a <code>measurable_space</code> with <code>preorder</code>, by construction.  I'll take that.  It's not 0.</p>",
        "id": 220488412,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608413768
    },
    {
        "content": "<p>Our CDF is no such thing</p>",
        "id": 220488417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413798
    },
    {
        "content": "<p>it's a real function</p>",
        "id": 220488419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413802
    },
    {
        "content": "<p>I can put all those assumptions on <code>CDF'</code> too</p>",
        "id": 220488429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413817
    },
    {
        "content": "<p>Obviously <code>CDF'</code> is a silly function, but the point is that we haven't shown anything about <code>CDF</code> that makes it meaningfully different from <code>CDF'</code></p>",
        "id": 220488443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413859
    },
    {
        "content": "<p>And my claim is that the real theorem of interest that will distinguish the two doesn't hold on arbitrary preorders</p>",
        "id": 220488503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413918
    },
    {
        "content": "<p>Obtained by running <code>prob</code>, where <code>prob</code> was supplied as a <code>probability_measure</code> when building the initial probability space, and then running it through <code>induced</code> on the <code>random_variable</code>.   As long as you have a meaningful and correct <code>probability_space</code> to begin with, and a meaningful and correct <code>random_variable</code>, the <code>CDF</code> will be meaningful and correct and derived from the original <code>probability_space</code> and the supplied <code>random_variable</code>.  There is nothing trivial about it at all.</p>",
        "id": 220488511,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608413932
    },
    {
        "content": "<p>How do you know it is meaningful and correct?</p>",
        "id": 220488519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413963
    },
    {
        "content": "<p>That's what theorems are for</p>",
        "id": 220488523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413978
    },
    {
        "content": "<p>and we don't have any</p>",
        "id": 220488526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413983
    },
    {
        "content": "<p>except the obvious ones that are true also for <code>CDF'</code></p>",
        "id": 220488535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608413994
    },
    {
        "content": "<p>If I start out with say the Steinhaus space and the definition of the random variable for the 2 point-distribution and crank it through I will get the distribution and distribution function for the 2-point random variable.  What's missing?</p>",
        "id": 220488588,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608414041
    },
    {
        "content": "<p>well that's over <code>real</code></p>",
        "id": 220488599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414071
    },
    {
        "content": "<p>I thought you wanted arbitrary preorders?</p>",
        "id": 220488604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414081
    },
    {
        "content": "<p>As another example we could compute distributions of binary trees of depth <code>n</code>.  This is something people actually think about.  Why can't I have a CDF of those?</p>",
        "id": 220488626,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608414121
    },
    {
        "content": "<p>The main theorem here is that two random variables with the same <code>CDF</code> are the same random variable</p>",
        "id": 220488663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414139
    },
    {
        "content": "<p>that's not true for <code>CDF'</code></p>",
        "id": 220488666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414146
    },
    {
        "content": "<p>and it's not true for <code>CDF</code> on some preorders</p>",
        "id": 220488668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414160
    },
    {
        "content": "<p>Really, I think it's not worth thinking about the CDF in the more unusual codomains. Just call <code>X.induced</code> CDF if it makes you feel better</p>",
        "id": 220488702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414227
    },
    {
        "content": "<p>So what you proved at the bottom required that <code>S</code> be a topological space, an order closed topology and an opens measurable space.    I don't need those assumptions for <code>def CDF</code>.   If I delete <code>variables [preorder β]</code>, then <code>def CDF</code> crashes.  It doesn't rely however on being topological space, order closed topology and opens measurable space.  Are you saying that I will crash if I try to define a random variable into binary trees of length N with a preorder, because of something I'm not understanding?</p>",
        "id": 220488836,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608414385
    },
    {
        "content": "<p>In measure theory, a distribution is no more or less than a measure. It takes all subsets of X as its input, and it doesn't need to be boiled down to a function on X</p>",
        "id": 220488843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414402
    },
    {
        "content": "<blockquote>\n<p>I don't need those assumptions for def CDF. If I delete variables [preorder β], then def CDF crashes. It doesn't rely however on being topological space, order closed topology and opens measurable space. Are you saying that I will crash if I try to define a random variable into binary trees of length N with a preorder, because of something I'm not understanding?</p>\n</blockquote>\n<p>This is why you need to prove theorems about your definitions. It's perfectly possible that a definition can be <em>made</em> in some tremendous generality but it doesn't <em>make sense</em> without some more assumptions. In fact <code>def CDF</code> works using only <code>has_le beta</code>, it doesn't even need <code>preorder</code>, but it certainly doesn't <em>make sense</em> in that generality; we already have a theorem that will detect this nonsense, namely <code>CDF_mono</code>. WIthout that theorem you might well think that there are no problems with that definition</p>",
        "id": 220488927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414566
    },
    {
        "content": "<p>But you haven't tried to prove anything more complicated about <code>CDF</code> yet, and when you do you will find that <code>preorder beta</code> isn't good enough either</p>",
        "id": 220488932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414594
    },
    {
        "content": "<p>It all comes back to the thing I mentioned earlier: how do people <em>use</em> the definition?</p>",
        "id": 220488994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414667
    },
    {
        "content": "<p>making definitions doesn't tell you any deep truths about it, because you can very easily write nonsense without noticing</p>",
        "id": 220489000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414703
    },
    {
        "content": "<p>but once you try to use the definition it all falls down</p>",
        "id": 220489039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608414732
    },
    {
        "content": "<p>Which brings me back to trees.  A long time ago I helped a mathematician counting trees to write <a href=\"https://www.researchgate.net/profile/Lars_Ericson4/publication/2809929_Enumeration_of_Tree_Properties_by_Naive_Methods/links/5592c72a08ae5af2b0eb59dd/Enumeration-of-Tree-Properties-by-Naive-Methods.pdf\">a paper</a> making some probabiliistic arguments about operations on trees.   Conceivably, while doing that, in a practical sense, I might want to define a preorder on trees and compute the percentage of trees in the entire space of trees of size <code>n</code> which were \"less than\" a single particular tree, or an equivalence class of trees.   So that would be the CDF of a single tree.  It might be boring nonsense to almost everybody in the world, but for the two people in that room, it might be helpful.  So then the question, how much of this will fall down if my trees have a preorder but do not constitute a type which is a topological space, order closed topology and opens measurable space?  All of it, some of it or none of it?  And if it is all of it, can we go further and say that there is a 1-1 onto map between the reals and any such space?</p>",
        "id": 220489163,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608414967
    },
    {
        "content": "<p>Even in this hypothetical scenario, you could just write down \"the probability that a random tree is 'less than' the particular tree in question\" and not bother with this CDF terminology stuff.</p>",
        "id": 220489571,
        "sender_full_name": "Reid Barton",
        "timestamp": 1608415587
    },
    {
        "content": "<p>Yes, I could write \"the probability that a random tree is 'less than' the particular tree in question\"  as <code>CDF T</code> after defining a preorder on trees, following the development of the generalized distribution function above, which establishes that I can do so in a well-typed way.   This is very helpful for me.  Thanks!</p>",
        "id": 220524662,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608478646
    },
    {
        "content": "<p>But I think the answer to the question of why distribution function is only defined by the literature for R is in <a href=\"https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009#comment7787969_3782009\">this comment by Oliver Diaz</a> in the Wikipedia article:</p>\n<p>\"If (𝑌,𝑑) is s Borel space (a Polish space for instance) then it is measurable isomorphic to (0,1) and one can define an order in 𝑌. The isomorphism however is not explicit, it is based on constructions that use the axiom of choice.\"</p>\n<p>\"Measurable isomorphic to (0,1)\" is what I was looking for, it gives motivation for only talking about R, in the sense that talking about <code>Y</code> would be redundant under the isomorphism.</p>",
        "id": 220526880,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608482163
    },
    {
        "content": "<p>I don't think that is true at all</p>",
        "id": 220528652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608485239
    },
    {
        "content": "<p>Y can easily be something like <code>bool</code> with the preorder formulation</p>",
        "id": 220528664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608485282
    },
    {
        "content": "<p>you need a lot more assumptions to make it look like real. Borel won't cut it, Polish might but it's not clear what the reason for such an assumption is</p>",
        "id": 220528759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608485402
    }
]
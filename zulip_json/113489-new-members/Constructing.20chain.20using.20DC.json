[
    {
        "content": "<p>Hi, I'm relatively new to Lean and am currently trying to prove stuff about Noetherian rings and got stuck here:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">fractional_ideal</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n <span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R&#39;</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R&#39;</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"o\">(</span><span class=\"n\">gt</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">akey</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n          <span class=\"n\">M</span> <span class=\"err\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">I</span> <span class=\"err\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">M</span> <span class=\"bp\">&lt;</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">order_embedding</span><span class=\"bp\">.</span><span class=\"n\">well_founded_iff_no_descending_seq</span> <span class=\"n\">at</span> <span class=\"n\">wf</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">wf</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">nonempty</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"c1\">--point of h1 is to have a stronger hypothesis by requiring all terms be elements of A</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"err\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n    <span class=\"c1\">--here the fact that f(n) ∈ A needs to be used to construct f(n+1)</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">Mn</span><span class=\"o\">,</span> <span class=\"c1\">--another inductive hypothesis MninA (Mn ∈ A)</span>\n    <span class=\"o\">{</span><span class=\"c1\">--base case</span>\n      <span class=\"n\">use</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"c1\">--exact akey</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span><span class=\"c1\">--nat.succ case</span>\n    <span class=\"c1\">--rcases h&#39; Mn MninA with ⟨I, IinA, MltI⟩,</span>\n    <span class=\"c1\">--use I, exact IinA</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"c1\">--I have no idea what all these nat.rec&#39;s are</span>\n    <span class=\"c1\">--exact MltI, (by construction)</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">},</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">order_embedding</span><span class=\"bp\">.</span><span class=\"n\">nat_gt</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"c1\">--rcases h1 with ⟨f, fina, fkey⟩, --induction tactic failed, recursor &#39;Exists.dcases_on&#39; can only eliminate into  Prop</span>\n  <span class=\"c1\">--exact f, exact fkey</span>\n  <span class=\"n\">repeat</span><span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Essentially the math proof is that we can start off with <code>a</code>, and using <code>h'</code>, construct a strictly larger element of <code>A</code> ad infinitum (we also invoke axiom of dependent choice here, as our next larger elements depends on our previous).<br>\nHowever, the main roadblock is that as is, it's not possible to use <code>h'</code>, as the inductive hypothesis doesn't say anything about being members of <code>A</code>. Additionally, <code>rcases h1</code> doesn't work because it can only reduce into Prop. Any help is appreciated!</p>",
        "id": 207035347,
        "sender_full_name": "Kenji Nakagawa",
        "timestamp": 1597519444
    },
    {
        "content": "<p>I'm not at lean right now but you should delete <code>ring R'</code> because I'm pretty sure it's implied by <code>integral domain R'</code> and what you have will give R' two independent ring structures</p>",
        "id": 207035677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597520013
    },
    {
        "content": "<p>You can get <code>f</code> using <code>choose f hf using h1</code>.</p>",
        "id": 207035829,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597520241
    },
    {
        "content": "<p>More specifically, everything after the <code>have</code> block can be replaced by </p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">choose</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"kn\">using</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">order_embedding</span><span class=\"bp\">.</span><span class=\"n\">nat_gt</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">forall_and_distrib</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 207036005,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597520515
    },
    {
        "content": "<p>This is answering your specific question about the end, but clearly something with this proof is not quite right.</p>",
        "id": 207036172,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597520709
    },
    {
        "content": "<p>for some more context, this is more specifically about proving equivalence between some Neotherian module definitions (also, in a previous attempt, I tried to use <code>zorn.zorn_partial_order₀</code>, but to use it, it boiled down to proving this, and the other <code>order.zorn</code> lemmas seemed to not match well)</p>",
        "id": 207036362,
        "sender_full_name": "Kenji Nakagawa",
        "timestamp": 1597520969
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">order_embedding</span><span class=\"bp\">.</span><span class=\"n\">well_founded_iff_no_descending_seq</span> <span class=\"n\">at</span> <span class=\"n\">wf</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">wf</span><span class=\"o\">,</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R&#39;</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">M_in</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h&#39;</span> <span class=\"n\">M</span> <span class=\"n\">M_in</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">I_in</span><span class=\"o\">,</span> <span class=\"n\">hMI</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">I_in</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">hMI</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">akey</span><span class=\"bp\">⟩</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">h&#39;&#39;</span> <span class=\"n\">M</span><span class=\"o\">)),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">order_embedding</span><span class=\"bp\">.</span><span class=\"n\">nat_gt</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"err\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">h&#39;&#39;</span> <span class=\"err\">$</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"319839\">@Kenji Nakagawa</span> the <code>have h''</code> in the middle is extremely irritating, but that's the current reality, we spend a lot of time unpacking and repacking the same stuff.</p>",
        "id": 207036960,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597521802
    },
    {
        "content": "<p>Thanks a lot! Yeah, I've noticed that quite a bit of work is usually just reframing it into the right way. Hopefully relatively soon we'll have some lemmas about dedekind domains (although equivalence between definitions might take awhile yet)!</p>",
        "id": 207037294,
        "sender_full_name": "Kenji Nakagawa",
        "timestamp": 1597522326
    },
    {
        "content": "<p>I think several people are independently thinking any t Dedekind domains, i should chase up what my students are doing</p>",
        "id": 207038482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597524129
    }
]
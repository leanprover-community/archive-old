[
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">E/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> be a finite field extension, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>v</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_1,\\ldots, v_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> be a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-basis for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>. I would like to show that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> generate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> as a field over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>. I have stated this as the following lemma. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.galois</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">gen_by_basis</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h_findim</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">intermediate_field.adjoin</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">finset.univ.image</span> <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">∘</span>\n<span class=\"n\">finite_dimensional.fin_basis</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Ideally I'd like to prove the statement in its current form, because it works in the context of a larger proof, but if I've stated it in the \"wrong\" way, I'd be grateful for help fixing that too.</p>",
        "id": 265956077,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640296062
    },
    {
        "content": "<p>I think the statement's fine, although I would be tempted to put the more complex term on the left because this is the convention (<code>simp</code> lemmas simplify the LHS to the RHS). I think I'd go for <code>apply le_antisymm</code> as the first line.</p>",
        "id": 265961912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640301360
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"460212\">@Sebastian Monnet</span> What is the larger result that you are trying to prove?</p>",
        "id": 265968856,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1640309524
    },
    {
        "content": "<p>You could just use <code>set.range</code> instead of <code>finset.univ.image</code>. Here's one way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.galois</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">gen_by_basis</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h_findim</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">intermediate_field.adjoin</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">∘</span>\n<span class=\"n\">finite_dimensional.fin_basis</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">intermediate_field.adjoin_le_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">l</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hl</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">finite_dimensional.fin_basis</span> <span class=\"n\">K</span> <span class=\"bp\">↥</span><span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">e.2</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 265968880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640309577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253861\">Thomas Browning</span> <a href=\"#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265968856\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"460212\">Sebastian Monnet</span> What is the larger result that you are trying to prove?</p>\n</blockquote>\n<p>He's defining the Krull topology on Galois groups.</p>",
        "id": 265968990,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640309735
    },
    {
        "content": "<p>I guess I'm wondering what the result one level up is. When I was working in field theory, working with bases was very painful, but there were usually nice ways to work around them.</p>",
        "id": 265969094,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1640309877
    },
    {
        "content": "<p>It's the definition of the normal closure of an intermediate field E in an extension L/K as the subfield of L obtained by adjoining all the roots of the min polys of a basis.</p>",
        "id": 265969246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640310073
    },
    {
        "content": "<p>I mean, it's probably not even the normal closure in any sense, if L/K isn't normal</p>",
        "id": 265969259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640310096
    },
    {
        "content": "<p>Ah, I see. You could also adjoin all roots of all minimal polynomials, but maybe that's not as nice to work with.</p>",
        "id": 265969315,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1640310145
    },
    {
        "content": "<p>then it's not clear that if E/K is findim then NC(E)/K is</p>",
        "id": 265969324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640310170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253861\">Thomas Browning</span> <a href=\"#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265969315\">said</a>:</p>\n<blockquote>\n<p>Ah, I see. You could also adjoin all roots of all minimal polynomials, but maybe that's not as nice to work with.</p>\n</blockquote>\n<p>So, the point is that given a finite subextension extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">E/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> of some extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">L/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, I need another finite subextension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">N/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> such that for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-algebra equivalence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma:L \\to L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>, we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo>⊆</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma(E) \\subseteq N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. I have defined <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> by adjoining the roots in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> of the product of minimum polynomials of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> basis for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>, and now I'm trying to prove that indeed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo>⊆</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma(E) \\subseteq L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>. In order to do that, I need the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> is generated by its basis, from which it follows that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sigma(E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span> is generated by the image of the basis. I have almost the whole proof, dependent on this sorried lemma and also one other detail that I'm currently working on.</p>",
        "id": 265991202,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640339844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"460212\">@Sebastian Monnet</span> In your example, you are picking an arbitrary basis using choice using the finite-dimensionality assumption. I think it might be better to include an arbitrary basis in your assumptions.</p>",
        "id": 265992047,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640340766
    },
    {
        "content": "<p>In general, there should be a lemma saying that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi mathvariant=\"normal\">/</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">B/A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">A</span></span></span></span> is generated by <code>s</code> as a module, then it's also generated by <code>s</code> as algebra (or intermediate field, when this applies).</p>",
        "id": 265992097,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640340839
    },
    {
        "content": "<p>So I think you can generalise your statement a bit, which might also make it easier to prove.</p>",
        "id": 265992145,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640340856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265992047\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"460212\">Sebastian Monnet</span> In your example, you are picking an arbitrary basis using choice using the finite-dimensionality assumption. I think it might be better to include an arbitrary basis in your assumptions.</p>\n</blockquote>\n<p>Yeah that's a good point. I was hoping that lean would be just fixing a basis once and for all somewhere, but I have no idea what's going on under the hood</p>",
        "id": 265994809,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640344062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265992097\">said</a>:</p>\n<blockquote>\n<p>In general, there should be a lemma saying that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi mathvariant=\"normal\">/</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">B/A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">A</span></span></span></span> is generated by <code>s</code> as a module, then it's also generated by <code>s</code> as algebra (or intermediate field, when this applies).</p>\n</blockquote>\n<p>Good idea. Looking through the library now :)</p>",
        "id": 265994908,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640344197
    },
    {
        "content": "<p>This normal-closure-like construction should probably have its own definition and API. Right now I'm not even 100% sure that the definition above gives a well-defined object ie independent of choice of basis. Right now Sebastian is only using the construction as a temporary measure. There's a good notion of algebraic closure of an intermediate field in a bigger field but I don't know if there's a good definition of normal closure. My vague worry is that the normal closure of a sub-intermediate field equipped with a different basis might not be contained in the normal closure of the bigger field, as Sebastian has defined it (subfield generated by roots of min polys of a basis)</p>",
        "id": 265996585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640346296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/265968990\">said</a>:</p>\n<blockquote>\n<p>He's defining the Krull topology on Galois groups.</p>\n</blockquote>\n<p>Can you remind me why you need normal closure for this? I might be missing something obvious. But I think you only need to know what finite Galois subextensions are to define this topology, right?</p>",
        "id": 265997562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640347416
    },
    {
        "content": "<p>That's correct, but he's also proving that Gal(L/E) is open if E/K is finite (basically as a proof that he's defined the right topology) and to do this he is using the theory of group filter bases (which Patrick set up for us in the perfectoid project and which is now in mathlib) and it apparently shows up in the axioms there.</p>",
        "id": 265997990,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640347917
    },
    {
        "content": "<p>There's a cheap method for getting the topology of the form \"these sets should be open, now look at the group topology they generate\" but with group topologies it turns out not to be true in general that the sup of the group topologies making given sets open still has all those given sets open, there was extensive discussion about this point last week</p>",
        "id": 265998113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640348049
    },
    {
        "content": "<p>At the end of the day we want to prove the Galois correspondence for infinite extensions but I had not realised that we have still not proved that for finite extensions, the subgroup is normal iff the subfield is normal, and this construction could also be regarded as a step in the direction towards proving this</p>",
        "id": 265998242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640348252
    },
    {
        "content": "<p>Yeah, that seems like good target on the way to the infinite gc</p>",
        "id": 265998335,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640348392
    },
    {
        "content": "<p>Interestingly, Sebastian is going to end up putting a topology on Aut_K(L) for an arbitrary extension of fields L/K. It coincides with the Krull topology in the case that the extension is Galois</p>",
        "id": 265999431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640349741
    },
    {
        "content": "<p>I now wonder whether instead of working with <code>intermediate_field</code>s he could have worked with an arbitrary extension of commutative rings B/A and used subrings which were fg or Noetherian as A-modules for the basis of open sets</p>",
        "id": 266000508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640351016
    },
    {
        "content": "<p>I'm still pretty stuck on this. I've reduced the statement to the following lemma. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subalg_le_gen_by_basis</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h_findim</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">finite_dimensional.fin_basis</span> <span class=\"n\">K</span> <span class=\"bp\">↥</span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">finset.image</span> <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">finset.univ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n<span class=\"n\">E.to_subalgebra</span> <span class=\"bp\">≤</span> <span class=\"n\">algebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n   <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">E</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n   <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:=</span> <span class=\"n\">basis.mem_span</span> <span class=\"n\">b</span> <span class=\"n\">x'</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"n\">algebra.span_le_adjoin</span> <span class=\"n\">K</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n   <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>As <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> suggested, I used a lemma relating being generated as an algebra to being generated as a module, but now I basically have type-theoretic issues. Currently the hypothesis <code>hx'</code> is basically the same as the goal, but I need to map from <code>↥E</code> to <code>L</code>. I tried mapping to <code>L</code> with something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">x'</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.algebra_map</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"bp\">⇑</span><span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but this didn't work. I'm at a bit of a loss here, so I'd really appreciate any help!</p>",
        "id": 266010931,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640361992
    },
    {
        "content": "<p>opt param lets you do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">subalg_le_gen_by_basis</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">{},</span>\n</code></pre></div>\n<p>replace ℂ with something that's actually fin-dim over ℚ and you clearly have a contradiction</p>",
        "id": 266011497,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640362759
    },
    {
        "content": "<p>I think you ned to write the definition of <code>S</code> by hand</p>",
        "id": 266011503,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640362773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/266011503\">said</a>:</p>\n<blockquote>\n<p>I think you ned to write the definition of <code>S</code> by hand</p>\n</blockquote>\n<p>What do you mean by this? As in I need to just put <code>(finset.univ.image ((algebra_map ↥E L) ∘\nfinite_dimensional.fin_basis K E))</code> every time I've written <code>S</code>?</p>",
        "id": 266011656,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640362958
    },
    {
        "content": "<p>yeah</p>",
        "id": 266011666,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640362973
    },
    {
        "content": "<p>Or have \"hs : S = ...\"</p>",
        "id": 266011937,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1640363288
    },
    {
        "content": "<p>Such helper hypotheses usually work much better than relying on opt_param like (b := ...)</p>",
        "id": 266011963,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1640363343
    },
    {
        "content": "<p>this seems like a much more palatable goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subalg_le_gen_by_basis</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h_findim</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">finite_dimensional.fin_basis</span> <span class=\"n\">K</span> <span class=\"bp\">↥</span><span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">E.to_subalgebra</span> <span class=\"bp\">≤</span> <span class=\"n\">algebra.adjoin</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">finset.image</span> <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">finset.univ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n   <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">E</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n   <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:=</span> <span class=\"n\">basis.mem_span</span> <span class=\"n\">b</span> <span class=\"n\">x'</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"n\">algebra.span_le_adjoin</span> <span class=\"n\">K</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n   <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_image</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_univ</span><span class=\"o\">,</span> <span class=\"n\">set.image_univ</span><span class=\"o\">],</span>\n   <span class=\"n\">rw</span> <span class=\"n\">set.range_comp</span><span class=\"o\">,</span>\n   <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 266011993,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640363395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>  yes, that is much more palatable, thank you. I've progressed a little further and now have this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subalg_le_gen_by_basis'</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h_findim</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">finite_dimensional.fin_basis</span> <span class=\"n\">K</span> <span class=\"bp\">↥</span><span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">E.to_subalgebra</span> <span class=\"bp\">≤</span> <span class=\"n\">algebra.adjoin</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">finset.image</span> <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">finset.univ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n   <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">E</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n   <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:=</span> <span class=\"n\">basis.mem_span</span> <span class=\"n\">b</span> <span class=\"n\">x'</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"n\">algebra.span_le_adjoin</span> <span class=\"n\">K</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n   <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_image</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_univ</span><span class=\"o\">,</span> <span class=\"n\">set.image_univ</span><span class=\"o\">],</span>\n   <span class=\"n\">rw</span> <span class=\"n\">set.range_comp</span><span class=\"o\">,</span>\n   <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E.val</span> <span class=\"bp\">''</span> <span class=\"n\">set.range</span> <span class=\"bp\">⇑</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n   <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"bp\">↥</span><span class=\"n\">E</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">set.range</span> <span class=\"bp\">⇑</span><span class=\"n\">b</span><span class=\"o\">),</span>\n   <span class=\"o\">{</span>\n     <span class=\"n\">ext</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n     <span class=\"n\">split</span><span class=\"o\">,</span>\n     <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n     <span class=\"o\">},</span>\n     <span class=\"o\">{</span>\n       <span class=\"n\">intro</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n       <span class=\"n\">exact</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n     <span class=\"o\">},</span>\n   <span class=\"o\">},</span>\n   <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n   <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>What I'd like to do now is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">((</span><span class=\"n\">E.val</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"bp\">⇑</span><span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n   <span class=\"n\">submodule.map</span> <span class=\"o\">(</span><span class=\"n\">E.val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"bp\">⇑</span><span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but I can't because <code>E.val</code> is not the right kind of map. It's a <code>K</code>-algebra map and not a semilinear map over <code>K</code>. Do you have any idea how to coerce <code>E.val</code> into the form I need?</p>",
        "id": 266014230,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640366198
    },
    {
        "content": "<p><code>ext y, split, {intro hy, exact hy}, {intro hy, exact hy}</code> is just a very long way of saying <code>refl</code> :-)</p>",
        "id": 266014311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640366312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Finite.20field.20extension.20is.20obtained.20by.20adjoining.20basis/near/266014311\">said</a>:</p>\n<blockquote>\n<p><code>ext y, split, {intro hy, exact hy}, {intro hy, exact hy}</code> is just a very long way of saying <code>refl</code> :-)</p>\n</blockquote>\n<p>Good point</p>",
        "id": 266014332,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1640366396
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">((</span><span class=\"n\">E.val</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"bp\">⇑</span><span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n   <span class=\"n\">submodule.map</span> <span class=\"o\">(</span><span class=\"n\">E.val</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"bp\">⇑</span><span class=\"n\">b</span><span class=\"o\">)),</span>\n</code></pre></div>\n<p>seems to work for your h3.</p>",
        "id": 266014501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640366619
    },
    {
        "content": "<p>(I guess there's a coercion from K-algebra ring maps to K-linear module maps, and linear things are semilinear; I don't quite understand linear algebra in Lean any more ;-) )</p>",
        "id": 266014629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640366772
    }
]
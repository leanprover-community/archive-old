[
    {
        "content": "<p>Dear All,</p>\n<p>I have managed to prove the lemmas <code>prost</code> and <code>prots</code> below.  It takes a while to realize that they are different: both start with nonempty, finite sets <code>s</code> and <code>t</code>and assume that the max of <code>s</code> is less than or equal to the max of <code>t</code>.  The conclusion is that the max of either <code>(s ∪ t)</code> or of <code>(t ∪ s)</code> equals the max of <code>t</code>.  The proofs are also almost identical.  I would have liked to prove the second one by \"exchanging\" <code>s</code> and <code>t</code> with <code>rw union_comm s t</code>, and then applying the previous lemma.  However, Lean would not let me.  I think that this is because, even though the statements are symmetric, the actual arguments to show non-emptyness in the correct place need to take one of the two roads (<code>s.nonempty</code> or <code>t.nonempty</code>) and, once this choice is made, Lean cannot use the other road for the second argument.</p>\n<p>As I said, below are full proofs of the two statements, but... I can feel that there are far better ways of solving this issue!  Does anyone want to chime in?</p>\n<p>Thank you!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nonempty_union_of_nonempty_str</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.nonempty</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nonempty</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">hs_w</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_union_left</span> <span class=\"n\">t</span> <span class=\"n\">hs_h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prost</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.nonempty</span><span class=\"o\">}</span>\n <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">finset.max'</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">≤</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"n\">finset.max'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nonempty_union_of_nonempty_str</span><span class=\"bp\">;</span>\n    <span class=\"o\">{</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">max'_le</span><span class=\"o\">,</span>\n      <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mem_union</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"n\">_</span> <span class=\"n\">hst</span><span class=\"o\">,</span>\n          <span class=\"n\">apply</span> <span class=\"n\">le_max'</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n        <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">le_max'</span> <span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">le_max'</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">mem_union_right</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">max'_mem</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prots</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.nonempty</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">finset.max'</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">≤</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">finset.max'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nonempty_union_of_nonempty_str</span><span class=\"bp\">;</span>\n    <span class=\"o\">{</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">max'_le</span><span class=\"o\">,</span>\n      <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mem_union</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">le_max'</span> <span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n        <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"n\">_</span> <span class=\"n\">hst</span><span class=\"o\">,</span>\n          <span class=\"n\">apply</span> <span class=\"n\">le_max'</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">le_max'</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">mem_union_left</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">max'_mem</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 210989393,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1600861057
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prots</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.nonempty</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">finset.max'</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">≤</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset.max'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nonempty_union_of_nonempty_str</span><span class=\"bp\">;</span>\n    <span class=\"o\">{</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">finset.union_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">prost</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 210989734,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600861271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> your lines are a bit long</p>",
        "id": 210989831,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1600861323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113489-new-members/topic/.22almost.22.20equal.20proofs/near/210989831\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> your lines are a bit long</p>\n</blockquote>\n<p>Lines shortened!</p>",
        "id": 210989966,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1600861421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/.22almost.22.20equal.20proofs/near/210989734\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prots</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.nonempty</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"n\">finset.max'</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">≤</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset.max'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nonempty_union_of_nonempty_str</span><span class=\"bp\">;</span>\n    <span class=\"o\">{</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finset.max'</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">finset.union_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">prost</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n</blockquote>\n<p>Thank you!!  I did not know about <code>simp_rw</code>, I will look it up!</p>",
        "id": 210990040,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1600861451
    },
    {
        "content": "<p>the fact that you can't just use the lemma directly but need <code>apply</code> might be an indication that you should make the arguments explicit</p>",
        "id": 210990127,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1600861507
    },
    {
        "content": "<p>See what happens if you change <code>simp_rw h</code> to <code>simp only [h]</code>? These two tactics are extremely similar.</p>",
        "id": 210990131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600861513
    },
    {
        "content": "<p>I think the reason it exists, is that <code>rw</code> doesn't do what a mathematician expects it does, but something a little bit more simple. 99% of the cases, this is ok. But sometimes it fails with an error \"motive not type correct\". (Unfortunately this doesn't have anything to do with <em>motives</em>, in the sense of algebraic geometry.)<br>\nBut <code>rw</code> is quite cheap. (Only Kenny disagrees.)<br>\nSo we make a new tactic for the 1% of cases where we need the more expensive trick.</p>\n<p>(This is my lay understanding of what's going on, and why <code>rw</code> isn't a bit more powerful.)</p>",
        "id": 210990242,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600861587
    },
    {
        "content": "<p>I don't disagree that <code>rw</code> is cheap</p>",
        "id": 210990300,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1600861627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/.22almost.22.20equal.20proofs/near/210990131\">said</a>:</p>\n<blockquote>\n<p>See what happens if you change <code>simp_rw h</code> to <code>simp only [h]</code>? These two tactics are extremely similar.</p>\n</blockquote>\n<p><code>simp only [finset.union_comm]</code> works just as well as <code>simp_rw finset.union_comm</code></p>",
        "id": 210990321,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1600861645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks for exanding on the difference between <code>rw</code> and <code>simp_rw</code>!</p>",
        "id": 210990467,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1600861749
    },
    {
        "content": "<p>My point is simply that I don't know a situation where <code>simp_rw h</code> and <code>simp only [h]</code> do different things.</p>",
        "id": 210999011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600866489
    },
    {
        "content": "<p>I guess one could set h= (simp lemma).symm  :-)</p>",
        "id": 210999074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600866520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/.22almost.22.20equal.20proofs/near/210999011\">said</a>:</p>\n<blockquote>\n<p>My point is simply that I don't know a situation where <code>simp_rw h</code> and <code>simp only [h]</code> do different things.</p>\n</blockquote>\n<p>I seem to remember that <code>simp_rw [a,b,c,...]</code> is almost exactly <code>simp only [a], simp only [b], simp only [c], ...</code> (with the difference being that <code>simp_rw</code> reads in a <code>rw</code> list and lightly translates it into a form suitable for <code>simp</code>).</p>",
        "id": 211054475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600891080
    }
]
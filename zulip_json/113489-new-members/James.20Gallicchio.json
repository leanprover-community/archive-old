[
    {
        "content": "<p>Hi everybody! I'm a CS student at Carnegie Mellon, interested in formal verification and programming languages generally :)</p>\n<p>I've been writing a formalization of super basic register machines in Lean to learn the language. Starting to get to the point in that project where I should probably reach out here for help... so here I am!</p>",
        "id": 239334763,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621376404
    },
    {
        "content": "<p>Hm, so I've written a lemma which takes a couple values<br>\n<code>{ip : fin ic} {regs : vector ℕ rc}</code><br>\nand then is stated in terms of the object<br>\n<code>{ip := some ip, regs := regs} : state ic rc</code><br>\n(note the <code>some ip</code> rather than <code>ip</code>)</p>\n<p>When trying to use this lemma, I have an expression <code>step M c.s : state ic rc</code> and a hypothesis that <code>(step M c.s).ip = some ip</code>; how would I then apply the lemma?</p>",
        "id": 239896428,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621713563
    },
    {
        "content": "<p>(if this seems to indicate a fundamental issue with how I'm representing the problem, that'd also be appreciated, haha! not sure if the issue is with how I wrote out the hypotheses of the lemma or the application of the lemma or with the representation altogether)</p>",
        "id": 239896521,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621713625
    },
    {
        "content": "<p>Can you share a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 239896683,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1621713788
    },
    {
        "content": "<p><a href=\"https://gist.github.com/JamesGallicchio/87e40a3fbd0b4c7ab3c1063f558517ad\">https://gist.github.com/JamesGallicchio/87e40a3fbd0b4c7ab3c1063f558517ad</a> something like this -- I know in this mwe I can just use the definition of <code>pred_a</code>, but suppose the lemma is much less trivial than this and I want to use the lemma here instead</p>",
        "id": 239897455,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621714679
    },
    {
        "content": "<p>For the full context not mwe, this is the <code>sorry</code> I'm trying to fill<br>\n<a href=\"https://github.com/JamesGallicchio/lean_rms/blob/master/src/register_machine.lean#L229\">https://github.com/JamesGallicchio/lean_rms/blob/master/src/register_machine.lean#L229</a></p>",
        "id": 239897506,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621714706
    },
    {
        "content": "<p>oh, wait, in that mwe a simple rewrite works for applying the lemma</p>",
        "id": 239897533,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621714764
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>'s that fit inside a code block here are way more likely to get help; also the process of minimising often reveals the solution!)</p>",
        "id": 239916866,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621736529
    },
    {
        "content": "<p>Okay, I reorganized a bunch and think I have a better MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">mystruct</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mytheorem</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">mystruct</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">s.a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">s.b</span><span class=\"o\">}</span>\n  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Not sure how to fill this sorry..?</p>",
        "id": 239928934,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621751583
    },
    {
        "content": "<p>Wait, cases splits up the structure into its projections? <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> cases seems to do so much (I tried it randomly!)</p>",
        "id": 239929360,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621752067
    },
    {
        "content": "<p><code>by cases s; refl</code></p>",
        "id": 239933518,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621757096
    },
    {
        "content": "<p>So the reason cases works there is because structures are just inductive types with a single constructor; cases makes a case for that one constructor and introduces all the arguments. Right?</p>",
        "id": 239966375,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621791472
    },
    {
        "content": "<p>Hm, how do you prove to the typechecker that certain types are equivalent?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">ic</span> <span class=\"o\">:=</span> <span class=\"n\">vector.of_fn</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">ic</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">vector.append</span> <span class=\"o\">⟨[</span><span class=\"mi\">0</span><span class=\"o\">],</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">test</span>\n</code></pre></div>\n<p>Say I wanted <code>thing : vector ℕ ic.succ</code> instead.</p>",
        "id": 239987399,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621814313
    },
    {
        "content": "<p>I'm sure this has to do with my fundamentally not understanding how equality works in Lean, so any resources/pointers there would be super appreciated!</p>",
        "id": 239987416,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621814359
    },
    {
        "content": "<p>(Starting off by reading the equality section of TPIL, hopefully my answer lies in there...)</p>",
        "id": 239987686,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621814588
    },
    {
        "content": "<p>To prove two types are equivalent, you need to provide an explicit iso between them. To start, here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.vector2</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">ic</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">ic</span> <span class=\"o\">:=</span> <span class=\"n\">vector.of_fn</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">ic</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">vector.append</span> <span class=\"o\">⟨[</span><span class=\"mi\">0</span><span class=\"o\">],</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">test</span> <span class=\"n\">ic</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">thing2</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">nat</span> <span class=\"n\">ic.succ</span> <span class=\"o\">:=</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">ic</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 239987841,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621814756
    },
    {
        "content": "<p>In fact, you can use <code>equiv.cast</code> to get the iso</p>",
        "id": 239988037,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621814921
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">thing3</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">nat</span> <span class=\"n\">ic.succ</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">ic</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 239988055,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621814946
    },
    {
        "content": "<p>Ahh, cast is exactly what I needed. Thank you!</p>",
        "id": 239988362,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621815289
    },
    {
        "content": "<p>But careful, it is difficult to make proofs about structures/terms that have been constructured through complex <code>cast</code> manipulation</p>",
        "id": 239988492,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621815408
    },
    {
        "content": "<p>Hm... so my goal should be to avoid whenever possible?</p>",
        "id": 239989733,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1621816778
    },
    {
        "content": "<p>In what contexts do you need to modify types likes this? It's fine to do so if you know what you're striving for. What's your use case?</p>",
        "id": 239997958,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621825480
    },
    {
        "content": "<p>Ended up rewriting a bunch of stuff to work around casts (so far <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span>)</p>",
        "id": 240741232,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622356046
    },
    {
        "content": "<p>It was a good indication that something in my design wasn't great. Hopefully we're out of the swamp there</p>",
        "id": 240741283,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622356123
    },
    {
        "content": "<p>But now I am stuck wondering how this definition works:<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/computability/primrec.html#primcodable\">https://leanprover-community.github.io/mathlib_docs/computability/primrec.html#primcodable</a><br>\nIn my head, the <code>prim</code> type shouldn't typecheck.<br>\n<code>encodable.decode α n : option ℕ</code>, but <code>encodable.encode : ℕ → ℕ</code>... how the heck?</p>",
        "id": 240741387,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622356276
    },
    {
        "content": "<p>It's playing a bit of a trick. The type of <code>encodable.encode</code> isn't <code>ℕ → ℕ</code>, it's <code>α → ℕ</code> (for all encodable <code>α</code>), and there is an instance saying <code>option α</code> is encodable if <code>α</code> is, so it is using the <code>decode</code> instance for <code>α</code> and applying the <code>encode</code> instance for <code>option α</code> to the result.</p>",
        "id": 240744988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622362568
    },
    {
        "content": "<p>Ahh, that makes sense</p>",
        "id": 240782016,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622422358
    },
    {
        "content": "<p>I guess I have a bit of a general question about choosing representations -- in doing some indexing trickery, I'm struggling to pick between representing a certain index as <code>fin n.succ</code> or <code>option (fin n)</code>, where <code>none</code> would correspond with <code>fin.last n</code></p>\n<p>Sometimes the <code>fin n.succ</code> representation is super elegant, but other times it's easier to just case on an <code>option (fin n)</code>... is there an easy way to case on whether <code>i : fin n.succ</code> is <code>fin.last n</code> or else equals <code>i' : fin n</code>?</p>\n<p>(If not, I'm gonna go with the <code>option (fin n)</code> one since it's pretty straightforward going to the <code>fin n.succ</code> representation from there)</p>",
        "id": 240846371,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622475001
    },
    {
        "content": "<p><code>option (fin n)</code> is good, but I think the vector methods like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cons\">docs#fin.cons</a> will work best (and yes, this appends at 0 instead of at <code>n</code>: this is honestly <em>so much easier</em> to work with in Lean)</p>",
        "id": 240849172,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1622476759
    },
    {
        "content": "<p>if you wanna append at the end, there's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.snoc\">docs#fin.snoc</a> (<code>cons</code> backwards). i would <strong>strongly advise</strong> you to avoid this unless it's needed</p>",
        "id": 240849264,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1622476805
    },
    {
        "content": "<p>hmm, yeah. Lean _really_ doesn't like working at the end of the range. gonna just go with <code>option (fin n)</code></p>",
        "id": 240851914,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622478693
    },
    {
        "content": "<p>There are also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_succ_equiv\">docs#fin_succ_equiv</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_succ_equiv'\">docs#fin_succ_equiv'</a> to easily convert between the two options you said</p>",
        "id": 240851923,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622478702
    },
    {
        "content": "<p>Where <code>fin_succ_equiv</code> sends <code>0</code> to <code>none</code>, and the <code>fin_succ_equiv'</code> version lets you specify the \"hole\" explicitly.</p>",
        "id": 240852051,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622478780
    },
    {
        "content": "<p>I was looking through the fin-tuple stuff -- is there a reason why both the fin tuples are defined and <code>vector</code>? Or rather where should I prefer one over the other? I just used <code>vector</code> cuz it was what I found first</p>",
        "id": 240852085,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622478806
    },
    {
        "content": "<p>Depends on your use case. Of course, there are explicit equivs between all of these. But the API is different, and there might be different computability aspects</p>",
        "id": 240852175,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622478872
    },
    {
        "content": "<p><code>vector</code> has treated me well so far, so I'll stick with it <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> I did need a couple more quick vector lemmas that aren't in mathlib yet, but I assume the lemmas accumulate from people finding new use cases :-)</p>",
        "id": 240852343,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622479010
    },
    {
        "content": "<p>fin tuples are generally easier to use for mathematics and have a better API</p>",
        "id": 240853039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622479537
    },
    {
        "content": "<p>fin tuples can be heterogeneous as well, IIRC</p>",
        "id": 240870713,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622494815
    },
    {
        "content": "<p>Yeah; I kinda assumed that vectors would just have a better API for homogeneous tuples but maybe not <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> I'm gonna ask for feedback on my code once it's in a better state and maybe then I'll review whether I chose the wrong API :p</p>",
        "id": 240880873,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622505937
    },
    {
        "content": "<p>(I'm mostly just using the <code>nth</code> and <code>update_nth</code> functions, along with lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/data/vector2.html#vector.nth_update_nth_same\"><code>vector.nth_update_nth_same</code></a>. not sure how i'd do that with the fin tuples)</p>",
        "id": 240881201,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1622506282
    },
    {
        "content": "<p>You could use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.update\">docs#function.update</a>, with help from lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cons_update\">docs#fin.cons_update</a></p>",
        "id": 240888505,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622514691
    },
    {
        "content": "<p>Hi, back to working on this project :) is it at all possible to do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>for <code>i : fin 2</code> or similar? I see the <code>fin2</code> type which might be helpful here since it's defined inductively?</p>",
        "id": 245410984,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625816631
    },
    {
        "content": "<p>Yes, but with <code>⟨0, _⟩</code> instead of <code>0</code> etc</p>",
        "id": 245411276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625816854
    },
    {
        "content": "<p>Although often <code>![..., ...]</code> is a better way to define such a function</p>",
        "id": 245411373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625816917
    },
    {
        "content": "<p>hm,  is that <code>![]</code> syntax behind some import?</p>",
        "id": 245411520,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625817025
    },
    {
        "content": "<p>The exhaustiveness checker does not like <code>⟨0, _⟩</code> :/ I assume I'd need to have an extra case like <code>⟨n,h⟩</code> that derives bottom or something if I wanted the compiler to not complain</p>",
        "id": 245411575,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625817088
    },
    {
        "content": "<p>Notation is here: <a href=\"https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html\">https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html</a></p>",
        "id": 245411754,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1625817233
    },
    {
        "content": "<p>Oh, huh! Yeah, this could work. I'm a bit sad that the pattern match doesn't directly work, because in this context it actually is much more readable if each item is numbered...</p>",
        "id": 245411941,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625817362
    },
    {
        "content": "<p>I think Anne did add support for the equation compiler to do what you'd like here, via wf recursion</p>",
        "id": 245437358,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625834534
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.has_well_founded\">docs#fin.has_well_founded</a>. So it's like what Eric said</p>",
        "id": 245437517,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625834643
    },
    {
        "content": "<p>That instance is only needed if you actually need to recurse. If you're just case matching the equation compiler doesn't need it</p>",
        "id": 245439750,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625835870
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">instr.dec</span> <span class=\"o\">(</span><span class=\"n\">r_map</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ai_map</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The compiler complains about missing the case</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rst._match_1</span> <span class=\"n\">r</span> <span class=\"n\">_x</span> <span class=\"n\">_x_1</span> <span class=\"n\">r_map</span> <span class=\"n\">ai_map</span> <span class=\"o\">⟨</span><span class=\"n\">nat.succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>which is the absurd case. I can get around it by adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">instr.dec</span> <span class=\"o\">(</span><span class=\"n\">r_map</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ai_map</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hi.rec_on</span> <span class=\"n\">_</span> <span class=\"kd\">end</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(not sure if there's a more canonical way to use absurdity)<br>\nThis is a bit unsatisfying though, and also won't be very practical if the case is <code>n.succ.succ.succ.succ.succ.succ</code> unless there's a better way to do it in that case.</p>",
        "id": 245473407,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625852112
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> is always a good idea :-)</p>",
        "id": 245473464,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1625852160
    },
    {
        "content": "<p>ah, ye, I can strip this down, gimme a sec</p>",
        "id": 245473545,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625852197
    },
    {
        "content": "<p>We're hoping you can just give us something which compiles for us :-) (but in general your strategy of using false.elim for the cases which can't happen is the correct one, if you can't persuade the equation compiler to do it for you)</p>",
        "id": 245473580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625852221
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"one!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"two!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"c\">/-</span><span class=\"cm\"> some way to absurdity -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This doesn't quite compile, but gives the idea</p>",
        "id": 245473859,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625852386
    },
    {
        "content": "<p>You can use <code>sorry</code> to make it compile. Using the <code>rcases?</code> tactic you can prove it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"one!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"two!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">false.elim</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rcases</span> <span class=\"n\">hi</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩⟩)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 245474509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625852708
    },
    {
        "content": "<p>Haven't heard of rcases (and don't understand how it works <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> will look at that) but I think this pattern grows with the size of the constant, no? I don't plan to have particularly large constants but it's still not ideal to have to expand that each time</p>",
        "id": 245475497,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625853088
    },
    {
        "content": "<p>I'm abusing the definition of <code>&lt;</code>, which is defined as an inductive type. <code>rcases</code> is just recursive <code>cases</code>, available in the mathlib repo. The pattern grows with the size of the constant, as does your code dealing with the valid cases.</p>",
        "id": 245475783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625853241
    },
    {
        "content": "<p>The case of 2 is also absurd here, right? <code>fin 2</code> is just 0 and 1, isn't it? (I have never really worked with <code>fin</code>)</p>",
        "id": 245478885,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1625854759
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"one!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">absurd</span>\n  <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"o\">((</span><span class=\"n\">nat.le_add_left</span> <span class=\"mi\">2</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">hi</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">lt_irrefl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 245479335,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625854983
    },
    {
        "content": "<p>this is better than my solution because it doesn't increase linearly as the number gets bigger</p>",
        "id": 245479394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625855030
    },
    {
        "content": "<p>Also this generates better definitional things because it's not hidden behind a <code>match</code></p>",
        "id": 245479777,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625855196
    },
    {
        "content": "<p>Slightly shorter with <code>false.elim</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"one!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">lt_irrefl</span> <span class=\"n\">_</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">nat.le_add_left</span> <span class=\"mi\">2</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">hi</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n</code></pre></div>",
        "id": 245480305,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1625855444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/James.20Gallicchio/near/245479777\">said</a>:</p>\n<blockquote>\n<p>Also this generates better definitional things because it's not hidden behind a <code>match</code></p>\n</blockquote>\n<p>Is there a way to do that for anonymous function declarations?</p>",
        "id": 245480358,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625855472
    },
    {
        "content": "<p>For fin? I would just do matrix notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"one!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">absurd</span>\n  <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"o\">((</span><span class=\"n\">nat.le_add_left</span> <span class=\"mi\">2</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">hi</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">lt_irrefl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe'</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"s2\">\"zero!\"</span><span class=\"o\">,</span> <span class=\"s2\">\"one!\"</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">mwe</span> <span class=\"bp\">=</span> <span class=\"n\">mwe'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">fin_cases</span> <span class=\"n\">i</span><span class=\"bp\">;</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 245480826,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625855733
    },
    {
        "content": "<p>Yeah... :/ The reason I was preferring the explicit match syntax is because I'm trying to replicate a syntax that is like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">line</span> <span class=\"n\">of</span> <span class=\"n\">code</span>\n<span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">line</span> <span class=\"n\">of</span> <span class=\"n\">code</span>\n<span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">line</span> <span class=\"n\">of</span> <span class=\"n\">code</span>\n</code></pre></div>\n<p>where the lines make reference to each other. so it's helpful to have the line numbers on the side as part of the syntax (since that makes it easy to see what line 3 is, for instance). But I may just revert back to matrix notation.</p>",
        "id": 245481493,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625856045
    },
    {
        "content": "<p>You can't do self-referential definitions that rely on match.</p>",
        "id": 245481993,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625856305
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">5</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mwe</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nat.le_add_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe'</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">5</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mwe'</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nat.le_add_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"c1\">-- doesn't know about mwe'</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 245482028,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625856322
    },
    {
        "content": "<p>Because lean needs to know that the function terminates. The equation compiler can figure that out, either by structural or well-founded recursion. That isn't available in match.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mweN</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mweN</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mweN'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mweN'</span> <span class=\"n\">n</span> <span class=\"c1\">-- still doesn't know</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 245482270,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625856451
    },
    {
        "content": "<p>Yeah -- I don't mean literal self reference, just that when you say 3 in the \"code\" part it refers to line 3 of the \"program,\" so it's helpful for line 3 to be labelled with a 3. I could get what I want via the matrix notation and comments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">!</span><span class=\"o\">[</span>\n<span class=\"c\">/-</span><span class=\"cm\"> 1: -/</span> <span class=\"bp\">...</span><span class=\"o\">,</span>\n<span class=\"c\">/-</span><span class=\"cm\"> 2: -/</span> <span class=\"bp\">...</span><span class=\"o\">,</span>\n<span class=\"c\">/-</span><span class=\"cm\"> 3: -/</span> <span class=\"bp\">...</span>\n<span class=\"o\">]</span>\n</code></pre></div>\n<p>which is what I think I'll end up doing.</p>",
        "id": 245482483,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1625856578
    },
    {
        "content": "<p>fyi, match and eq compiler does not need to have the cases in \"order\" -- how could it for types that have no inherent order for the terms?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">5</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mwe</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nat.le_add_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"s2\">\"zero!\"</span>\n</code></pre></div>",
        "id": 245482756,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625856712
    },
    {
        "content": "<p><code>by linarith</code> is able to close the absurd goal too, which while slower is easier to dismiss</p>",
        "id": 245491404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625861307
    },
    {
        "content": "<p>Lots more progress on this :) I'm finally hitting the wall of stuff I don't know again, though. Weird issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n  <span class=\"bp\">@</span><span class=\"n\">sum.cases_on</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">sum.inl</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">sum.inl</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sum.inr</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">fin_cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">iterate</span> <span class=\"o\">{</span> <span class=\"gr\">admit</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm trying to prove some small fin tuples equal, but for some reason simplifying these cases does not fully evaluate...</p>",
        "id": 253999528,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632115728
    },
    {
        "content": "<p>Using <code>simp</code> on the first case reduces it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">sum.rec</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">sum.inl</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">sum.inl</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sum.inr</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is clearly still simplifiable. Not sure why it's having a hard time reducing that.</p>",
        "id": 253999614,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632115811
    },
    {
        "content": "<p>Raw <code>sum.rec</code> can block computation, because it is a dependent function. You should avoid using it and use <code>match</code> or definitions by the equation compiler instead</p>",
        "id": 254000080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632116366
    },
    {
        "content": "<p>using <code>sum.elim</code> also works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n  <span class=\"n\">sum.elim</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">sum.inl</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">sum.inl</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">sum.inr</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">fin_cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 254000185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632116482
    },
    {
        "content": "<p>Ah, okay, will give that a shot!</p>",
        "id": 254000265,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632116574
    },
    {
        "content": "<p>Another weird thing, getting this error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">type</span> <span class=\"n\">correct</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">init</span> <span class=\"o\">(</span><span class=\"n\">ic1.succ</span> <span class=\"bp\">+</span> <span class=\"n\">ic2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">fin.cast_add</span> <span class=\"n\">ic2</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"n\">_a</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">fin.cast_add</span> <span class=\"n\">ic2</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.fin</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">init</span> <span class=\"o\">(</span><span class=\"n\">ic</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">ic</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">ic</span> <span class=\"k\">with</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">none</span> <span class=\"bp\">|</span> <span class=\"n\">icp</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">0</span> <span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">map_i</span> <span class=\"o\">(</span><span class=\"n\">ic1</span> <span class=\"n\">ic2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">ic1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">ic1</span><span class=\"bp\">+</span><span class=\"n\">ic2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"n\">fin.cast_add</span> <span class=\"n\">ic2</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">ic1</span> <span class=\"n\">ic2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">init</span> <span class=\"o\">(</span><span class=\"n\">ic1.succ</span> <span class=\"bp\">+</span> <span class=\"n\">ic2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_add</span> <span class=\"n\">ic2</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">conv</span> <span class=\"o\">{</span>\n      <span class=\"n\">to_lhs</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">nat.add_comm</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>Never seen that error before, poked around on zulip and Mario had suggested using conv, but I played around and couldn't figure how to avoid it...</p>",
        "id": 254799858,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632536806
    },
    {
        "content": "<p>So the problem is that when you are trying to change <code>ic1.succ + ic2</code> into <code>ic2 + ic1.succ</code>, you would at the same time need to change the types of both sides of equation!</p>",
        "id": 254800261,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632537241
    },
    {
        "content": "<p>This is avoiding the question, perhaps, but you could use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.fin</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">init</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_add</span> <span class=\"n\">m</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 254800434,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632537403
    },
    {
        "content": "<p>(Asides: I'm not sure why you put <code>@[simp]</code> on both of your definitions. This was probably unnecessary. Also <code>map_i</code> is not needed for a MWE.)</p>",
        "id": 254800537,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632537501
    },
    {
        "content": "<p>(Ah, sorry, hangovers from when I was cutting it down). Is there a reason this needs to be by induction?</p>",
        "id": 254800939,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632537921
    },
    {
        "content": "<p>You should think a bit about this: if you could rewrite <code>n.succ + m</code> into <code>m + n.succ</code> on the LHS here, what type would you need to have on the RHS? What term would you expect to see there after the rewrite?</p>",
        "id": 254801424,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632538342
    },
    {
        "content": "<p>Mm, fair enough. I guess the other option would be to insert a cast there?</p>",
        "id": 254801490,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632538427
    },
    {
        "content": "<p>Cuz I could put a cast on both sides to <code>option (fin (n+m).succ</code></p>",
        "id": 254801611,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632538554
    },
    {
        "content": "<p>Actually, that doesn't quite make sense either, hm</p>",
        "id": 254801751,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1632538683
    }
]
[
    {
        "content": "<p>a slightly different question, is there any support for defining lean functions from standard input? For instance, is there a way to use <code>get_line</code> to read a string like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">ne</span> <span class=\"n\">n</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n<p>and turn this into a lean expression, which could be used in a tactic? I looked around in <code>tactic.expr</code> and <code>system.io</code> but I can't seem to find anything of this kind. I  can write a simple parser for now, but it would be nice to know if there's a general function or something</p>",
        "id": 212102906,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1601658903
    },
    {
        "content": "<p>You can only do this from the <code>parser</code> monad</p>",
        "id": 212112689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601664297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319223\">@Logan Murphy</span> Here's a proof of concept:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">system.io</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">lean</span> <span class=\"n\">lean.parser</span> <span class=\"n\">tactic</span> <span class=\"n\">interactive</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">from_file</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">buf</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.unsafe_run_io</span> <span class=\"o\">(</span><span class=\"n\">io.fs.read_file</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">with_input</span> <span class=\"n\">p</span> <span class=\"n\">buf.to_string</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">load_parser</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span>\n  <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">to_expr</span> <span class=\"n\">t</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">eval_expr</span> <span class=\"n\">string</span><span class=\"o\">),</span>\n  <span class=\"n\">from_file</span> <span class=\"n\">f</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.load</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">load_parser</span> <span class=\"n\">types.texpr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">interactive.exact</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">load</span> <span class=\"s2\">\"foo.txt\"</span><span class=\"o\">,</span>\n<span class=\"c1\">-- foo : ℕ → Prop := λ (n : ℕ), n ≠ 0</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>foo.txt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 212115035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601665532
    },
    {
        "content": "<p>That’s very helpful Mario, thank you very much!</p>",
        "id": 212115145,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1601665570
    },
    {
        "content": "<p>Here's a version that doesn't do any file IO and just does the string -&gt; expr part</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">lean</span> <span class=\"n\">lean.parser</span> <span class=\"n\">tactic</span> <span class=\"n\">interactive</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">parse_parser</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span>\n  <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">to_expr</span> <span class=\"n\">t</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">eval_expr</span> <span class=\"n\">string</span><span class=\"o\">),</span>\n  <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">with_input</span> <span class=\"n\">p</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.parse</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">parse_parser</span> <span class=\"n\">types.texpr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">interactive.exact</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">parse</span> <span class=\"s2\">\"λ (n : ℕ), n ≠ 0\"</span><span class=\"o\">,</span>\n<span class=\"c1\">-- foo : ℕ → Prop := λ (n : ℕ), n ≠ 0</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 212115422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601665724
    },
    {
        "content": "<p>I'm not super familiar yet with monads as a programming structure, would it be hard to write a version of <code>io.iterate</code>  as a <code>tactic unit</code>? Just looking at how it's used in <a href=\"https://agentultra.github.io/lean-for-hackers/\">Lean 3 for Hackers</a>, it would be useful to have a counter of some kind in an iteration. </p>\n<p>Specifically, the proof I'm trying to automate is of the form </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">system.io</span> <span class=\"n\">tactic</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">open</span>  <span class=\"n\">io</span> <span class=\"n\">tactic</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">aList</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">aList.length</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">aList.nth_le</span> <span class=\"n\">i.val</span> <span class=\"n\">i.property</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">aList</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">dec_trivial</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">dec_trivial</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">dec_trivial</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>It seems that the simplest way to automate this would be to iterate a counter <code>i</code> from 0  to <code>aList.length</code> (for any <code>aList</code>)</p>\n<p><code>tactic.interactive.iterate</code> allows one to specify the size of the loop, but not to refer to the counter variable</p>",
        "id": 212251791,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1601863047
    },
    {
        "content": "<p>It's easy to do unbounded iteration using a recursive function</p>",
        "id": 212256322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601870933
    },
    {
        "content": "<p>you don't need <code>io</code> for that</p>",
        "id": 212256327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601870951
    },
    {
        "content": "<p>By the way, your proof looks a lot like <code>fin_cases</code></p>",
        "id": 212256346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601870988
    },
    {
        "content": "<p>Here's a really literal interpretation of how you could automate that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">aList.length</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">aList.nth_le</span> <span class=\"n\">i.val</span> <span class=\"n\">i.property</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">aList</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mmap'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"s2\">\"h\"</span> <span class=\"bp\">++</span> <span class=\"n\">to_string</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">),</span>\n    <span class=\"n\">tactic.interactive.</span><span class=\"bp\">«</span><span class=\"k\">have</span><span class=\"bp\">»</span> <span class=\"n\">h</span> <span class=\"n\">none</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">⟨</span><span class=\"bp\">%%</span><span class=\"o\">(</span><span class=\"n\">reflect</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">dec_trivial</span><span class=\"o\">⟩))),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 212256664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601871506
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  (or anyone), would you be able to help me understand how some of the parser code you sent works? I'm not familiar with using a monad for parsing.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">system.io</span> <span class=\"n\">tactic</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">open</span>  <span class=\"n\">io</span> <span class=\"n\">tactic</span> <span class=\"n\">list</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean</span> <span class=\"n\">lean.parser</span> <span class=\"n\">tactic</span> <span class=\"n\">interactive</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">from_file</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n  <span class=\"n\">buf</span> <span class=\"bp\">←</span> <span class=\"n\">unsafe_run_io</span> <span class=\"o\">(</span><span class=\"n\">io.fs.read_file</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"c1\">-- this is clear</span>\n  <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">with_input</span> <span class=\"n\">p</span> <span class=\"n\">buf.to_string</span><span class=\"o\">,</span>  <span class=\"c1\">-- not sure what this is doing</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- returns something of type lean.parser (types.texpr)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">load_parser</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span> <span class=\"c1\">-- fine</span>\n   <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">to_expr</span> <span class=\"n\">t</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">eval_expr</span> <span class=\"n\">string</span><span class=\"o\">),</span>  <span class=\"c1\">-- not sure what this does</span>\n   <span class=\"n\">from_file</span> <span class=\"n\">f</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.load</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">load_parser</span> <span class=\"n\">types.texpr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">interactive.exact</span> <span class=\"n\">e</span>\n</code></pre></div>\n\n<p>Additionally, I'm wondering if there's a way to get expressions which are loaded by the parser in this fashion into the scope of a <code>begin...end</code> block, in the following sense. I want to parse an expression from, say a file, and call a tactic from <code>io.run_cmd</code> which sets the goal to be  something containing that expression, and prove it. For instance, I'd like to be able to write something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">add2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">silly</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">applyc</span> <span class=\"bp\">`</span><span class=\"n\">even.zero</span>\n\n<span class=\"c1\">-- input.txt :</span>\n<span class=\"c1\">-- 0</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">io</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n <span class=\"k\">let</span> <span class=\"n\">INPUT</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">load</span> <span class=\"s2\">\"/path/to/input.txt\"</span><span class=\"o\">]</span> <span class=\"k\">in</span>\n <span class=\"n\">io.run_tactic</span> <span class=\"bp\">$</span> <span class=\"k\">do</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">INPUT</span><span class=\"o\">],</span> <span class=\"n\">silly</span><span class=\"o\">,</span>\n <span class=\"n\">return</span> <span class=\"o\">()</span>\n</code></pre></div>\n\n<p>But I don't think I can refer to things like INPUT outside the [ block ] like this.</p>\n<p>Any help greatly appreciated :)</p>",
        "id": 213498072,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1602802560
    },
    {
        "content": "<p>The whole idea being that i can call <code>main</code> from some other process and see what Lean does with the contents of the file</p>",
        "id": 213498609,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1602802912
    },
    {
        "content": "<p>There are three ways you can get to <code>io</code>:  (1) A <code>main : io unit</code> def, (2) inside a tactic monad via <code>tactic.unsafe_run_io</code> and (3) inside a parser monad via <code>parser.of_tactic t</code> where <code>t</code> calls <code>tactic.unsafe_run_io</code>.  Only the parser has access to the parser monad.  However, you can make your own custom lean command which runs the parser monad and that can then get information from a file and parse it.  (You can even pass around the parser state to other monads so they can use it to parse stuff.)  I need to think through your use case and then I can give you more advice with some code.</p>",
        "id": 213499459,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602803535
    },
    {
        "content": "<p>Also, I have a fairly involved private WIP repo which uses these techniques to have lean communicate with stdin/stdout or with python as a subprocess.  If you want an invite, I can give you one.</p>",
        "id": 213499479,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602803555
    },
    {
        "content": "<p>Also, I should say that if you are only parsing simple things like numbers or such, you could also do one of the following:</p>\n<ol>\n<li>write your own parser in lean which parses a string from scratch into whatever type of object you like.  Lean has a few built in operations already for converting strings to numbers, etc, for example <code>string.to_nat</code>.  You probably want to use <code>meta</code>, but you shouldn't need to use <code>tactic</code>, <code>io</code>, or <code>parse</code> monads unless you want to use them for convenience of error handling.</li>\n<li>Use the library <code>data.buffer.parser</code> which despite its name is a <em>separate</em> parser monad from <code>lean.parser</code>.  For example, I've used this to write a JSON parser.  However, it is really slow and something Mario said, makes me think that this is a necessary consequence of using a parsing monad like this.</li>\n</ol>\n<p>Both of these are available to be used inside the <code>tactic</code> or <code>io</code> monads.  However, they don't have good support for parsing Lean expressions.</p>",
        "id": 213501540,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602805334
    },
    {
        "content": "<p>Thank you very much Jason, I'll digest this and let you know re: your repo :)</p>",
        "id": 213502039,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1602805783
    },
    {
        "content": "<p>I'll try to write code up some examples, but I don't know if I'll get to it tonight.</p>",
        "id": 213502760,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602806441
    },
    {
        "content": "<p>Oh, I just looked at Mario's code that you posted. I'll comment what the pieces are doing and show you how to use it to set the goal.  I was in the same place a few months ago.  This was all very confusing.  If you haven't read them, I also recommend the following background material:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/extras/tactic_writing.html\">https://leanprover-community.github.io/extras/tactic_writing.html</a></li>\n<li><a href=\"https://agentultra.github.io/lean-for-hackers/\">https://agentultra.github.io/lean-for-hackers/</a></li>\n</ul>",
        "id": 213516344,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602820556
    },
    {
        "content": "<p>Here is a heavily commented version of Mario's code.  Hopefully, this will help to understand what is going on.  I tried to avoid too much fancy notation to make it a bit easier to follow.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">system.io</span>\n<span class=\"kn\">open</span> <span class=\"n\">io</span> <span class=\"n\">tactic</span> <span class=\"n\">list</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean</span> <span class=\"n\">lean.parser</span> <span class=\"n\">tactic</span> <span class=\"n\">interactive</span>\n\n<span class=\"sd\">/-- Runs parser `p` on the contents of the file path `f`.</span>\n<span class=\"sd\">This parser is nonstandard.  It ignores the buffer it</span>\n<span class=\"sd\">is supposed to parse and instead does an io operation to</span>\n<span class=\"sd\">read the contents of file path `f` into another buffer</span>\n<span class=\"sd\">and runs the parser `p` on that buffer. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">from_file</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n  <span class=\"c1\">-- converts the io monad operation of reading a file</span>\n  <span class=\"c1\">-- into a parser monad operation,</span>\n  <span class=\"c1\">-- returning the file buffer.</span>\n  <span class=\"n\">buf</span> <span class=\"bp\">←</span> <span class=\"n\">unsafe_run_io</span> <span class=\"o\">(</span><span class=\"n\">io.fs.read_file</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- with_input temporarily replaces the buffer being</span>\n  <span class=\"c1\">-- parsed with a string (`buf.to_string` in this case)</span>\n  <span class=\"c1\">-- and runs the parser `p` on that string.</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">with_input</span> <span class=\"n\">p</span> <span class=\"n\">buf.to_string</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- with_input returns a pair `(a, s)` where</span>\n  <span class=\"c1\">-- `a` is the result of parser `p`</span>\n  <span class=\"c1\">-- and `s` is the string that was parsed.</span>\n  <span class=\"c1\">-- we only want to return the result `a`.</span>\n  <span class=\"n\">return</span> <span class=\"n\">a</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> This parser reads a file path from the buffer</span>\n<span class=\"cm\">(which will be a particular location in the lean</span>\n<span class=\"cm\">file where this is run)</span>\n<span class=\"cm\">as a quoted string, e.g. \"myfile.txt\", and</span>\n<span class=\"cm\">runs the parser `p` on the file contents. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">load_parser</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n   <span class=\"c1\">-- read a filename from the buffer</span>\n   <span class=\"c1\">-- as a pre-expression</span>\n   <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- that pre-expression needs to be converted</span>\n   <span class=\"c1\">-- a string.  This is usually done at the</span>\n   <span class=\"c1\">-- tactic level, but we need to stay at the parser</span>\n   <span class=\"c1\">-- level to run the parser `p` later, so we do a</span>\n   <span class=\"c1\">-- a computation in the tactic monad and lift it</span>\n   <span class=\"c1\">-- back up to the parser monad.</span>\n   <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">of_tactic</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"c1\">-- now we are in the tactic monad</span>\n      <span class=\"c1\">-- convert the pre-expression `t` to an expression `e`</span>\n      <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">to_expr</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- evaluate this expression as a string</span>\n      <span class=\"n\">s</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">eval_expr</span> <span class=\"n\">string</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- return that string as the result of this tactic block</span>\n      <span class=\"n\">return</span> <span class=\"n\">s</span>\n   <span class=\"o\">),</span>\n   <span class=\"c1\">-- run parser `p` on contents of file path `f`</span>\n   <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">from_file</span> <span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n   <span class=\"n\">return</span> <span class=\"n\">e</span>\n\n<span class=\"c1\">-- There are now two ways we can run our load_parser:</span>\n<span class=\"c1\">--   1. As the parameter of an interactive tactic.</span>\n<span class=\"c1\">--   2. Via a user command.</span>\n\n<span class=\"c1\">-- Here we do the first approach.</span>\n<span class=\"c1\">-- We will read a proof from a file and apply that</span>\n<span class=\"c1\">-- to our goal.</span>\n\n<span class=\"sd\">/-- This tactic will run a proof stored in a file.</span>\n<span class=\"sd\">Specifically `load \"myfile.txt\"` will load a proof</span>\n<span class=\"sd\">term saved in the file \"myfile.txt\" and use that</span>\n<span class=\"sd\">(inside an `exact` tactic) to complete the proof. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.load</span>\n<span class=\"c1\">-- In interative tactics, parameters take the form</span>\n<span class=\"c1\">-- `(&lt;var&gt; : parse &lt;some_parser&gt;)`</span>\n<span class=\"c1\">-- This means after the `load` tactic keyword, run</span>\n<span class=\"c1\">-- the parser `&lt;some_parser&gt;` to parse what the first</span>\n<span class=\"c1\">-- argument should be, and set `&lt;var&gt;` to be that value.</span>\n<span class=\"c1\">-- In this case, `e` will be the pre-expression</span>\n<span class=\"c1\">-- stored in the file path string which comes after</span>\n<span class=\"c1\">-- the `load` keyword.</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">load_parser</span> <span class=\"n\">types.texpr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- take our expression e (which should be a proof term)</span>\n<span class=\"c1\">-- and attempt to prove the goal with it</span>\n<span class=\"n\">interactive.exact</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n   <span class=\"n\">load</span> <span class=\"s2\">\"/tmp/my_file1.txt\"</span>  <span class=\"c1\">-- exists.intro 0 h</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 213562849,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602856449
    },
    {
        "content": "<p>Also, an object of type <code>parser α</code> is roughly a function of type <code>parser_state -&gt; parser_state × α</code>. The parser_state is essentially some buffer being parsed (i.e. usually the lean file) and the current position being read.  (It also has some information about the environment and settings, but I'm ignoring that.)  So a parser reads in a state and returns a new state and the parsed value.  The monadic stuff hides the parser state so each line <code>a &lt;- my_parser</code> in the <code>do</code> block is essentially saying run the parser on the buffer (possibly changing the parser state) and return the result <code>a</code>.  The final <code>return a</code> is saying to return <code>a : α</code>, but in actuality we aren't building an object of type α, but instead an object of type <code>parser α</code> which is itself (roughly) a function.  A parser is basically a delayed execution which will only return the result <code>a</code> at the point when it has some actual buffer to parse. This happens when it is run as part of an interactive tactic.</p>",
        "id": 213563150,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602856630
    },
    {
        "content": "<p>I'm also working on coding up your other request which reads from a file, sets the goal, and runs a tactic on that goal.</p>",
        "id": 213563192,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602856659
    },
    {
        "content": "<p>That's incredible Jason, thanks so much for taking the time to help me understand this!</p>",
        "id": 213616314,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1602883661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319223\">@Logan Murphy</span>  Here is one (of many) ways you can solve the second half of your question.  As I said above, you can't access the lean parser framework inside the io monad, so you can't use it inside tactics or a <code>main : io unit</code>.  But you can use a user command instead.  Here is an example (which reuses Mario's code above):</p>",
        "id": 213629057,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602897934
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">add2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- we break down the task into a few helper</span>\n<span class=\"c1\">-- tactics.  These might already be in mathlib.</span>\n\n<span class=\"sd\">/-- Sets the goal to the given expression,</span>\n<span class=\"sd\">ignoring the current goal. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">set_goal</span> <span class=\"o\">(</span><span class=\"n\">goal</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n   <span class=\"c1\">-- Set metavariable for our goal.</span>\n   <span class=\"n\">v</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">mk_meta_var</span> <span class=\"n\">goal</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- Replace goal list with our goal</span>\n   <span class=\"n\">set_goals</span> <span class=\"o\">[</span><span class=\"n\">v</span><span class=\"o\">],</span>\n   <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"sd\">/-- Returns tt if no more goals, else false -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">is_solved</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- the pattern ... &gt;&gt; ... &lt;|&gt; ...</span>\n<span class=\"c1\">-- is like a monadic if then else</span>\n<span class=\"n\">done</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">return</span> <span class=\"n\">tt</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">return</span> <span class=\"n\">ff</span>\n\n\n<span class=\"sd\">/-- Replaces the  current goals with `goal`,</span>\n<span class=\"sd\">applies `tac`, and returns if the goal is</span>\n<span class=\"sd\">solved. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">try_tactic_on_goal</span> <span class=\"o\">(</span><span class=\"n\">tac</span><span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">goal</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n   <span class=\"c1\">-- We will ignore the current goal</span>\n   <span class=\"c1\">-- (which is `|- true` inside a parser).</span>\n   <span class=\"n\">set_goal</span> <span class=\"n\">goal</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- For debugging:</span>\n   <span class=\"n\">trace_state</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- apply tac</span>\n   <span class=\"n\">try</span> <span class=\"n\">tac</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- For debugging:</span>\n   <span class=\"n\">trace_state</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- check if solved</span>\n   <span class=\"c1\">-- (and since this is the last tactic,</span>\n   <span class=\"c1\">-- in the do block, return it's result)</span>\n   <span class=\"n\">is_solved</span>\n\n<span class=\"sd\">/-- A user command.  It is technically a</span>\n<span class=\"sd\">parser, but we will actually be using it</span>\n<span class=\"sd\">to run some code.  However, since it is</span>\n<span class=\"sd\">a parser we can use our `from_file`</span>\n<span class=\"sd\">parser from above in the code. -/</span>\n<span class=\"kd\">@[user_command]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">main_app</span>\n<span class=\"o\">(</span><span class=\"n\">meta_info</span> <span class=\"o\">:</span> <span class=\"n\">decl_meta_info</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"main_app\"</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- the above is user command boilerplate</span>\n<span class=\"c1\">-- below is the code</span>\n<span class=\"k\">do</span>\n   <span class=\"c1\">-- get contents of file as a pre-expression</span>\n   <span class=\"n\">t</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">from_file</span> <span class=\"s2\">\"/tmp/my_file2.txt\"</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- now that we are done with the parser,</span>\n   <span class=\"c1\">-- everything else can be done in the tactic monad</span>\n   <span class=\"n\">of_tactic</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">to_expr</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n      <span class=\"n\">n</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">eval_expr</span> <span class=\"n\">ℕ</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n      <span class=\"k\">let</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">apply</span> <span class=\"n\">even.zero</span><span class=\"o\">],</span>\n      <span class=\"n\">success</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">try_tactic_on_goal</span> <span class=\"n\">tac</span> <span class=\"n\">goal</span><span class=\"o\">,</span>\n      <span class=\"k\">if</span> <span class=\"n\">success</span> <span class=\"k\">then</span>\n         <span class=\"n\">trace</span> <span class=\"s2\">\"Solved!\"</span>\n      <span class=\"k\">else</span>\n         <span class=\"n\">trace</span> <span class=\"s2\">\"Not solved :(\"</span>\n   <span class=\"o\">)</span>\n\n<span class=\"c1\">-- We put a period here to let lean know to stop</span>\n<span class=\"c1\">-- parsing the above definition.  I don't know</span>\n<span class=\"c1\">-- exactly why it is needed.</span>\n<span class=\"bp\">.</span>\n<span class=\"c1\">-- /tmp/my_file2.txt  0</span>\n<span class=\"n\">main_app</span>   <span class=\"c1\">--  |- even 0</span>\n           <span class=\"c1\">--  Solved!</span>\n</code></pre></div>",
        "id": 213629060,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602897942
    },
    {
        "content": "<p>You could run the above as a stand alone program with <code>lean your_file.lean</code>.  Right now it outputs via traces, but you could use the IO framework instead and output to stdout.  (Traces are easier to work with in VS Code.)</p>",
        "id": 213629334,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602898335
    },
    {
        "content": "<p>One thing you will notice about the above code is that all the work is done in the tactic monad, but we need the parser monad for just some key parsing tasks.  One fancy trick I've discovered is that we could \"steal\" the parser state from the parser monad and give it as an argument to a tactic.  This allows us to better organize the code.  Here is what that would look like.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Run a parser inside as a tactic.</span>\n<span class=\"sd\">It's unsafe in that you don't expect a</span>\n<span class=\"sd\">tactic to consume the buffer being parsed.</span>\n<span class=\"sd\">Best to only use with parsers that don't</span>\n<span class=\"sd\">consuming the buffer. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">unsafe_run_parser</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">parser_state</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- Since parser and tactic frameworks are</span>\n<span class=\"c1\">-- the same, can replaces the parser state</span>\n<span class=\"c1\">-- with the tactic state.</span>\n<span class=\"bp\">λ</span> <span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">tactic_state</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">ps</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">result.success</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">result.success</span> <span class=\"n\">a</span> <span class=\"n\">ts</span>\n<span class=\"bp\">|</span> <span class=\"n\">result.exception</span> <span class=\"n\">fmt</span> <span class=\"n\">pos</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">result.exception</span> <span class=\"n\">fmt</span> <span class=\"n\">pos</span> <span class=\"n\">ts</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- The tactic which does all the work -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">main_t</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">parser_state</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n   <span class=\"c1\">-- now that I have a parser state,</span>\n   <span class=\"c1\">-- I can do parser things inside tactics:</span>\n   <span class=\"n\">buf</span> <span class=\"bp\">←</span> <span class=\"n\">unsafe_run_io</span> <span class=\"o\">(</span><span class=\"n\">io.fs.read_file</span> <span class=\"s2\">\"/tmp/my_file.txt\"</span><span class=\"o\">),</span>\n   <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">unsafe_run_parser</span> <span class=\"n\">ps</span> <span class=\"o\">(</span>\n      <span class=\"n\">with_input</span> <span class=\"n\">types.texpr</span> <span class=\"n\">buf.to_string</span>\n   <span class=\"o\">),</span>\n   <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">to_expr</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n   <span class=\"n\">n</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">eval_expr</span> <span class=\"n\">ℕ</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n   <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n   <span class=\"k\">let</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">apply</span> <span class=\"n\">even.zero</span><span class=\"o\">],</span>\n   <span class=\"n\">success</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">try_tactic_on_goal</span> <span class=\"n\">tac</span> <span class=\"n\">goal</span><span class=\"o\">,</span>\n   <span class=\"k\">if</span> <span class=\"n\">success</span> <span class=\"k\">then</span>\n      <span class=\"n\">trace</span> <span class=\"s2\">\"Solved!\"</span>\n   <span class=\"k\">else</span>\n     <span class=\"n\">trace</span> <span class=\"s2\">\"Not solved :(\"</span>\n\n<span class=\"sd\">/-- Return the parser_state. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">get_state</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">parser_state</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">ps</span><span class=\"o\">,</span> <span class=\"n\">result.success</span> <span class=\"n\">ps</span> <span class=\"n\">ps</span>\n\n<span class=\"kd\">@[user_command]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">main_app2</span>\n<span class=\"o\">(</span><span class=\"n\">meta_info</span> <span class=\"o\">:</span> <span class=\"n\">decl_meta_info</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"main_app\"</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n  <span class=\"n\">ps</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">get_state</span><span class=\"o\">,</span>\n  <span class=\"n\">of_tactic</span> <span class=\"o\">(</span><span class=\"n\">main_t</span> <span class=\"n\">ps</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 213631004,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602901113
    },
    {
        "content": "<p>This trick is only good for user commands I think.  I don't think you could use it in Mario's example.</p>",
        "id": 213631061,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602901234
    },
    {
        "content": "<p>Well, whenever lean calls out to the parser monad you can do it. In my example I used tactic argument parsing to capture a <code>parser_state</code></p>",
        "id": 213631573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602902229
    },
    {
        "content": "<p>But you can’t pass that state to the body of the interactive tactic.  It would seem clearer to do the file IO in the tactic body.</p>",
        "id": 213631700,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602902487
    },
    {
        "content": "<p>Actually you can, although I have no idea what would happen if you did</p>",
        "id": 213631737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602902527
    },
    {
        "content": "<p>you can just use <code>parse read</code> where <code>def read : parser parser_state := \\lam s, (return s) s</code></p>",
        "id": 213631741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602902560
    },
    {
        "content": "<p>Oh, that probably doesn't work because <code>parser_state</code> is not serializable</p>",
        "id": 213631787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602902650
    },
    {
        "content": "<p>it doesn't implement <code>has_reflect</code> and I think this is required by <code>parse</code> because it is used during the desugaring of the tactic block to an expression that will be <code>eval_expr</code>'d</p>",
        "id": 213631801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602902719
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 213644237,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602928554
    },
    {
        "content": "<p>Sorry for all the messages.  I've been thinking about this subject a lot.  One final point I want to make (again), is that one often doesn't need the Lean parser as much as one thinks.  The one thing the lean parser is really good at is parsing \"user readable\" Lean expressions with special notation, overloaded operators, etc.  But usually what one wants to store in a file is data.  Here are two common cases:</p>\n<ul>\n<li><strong>store data in a standard format, e.g. JSON.</strong>  This is what we were doing with the setting a goal example.  We read in a number string and converted that to a number in Lean.  Using the lean parser was overkill, since we could just use <code>string.to_nat</code>.  I also just discovered that newer versions of Lean have <a href=\"https://github.com/leanprover-community/lean/blob/a5b0cb3e8e24401791905941e3d7641bc7dfd74c/library/init/meta/json.lean\">a JSON parser built in</a>.  And even if it didn't you could write your own in Lean (I'll send you an example).  This doesn't require the lean parser at all.</li>\n<li><strong>store Lean expressions as text.</strong>  This is what Mario's example does.  All we needed the lean parser for was to turn a string into an expression.  But again, we could have stored that proof term in a more machine readable form.  Lean IO has a few built-in ways to <a href=\"https://github.com/leanprover-community/lean/blob/194cc8e2416b5969cfdab4006bb9e20cb75e5adc/library/system/io.lean#L95-L99\">serialize and deserialize expressions to/from a file</a>.  Also, <a href=\"https://github.com/leanprover-community/lean/blob/653bd21db3937a4b6d7f5629923bbcf0a836692f/library/init/meta/expr.lean#L553\">one can serialize an expression to a string</a>.  The built in ones might not suit your needs, but again it is not very hard to write a serializer and deserializer for expressions in Lean that don't require the lean parser (I'll also send you an example serializing and deserializing expressions into/from s-expressions).</li>\n</ul>",
        "id": 213653921,
        "sender_full_name": "Jason Rute",
        "timestamp": 1602944141
    },
    {
        "content": "<p>This is great Jason, thank for being so thorough. This will be great for helping me move my project forward. </p>\n<p>I'm seeing how I can use your code for the particular task I'm trying to automate. I think this is only tangentially related to what you wrote, but I'm basically trying to substitute some custom structures instead of the natural numbers in the example, and trying to figure out how to resolve a <code>reflected</code> instance. I think from reading the docs that <code>reflected</code> is closely related to <code>has_repr</code>, but aside from that I'm not sure what I need to  be doing in this case.  Here are the structures I'm trying to use. </p>\n<p>If Lean just needs some string formatting for the structure, I'm happy with just using some placeholder string for now,  just don't know how to tell Lean what to use (if I understand the nature of the type class <code>reflected</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Property</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Claim</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Property</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">strategy</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Clm</span> <span class=\"o\">:</span> <span class=\"n\">Claim</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Props</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">Property</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[derive fintype]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"n\">d</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">contra</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">strategy</span> <span class=\"n\">foo</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">S.Clm.P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">S.Props.length</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">S.Props.nth_le</span> <span class=\"n\">i.1</span> <span class=\"n\">i.2</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">silly_tactic</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n <span class=\"k\">do</span>\n <span class=\"bp\">`</span><span class=\"o\">[</span>  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n     <span class=\"n\">fin_cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n     <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n     <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n     <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n     <span class=\"n\">use</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n     <span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--- path/to/input.txt file :</span>\n<span class=\"c1\">-- (strategy.mk</span>\n<span class=\"c1\">-- (Claim.mk {foo.a} (λ n, n = foo.a))</span>\n<span class=\"c1\">-- [(λ n, n=foo.b),</span>\n<span class=\"c1\">--  (λ n, n=foo.c),</span>\n<span class=\"c1\">--  (λ n, n=foo.d)])</span>\n\n\n<span class=\"kd\">@[user_command]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">main_app</span>\n<span class=\"o\">(</span><span class=\"n\">meta_info</span> <span class=\"o\">:</span> <span class=\"n\">decl_meta_info</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"main_app\"</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- below is the code</span>\n<span class=\"k\">do</span>\n   <span class=\"c1\">-- get contents of file as a pre-expression</span>\n   <span class=\"n\">t</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">from_file</span> <span class=\"s2\">\"/path/to/input.txt\"</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- now that we are done with the parser,</span>\n   <span class=\"c1\">-- everything else can be done in the tactic monad</span>\n   <span class=\"n\">of_tactic</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">to_expr</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n      <span class=\"n\">S</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">eval_expr</span> <span class=\"o\">(</span><span class=\"n\">strategy</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">contra</span> <span class=\"n\">foo</span> <span class=\"n\">S</span><span class=\"o\">),</span>\n      <span class=\"c1\">--  failed to synthesize type class instance for</span>\n      <span class=\"c1\">--  ⊢ reflected (contra foo S)</span>\n      <span class=\"k\">let</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">silly_tactic</span><span class=\"o\">],</span>\n      <span class=\"n\">success</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">try_tactic_on_goal</span> <span class=\"n\">tac</span> <span class=\"n\">goal</span><span class=\"o\">,</span>\n      <span class=\"k\">if</span> <span class=\"n\">success</span> <span class=\"k\">then</span>\n         <span class=\"n\">trace</span> <span class=\"s2\">\"Solved!\"</span>\n      <span class=\"k\">else</span>\n         <span class=\"n\">trace</span> <span class=\"s2\">\"Not solved :(\"</span>\n   <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 213802800,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603121140
    },
    {
        "content": "<p>You can <code>@[derive has_reflect]</code> on inductives</p>",
        "id": 213803805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603121588
    },
    {
        "content": "<p>Still getting the same error, should I be making a local instance like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[instance]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">contra_foo.refl</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">strategy</span> <span class=\"n\">foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_reflect</span> <span class=\"o\">(</span><span class=\"n\">contra</span> <span class=\"n\">foo</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 213805124,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603122192
    },
    {
        "content": "<p>what's the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 213805549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603122367
    },
    {
        "content": "<p>the code above is missing imports and also doesn't have a failing example</p>",
        "id": 213805611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603122401
    },
    {
        "content": "<p>If the error you are talking about is the <code>let goal</code>, you should try <code>let goal := `(contra foo %%S),</code>, since <code>S</code> is coming from the tactic context</p>",
        "id": 213806178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603122676
    },
    {
        "content": "<p>Sorry, I think this is as minimal as I can get it right now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">system.io</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">io</span> <span class=\"n\">tactic</span> <span class=\"n\">list</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean</span> <span class=\"n\">lean.parser</span> <span class=\"n\">tactic</span> <span class=\"n\">interactive</span>\n\n\n<span class=\"sd\">/-- Jason and Mario's parser code --/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">from_file</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n  <span class=\"n\">buf</span> <span class=\"bp\">←</span> <span class=\"n\">unsafe_run_io</span> <span class=\"o\">(</span><span class=\"n\">io.fs.read_file</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">with_input</span> <span class=\"n\">p</span> <span class=\"n\">buf.to_string</span><span class=\"o\">,</span>\n  <span class=\"n\">return</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">load_parser</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n   <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span>\n   <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">of_tactic</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">to_expr</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n      <span class=\"n\">s</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">eval_expr</span> <span class=\"n\">string</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"n\">return</span> <span class=\"n\">s</span>\n   <span class=\"o\">),</span>\n   <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">from_file</span> <span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n   <span class=\"n\">return</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.load</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">load_parser</span> <span class=\"n\">types.texpr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">interactive.exact</span> <span class=\"n\">e</span>\n\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">set_goal</span> <span class=\"o\">(</span><span class=\"n\">goal</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span>\n   <span class=\"n\">v</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">mk_meta_var</span> <span class=\"n\">goal</span><span class=\"o\">,</span>\n   <span class=\"n\">set_goals</span> <span class=\"o\">[</span><span class=\"n\">v</span><span class=\"o\">],</span>\n   <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"sd\">/-- My custom structures/types --/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Property</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Claim</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Property</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">strategy</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Clm</span> <span class=\"o\">:</span> <span class=\"n\">Claim</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Props</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">Property</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[derive [fintype, has_reflect]</span><span class=\"o\">]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"n\">d</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">contra</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">strategy</span> <span class=\"n\">foo</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">S.Clm.P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">S.Props.length</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">S.Props.nth_le</span> <span class=\"n\">i.1</span> <span class=\"n\">i.2</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">silly_tactic</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n <span class=\"k\">do</span>\n <span class=\"bp\">`</span><span class=\"o\">[</span>  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n     <span class=\"n\">fin_cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n     <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n     <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n     <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n     <span class=\"n\">use</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n     <span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--- path/to/input.txt file :</span>\n<span class=\"c1\">-- (strategy.mk</span>\n<span class=\"c1\">-- (Claim.mk {foo.a} (λ n, n = foo.a))</span>\n<span class=\"c1\">-- [(λ n, n=foo.b),</span>\n<span class=\"c1\">--  (λ n, n=foo.c),</span>\n<span class=\"c1\">--  (λ n, n=foo.d)])</span>\n\n\n<span class=\"kd\">@[user_command]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">main_app</span>\n<span class=\"o\">(</span><span class=\"n\">meta_info</span> <span class=\"o\">:</span> <span class=\"n\">decl_meta_info</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"main_app\"</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">lean.parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- below is the code</span>\n<span class=\"k\">do</span>\n   <span class=\"c1\">-- get contents of file as a pre-expression</span>\n   <span class=\"n\">t</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">from_file</span> <span class=\"s2\">\"/path/to/input.txt\"</span> <span class=\"n\">types.texpr</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- now that we are done with the parser,</span>\n   <span class=\"c1\">-- everything else can be done in the tactic monad</span>\n   <span class=\"n\">of_tactic</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">to_expr</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n      <span class=\"n\">S</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">eval_expr</span> <span class=\"o\">(</span><span class=\"n\">strategy</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">contra</span> <span class=\"n\">foo</span> <span class=\"n\">S</span><span class=\"o\">),</span>\n      <span class=\"c1\">--  failed to synthesize type class instance for</span>\n      <span class=\"c1\">--  ⊢ reflected (contra foo S)</span>\n      <span class=\"k\">let</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">silly_tactic</span><span class=\"o\">],</span>\n      <span class=\"n\">return</span> <span class=\"o\">()</span>\n   <span class=\"o\">)</span>\n<span class=\"bp\">.</span>\n<span class=\"n\">main_app</span>\n</code></pre></div>",
        "id": 213807791,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603123356
    },
    {
        "content": "<p>I think you actually just need <code> `(contra foo %%e),</code> and skip the eval_expr</p>",
        "id": 213808277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603123570
    },
    {
        "content": "<p>Yes, that 's what I needed . Thank you Mario.</p>",
        "id": 213808612,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603123740
    },
    {
        "content": "<p>So by using the antiquotations, we postpone the evaluation of the <code>expr</code> to when  <code>main_app</code> is invoked?</p>",
        "id": 213808811,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603123837
    },
    {
        "content": "<p>And it's the <code>expr</code> that's reflected, not anything at the object level,e.g. any <code>Prop</code></p>",
        "id": 213808885,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603123873
    },
    {
        "content": "<p>No, we never evaluate anything here</p>",
        "id": 213808971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603123918
    },
    {
        "content": "<p>so we don't need <code>has_reflect</code></p>",
        "id": 213809003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603123924
    },
    {
        "content": "<p>we're just splicing the expression <code>e</code> we elaborated directly into the term we're making</p>",
        "id": 213809065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603123950
    },
    {
        "content": "<p><code>eval_expr</code> is a way for turning expressions into values of various types, and <code>has_reflect</code> is a way to turn values back into expressions</p>",
        "id": 213809164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603124004
    },
    {
        "content": "<p>they are just canceling each other out here</p>",
        "id": 213809182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603124012
    },
    {
        "content": "<p>Now it's not entirely correct that they are inverses, for example the expression <code> `(2 + 2 : nat)</code> gets <code>eval_expr</code>'d into 4, which is then <code>reflect</code>ed into <code> `(4 : nat)</code>. So if you wanted to make sure your terms were \"normalized\" then this would be a way to do it</p>",
        "id": 213809369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603124094
    },
    {
        "content": "<p>but if you just use the expr as is you don't have to worry about all the ways in which <code>eval_expr</code> fails, for example if it runs across something noncomputable like a variable or an axiom or a pi</p>",
        "id": 213809548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603124168
    },
    {
        "content": "<p>Ah I see. Thank you.</p>",
        "id": 213809737,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603124279
    },
    {
        "content": "<p>Is there an easy way to modify a function : x -&gt; tactic x, so that it becomes x -&gt; x? For example, the function tactic.infer_type : expr -&gt; tactic expr. I'd like to create a function that does the same thing but yields 'expr' instead of 'tactic expr'.</p>\n<p>I'm aware of mjoin, but my understanding that requires 2 levels of structure in order to apply it (i.e. it's a form of concat).</p>\n<p>If you're wondering what I'm actually trying to do, I'm trying to implement the tactic 'extract_theorems' below, and the implementation I thought of requires a modification to tactic.infer_type. I wouldn't be surprised if there's a much better way to implement 'extract_theorems 'as I'm just getting started with Lean metaprogramming and don't really know what I'm doing :P, so I'd appreciate any tips. Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"kd\">meta</span><span class=\"bp\">.</span><span class=\"n\">expr</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">process_thm</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">declaration</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">declaration</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">d.to_name</span> <span class=\"k\">in</span>\n  <span class=\"k\">if</span> <span class=\"bp\">¬</span> <span class=\"n\">d.is_trusted</span> <span class=\"bp\">∨</span> <span class=\"n\">n.is_internal</span> <span class=\"k\">then</span> <span class=\"n\">none</span>\n  <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n       <span class=\"bp\">|</span> <span class=\"n\">declaration.defn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n       <span class=\"bp\">|</span> <span class=\"n\">t</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">declaration.thm</span> <span class=\"n\">n</span> <span class=\"n\">ns</span> <span class=\"n\">e</span> <span class=\"n\">te</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">t</span>\n       <span class=\"bp\">|</span> <span class=\"n\">declaration.cnst</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n       <span class=\"bp\">|</span> <span class=\"n\">declaration.ax</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n       <span class=\"kd\">end</span>\n\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">library_thms</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">$</span> <span class=\"n\">list</span> <span class=\"n\">declaration</span> <span class=\"o\">:=</span>\n  <span class=\"n\">environment.decl_filter_map</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">get_env</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">return</span> <span class=\"n\">process_thm</span>\n\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">get_all_proofs</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">$</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n  <span class=\"k\">do</span> <span class=\"n\">library_thms</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">declaration.value</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">print_proofs</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">do</span> <span class=\"n\">get_all_proofs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">tactic.trace</span> <span class=\"n\">x</span>\n\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">extract_theorems</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n  <span class=\"k\">do</span> <span class=\"n\">get_all_proofs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">exprs</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"n\">MODIFIER</span> <span class=\"n\">FOR</span> <span class=\"n\">INFER_TYPE</span><span class=\"bp\">&gt;</span> <span class=\"bp\">∙</span> <span class=\"n\">infer_type</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">exprs</span>\n\n  <span class=\"c1\">--exprs : list expr</span>\n  <span class=\"c1\">--infer_type : expr -&gt; tactic expr</span>\n  <span class=\"c1\">--&lt;MODIFIER FOR INFER_TYPE&gt; ∙ infer_type : expr -&gt; expr</span>\n  <span class=\"c1\">--(&lt;MODIFIER FOR INFER_TYPE&gt; ∙ infer_type) &lt;$&gt; exprs : list expr</span>\n</code></pre></div>",
        "id": 234232600,
        "sender_full_name": "Joe Palermo (S2'17)",
        "timestamp": 1618261998
    },
    {
        "content": "<p>You can't really change a <code>x -&gt; tactic x</code> into a <code>x -&gt; x</code>. But you can definitely change a <code>list (tactic expr)</code> into a <code>tactic (list expr)</code>, using <code>list.traverse</code></p>",
        "id": 234233573,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262542
    },
    {
        "content": "<p>An exercise for you to get a feel for such monadic transformations would be to write your own implementation of <code>list.traverse</code></p>",
        "id": 234233605,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262570
    },
    {
        "content": "<p>Also, since you're writing things with a combo of <code>&gt;&gt;=</code>, <code>&lt;$&gt;</code> and <code>return</code>, you might just switch to do notation</p>",
        "id": 234233758,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262661
    },
    {
        "content": "<p>you already have two levels of structure here, you have the tactic monad and the list monad</p>",
        "id": 234233835,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262710
    },
    {
        "content": "<p>you might want to restructure your code to have a</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declaration</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">expr</span>\n</code></pre></div>",
        "id": 234233967,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262774
    },
    {
        "content": "<p>Because your <code>get_all_proofs</code> is really a <code>tactic.map (list.map declaration.value))</code></p>",
        "id": 234234003,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262798
    },
    {
        "content": "<p>When you have a <code>&gt;&gt;= λ x, return ...</code>, that is just <code>&lt;$&gt;</code></p>",
        "id": 234234098,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262876
    },
    {
        "content": "<p>Provably: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_lawful_monad.bind_pure_comp_eq_map\">docs#is_lawful_monad.bind_pure_comp_eq_map</a></p>",
        "id": 234234185,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618262910
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Thanks for the recommendation to use list.traverse. With it I wrote up <code>proofs &gt;&gt;= λ exprs, (list.traverse tactic.infer_type exprs)</code> to get theorem exprs from proof exprs. Then I merged things together using do notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">extract_theorems</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">$</span> <span class=\"n\">list</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">library_theorem_decls</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">environment.decl_filter_map</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">tactic.get_env</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">return</span> <span class=\"n\">process_thm</span><span class=\"o\">),</span>\n  <span class=\"n\">proofs</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">library_theorem_decls</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">declaration.value</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span><span class=\"o\">)),</span>\n  <span class=\"n\">theorems</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">proofs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">exprs</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">list.traverse</span> <span class=\"n\">tactic.infer_type</span> <span class=\"n\">exprs</span><span class=\"o\">),</span>\n  <span class=\"n\">return</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">,</span> <span class=\"n\">x.to_string</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">theorems</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'd like to cleanup the line with \"proofs &lt;- ...\", using <a href=\"http://tactic.map\">tactic.map</a> as recommended, but I get the error message \"unknown identifier '<a href=\"http://tactic.map\">tactic.map</a>'\". I tried <code>import tactic</code>, but apparently there is no <a href=\"http://tactic.map\">tactic.map</a>? Not sure what I'm doing wrong</p>",
        "id": 234336433,
        "sender_full_name": "Joe Palermo (S2'17)",
        "timestamp": 1618324503
    },
    {
        "content": "<p>If you have a</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span>\n  <span class=\"n\">var</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">op</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>that is the same at</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">var</span> <span class=\"o\">:=</span> <span class=\"n\">op</span>\n</code></pre></div>",
        "id": 234337584,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618324840
    },
    {
        "content": "<p>There is no <code>tactic.map</code>, I just meant <code>functor.map</code> specialized to <code>functor</code>, which you can just write as <code>&lt;$&gt;</code></p>",
        "id": 234337695,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618324886
    },
    {
        "content": "<p>Your <code>&lt;*&gt; return ...</code> can also be simplified to a <code>&lt;$&gt;</code>: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_lawful_applicative.seq_pure\">docs#is_lawful_applicative.seq_pure</a></p>",
        "id": 234337992,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618324992
    },
    {
        "content": "<p>What about something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">decl_to_theorem</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">declaration</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">infer_type</span> <span class=\"n\">d.value</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">extract_theorems</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">$</span> <span class=\"n\">list</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">env</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tactic.get_env</span>\n  <span class=\"k\">let</span> <span class=\"n\">ds</span> <span class=\"o\">:=</span> <span class=\"n\">env.decl_filter_map</span> <span class=\"n\">process_thm</span>\n  <span class=\"n\">theorems</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">ds.traverse</span> <span class=\"n\">decl_to_theorem</span>\n  <span class=\"n\">return</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">,</span> <span class=\"n\">x.to_string</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">theorems</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234339546,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618325522
    },
    {
        "content": "<p>That's much cleaner! Thank you</p>",
        "id": 234341069,
        "sender_full_name": "Joe Palermo (S2'17)",
        "timestamp": 1618325963
    },
    {
        "content": "<p>Modulo any errors, I'm just guessing the types/API here. One might say, why not just make a <code>decl -&gt; tactic string</code> and print over those?</p>",
        "id": 234343149,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618326321
    },
    {
        "content": "<p>Yeah that would be a reasonable way to structure it too</p>",
        "id": 234343737,
        "sender_full_name": "Joe Palermo (S2'17)",
        "timestamp": 1618326447
    },
    {
        "content": "<p>I gather you'll be printing these. I think you should just use <code>list.intersperse theorems \"\\n\"</code>, that way you're not just doing the many O(n) list appends, since you're just relying on the \"\\n\" for nice printing</p>",
        "id": 234343738,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618326447
    },
    {
        "content": "<p>Then you might factor out <code>env &lt;- tactic.get_env</code> to make a <code>env -&gt; tactic (list string)</code>, because you might be doing other things with an env</p>",
        "id": 234343991,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618326500
    },
    {
        "content": "<p>So that you don't have to <code>tactic.get_env</code> elsewhere (if that is an expensive computation, idk if it is)</p>",
        "id": 234344086,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618326523
    }
]
[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">):</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">):</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">fapply</span> <span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>in this stupid theorem, i want to replace <code>3</code> with the <code>a</code> given by <code>test</code>, how should i write?</p>",
        "id": 169009150,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1561537437
    },
    {
        "content": "<p>you can't take out what you put in the proof of an existential statement</p>",
        "id": 169009211,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561537507
    },
    {
        "content": "<p>huh? but then how should we define a number x+1, in which the existence of x is guaranteed by some previous theorem A?</p>",
        "id": 169009349,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1561537678
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">choice</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">choice</span> <span class=\"n\">C</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero_ne_one</span> <span class=\"err\">$</span> <span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n<span class=\"k\">calc</span>  <span class=\"mi\">0</span>\n    <span class=\"bp\">=</span> <span class=\"n\">choice</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">choice</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>                           <span class=\"o\">:</span> <span class=\"n\">spec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"n\">rfl</span>\n</pre></div>",
        "id": 169009421,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561537723
    },
    {
        "content": "<p>this is because of proof irrelevance, where two proofs of the same theorem are definitionally equal</p>",
        "id": 169009433,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561537739
    },
    {
        "content": "<p>so in particular two witnesses result in the same proof of the existential.</p>",
        "id": 169009452,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561537774
    },
    {
        "content": "<p>but you can use a <code>subtype</code> to retain the witness:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">//</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">test</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 169009640,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561537974
    },
    {
        "content": "<p>But if you want only want to use the witness a in a proof of something else then you can say <code>cases test with a ha,</code></p>",
        "id": 169009773,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1561538115
    },
    {
        "content": "<p>oh right</p>",
        "id": 169009842,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561538163
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">test</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">two_mul</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">bit0_inj</span> <span class=\"n\">ha</span> <span class=\"o\">},</span>\n  <span class=\"n\">subst</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 169009995,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561538296
    },
    {
        "content": "<p>i see, thanks!!</p>",
        "id": 169010235,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1561538534
    },
    {
        "content": "<blockquote>\n<p>you can't take out what you put in the proof of an existential statement</p>\n</blockquote>\n<p>Don't listen to the constructivist!</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">):</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">):</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">choose</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"kn\">using</span> <span class=\"n\">test</span> <span class=\"mi\">37</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  1 goal</span>\n<span class=\"cm\">  x a : ℕ,</span>\n<span class=\"cm\">  ha : 2 * a = 4</span>\n<span class=\"cm\">  ⊢ ∃ (b : ℕ), 3 * b = 6</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>[why does test take an input which is never used?]</p>",
        "id": 169017943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561546613
    },
    {
        "content": "<p>You don't need <code>choose</code> here, just <code>cases</code> which was mentioned earlier</p>",
        "id": 169018082,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561546793
    },
    {
        "content": "<p>Sure, but this is a refutation of Kenny's claim \"you can't take out what you put in the proof of an existential statement\". The issue with <code>choose</code> is that it is noncomputable (Lean actually forgot <code>a</code> once it had checked your proof, so there is no algorithm for getting it back).</p>",
        "id": 169018211,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561546890
    },
    {
        "content": "<p>but my point was that you can't take out what you <strong>put in</strong>, i.e. the explicit witness you constructed</p>",
        "id": 169024194,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561552301
    },
    {
        "content": "<p>contrary to maths where you can always destruct an existential to get data</p>",
        "id": 169024208,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561552318
    },
    {
        "content": "<p>I don't know that in maths the behavior is much different from <code>choose</code></p>",
        "id": 169024328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561552410
    },
    {
        "content": "<p>Except possibly that you can prove additional properties to put in the existential after the fact</p>",
        "id": 169024390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561552457
    },
    {
        "content": "<p>but this is more of a proof structuring thing</p>",
        "id": 169024400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561552470
    },
    {
        "content": "<p>I think the situation in real maths is just that if you constructed an existential by directly producing a term, then if you ever need it later you're allowed to remember your proof and the element</p>",
        "id": 169024920,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1561552867
    },
    {
        "content": "<p>It's even better than that, we're even allowed to say \"By the proof of Theorem 3.2, ...\"</p>",
        "id": 169025554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561553372
    },
    {
        "content": "<p>how to prove that </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>  <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>? library search gives nothing</p>",
        "id": 169126576,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1561636003
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n  <span class=\"n\">funext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 169126707,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561636139
    },
    {
        "content": "<p>Or in term mode: <code>funext $ _</code></p>",
        "id": 169126736,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561636179
    },
    {
        "content": "<p>i see</p>",
        "id": 169126860,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1561636276
    },
    {
        "content": "<p>Why does <code>rfl</code> fail?</p>",
        "id": 169128301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561637409
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>  <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- type mismatch</span>\n</pre></div>",
        "id": 169128318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561637434
    },
    {
        "content": "<p>the first one is <code>i+1</code> and the second one is <code>1+i</code></p>",
        "id": 169128834,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561637912
    },
    {
        "content": "<p>oh thanks. Duh.</p>",
        "id": 169129325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561638397
    },
    {
        "content": "<p>The colours played a trick on my brain somehow</p>",
        "id": 169129343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561638414
    },
    {
        "content": "<p>Whoever made the courier new typeface has caused at least billions of dollars of damage with how close <code>i</code> and <code>1</code> look</p>",
        "id": 169129922,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1561638906
    },
    {
        "content": "<p>wouldn't <code>1</code> and <code>l</code> be deadlier?</p>",
        "id": 169137953,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1561644520
    },
    {
        "content": "<p>1ucki1y l is 1ess common in programming</p>",
        "id": 169140519,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1561646200
    },
    {
        "content": "<p>is it illegal to delcare a long literal in Java with a lower case <code>l</code>?</p>",
        "id": 169284881,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1561790082
    },
    {
        "content": "<p>If no, that's a good one</p>",
        "id": 169284883,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1561790087
    },
    {
        "content": "<p>that's legal</p>",
        "id": 169285287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561790989
    },
    {
        "content": "<p>There's an entire class of \"off-by-<code>l</code>\" errors</p>",
        "id": 169285741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561791927
    },
    {
        "content": "<p>Hi guys, I want to use the heterogeneous equality but cannot derive it to homogeneous equality. i.e. can we define the following?</p>\n<div class=\"codehilite\"><pre><span></span>    <span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n              <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 171379559,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1563728010
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n              <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</pre></div>",
        "id": 171379702,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563728247
    },
    {
        "content": "<p>You don't need the assumption <code>α = β</code>, it's implied by <code>x == y</code></p>",
        "id": 171379869,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563728462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> ah, thanks. but how about another way?</p>",
        "id": 171379885,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1563728516
    },
    {
        "content": "<p>wait, if we don't need <code>p : α = β</code>, then how can we express <code>(eq.rec_on p x : β) = y</code>?</p>",
        "id": 171380013,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1563728699
    },
    {
        "content": "<p>You could write <code>eq.rec_on (type_eq_of_heq (h : x == y)) x</code></p>",
        "id": 171380034,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563728754
    },
    {
        "content": "<p>Hi, there. Can anyone tell me why the following example doesn't work?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span> <span class=\"n\">rw</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">reflexivity</span> <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>after <code>rw p</code> the goal is <code>unit → β = unit → β</code> but <code>reflexivity</code> doesn't work.</p>",
        "id": 171419680,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1563791658
    },
    {
        "content": "<p>Brackets</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span> <span class=\"n\">rw</span> <span class=\"n\">p</span> <span class=\"kn\">end</span>\n</pre></div>",
        "id": 171419725,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563791730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> wow, such a silly mistake. Thank you</p>",
        "id": 171419787,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1563791801
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"o\">()</span> <span class=\"kn\">end</span>\n</pre></div>",
        "id": 171420094,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563792187
    },
    {
        "content": "<p>Does lean have something like the following in standard library or mathlib?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">uip</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>if not, how can we prove this?</p>",
        "id": 171453375,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1563818811
    },
    {
        "content": "<p><code>rfl</code></p>",
        "id": 171453408,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563818850
    },
    {
        "content": "<p>this is called proof irrelevance and is built into Lean</p>",
        "id": 171453437,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563818858
    },
    {
        "content": "<p>it says that two proofs of the same proposition are definitionally equal</p>",
        "id": 171453453,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563818867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> , thank you :)</p>",
        "id": 171453510,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1563818887
    },
    {
        "content": "<p>I have a problem with unfolding tactic. Considering the following code</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">nodes</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">srctrg</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"n\">nodes</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">prism_graph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">nodes</span>  <span class=\"o\">:=</span> <span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">nodes</span>\n  <span class=\"o\">,</span> <span class=\"n\">edges</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edges</span><span class=\"o\">)</span> <span class=\"err\">⊕</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">nodes</span>\n  <span class=\"o\">,</span> <span class=\"n\">srctrg</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n                     <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">b&#39;</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">srctrg</span> <span class=\"n\">b&#39;</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n                     <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">v</span><span class=\"o\">)</span>       <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n                     <span class=\"kn\">end</span>\n  <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">cube_graph</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">graph</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>      <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"o\">())</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">prism_graph</span> <span class=\"o\">(</span><span class=\"n\">cube_graph</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">cube_graph</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodes</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"o\">(</span><span class=\"n\">graph</span><span class=\"bp\">.</span><span class=\"n\">srctrg</span> <span class=\"o\">(</span><span class=\"n\">cube_graph</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">cube_graph</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I don't understand why <code>unfold cube_graph</code> fails. Clearly, it should succeed with the goal become <code>(graph.srctrg (prism_graph (cube_graph n)) b (sum.inr v)) = (b, v)</code>.</p>\n<p>Ps. You might argue that I can close this tactic by <code>refl</code> but my point is to use <code>unfold</code>. The reason is that this is the simplified version of the actual problem that I am working and I can't just use <code>refl</code>.<br>\nPs2. This is another question. If <code>refl</code> works, why <code>simp</code> doesn't. Isn't <code>simp</code> use <code>refl</code> at the end anyway?</p>",
        "id": 171680724,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1564051957
    },
    {
        "content": "<p>You're expecting too much from unfold. What you want here is <code>dsimp [cube_graph]</code>.</p>",
        "id": 171681264,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1564052559
    },
    {
        "content": "<p>About your second question, maybe <code>simp</code> is actually doing some thing which turns your goal into a non-refl goal.</p>",
        "id": 171681280,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1564052598
    },
    {
        "content": "<p>You can use <code>dunfold</code>. The reason <code>simp</code> doesn't work, is because <code>graph.srctrg</code> is a dependent function, so the expression after rewriting only typechecks because <code>cube_graph (n + 1) = prism_graph (cube_graph n)</code> is s definitional equality.</p>",
        "id": 171681287,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1564052629
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  Thank you for introducing <code>dsimp</code> and <code>dunfold</code> to me.</p>\n<p>Another question, if I have two occurrences of the same<br>\ndefinition in a goal. <code>(d)unfold</code> once will affect the first<br>\noccurrence an not the second, if I want another way (i.e. affect the second<br>\none and not the first one) what should I do?</p>",
        "id": 171690621,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1564061022
    },
    {
        "content": "<p>Definitional unfolding is all defeq, so if your goal does not look like what you want it to look like, you can just write <code>change &lt;what you want the goal to look like&gt;</code> and if what you write is definitionally equal to what the goal is, the goal will change to what you write. Note that <code>show</code> is synonymous with <code>change</code>, although you can use <code>change</code> on hypotheses as well.</p>",
        "id": 171690749,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564061141
    },
    {
        "content": "<p>The other approach for zooming in on terms in goals is <code>conv</code> mode:  <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md\">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md</a></p>",
        "id": 171690838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564061201
    },
    {
        "content": "<p>I don't know how much you know about definitional equality v all the other equalities, but here's something I wrote about definitional equality: <a href=\"https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/\">https://xenaproject.wordpress.com/2019/05/21/equality-part-1-definitional-equality/</a></p>",
        "id": 171690925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564061273
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span>  <span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span>  Thank you for introducing <code>dsimp</code> and <code>dunfold</code> to me.</p>\n<p>Another question, if I have two occurrences of the same<br>\ndefinition in a goal. <code>(d)unfold</code> once will affect the first<br>\noccurrence an not the second, if I want another way (i.e. affect the second<br>\none and not the first one) what should I do?</p>\n</blockquote>\n<p>Do you have an example of this. Usually I think it unfolds all occurrences, so it might be not unfolding the second one for some other reason.</p>",
        "id": 171691021,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1564061334
    },
    {
        "content": "<p>Another thing you might want to know is that if you type <code>#print prefix cube_graph</code> then you can see all the stuff that Lean generated for you when you made <code>cube_graph</code>. Things called <code>cube_graph._equation.1</code> or something (I forget what they're exactly called) are the things which Lean tries to use when you run <code>unfold</code> -- that's what the tactic actually does.  Similarly <code>dsimp [cube_graph]</code> tries to simplify using those \"hidden\" equation lemmas.</p>",
        "id": 171691194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564061479
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thank you for introducing <code>change</code> and <code>conv</code>. These what tactics that I have been looking for many days. It is also interesting to know that we can even unfold anonymous functions as well. </p>\n<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  I have but it is in a long file and it can be the case that the second occurrence is not unfoldable at the moment so I miss understood the behaviour of <code>(d)unfold</code> .</p>",
        "id": 171691501,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1564061733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"144193\">@Gun Pinyo</span> you should definitely read through the general <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md\">mathlib tactic documentation</a></p>",
        "id": 171700078,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1564067628
    },
    {
        "content": "<p>If I am in the tactic mode with 2 goals. Is there any tactic that lets me prove the second goal before the first one?<br>\nThe motivation behind this is when the second goal is a lot easier than the first one.</p>\n<p>Ps. I have read through <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md\">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md</a> but didn't find any.</p>",
        "id": 171840194,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1564224496
    },
    {
        "content": "<p><code>swap</code></p>",
        "id": 171840196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564224511
    },
    {
        "content": "<p>Once you've got it working, hover over the tactic to see the docstring.</p>",
        "id": 171840209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564224536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Thank you.<br>\nSo there are more tactics that are not in mathlib. Where can I find the documentation of these built-in tactics?<br>\nAt first, I thought every built-in tactic should be in <a href=\"https://leanprover.github.io/reference/tactics.html\" target=\"_blank\" title=\"https://leanprover.github.io/reference/tactics.html\">https://leanprover.github.io/reference/tactics.html#</a> but it is not the case for <code>swap</code>.</p>",
        "id": 171840339,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1564224767
    },
    {
        "content": "<p>Maybe <code>swap</code> is in core Lean? You can just right click on it to check.</p>",
        "id": 171840390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564224850
    },
    {
        "content": "<p>A great place for learning about core tactics is the book Theorem Proving In Lean.</p>",
        "id": 171840394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564224880
    },
    {
        "content": "<p>It would be good to add <code>swap</code> and any other missing core tactics to that doc page. Maybe for now we should just add a comment to this issue <a href=\"https://github.com/leanprover-community/mathlib/issues/450\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/450\">https://github.com/leanprover-community/mathlib/issues/450</a></p>",
        "id": 171840539,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1564225166
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I agree, that was what I did before starting my current project.<br>\nBut again, it doesn't mention <code>swap</code>.</p>",
        "id": 171840543,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1564225193
    },
    {
        "content": "<p>Oh, btw, <code>swap</code> is defined in mathlib and not the builtin one. <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/interactive.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/interactive.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/interactive.lean</a></p>",
        "id": 171840747,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1564225445
    },
    {
        "content": "<p>If I recall, core defines <code>tactic.swap</code> but does not expose to interactive?</p>",
        "id": 171846042,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1564235309
    },
    {
        "content": "<p>This might be a very stupid question but why can't we add univalence axiom to lean3? i.e. why axiom K of lean3 doesn't play well with the univalence axiom?</p>",
        "id": 172680308,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565186462
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 172680357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565186497
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 172680391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565186521
    },
    {
        "content": "<p>This has been talked about before and I know it's inconsistent but I don't know why. It's something to do with impredicativity of Prop</p>",
        "id": 172680490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565186573
    },
    {
        "content": "<p>Because equality is a subsingleton, and univalence says it is isomorphic to something which is not a subsingleton. Even if you define a equality to return a type, rather than a Prop, this is still provably a subsingleton (the proof uses the proof irrelevant version of eq).</p>",
        "id": 172681053,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565187023
    },
    {
        "content": "<p>I think <code>α ≃ β → α = β</code> is consistent though, but not very useful.</p>",
        "id": 172681138,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565187091
    },
    {
        "content": "<p>So is even my undeleted post incorrect?</p>",
        "id": 172681498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565187358
    },
    {
        "content": "<p>Because <code>α = β → α ≃ β</code> is a theorem</p>",
        "id": 172681580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565187396
    },
    {
        "content": "<p>Those two function aren't inverses of each other in Lean, but univalence says they are.</p>",
        "id": 172681735,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565187495
    },
    {
        "content": "<p>Surely <code>α ≃ β → α = β</code> would be useful in Lean, because it would enable me to show that if R and S are isomorphic rings and R is Noetherian local then S is Noetherian local?</p>",
        "id": 172681847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565187597
    },
    {
        "content": "<p>You also need the ring structures to be <code>heq</code> for that. Which won't be provable.</p>",
        "id": 172681963,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565187676
    },
    {
        "content": "<p>So you can't get from the bare <code>α ≃ β → α = β</code> statement about types to statements about isomorphic groups being equal groups by using some kind of trickery?</p>",
        "id": 172682115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565187811
    },
    {
        "content": "<p>I would imagine that in HoTT they can do this somehow</p>",
        "id": 172682140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565187833
    },
    {
        "content": "<p>I don't think so. In Lean, you have no idea what <code>eq.mp</code> gives you. In HoTT, you know from the <code>right_inv</code> part of the univalence equivalence, that <code>eq.mpr</code> is <code>to_fun</code> of your bijection. Then you can prove that <code>eq.rec one_ring_strcuture = the_other_ring_structure</code></p>",
        "id": 172682305,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565187950
    },
    {
        "content": "<p>In the univalence equivalence <code>inv_fun := eq.mp</code>. The axiom says that <code>eq.mp</code> has a two sided inverse.</p>",
        "id": 172682587,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565188151
    },
    {
        "content": "<p>In answer to the original question: from univalence you can show that <code>bool = bool</code>  has two unequal elements (one corresponding to the identity function, and one corresponding to the function that swaps the elements), which contradicts axiom K.</p>",
        "id": 172692268,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1565194791
    },
    {
        "content": "<p>And I'm quite sure that Chris is right that weak univalence (<code>α ≃ β → α = β</code>) doesn't give you that isomorphic groups are equal.</p>",
        "id": 172692548,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1565194996
    },
    {
        "content": "<p>Hi, there. Regarding defined class in stdlib, many of them have one field. I try to understand why don't you just use <code>def</code> with <code>@[class]</code>? For example, </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">inhabited&#39;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n</pre></div>\n\n\n<p><code>inhabited'</code> should be as usable as <code>inhabited</code> but we also don't need to write the constructor. </p>\n<p>There are some classes that way such as in <code>library/init/relator.lean</code>. I can see the advantage of using the letter way but haven't seen the advantage of the former way. Could you please explain to me please?</p>",
        "id": 172929865,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565452665
    },
    {
        "content": "<p>&lt;deleted&gt;</p>",
        "id": 172953836,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1565499942
    },
    {
        "content": "<p>&lt;deleted&gt;</p>",
        "id": 172953987,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1565500242
    },
    {
        "content": "<p>&lt;deleted&gt;</p>",
        "id": 172954210,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1565500686
    },
    {
        "content": "<p>One difference is that <code>inhabited' α</code> is definitionally equal to <code>α</code>, while <code>inhabited α</code> is not (it is equivalent to <code>α</code>, in the sense that <code>equiv (inhabited α) α</code> can be proven). <br>\nSometimes extra definitional equalities are convenient, but sometimes they have downsides. It is possible that the elaborator of Lean will unfold <code>inhabited'</code> in places where you didn't want to, and then you are not talking about the type <code>inhabited' α</code> anymore, but about <code>α</code>. The latter is not a class, which might cause issues with type class inference not firing.<br>\nSince <code>inhabited</code> is not a definition, it can never be unfolded.</p>",
        "id": 172954397,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1565501137
    },
    {
        "content": "<p>This is a much better explanation of why, haha.</p>",
        "id": 172954454,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1565501268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> , how about we add <code>@[irreducible]</code> to <code>inhabited' α</code>, would it solved the problem with unwanted unfolding?</p>",
        "id": 172971447,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565534603
    },
    {
        "content": "<p>In that case there won't be much advantage of the <code>def</code> over the single-field <code>class</code></p>",
        "id": 172973230,
        "sender_full_name": "Reid Barton",
        "timestamp": 1565538143
    },
    {
        "content": "<p>That would also be fine. But as Reid said: if you don't want to unfold it, you can just as well make it a structure.</p>",
        "id": 172976066,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1565543577
    },
    {
        "content": "<p>Well, my point is that I don't want to keep writing <code>.intro</code> or something like that.</p>",
        "id": 172976425,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565544237
    },
    {
        "content": "<p>Angle bracket notation doesn't work for you?</p>",
        "id": 172976915,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1565545192
    },
    {
        "content": "<p>If you marked it irreducible you'd have to define an<code>intro</code> and use that.</p>",
        "id": 172977345,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565545937
    },
    {
        "content": "<p>I just discover that we can write numerals as elements of <code>fin</code><br>\ntype. So I want to refactor the following code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_succ</span> <span class=\"n\">n</span><span class=\"bp\">⟩</span>\n<span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth_zero</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span> <span class=\"n\">a</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">l</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span><span class=\"o\">,</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span><span class=\"o\">],</span>\n  <span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth_zero&#39;</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">l</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[{</span><span class=\"bp\">!</span><span class=\"n\">what</span> <span class=\"n\">should</span> <span class=\"n\">be</span> <span class=\"n\">here</span><span class=\"err\">?</span><span class=\"bp\">!</span><span class=\"o\">},</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span><span class=\"o\">,</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span><span class=\"o\">],</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p><code>vector.insert_nth_zero'</code> is the same as <code>vector.insert_nth_zero</code><br>\nexcept that <code>fin.zero</code> is changed to <code>0</code>. Everything should be fine, however, I don't know there to replace <code>fin.zero</code> in <code>simp</code> tactic now. Does anyone know how to fix this?</p>",
        "id": 173217032,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565798817
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth_zero&#39;</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">l</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span><span class=\"o\">],</span> <span class=\"n\">norm_cast</span>\n  <span class=\"kn\">end</span>\n</pre></div>",
        "id": 173221599,
        "sender_full_name": "Joe",
        "timestamp": 1565802110
    },
    {
        "content": "<p>or maybe this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth_zero&#39;</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"n\">l</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span><span class=\"o\">,</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_mk</span><span class=\"o\">],</span>\n    <span class=\"k\">show</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">insert_nth</span><span class=\"o\">]</span>\n  <span class=\"kn\">end</span>\n</pre></div>",
        "id": 173221946,
        "sender_full_name": "Joe",
        "timestamp": 1565802345
    },
    {
        "content": "<p>I still have another question regarding <code>fin</code>.  Sometimes, I want to use pattern matching on <code>i : fin n</code> in the same way as one will do in <code>ℕ</code> but since the inductive part is in <code>i.val</code> so I need to do as follows:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">fin_is_even</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>      <span class=\"n\">i</span>                        <span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">elim0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span>    <span class=\"bp\">_⟩</span>                <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"n\">i_val</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">succ_i_is_lt</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span>\n     <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">i_val</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pred_le_pred</span> <span class=\"n\">succ_i_is_lt</span><span class=\"bp\">⟩</span>\n      <span class=\"k\">in</span> <span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">fin_is_even</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Ok it works, but in practice, I find it quite annoying to write <code>let i : fin n := ⟨i_val, nat.pred_le_pred succ_i_is_lt⟩</code> every time whereas <code>i</code> should be obtained directly from something like <code>fin.succ i</code>. Therefore, I try to use <code>@[pattern]</code> to help me with this as follows:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_succ</span> <span class=\"n\">n</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fin_is_even&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>      <span class=\"n\">i</span>            <span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">elim0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">zero</span>     <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">fin_is_even&#39;</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>However I get an error, what is wrong with my code?  Did I misunderstand anything about <code>@[pattern]</code>?</p>\n<p>err msg1:<br>\n<code>invalid function application in pattern, it cannot be reduced to a constructor (possible solution, mark term as inaccessible using '.( )')</code><br>\nerr msg2:<br>\n<code>don't know how to synthesize placeholder\ncontext:\nfin_is_even' : Π (n : ℕ), fin n → bool\n⊢ fin n</code></p>",
        "id": 173292870,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565877758
    },
    {
        "content": "<p>You're basically expecting the equation compiler to determine whether an element of <code>fin n</code> is in the image of <code>fin.succ</code> or not, and if it is what the element that maps to it is. This is very hard in general. I think the <code>pattern</code> attribute only works for things that are definitionally equal to a constructor. for example <code>λ x, x + 2 = λ x, nat.succ (nat.succ x)</code>, by definition, so marking add with the pattern attribute works. Incidentall changing your definition of <code>fin.zero</code> also works - it also wanted to reduce the proof to a constructor, but it's probably not a desirable change.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">):</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fin_is_even&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>      <span class=\"n\">i</span>            <span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">elim0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"n\">h</span><span class=\"o\">)</span>     <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"c1\">--| (n +1) x := bnot (fin_is_even&#39; n i)</span>\n</pre></div>",
        "id": 173297330,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565881407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> , thank you, now I can see why fin.succ doesn't work. Anyway, is there any other that allow us use something like fin.zero and fin.succ in pattern matching? I really miss the following alternative definition of <code>fin</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">fin&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">fin&#39;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">fin&#39;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin&#39;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>But I use this definition, it is incompatible with the standard library.</p>\n<blockquote>\n<p>I think the <code>pattern</code> attribute only works for things that are definitionally equal to a constructor</p>\n</blockquote>\n<p>How about this following code in <code>data.vector</code>? Is this definitionally equal to any constructor? I fact, I haven't seen any code using pattern matching on <code>vector</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"o\">[],</span>  <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">pattern</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">⟨</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span> <span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">h</span> <span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 173308047,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565890275
    },
    {
        "content": "<p><code>nil</code> definitely is. <code>cons</code> definitely isn't.</p>\n<p>Actually it depends on the vector you're trying to match with. If your vector is a variable then it won't work. If you do</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">match</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">l</span> <span class=\"n\">rfl</span> <span class=\"k\">with</span><span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>Then it has a better chance of working, but I think the prood of equality would have to be rfl.</p>",
        "id": 173309108,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1565891186
    },
    {
        "content": "<p>I thought this variant of fin was in mathlib somewhere</p>",
        "id": 173353499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565939876
    }
]
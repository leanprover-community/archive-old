[
    {
        "content": "<p>I came across this cryptic-sounding error when trying to execute <code>cases</code> on a particular inductive type:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">cases</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">unsupported</span> <span class=\"n\">equality</span> <span class=\"n\">between</span> <span class=\"n\">type</span> <span class=\"n\">and</span> <span class=\"n\">constructor</span> <span class=\"n\">indices</span>\n<span class=\"o\">(</span><span class=\"n\">only</span> <span class=\"n\">equalities</span> <span class=\"n\">between</span> <span class=\"n\">constructors</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"kn\">variables</span> <span class=\"n\">are</span> <span class=\"n\">supported</span><span class=\"o\">,</span> <span class=\"n\">try</span> <span class=\"n\">cases</span> <span class=\"n\">on</span> <span class=\"n\">the</span> <span class=\"n\">indices</span><span class=\"o\">):</span>\n<span class=\"n\">zeros</span> <span class=\"bp\">_</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"kn\">context</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">r₁_</span><span class=\"err\">Γ</span> <span class=\"o\">(</span><span class=\"n\">r₁_π</span> <span class=\"err\">•</span> <span class=\"n\">r₁_</span><span class=\"err\">Γ&#39;</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Does anyone know what this means?</p>\n<p>Also here's an irrelevant, but fun-looking error (it seems Lean got stuck in a loop for a bit?):<br>\n<a href=\"https://pastebin.com/779LZsf1\" target=\"_blank\" title=\"https://pastebin.com/779LZsf1\">https://pastebin.com/779LZsf1</a></p>",
        "id": 158075998,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1549927719
    },
    {
        "content": "<p>It means you want <code>cases</code> to unify some expression that is not a local constant with some other expression that is not a local constant</p>",
        "id": 158076037,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549927774
    },
    {
        "content": "<p>What do you mean by \"local constant\" here? I've split the \"zeros _x\" into a constant by doing a <code>cases</code> of a different variable first, but the error is still the same, trying to prove <code>nil = context.add r₁_Γ (r₁_π • r₁_Γ')</code>.</p>",
        "id": 158118832,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1549979822
    },
    {
        "content": "<p>Can you post code?</p>",
        "id": 158121523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982174
    },
    {
        "content": "<p>Yep, it arises on <a href=\"https://github.com/Vtec234/leanear/blob/a1cd8053868c45305a66bc1c667f0c91d25df596/src/term.lean#L275\" target=\"_blank\" title=\"https://github.com/Vtec234/leanear/blob/a1cd8053868c45305a66bc1c667f0c91d25df596/src/term.lean#L275\">this line</a>. It does seem like Lean is trying to automatically prove a propositional equality, which I should do manually, I'm just unsure how to do it with <code>cases</code> - I suppose using <code>cases_on</code> is the way to do it?</p>",
        "id": 158122218,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1549982722
    },
    {
        "content": "<p>Oh, I mean code that we can run (there's some <code>import matrix</code> line). But maybe this already helps.</p>",
        "id": 158122714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549983089
    },
    {
        "content": "<p>I can't work out the type of anything unless I can run the code, basically.</p>",
        "id": 158122788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549983129
    },
    {
        "content": "<p>you're doing <code>cases r\\1</code>. What is the type of r\\1?</p>",
        "id": 158122846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549983180
    },
    {
        "content": "<p>minimized:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"n\">run_cmd</span> <span class=\"n\">mk_simp_attr</span> <span class=\"bp\">`</span><span class=\"n\">sop_form</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">simp</span><span class=\"o\">]</span>\n<span class=\"n\">run_cmd</span> <span class=\"n\">mk_simp_attr</span> <span class=\"bp\">`</span><span class=\"n\">unfold_</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">simp</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">decidable_eq</span><span class=\"o\">]</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">mult</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mult</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">mult</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">mult</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">mult</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">mult</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">mult</span>\n\n\n<span class=\"kn\">inductive</span> <span class=\"n\">tp</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat</span><span class=\"o\">:</span> <span class=\"n\">tp</span>\n<span class=\"bp\">|</span> <span class=\"n\">bool</span><span class=\"o\">:</span> <span class=\"n\">tp</span>\n<span class=\"bp\">|</span> <span class=\"n\">fn</span><span class=\"o\">:</span> <span class=\"n\">mult</span> <span class=\"bp\">→</span> <span class=\"n\">tp</span> <span class=\"bp\">→</span> <span class=\"n\">tp</span> <span class=\"bp\">→</span> <span class=\"n\">tp</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">⟦</span><span class=\"bp\">`</span><span class=\"n\">π</span><span class=\"bp\">`⬝`</span><span class=\"n\">T</span><span class=\"bp\">`</span><span class=\"err\">⟧⊸</span><span class=\"bp\">`</span><span class=\"n\">U</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"o\">:=</span> <span class=\"n\">tp</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"n\">π</span> <span class=\"n\">T</span> <span class=\"n\">U</span>\n\n<span class=\"n\">def</span> <span class=\"n\">precontext</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">tp</span>\n\n<span class=\"kn\">inductive</span> <span class=\"kn\">context</span><span class=\"o\">:</span> <span class=\"n\">precontext</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"o\">[]</span>\n<span class=\"c1\">-- You have a dependent pi (n) after a recursive arg (_ : context ns)</span>\n<span class=\"c1\">-- and Lean doesn&#39;t like this.</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">:</span> <span class=\"n\">precontext</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"o\">:</span> <span class=\"n\">mult</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">tp</span><span class=\"o\">):</span> <span class=\"kn\">context</span> <span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">::</span><span class=\"err\">Γ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">⟦</span><span class=\"bp\">`</span><span class=\"n\">π</span><span class=\"bp\">`⬝`</span><span class=\"n\">T</span><span class=\"bp\">`</span><span class=\"err\">⟧</span><span class=\"bp\">::`</span><span class=\"err\">Γ</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"o\">:=</span> <span class=\"kn\">context</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">π</span> <span class=\"n\">T</span> <span class=\"err\">Γ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"kn\">context</span>\n\n<span class=\"n\">def</span> <span class=\"n\">zeros</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">::</span><span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">⟦</span><span class=\"mi\">0</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧</span><span class=\"bp\">::</span><span class=\"o\">(</span><span class=\"n\">zeros</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"n\">precontext</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⟨</span><span class=\"n\">zeros</span> <span class=\"n\">γ</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">},</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"err\">⟦</span><span class=\"n\">π₁</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧</span><span class=\"bp\">::</span><span class=\"err\">Γ₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">⟦</span><span class=\"n\">π₂</span><span class=\"bp\">⬝.</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"err\">⟧</span><span class=\"bp\">::</span><span class=\"err\">Γ₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">π₁</span><span class=\"bp\">+</span><span class=\"n\">π₂</span><span class=\"o\">)</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧</span><span class=\"bp\">::</span><span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"err\">Γ₁</span> <span class=\"err\">Γ₂</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"n\">precontext</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⟨</span><span class=\"kn\">context</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">smul</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">},</span> <span class=\"n\">mult</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">π</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">π</span> <span class=\"o\">(</span><span class=\"err\">⟦</span><span class=\"n\">π&#39;</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧</span><span class=\"bp\">::</span><span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">π</span><span class=\"bp\">*</span><span class=\"n\">π&#39;</span><span class=\"o\">)</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧</span><span class=\"bp\">::</span><span class=\"o\">(</span><span class=\"n\">smul</span> <span class=\"n\">π</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"n\">precontext</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">mult</span> <span class=\"o\">(</span><span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⟨</span><span class=\"kn\">context</span><span class=\"bp\">.</span><span class=\"n\">smul</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span> <span class=\"kn\">context</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Introduces matrices and horrifying linear algebra. -/</span>\n\n\n<span class=\"kn\">open</span> <span class=\"kn\">context</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">term</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">},</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">tp</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">):</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">},</span>\n  <span class=\"c1\">--------------------------</span>\n  <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"n\">tp</span><span class=\"bp\">.</span><span class=\"n\">nat</span>\n\n<span class=\"bp\">|</span> <span class=\"n\">Bool</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">):</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">},</span>\n  <span class=\"c1\">---------------------------</span>\n  <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"n\">tp</span><span class=\"bp\">.</span><span class=\"n\">bool</span>\n\n<span class=\"bp\">|</span> <span class=\"n\">App</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"n\">precontext</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"err\">Γ&#39;</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"n\">tp</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span><span class=\"o\">:</span> <span class=\"n\">mult</span><span class=\"o\">},</span>\n  <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"err\">⟦</span><span class=\"n\">π</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧⊸</span><span class=\"n\">U</span>\n<span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ&#39;</span> <span class=\"n\">T</span>\n  <span class=\"c1\">----------------------</span>\n<span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"bp\">+</span> <span class=\"n\">π</span><span class=\"err\">•Γ&#39;</span><span class=\"o\">)</span> <span class=\"n\">U</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n\n<span class=\"c1\">-- preservation proven by construction</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">reduces</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">tp</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">AppEtaLeft</span><span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"err\">Γ&#39;</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"n\">tp</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span><span class=\"o\">:</span> <span class=\"n\">mult</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">fn</span> <span class=\"n\">fn&#39;</span><span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"err\">⟦</span><span class=\"n\">π</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧⊸</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">arg</span><span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Γ&#39;</span> <span class=\"n\">T</span><span class=\"o\">},</span>\n  <span class=\"n\">reduces</span> <span class=\"n\">fn</span> <span class=\"n\">fn&#39;</span>\n  <span class=\"c1\">----------------------------------</span>\n<span class=\"bp\">→</span> <span class=\"n\">reduces</span> <span class=\"o\">(</span><span class=\"n\">App</span> <span class=\"n\">fn</span> <span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">App</span> <span class=\"n\">fn&#39;</span> <span class=\"n\">arg</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">reduces</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">implicit</span> <span class=\"n\">true</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">diamond_property</span><span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">tp</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"n\">T</span><span class=\"o\">},</span>\n    <span class=\"n\">reduces</span> <span class=\"n\">e</span> <span class=\"n\">e₁</span>\n  <span class=\"bp\">→</span> <span class=\"n\">reduces</span> <span class=\"n\">e</span> <span class=\"n\">e₂</span>\n    <span class=\"c1\">------------------------------</span>\n  <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">e&#39;</span><span class=\"o\">,</span> <span class=\"n\">reduces</span> <span class=\"n\">e₁</span> <span class=\"n\">e&#39;</span> <span class=\"bp\">∧</span> <span class=\"n\">reduces</span> <span class=\"n\">e₂</span> <span class=\"n\">e&#39;</span>\n<span class=\"c\">/-</span><span class=\"cm\"> TODO cases r₁ fails almost everywhere -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">γ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"n\">r₁</span> <span class=\"n\">r₂</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">cases</span> <span class=\"n\">γ</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">r₁</span><span class=\"o\">,</span>\n\n <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">Bool</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">r₁</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">App</span> <span class=\"n\">γ&#39;</span> <span class=\"err\">Γ&#39;</span> <span class=\"err\">Γ&#39;&#39;</span> <span class=\"n\">T&#39;</span> <span class=\"n\">U&#39;</span> <span class=\"n\">π&#39;</span> <span class=\"n\">fn</span> <span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"n\">r₁</span> <span class=\"n\">r₂</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 158123523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549983661
    },
    {
        "content": "<p>The type of <code>r₁</code> is <code>@reduces (@list.nil tp) 0 tp.nat (@Nat n (@list.nil tp)) e₁</code> before the cases. In the cases we try to match it against the <code>AppEtaLeft</code> constructor, which has type <code>@reduces γ (Γ + π • Γ') U (@App γ Γ Γ' T U π fn arg) (@App γ Γ Γ' T U π fn' arg)</code>. This involves matching <code>(@list.nil tp) = γ</code> (no problem), <code>0 = Γ + π • Γ'</code> (big problem), <code>tp.nat = U</code> (no problem), before we get to <code>(@Nat n (@list.nil tp)) =  (@App γ Γ Γ' T U π fn arg)</code> (ill typed)</p>",
        "id": 158124090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549984036
    },
    {
        "content": "<p>The reason <code>0 = Γ + π • Γ'</code> is problematic is because the lhs is a constructor (okay) and the rhs is a function, namely <code>add</code> which is not a constructor. <code>cases</code> doesn't know what to do with this</p>",
        "id": 158124210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549984096
    },
    {
        "content": "<p>I'm looking at this definition.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">precontext</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">tp</span>\n\n<span class=\"kn\">inductive</span> <span class=\"kn\">context</span><span class=\"o\">:</span> <span class=\"n\">precontext</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span><span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"o\">[]</span>\n<span class=\"c1\">-- You have a dependent pi (n) after a recursive arg (_ : context ns)</span>\n<span class=\"c1\">-- and Lean doesn&#39;t like this.</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">:</span> <span class=\"n\">precontext</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"o\">:</span> <span class=\"n\">mult</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">tp</span><span class=\"o\">):</span> <span class=\"kn\">context</span> <span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">::</span><span class=\"err\">Γ</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I think you want <code>context</code> to be nondependent. You aren't really using the precontext in the definition - a context is only a list of <code>mult * tp</code> pairs of the same length as the precontext. I would suggest using a well formedness property to express this</p>",
        "id": 158124564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549984338
    },
    {
        "content": "<p>Same for <code>term</code>, maybe even more so. A dependent type of terms will lead only to weeping and gnashing of teeth</p>",
        "id": 158124748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549984483
    },
    {
        "content": "<p>First of all, thanks a lot! I was just trying to conjure up an artificial example that people could run, but your minimization works better (and TIL about <code>pp.implicit</code>).<br>\nOn the topic of <code>cases</code>:<br>\nAs you rightly mentioned, <code>(@Nat n (@list.nil tp)) =  (@App γ Γ Γ' T U π fn arg)</code>is ill-typed. What I wanted <code>cases</code> to do in the first place was to simply discharge the cases of <code>Nat n</code> as absurd using this condition (and similar ones for <code>AppEtaRight</code> et al). Do you think it would be possible to modify <code>cases</code> so that it checks for impossible conditions such as this first? That way, even if it runs into something it can't unify such as <code>0 = Γ + π • Γ'</code>, it wouldn't matter as the case cannot occur anyway. It is true that all of <code>Γ Γ' π</code> are used in the ill-typed expression, but <code>@Nat .. = @App ..</code> is ill-typed regardless of argument values.<br>\nAlternatively, could the <code>cases</code> tactic simply generate a <code>0 = Γ + π • Γ'</code> goal? Is there a tactic which already does this?</p>\n<p>On the dependency of <code>context</code>/<code>term</code>:<br>\nThis is essentially a strongly-typed representation of a particular lambda calculus, as described e.g. <a href=\"https://people.mpi-sws.org/~gil/publications/typedsyntaxfull.pdf\" target=\"_blank\" title=\"https://people.mpi-sws.org/~gil/publications/typedsyntaxfull.pdf\">here</a>. The reason why <code>context</code>s depend on <code>precontext</code>s is that, for example, the definition of <code>App</code> in <code>term</code> (function application) allows the function and argument to have different <code>context</code>s, i.e. different <code>mult</code>s per <code>tp</code>, but they must have the same <code>precontext</code>,  i.e. the same list of <code>tp</code>s. This way, terms are correct-by-construction, meaning it's impossible to construct a <code>term</code> of an invalid embedded type (<code>tp</code>). Similarly, <code>term</code>s depend on <code>context</code>s, making the definition of <code>reduces</code> trivially uphold the type-preservation property of the described calculus. By \"well formedness property\", do you mean something that could achieve the same without messing with dependent types?</p>",
        "id": 158126385,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1549985832
    },
    {
        "content": "<blockquote>\n<p>As you rightly mentioned, (@Nat n (@list.nil tp)) =  (@App γ Γ Γ' T U π fn arg)is ill-typed. What I wanted cases to do in the first place was to simply discharge the cases of Nat n as absurd using this condition (and similar ones for AppEtaRight et al). Do you think it would be possible to modify cases so that it checks for impossible conditions such as this first?</p>\n</blockquote>\n<p>That's exactly what it was trying to do. But it never got that far - you can't prove two different constructors are distinct if the proof of distinctness is not even type correct</p>",
        "id": 158126656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986079
    },
    {
        "content": "<blockquote>\n<p>Alternatively, could the cases tactic simply generate a 0 = Γ + π • Γ' goal? Is there a tactic which already does this?</p>\n</blockquote>\n<p>I wish it did this; <code>cases</code> failing is a kind of messy solution. You can actually capture the error state and attempt to proceed from there, but I don't recommend it. The failure of the equality to be discharged means all later equalities are heterogeneous, which makes them that much harder to work with</p>",
        "id": 158126808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986204
    },
    {
        "content": "<p>In the Coq paper, it is important that all the terms that appear in dependent arguments are constructors. That's what makes them pattern match nicely. You are using <code>Γ + π • Γ'</code> in a dependent argument, which will cause many problems</p>",
        "id": 158127093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986393
    },
    {
        "content": "<p>see the top of p. 7</p>",
        "id": 158127108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986409
    },
    {
        "content": "<blockquote>\n<p>By \"well formedness property\", do you mean something that could achieve the same without messing with dependent types?</p>\n</blockquote>\n<p>Yes. The idea is to have two definitions: a weakly typed type of terms, which is really just the syntax of the expressions, and an inductive typechecking relation</p>",
        "id": 158127223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986501
    },
    {
        "content": "<p>The real reason <code>App</code> is badly typed is that you can't really change it out for anything else, even if <code>Γ + π • Γ' = Γ2 + π • Γ'2</code></p>",
        "id": 158127451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986657
    },
    {
        "content": "<p>One way to fix this problem without an overhaul is to give <code>app</code> the type</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">|</span> <span class=\"n\">App</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"n\">precontext</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"err\">Γ&#39;</span> <span class=\"err\">Γ&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"n\">tp</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span><span class=\"o\">:</span> <span class=\"n\">mult</span><span class=\"o\">},</span>\n  <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"err\">⟦</span><span class=\"n\">π</span><span class=\"bp\">⬝</span><span class=\"n\">T</span><span class=\"err\">⟧⊸</span><span class=\"n\">U</span>\n<span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ&#39;</span> <span class=\"n\">T</span>\n<span class=\"bp\">→</span> <span class=\"err\">Γ&#39;&#39;</span> <span class=\"bp\">=</span> <span class=\"err\">Γ</span> <span class=\"bp\">+</span> <span class=\"n\">π</span><span class=\"err\">•Γ&#39;</span>\n  <span class=\"c1\">----------------------</span>\n<span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ&#39;&#39;</span> <span class=\"n\">U</span>\n</pre></div>",
        "id": 158127596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986756
    },
    {
        "content": "<p>This way <code>Γ''</code> is free to be whatever the context needs it to be, and you get an equality hypothesis out instead</p>",
        "id": 158127638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549986812
    },
    {
        "content": "<blockquote>\n<p>That's exactly what it was trying to do. But it never got that far - you can't prove two different constructors are distinct if the proof of distinctness is not even type correct</p>\n</blockquote>\n<p>If this makes any sense, is there a type theory which could admit a statement of the form, informally, \"regardless of the types of LHS and RHS, an equality cannot be constructed since the sides use different constructors\"?</p>",
        "id": 158403287,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1550020103
    }
]
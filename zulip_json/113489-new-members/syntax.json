[
    {
        "content": "<p>I found the following in a file </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The transpose of a matrix. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">transpose</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">M</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>What does <code>|</code> mean here?</p>",
        "id": 242043315,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623234011
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching\">https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching</a></p>",
        "id": 242043587,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623234151
    },
    {
        "content": "<p>Remember that<code>matrix n m α</code> is just <code>n → m → α</code></p>",
        "id": 242043655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623234193
    },
    {
        "content": "<p>The definition of addition on the natural numbers uses these pipe symbols to write the two cases X+0 and X+(succ n)</p>",
        "id": 242043703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623234239
    },
    {
        "content": "<p>In</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_add</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→+</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">+</span> <span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">M.map</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">N.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>What does the plus sign before β mean in <code> (f : α →+ β)</code>?</p>",
        "id": 242044937,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623234944
    },
    {
        "content": "<p>an additive morphism, i.e. <code>f 0 = 0</code> and <code>f a + f b = f (a + b)</code></p>",
        "id": 242045161,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623235082
    },
    {
        "content": "<p>there's similarly <code>→*</code> and <code>→+*</code></p>",
        "id": 242045187,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623235095
    },
    {
        "content": "<p>and many variations, e.g. a ring equiv is <code>≃+*</code></p>",
        "id": 242045202,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623235112
    },
    {
        "content": "<p>Thanks a lot!</p>",
        "id": 242047019,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623236187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span> this is bundled morphisms/isomorphisms :-) We worked with unbundled ones for a while but bundled ones work better in most situations because \"you can use dot notation\".</p>",
        "id": 242051919,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623238999
    },
    {
        "content": "<p>for the record - this stuff is complicated and confusion is very understandable! even mathlib changes its mind often; the most recent that comes to mind was module bases used to be unbundled, and now they are bundled</p>",
        "id": 242052233,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623239174
    },
    {
        "content": "<p>Also, because there are many ways to write the same map <code>f</code>: <code>f \\comp id</code>, <code>id \\comp f</code>, <code>λ x, f x</code>, ... and it's hard to automatically recognize when <code>is_ring_hom f</code> can apply to a given <code>f'</code> (even if <code>f</code> and <code>f'</code> are \"obviously\" the same).</p>",
        "id": 242052316,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1623239219
    },
    {
        "content": "<p>(back at a keyboard) <span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span>  Here is the advantage of bundled <code>f : α →+ β</code> morphisms. This <code>→+</code> notation means <code>add_monoid_hom</code>, so really it says <code>f : add_monoid_hom α β</code> (and it's just displayed using the notation to make it easier to read for humans). Any theorem about additive monoid or group homomorphisms, such that <code>f 0 = 0</code>, can be given then name <code>add_monoid_hom.map_zero</code>, and then it can be accessed with <code>f.map_zero</code> easily -- this is how dot notation works. If <code>f</code> were unbundled it would be a function type and you wouldn't be able to pull off this trick. This works because <code>add_monoid_hom</code> is a structure but not a class (you can't have it being a class because given two groups it's completely reasonable to want to consider more than one group hom between them). In contrast, in your other thread, <code>fintype p</code> is a class (because you only need one proof that a type is finite) which means that the term of type <code>fintype p</code> doesn't have a name which users will ever need to worry about (it will be called something like <code>_inst_37</code>) and so you can't pull off the dot notation trick, so unbundled is best.</p>",
        "id": 242053838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623240032
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">o</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>What are the differences between <code> Type*</code> and <code>Type u</code> and why should we declare <code>l m n o</code> to be in <code>Type*</code> (I am actually not sure whether we should always do this)</p>",
        "id": 242061111,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623243890
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>is (nearly?) equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but less typing</p>",
        "id": 242061860,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1623244256
    },
    {
        "content": "<p>The only difference I can think of is that <code>universe u</code> lets you easily make several variables in the same universe.</p>",
        "id": 242062142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623244405
    },
    {
        "content": "<p>What are the differences between <code>Type</code> and <code>Type u</code> then?<br>\nThanks a lot for all your above answers!</p>",
        "id": 242062893,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623244754
    },
    {
        "content": "<p>I just use Type u. I used Type* several times when I was very new to Lean but I found it kind of... not necessary for the kind of things that I usually formalize.</p>",
        "id": 242064295,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1623245249
    },
    {
        "content": "<p><code>Type</code> is just short for <code>Type 0</code></p>",
        "id": 242064474,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623245314
    },
    {
        "content": "<p>Note that <code>variables {X Y : Type u}</code> means \"put X and Y in the same universe\" but <code>{X Y : Type*}</code> means \"create a new universe for each\". Separate universes are preferred whenever it doesn't make the proofs harder.</p>",
        "id": 242064655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623245387
    },
    {
        "content": "<p>When I was teaching Lean to mathematicians earlier this year I just completely ignored universes, and used <code>X : Type</code> for every set/type/whatever your mental model of these things is. Mathlib style is to be \"as universe polymorphic as possible\", so e.g. if R is a ring and M is an R-module then R is supposed to live in universe u and M in universe v, but in practice if you're just writing maths in code which isn't going into mathlib there's no harm in using <code>Type</code> everywhere. If you know about how to set up maths in set theory, then <code>Type = Type 0</code> is sets, and <code>Type 1</code> includes proper classes, and then there are even higher universes containing absurdly mega-infinite things which one hardly ever sees in practice in most normal mathematics, except if one is specifically messing with large objects (e.g. studying large cardinals or whatever)</p>",
        "id": 242066164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623245947
    },
    {
        "content": "<p>Many thanks!</p>",
        "id": 242074992,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623249143
    },
    {
        "content": "<p>What is the difference between <code>Type</code> and <code>Sort</code>?</p>",
        "id": 242316569,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623401176
    },
    {
        "content": "<p>Roughly speaking <code>Type u = Sort (u+1)</code> but Gabriel will probably remind me there's a <code>max</code> that belongs there somewhere.</p>",
        "id": 242317396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623401760
    },
    {
        "content": "<p>As far as I can tell, <code>Type*</code> is <code>Sort (1 or higher)</code>.  <code>Type</code> is actually <code>Type 0</code>, while <code>Sort</code> is, I think, <code>Prop</code>.  There is a hierarchy</p>\n<p><code>Sort 0 = Prop</code><br>\n<code>Sort 1 = Type 0 = Type</code><br>\n...<br>\n<code>Sort (u+1) = Type u</code> -- thanks Eric!</p>",
        "id": 242317464,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623401799
    },
    {
        "content": "<p>Use <code>Sort*</code> if you want to include <code>Prop</code>, use <code>Type*</code> if you don't</p>",
        "id": 242317564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623401869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/syntax/near/242317396\">said</a>:</p>\n<blockquote>\n<p>Roughly speaking <code>Type u = Sort (u+1)</code> but Gabriel will probably remind me there's a <code>max</code> that belongs there somewhere.</p>\n</blockquote>\n<p>What? There <em>is</em> a max somewhere?</p>",
        "id": 242317876,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1623402061
    },
    {
        "content": "<blockquote>\n<p>Type u abbreviates Sort (u + 1) when u is a universe variable</p>\n</blockquote>",
        "id": 242317945,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1623402103
    },
    {
        "content": "<p>The <a href=\"https://leanprover.github.io/reference/expressions.html\">Lean reference</a> says otherwise.</p>",
        "id": 242317955,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1623402108
    },
    {
        "content": "<p>I remember being told that at some point during lean's development the link between type and sort was changed</p>",
        "id": 242318658,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623402488
    },
    {
        "content": "<p>So either I'm misremembering the direction of the flip, or that document predates it</p>",
        "id": 242318711,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623402519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>, am I imagining you telling me that?</p>",
        "id": 242318743,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623402537
    },
    {
        "content": "<p>A long long time ago, in a repository far away, it used to be the case that <code>Prop = Type 0</code>.  And <code>option</code> had the type <code>Type (max 1 u)</code>, which caused all kinds of issues with universe level unification.  <a href=\"https://github.com/leanprover/lean/issues/1341\">https://github.com/leanprover/lean/issues/1341</a><br>\nFloris then <a href=\"https://github.com/leanprover/lean/issues/1341\">suggested</a> to use <code>Type u = Sort (u+1)</code> and thereby separate <code>Type</code> from <code>Prop</code>.  And the universe level unification issues were again gone from our kingdom.</p>",
        "id": 242321209,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1623404015
    },
    {
        "content": "<p>This is a piece of code from Theorem Proving in Lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">weekday</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">sunday</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span>\n<span class=\"bp\">|</span> <span class=\"n\">monday</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span>\n<span class=\"bp\">|</span> <span class=\"n\">tuesday</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span>\n<span class=\"bp\">|</span> <span class=\"n\">wednesday</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span>\n<span class=\"bp\">|</span> <span class=\"n\">thursday</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span>\n<span class=\"bp\">|</span> <span class=\"n\">friday</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span>\n<span class=\"bp\">|</span> <span class=\"n\">saturday</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">weekday</span>\n\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">cases_on</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">weekday.cases_on</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">number_of_day</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"n\">weekday.cases_on</span> <span class=\"n\">d</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"mi\">4</span> <span class=\"mi\">5</span> <span class=\"mi\">6</span> <span class=\"mi\">7</span>\n<span class=\"kd\">end</span> <span class=\"n\">weekday</span>\n</code></pre></div>\n<p>In <code>@[reducible] private def cases_on := @weekday.cases_on</code>, why do we need <code>@</code> before<code> weekday.cases_on</code> and why does it report an error <code>invalid definition, a declaration named 'weekday.cases_on' has already been declared</code> when <code>private</code> is removed?</p>",
        "id": 242435220,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623484860
    },
    {
        "content": "<p>What does <code>#print weekday.cases_on</code> show before and after that line?</p>",
        "id": 242438367,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623488754
    },
    {
        "content": "<p>Usually <code>def x := @y</code> is used when no @ means that lean has to solve a type class problem with no clues</p>",
        "id": 242439172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623489573
    },
    {
        "content": "<p>Obviously the error about having something already defined is because you're trying to define something when it's already been defined. I don't know what private does though.</p>",
        "id": 242439281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623489650
    },
    {
        "content": "<p>private gives the declaration a weird namespace, so it doesn't clash with the existing one</p>",
        "id": 242440468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623491269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/syntax/near/242438367\">said</a>:</p>\n<blockquote>\n<p>What does <code>#print weekday.cases_on</code> show before and after that line?</p>\n</blockquote>\n<p>Both give </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">weekday.cases_on</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span><span class=\"o\">),</span>\n  <span class=\"n\">C</span> <span class=\"n\">sunday</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">monday</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">tuesday</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">wednesday</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">thursday</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">friday</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">saturday</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">weekday</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_1</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">sunday</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_2</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">monday</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_3</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">tuesday</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_4</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">wednesday</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">e_5</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">thursday</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_6</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">friday</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_7</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">saturday</span><span class=\"o\">),</span> <span class=\"n\">weekday.rec</span> <span class=\"n\">e_1</span> <span class=\"n\">e_2</span> <span class=\"n\">e_3</span> <span class=\"n\">e_4</span> <span class=\"n\">e_5</span> <span class=\"n\">e_6</span> <span class=\"n\">e_7</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 242564970,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623658398
    },
    {
        "content": "<p>That's the built in <code>weekday.cases_on</code> function</p>",
        "id": 242565342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623658644
    },
    {
        "content": "<p>not your private alias</p>",
        "id": 242565353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623658652
    },
    {
        "content": "<p>to refer to the private alias you can use <code>#print cases_on</code> inside the section, and outside the section you can't refer to it</p>",
        "id": 242565435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623658689
    },
    {
        "content": "<p>So in the example above then the <code>private def</code> isn't being used anyway?</p>",
        "id": 242569630,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623661466
    },
    {
        "content": "<p>I think <code>cases_on</code> can be used as a shortcut then. I just didn't quite understand the syntax there at the beginning.</p>",
        "id": 242701711,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623745353
    },
    {
        "content": "<p>Is there a better (i.e. shorter) way to equivalently write<br>\n<code>begin (some tactic), exact ***, end</code></p>",
        "id": 243307186,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624202151
    },
    {
        "content": "<p>If the tactic is <code>rw</code> and the <code>***</code> is a hypothesis then the <code>rwa</code> tactic can be used to do both at once.</p>",
        "id": 243307422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624202465
    },
    {
        "content": "<p>If the tactic is <code>simp</code> then you might just be able to add <code>***</code> to the list which simp optionally accepts</p>",
        "id": 243307490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624202535
    },
    {
        "content": "<p>In general your question is probably too broad. If you want something then it would be a cool exercise to write a new tactic which does what you want :-) There are some useful resources on basic tactic writing nowadays (something on the website, Rob Lewis' LFTCM videos)</p>",
        "id": 243307562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624202653
    },
    {
        "content": "<p>Is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[class]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span>\n<span class=\"bp\">|</span> <span class=\"n\">is_true</span>  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span>\n</code></pre></div>\n<p>equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"kd\">inductive</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">decidable</span>\n<span class=\"bp\">|</span> <span class=\"n\">is_true</span>  <span class=\"o\">:</span>  <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">decidable</span>\n</code></pre></div>\n<p>?</p>",
        "id": 243602399,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624417032
    },
    {
        "content": "<p>yes</p>",
        "id": 243604539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624420139
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Semigroup</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span><span class=\"o\">,</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"n\">Semigroup_to_sort</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">Semigroup</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">S.carrier</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 243754940,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624523075
    },
    {
        "content": "<p>Will there be any difference if I change the last two lines to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">Semigroup_to_sort'</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">Semigroup</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">S.carrier</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>?</p>",
        "id": 243755081,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624523187
    },
    {
        "content": "<p>Nope, it's equivalent.</p>",
        "id": 243755173,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624523256
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ext_iff</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">N</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>What does the dollar sign mean here?</p>",
        "id": 244102877,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624857140
    },
    {
        "content": "<p><em>alright i accept defeat i don't understand $ either</em></p>",
        "id": 244104005,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1624858976
    },
    {
        "content": "<p>The <code>$</code> means \"open a parenthesis from here until the end\".  It is sometimes useful to avoid ending a line with <code>))))</code>.</p>",
        "id": 244104023,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1624859021
    },
    {
        "content": "<p>In the examply be <span class=\"user-mention\" data-user-id=\"270523\">@Huỳnh Trần Khanh</span> you don't really see the power of <code>$</code> shine. Here's when <code>$</code> is helpful:</p>\n<p>You have a function <code>f</code> that you can apply to some arguments, and as last argument you want to apply a function application <code>g x y z</code>.<br>\nThen you would usually write <code>f 1 2 3 (g x y z)</code>. But maybe you don't want to pass <code>z</code>, but instead some function application <code>h a b c</code>, so then you write <code>f 1 2 3 (g x y (h a b c))</code>. But maybe you don't want to pass <code>c</code>, but rather <code>s k l m</code>, so you write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">k</span> <span class=\"n\">l</span> <span class=\"n\">m</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>Using <code>$</code>, you can tell Lean \"hey, every thing that follows <code>$</code> should be interpreted as the final argument to the function application left of the <code>$</code>!\"</p>\n<p>So you can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"bp\">$</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">$</span> <span class=\"n\">s</span> <span class=\"n\">k</span> <span class=\"n\">l</span> <span class=\"n\">m</span>\n</code></pre></div>",
        "id": 244104247,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624859367
    },
    {
        "content": "<p>I don't quite understand the syntax of the defn of simple graphs: what does <code>. obviously</code> mean and what is its function?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 245282515,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1625730817
    },
    {
        "content": "<p>Did you try the search field on top of <a href=\"https://leanprover-community.github.io/mathlib_docs/\">https://leanprover-community.github.io/mathlib_docs/</a>?</p>",
        "id": 245282883,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1625731070
    },
    {
        "content": "<p>The syntax <code>x : A . t</code> means \"try to synthesize the argument <code>x</code> of type <code>A</code> using tactic <code>t</code>\"</p>",
        "id": 245283001,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1625731146
    },
    {
        "content": "<p>So in your case Lean will try to prove <code>symmetric adj</code> by the tactic <code>obviously</code> when you define a <code>simple_graph</code></p>",
        "id": 245283074,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1625731203
    },
    {
        "content": "<p>It's briefly mentioned here if you want a reference: <a href=\"https://leanprover.github.io/reference/expressions.html#implicit-arguments\">https://leanprover.github.io/reference/expressions.html#implicit-arguments</a></p>",
        "id": 245284565,
        "sender_full_name": "Julian Berman",
        "timestamp": 1625732219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/113489-new-members/topic/syntax/near/245283074\">said</a>:</p>\n<blockquote>\n<p>So in your case Lean will try to prove <code>symmetric adj</code> by the tactic <code>obviously</code> when you define a <code>simple_graph</code></p>\n</blockquote>\n<p>(iff you don't provide a proof yourself)</p>",
        "id": 245343665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625764788
    },
    {
        "content": "<p>I think the only use of this so far in the simple graph library is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">ne</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 245344283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1625765096
    },
    {
        "content": "<p>How can I input other letters like <code>f</code> as a subscript like <code>ₖ</code>?</p>",
        "id": 245725689,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626113819
    },
    {
        "content": "<p><code>\\_f</code> gives me <code>ₐf</code></p>",
        "id": 245725869,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626113913
    },
    {
        "content": "<p>You can't input all of them, only the ones which unicode allows. To get subscript k you do <code>\\_k</code> and if that doesn't work for other letters then it might be literally impossible in the sense that the subscripts are not in the unicode \"alphabet\" or whatever it's called.</p>",
        "id": 245725876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626113920
    },
    {
        "content": "<p>Here are all of them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">₀₁₂₃₄₅₆₇₈₉₊₋₌₍₎ₐₑₒₓₔₕₖₗₘₙₚₛₜ</span>\n</code></pre></div>\n<p>You don't see subscript-schwa (<code>xₔ</code>) nearly often enough in math <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  (Weird, between backticks ₔ shows up as a superscript even though it's a subscript character...)</p>",
        "id": 245728251,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1626115021
    },
    {
        "content": "<p>That's very strange: \"ₔᵊ\" appears as<code>ₔᵊ</code>, which is a double superscript in my font.</p>",
        "id": 245729840,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626115603
    },
    {
        "content": "<p>I am not sure what the double and single up arrows mean in this code: <a href=\"https://leanprover-community.github.io/mathlib_docs/data/polynomial/field_division.html#polynomial.normalization_monoid\">https://leanprover-community.github.io/mathlib_docs/data/polynomial/field_division.html#polynomial.normalization_monoid</a> Can someone explain?</p>",
        "id": 245733058,
        "sender_full_name": "Taylor Belcher",
        "timestamp": 1626116865
    },
    {
        "content": "<p>You can click on them on the web docs and it will take you to the names that correspond to the notation.</p>",
        "id": 245733163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626116917
    },
    {
        "content": "<p>They are different types of coercions, you can read a bit about this at <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#coercions-using-type-classes\">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#coercions-using-type-classes</a>.</p>",
        "id": 245734358,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1626117399
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 245734790,
        "sender_full_name": "Taylor Belcher",
        "timestamp": 1626117596
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"n\">I</span> <span class=\"n\">I</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">matrix.non_unital_semiring</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">matrix.non_assoc_semiring</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Could anyone please explain the syntax in <code>{ ..matrix.non_unital_semiring, ..matrix.non_assoc_semiring }</code>?</p>",
        "id": 247874986,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627848559
    },
    {
        "content": "<p>You are trying to make an instance of a structure here. A structure is an inductive type with only one constructor, namely a list of inputs. There is a lot of syntax sugar available for making structures and you're looking at some of it right now. A <code>semiring</code> structure has a lot of fields, e.g. it has a data field containing a multiplication, and a proof field containing the proof that the multiplication is associative etc etc.</p>\n<p>What's happening in your example is that Lean already knows about two structures, namely <code>matrix.non_unital_semiring : non_unital_semiring (matrix I I alpha)</code> and <code>matrix.non_assoc_semiring: non_assoc_semiring (matrix I I alpha)</code>. These are also structures which have lots of fields. The <code>..</code> notation means \"take the definition of the fields used in these other structures, and use them as the definition of the fields in this structure\". In this case we're lucky and every field which we need is already defined in one of the other structures, so we don't need to do anything else.</p>",
        "id": 247875529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627849394
    },
    {
        "content": "<p>Hi, I wonder if there is some learning resource/tutorial that focuses more on the \"lexical/syntax\" aspect of lean. A purpose is to grasp the boundaries of the language supported by lean. For example, is there a page that explains the usage of these keyword [#check, def, class, instance, example, meta def, variables, lemma, theorem, #print, ...]. Maybe a similar resource I'm thinking of in the case of python is <a href=\"https://docs.python.org/3/reference/lexical_analysis.html#keywords\">https://docs.python.org/3/reference/lexical_analysis.html#keywords</a></p>",
        "id": 248434967,
        "sender_full_name": "david",
        "timestamp": 1628134651
    },
    {
        "content": "<p>It would also be great if something similar to <a href=\"https://docs.python.org/3/library/functions.html#built-in-funcs\">https://docs.python.org/3/library/functions.html#built-in-funcs</a> exists, if a similar concept applies to lean!</p>",
        "id": 248435092,
        "sender_full_name": "david",
        "timestamp": 1628134879
    },
    {
        "content": "<p>The reference manual is probably what you need</p>",
        "id": 248437077,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1628137701
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/reference/\">https://leanprover.github.io/reference/</a></p>",
        "id": 248437176,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1628137820
    },
    {
        "content": "<p>Thank you! That is exactly what I am looking for!</p>",
        "id": 248440040,
        "sender_full_name": "david",
        "timestamp": 1628141324
    },
    {
        "content": "<p>Hello ! I am a beginner and I would need a little help, unfortunately I can't find it on the net. I want to formalize this problem in lean, but I don't know where I should start and what I should do. Can you give me a little help? For example: what are the stages? <a href=\"/user_uploads/3121/jDvQUc9pwHbU7amMKwEOXVEx/image_2021-09-22_103831.png\">image_2021-09-22_103831.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jDvQUc9pwHbU7amMKwEOXVEx/image_2021-09-22_103831.png\" title=\"image_2021-09-22_103831.png\"><img src=\"/user_uploads/3121/jDvQUc9pwHbU7amMKwEOXVEx/image_2021-09-22_103831.png\"></a></div>",
        "id": 254326865,
        "sender_full_name": "Maria",
        "timestamp": 1632296313
    },
    {
        "content": "<p>Ahah! You're right on time. We're formalizing many AMC questions at the moment. The way to translate this statement is to ask for the existence of a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset\">docs#finset</a> of cardinality the answer whose elements are exactly the solutions to the equation.</p>",
        "id": 254335002,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632300710
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.pi.bounds</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">the_answer</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">π</span> <span class=\"bp\">∧</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cos</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 254335440,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1632300943
    },
    {
        "content": "<p>Here's two more ways you could state it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.trigonometric</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">real</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">π</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">real.pi</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">π</span> <span class=\"bp\">∧</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cos</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">the_answer</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">π</span> <span class=\"bp\">∧</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">cos</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)}</span> <span class=\"bp\">→</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">the_answer</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 254488309,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1632379219
    },
    {
        "content": "<p>Isn't that second one false when <code>s = ∅</code>?</p>",
        "id": 254490908,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632380931
    },
    {
        "content": "<p>I think you meant <code>{x : ℝ | ...}</code> not <code>{x ∈ s | ...}</code></p>",
        "id": 254491018,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632381004
    },
    {
        "content": "<p>Im trying to prove that given a category X and x  : X , there exists f: x \\hom x. But i cant figure out how to express \"there exists f: x \\hom x\".</p>\n<p>Excuse me i was certain i posted this in the syntax thread.</p>",
        "id": 254494133,
        "sender_full_name": "Elias Fåkvam",
        "timestamp": 1632382802
    },
    {
        "content": "<p>You probably want to ask this question in a more appropriate thread.</p>",
        "id": 254494243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632382863
    },
    {
        "content": "<p>You can edit the thread of your message above</p>",
        "id": 254494280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632382882
    }
]
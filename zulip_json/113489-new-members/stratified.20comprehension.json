[
    {
        "content": "<p>I am starting to develop Quine's New Foundations  set theory (NF), but with intuitionistic logic,  in Lean.  To that end I <br>\nfirst had to learn how to use Lean at least a little.  That done, I'm ready to proceed with the project.  Now here is the difficulty: <br>\nNF has \"stratified comprehension\",  which means we have a syntactic condition on the formula B to check before it is legal to form the set {x : x \\in B}.  I don't know how to do that in Lean and reading about metaprogramming scared me.  (and I'm not too easily scared.)   I have an equivalent finite axiomatization of intuitionistic NF (INF).  There is an algorithm for translating a so-called \"stratified\" formula B  so that you can construct {x : B(x)}  from unions, intersections, and some other basic operations.  <br>\nI was thinking I would just do that by hand whenever I need {x: B(x)},  and use the finite axiomatization in Lean.  But it turns out to be quite a pain to do that by hand.  So what I did so that I can get on with proofs is I put in the (known inconsistent!) full <br>\ncomprehension axiom  like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">comprehension</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"bp\">→</span><span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,(</span><span class=\"n\">z</span><span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">setof</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">)))</span>\n</code></pre></div>\n\n\n<p>(Here M is an instance of class Model in which the axioms are listed.)   Then I can do stuff like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">FINITE</span><span class=\"o\">:</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">setof</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"bp\">∀</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"err\">∪</span> <span class=\"o\">(</span><span class=\"n\">single</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"err\">∈</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">w</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">finite_members</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"o\">(</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">FINITE</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"bp\">↔</span>\n   <span class=\"bp\">∀</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">w</span> <span class=\"bp\">→</span><span class=\"o\">(</span> <span class=\"n\">u</span> <span class=\"err\">∪</span> <span class=\"o\">(</span><span class=\"n\">single</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"err\">∈</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">w</span><span class=\"o\">))</span>\n   <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">FINITE</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">(</span> <span class=\"n\">comprehension</span>  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">u</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">u</span> <span class=\"err\">∪</span> <span class=\"n\">single</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">w</span><span class=\"o\">)),</span>\n    <span class=\"n\">ifinish</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Then the plan would be to check the proof I want to check this way and then go back and replace<br>\nthese applications of comprehension by constructions from the finite axiomatization.   <br>\nFor example, the set FINITE defined above using comprehension would eventually have to be constructed directly.</p>\n<p>However, if anybody can show me a reasonable way to restrict the comprehension axiom to <br>\nstratified formulas or if anybody who is expert enough at metaprogramming will \"just do it\" that<br>\nwould be wonderful.   I could implement the algorithm easily in Python or C but then I would still have<br>\nto prove in Lean the lemmas saying that the resulting construction worked.</p>\n<p>You can find out what \"stratified\" means  at <a href=\"https://plato.stanford.edu/entries/quine-nf/\">https://plato.stanford.edu/entries/quine-nf/</a></p>",
        "id": 203627374,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1594528293
    }
]
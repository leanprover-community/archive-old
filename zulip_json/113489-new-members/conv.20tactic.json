[
    {
        "content": "<p>Several times in my lean project I have been faced with the situation of needing to rewrite an expression which involves a variable from a lambda encompassing that expression. My understanding is that this is called \"rewriting under binders\", and <a href=\"https://leanprover-community.github.io/extras/conv.html\">this page</a> seems to say pretty explicitly that <code>conv</code> is the proper way of doing this. However, I am confused as to how this works. The \"conversions\" section in the lean reference manual <a href=\"https://leanprover.github.io/reference/tactics.html\">https://leanprover.github.io/reference/tactics.html</a> is simply blank (which is itself rather frustrating ) .</p>\n<p>My understanding from reading the leanprover-community page is that applying the conv tactic would allow me to rewrite a particular section of a goal, even with a binder. However, this is not what happens in the mwe below. What am I doing wrong?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.basic</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">parameter</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">parameter</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">vars</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">vars</span>\n<span class=\"bp\">|</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">vars</span>\n<span class=\"bp\">|</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">vars</span>\n\n\n<span class=\"sd\">/-- Helper for converting mv_polynomial to single -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">singlify</span> <span class=\"o\">:</span> <span class=\"n\">vars</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">vars.X</span><span class=\"o\">)</span> <span class=\"n\">polynomial.X</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">helper_lemma</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">vars</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">singlify</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">vars</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">vars.X</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">polynomial.X</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">singlify</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ite_pow</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">one_pow</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">main_theorem</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"o\">:</span> <span class=\"n\">vars</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a₁.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">vars</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">singlify</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">polynomial.X</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"n\">vars.X</span><span class=\"o\">))</span>\n<span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- This method works, but requires me to create a whole new lemma which will only be used here.</span>\n  <span class=\"c1\">-- I would prefer to use conv, since that seems to be the canonical way, and it would make the proof more self contained.</span>\n\n  <span class=\"n\">rw</span> <span class=\"n\">helper_lemma</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finsupp.prod</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.prod_ite</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.filter_eq'</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">vars.X</span> <span class=\"bp\">∈</span> <span class=\"n\">a₁.support</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">if_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.prod_singleton</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">if_neg</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.prod_empty</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a₁</span> <span class=\"n\">vars.X</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finsupp.not_mem_support_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">main_theorem_with_conv</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"o\">:</span> <span class=\"n\">vars</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a₁.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">vars</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">singlify</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">polynomial.X</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"n\">vars.X</span><span class=\"o\">))</span>\n<span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">conv</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">to_lhs</span><span class=\"o\">,</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">skip</span><span class=\"o\">,</span>\n    <span class=\"n\">funext</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">singlify</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ite_pow</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">one_pow</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n  <span class=\"c1\">-- Goal is unchanged from the initial goal</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224015774,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1611653965
    },
    {
        "content": "<p>Is <code>  simp only [singlify, ite_pow, one_pow],</code> what you are looking for? <code>simp</code> can rewrite under binders.</p>",
        "id": 224016099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611654175
    },
    {
        "content": "<p>PS creating a whole new lemma to help with other lemmas is exactly the mathlib philosophy. Better two short proofs than one longer one.</p>",
        "id": 224016138,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611654212
    },
    {
        "content": "<p>You should put a comma after <code>end</code> to see the new tactic state.</p>",
        "id": 224016399,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611654388
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">helper_lemma</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">vars</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">singlify</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">vars</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">vars.X</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">polynomial.X</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">singlify</span><span class=\"o\">,</span> <span class=\"n\">ite_pow</span><span class=\"o\">,</span> <span class=\"n\">one_pow</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 224016425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611654418
    },
    {
        "content": "<p>(right before your comment saying it doesn't work)</p>",
        "id": 224016430,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611654419
    },
    {
        "content": "<p>Kevin's answers are nice but the question \"how to use <code>conv</code>\" is still valid.</p>",
        "id": 224016479,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611654454
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">main_theorem</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"o\">:</span> <span class=\"n\">vars</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a₁.prod</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">vars</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">singlify</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">polynomial.X</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"n\">vars.X</span><span class=\"o\">))</span>\n<span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- This method works, but requires me to create a whole new lemma which will only be used here.</span>\n  <span class=\"c1\">-- I would prefer to use conv, since that seems to be the canonical way, and it would make the proof more self contained.</span>\n\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">singlify</span><span class=\"o\">,</span> <span class=\"n\">ite_pow</span><span class=\"o\">,</span> <span class=\"n\">one_pow</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finsupp.prod</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.prod_ite</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 224016481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611654456
    }
]
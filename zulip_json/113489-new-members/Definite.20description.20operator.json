[
    {
        "content": "<p>Is there something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">the</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>to obtain the unique element for which a predicate is true? In Isabelle, there exists axiomatically defined function <code>THE</code> which does exactly this. In Lean, destructuring an existential quantifier works only if the goal is a proposition.</p>",
        "id": 261613518,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1637053665
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.some\">docs#classical.some</a>. Uniqueness isn't necessary (and doesn't help in Lean's type theory, you still need to apply a classical axiom).</p>",
        "id": 261613744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637053798
    },
    {
        "content": "<p>I'm trying to implement something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">If exists unique `(x : α)` such that `P x`</span>\n<span class=\"cm\">   then return `f x`</span>\n<span class=\"cm\">   else return `z`</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 261616094,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1637055312
    },
    {
        "content": "<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">classical.choice</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>(untested since it wasn't a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>)</p>",
        "id": 261617166,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1637055988
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">classical.some</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">z</span>\n</code></pre></div>",
        "id": 261617290,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637056072
    },
    {
        "content": "<p>Also called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.epsilon\">docs#classical.epsilon</a></p>",
        "id": 261618941,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1637057042
    },
    {
        "content": "<p>Do you know about Martin Escardo's work on \"searchable sets\"?  <a href=\"https://www.cs.bham.ac.uk/~mhe/papers/omniscient-journal-revised.pdf\">https://www.cs.bham.ac.uk/~mhe/papers/omniscient-journal-revised.pdf</a></p>\n<p>By his definition, a set <code>X</code> is searchable if it has a function <code>ε : (X → 2) → X</code> such that for any <code>p : (X → 2)</code>, iff <code>p</code> has a root (i.e. a value <code>x ∈ X</code> such that <code>p x = 0</code>) then <code>ε p ∈ X</code> is a root of <code>p</code>.</p>\n<p>He's formalised this in Agda (<a href=\"https://www.cs.bham.ac.uk/~mhe/agda/CantorSearch.html\">https://www.cs.bham.ac.uk/~mhe/agda/CantorSearch.html</a>) and shown, for example, that the one-point compactification of <code>ℕ</code> is searchable.</p>\n<p>I don't know if any of this has been done in Lean yet.  I made a bit of progress with it a couple of months ago.</p>",
        "id": 261626042,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637061192
    },
    {
        "content": "<p>This notion kind of falls apart if the ambient logic is classical - every set is searchable</p>",
        "id": 261627364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637061879
    },
    {
        "content": "<p>What is the type <code>2</code> there? is it <code>fin 2</code> or something isomorphic like <code>bool</code>?</p>",
        "id": 261628381,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637062494
    },
    {
        "content": "<p>It's defined here: <a href=\"https://www.cs.bham.ac.uk/~mhe/agda/Two.html\">https://www.cs.bham.ac.uk/~mhe/agda/Two.html</a></p>",
        "id": 261628787,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637062764
    },
    {
        "content": "<p>it's <code>bool</code></p>",
        "id": 261629195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637063099
    },
    {
        "content": "<p>Is it possible to work in a constructive setting in Lean and mathlib?</p>",
        "id": 261629556,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1637063352
    },
    {
        "content": "<p>it's possible, but I don't think these results hold. I am very suspicious of the claim that 2^N_infty has decidable equality by lean's interpretation</p>",
        "id": 261630000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637063625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422543\">Stuart Presnell</span> <a href=\"#narrow/stream/113489-new-members/topic/Definite.20description.20operator/near/261629556\">said</a>:</p>\n<blockquote>\n<p>Is it possible to work in a constructive setting in Lean and mathlib?</p>\n</blockquote>\n<p>Yes, search for a post on Zulip that defines the <code>@[intuit]</code> attribute that requires a theorem to be constructive</p>",
        "id": 261631052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637064251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Definite.20description.20operator/near/261630000\">said</a>:</p>\n<blockquote>\n<p>it's possible, but I don't think these results hold. I am very suspicious of the claim that 2^N_infty has decidable equality by lean's interpretation</p>\n</blockquote>\n<p>I think this one is okay (only needs <code>funext</code>), but the one about searching the Cantor set requires internalizing some Brouwerian uniform continuity hypothesis</p>",
        "id": 261631940,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637064888
    },
    {
        "content": "<p>(I don't know if it's <em>required</em>, but that's what the Agda formalization does)</p>",
        "id": 261632026,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637064953
    },
    {
        "content": "<p>I think you're right:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.bool</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">enat'</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inf</span> <span class=\"o\">:</span> <span class=\"n\">enat'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">enat'.ext</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">enat'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x.1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">inf</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">funext</span> <span class=\"n\">H</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">enat'.mono</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">enat'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.1</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">x.1</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.le_induction</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"n\">_</span> <span class=\"n\">h'</span><span class=\"o\">))</span> <span class=\"n\">j</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">ℕ</span> <span class=\"n\">enat'</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lt_trans</span> <span class=\"o\">(</span><span class=\"n\">lt_add_one</span> <span class=\"n\">i</span><span class=\"o\">)⟩⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">enat'.eq_nat</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">enat'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">x.1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">nat.find_min'</span> <span class=\"n\">_</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">bool.coe_bool_iff.1</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">iff.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">to_bool_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">decidable.not_not.1</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">nat.find_min</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩)</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">mt</span> <span class=\"o\">(</span><span class=\"n\">enat'.mono</span> <span class=\"n\">x</span> <span class=\"n\">j</span> <span class=\"n\">i</span> <span class=\"n\">h₁</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h₂</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">selection</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">ε</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eps</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">enat'</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">enat'</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">to_bool</span> <span class=\"bp\">$</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"n\">k</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">nat.le_succ_of_le</span> <span class=\"n\">h</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">has_sel</span> <span class=\"o\">:</span> <span class=\"n\">selection</span> <span class=\"n\">enat'</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">eps</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">H</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">eps</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">inf</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">enat'.ext</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">by_contra</span> <span class=\"n\">H'</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">enat'.eq_nat</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">H'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">enat'</span><span class=\"o\">,</span> <span class=\"n\">x.1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">A</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">eq_ff_eq_not_eq_tt</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">lt_or_eq_of_le</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span> <span class=\"n\">h₁</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"n\">H</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">inf</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">rwa</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">enat'.ext</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">H'</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">enat'.eq_nat</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">H'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">enat'</span><span class=\"o\">,</span> <span class=\"n\">x.1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">inf</span><span class=\"o\">,</span> <span class=\"n\">eps</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"o\">(</span><span class=\"n\">enat'</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">eps</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">has_sel.2</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">congr_fun</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 261635093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637066955
    }
]
[
    {
        "content": "<p>greetings my new Friends! i like graph theory and automated theorem proving, looking forward to learning lean. Previously made a first order predicate logic theorem prover using linear resolution with paramodulation in the 1990's. Trying to understand lean better since last week i learned that the main theoretical math I help create twenty years ago was finally used in a proof using lean in \"A parametrized family of Tversky metrics connecting the Jaccard distance to an analogue of the normalized information distance\"</p>",
        "id": 260825662,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636476841
    },
    {
        "content": "<p>Paramodulation! We were having an interesting time with that a while ago trying to figure out the proof of things like <a href=\"#narrow/stream/116395-maths/topic/McCune's.20axiom\">McCune's axiom</a>. Welcome, you may want to check out [stream#graph theory]</p>",
        "id": 260826481,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636477301
    },
    {
        "content": "<p>thank you <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> i am in the stream and appreciate the pointer!</p>",
        "id": 260830910,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636479216
    },
    {
        "content": "<p>There has also been some discussion / PRs about Jaccard distance here before, hopefully you can find it by searching (I'm on mobile so unfortunately can't right now)</p>",
        "id": 260833909,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1636480363
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"456371\">@Rudi Cilibrasi</span> I am new to lean and I like graph theory too. If you'd want to team up, I'm a bit stuck on <a href=\"https://github.com/leanprover-community/mathlib/tree/graph-coloring-homomorphism\">this branch</a>. We're trying to formalize graph coloring as an homomorphism to a complete graph. You can check <code>src/combinatorics/simple_graph/coloring.lean</code></p>",
        "id": 260845220,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636484779
    },
    {
        "content": "<p>thank you Arthur! that would be awesome if i can reach that level but first i will need to do the basic tutorial and environment install. thank you for this invitation it seems like a perfect introduction unless i discover it's really too hard in which case i am still happy for the practice learning</p>",
        "id": 260853010,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636488293
    },
    {
        "content": "<p>Several people have learnt a working knowledge of Lean by working on graph theory -- I think it's quite a nice entry point.</p>",
        "id": 261003293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636557071
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"456371\">@Rudi Cilibrasi</span> ! That's my paper - <a href=\"https://arxiv.org/abs/2111.02498\">https://arxiv.org/abs/2111.02498</a> (notice the \"Code &amp;Data\" link) I got a lot of help from people here on the Lean part, see <a href=\"#narrow/stream/113488-general/topic/Jaccard.20distance\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Jaccard.20distance</a> The paper is about an analogue of the NID (normalized information distance). Formalizing the NID itself would require first formalizing Kolmogorov complexity which I don't think has been done(?).</p>",
        "id": 261047935,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1636575162
    },
    {
        "content": "<p>Wow thanks for this great detail Bjorn!</p>",
        "id": 261048042,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636575215
    },
    {
        "content": "<p>Have we got a Turing machine in math lib yet by any chance?</p>",
        "id": 261048101,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636575239
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/computability/turing_machine.html\">https://leanprover-community.github.io/mathlib_docs/computability/turing_machine.html</a></p>",
        "id": 261048486,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1636575382
    },
    {
        "content": "<p>I don't see anything about existence of a universal Turing machine there, though?</p>",
        "id": 261049728,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1636575913
    },
    {
        "content": "<p>There is a universal partial recursive function, and some work on connecting turing machines to the partial recursive functions that is mostly complete but not all the library lemmas are there</p>",
        "id": 261049999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576063
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib_docs/computability/halting.html\">https://leanprover-community.github.io/mathlib_docs/computability/halting.html</a> for stuff about universal machines</p>",
        "id": 261050104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576118
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> great, the universal partial recursive function could be used to define Kolmogorov complexity I suppose</p>",
        "id": 261050108,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1636576121
    },
    {
        "content": "<p>yes, I think that would work fine</p>",
        "id": 261050153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576146
    },
    {
        "content": "<p>There is the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.partrec.code\">docs#nat.partrec.code</a> type for expressing partial recursive functions as elements of a countable type</p>",
        "id": 261050241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576176
    },
    {
        "content": "<p>is a countable type like peano integers?</p>",
        "id": 261050558,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636576313
    },
    {
        "content": "<p>more precisely, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/denumerable\">docs#denumerable</a></p>",
        "id": 261050661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576358
    },
    {
        "content": "<p>i see zero and succ which seem familiar to me from that in that code</p>",
        "id": 261050666,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636576360
    },
    {
        "content": "<p>yes, <code>nat</code> is the canonical denumerable type</p>",
        "id": 261050689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576374
    },
    {
        "content": "<p>a denumerable type is one that is isomorphic to <code>nat</code></p>",
        "id": 261050715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576393
    },
    {
        "content": "<p>great makes total sense</p>",
        "id": 261050732,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636576404
    },
    {
        "content": "<p>in particular, this matters for encoding because the isomorphism gives you a way to assign bit sequences or so to individual programs</p>",
        "id": 261050826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576452
    },
    {
        "content": "<p>so you can ask what is the 5th program</p>",
        "id": 261050868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576479
    },
    {
        "content": "<p>and more complicated programs get bigger numbers</p>",
        "id": 261050901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576496
    },
    {
        "content": "<p>yes that seems pretty close to what would be required to define K and C kolmogorov complexity</p>",
        "id": 261050962,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636576526
    },
    {
        "content": "<p>Btw I was reading <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/computability/turing_machine.lean\"><code>turing_machine.lean</code></a> today (haven't finished it yet) and it inspired me <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 261051659,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636576871
    },
    {
        "content": "<p>incidentally, the 5th program is <code>prec zero zero</code> which is another way of writing the zero function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">computability.halting</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat.partrec</span> <span class=\"o\">(</span><span class=\"n\">code</span><span class=\"o\">)</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">has_reflect</span><span class=\"o\">]</span> <span class=\"n\">code</span>\n<span class=\"k\">#eval</span> <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">denumerable.of_nat</span> <span class=\"n\">code</span> <span class=\"mi\">5</span> <span class=\"k\">in</span> <span class=\"n\">pp</span> <span class=\"o\">(</span><span class=\"n\">reflect</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"c1\">-- prec zero zero</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"n\">denumerable.of_nat</span> <span class=\"n\">code</span> <span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"mi\">42</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">undefined</span> <span class=\"c1\">-- f 42 = 0</span>\n</code></pre></div>",
        "id": 261051710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636576903
    },
    {
        "content": "<p>What about the 37th program</p>",
        "id": 261051912,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636577016
    },
    {
        "content": "<p>that seems more useful</p>",
        "id": 261051922,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636577021
    },
    {
        "content": "<p>that's <code>prec left left</code> apparently, which is <code>0</code> for <code>0</code> and <code>(nat.unpair (n-1)).1</code> otherwise</p>",
        "id": 261052173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636577151
    },
    {
        "content": "<p>wow these are great programs!</p>",
        "id": 261052503,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636577311
    },
    {
        "content": "<p>i shouldn't let my imagine wander too far but i wonder how big the program must be to be turing complete</p>",
        "id": 261052606,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636577369
    },
    {
        "content": "<p>my friend john tromp is super into that question and has enjoyed writing up some pretty small turing machines on the order of dozens of bytes<br>\n... the rules aren't totally clear to that game though in the literature imo. which is why finding an answer with lean would be super interesting.</p>",
        "id": 261052751,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636577441
    },
    {
        "content": "<p>I really enjoyed watching the discussion around Aaronson &amp; Yedidia's <a href=\"https://scottaaronson.blog/?p=2725\">search for the smallest unprovably halting TM</a>, which resulted in an <a href=\"https://github.com/sorear/metamath-turing-machines\">optimizing compiler for turing machines</a></p>",
        "id": 261053043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636577587
    },
    {
        "content": "<p>In principle, you should be able to extract the proof of computability in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.partrec.code.eval_part\">docs#nat.partrec.code.eval_part</a> and turn the witness into a number, but I have reasons to believe that the result is very large and lean will probably not be able to handle it</p>",
        "id": 261053737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636577923
    },
    {
        "content": "<p>While it's not a Turing machine, the binary lambda calculus is kind of neat. There's a 206 bit self-interpreter at <a href=\"https://tromp.github.io/cl/cl.html\">https://tromp.github.io/cl/cl.html</a> (more details: <a href=\"https://tromp.github.io/cl/Binary_lambda_calculus.html\">https://tromp.github.io/cl/Binary_lambda_calculus.html</a>)</p>",
        "id": 261053922,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636578007
    },
    {
        "content": "<p>i installed lean just now and the vscode extension to try to reproduce Mario first example above for program 5. i cannot import computability.halting should i use elan to fix  it or what?</p>",
        "id": 261054104,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636578076
    },
    {
        "content": "<p>yup thats my john too kyle he is super into it</p>",
        "id": 261054305,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636578155
    },
    {
        "content": "<p>You need mathlib as well. See <a href=\"https://leanprover-community.github.io/get_started.html\">https://leanprover-community.github.io/get_started.html</a></p>",
        "id": 261054372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636578193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456371\">Rudi Cilibrasi</span> <a href=\"#narrow/stream/113489-new-members/topic/algorithmic.20information.20theory/near/261054305\">said</a>:</p>\n<blockquote>\n<p>yup thats my john too kyle he is super into it</p>\n</blockquote>\n<p>(Oh, I completely missed that you said his last name earlier!)</p>",
        "id": 261054557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636578267
    },
    {
        "content": "<p>how do i install computability.halting i am having trouble with the command<br>\ni think i have mathlib in there but i guess i can't be sure</p>",
        "id": 261055909,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636578967
    },
    {
        "content": "<p>i tried on two different linux</p>",
        "id": 261055935,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636578983
    },
    {
        "content": "<p>Otherwise pipx is ready to go! <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span> <span aria-label=\"glowing star\" class=\"emoji emoji-1f31f\" role=\"img\" title=\"glowing star\">:glowing_star:</span> <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span><br>\n  installed package mathlibtools 1.1.0, Python 3.8.10<br>\n  These apps are now globally available</p>\n<div class=\"codehilite\"><pre><span></span><code>- leanproject\n</code></pre></div>\n\n<p>done! <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span> <span aria-label=\"glowing star\" class=\"emoji emoji-1f31f\" role=\"img\" title=\"glowing star\">:glowing_star:</span> <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span><br>\nrudi@rsys:~$ cd ~/tmp</p>",
        "id": 261056070,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636579065
    },
    {
        "content": "<p>oh maybe pipx?</p>",
        "id": 261056211,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636579138
    },
    {
        "content": "<p>probably i will have to run a tutorial to figure out this new package management tool and determine if i really have mathlib or not. at least the eval 1+1 part did appear to work so something is working</p>",
        "id": 261056452,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636579272
    },
    {
        "content": "<p>Are you following the instructions at <a href=\"https://leanprover-community.github.io/install/debian.html\">https://leanprover-community.github.io/install/debian.html</a> ? And then on the linked at the bottom for lean projects?</p>",
        "id": 261057117,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1636579591
    },
    {
        "content": "<p>Or <a href=\"https://leanprover-community.github.io/install/linux.html\">https://leanprover-community.github.io/install/linux.html</a> if not debian/ubntu?</p>",
        "id": 261057167,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1636579621
    },
    {
        "content": "<p>yes i did follow that page... the wget way twice and also went through the long step way a bit too.. i am on 20.04 ubu<br>\nbut i did not do lean projects at the bottom yet i guess that could be my problem</p>",
        "id": 261057207,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636579646
    },
    {
        "content": "<p>oh i see now i must need a project to add deps. cool! ty Alex</p>",
        "id": 261057316,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636579700
    },
    {
        "content": "<p>Yes mathlibtools is a helpful python package, it won't download any actual mathlib olean files for you to import things unless you give it a reason to, either you are working on your own local fork of mathlib, or a project that depends on it.</p>",
        "id": 261057366,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1636579730
    },
    {
        "content": "<p>it works now i verified mario's first result. ty for help friends i have tried lean a few times before in earlier years and version 2 but i never got far and now in only one afternoon i feel like i am already equipped to make independent slow progress.</p>",
        "id": 261060362,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636581321
    },
    {
        "content": "<p>i am able to read and understand the <code>succ</code> and <code>zero</code> definitions in nat.partrec.code quite easily but the <code>id</code>, <code>pair</code>, <code>left</code>, and <code>right</code> are confusing me. i feel like i am not getting it. i am familiar with tuples, cartesian pairs, currying and element-extraction functions in other languages and high school math. i reviewed the equations definition in partrec_code.html for these and still feel like i must be missing some code. i'm familiar with how to draw a spiral in cartesian integers to show equivalence of the lattice to the line and back but i don't quite see it here yet. just another newbie question when somebody has time. meanwhile i will start to work more tutorial</p>",
        "id": 261065803,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636583967
    },
    {
        "content": "<p>Note that <code>nat.partrec.code</code> doesn't explain what the functions actually do, it is only the raw structure of the program. A better place to look to understand what all the constructors do is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.partrec\">docs#nat.partrec</a>, which has the exact same constructors but it is talking about actual <code>nat -&gt;. nat</code> partial functions</p>",
        "id": 261066523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636584353
    },
    {
        "content": "<p>In particular, to understand what <code>left</code> and <code>right</code> are doing you should look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.unpair\">docs#nat.unpair</a> - the short answer is that it is the inverse to the cantor pairing function (or rather a slight variant on the cantor pairing function)</p>",
        "id": 261066732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636584469
    },
    {
        "content": "<p>We use these functions so that we can pack multiple variables into a single <code>nat</code>, using <code>pair</code> to put nats together and <code>left</code>/<code>right</code> to pull out the pieces</p>",
        "id": 261066883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636584554
    },
    {
        "content": "<p>ok i've invited some of my science friends paul and joseph and soon i think i will invite john<br>\nlean is so much cooler now with the zulipchat :)</p>",
        "id": 261086000,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636598183
    },
    {
        "content": "<p>i want to get this K or C kolmogorov complexity show on the road</p>",
        "id": 261086016,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636598204
    },
    {
        "content": "<p>usually i think the most important weird math function necessary when talking about K and C is log.  I see there is a <code>nat/log</code> in mathlib would that be appropriate to use for proofs bounding K and C?</p>",
        "id": 261132001,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636636577
    },
    {
        "content": "<p>Looks like <code>nat.clog</code> would be more useful when the log is in the upper bound</p>",
        "id": 261160993,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1636650968
    },
    {
        "content": "<p>And <code>nat.log</code> when it's in a lower bound of K or C</p>",
        "id": 261161121,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1636651042
    },
    {
        "content": "<p>excellent hint ty Bjorn!</p>",
        "id": 261161233,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636651087
    },
    {
        "content": "<p>Hmm I think maybe our aforementioned <span class=\"user-mention\" data-user-id=\"456970\">@John Tromp</span> could be awake …</p>",
        "id": 261187478,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636666911
    },
    {
        "content": "<p>hi, Rudi</p>",
        "id": 261187484,
        "sender_full_name": "John Tromp",
        "timestamp": 1636666917
    },
    {
        "content": "<p>and lean fans</p>",
        "id": 261187532,
        "sender_full_name": "John Tromp",
        "timestamp": 1636666932
    },
    {
        "content": "<p>We have been talking about formalizing K and C in here as shown above largely based on Mario work already done with partial recursive universal fn</p>",
        "id": 261187614,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636667030
    },
    {
        "content": "<p>i don't know much about lean, but happy to answer any questions about binary lambda calculus</p>",
        "id": 261187683,
        "sender_full_name": "John Tromp",
        "timestamp": 1636667063
    },
    {
        "content": "<p>We also noticed lean mathlib already has nat log and clog suitable for basic theorems about K and C</p>",
        "id": 261187707,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636667088
    },
    {
        "content": "<p>i guess lean can prove any reduction in the untyped lambda calculus?</p>",
        "id": 261187730,
        "sender_full_name": "John Tromp",
        "timestamp": 1636667110
    },
    {
        "content": "<p>Oh I would assume so. It was <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> who mentioned the binary lambda calc</p>",
        "id": 261187771,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636667162
    },
    {
        "content": "<p>what is K and C? Does that stand for something?</p>",
        "id": 261187930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636667267
    },
    {
        "content": "<p>Lambda calculus is not defined in mathlib, but it could be</p>",
        "id": 261187999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636667297
    },
    {
        "content": "<p>i use KS and KP in my paper instead of C and K</p>",
        "id": 261188030,
        "sender_full_name": "John Tromp",
        "timestamp": 1636667324
    },
    {
        "content": "<p>are these combinators?</p>",
        "id": 261188049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636667339
    },
    {
        "content": "<p>KS/C is plain complexity, with delimited programs</p>",
        "id": 261188056,
        "sender_full_name": "John Tromp",
        "timestamp": 1636667342
    },
    {
        "content": "<p>oh, that</p>",
        "id": 261188075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636667360
    },
    {
        "content": "<p>KP is prefix complexity, with self-delimited programs</p>",
        "id": 261188101,
        "sender_full_name": "John Tromp",
        "timestamp": 1636667374
    },
    {
        "content": "<p>How precisely do you want to get the kolmogorov complexity definition? As I understand it you can get within a constant additive factor without trouble but the exact definition is language dependent</p>",
        "id": 261188229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636667432
    },
    {
        "content": "<p>so that would mean formalizing e.g. binary lambda calculus</p>",
        "id": 261188262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636667457
    },
    {
        "content": "<p>rather than anything with equivalent computational strength</p>",
        "id": 261188276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636667471
    },
    {
        "content": "<p>yes, for theorem proving you want precise definitions. such as the TMs counted in <a href=\"https://oeis.org/A141475\">https://oeis.org/A141475</a></p>",
        "id": 261189085,
        "sender_full_name": "John Tromp",
        "timestamp": 1636668052
    },
    {
        "content": "<p>or the KP/KS in my paper</p>",
        "id": 261189328,
        "sender_full_name": "John Tromp",
        "timestamp": 1636668252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456970\">@John Tromp</span> There's a variation on binary lambda calculus that I've played with a little, but I haven't tried making a competitive self-interpreter with it yet (and I don't really expect it to be able to make terser programs).  The idea is you let the De Bruijn indexing's successor (that's usually only for indices) apply to entire expressions.  The interpretation is that everything inside the successor of an expression forgets the current innermost binding.  This lets you factor out taking successors in applications if both variables in the application are nonzero indices.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">lambda</span>\n<span class=\"bp\">|</span> <span class=\"n\">get</span> <span class=\"o\">:</span> <span class=\"n\">lambda</span>\n<span class=\"bp\">|</span> <span class=\"n\">drop</span> <span class=\"o\">:</span> <span class=\"n\">lambda</span> <span class=\"bp\">→</span> <span class=\"n\">lambda</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">lambda</span> <span class=\"bp\">→</span> <span class=\"n\">lambda</span> <span class=\"bp\">→</span> <span class=\"n\">lambda</span>\n<span class=\"bp\">|</span> <span class=\"n\">abs</span> <span class=\"o\">:</span> <span class=\"n\">lambda</span> <span class=\"bp\">→</span> <span class=\"n\">lambda</span>\n</code></pre></div>\n<p>For the binary encoding, it's still a prefix code, but the codes are now just all four two-bit sequences.</p>",
        "id": 261189989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636668773
    },
    {
        "content": "<p>so drop E is E with all de bruijin indices of free variables increased by 1?</p>",
        "id": 261190669,
        "sender_full_name": "John Tromp",
        "timestamp": 1636669299
    },
    {
        "content": "<p>and then get is equivalent to var 0</p>",
        "id": 261190880,
        "sender_full_name": "John Tromp",
        "timestamp": 1636669443
    },
    {
        "content": "<p>interesting variation!</p>",
        "id": 261190932,
        "sender_full_name": "John Tromp",
        "timestamp": 1636669468
    },
    {
        "content": "<p>Yep, or if you're thinking about it in terms of an evaluator that has a list of values for each de Bruijn binding, <code>drop</code> drops the first entry of the list, and <code>get</code> gets the first entry.</p>",
        "id": 261190962,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636669502
    },
    {
        "content": "<p>for instance S = \\ \\ \\  2 0 (1 0) becomes \\ \\ \\  (+ + 0) 0 ((+ 0) 0)</p>",
        "id": 261191103,
        "sender_full_name": "John Tromp",
        "timestamp": 1636669591
    },
    {
        "content": "<p>in which case you get no savings, and get a longer program</p>",
        "id": 261191146,
        "sender_full_name": "John Tromp",
        "timestamp": 1636669630
    },
    {
        "content": "<p>hard to say if the interpreter would get longer or shorter though. without actually writing it out</p>",
        "id": 261191389,
        "sender_full_name": "John Tromp",
        "timestamp": 1636669813
    },
    {
        "content": "<p>i'll try it out tomorrow. close to bedtime now:)</p>",
        "id": 261193082,
        "sender_full_name": "John Tromp",
        "timestamp": 1636671062
    },
    {
        "content": "<p>the interpreter itself becomes simpler, but its encoding becomes larger: 222 instead of 206 bits</p>",
        "id": 261285434,
        "sender_full_name": "John Tromp",
        "timestamp": 1636738513
    },
    {
        "content": "<p>so for the goal of minimizing program sizes, i should stick with the current variable encoding</p>",
        "id": 261285513,
        "sender_full_name": "John Tromp",
        "timestamp": 1636738560
    },
    {
        "content": "<p>btw, there is only one occurrence in the interpreter where a drop can apply to an expression larger than one variable</p>",
        "id": 261285714,
        "sender_full_name": "John Tromp",
        "timestamp": 1636738663
    },
    {
        "content": "<p>Interesting -- thanks for looking into it.  The reason I'd thought of it in the first place was to simplify case dispatch in the main loop, since there's now only a single inductive type rather than two.</p>\n<p>Do you think it could be improved by using a base-4 stream with the encoding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>λ</mi><mi>λ</mi><mi>λ</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda\\lambda\\lambda\\lambda i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λλλλi</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">i=0,1,2,3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span></span></span></span>?  (Each of these would still count as two bits of course.)</p>",
        "id": 261286913,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636739258
    },
    {
        "content": "<p>Hey is <span class=\"user-mention\" data-user-id=\"457213\">@Joseph Dimos</span> here yet?</p>",
        "id": 261292702,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636741836
    },
    {
        "content": "<p>Greetings everyone! I like argumentation theory and its alignment with ATP. I often venture into applied category theory problems that interlace with satisfiability problems. Previously, I defined a formal chaining inside linear temporal logic and defined a dualistic theme for doxastic and epistemic logics according to belief probability. I'm also involved in some quantum gravity related problems that interlace 6j symbols with fusion categories in gauge theory. I'm quite interested in Lean, but am still learning its many facets.</p>",
        "id": 261293834,
        "sender_full_name": "Joseph Dimos",
        "timestamp": 1636742380
    },
    {
        "content": "<p>Glad to see you here Joseph!</p>",
        "id": 261294533,
        "sender_full_name": "Rudi Cilibrasi",
        "timestamp": 1636742711
    },
    {
        "content": "<p>no, the interpreter makes very good use of the 2-bit encoding. moving to base 4 would certainly expand it significantly</p>",
        "id": 261307911,
        "sender_full_name": "John Tromp",
        "timestamp": 1636749662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456371\">Rudi Cilibrasi</span> <a href=\"#narrow/stream/113489-new-members/topic/algorithmic.20information.20theory/near/261294533\">said</a>:</p>\n<blockquote>\n<p>Glad to see you here Joseph!</p>\n</blockquote>\n<p>Wow, you can wish people in existence!</p>",
        "id": 261319646,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636756127
    },
    {
        "content": "<p>Btw, there's a language called \"Real Fast Nora's Hair Salon 3: Shear Disaster Download\" (yes, really!) that looks similar to your proposal, Kyle.</p>",
        "id": 261409068,
        "sender_full_name": "John Tromp",
        "timestamp": 1636883938
    },
    {
        "content": "<p><a href=\"https://esolangs.org/wiki/Real_Fast_Nora%27s_Hair_Salon_3:_Shear_Disaster_Download\">https://esolangs.org/wiki/Real_Fast_Nora%27s_Hair_Salon_3:_Shear_Disaster_Download</a></p>",
        "id": 261409074,
        "sender_full_name": "John Tromp",
        "timestamp": 1636883950
    },
    {
        "content": "<p>Except they forgot to generalize to applying the ONE MORE THAN operator to arbitrary terms (while changing its encoding to 11).</p>",
        "id": 261409126,
        "sender_full_name": "John Tromp",
        "timestamp": 1636884007
    },
    {
        "content": "<p>Wow, the guy who made that is called Nathan van Doorn, but they are <a href=\"https://mobile.twitter.com/Ngevd/status/1420306626012196871\">not related to Floris</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://mobile.twitter.com/Ngevd/status/1420306626012196871\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/4c7109efa1c506d4de6287c9ea4ccb02e1e070c8/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3839353032343830393334373737363531322f713047484a4977435f6e6f726d616c2e6a7067\"></a><p>It strikes me as a very weird coincidence that there's someone out there doing the kind of research that I'd very much like to be doing, with the same fairly uncommon surname as me, who is not to my knowledge related to me (if you read this, hi Floris)</p><span>- Nathan van Doorn (@Ngevd)</span></div></div>",
        "id": 261409448,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636884513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> just to check you see this!</p>",
        "id": 261413873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636891337
    },
    {
        "content": "<p>Haha, that's great. I've contacted him.</p>",
        "id": 261415576,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1636894074
    },
    {
        "content": "<p>Thanks for the ping.</p>",
        "id": 261415614,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1636894083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456970\">@John Tromp</span> I guess my variant must be \"Real Fast Nora's Hair Salon 4: A Little off the Top\"</p>",
        "id": 261426176,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636908318
    }
]
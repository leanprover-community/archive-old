[
    {
        "content": "<p>I'm trying to prove the following statement</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">power_inverse</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">^</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n\n<p>and it looks to me from the docs that <code>real.rpow_mul</code> is a lemma that I might want to use. But when I tried to start the proof as follows:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">begin</span>\n<span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"n\">ha</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">))],</span>\n<span class=\"bp\">...</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>it seems that lean can't figure out the coersions of <code>1/b</code> and <code>b</code> and I get a <code>rewrite tactic failed, did not find instance of the pattern in the target expression \\n     (a ^ (1 / ↑b)) ^ ↑b</code>.  But if I replace the <code>b</code> with <code>↑b</code>, then it gives me a <code>don't know how to synthesize placeholder</code> error.</p>\n<p>Can anyone help me deal with these coercions? Or, is there a more automatic way to do things like this that I'm missing?</p>",
        "id": 195794486,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1588216340
    },
    {
        "content": "<p>Whenever you get stuck with coercions like this its important to work out exactly what types everything is.<br>\nYou can do this in a couple of ways, by setting <code>set_option pp.all true</code> will show you everything, but in this case you can also add <code>dsimp [(^)],</code> to see what <code>^</code> is being used here. In either case you'll see its taking real to a <code>nat</code> power, which is not what you intended. <code>1/b</code> is being interpreted as the nat <code>1/b</code>  (likely just 0).</p>",
        "id": 195794772,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1588216779
    },
    {
        "content": "<p>So a corrected (but not completely correct yet) statement would be</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">power_inverse</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"n\">ha</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 195794930,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1588216970
    },
    {
        "content": "<p>Thanks so much! All of this was extremely helpful! I've now successfully proven my lemma, which looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">power_inverse</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"n\">ha</span><span class=\"o\">],</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"k\">calc</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">((</span><span class=\"err\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"err\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">inv_mul_cancel</span> <span class=\"n\">hb</span><span class=\"o\">]</span>\n      <span class=\"bp\">...</span>               <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>The proof I used though is a bit verbose, and I'd like to make it shorter. In particular, <br>\n1) I can't figure out how to get <code>simp</code> to use the <code>field.inv_mul_cancel</code> lemma (which is marked <code>@[simp]</code>)<br>\n2) It might be nice to have <code>hb</code> be of type <code>b ≠ 0</code> rather than <code>(b : ℝ) ≠ 0</code>, but I don't know how to easily make <code>b</code> promote it's type.<br>\nHow might I go about solving these?</p>",
        "id": 195862135,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1588262811
    },
    {
        "content": "<p>Well if you want to make it short you can just use an explicit chain of rewrites in place of invoking simp, and not use a calc block (but calc blocks look nice)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">power_inverse</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">one_div_eq_inv</span><span class=\"o\">,</span> <span class=\"n\">inv_mul_cancel</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_one</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 195864614,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1588263945
    },
    {
        "content": "<p>If you want simp to use <code>inv_mul_cancel</code> I believe you'll need to supply <code>hb</code> to simp, </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">power_inverse</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"n\">ha</span><span class=\"o\">],</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 195867402,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1588265133
    },
    {
        "content": "<p>Though in fact simp uses a different lemma <code>inv_mul_cancel'</code> in this case instead of the one you has in mind, which applies instead to groups with zero, rather than just division rings.</p>",
        "id": 195867585,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1588265183
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">calculus</span><span class=\"bp\">.</span><span class=\"n\">specific_functions</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">power_inverse</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[(</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">rpow_mul</span> <span class=\"n\">ha</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 195874110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588267930
    }
]
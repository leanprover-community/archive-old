[
    {
        "content": "<p>Hi, I have encountered the following error and I can't figure out why, any help would be greatly appreciated:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"k\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">comm_semiring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span> <span class=\"err\">↥</span><span class=\"n\">K</span>\n</code></pre></div>\n\n\n<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ring_exp</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">opposites</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">commute</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">quadratic_form</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"c1\">-- [Q : quadratic_form K V]</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">extends</span> <span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">G</span>\n <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inner_product</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>The background is that I need K ⊆ G and V ⊆ G and they need to share the same +, * and follow the same basic arithmetic rules.</p>\n<p>Reference: <a href=\"https://en.wikipedia.org/wiki/Geometric_algebra\">https://en.wikipedia.org/wiki/Geometric_algebra</a></p>",
        "id": 199892250,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591370593
    },
    {
        "content": "<p>I get a different error message, but the problem seems to be the <code>[is_subring K]</code>. Lean can infer that <code>K</code> is a ring from <code>[field K]</code>. Below, when I ask Lean to print everything and I give it the instance explicitly, it complains that it is trying to match the two different ring instance for <code>K</code> and failing. Why do you need <code>[is_subring K]</code>? If I comment it out, the definition works for me.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ring_exp</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">opposites</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">commute</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">quadratic_form</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"c1\">-- [Q : quadratic_form K V]</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">extends</span> <span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">G</span>\n <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inner_product</span> <span class=\"o\">:</span> <span class=\"n\">quadratic_form</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 199902829,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1591374998
    },
    {
        "content": "<p>I need it because there's another property I need that is <code>\\forall v : V, v*v \\in K</code></p>",
        "id": 199903683,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591375387
    },
    {
        "content": "<p>I can tell the direct cause from the error massage but don't know if it's a limitation of Lean or I'm puting the assumption at the wrong location</p>",
        "id": 199903951,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591375516
    },
    {
        "content": "<p>Three places to choose from: [] before extends, after extends, after :=</p>",
        "id": 199904090,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591375578
    },
    {
        "content": "<p>By limitation I mean whether one type can be sub-something and something++ and Lean knows the duplication of specifying something is acceptable</p>",
        "id": 199904701,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591375864
    },
    {
        "content": "<p>If I understand correctly, what is happening is that you are giving <code>K</code> two different (and possibly entirely unrelated) ring structures. I don't think the type classes are set up to do exactly what you want. Hmm.....</p>",
        "id": 199904863,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1591375945
    },
    {
        "content": "<p>Yes, I guess that's the root cause and I need to try doing it in another way.</p>",
        "id": 199905162,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376087
    },
    {
        "content": "<p>I think you need to define a special structure for <code>is_subfield K</code>, write down the axioms that describe that, and then show <code>is_subring K</code> and <code>field K</code> both follow.</p>",
        "id": 199905264,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1591376136
    },
    {
        "content": "<p>but G is not a field...</p>",
        "id": 199905371,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376181
    },
    {
        "content": "<p>(Where <code>is_subfield K</code> says, roughly, that <code>K</code> is equipped with a division that makes it both a field and a subring of the bigger ring. Maybe there is a better name for that, like <code>is_field_as_subring K</code>.)</p>",
        "id": 199905427,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1591376217
    },
    {
        "content": "<p>I see, that seems ok</p>",
        "id": 199905517,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376274
    },
    {
        "content": "<p>I'll try that, thanks!</p>",
        "id": 199905619,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> In practice it seems to be better in the long run to work with injective structure preserving functions rather than <code>set G</code></p>",
        "id": 199905673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591376357
    },
    {
        "content": "<p>(In the perfectoid project we had the definition of a Huber pair, which is a ring <code>A</code> and a subring <code>A^+</code>...</p>",
        "id": 199905747,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591376398
    },
    {
        "content": "<p>And after a while we realised that we couldn't prove that <code>Z_p, Q_p</code> was an example.</p>",
        "id": 199905833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591376426
    },
    {
        "content": "<p>Because in lean, <code>Z_p</code> is not a subring of <code>Q_p</code>, even though there is a injective ring homomorphism.</p>",
        "id": 199905878,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591376452
    },
    {
        "content": "<p>So then we changed the definition, to use an injective ring hom (or algebra), and most proofs stayed the same, some became shorter.</p>",
        "id": 199905944,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591376489
    },
    {
        "content": "<p>In general it was just a lot more pleasant to work with.</p>",
        "id": 199905966,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591376501
    },
    {
        "content": "<p>That's because I just found out how to write <code>is_subring A B</code> (not Lean) from Zulip chat history</p>",
        "id": 199905971,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376502
    },
    {
        "content": "<p>broken into <code>A : set B</code> and <code>is_subring A</code>...</p>",
        "id": 199906245,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376615
    },
    {
        "content": "<p>strictly speaking, in my case, K is indeed not a subring of G</p>",
        "id": 199906562,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376778
    },
    {
        "content": "<p>the hom approach is more accurate</p>",
        "id": 199906614,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591376815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/199905944\">said</a>:</p>\n<blockquote>\n<p>So then we changed the definition, to use an injective ring hom (or algebra), and most proofs stayed the same, some became shorter.</p>\n</blockquote>\n<p>The PR seems to be <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/pull/56\">https://github.com/leanprover-community/lean-perfectoid-spaces/pull/56</a> and particular <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/pull/56/commits/2b6a01f707f667f0c761250d7784bc38b4ff6062\">this commit</a>.</p>\n<p>The related code are:</p>\n<ol>\n<li>in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_theory.algebra\">docs#ring_theory.algebra</a></li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">commutes&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">to_fun</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_def&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- Embedding `R →+* A` given by `algebra` structure. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">algebra_map</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span>\n</code></pre></div>\n\n\n<ol start=\"2\">\n<li>in <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/Huber_pair.lean\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/Huber_pair.lean</a></li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">plus</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">plus</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">plus</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">Huber</span> <span class=\"o\">:</span> <span class=\"n\">Huber_ring</span> <span class=\"n\">carrier</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">alg</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">plus</span> <span class=\"n\">carrier</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">intel</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_of_integral_elements</span> <span class=\"n\">plus</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">⁺</span><span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">66</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">plus</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"err\">⁺</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"err\">⁺</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">top</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Huber_ring</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Huber</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"err\">⁺</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">alg</span>\n</code></pre></div>",
        "id": 200026861,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591540834
    },
    {
        "content": "<p>From this example now I can see clearly why <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> said that <code>B : subring C</code> and  <code>algebra B C</code> are kind of the same in  <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191348229\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191348229</a> (found during searching for a proper solution for my issue here) .</p>",
        "id": 200027157,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591541098
    },
    {
        "content": "<p>BTW, I don't know we can do <code>[]</code> after <code>:=</code>  too(I always wondered how we can reference the algebraic structure), only that it can be used before <code>extends</code>, and we can do it between <code>extends</code> and <code>:=</code> without the <code>[]</code>.</p>",
        "id": 200027294,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591541362
    },
    {
        "content": "<p>And how do we decide where to put <code>[]</code>(the type class arguments)? I'm very confused now. All three places seem to be legal, this seems to be just a mathematical design principle issue.</p>",
        "id": 200027595,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591541799
    },
    {
        "content": "<p>If you're talking about defining structures and classes, then <code>[]</code> after <code>:=</code> means that you tell it the instance at the same time as you're making the structure. Before the <code>:=</code> Lean will try to make the instance before you have even started making the structure</p>",
        "id": 200027688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591541992
    },
    {
        "content": "<p>Thanks, but what it means for the definition, mathematically?</p>",
        "id": 200028349,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591543049
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ring_exp</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">opposites</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">commute</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">quadratic_form</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">class</span> <span class=\"n\">test</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">space</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">test</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"c1\">-- test.mk ℝ ℝ : test</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"n\">test_rr</span> <span class=\"o\">:</span> <span class=\"n\">test</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n  <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">class</span> <span class=\"n\">test&#39;</span>\n<span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">space</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">test&#39;</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"c1\">-- test&#39; ℝ ℝ : Type</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">test&#39;_rr</span> <span class=\"o\">:</span> <span class=\"n\">test&#39;</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- by apply_instance -- tactic.mk_instance failed to generate instance for</span>\n\n<span class=\"n\">class</span> <span class=\"n\">test&#39;&#39;</span>\n<span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">extends</span> <span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"c1\">-- invalid &#39;structure&#39; extends, &#39;vector_space&#39; is not a structure</span>\n</code></pre></div>",
        "id": 200028361,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591543071
    },
    {
        "content": "<p>Finally I got to my x of the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> , here's a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>  that's actually working :</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">ring_exp</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">opposites</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">commute</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">quadratic_form</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lift</span> <span class=\"n\">K</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lift</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)]</span>\n<span class=\"o\">(</span><span class=\"n\">v_sq_in_k</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lift</span> <span class=\"n\">K</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lift</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">GA</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">G</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- the trivial case: prove ℝ is a GA</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_lift</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">lift</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">assoc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">semigroup</span><span class=\"bp\">.</span><span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n    <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">distrib</span><span class=\"bp\">.</span><span class=\"n\">left_distrib</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n    <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">distrib</span><span class=\"bp\">.</span><span class=\"n\">right_distrib</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n    <span class=\"n\">v_sq_in_k</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n        <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">v</span><span class=\"o\">),</span>\n        <span class=\"n\">refl</span>\n    <span class=\"kn\">end</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>\n\n\n<p>But I have 3 new questions:</p>\n<p>Q1: How can I express that there should exist only one k? (by changing \\in to \\exist, I avoided the <code>has_mem</code> issues but it seems not completely safe)</p>\n<p>Q2: Why do I have to write an instance for <code>has_lift ℝ ℝ</code>? Shouldn't it be automatically inferred?</p>\n<p>Q3: Why can't <code>assoc</code>, <code>left_distrib</code>, <code>right_distrib</code> be automatically inferred?</p>",
        "id": 200032447,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591549191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> You are requiring <code>[ring G]</code> and afterwards you have axioms <code>assoc</code>, <code>left_distrib</code>, and <code>right_distrib</code>. But those are already part of <code>ring G</code>...<br>\nDid you mean something else?</p>",
        "id": 200033570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591550724
    },
    {
        "content": "<p>Also, you are not asking for any compatibility of the field structure on <code>K</code> and the ring structure on <code>G</code>. Should the <code>has_lift</code> respect multiplication and addition?</p>",
        "id": 200033626,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591550765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200033570\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> You are requiring <code>[ring G]</code> and afterwards you have axioms <code>assoc</code>, <code>left_distrib</code>, and <code>right_distrib</code>. But those are already part of <code>ring G</code>...<br>\nDid you mean something else?</p>\n</blockquote>\n<p>I think that I might have done something redundant here, but what I was thinking is that G is a ring but geometric_algebra G K V isn't so I added these trivial properties and name them under geometric_algebra. This seems to be exactly why it can't be inferred.</p>\n<p>Ignore Q3 then.</p>",
        "id": 200033816,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591551029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200033626\">said</a>:</p>\n<blockquote>\n<p>Also, you are not asking for any compatibility of the field structure on <code>K</code> and the ring structure on <code>G</code>. Should the <code>has_lift</code> respect multiplication and addition?</p>\n</blockquote>\n<p>Yes, you're right, it should, I can add <code>[algebra K G]</code> back, and everything still works.</p>\n<p>I removed it for K since I can't do the same for V. <code>[algebra V G]</code> requires <code>V</code> to be <code>[comm_semiring V]</code> but <code>*</code> (geometric product) does not commute for vectors and it's not even a group since the multiplication is not closed, a vector times a vector becomes a bivector, it's in G, but not in V. But actually for K, <code>[algebra V G]</code> is fine and so is the <code>*</code> for K.</p>",
        "id": 200034006,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591551301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200027688\">said</a>:</p>\n<blockquote>\n<p>If you're talking about defining structures and classes, then <code>[]</code> after <code>:=</code> means that you tell it the instance at the same time as you're making the structure. Before the <code>:=</code> Lean will try to make the instance before you have even started making the structure</p>\n</blockquote>\n<p>Either I don't understand this or Kevin is wrong here.</p>",
        "id": 200034421,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1591551854
    },
    {
        "content": "<p>I can quite believe I'm wrong. I think Utensil Song knows exactly what they are talking about at this point though.</p>",
        "id": 200034608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591552181
    },
    {
        "content": "<p>~To answer Q1, it seems that I should take a closer look at~</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">-An R-algebra A is integrally closed if every element of A that is integral over R is contained in</span>\n<span class=\"cm\">the image of the canonical map R → A. This algebra_map is required to be injective.-/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">is_integrally_closed</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inj</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">closed</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_integral</span> <span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>~from the Huber_pair PR.~</p>\n<p>EDIT: doesn't help. The injection of the lift seems to be covered in <code>[algebra K G]</code> , the uniqueness of k is another question.</p>",
        "id": 200034950,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591552679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200034608\">said</a>:</p>\n<blockquote>\n<p>I can quite believe I'm wrong. I think Utensil Song knows exactly what they are talking about at this point though.</p>\n</blockquote>\n<p>From the tests in <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200028361\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200028361</a> , I do know that they're very different, but still, the applicability of each choice is still an unsolved puzzle.</p>",
        "id": 200035091,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591552851
    },
    {
        "content": "<p>Lean is just letting you write what you mean.</p>",
        "id": 200035102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591552885
    },
    {
        "content": "<p>Indeed.</p>",
        "id": 200035407,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591553384
    },
    {
        "content": "<p>However sometimes there is more than one way to write what you mean...</p>",
        "id": 200036387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591554850
    },
    {
        "content": "<p>After updating Lean to 3.16.0 and mathlib to  <code>mathlib = {git = \"https://github.com/leanprover-community/mathlib\", rev = \"593f731dd200fe74c218ff9886eb663d4a860dcd\"}</code> using <code>leanproject up</code>, Lean dies frequently for the following <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> :</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"c1\">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"c1\">-- TODO: find better ways to map G₀ and G₁ to G</span>\n<span class=\"o\">[</span><span class=\"n\">has_coe</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_coe</span> <span class=\"n\">G₁</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">G₀</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"c1\">-- Axiom 4: The square of every vector is a scalar.</span>\n<span class=\"o\">(</span><span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"c1\">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"c1\">-- TODO: find better ways to map G₀ and G₁ to G</span>\n<span class=\"o\">[</span><span class=\"n\">has_coe</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_coe</span> <span class=\"n\">G₁</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">G₀</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">GA</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span>\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>",
        "id": 200636600,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591940545
    },
    {
        "content": "<p>After every restart of Lean, and opening only this <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> in the editor, the orange bar shows up and does not disappear and then<br>\n<a href=\"/user_uploads/3121/2gmr5a6mM8-C0xylIGr3VTTx/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/2gmr5a6mM8-C0xylIGr3VTTx/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/2gmr5a6mM8-C0xylIGr3VTTx/image.png\"></a></div>",
        "id": 200636656,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591940651
    },
    {
        "content": "<p>How can I get more trace log to debug this?</p>",
        "id": 200636672,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591940706
    },
    {
        "content": "<p>I don't have any issues running this, although I get an error on the last line because <code>[G₀ →+* G] [G₁ →+ G]</code> are not classes</p>",
        "id": 200636724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591940780
    },
    {
        "content": "<p>Usually, if you get something that kills lean straight away, it requires some C++ debugging</p>",
        "id": 200636743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591940830
    },
    {
        "content": "<p>because you don't have the opportunity to ask more info</p>",
        "id": 200636746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591940853
    },
    {
        "content": "<blockquote>\n<p>[G₀ →+* G] [G₁ →+ G] are not classes</p>\n</blockquote>\n<p>Oh I see, type class <code>algebra</code> extends them but it doesn't mean I can use them as type classes. But I can't extend them either since there would be duplicated <code>to_fun</code> etc.</p>",
        "id": 200636902,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941173
    },
    {
        "content": "<p>you don't need to extend them</p>",
        "id": 200636948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941258
    },
    {
        "content": "<blockquote>\n<p>I don't have any issues running this</p>\n</blockquote>\n<p>I don't always have issues running this, but when I comment out some type classes and add some back, somehow it triggers Lean to be killed and it stays that way even after restart</p>",
        "id": 200636949,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941262
    },
    {
        "content": "<p>just have a field</p>",
        "id": 200636950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941263
    },
    {
        "content": "<p>G1 is not a field by itself</p>",
        "id": 200636954,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941286
    },
    {
        "content": "<p>no, the function</p>",
        "id": 200636960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941306
    },
    {
        "content": "<p>the two functions should be fields of the structure</p>",
        "id": 200636962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941315
    },
    {
        "content": "<p>well probably not <code>[G₀ →+* G] </code> since that one duplicates the function embedded in the algebra</p>",
        "id": 200636972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941352
    },
    {
        "content": "<p>you should not ask for <code>has_coe</code> instances either</p>",
        "id": 200637015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941407
    },
    {
        "content": "<p>the intention was to comment out the <code>has_coe</code>, <code>algebra</code> lines</p>",
        "id": 200637022,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941427
    },
    {
        "content": "<blockquote>\n<p>Mario Carneiro: the two functions should be fields of the structure</p>\n</blockquote>\n<p>I'll try that</p>",
        "id": 200637031,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941459
    },
    {
        "content": "<p>I think you want something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 4: The square of every vector is a scalar.</span>\n<span class=\"o\">(</span><span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 200637137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941628
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"c1\">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"c1\">-- TODO: find better ways to map G₀ and G₁ to G</span>\n<span class=\"c1\">-- [has_coe G₀ G] [has_coe G₁ G]</span>\n<span class=\"c1\">-- [G₀ →+* G]</span>\n<span class=\"c1\">-- [algebra G₀ G]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">scalar_hom</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vec_hom</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 4: The square of every vector is a scalar.</span>\n<span class=\"o\">(</span><span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span> <span class=\"n\">vec_hom</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">vec_hom</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">scalar_hom</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Here's what I came up with</p>",
        "id": 200637160,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941686
    },
    {
        "content": "<p>you have a lot of duplicate data in the parameters</p>",
        "id": 200637172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941716
    },
    {
        "content": "<p>Oh, <code>algebra_map _ _ k</code> is the <code>scalar_hom</code> equivalent</p>",
        "id": 200637214,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941755
    },
    {
        "content": "<p>those <code>has_zero</code> and <code>has_one</code> instances are also duplicate</p>",
        "id": 200637225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941798
    },
    {
        "content": "<blockquote>\n<p>Mario Carneiro: you have a lot of duplicate data in the parameters</p>\n</blockquote>\n<p>Yes, I'm trying to see the effect of doing so. Was expecting to get warnings about them.</p>",
        "id": 200637227,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941808
    },
    {
        "content": "<p>no, you will just get stuck in proofs</p>",
        "id": 200637231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941821
    },
    {
        "content": "<p>I don't think lean knows what a warning is</p>",
        "id": 200637238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941839
    },
    {
        "content": "<p>If you have any duplicate data, you are constructing something like \"a field with two independent multiplications\" or similar. Any theorem using one operation will not be able to play well with definitions based on the other</p>",
        "id": 200637315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941923
    },
    {
        "content": "<blockquote>\n<p>Mario Carneiro: no, you will just get stuck in proofs</p>\n</blockquote>\n<p>Oh, I got stuck somewhere else. Using <code>has_coe</code> made me to prove <code>↑kab - ↑ka - ↑kb = ↑(kab - ka - kb)</code> which can't be proved unless I have a <code>-&gt;+</code>.</p>",
        "id": 200637368,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591941965
    },
    {
        "content": "<p>for example, with <code>[field G₀] [has_one G₀]</code> you will not be able to prove <code>1 * x = x</code></p>",
        "id": 200637371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591941994
    },
    {
        "content": "<p>because nothing says that <code>1</code> is a unit</p>",
        "id": 200637380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591942016
    },
    {
        "content": "<p>Oh, I thought it's eliminated in the solution to the diamond problem.</p>",
        "id": 200637396,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591942054
    },
    {
        "content": "<p>if they were fields it would be a different matter, but you are passing everything as parameters</p>",
        "id": 200637412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591942078
    },
    {
        "content": "<p>there is no way for lean to assert a relation on the inputs unless you provide such relation</p>",
        "id": 200637453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591942111
    },
    {
        "content": "<p>I notice that <code>Axiom 2</code> and <code>Axiom 3</code> make additional claims about closure. These need to be axioms inside the structure</p>",
        "id": 200637522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591942204
    },
    {
        "content": "<p>maybe they come for free given the homs</p>",
        "id": 200637541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591942247
    },
    {
        "content": "<blockquote>\n<p>Mario Carneiro: maybe they come for free given the homs</p>\n</blockquote>\n<p>I believe so</p>",
        "id": 200637647,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591942413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  I can't refer to f1 later  though:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 4: The square of every vector is a scalar.</span>\n<span class=\"o\">(</span><span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">GA</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">square</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sym_prod</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">infix</span> <span class=\"bp\">`*</span><span class=\"err\">₊</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">75</span> <span class=\"o\">:=</span> <span class=\"n\">sym_prod</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">²</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">square</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">f₁</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  Symmetrised product of two vectors must be a scalar</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_failed</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"n\">f₁</span> <span class=\"n\">a</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"n\">f₁</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n\n<span class=\"c1\">-- type mismatch at application</span>\n<span class=\"c1\">--   f₁ a</span>\n<span class=\"c1\">-- term</span>\n<span class=\"c1\">--   a</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   G₁ : Type u_3</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   Type ? : Type (?+1)</span>\n<span class=\"c1\">-- Additional information:</span>\n<span class=\"c1\">-- minimal.lean:43:2: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</span>\n<span class=\"c1\">--   type mismatch, term</span>\n<span class=\"c1\">--     f₁ ?m_2</span>\n<span class=\"c1\">--   has type</span>\n<span class=\"c1\">--     ?m_1 →+ ?m_2 : Type (max ? ?)</span>\n<span class=\"c1\">--   but is expected to have type</span>\n<span class=\"c1\">--     Type ? : Type (?+1)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_still_failed</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">G₀</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">G₀</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n<span class=\"c1\">-- failed to synthesize type class instance for</span>\n<span class=\"c1\">-- G₀ : Type u_2,</span>\n<span class=\"c1\">-- _inst_1 : field G₀,</span>\n<span class=\"c1\">-- _inst_2 : char_zero G₀,</span>\n<span class=\"c1\">-- G₁ : Type u_3,</span>\n<span class=\"c1\">-- _inst_3 : add_comm_group G₁,</span>\n<span class=\"c1\">-- _inst_4 : vector_space G₀ G₁,</span>\n<span class=\"c1\">-- a b : G₁,</span>\n<span class=\"c1\">-- k : G₀</span>\n<span class=\"c1\">-- ⊢ ring (Type ?)</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>\n\n\n<p>And Lean dies randomly again...</p>",
        "id": 200679346,
        "sender_full_name": "Utensil Song",
        "timestamp": 1591973274
    },
    {
        "content": "<p>I'm not able to reproduce this random dying thing. If you hover over the first error, namely <code>f₁</code>, you see that it has this type:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">geometric_algebra</span><span class=\"bp\">.</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_5</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">],</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span>\n</code></pre></div>\n\n\n<p>In particular <code>f₁ a</code> will not work because <code>a</code> is supposed to be <code>G₀</code>, the first <code>()</code> input to <code>f₁</code></p>",
        "id": 200703068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591984712
    },
    {
        "content": "<p>If you would like <code>G₀</code> to be inferred by unification, then change <code>(G₀ : Type*)</code> to <code>{G₀ : Type*}</code> when you're setting up your variables.</p>",
        "id": 200703305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591984808
    },
    {
        "content": "<p>Your second error is because when Lean sees <code>f₁ G₀ a</code> it has to now guess all of the <code>{}</code> variables for <code>f₁</code> by unification, and it doesn't know how to guess <code>G</code>, so it just uses a metavariable, and then it has to prove that this metavariable is a ring because of <code>[ring G]</code>, so it gets stuck.</p>",
        "id": 200703710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591985001
    },
    {
        "content": "<p>Next problem: <code>sym_prod</code> expects an explicit <code>G</code> (look at the type) so the <code>*₊</code> notation won't work. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">include</span> <span class=\"n\">GA</span> <span class=\"c1\">-- you named it, so it doesn&#39;t get included automatically</span>\n<span class=\"c1\">-- and Lean cannot solve the problem you have left it regarding implicit variables so I</span>\n<span class=\"c1\">-- told it the solution explicitly</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_typechecks</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"n\">sym_prod</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">f₁</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">G₁</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">f₁</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">G₁</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 200704362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591985278
    },
    {
        "content": "<p>The problem is that if you're just telling <code>f\\_1</code> that it's going to eat <code>a</code>, then it can figure out <code>G\\_1</code>, but it can't figure out <code>G</code> or <code>G\\_0</code> because even though we have <code>geometric_algebra G G₀ G₁</code> Lean thinks that maybe there could be some other instances <code>geometric_algebra H H₀ G₁</code> so it will refuse to guess G and G_0 from what you told it.</p>",
        "id": 200704577,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591985383
    },
    {
        "content": "<p>One easy fix is to let f_1 also eat G and G_0. This sort of thing happens with algebras in Lean -- if A is an R-algebra then Lean never quite knows if A is an algebra for any other ring too, so many definitions and lemmas about R-algebras ask for R explicitly.</p>",
        "id": 200704745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591985440
    },
    {
        "content": "<p>You probably want to make G implicit in <code>sym_prod</code> and to make G and G_0 explicit in f_1. Maybe this?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁&#39;</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"c1\">-- I added a prime because the binders are wrong</span>\n<span class=\"c1\">-- Axiom 4: The square of every vector is a scalar.</span>\n<span class=\"o\">(</span><span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span> <span class=\"n\">f₁&#39;</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">f₁&#39;</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">f₁&#39;</span> <span class=\"c1\">-- G is implicit</span>\n<span class=\"c1\">-- let&#39;s fix those binders</span>\n<span class=\"n\">def</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"c1\">-- explicit G</span>\n  <span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">geometric_algebra</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">f₁&#39;</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">G₁</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"c1\">-- make it implicit</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">geometric_algebra</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"c1\">-- removing the name</span>\n\n<span class=\"n\">def</span> <span class=\"n\">square</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- implicit G for sym_prod</span>\n<span class=\"n\">def</span> <span class=\"n\">sym_prod</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">infix</span> <span class=\"bp\">`*</span><span class=\"err\">₊</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">75</span> <span class=\"o\">:=</span> <span class=\"n\">sym_prod</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">²</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">square</span>\n\n<span class=\"c1\">-- now back to explicit G</span>\n<span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  Symmetrised product of two vectors must be a scalar</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_typechecks</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">G</span> <span class=\"n\">G₀</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>",
        "id": 200705995,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591986040
    },
    {
        "content": "<p>Thanks for your detailed explanations on how Lean works , here's the further <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to demonstrate what I need partially following your hints with many comments describing my motivation and goal here:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"c1\">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 4: The square of every vector is a scalar.</span>\n<span class=\"o\">(</span><span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variables</span>\n<span class=\"o\">{</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">geometric_algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">square</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sym_prod</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">infix</span> <span class=\"bp\">`*</span><span class=\"err\">₊</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">75</span> <span class=\"o\">:=</span> <span class=\"n\">sym_prod</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">²</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"n\">square</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">f₁</span>\n\n<span class=\"c1\">-- implicit G₀</span>\n<span class=\"n\">def</span> <span class=\"n\">f₁&#39;</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">f₁</span> <span class=\"n\">G₀</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">f₁&#39;</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">f₁&#39; :</span>\n<span class=\"cm\">  Π {G₀ : Type u_4} [_inst_1 : field G₀]</span>\n<span class=\"cm\">  {G₁ : Type u_5} [_inst_2 : add_comm_group G₁] [_inst_3 : vector_space G₀ G₁]</span>\n<span class=\"cm\">  {G : Type u_6} [_inst_4 : ring G] [_inst_5 : algebra G₀ G]</span>\n<span class=\"cm\">  [_inst_6 : geometric_algebra G₀ G₁ G],</span>\n<span class=\"cm\">  G₁ →+ G</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  Symmetrised product of two vectors must be a scalar</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_works_but_not_ideal</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"n\">f₁</span> <span class=\"n\">G₀</span> <span class=\"n\">a</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"n\">f₁</span> <span class=\"n\">G₀</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">OK, it seems Lean knows G₁ from a and b,</span>\n<span class=\"cm\">but requires explicit G₀ to know to which G f₁ belongs</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_works_inferred_as_much_as_possible</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"n\">f₁</span> <span class=\"n\">G₀</span> <span class=\"n\">a</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"n\">f₁</span> <span class=\"n\">G₀</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">The only thing can be inferred is the type of k from k</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_better_but_failed</span><span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"n\">f₁&#39;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"n\">f₁&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Here&#39;s why I &quot;think&quot; this should work:</span>\n<span class=\"cm\">- rhs fixed G₀ and G, a and b fixed G₁, Lean should know everything about f₁&#39;</span>\n<span class=\"cm\">- plus *₊ fixed G too</span>\n\n<span class=\"cm\">Note that now I&#39;ve made all parameters in f₁&#39; implicit</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_ideal_but_seems_impossble_in_lean</span><span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"n\">a</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Here&#39;s why I further &quot;think&quot; this should work:</span>\n<span class=\"cm\">- a and b fixed G₁</span>\n<span class=\"cm\">- *₊ fixed G</span>\n<span class=\"cm\">- G₀ can be inferred from [geometric_algebra G₀ G₁ G]</span>\n\n<span class=\"cm\">Here&#39;s why I want it:</span>\n\n<span class=\"cm\">It&#39;s closer to how it&#39;s stated in literature, without the hassle of homs</span>\n<span class=\"cm\">and I have to state more complicated theoerem that involves more +-*/exp</span>\n<span class=\"cm\">as in https://github.com/pygae/GAlgebra.jl/blob/master/test/runtests.jl#L321</span>\n\n<span class=\"cm\">Here&#39;s how I&#39;m so close to it:</span>\n\n<span class=\"cm\">If I relax →+ and demand [has_coe G₀ G], then I get to state it like:</span>\n\n<span class=\"cm\">lemma vec_sym_prod_scalar [geometric_algebra G K V] :</span>\n<span class=\"cm\">∀ (a b : V), ∃ k : K, a *₊ b = (k : G) := by sorry</span>\n\n<span class=\"cm\">as in https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/basic.lean#L98</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>",
        "id": 200747637,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592020460
    },
    {
        "content": "<p>The crucial thing here is \"even though we have geometric_algebra G G₀ G₁ Lean thinks that maybe there could be some other instances geometric_algebra H H₀ G₁ so it will refuse to guess G and G_0 from what you told it.\"</p>",
        "id": 200748255,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592021693
    },
    {
        "content": "<p>Is there a way to force so, just locally?</p>",
        "id": 200748267,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592021718
    },
    {
        "content": "<p>(sorry I change the order of  G₀ G₁ G to make it in an ascendant order like in algebra)</p>",
        "id": 200748324,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592021808
    },
    {
        "content": "<p>The @ character can be used to tell lean you want to explicitly fill some implicit types in</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">vec_sym_prod_scalar_better_but_failed</span><span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">f₁&#39;</span> <span class=\"n\">G₀</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">*</span><span class=\"err\">₊</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">f₁&#39;</span> <span class=\"n\">G₀</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>I think your logic that the right hand side of this fixes <code>G₀</code>  doesn't really follow, the type of the RHS is <code>G</code> and just because you used a particular <code>G₀</code> doesn't mean the LHS has to use the same one.<br>\nP.s. the extra brackets I added aren't needed really.</p>",
        "id": 200749160,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592023614
    },
    {
        "content": "<p>It seems that to achieve what I want, I have to redesign the whole thing from ground up.</p>\n<p>Starting by giving G₁ a (not has_mul) multiplication that always return G but it's actually just G₀ or G₂, which in turn needs a grade projection operator first, and make G₁ not special and not in the parameters but generated from a projection. But in this case I'll have to use <code>G -&gt; set G</code> as the type of the grade projection, which I have been trying to avoid, because I want G₀  and G₁ to be a real type and not a type to Prop. And then from there I'll need to redefine <code>eq</code> as well, because eventually I'll need all 0 in G₀,  G₁,  G₂, ..., G etc. to equal and a G with only G₁ or G₂ components to equal to G₁ or G₂. I'll also need to state that G can be written as the infinite sum of G₀,  G₁,  G₂, ..., which might involve some cardinality stuff......</p>\n<p>(This formalism is used in GA to GC by Hestenes and Sobczyk, I thought I could try something simpler first, but the simpler formalism seems to be making it more difficult in Lean)</p>\n<p>(To make the discussion above easier to interpret, think G as another formalism to spell out Clifford Algebra (it seems to be not ready to be defined generally in mathlib yet as I've read on the Zulip, as well as Grassmann Algebra i.e. exterior algebra ).)</p>",
        "id": 200749166,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592023660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200749160\">said</a>:</p>\n<blockquote>\n<p>I think your logic that the right hand side of this fixes <code>G₀</code>  doesn't really follow, the type of the RHS is <code>G</code> and just because you used a particular <code>G₀</code> doesn't mean the LHS has to use the same one.</p>\n</blockquote>\n<p>Yes, I can see that now, but I'm wondering whether it's possible to specify so somehow.</p>",
        "id": 200749218,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592023743
    },
    {
        "content": "<p>I haven't used it myself, but perhaps using <code>parameters</code> instead of <code>variables</code> in this file does what you want</p>",
        "id": 200749331,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592024015
    },
    {
        "content": "<p>Oh silly me, I've confused them before and doing this again...Changing <code>variables</code> to <code>parameters</code> makes <code>vec_sym_prod_scalar_better_but_failed</code> work as expected! Thanks!</p>",
        "id": 200749675,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592024739
    },
    {
        "content": "<p>Is there anyway to simply use <code>cc</code>after <code>rw h1</code>, by making it somehow see through homs? It's painful to move terms around step by step...</p>\n<div class=\"codehilite\"><pre><span></span><code>      <span class=\"k\">begin</span>\n        <span class=\"n\">intros</span> <span class=\"n\">hb</span> <span class=\"n\">ha</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n        <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">          G₀ : Type u_1,</span>\n<span class=\"cm\">          _inst_1 : field G₀,</span>\n<span class=\"cm\">          G₁ : Type u_2,</span>\n<span class=\"cm\">          _inst_2 : add_comm_group G₁,</span>\n<span class=\"cm\">          _inst_3 : vector_space G₀ G₁,</span>\n<span class=\"cm\">          G : Type u_3,</span>\n<span class=\"cm\">          _inst_4 : ring G,</span>\n<span class=\"cm\">          _inst_5 : algebra G₀ G,</span>\n<span class=\"cm\">          _inst_6 : geometric_algebra G₀ G₁ G,</span>\n<span class=\"cm\">          a b : G₁,</span>\n<span class=\"cm\">          h1 : (a + b)²ᵥ = a²ᵥ + b²ᵥ + a*₊ᵥ b,</span>\n<span class=\"cm\">          vec_sq_scalar : ∀ (v : G₁), ∃ (k : G₀), v²ᵥ = ⇑fₛ k,</span>\n<span class=\"cm\">          kab ka kb : G₀,</span>\n<span class=\"cm\">          hb : b²ᵥ = ⇑fₛ kb,</span>\n<span class=\"cm\">          ha : a²ᵥ = ⇑fₛ ka,</span>\n<span class=\"cm\">          hab : (a + b)²ᵥ = ⇑fₛ kab</span>\n<span class=\"cm\">          ⊢ ∃ (k : G₀), a*₊ᵥ b = ⇑fₛ k</span>\n<span class=\"cm\">        -/</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">ka</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">kb</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">kab</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-ka - kb + kab)</span>\n        <span class=\"n\">rw</span> <span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb) + (⇑fₛ ka + ⇑fₛ kb + a*₊ᵥ b)</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb) + (⇑fₛ ka + ⇑fₛ kb) + a*₊ᵥ b</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb) + ⇑fₛ ka + ⇑fₛ kb + a*₊ᵥ b</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb + ka) + ⇑fₛ kb + a*₊ᵥ b</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-ka + -kb + ka + kb) + a*₊ᵥ b</span>\n        <span class=\"n\">rw</span> <span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">ka</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">kb</span><span class=\"o\">),</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-kb + -ka + ka + kb) + a*₊ᵥ b</span>\n        <span class=\"n\">rw</span> <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">kb</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">ka</span><span class=\"o\">)</span> <span class=\"n\">ka</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-kb + (-ka + ka) + kb) + a*₊ᵥ b</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span><span class=\"o\">,</span> <span class=\"n\">add_left_neg</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">],</span>\n      <span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>(Full working code is too long to paste in here, it's at <a href=\"https://github.com/pygae/lean-ga/blob/1d589406ffbed0e00bafff18bf1466689ea8b4b8/src/geometric_algebra/nursery/chisolm.lean#L97\">https://github.com/pygae/lean-ga/blob/1d589406ffbed0e00bafff18bf1466689ea8b4b8/src/geometric_algebra/nursery/chisolm.lean#L97</a> )</p>",
        "id": 200774586,
        "sender_full_name": "Utensil Song",
        "timestamp": 1592066585
    },
    {
        "content": "<p>After <code>use (-ka) + (-kb) + kab,</code> you can do <code>simp [fₛ.map_add, h1]</code>, which immediately reduces your goal to</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"err\">⊢</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"err\">₊ᵥ</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"err\">⇑</span><span class=\"n\">fₛ</span> <span class=\"n\">ka</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span><span class=\"err\">⇑</span><span class=\"n\">fₛ</span> <span class=\"n\">kb</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"err\">⇑</span><span class=\"n\">fₛ</span> <span class=\"n\">ka</span> <span class=\"bp\">+</span> <span class=\"err\">⇑</span><span class=\"n\">fₛ</span> <span class=\"n\">kb</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"err\">₊ᵥ</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>and then the <code>abel</code> tactic finishes the job.</p>\n<div class=\"codehilite\"><pre><span></span><code>        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">ka</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">kb</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">kab</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- a*₊ᵥ b = ⇑fₛ (-ka - kb + kab)</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fₛ</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">],</span>\n        <span class=\"n\">abel</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 200777359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592070690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/200749331\">said</a>:</p>\n<blockquote>\n<p>I haven't used it myself, but perhaps using <code>parameters</code> instead of <code>variables</code> in this file does what you want</p>\n</blockquote>\n<p>But <code>parameters</code> is being removed in lean 4, right? So what should we do here instead?</p>",
        "id": 202333834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593447786
    },
    {
        "content": "<p>Well if the problem you're trying to solve is, \"I have a bunch of variables, and every def/lemma/theorem in the theory I'm writing takes all of them as input and I don't want to write them all the time (i.e. some ambient space / ring you are working in with some properties)\" then I think the solution is to bundle everything you need into a structure that holds all these assumptions and use a single variable of type that structure and use that as input to every lemma etc.</p>",
        "id": 202335163,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593448279
    },
    {
        "content": "<p>Or just don't worry about what Lean 4 may or may not do.</p>",
        "id": 202335221,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593448306
    },
    {
        "content": "<p>Well in this case I run into the same problem using <code>variables</code> as I do trying to move my parameters to separate files</p>",
        "id": 202335718,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593448515
    },
    {
        "content": "<p>Can you give an example of what you mean?</p>",
        "id": 202335885,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593448589
    },
    {
        "content": "<p>I'm trying to</p>",
        "id": 202335900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593448595
    },
    {
        "content": "<p>Here's a fairly minimal example:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> doesn&#39;t work if `variables` instead -/</span>\n<span class=\"kn\">parameters</span>\n<span class=\"o\">{</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">geometric_algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">f₁</span> <span class=\"n\">G₀</span>\n<span class=\"n\">def</span> <span class=\"n\">prod_vec</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>\n\n\n<p>As is, this has no errors.</p>\n<p>If I change <code>parameters</code> to <code>variables</code>, then <code>prod_vec</code> doesn't \"know how to synthesize placeholder\" at <code>fᵥ</code>.</p>",
        "id": 202336406,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593448831
    },
    {
        "content": "<p>But I if leave it with <code>parameters</code>, then I have the same problem attempting to use <code>fᵥ</code> from another file.</p>",
        "id": 202336520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593448897
    },
    {
        "content": "<p>The problem from the beginning is that I put too many things in parameters, which should probably be bundled into the class.</p>",
        "id": 202336762,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449002
    },
    {
        "content": "<p>But still, I'm very confused about the subtle differences between parameters and variables and the idiomatic ways to use them.</p>",
        "id": 202337152,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449200
    },
    {
        "content": "<p>As demonstrated in the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> above</p>",
        "id": 202337216,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449233
    },
    {
        "content": "<p>idiomatic in the sense of mathlib is \"don't use parameters\"</p>",
        "id": 202337235,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593449247
    },
    {
        "content": "<p>But I'm not a mathlib dictator!</p>",
        "id": 202337264,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593449264
    },
    {
        "content": "<p>So feel free to use them. I've just never used them myself.</p>",
        "id": 202337291,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593449276
    },
    {
        "content": "<p>then how to use variables to achieve similar purpose?</p>",
        "id": 202337342,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449285
    },
    {
        "content": "<p>I'm seeing the argument against using <code>parameters</code> since I've been trying to split a section in two, but I can't work out an alternative spelling of the above without <code>parameters</code> that doesn't need a gazillion <code>_</code> placeholders</p>",
        "id": 202337374,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593449304
    },
    {
        "content": "<p>I wish to avoid relying on something not recommended by mathlib</p>",
        "id": 202337390,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449313
    },
    {
        "content": "<p>I think making <code>G</code> implicit in <code>fᵥ</code> is a bit strange. The issue is that when you write <code>fᵥ a</code> , Lean can't tell what <code>G</code> should be.</p>",
        "id": 202337573,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593449411
    },
    {
        "content": "<p>Changing to <code>def fᵥ (G : Type*) : G₁ →+ G := f₁ G₀</code> in the example above results in an error at <code>→+</code></p>",
        "id": 202337662,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593449480
    },
    {
        "content": "<p>The end goal is even to remove the need of fv...</p>",
        "id": 202337796,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449515
    },
    {
        "content": "<p>since they're not in the original math</p>",
        "id": 202337943,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449579
    },
    {
        "content": "<p>the arithmetic just works across \"types\"</p>",
        "id": 202338033,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449615
    },
    {
        "content": "<p>I'd still like to understand how to write the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> above, even if we don't end up needing it</p>",
        "id": 202338076,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593449641
    },
    {
        "content": "<p>yeah</p>",
        "id": 202338155,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593449653
    },
    {
        "content": "<p>Oh, I was wrong. The issue wasn't with <code>G</code> being implicit, but with <code>G₀</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variables</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"c1\">-- I made G₀ explicit here</span>\n<span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">geometric_algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">f₁</span> <span class=\"n\">G₀</span>\n<span class=\"n\">def</span> <span class=\"n\">prod_vec</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">G₀</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">G₀</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>",
        "id": 202340071,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593450521
    },
    {
        "content": "<p>As Alex says, I get the feeling this would be easier with more bundling though.</p>",
        "id": 202340225,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593450594
    },
    {
        "content": "<p>What do you mean by bundling in this case?</p>",
        "id": 202340284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593450604
    },
    {
        "content": "<p>Instead of:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Something more like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acg</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>(I haven't tested the latter.)</p>",
        "id": 202340454,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593450687
    },
    {
        "content": "<p>That was what I was about to ask</p>",
        "id": 202340475,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593450697
    },
    {
        "content": "<p>That means the <code>field</code> and <code>add_comm_group</code> fields have to be provided explicitly though, right?</p>",
        "id": 202340597,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593450732
    },
    {
        "content": "<p>They should only need to be provided once though when you create an instance of <code>geometric_algebra G</code>.</p>",
        "id": 202340644,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593450766
    },
    {
        "content": "<p>There's a little more about bundled vs unbundled stuff in 4.1.1 of the <a href=\"https://arxiv.org/abs/1910.09336\">mathlib paper</a>.</p>",
        "id": 202340701,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593450796
    },
    {
        "content": "<p><code>by apply_instance</code> will supply the e.g. field instance if you're making an instance of the bundled structure</p>",
        "id": 202340736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593450815
    },
    {
        "content": "<p>I suppose we can make a helper <code>def</code> to obtain them automatically anyway?</p>",
        "id": 202340759,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593450827
    },
    {
        "content": "<p><code>geometric_algebra.mk_from_instances</code> or something?</p>",
        "id": 202340810,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593450842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202340597\">said</a>:</p>\n<blockquote>\n<p>That means the <code>field</code> and <code>add_comm_group</code> fields have to be provided explicitly though, right?</p>\n</blockquote>\n<p>You can also use <code>[]</code> for fields in a class.</p>",
        "id": 202340900,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593450874
    },
    {
        "content": "<p>Right, so:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ag</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 202341132,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593450944
    },
    {
        "content": "<p>Something in between would be to make the three types into arguments, but put all the other stuff in fields.</p>",
        "id": 202341277,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593450999
    },
    {
        "content": "<p>Also, don't you need more functions, and injectivity assumptions?</p>",
        "id": 202341344,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593451030
    },
    {
        "content": "<p>This becomes slightly painful because we have as a field that I removed, <code>(vec_sq_scalar : ∀ v : G₁, ∃ k : G₀, f₁ v * f₁ v = algebra_map _ _ k )</code>, where <code>algebra_map</code> needs the <code>[]</code> arguments</p>",
        "id": 202341397,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202341344\">said</a>:</p>\n<blockquote>\n<p>Also, don't you need more functions, and injectivity assumptions?</p>\n</blockquote>\n<p>Yes, I stripped them to get a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of parameter woes</p>",
        "id": 202341426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451078
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">acg</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">G₀</span> <span class=\"o\">:=</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span>\n  <span class=\"n\">G₁</span> <span class=\"o\">:=</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span>\n  <span class=\"n\">f₁</span> <span class=\"o\">:=</span> <span class=\"n\">add_monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">ℂ</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>It should surely be a structure not a class if it's bundled this much. How many terms of type <code>geometric_algebra ℂ</code> might there be? Surely \"more than one\" is a reasonable answer. So structure not class.</p>",
        "id": 202341475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451083
    },
    {
        "content": "<p>I think \"exactly one\" is a perfectly reasonable answer</p>",
        "id": 202341614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451155
    },
    {
        "content": "<p><code>ℂ</code> is canonically <code>Cl(0, 1)</code>, I think -  a GA with a one-dimensional vector space, with the sole basis vector squaring to -1</p>",
        "id": 202341979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451347
    },
    {
        "content": "<p>Now maybe I misunderstand the question \"how many terms of the form ...\"</p>",
        "id": 202342027,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451380
    },
    {
        "content": "<p>I don't know what a geometric algebra is... so I can't really help there. (I know Clifford algebras, and I think they are examples.)</p>",
        "id": 202342203,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593451462
    },
    {
        "content": "<p>The reason <code>[group G]</code> is a class is that if <code>G</code> is a set/type/whatever you want to call it, then it is generally unlikely that you will want to put more than one group structure on <code>G</code> (i.e. two different multiplications).</p>",
        "id": 202342287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451508
    },
    {
        "content": "<p>I was under the impression they were synonymous, but I may be mistaken</p>",
        "id": 202342290,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451510
    },
    {
        "content": "<p>So under normal circumstances, if <code>G</code> is a type then there will be at most one term of type <code>group G</code></p>",
        "id": 202342326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202342290\">said</a>:</p>\n<blockquote>\n<p>I was under the impression they were synonymous, but I may be mistaken</p>\n</blockquote>\n<p>Maybe! Like I said, I don't know what a geom alg is</p>",
        "id": 202342372,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593451548
    },
    {
        "content": "<p>The type class inference system algorithm assumes that there will be at most one instance per class.</p>",
        "id": 202342388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451556
    },
    {
        "content": "<p>Wikipedia says \"Real Clifford algebras are also sometimes referred to as geometric algebras.\"</p>",
        "id": 202342450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451566
    },
    {
        "content": "<p>If you decided to make a vector space structure and wrote</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">vector_space</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">all</span> <span class=\"n\">the</span> <span class=\"kn\">structure</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"n\">vector</span> <span class=\"n\">space</span> <span class=\"n\">on</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>then this would be bad, because a term of type <code>vector_space k</code> would be a vector space over K, and because it's a class, each field is allowed to have at most one vector space over it.</p>",
        "id": 202342742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451672
    },
    {
        "content": "<p>I think I now see Kevin's point. ℂ can be thought of as either a 0-d clifford algebra over itself, or a 1d clifford algebra over the reals</p>",
        "id": 202342758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451680
    },
    {
        "content": "<p>So at least <code>G₀</code> needs to be an argument too</p>",
        "id": 202342893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451735
    },
    {
        "content": "<p>The question with</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ag</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>is nothing to do with what happens when G changes. It's precisely to do with what happens if the other stuff changes.</p>",
        "id": 202342923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451747
    },
    {
        "content": "<p>If you want more than one G_0 for a given G then you must make it a structure not a class.</p>",
        "id": 202343012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451771
    },
    {
        "content": "<p>Or a class taking two arguments?</p>",
        "id": 202343054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202342893\">said</a>:</p>\n<blockquote>\n<p>So at least <code>G₀</code> needs to be an argument too</p>\n</blockquote>\n<p>No. Not if you make it a structure</p>",
        "id": 202343060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451799
    },
    {
        "content": "<p>This is a design decision. You can make whatever you like an input or a structure field.</p>",
        "id": 202343142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451820
    },
    {
        "content": "<p>My only point was simply that <code>class</code> means that you expect at most one instance, and <code>structure</code> means you are allowed as many as you like.</p>",
        "id": 202343182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451846
    },
    {
        "content": "<p>but which mathematical object corresponds to \"instance\" depends on what you make as structure fields and what you make as inputs. The answer changes.</p>",
        "id": 202343278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593451892
    },
    {
        "content": "<p>All makes sense, thanks.</p>",
        "id": 202343328,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451920
    },
    {
        "content": "<p>I suppose the question now is whether I expect <code>G₀</code> to uniquely parameterize a geometric algebra <code>G</code>, or if there's a situation I haven't thought of where multiple choices of <code>G₁</code> are available</p>",
        "id": 202343476,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593451992
    },
    {
        "content": "<p>If you want help with that decision, please write down 3 examples for me.</p>",
        "id": 202343547,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452035
    },
    {
        "content": "<p>Yes, the definition is completely confusing</p>",
        "id": 202343639,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452066
    },
    {
        "content": "<p>(in its current state, where G_0 plays no role at all)</p>",
        "id": 202343651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452081
    },
    {
        "content": "<p>for a given G, there's only one G0</p>",
        "id": 202343652,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593452081
    },
    {
        "content": "<p>Not if we generalize to the clifford algebras I think...</p>",
        "id": 202343704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452112
    },
    {
        "content": "<p>it's still the same</p>",
        "id": 202343767,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593452149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202343639\">said</a>:</p>\n<blockquote>\n<p>Yes, the definition is completely confusing</p>\n</blockquote>\n<p>That's because the one I post above was the minimum definition that showed a language difficulty, not a mathematically meaningful statement!</p>",
        "id": 202343832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452170
    },
    {
        "content": "<p>Can you write down the definition in maths?</p>",
        "id": 202343886,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452209
    },
    {
        "content": "<p>Or link to one?</p>",
        "id": 202343890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452212
    },
    {
        "content": "<blockquote>\n<p>That's because the one I post above was the minimum definition that showed a language difficulty, not a mathematically meaningful statement!</p>\n</blockquote>\n<p>Yes, I know :-) That's why Johan just wants to see some examples. Then we'll get the hang of it.</p>",
        "id": 202343901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452217
    },
    {
        "content": "<p>I can give the paper that <span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> started our formalization from: <a href=\"https://arxiv.org/abs/1205.5935\">https://arxiv.org/abs/1205.5935</a></p>",
        "id": 202343979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452260
    },
    {
        "content": "<p>I would rather see three examples of G, G_0 and G_1</p>",
        "id": 202344001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452275
    },
    {
        "content": "<p>Ah, ok, got it</p>",
        "id": 202344053,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452286
    },
    {
        "content": "<p>The definition on wiki is vague and incomplete as far as I can tell</p>",
        "id": 202344164,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452346
    },
    {
        "content": "<p>Just some dumb examples</p>",
        "id": 202344213,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452378
    },
    {
        "content": "<p>Discussing offline with utensil to try and find some we agree on :)</p>",
        "id": 202344292,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452406
    },
    {
        "content": "<p>Hmm, from page 10 onwards in that link there is a pretty precise definition.</p>",
        "id": 202344408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452483
    },
    {
        "content": "<p>However, there is a tonne of structure there.</p>",
        "id": 202344421,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452492
    },
    {
        "content": "<p>There will be some nontrivial design decisions here</p>",
        "id": 202344458,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452513
    },
    {
        "content": "<p>My intuition is: add all the structure into the definition, and ask for lots of compatibilities.</p>",
        "id": 202344529,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452538
    },
    {
        "content": "<p>What do you mean by \"compatibilities\"?</p>",
        "id": 202344563,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452565
    },
    {
        "content": "<p>Then build custom constructors that take less data, and generate the remaining structure (because there will be apparent redundancy in the definition)</p>",
        "id": 202344572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452571
    },
    {
        "content": "<p>oh this is high-level structure making tips!</p>",
        "id": 202344609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452586
    },
    {
        "content": "<p>Example: the inner product follows from other pieces of data, but you might want to explicitly include it in the definition, and then say that the inner product that you include is the same as the one built from the other pieces.</p>",
        "id": 202344685,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452632
    },
    {
        "content": "<p>The reason you want this redundancy is that it will give you flexibility in definitional equalities later on.</p>",
        "id": 202344765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452663
    },
    {
        "content": "<p><a href=\"https://stackedit.io/viewer#!url=https://raw.githubusercontent.com/pygae/lean-ga/master/docs/misc/many_faces.md\">https://stackedit.io/viewer#!url=https://raw.githubusercontent.com/pygae/lean-ga/master/docs/misc/many_faces.md</a> is an incomplete work-in-progress math description of the definition problem here.</p>",
        "id": 202344797,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593452688
    },
    {
        "content": "<p>Like <code>&lt;</code> can be deduced from <code>&lt;=</code> in a partial order, but there's an axiom saying <code>a &lt; b ↔ a ≤ b ∧ ¬b ≤ a</code></p>",
        "id": 202344833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, is there an example of that approach I can look at in mathlib?</p>",
        "id": 202344963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452774
    },
    {
        "content": "<p>Yes, <code>metric_space</code> is a classical example</p>",
        "id": 202344991,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452788
    },
    {
        "content": "<p>It takes a topology, even though that's completely redundant. But...</p>",
        "id": 202345013,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452804
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric_space\">docs#metric_space</a></p>",
        "id": 202345029,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452816
    },
    {
        "content": "<p>It takes a uniform structure now, I think</p>",
        "id": 202345030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452816
    },
    {
        "content": "<p>The product topology on the product of two metric spaces is not <em>definitionally</em> the same as the metric topology on the product.</p>",
        "id": 202345072,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452843
    },
    {
        "content": "<p>It is a theorem that they are the same. And this theorem is now part of the definition</p>",
        "id": 202345086,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452858
    },
    {
        "content": "<p>But there is a constructor that will ignore the topology and just generate it from the metric.</p>",
        "id": 202345117,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452878
    },
    {
        "content": "<p>What is that constructor?</p>",
        "id": 202345166,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452886
    },
    {
        "content": "<p>This is rather advanced structure-making.</p>",
        "id": 202345174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452890
    },
    {
        "content": "<p>But for the product metric/topology, you don't want to use that constructor!</p>",
        "id": 202345190,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452899
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202345174\">said</a>:</p>\n<blockquote>\n<p>This is rather advanced structure-making.</p>\n</blockquote>\n<p>Yup, but the example at hand (geometric algebra) seems quite a complex thing.</p>",
        "id": 202345220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593452919
    },
    {
        "content": "<p>But I suspect that non-defeq diamonds are right now the least of their worries. We still don't even know if it's a structure or a class.</p>",
        "id": 202345266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452952
    },
    {
        "content": "<p>Looks like <a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance\">https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance</a> is related to this conversation?</p>",
        "id": 202345315,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593452980
    },
    {
        "content": "<p>But we can't even think about forgetful inheritence issues until we have decided what is an input and what is a structure field.</p>",
        "id": 202345448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453033
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/Kcz5lPFQH2CVU-H7cwEdFEHi/IMG_1517.PNG\">IMG_1517.PNG</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Kcz5lPFQH2CVU-H7cwEdFEHi/IMG_1517.PNG\" title=\"IMG_1517.PNG\"><img src=\"/user_uploads/3121/Kcz5lPFQH2CVU-H7cwEdFEHi/IMG_1517.PNG\"></a></div>",
        "id": 202345548,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <a href=\"https://github.com/leanprover-community/mathlib/blob/eb05a94/src/topology/metric_space/basic.lean#L71\">https://github.com/leanprover-community/mathlib/blob/eb05a94/src/topology/metric_space/basic.lean#L71</a><br>\nI was wrong, it's not a seperate constructor, but a default argument.</p>",
        "id": 202345620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453125
    },
    {
        "content": "<p>the current design is that it's a class</p>",
        "id": 202345668,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453166
    },
    {
        "content": "<p>So for R R^1 C which is G, G_0, G_1?</p>",
        "id": 202345671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453167
    },
    {
        "content": "<p>Order is specified as <code>G_0 G_1 G</code></p>",
        "id": 202345729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453200
    },
    {
        "content": "<p>so if R R^1 C and C C C are both Ok, you can't have a class and just make G an input</p>",
        "id": 202345758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453224
    },
    {
        "content": "<p>Correct, but we can have a class and make both G_0 and G an input</p>",
        "id": 202345846,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453253
    },
    {
        "content": "<p>The instended design is geometric_algebra R R^1 G(0, 1)</p>",
        "id": 202345871,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453274
    },
    {
        "content": "<p>not R R C</p>",
        "id": 202345898,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453293
    },
    {
        "content": "<p>What is G(0,1)?</p>",
        "id": 202345907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453300
    },
    {
        "content": "<p>The geometric algebra with 0 basis vectors with length 1 and 1 basis vector with length -1</p>",
        "id": 202345945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453323
    },
    {
        "content": "<p>Unfortunately that definition is circular</p>",
        "id": 202345969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453338
    },
    {
        "content": "<p>Is G determined by G_0 and G_1?</p>",
        "id": 202346000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453356
    },
    {
        "content": "<p>I think the answer is probably yes.</p>",
        "id": 202346078,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453383
    },
    {
        "content": "<p>Is there a reason you're asking for it at all?</p>",
        "id": 202346104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453395
    },
    {
        "content": "<p>I suggest also reading the story in §6.1 of <a href=\"https://arxiv.org/pdf/1910.12320.pdf\">https://arxiv.org/pdf/1910.12320.pdf</a></p>",
        "id": 202346145,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453417
    },
    {
        "content": "<p>Wait, G can be any implementation of that though right?</p>",
        "id": 202346186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453432
    },
    {
        "content": "<p>About how we approached valuations and especially the target type.</p>",
        "id": 202346203,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453438
    },
    {
        "content": "<p>We made a lot of design decisions which turned out to be bad</p>",
        "id": 202346241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> This <code>G(0,1)</code> looks fishy.</p>",
        "id": 202346269,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453470
    },
    {
        "content": "<p>but it was OK, because we learnt a lot</p>",
        "id": 202346274,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593453471
    },
    {
        "content": "<p>It's may work very well for the abstract theory, but it looks bad for application to examples.</p>",
        "id": 202346352,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453496
    },
    {
        "content": "<p>The answer is no actually</p>",
        "id": 202346381,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202346241\">said</a>:</p>\n<blockquote>\n<p>We made a lot of design decisions which turned out to be bad</p>\n</blockquote>\n<p>Another example was that we gave a mathematically correct definition of \"Huber pair\" (whatever that may be), but the canonical example that every mathematician will give first (p-adic integers, p-adic numbers) could not be made into an <code>instance</code> with our definition.</p>",
        "id": 202346485,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453565
    },
    {
        "content": "<p>We could prove lots of stuff though! But all abstract.</p>",
        "id": 202346518,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453579
    },
    {
        "content": "<p>it's also determined by the signature p q r and the specific way to implement a geometric algebra</p>",
        "id": 202346522,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453583
    },
    {
        "content": "<p>I will repeat, give me an example.</p>",
        "id": 202346603,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453606
    },
    {
        "content": "<p>The signature pqr is embedded in the <code>G_1</code> argument</p>",
        "id": 202346616,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453614
    },
    {
        "content": "<p>Is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}, \\mathbb{R}, \\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.88333em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> an example?</p>",
        "id": 202346642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453624
    },
    {
        "content": "<p>sorry I'm typing on my phone in bed...</p>",
        "id": 202346646,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453627
    },
    {
        "content": "<p>I think all(?) examples are given by G = the Clifford algebra of a vector space V over a field k equipped with a quadratic form, G_0 = k, G_1 = V.</p>",
        "id": 202346734,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593453671
    },
    {
        "content": "<p>If that helps.</p>",
        "id": 202346740,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593453675
    },
    {
        "content": "<p>And obviously up to isomorphism.</p>",
        "id": 202346768,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593453687
    },
    {
        "content": "<p>will type examples out tmr</p>",
        "id": 202346781,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202346768\">said</a>:</p>\n<blockquote>\n<p>And obviously up to isomorphism.</p>\n</blockquote>\n<p>That's exactly my point.</p>",
        "id": 202346790,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453697
    },
    {
        "content": "<p>You want a definition that also applies to objects isomorphic to that.</p>",
        "id": 202346819,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453715
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/QudJk_fs8uprDxGkMWt0U-Ex/IMG_1518.PNG\">IMG_1518.PNG</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/QudJk_fs8uprDxGkMWt0U-Ex/IMG_1518.PNG\" title=\"IMG_1518.PNG\"><img src=\"/user_uploads/3121/QudJk_fs8uprDxGkMWt0U-Ex/IMG_1518.PNG\"></a></div>",
        "id": 202346991,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593453783
    },
    {
        "content": "<p>some examples (<code>G₀ G₁ G</code>) that utensil may or may not agree with:</p>\n<p>Euclidean space: <code>ℝ ℝ³ some_implementation_of_g3_i_wish_to_register</code><br>\nspacetime: <code>ℝ ℝ³,¹ some_implementation_of_sta_i_wish_to_register</code><br>\nan embedding of the builtin complex numbers: <code>ℝ ℝ⁰,¹ ℂ</code><br>\na different embedding of the builtin complex numbers: <code>ℂ ℂ⁰ ℂ</code></p>",
        "id": 202347072,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453823
    },
    {
        "content": "<p>So your third type should <em>not</em> be some construction, but allow for arbitrary types.</p>",
        "id": 202347293,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593453951
    },
    {
        "content": "<p><code>G</code> you mean - yes, just like the <code>M</code> argument to <code>vector_space</code> currently behaves</p>",
        "id": 202347386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593453983
    },
    {
        "content": "<p>And maybe <code>G</code> already has some inner product (from a different part of mathlib), so you don't want to construct the inner product, but take it as an argument. (Even though you might want to give a default argument that constructs it from other data.)</p>",
        "id": 202347519,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454062
    },
    {
        "content": "<p>The (vector) inner product comes from <code>G₁</code></p>",
        "id": 202347583,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593454084
    },
    {
        "content": "<p>And maybe your <code>G</code> is already naturally graded into pieces <code>G_0</code>, <code>G_1</code>, ... <code>G_r</code> by another piece of mathlib, so you might want to take all the <code>G_r</code> as parameters as well</p>",
        "id": 202347616,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> your examples made it clear to me that we don't need G1 in the parameters</p>",
        "id": 202347630,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454111
    },
    {
        "content": "<p>Etc... (this is why I said there is so much data flying around in this definition.)</p>",
        "id": 202347650,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454131
    },
    {
        "content": "<p>That's funny <span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span>, because it made clear to me that we do if we want the algebra to know about it's own metric</p>",
        "id": 202347709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593454169
    },
    {
        "content": "<p>it's actually in G already</p>",
        "id": 202347814,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454215
    },
    {
        "content": "<p>the quadratic form and other stuff...</p>",
        "id": 202347863,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454248
    },
    {
        "content": "<p>we are talking about two different designs</p>",
        "id": 202348127,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> Again, I'll claim that's only true in maths, not in lean.</p>",
        "id": 202348130,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454380
    },
    {
        "content": "<p>Up to isomorphism, everything is fine.</p>",
        "id": 202348144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454392
    },
    {
        "content": "<p>We won't have C R^n Gsth, right? <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 202348725,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454657
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> Is <code>ℂ ℂ⁰ ℂ</code> an example of a geometric algebra? How about <code>ℝ ℝ⁰,¹ ℂ</code>?</p>",
        "id": 202348761,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454677
    },
    {
        "content": "<p>not in the design I'm referring to</p>",
        "id": 202348861,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454718
    },
    {
        "content": "<p>Then I can't use your theorems in some interesting concrete examples <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>",
        "id": 202348915,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454753
    },
    {
        "content": "<p>C will be proven to be isomorphic to the G something later</p>",
        "id": 202348925,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202348725\">said</a>:</p>\n<blockquote>\n<p>We won't have C R^n Gsth, right? <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span></p>\n</blockquote>\n<p>No, because there is no instance of  <code>vector_space C R^n</code></p>",
        "id": 202348943,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593454763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202348925\">said</a>:</p>\n<blockquote>\n<p>C will be proven to be isomorphic to the G something later</p>\n</blockquote>\n<p>Lean doesn't like such isomorphisms. They are a royal pita.</p>",
        "id": 202348974,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454782
    },
    {
        "content": "<p>If you create a more flexible definition, your proofs will probably also benefit.</p>",
        "id": 202349061,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593454807
    },
    {
        "content": "<p>That's why G1 should not be special and it's redundant in the parameter and it's just a bundled field</p>",
        "id": 202349117,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593454840
    },
    {
        "content": "<p>Please read §6.1 of the perfectoid paper (linked above). It's not that long.</p>",
        "id": 202349469,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455034
    },
    {
        "content": "<p>Note that this was not a problem that we hit during our project. We were done, and we tried to get some juicy examples. That's when we hit the problem.</p>",
        "id": 202349541,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455063
    },
    {
        "content": "<p>We could easily write 1000s of lines of interesting theorems... but they were useless, because we couldn't apply them to concrete examples.</p>",
        "id": 202349585,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455089
    },
    {
        "content": "<p>So, the case I'm thinking of is one where I want extra constraints on the vector space for a proof, perhaps that the square of a vector is always positive. I suppose that can be written whether G1 is an argument or not though, as <code>[ga G0 G1 G] (h : ∀ g : G1, p g)</code> or <code>[h : ga G0 G] (h : ∀ g : h.G1, p g)</code></p>",
        "id": 202349624,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593455102
    },
    {
        "content": "<p>consider the complex numbers as either:</p>\n<ul>\n<li>G(0, 1) over R</li>\n<li>G(0, 0) over C</li>\n</ul>",
        "id": 202349632,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593455106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span>  Lean disagrees. It only knows <code>complex</code>. That's it.</p>",
        "id": 202349689,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455133
    },
    {
        "content": "<p>I'm working on reading it <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, my math background is pretty weak :)</p>",
        "id": 202349700,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593455140
    },
    {
        "content": "<p>Lean is pretty stubborn. It will not change it's mind.</p>",
        "id": 202349715,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455145
    },
    {
        "content": "<p>we need both</p>",
        "id": 202349718,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593455146
    },
    {
        "content": "<p>I agree that you need both.</p>",
        "id": 202349732,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455156
    },
    {
        "content": "<p>so it seems isomorphism is the way to go</p>",
        "id": 202349791,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593455167
    },
    {
        "content": "<p>And since both are examples of <code>foobar : Type*</code>, you should include a <code>foobar : Type*</code> that abstracts over this.</p>",
        "id": 202349812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455182
    },
    {
        "content": "<p>No, abstracting into types with axioms about that type. That's the way to go.</p>",
        "id": 202349837,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455199
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 202349863,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593455217
    },
    {
        "content": "<p>A Huber pair is a pair <code>(R, A)</code> where <code>R</code> is a subring of <code>A</code>. Except that in mathlib <code>Z_p</code> is not a subring of <code>Q_p</code>. There is an injective ring homomorphism.</p>",
        "id": 202349945,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455253
    },
    {
        "content": "<p>So we changed the definition of Huber pair to: a pair <code>(R, A)</code> with an injective ring homomorphism <code>R →+* A</code>.</p>",
        "id": 202349994,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455280
    },
    {
        "content": "<p>Mathematically an isomorphic definition, but it makes a big difference in lean.</p>",
        "id": 202350065,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455293
    },
    {
        "content": "<p>And guess what! Some proofs became easier!</p>",
        "id": 202350099,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455308
    },
    {
        "content": "<p>abstracting into types with axioms about that type. That's the way to go.</p>\n<p>I see, this is it.</p>",
        "id": 202350149,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593455331
    },
    {
        "content": "<p>So to be clear, you replace the requirement \"is a subring of\" with a field providing that homomorphism?</p>",
        "id": 202350293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593455397
    },
    {
        "content": "<p>And my impression from what I've read so far about geometric algebras, is that there are lot's of things that can be abstracted into types and functions, and there will be many compatibility axioms.</p>",
        "id": 202350307,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455402
    },
    {
        "content": "<p>yes</p>",
        "id": 202350424,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593455426
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Yes, replace <code>(A : Type*) (R : subring A)</code> with <code>(A : Type*) (R : Type*) (f : R →+* A) (hf : injective f)</code>.</p>",
        "id": 202350479,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455455
    },
    {
        "content": "<p>And then presumably provide a constructor that populates <code>f</code> and <code>hf</code> for you if you can show <code>R : subring A</code>?</p>",
        "id": 202350565,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593455496
    },
    {
        "content": "<p>We didn't provide such a constructor, but you could do that.</p>",
        "id": 202350608,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455516
    },
    {
        "content": "<p>Did you find it would never have been useful?</p>",
        "id": 202350671,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593455534
    },
    {
        "content": "<p>It seems like you're obliged to provide that constructor to prove the statements are mathematically isomorphic ;)</p>",
        "id": 202350729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593455580
    },
    {
        "content": "<p>so now we all agree C cant directly stand at the position of G, but a structure abstracted over it, right?</p>",
        "id": 202350779,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593455616
    },
    {
        "content": "<p>I'm confused...</p>",
        "id": 202350883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455665
    },
    {
        "content": "<p>At me or utensil, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>?</p>",
        "id": 202350900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593455676
    },
    {
        "content": "<p>Utensil</p>",
        "id": 202350912,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455683
    },
    {
        "content": "<p>I would think that when you create examples, you do want to be able to plug <code>C</code> into some field at some point.</p>",
        "id": 202350966,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202350293\">said</a>:</p>\n<blockquote>\n<p>So to be clear, you replace the requirement \"is a subring of\" with a field providing that homomorphism?</p>\n</blockquote>\n<p>In type theory there is no such thing as a subring, really. There is some construction called a subring. But if A -&gt; B is an injective ring homomorphism then that does not make A a subring of B, and indeed it would be impossible in general to make A a subring of B. A and B are just different types. The whole \"sub\" thing is dangerous.</p>",
        "id": 202351000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593455744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202350671\">said</a>:</p>\n<blockquote>\n<p>Did you find it would never have been useful?</p>\n</blockquote>\n<p>We just directly plugged in <code>R</code>, <code>subtype.val</code> and <code>subtype.val_injective</code>. It's so short that it didn't merit a new constructor.</p>",
        "id": 202351023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593455756
    },
    {
        "content": "<p>This has been lots of useful discussion for me, thanks everyone</p>",
        "id": 202351564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593456025
    },
    {
        "content": "<p>sorry since its 2:39am in my timezone, I'll get some sleep first. I'm pretty sure I can come up with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to demonstrate what's in my mind after the discussion above, with defs and juicy concrete examples.</p>",
        "id": 202351788,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593456139
    },
    {
        "content": "<p>So clearly, if you start with <code>Q : V → K</code>, and you construct the Clifford algebra, then you want <code>Q</code>, <code>V</code> and <code>K</code> to be fields in the structure. Not isomorphic things.</p>",
        "id": 202351829,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593456168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202351788\">said</a>:</p>\n<blockquote>\n<p>sorry since its 2:39am in my timezone, I'll get some sleep first. I'm pretty sure I can come up with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to demonstrate what's in my mind after the discussion above, with defs and juicy concrete examples.</p>\n</blockquote>\n<p>Sleep well! <span aria-label=\"sleeping\" class=\"emoji emoji-1f634\" role=\"img\" title=\"sleeping\">:sleeping:</span></p>",
        "id": 202351846,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593456181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202351000\">said</a>:</p>\n<blockquote>\n<p>In type theory there is no such thing as a subring, really. There is some construction called a subring. But if A -&gt; B is an injective ring homomorphism then that does not make A a subring of B, and indeed it would be impossible in general to make A a subring of B. A and B are just different types. The whole \"sub\" thing is dangerous.</p>\n</blockquote>\n<p>Speaking for myself, this has been one of the harder things to wrap my head around in formalization. (I spent a bunch of time trying to figure out how to define and work with submatroids and I'm still stuck...) I hope that MiL has a lot of discussion about this.</p>",
        "id": 202351873,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593456202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202351829\">said</a>:</p>\n<blockquote>\n<p>So clearly, if you start with <code>Q : V → K</code>, and you construct the Clifford algebra, then you want <code>Q</code>, <code>V</code> and <code>K</code> to be fields in the structure. Not isomorphic things.</p>\n</blockquote>\n<p>Because in the end, you want to deduce facts about <code>Q</code>, <code>V</code> and <code>K</code>.</p>",
        "id": 202351880,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593456207
    },
    {
        "content": "<p>thanks!</p>",
        "id": 202351884,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593456209
    },
    {
        "content": "<p>I realized that I should first <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> the problem before writing a new <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . The following will refer to the definitions in <a href=\"https://stackedit.io/viewer#!url=https://raw.githubusercontent.com/pygae/lean-ga/master/docs/misc/many_faces.md\">The Many Faces of Geometric Algebra</a> by section titles with &lt;&gt; around them. I'll try to avoid mentioning any specific language structure in Lean such as structure/type class/instance, inheritance, parameters, bundled v.s. unbundled etc. because they're part of the y.</p>\n<p>The grand design is somewhat top-down.</p>\n<ol>\n<li>Define general Geometric Algebra (GA) with axioms about its properties/behaviors instead of representations, avoid mentioning grades/coordinates/metric, etc., keep it as readable and intuitive as possible;</li>\n<li>Define G(p, q, r) over a field which could be ℝ, ℂ or dual numbers 𝔻, hyperbolic numbers ℍ ( note that this is not quaternions ) but without specific metric, where (p, q, r) means <code>p</code> positive, <code>q</code> negative and <code>r</code> zero dimensions, e.g. Minkowski space is ℝ(1, 3, 0), dual number is G(0, 0, 1); Projective GA(PGA) and Conformal GA(CGA) are of specific interest at this abstraction layer with their own theorems and identities unrelated to specific metrics</li>\n<li>Define G(p, q, r) over a field a specific metric(or quadratic form)</li>\n<li>\n<p>All of<br>\n  a. Formalize data structures and the corresponding algorithms in sense of software libraries, such as using binary trees or prefix trees or whatever to implement GA<br>\n  b. formalize GA in other ways so that it's equivalent to the definition in 1 (with certain limited scope), the formalization might be &lt;Lawson 1989&gt;, &lt;Clifford algebra as a quotient of the tensor algebra&gt; or &lt;Clifford 1882&gt;<br>\n  c. ℝ, ℂ, dual numbers 𝔻, hyperbolic numbers ℍ, quaternions ℚ are all GAs</p>\n</li>\n<li>\n<p>Prove general theorems and identities for 1,  prove 2 \"is\" 1, prove dedicated theorems and identities for PGA and CGA, prove 3 \"is\" 2, prove 4b is 2 or 1, prove 4a and 4c are 3.</p>\n</li>\n</ol>\n<p>Last night, Eric was talking about at most the relationship between 3 and 4, and I was thinking about how to handle all the relationships between all of the above(and they might not be the same!). Maybe I've overcomplicated the problem at an initial stage. That's why I kept saying \"not exactly\" to Eric's examples.</p>\n<p>Now let's come back to the current attempt in <a href=\"https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean\">https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean</a> . It's trying to directly address 1 and it has at least the following mistakes:</p>\n<ol>\n<li>it should not directly try to address 1, instead, it should try something more concrete at the level of 2 or 3 and attack 1 based on what's learned during the process;</li>\n<li>it should not choose the axiom sets in &lt;Chisolm 2012&gt;, the axioms treated G₀ and G₁ specially and I believe this is its weakness; on the opposite, something like &lt;Buchholz 2005&gt;, &lt;Definition by generators and relations&gt;, &lt;Lynn&gt; might be better alternatives;</li>\n<li>it should not choose using [] parameters to specify most of the axioms, the axioms should be bundled fields</li>\n<li>it could reduce the numbers of types in parameters, the possibilities are 2(only G₀ and G), 1(only G) or 0;</li>\n<li>it should not stick to type class to implement the \"is\"s in 5, and might need to use the technique documented in <a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance\">https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance</a> for better definitionally equality; there might be other alternatives;</li>\n<li>it should handle the equality across types (i.e. Gr) better, such as the way to deal with the fact that the square of G₁ is G₀, homs are used here, but there're alternatives like coe, set, subtype etc.</li>\n<li>it should pick a way to prove that ℂ could \"be\" G(0, 1, 0) over ℝ or G(0, 0, 0) over ℂ, and find a way to allow plugging ℂ into proven theorems about abstract GA.</li>\n</ol>",
        "id": 202418534,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593513467
    },
    {
        "content": "<p>Some concrete examples of GA (but not of the <code>geometric_algebra G₀ G₁ G</code> here) are(note: it's not Lean): </p>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"c\"># Basic</span>\n    <span class=\"n\">ℝ</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>          <span class=\"c\"># Real numbers.</span>\n    <span class=\"n\">ℂ</span>  <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span>      <span class=\"c\"># Complex numbers.</span>\n    <span class=\"n\">ℚ</span>  <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)</span>      <span class=\"c\"># Quaternions.</span>\n    <span class=\"n\">ℍ</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>           <span class=\"c\"># Hyperbolic numbers.</span>\n    <span class=\"n\">𝔻</span>  <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span>   <span class=\"c\"># Dual numbers.</span>\n\n\n    <span class=\"c\"># Clifford</span>\n    <span class=\"n\">Cl2</span>       <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>     <span class=\"c\"># Clifford algebra for 2D vector space.</span>\n    <span class=\"n\">Cl3</span>       <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>     <span class=\"c\"># Clifford algebra for 3D vector space.</span>\n    <span class=\"n\">Spacetime</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)</span>   <span class=\"c\"># Clifford algebra for timespace vectors.</span>\n\n    <span class=\"c\"># Geometric</span>\n    <span class=\"n\">PGA2D</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span>     <span class=\"c\"># Projective Euclidean 2D plane. (dual)</span>\n    <span class=\"n\">PGA3D</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span>     <span class=\"c\"># Projective Euclidean 3D space. (dual)</span>\n    <span class=\"n\">CGA2D</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span>       <span class=\"c\"># Conformal 2D space.</span>\n    <span class=\"n\">CGA3D</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span>       <span class=\"c\"># Conformal 3D space.</span>\n</code></pre></div>",
        "id": 202421011,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593515399
    },
    {
        "content": "<p>One curious thing about this notion of geometric algebra (at least in the Chisolm version) which is clarified by some of the other presentations is that it is not really an algebraic structure  at all, in the sense of describing a kind of algebra. Rather, it's attempting to axiomatize the <em>free</em> algebra of some sort: namely (noncommutative) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>-algebras equipped with a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>-linear map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> compatible with the quadratic form on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> in a certain way.</p>",
        "id": 202430288,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593521701
    },
    {
        "content": "<p>So maybe it would be worthwhile to start by formalizing that kind of algebra.</p>",
        "id": 202430588,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593521851
    },
    {
        "content": "<p>I think equations which hold in all geometric algebras would also hold in all of these guys.</p>",
        "id": 202430627,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593521869
    },
    {
        "content": "<p>Mathematically, it's correct. GA is simply a free algebra with one particular constraint on the quadratic form. But such a statement is of no interest to the community applied GA in mathematical physics, quantum physics, electromagnetism, astrophysics, computer graphics, machine vision, engineering, robotics etc. All rich structures and interesting behaviors arise from that one constraint, and in turn, embeds many concepts in different math areas with different appearances.</p>",
        "id": 202442123,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593526984
    },
    {
        "content": "<blockquote>\n<p>it is not really an algebraic structure at all, in the sense of describing a kind of algebra.</p>\n</blockquote>\n<p>I don't follow what qualifies as an algebra here. </p>\n<blockquote>\n<p>Repeatedly and independently a long list of Clifford's geometric algebras, their subalgebras have been studied and applied historically, often under different names. Some of these algebras are complex numbers (and the complex number plane), hyperbolic numbers (split complex numbers, real tessarines), dual numbers, quaternions, biquaternions (complex quaternions), dual quaternions, Plucker coordinates, bicomplex numbers (commutative quaternions, tessarines, Segre quaternions), Pauli algebra (space algebra), Dirac algebra (space-time algebra, Minkowski algebra), algebra of physical space, para-vector algebra, spinor algebra, Lie algebras, Cartan algebra, versor algebra, rotor algebra, motor algebra, Clifford bracket algebra, conformal algebra, algebra of differential forms, etc.</p>\n</blockquote>",
        "id": 202445723,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593528489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202346145\">said</a>:</p>\n<blockquote>\n<p>I suggest also reading the story in §6.1 of <a href=\"https://arxiv.org/pdf/1910.12320.pdf\">https://arxiv.org/pdf/1910.12320.pdf</a></p>\n</blockquote>\n<p>I'm trying to sort out what's going on in that section. The storyline seems to be:</p>\n<blockquote>\n<p>The definition</p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mn>0</mn></msub><mo>:</mo><mo>=</mo><mi mathvariant=\"normal\">Γ</mi><mo>∪</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\Gamma_0 := \\Gamma \\cup {0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span></span> where the multiplication and order relation are extended by specifying that 0γ = 0 × 0 = 0 and 0 ≤ γ for every γ in Γ.<br>\nfocuses on the construction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, starting from an ordered group and adding an element, rather than the properties of the resulting object.</p>\n</blockquote>\n</blockquote>\n<p>The latter (directly addressing the properties of the resulting object instead of piecing some construction together and suddenly new behaviors emerge out of no(intuitively)where) is exactly what I'm after. If I have to extend some structure or bundle some field, I'll rather be adding some behaviors rather than gluing some constructions.</p>\n<blockquote>\n<p>We used Lean’s coercion mechanism to automatically insert the “inclusion” map from Γ to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. In set<br>\ntheory, this is indeed a true inclusion, but there are no inclusions between types in type theory as a term<br>\ncan only have one type. The <code>norm_cast</code> tactic, by Paul-Nicolas Madeleine [Mad19], greatly alleviates<br>\nthe pain of invoking lemmas about such coercions<br>\n Set-theoretically, it is almost true that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub><msub><mo stretchy=\"false\">)</mo><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}_{\\ge 0} = (\\mathbb{R}_{\\gt 0})_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.934069em;vertical-align:-0.24517899999999998em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">&gt;</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17737em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. This tiny lie only requires that we forget that the 0 in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub><msub><mo stretchy=\"false\">)</mo><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\"> (\\mathbb{R}_{\\gt 0})_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">&gt;</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17737em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is meant to be an extra element coming from nowhere in particular, hence has nothing to do with the neutral element of the additive group R. It gets harder to ignore with type-theoretic foundations. It means that merging the elementary theory with our abstract theory would require non-trivial glue.</p>\n</blockquote>\n<p>Generally I love type-theoretic foundations because it seems more strict and you can't blur things out unintentionally. But it's really problematic when you intentionally need to do something across types, it forces you to be verbosely formal and I'm yet to find the best practice to handle such situations. This story give hints about how to handle it, accompanied by old code presumably <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/commit/bf2d30b1925f22b45b32308251b908c87a2b40a9#diff-b5acb6e2a77a37f3c4deca33d0ae14d2\">here</a>.</p>\n<blockquote>\n<p>We defined the concept of totally ordered commutative monoid with zero as a type equipped with a composition law, a total order, and special elements 0 and 1 with enough properties to guarantee that all instances are isomorphic (as ordered commutative monoids) to some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Γ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. This corresponds to a type class which admits both with_zero Γ and {x : R // 0 ≤ x} as instances. Once again, focusing on properties instead of constructions gives us the needed extra flexibility at no cost.</p>\n</blockquote>\n<p>So here's the solution. Basically I understood the last sentence and worked my way backwards with the help of the corresponding code <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/pull/54/files\">here</a>, particularly <code>src/valuation/basic.lean</code>(see also <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/linear_ordered_comm_group_with_zero.lean#L28\">linear_ordered_comm_group_with_zero at master branch</a>). The core idea here seems to be we should model the properties in the definitions and prove some construction is an instance of it later and the benefit would be (I guess) better integration with elementary theory which involves more informal treatment?</p>",
        "id": 202528906,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593576232
    },
    {
        "content": "<blockquote>\n<p>The core idea here seems to be we should model the properties in the definitions and prove some construction is an instance of it later</p>\n</blockquote>\n<p>Yes, exactly.</p>\n<blockquote>\n<p>and the benefit would be (I guess) better integration with elementary theory which involves more informal treatment?</p>\n</blockquote>\n<p>The benefit would be that examples that are not by definition equal to you construction can still be turned into instances, whereas with the approach we took first this is simply impossible.</p>\n<ul>\n<li><code>nnreal</code> is not of the form <code>with_zero G</code>. It's only isomorphic to it.</li>\n<li><code>Z_p</code> is not a <code>set Q_p</code> and hence <code>is_subring Z_p</code> will never work. But it does have an injective ring homomorphism to <code>Q_p</code>.</li>\n</ul>",
        "id": 202533632,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593583082
    },
    {
        "content": "<p>As a mathematician you might say \"but what is the problem here? If X and Y are isomorphic then everything which is true for X is true for Y\". This is problematic for two reasons. Firstly, the principle is not true in general. For example if P(T) is <code>T=X</code> (which makes sense in type theory) then P(X) is true and P(Y) might not be (in Lean at least -- in a univalent theory this would be true but their = is not proof-irrelevant and this seems to bring other problems). </p>\n<p>And secondly, because all the <em>mathematical</em> facts about X, which of course do translate over to Y, actually have to be translated over. There is no \"rewrite along an isomorphism\" like there is a rewrite along an equality, and until such a tactic exists (and it will be hard to write because it's not always true, it's not true for P above for example) everything has to be transferred manually. Completely dumb proofs like if V and W are isomorphic algebras and V is 10 dimensional over some subalgebra isomorphic to the reals then so is W -- this is mathematically obvious but will not be a one-liner in Lean by any means</p>",
        "id": 202535279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593585335
    },
    {
        "content": "<p>I was trying to have a few examples under the current definition, and have difficulty proving <code>instance rrc_ga : geometric_algebra ℝ ℝ ℂ</code> at the <code>sorry /- here -/</code> in the following <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"n\">class</span> <span class=\"n\">geometric_algebra</span>\n<span class=\"c1\">-- Axiom 2: G contains a field G0 of characteristic zero which includes 0 and 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 3: G contains a subset G1 closed under addition,</span>\n<span class=\"c1\">-- and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Axiom 1: G is a ring with unit.</span>\n<span class=\"c1\">-- The additive identity is called 0 and the multiplicative identity is called 1.</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Axiom 4: The square of every vector is a scalar.</span>\n<span class=\"o\">(</span><span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">f₁</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">k</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">geometric_algebra</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">parameters</span>\n<span class=\"o\">{</span><span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">G₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">geometric_algebra</span> <span class=\"n\">G₀</span> <span class=\"n\">G₁</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">f₁</span> <span class=\"n\">G₀</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fₛ</span> <span class=\"o\">:</span> <span class=\"n\">G₀</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">G₀</span> <span class=\"n\">G</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"n\">rrc_ga</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">f₁</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">map_zero&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n      <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">norm_cast</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">coe_mk</span><span class=\"o\">,</span> <span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">],</span>\n    <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> here -/</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> For later discussion, the below doesn&#39;t matter for this question -/</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">field_ga</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">geometric_algebra</span> <span class=\"n\">K</span> <span class=\"n\">K</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">f₁</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n    <span class=\"n\">map_zero&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">forall_const</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">def</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">]</span>\n    <span class=\"kn\">end</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">vec_sq_scalar</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">map_eq_self</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">coe_mk</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">def</span><span class=\"o\">],</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">-- noncomputable instance rcc_ga : geometric_algebra ℝ ℂ ℂ := {</span>\n<span class=\"c1\">--   f₁ := {</span>\n<span class=\"c1\">--     to_fun := id,</span>\n<span class=\"c1\">--     map_zero&#39; := rfl,</span>\n<span class=\"c1\">--     map_add&#39; := by simp,</span>\n<span class=\"c1\">--   },</span>\n<span class=\"c1\">--   vec_sq_scalar := /- mathematically false due to the wrong mul equiped with ℂ -/</span>\n<span class=\"c1\">-- }</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">geometric_algebra</span>\n</code></pre></div>",
        "id": 202569843,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593610820
    },
    {
        "content": "<p>The goal state is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n<span class=\"err\">⊢</span> <span class=\"err\">↑</span><span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"err\">↑</span><span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"err\">⇑</span><span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"err\">⇑</span><span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"n\">v</span>\n</code></pre></div>",
        "id": 202569857,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593610835
    },
    {
        "content": "<p>The solution to your sorry is <code>refl</code></p>",
        "id": 202570448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593611168
    },
    {
        "content": "<p><code>unfold algebra_map</code> only gives</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n<span class=\"err\">⊢</span> <span class=\"err\">↑</span><span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"err\">↑</span><span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"err\">⇑</span><span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span> <span class=\"n\">v</span> <span class=\"bp\">*</span> <span class=\"err\">⇑</span><span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span> <span class=\"n\">v</span>\n</code></pre></div>\n\n\n<p>and I can't do any <code>rw</code> or <code>apply</code> with <code>algebra.to_ring_hom.xxx</code></p>",
        "id": 202570461,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593611175
    },
    {
        "content": "<p>I tried everything except <code>refl</code>!</p>",
        "id": 202570554,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593611244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202445723\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it is not really an algebraic structure at all, in the sense of describing a kind of algebra.</p>\n</blockquote>\n<p>I don't follow what qualifies as an algebra here. </p>\n</blockquote>\n<p>I mean in the sense of universal algebra. For example groups are the models of an algebraic theory in the sense that they are sets equipped with certain functions/constants which satisfy universally quantified equations (like \"for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span></span></span></span>, we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo>∗</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x * y) * z = x * (y * z)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span>\"). Free groups however are not the models of an algebraic theory.</p>",
        "id": 202570698,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593611320
    },
    {
        "content": "<p>It's really weird that <code>simp</code> can't cover this and <code>refl</code> can.</p>",
        "id": 202570714,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593611335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  After reading the group example in <a href=\"https://en.wikipedia.org/wiki/Universal_algebra\">https://en.wikipedia.org/wiki/Universal_algebra</a> , I'm pretty sure GA can be rephrased so that it's also a universal algebra.</p>",
        "id": 202572187,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593612164
    },
    {
        "content": "<p>There are many existing substitutions of \"Axiom 4: The square of every vector is a scalar\" in literature, I always wondered which's the best one.</p>",
        "id": 202572435,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593612310
    },
    {
        "content": "<p>For example, would the following qualify for universal algebra?</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">X</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">Q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathrm{X}, \\mathrm{Q})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">X</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Q</span></span><span class=\"mclose\">)</span></span></span></span> be an arbitrary finite dimensional real quadratic space and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{A}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">A</span></span></span></span></span> be a real associative algebra with identity. Furthermore, let<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>:</mo><mi mathvariant=\"double-struck\">R</mi><mo>→</mo><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha: \\mathbb{R} \\rightarrow \\mathcal{A}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">A</span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>:</mo><mi mathvariant=\"normal\">X</mi><mo>→</mo><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">v: \\mathrm{X} \\rightarrow \\mathcal{A}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">X</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">A</span></span></span></span></span> be linear injections such that<br>\n(i) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{A}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">A</span></span></span></span></span> is generated as an algebra by its distinct subspaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>∣</mo><mi>v</mi><mo>∈</mo><mi>X</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{v(v) \\mid v \\in X\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">}</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>α</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>∣</mo><mi>a</mi><mo>∈</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\alpha(a) \\mid a \\in \\mathbb{R}\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mclose\">}</span></span></span></span><br>\n(ii) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>v</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>=</mo><mi>α</mi><mo stretchy=\"false\">(</mo><mi>Q</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall v \\in X:(v(v))^{2}=\\alpha(Q(v))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{A}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">A</span></span></span></span></span> is said to be a Clifford algebra for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">X</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">Q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathrm{X}, \\mathrm{Q})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">X</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Q</span></span><span class=\"mclose\">)</span></span></span></span>. The elements of a Clifford algebra are<br>\ncalled multivectors. The product of a Clifford algebra is named geometric product. The signature of the quadratic space is also the signature of the algebra.</p>",
        "id": 202573076,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593612633
    },
    {
        "content": "<p>I guess not yet. It's still not only about n-ary operations and identities.</p>",
        "id": 202573820,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593613005
    },
    {
        "content": "<p>If you remove part (i), then I think so</p>",
        "id": 202574727,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593613464
    },
    {
        "content": "<p>I think (i) is not necessary but a natural result of the rest of the definition. Will have to verify that.</p>",
        "id": 202578591,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593615336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202570714\">said</a>:</p>\n<blockquote>\n<p>It's really weird that <code>simp</code> can't cover this and <code>refl</code> can.</p>\n</blockquote>\n<p>A proof of equality by <code>simp</code> is \"once we simplify both sides, using simp lemmas we created on purpose, they become syntactically equal\".</p>\n<p>A proof of equality by <code>refl</code> is \"these are definitionally equal, you can check by unfolding the definitions\"</p>",
        "id": 202594691,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1593622665
    },
    {
        "content": "<p>If <code>simp</code> can't solve something that you expect it to solve, there's implicitly a lemma that you think should be tagged with <code>@[simp]</code> but isn't.</p>",
        "id": 202595055,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1593622818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span>: So to be clear, if <code>simp</code> fails but <code>refl</code> succeeds, <code>refl</code> is unfolding definitions that <code>simp</code> is not?</p>",
        "id": 202596620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593623620
    },
    {
        "content": "<p><code>refl</code> will unfold everything. <code>simp</code> won't.</p>",
        "id": 202597150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593623957
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202597222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593623999
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">],</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Of course <code>refl</code> works.</p>",
        "id": 202597293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593624025
    },
    {
        "content": "<p><code>simp [foo]</code> looks a bit weird because <code>simp</code> likes to use lemmas of the form <code>A=B</code> or <code>A &lt;-&gt; B</code> -- it is a confluent rewriting system.</p>",
        "id": 202597365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593624071
    },
    {
        "content": "<p>Yes</p>",
        "id": 202597435,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1593624115
    },
    {
        "content": "<p>But</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">prefix</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">foo : Type</span>\n<span class=\"cm\">foo.equations._eqn_1 : foo = ℕ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n\n\n<p>and what's happening is that <code>simp</code> temporarily is adding <code>foo.equations._eqn_1</code> to the simp set</p>",
        "id": 202597441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593624117
    },
    {
        "content": "<p>This is how <code>unfold</code> works. <code>unfold X</code> is basically \"simp only [X.equations*]\" I think.</p>",
        "id": 202597547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593624160
    },
    {
        "content": "<p>This difference between <code>simp</code> and <code>refl</code> is quite instructive. At first everyone thinks of <code>refl</code> as a \"really simply\" tactic, that \"just checks if things are equal\". However it's actually potentially doing a huge amount of work, because it is willing to unfold definitions arbitrarily deeply.  This is what people are referring to when they say \"a heavy <code>refl</code>\".</p>",
        "id": 202633955,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593644739
    },
    {
        "content": "<p>On the other hand <code>simp</code> looks complicated because it potentially makes use of a whole zoo of lemmas, but on the other hand it works at a syntactic level (it will unfold <code>reducible</code>, and this can be tweaked) so is in some sense much more controllable.</p>",
        "id": 202634059,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593644814
    },
    {
        "content": "<p>I would say that is <code>refl</code> is succeeding and <code>simp</code> is failing, it's probably an indication you should try to add some <code>simp</code> lemmas.</p>",
        "id": 202634091,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593644851
    },
    {
        "content": "<p>Thanks for the very informative answers!</p>\n<p>By \"weird\", actually there's a whole bunch of questions:</p>\n<p>Q1. As <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> pointed out the potential possibility, is there some <code>simp</code> lemma missing for <code>algebra</code>, <code>ring_hom</code>? Should we and how can we do something about it?</p>\n<p>Q2. Are all the understandings below correct or some of them are misleading? Particularly c, d, f, i, j, l. And the questions n through r.</p>\n<p>a. Initially I enjoy the atomic <code>apply</code> and <code>rw</code> for <code>-&gt;</code> and <code>=</code>, respectively.<br>\nb. <code>simp</code> was merely a tool helping me find out the stuff in <code>simp only [stuff]</code>.<br>\nc. Using <code>simp only [stuff]</code> instead of <code>rw [stuff]</code> was merely saving me  the trouble from handling the order and the repetition of the rewrites.<br>\nd. Then I noticed that sometimes seemingly complex goal can be simplified significantly by <code>simp only []</code> which indicates there must be something other than just rewrites using <code>simp</code> lemmas in <code>simp</code> which I have no idea what's going on.<br>\ne. I try to avoid using <code>simp</code> in the middle of a proof and consider it a finishing tactic.<br>\nf.  but I find myself repeatedly having to using <code>simp only []</code> or <code>simp only [stuff]</code> to clean up some noise in the goal and proceed. I don't know if it's something wrong with my use of coe/homs/alias etc.<br>\ng. then I noticed the differences of syneq, defeq, propeq (and in this order the eq is from close to more far away)<br>\nh. and start using <code>unfold</code> for defeq instead of <code>rw</code> since the latter can only apply the defeq rewrite for one pattern repeatedly but <code>unfold</code> can do this for all patterns repeatedly. by pattern I mean, if I have a def of <code>f</code>, than <code>rw</code> works on both <code>f(a)</code> in <code>f(a) + f(b) + f(a)</code> but not <code>f(b)</code> but <code>unfold</code> works on <code>f(*)</code>.<br>\ni. then I noticed <code>dsimp</code>, which seems to be more powerful than <code>unfold</code> which should help me figure out the stuff in <code>unfold [stuff]</code><br>\nj. and it's more conservative than <code>simp</code> since it only uses defeq<br>\nk. but I haven't been able to use <code>dsimp</code> to solve any goal yet<br>\nl. and I'm reluctant to use <code>dsimp</code> because I don't know how to squeeze it or trace it<br>\nm. with the discussions above, it seems <code>refl</code> is much heavier than just check <code>defeq</code> at a shallow level and applying refl lemmas, and it's \"willing\" to check defeq at arbitrary depth<br>\nn. then why there's the need of manual unfold and dsimp? is the difference only that refl is a finishing tactic and it fails if it can't close the goal?<br>\no. why I can't close the goal with <code>dsimp</code>? <br>\np. do I have some non-finishing tactic to do what's similar to <code>refl</code> did but in the middle of a proof?<br>\nq. the most important question is, what defeq did <code>refl</code> check in this example?<br>\nr. can I mimic it with other tactics which explicitly mention the defeq it used?</p>",
        "id": 202644935,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593657382
    },
    {
        "content": "<p>Oof, too many questions to be able to answer...</p>",
        "id": 202645186,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593657820
    },
    {
        "content": "<blockquote>\n<p>o. why I can't close the goal with dsimp?</p>\n</blockquote>\n<p>because it doesn't have anything in it that could close a goal; it always replaces one goal with another. Anytime you think you might \"close a goal with <code>dsimp</code>\", you want to use <code>refl</code>.</p>",
        "id": 202645239,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593657881
    },
    {
        "content": "<p>re: m. and n. Yes! I never use <code>unfold</code>, only <code>dsimp</code>.</p>",
        "id": 202645265,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593657940
    },
    {
        "content": "<p>d. <code>simp only []</code> will do beta reduction, and I think also unfold projections(?)</p>",
        "id": 202645324,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593657987
    },
    {
        "content": "<p><code>dsimp</code> is allowed mid-proof (although often can be removed once the proof is working, unless the following tactic is relying on the syntactic form that <code>dsimp</code> produced)</p>",
        "id": 202645356,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593658054
    },
    {
        "content": "<p>(i.e. in anything of the form <code>dsimp, exact ...</code>, the <code>dsimp</code> is unnecessary. Often however a <code>dsimp</code> may be needed before <code>simp</code> or <code>rw</code>)</p>",
        "id": 202645402,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593658090
    },
    {
        "content": "<p>re \"n\" again: the need for <code>dsimp</code> is that it unfolds definitions, and many other tactics won't, so you need to do it by hand before calling them</p>",
        "id": 202645421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593658147
    },
    {
        "content": "<p>Regarding Q1: anytime you think <code>simp</code> should help, but it doesn't, you should try to write the <code>simp</code> lemma that you think should have fired!</p>",
        "id": 202645472,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593658205
    },
    {
        "content": "<p>This is a very important part of developing a new theory --- setting up the (hopefully confluent) rewriting rules that are always \"safe\" to use.</p>",
        "id": 202645483,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593658227
    },
    {
        "content": "<p>You want as much as possible to be handled by <code>simp</code>, because it makes everything easier for anyone who comes afterwards to your theory.</p>",
        "id": 202645493,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593658248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202645239\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>o. why I can't close the goal with dsimp?</p>\n</blockquote>\n<p>because it doesn't have anything in it that could close a goal; it always replaces one goal with another. Anytime you think you might \"close a goal with <code>dsimp</code>\", you want to use <code>refl</code>.</p>\n</blockquote>\n<p>Ah, I phrased it wrong. The actual question is, now that refl can close the goal, and it's about defeq, why can't dsimp which focuses on defeq achieve the same thing? What can I do to help it to achieve this, like supply defs in <code>dsimp [defs]</code>?</p>",
        "id": 202648757,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593663359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202645472\">said</a>:</p>\n<blockquote>\n<p>Regarding Q1: anytime you think <code>simp</code> should help, but it doesn't, you should try to write the <code>simp</code> lemma that you think should have fired!</p>\n</blockquote>\n<p>Yes, but the defs involved here are in <code>algebra</code> part of mathlib, I was wondering if anyone is aware of the situation that some <code>simp</code> lemma is missing.</p>",
        "id": 202648850,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593663515
    },
    {
        "content": "<p><code>dsimp</code> will only use lemmas marked with <code>@[simp]</code>. So yes, you need to explicitly make these lemmas.</p>",
        "id": 202649109,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593663941
    },
    {
        "content": "<p>And yes, @[simp] lemmas are missing all across mathlib! As you identify them, please make PRs adding <code>@[simp]</code> to them. :-)</p>",
        "id": 202649151,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593663973
    },
    {
        "content": "<p>It's nontrivial to decide exactly which lemmas should be simp lemmas, and so it doesn't always get done thoroughly.</p>",
        "id": 202649165,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593664024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202645493\">said</a>:</p>\n<blockquote>\n<p>You want as much as possible to be handled by <code>simp</code>, because it makes everything easier for anyone who comes afterwards to your theory.</p>\n</blockquote>\n<p>I totally agree to do so for the end-users and intend to do so in a later stage. And yet inside the library, I'm a little bit afraid of the lemmas proven <code>by simp</code>, which means I don't have any clue about the dependencies here, it feels circular to me somehow although I know this is unlikely the actual case.</p>\n<p>So, what's the best practice here? I might be a little pedantic or overcautious here and was thinking about:</p>\n<ol start=\"0\">\n<li>only use <code>simp only [xxx]</code> with the help of <code>squeeze_simp</code>;</li>\n<li><code>simp</code> involving only the simp lemmas in mathlib is allowed;</li>\n<li>use no <code>simp</code> inside the theory if it involves simp lemmas in the theory; -- to avoid the circular feeling</li>\n<li>to relax 2 a little bit, if I can break the theory into a few layers, then the top layers can invoke the layers under it;  -- but I don't know how to prevent <code>simp</code> using <code>simp</code> lemmas from the same layer, except check manually or by a linter examining the <code>[xxx]</code> in <code>simp only [xxx]</code>.</li>\n</ol>",
        "id": 202649172,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593664069
    },
    {
        "content": "<p>i don't understand what circularity you are trying to avoid</p>",
        "id": 202649482,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1593664479
    },
    {
        "content": "<p>I'm not sure either.</p>",
        "id": 202649597,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593664634
    },
    {
        "content": "<p>How could there be any circularity? <code>simp</code> will only use lemmas proved higher up the page</p>",
        "id": 202649691,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593664799
    },
    {
        "content": "<p>The circularity does not exist in Lean. It exists in one's mind because one has read the simp lemmas higher up the page and everywhere else...</p>",
        "id": 202651418,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593667557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> </p>\n<blockquote>\n<p>p. do I have some non-finishing tactic to do what's similar to refl did but in the middle of a proof?</p>\n</blockquote>\n<p>How about <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#change\">tactic#change</a> ? Is that what you're looking for?</p>",
        "id": 202653121,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593669902
    },
    {
        "content": "<p>I tried <code>change</code> but I fail to provide the new goal to <code>change</code>, copying from the goal and modifying it won't always work, what's printed in goal view is not always legal lean.</p>",
        "id": 202653280,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593670099
    },
    {
        "content": "<p>e.g. copying the goal state in <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202569857\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202569857</a></p>",
        "id": 202653303,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593670152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202653280\">said</a>:</p>\n<blockquote>\n<p>I tried <code>change</code> but I fail to provide the new goal to <code>change</code>, copying from the goal and modifying it won't always work, what's printed in goal view is not always legal lean.</p>\n</blockquote>\n<p>Yup, this is a known issue, and it's hard to solve. Lean 4 will have a delaborator, and then life should be much better.</p>",
        "id": 202653367,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670211
    },
    {
        "content": "<p>However, usually you can  fix this by adding some type annotations and removing some up-arrows.</p>",
        "id": 202653378,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670233
    },
    {
        "content": "<p>or <code>{re := v, im := 0} * {re := v, im := 0} = ⇑(algebra_map ℝ ℂ) (v * v)</code></p>",
        "id": 202653388,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593670247
    },
    {
        "content": "<p>What's printed in the goal is not always legal lean, but it is almost always almost legal lean.</p>",
        "id": 202653393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670254
    },
    {
        "content": "<p>You can try using <code>set_option pp.implicit true</code> or other <code>pp</code> options, sometimes that helps to get something you can use.</p>",
        "id": 202653462,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593670342
    },
    {
        "content": "<p>I find deleting the up arrows fixes 95% of pretty-printed output problems.</p>",
        "id": 202653832,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1593670842
    },
    {
        "content": "<p>That's basically <code>set_option pp.coercions false</code>?</p>",
        "id": 202654683,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593671885
    },
    {
        "content": "<p>What's the quickest way to convert the structure stuff in goal view into legal Lean? like in <a href=\"#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202653388\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/synthesized.20not.20defeq.20inferred/near/202653388</a></p>",
        "id": 202654704,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593671929
    },
    {
        "content": "<p>We got stuck on how to implement the bundled version for a while and here's how far we have got ( <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for unbundled, bundling V, and bundling both R&amp;V, demonstrated in 3 different namespaces). The most natural one seems to be bundling only V.</p>\n<p>It there any way to make the references to the maps less verbose?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">unbundled</span>\n\n<span class=\"n\">class</span> <span class=\"n\">mwc</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">R</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">extends</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">lemmas</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">R</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">r₀</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">v₀</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">[</span><span class=\"n\">mwc</span> <span class=\"n\">R</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"o\">((</span><span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">R</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">R</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"n\">V</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">lemmas</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">unbundled</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">V_bundled</span>\n\n<span class=\"n\">class</span> <span class=\"n\">mwc</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">extends</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">V_acg</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">V_vs</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">R</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">lemmas</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mwc</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">r₀</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">v₀</span> <span class=\"o\">:</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"n\">r</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">lemmas</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">V_bundled</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">VR_bundled</span>\n\n<span class=\"n\">class</span> <span class=\"n\">mwc</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">R_f</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">V_acg</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">V_vs</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">R</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">to_algebra</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→+</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">lemmas</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mwc</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">r₀</span> <span class=\"o\">:</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">v₀</span> <span class=\"o\">:</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵥ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mwc</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"n\">r</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">lemmas</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">VR_bundled</span>\n</code></pre></div>",
        "id": 204044670,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594874793
    },
    {
        "content": "<p>Just a random comment --- using abbreviations like <code>mwc</code> is unhelpful. Presumably this is intended to be some standard mathematical object, and perhaps if you'd written out <code>mwc</code> I'd have heard of it, and not have to reverse engineer by _actually reading the code_. :-)</p>",
        "id": 204046527,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594877142
    },
    {
        "content": "<p>Also -- given there's been a two week pause on this thread, and this doesn't seem to be about the original title anymore, perhaps moving this to a new thread would be easier.</p>",
        "id": 204046588,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594877191
    },
    {
        "content": "<p>(and get more attention)</p>",
        "id": 204046591,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594877196
    },
    {
        "content": "<p>Thanks, I'll start a new topic. As for the naming, because other mathematical properties are stripped away and only the technical issue (figuring out how bundling v.s. unbundling type classes works in Lean and how to refer to fields in them) is left, I don't have any meaningful name for it anymore...I'll add a description though.</p>",
        "id": 204048595,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594879595
    },
    {
        "content": "<p>Moved to <a href=\"#narrow/stream/113488-general/topic/unbundled.20v.2Es.2E.20%28semi-%29bundled/near/204049917\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unbundled.20v.2Es.2E.20%28semi-%29bundled/near/204049917</a></p>",
        "id": 204051839,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594883065
    }
]
[
    {
        "content": "<p>I have a very long Prop that consists mostly of AND/OR statements and false equalities like 1 = 2. Is there a faster way to simplify it than going through it with cases, split, left/right? Is there a built-in function that can scan through a long Prop and replace false equalities with ff, and another than can recognize that A AND ff is equivalent to ff, or that A OR ff is equivalent to A?</p>",
        "id": 187848002,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1581361905
    },
    {
        "content": "<p><code>norm_num</code> would probably solve that goal.</p>",
        "id": 187848098,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1581361947
    },
    {
        "content": "<p>And for context, if I'm not mistaken, <code>norm_num</code> means the tactic <code>norm_num</code> provided by <a href=\"https://github.com/leanprover-community/mathlib/\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/\">mathlib</a></p>",
        "id": 187849336,
        "sender_full_name": "Cerek Hillen (he) (W2'20)",
        "timestamp": 1581362692
    },
    {
        "content": "<p>I'm implementing matricies as types <code>fin m →  fin n →  nat </code> and want to sum all the elements in each row, and then sum all those values. Is there an easy way to do this using <code>finset.univ.sum</code>? I've been able to do it with 1D arrays of type <code>fin m →  nat</code> so I feel like there should be a clever lambda solution for the 2D case. I committed to this implementation before I realized mathlib has a matrix type, but it's implemented the same way, so it might not be worth the hassle of switching.</p>",
        "id": 188423065,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582000229
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">matrix_sum</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"err\">$</span> <span class=\"n\">M</span> <span class=\"n\">i</span>\n</pre></div>\n\n\n<p>Of course if you find yourself asking five more questions like this, and for some of them the answer is \"we did it already with matrices in mathlib\", then you might want to take that as an indication that you should switch. Remember -- if you define it yourself, you've got to prove all the lemmas about it yourself.</p>",
        "id": 188433115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582016252
    },
    {
        "content": "<p>PS I can't guarantee that I summed the elements in the rows rather than the columns -- this depends on your mental model.</p>",
        "id": 188433175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582016291
    },
    {
        "content": "<p>Thank you! That's a good point that maybe this is a sign that I should switch to the mathlib representation. My other motivation for not switching was that eventually I want to start putting noncommutative elements (specifically entangled quantum states) into the matrix, so it would matter whether I'm ordering it by rows or columns. If we have <code>(M : fin m → fin n → ℕ )</code>, I guess I could also just transpose it and do <code>matrix_sum </code> on the transpose. This way we get both cases, and all I need is to show whether they're equal or not.</p>",
        "id": 188462495,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582041267
    },
    {
        "content": "<p>Ok I tried doing this and got to this point. I feel like again there's probably an easy tactic to finish this off that I'm not seeing. Maybe switching to mathlib's matrix representation would make this easier, but part of me still wants to hold out on switching because I'm not going to be multiplying or adding  these matrices, just summing their elements in specific ways, and I want as much control over that as possible.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"err\">⊢</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">),</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">),</span> <span class=\"n\">board</span> <span class=\"n\">m</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 188465633,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582043180
    },
    {
        "content": "<p>This is \"reverse the order of summation\"?</p>",
        "id": 188465682,
        "sender_full_name": "Reid Barton",
        "timestamp": 1582043224
    },
    {
        "content": "<p>Right</p>",
        "id": 188465694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582043231
    },
    {
        "content": "<p>It definitely won't be a tactic, it probably is a theorem that already exists.</p>",
        "id": 188465745,
        "sender_full_name": "Reid Barton",
        "timestamp": 1582043270
    },
    {
        "content": "<p>I think it's whatever the to_additive of <code>prod_product</code> is</p>",
        "id": 188465819,
        "sender_full_name": "Reid Barton",
        "timestamp": 1582043298
    },
    {
        "content": "<p>well, combined with more stuff. How can this not exist already?</p>",
        "id": 188465972,
        "sender_full_name": "Reid Barton",
        "timestamp": 1582043385
    },
    {
        "content": "<p>aah, remember the old days before automation where you could just read off the additive name in the library...</p>",
        "id": 188465975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582043387
    },
    {
        "content": "<p>Oh yeah so we're in exactly the same situation as in the other thread.</p>",
        "id": 188466069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582043426
    },
    {
        "content": "<p>oh, <code>prod_comm</code></p>",
        "id": 188466072,
        "sender_full_name": "Reid Barton",
        "timestamp": 1582043427
    },
    {
        "content": "<p>this should probably have a comment with things like \"fubini\" and maybe \"prod_prod\"</p>",
        "id": 188466119,
        "sender_full_name": "Reid Barton",
        "timestamp": 1582043453
    },
    {
        "content": "<p><a href=\"#narrow/stream/113489-new-members/topic/spheres/near/188451346\" title=\"#narrow/stream/113489-new-members/topic/spheres/near/188451346\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/spheres/near/188451346</a> also ideally needs to switch from <code>finset.sum finset.univ (fin n)</code> to <code>finset.sum finset.range n</code></p>",
        "id": 188466164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582043486
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">sum_univ_fin_eq_sum_range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 188466293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582043544
    },
    {
        "content": "<p>I don't like the look of induction on n</p>",
        "id": 188466328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582043561
    },
    {
        "content": "<p>What I'm saying is that <code>fin n</code> doesn't have type <code>finset ℕ</code></p>",
        "id": 188467516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582044241
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">sum_univ_fin_eq_sum_range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">set</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"n\">hF</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hF</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">dite</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">dif_pos</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">is_lt</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_image</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr&#39;</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- ⊢ finset.image (λ (x : fin n), x.val) finset.univ = finset.range n</span>\n    <span class=\"n\">ext</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"c1\">-- sigh</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_range</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_image</span><span class=\"o\">],</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"n\">hj</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">intros</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">eq_of_veq</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 188471000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582046402
    },
    {
        "content": "<p>Amazing, thank you! I'm having trouble getting this into a form that I can use to finish my goal state though. I understand conceptually why it works, but the usual tactics like <code>rw</code>  <code>apply</code> etc don't seem to be working here (even though mathematically it seems like that's what I'm doing). I've had a similar issue come up as well when I got to the following tactic and goals states. I feel like I'm missing something potentially simple and obvious.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">strategyB</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">strategyA</span> <span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">strategyB</span> <span class=\"n\">c</span> <span class=\"n\">r</span>\n<span class=\"err\">⊢</span> <span class=\"n\">strategyB</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">),</span> <span class=\"n\">strategyA</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n</pre></div>",
        "id": 188477897,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582050813
    },
    {
        "content": "<p><code>ext</code></p>",
        "id": 188477990,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582050859
    },
    {
        "content": "<p>You need to check that two functions are equal iff they agree everywhere. In term mode this is <code>funext</code> and in tactic mode it's <code>ext i</code> (or perhaps <code>ext c r</code> in your case)</p>",
        "id": 188478041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582050897
    },
    {
        "content": "<p>\"Extensionality\" is the general principle that two objects are equal if and only if they're made from equal things. I think it's one of those things which computer scientists sometimes make a fuss about, it might be an axiom or something.</p>",
        "id": 188478099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582050942
    },
    {
        "content": "<p>It results from a lack of understanding of mathematical equality ;-)</p>",
        "id": 188478178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582050973
    },
    {
        "content": "<p>Fascinating. So lean doesn't automatically know that two objects made of equal parts are equal? I guess that makes sense but something feels a little absurd about that... Like I'm telling lean that instead of this equality holding for every element of a set, I'm telling it that it holds for a general element of a set, and it recognizes that as an equality but not the former?</p>\n<p>Either way, it worked for the more recent goal state I posted but it doesn't seem to be working for the \"reverse order of summation\" goal state. I'm getting the following error</p>\n<p><a href=\"/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png\" target=\"_blank\" title=\"Screen-Shot-2020-02-18-at-1.44.34-PM.png\">Screen-Shot-2020-02-18-at-1.44.34-PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png\" target=\"_blank\" title=\"Screen-Shot-2020-02-18-at-1.44.34-PM.png\"><img src=\"/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png\"></a></div>",
        "id": 188479304,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582051714
    },
    {
        "content": "<p>There are a lot errors like that in the docstrings; I'm not sure what the precise cause is but they shouldn't affect the validity of the actual Lean code.</p>",
        "id": 188479385,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1582051791
    },
    {
        "content": "<p>Rocky: saying that two functions are equal if they take the same value when evaluated on the same input is absurd from a computer science point of view. For instance it completely disregard execution time or memory consumption for functions that can be actually run.</p>",
        "id": 188479508,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1582051880
    },
    {
        "content": "<p>The error in the docstring is irrelevant, that's just some parser issue.</p>",
        "id": 188479517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582051890
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">strategyA</span> <span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">strategyB</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">strategyB</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">),</span> <span class=\"n\">strategyA</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Oh -- this is the one you can do? <code>ext</code> only works if the goal is of the form <code>f = g</code> where <code>f</code> and <code>g</code> are, say, functions or sets.</p>",
        "id": 188479656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582051987
    },
    {
        "content": "<p>Yeah I got that one working fine. It's this one that's been difficult for me. Here's my attempt so far that gives me the error message I linked to in my previous post.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">row_sum_eq_col_sum</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">row_sum</span> <span class=\"n\">board</span> <span class=\"bp\">=</span> <span class=\"n\">col_sum</span> <span class=\"n\">board</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">rw</span> <span class=\"n\">row_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">col_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">matrix_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">matrix_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">sampleB</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">sampleA</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"n\">ext</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Edit: sorry, forgot I haven't linked to how row_sum or col_sum are defined. Might be easier just to look at my final tactic state. <a href=\"user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png\" target=\"_blank\" title=\"user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png\">Screen-Shot-2020-02-18-at-2.03.20-PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png\" target=\"_blank\" title=\"Screen-Shot-2020-02-18-at-2.03.20-PM.png\"><img src=\"user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png\"></a></div>",
        "id": 188480326,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582052431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/(no.20topic)/near/188479508\" title=\"#narrow/stream/113489-new-members/topic/(no.20topic)/near/188479508\">said</a>:</p>\n<blockquote>\n<p>Rocky: saying that two functions are equal if they take the same value when evaluated on the same input is absurd from a computer science point of view. For instance it completely disregard execution time or memory consumption for functions that can be actually run.</p>\n</blockquote>\n<p>That's a good point - I hadn't though about functions different in memory use or runtime. I guess I still haven't developed a good intuition for how lean thinks about mathematical objects.</p>",
        "id": 188480420,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582052493
    },
    {
        "content": "<p>Lean supports both ways of thinking about function, without making a fuss. It simply records whether you used mathematics way or not.</p>",
        "id": 188481027,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1582052889
    },
    {
        "content": "<p>you need to rewrite <code>h</code> a lot and then use <code>finset.sum_comm</code></p>",
        "id": 188481275,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582053091
    },
    {
        "content": "<p>Your goal is the equality of two natural numbers so you can't use <code>ext</code> here.</p>",
        "id": 188481351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582053125
    },
    {
        "content": "<p>actually maybe just <code>finset.sum_comm</code> will work directly</p>",
        "id": 188481404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582053159
    },
    {
        "content": "<p>BTW it's bad style to put <code>simp</code> in the middle of a proof; it should only be used to close a goal. There are ways to work around uses of <code>simp</code> in the middle of a proof.</p>",
        "id": 188481740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582053380
    },
    {
        "content": "<p>I've been chewing on this for a few days and can't seem to figure out how to rewrite <code>h</code> in this case. Could I get a hint? :-)</p>",
        "id": 188879309,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582483646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260106\">@Rocky Kamen-Rubio</span> I scrolled up a bit in the thread but I didn't see any self-contained code that I could copy / paste to try out. Could you provide that in a post or a link to a github gist?</p>",
        "id": 188879808,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1582484504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>  Here's the full proof in its current state. The part I'm struggling with is towards the end. Let me know if you have any questions since it's a bit long.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">init</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">big_operators</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">class</span><span class=\"bp\">.</span><span class=\"n\">instance_max_depth</span> <span class=\"mi\">15000000</span>\n\n\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"mi\">2</span> <span class=\"c1\">--You can&#39;t put open_locale classical after an import statement for some reason so that&#39;s why this is here</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">def</span> <span class=\"n\">board</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">strategyA</span>\n\n<span class=\"n\">def</span> <span class=\"n\">consistent</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"n\">r</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sampleA</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">board</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sampleB</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">),</span> <span class=\"n\">board</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">sampleA</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">sampleB</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">board_equiv_strategy</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">consistent</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">sampleA</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sampleB</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">))))</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">sampleA</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">board</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">board</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">sampleB</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">consistent</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">each_row_sum_even</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">sampleA</span> <span class=\"n\">board</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">even</span>\n\n<span class=\"n\">def</span> <span class=\"n\">each_col_sum_odd</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">sampleB</span> <span class=\"n\">board</span> <span class=\"n\">c</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">even</span>\n\n<span class=\"n\">def</span> <span class=\"n\">even_strategy</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">even</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">odd_strategy</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"n\">c</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">even</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">even_strategy_implies_even_rows</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">consistent</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">even_strategy</span> <span class=\"n\">strategyA</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">each_row_sum_even</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">rw</span> <span class=\"n\">even_strategy</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">each_row_sum_even</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">sampleA</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">board</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">--In order to talk about a board we need to assume the two strategies are consistent. Or else we need to define the board differently to allowfor this</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">odd_strategy_implies_odd_cols</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">consistent</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">odd_strategy</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">each_col_sum_odd</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">board_equiv_strategy</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h3</span> <span class=\"k\">with</span> <span class=\"n\">h4</span> <span class=\"n\">h5</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">each_col_sum_odd</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">h5</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">odd_strategy</span> <span class=\"n\">at</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">matrix_sum</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"err\">$</span> <span class=\"n\">M</span> <span class=\"n\">i</span>\n\n<span class=\"n\">def</span> <span class=\"n\">row_sum</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">matrix_sum</span> <span class=\"o\">(</span><span class=\"n\">sampleA</span> <span class=\"n\">board</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">col_sum</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">matrix_sum</span> <span class=\"o\">(</span><span class=\"n\">sampleB</span> <span class=\"n\">board</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--sometimes I get an error here that this theorem is using sorry. Doesn&#39;t look like it is to me, so idk what&#39;s going on</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">sum_univ_fin_eq_sum_range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">set</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"n\">hF</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hF</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">dite</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">dif_pos</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">is_lt</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_image</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr&#39;</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- ⊢ finset.image (λ (x : fin n), x.val) finset.univ = finset.range n</span>\n    <span class=\"n\">ext</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"c1\">-- sigh</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_range</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_image</span><span class=\"o\">],</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"n\">hj</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">refl</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">intros</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">eq_of_veq</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">row_sum_eq_col_sum</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">row_sum</span> <span class=\"n\">board</span> <span class=\"bp\">=</span> <span class=\"n\">col_sum</span> <span class=\"n\">board</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">rw</span> <span class=\"n\">row_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">col_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">matrix_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">matrix_sum</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">sampleB</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">sampleA</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">sum_univ_fin_eq_sum_range</span><span class=\"o\">,</span>\n<span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"c1\">-- finset.sum_comm,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">noStrategyMN2</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">¬</span> <span class=\"o\">((</span><span class=\"n\">consistent</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>  <span class=\"o\">(</span><span class=\"n\">even_strategy</span> <span class=\"n\">strategyA</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">odd_strategy</span> <span class=\"n\">strategyB</span><span class=\"o\">))</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">y</span> <span class=\"k\">with</span> <span class=\"n\">even</span> <span class=\"n\">odd</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">cEven</span> <span class=\"o\">:=</span> <span class=\"n\">even</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">even_strategy_implies_even_rows</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">even</span><span class=\"o\">),</span>  <span class=\"c1\">--why is this not ok???????</span>\n<span class=\"k\">have</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">odd_strategy_implies_odd_cols</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">even</span><span class=\"o\">),</span>\n<span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 188880242,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582485079
    },
    {
        "content": "<p>Re: \"sometimes I get an error here that this theorem is using sorry.\" I think this might be some kind of a bug in <code>use</code>. If you replace <code>use ⟨j, hj⟩,</code> near the end by <code>existsi (⟨j, hj⟩ : fin n),</code> is it any better?</p>",
        "id": 188881049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582486377
    },
    {
        "content": "<p>The <code>rw h</code> fails (correctly), and to debug this you can try filling in some of the gaps. The more precise <code>rw h m (λ (i : fin m), finset.sum finset.univ (board i))</code> fails and here the error is much clearer -- <code>sum_univ_fin_eq_sum_range</code> (which IIRC I wrote) is about functions from <code>fin n</code> to the reals, and you have a function from <code>fin n</code> to the naturals. The correct thing to prove is for a map to an arbitrary additive commutative monoid or something -- something which includes both the naturals and the reals. You can replace the first few lines with</p>\n<div class=\"codehilite\"><pre><span></span>theorem sum_univ_fin_eq_sum_range {A : Type*} [add_comm_monoid A] (n : ℕ) (f : fin n → A) :\n  finset.sum finset.univ f = (finset.range n).sum (λ i, if hi : i &lt; n then f ⟨i, hi⟩ else 0) :=\nbegin\n  set F : ℕ → A := λ i, if hi : i &lt; n then f ⟨i, hi⟩ else 0 with hF,\n</pre></div>",
        "id": 188881338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582486732
    },
    {
        "content": "<p>but even after the rewrites there is work to do. At least this is a step forward.</p>",
        "id": 188881384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582486792
    },
    {
        "content": "<p>oh no no what am I talking about? You don't use h at all, I've misremembered the idea. You can just finish the proof with <code>sum_comm</code>:</p>\n<div class=\"codehilite\"><pre><span></span>rw matrix_sum,\nrw sampleB,\nrw sampleA,\nrw finset.sum_comm,\n</pre></div>",
        "id": 188881583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582487042
    },
    {
        "content": "<p>So that gets <code>row_sum_eq_col_sum</code> compiling and now there's just an error  at <code>c ∧ even</code> -- you ask why this is not OK, and this has an easy answer: <code>P ∧ Q</code> works for propositions, which means <em>true-false statements</em>. For example <code>x = 2 ∧ y &lt; 4</code> is fine. Now <code>x = 2</code> has type <code>Prop</code>. Your term <code>c</code> has type <code>consistent strategyA strategyB</code> (not <code>Prop</code> -- it's a <em>proof</em> not a <em>statement</em>) so <code>c ∧ ...</code> makes no sense.</p>",
        "id": 188881724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582487228
    },
    {
        "content": "<ol>\n<li>\n<p>Yes, replacing <code>use (j,hj)</code> with <code>existsi ((j,hj) : fin n),</code> resolved the issue, thank you!</p>\n</li>\n<li>\n<p>I had a feeling there was an easy way to do that in Lean.  I'm a little confused what the purpose of defining h was then? I remember <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  and <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> talking about how this proof wouldn't be possible with tactics, but maybe that was for a more general idea?</p>\n</li>\n<li>\n<p>I defined <code>consistent</code> <code>even</code> and <code>odd</code>as <code>Prop</code>s though, not as theorems. Do I still need to treat them differently?</p>\n</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">consistent</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"n\">r</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">even_strategy</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">even</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">odd_strategy</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"n\">c</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">even</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 188882833,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582489039
    },
    {
        "content": "<p>For your last question mark, maybe this helps:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">noStrategyMN2</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">¬</span> <span class=\"o\">((</span><span class=\"n\">consistent</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>  <span class=\"o\">(</span><span class=\"n\">even_strategy</span> <span class=\"n\">strategyA</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">odd_strategy</span> <span class=\"n\">strategyB</span><span class=\"o\">))</span>\n<span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">y</span> <span class=\"k\">with</span> <span class=\"n\">even</span> <span class=\"n\">odd</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">cEven</span> <span class=\"o\">:=</span> <span class=\"n\">even</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">even_strategy_implies_even_rows</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">even</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"c1\">-- to give something of type A ∧ B, you need hA : A and hB : B,</span>\n<span class=\"c1\">-- and you put them together in angle brackets like this: ⟨hA, hB⟩,</span>\n<span class=\"k\">have</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">odd_strategy_implies_odd_cols</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">odd</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 188884617,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1582492238
    },
    {
        "content": "<p>You defined <code>consistent</code> as a Prop, and <code>and</code> expects a Prop. So why did you give it a <em>proof</em> and not a Prop? You gave it a term of type P, not P itself.</p>",
        "id": 188885872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582494571
    },
    {
        "content": "<p>Wanting to put an <code>and</code> there was the problem, since <code>even_strategy_implies_even_rows</code> looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">even_strategy_implies_even_rows</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">strategyA</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">strategyB</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">consistent</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">even_strategy</span> <span class=\"n\">strategyA</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">each_row_sum_even</span> <span class=\"o\">(</span><span class=\"n\">board</span> <span class=\"n\">strategyA</span> <span class=\"n\">strategyB</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 188885975,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1582494743
    },
    {
        "content": "<p>PS your <code>import init</code> is bad -- remove it. Your <code>set_option class.instance_max_depth 15000000</code> is also bad -- remove it. I think the reasons were already explained above but you don't want either of these two lines.</p>",
        "id": 188886296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582495377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872\">said</a>:</p>\n<blockquote>\n<p>You defined <code>consistent</code> as a Prop, and <code>and</code> expects a Prop. So why did you give it a <em>proof</em> and not a Prop? You gave it a term of type P, not P itself.</p>\n</blockquote>\n<p>Ok, I think I'm getting this. It's working fine with the modification. Thank you!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296\">said</a>:</p>\n<blockquote>\n<p>PS your <code>import init</code> is bad -- remove it. Your <code>set_option class.instance_max_depth 15000000</code> is also bad -- remove it. I think the reasons were already explained above but you don't want either of these two lines.</p>\n</blockquote>\n<p>You're right. I had forgotten to take those out since they weren't actively stopping my code from compiling... Thanks for the reminder!</p>",
        "id": 188963082,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582576402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260106\">Rocky Kamen-Rubio</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495\">said</a>:</p>\n<blockquote>\n<p>Thank you! That's a good point that maybe this is a sign that I should switch to the mathlib representation. My other motivation for not switching was that eventually I want to start putting noncommutative elements (specifically entangled quantum states) into the matrix, so it would matter whether I'm ordering it by rows or columns. If we have <code>(M : fin m → fin n → ℕ )</code>, I guess I could also just transpose it and do <code>matrix_sum </code> on the transpose. This way we get both cases, and all I need is to show whether they're equal or not.</p>\n</blockquote>\n<p>I'm now wanting to repeat this procedure but with matrices in each column instead of integers, and taking the matrix product of all the matrices in each row. <code>finset.univ.prod</code> (understandably) doesn't use <code>matrix.mul</code> automatically when its input is a matrix. Is there a way to feed it an arbitrary function (à la MapReduce) , or should I be thinking about this differently? I could see a benefit to implementing this matrix data structure differently, maybe as a 2D linked list, to facilitate recursive matrix multiplication of its elements over a given row or column, but I feel like that shouldn't be necessary.</p>",
        "id": 188963797,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582576919
    },
    {
        "content": "<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>",
        "id": 188967088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582579161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088\">said</a>:</p>\n<blockquote>\n<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>\n</blockquote>\n<p><code>list.prod</code> works, thank you! That's a shame though because now I'm going to have to choose between keeping my matrix type or using this easier product method (unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an \"unknown identifier\". Is there an import statement or something I'm missing that tells Lean it's ok to use variables that haven't been fully defined yet?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">big_operators</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"n\">pequiv</span>\n\n<span class=\"n\">def</span> <span class=\"n\">row_product</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mat</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">ℤ</span> <span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">row_product_helper</span> <span class=\"n\">mat</span> <span class=\"n\">r</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">def</span> <span class=\"n\">row_product_helper</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mat</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">ℤ</span> <span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">mat</span> <span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"k\">else</span> <span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">mat</span> <span class=\"n\">r</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">row_product_helper</span> <span class=\"n\">mat</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 188993063,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582608796
    },
    {
        "content": "<blockquote>\n<p>(unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). </p>\n</blockquote>\n<p>I don't really know what you mean. Anything is possible. Just write the function.</p>\n<blockquote>\n<p>I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an \"unknown identifier\". Is there an import statement or something I'm missing</p>\n</blockquote>\n<p>I can't help you unless you post complete fully working code.</p>",
        "id": 189003202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582622838
    },
    {
        "content": "<p>You have to use the equation compiler if you want to write a recursive function like that, i.e.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">case1</span> <span class=\"o\">:=</span> <span class=\"n\">bla</span>\n<span class=\"bp\">|</span> <span class=\"n\">case2</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">bar</span>\n</pre></div>",
        "id": 189003309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1582622939
    },
    {
        "content": "<p>Is the issue simply that <code>row_product_helper</code> is defined after you use it in <code>row_product</code>? No import will help you there, you have to define things before you use them.</p>",
        "id": 189003449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582623091
    },
    {
        "content": "<p>PS I found <a href=\"http://learnyouahaskell.com/\" target=\"_blank\" title=\"http://learnyouahaskell.com/\">learn you a haskell</a> really helpful when I was trying to figure out what functional languages looked like in general.</p>",
        "id": 189012124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582631028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003202\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003202\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>(unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). </p>\n</blockquote>\n<p>I don't really know what you mean. Anything is possible. Just write the function.</p>\n</blockquote>\n<p>Looking at the documentation for <code>row</code> it looks like it returns a vector not a list. You're right though that I could just convert it to a list and then product. Maybe this is an indication that a more functional approach would be preferred/more in line with how Lean is built?</p>\n<blockquote>\n<blockquote>\n<p>I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an \"unknown identifier\". Is there an import statement or something I'm missing</p>\n</blockquote>\n<p>I can't help you unless you post complete fully working code.</p>\n</blockquote>\n<p>I posted the code I have below the text. Is it not visible to you? Do you mean that I need to include all my import statements as well?</p>",
        "id": 189057294,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582662219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003449\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003449\">said</a>:</p>\n<blockquote>\n<p>Is the issue simply that <code>row_product_helper</code> is defined after you use it in <code>row_product</code>? No import will help you there, you have to define things before you use them.</p>\n</blockquote>\n<p>Even reversing the order of the two definitions, the recursive call in <code>row_product_helper</code> gives me an error. I'll check out learn you a haskell and see if that gives me more clarity. Thank you!</p>",
        "id": 189057456,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582662324
    },
    {
        "content": "<p>I cut and pasted the code you posted and it didn't work. Yes, include everything which makes it work!</p>",
        "id": 189057510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582662360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003309\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003309\">said</a>:</p>\n<blockquote>\n<p>You have to use the equation compiler if you want to write a recursive function like that, i.e.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">case1</span> <span class=\"o\">:=</span> <span class=\"n\">bla</span>\n<span class=\"bp\">|</span> <span class=\"n\">case2</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">bar</span>\n</pre></div>\n\n\n</blockquote>\n<p>Interesting. I'll try rewriting my function like this and see if it helps. Thank you!</p>",
        "id": 189057549,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582662363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189057510\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189057510\">said</a>:</p>\n<blockquote>\n<p>I cut and pasted the code you posted and it didn't work. Yes, include everything which makes it work!</p>\n</blockquote>\n<p>I added the import statements. I'll be sure to include them in future posts.</p>",
        "id": 189057995,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582662641
    },
    {
        "content": "<p>Your code doesn't work because you use <code>row_product_helper</code> before you define it. And if you switch the order of <code>row_product_helper</code> and <code>row_product</code> it doesn't work because <code>mat r c</code> doesn't make sense because <code>r</code> has type <code>nat</code> and not type <code>fin m</code>.  But even if you fix that it won't work because you can't use <code>row_product_helper</code> in the definition of <code>row_product_helper</code>, that doesn't make sense in functional programming.</p>",
        "id": 189062310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582665477
    },
    {
        "content": "<p>I now understand Mario's reply (I'm much less good than some other people at \"guessing what the user meant\"). You can use the definition of X when defining X, as long as you only run X on strictly \"smaller\" things. Here's a less abstract example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">Fib</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fib</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">Fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>You might want to read about how the equation compiler works in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html\">Theorem Proving In Lean</a>, although depending on what you know you might have to read a bunch of earlier chapters first.</p>",
        "id": 189064024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1582666781
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189064024\" title=\"#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189064024\">said</a>:</p>\n<blockquote>\n<p>I now understand Mario's reply (I'm much less good than some other people at \"guessing what the user meant\"). You can use the definition of X when defining X, as long as you only run X on strictly \"smaller\" things. Here's a less abstract example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">Fib</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fib</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">Fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>You might want to read about how the equation compiler works in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html\" target=\"_blank\" title=\"https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html\">Theorem Proving In Lean</a>, although depending on what you know you might have to read a bunch of earlier chapters first.</p>\n</blockquote>\n<p>That makes sense. I'll take some time to go back and try to fully understand how the equation compiler works as well as matrices, lists, and vectors. Thanks!</p>",
        "id": 189155370,
        "sender_full_name": "Rocky Kamen-Rubio",
        "timestamp": 1582748876
    }
]
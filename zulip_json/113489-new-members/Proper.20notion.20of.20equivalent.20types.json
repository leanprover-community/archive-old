[
    {
        "content": "<p>I am trying to figure out what the proper notion of equivalence of types is w/r/t proving theorems. E.g. it seems like we should be able to say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>α</mi><mo>×</mo><mi>β</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>γ</mi></mrow><annotation encoding=\"application/x-tex\">(\\alpha \\times \\beta) \\to \\gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05556em;\">γ</span></span></span></span> is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha \\to \\beta \\to \\gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05556em;\">γ</span></span></span></span> and that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>×</mo><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha \\times \\beta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span> is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mo>×</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\beta \\times \\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span> (in some sense). Further, it seems we should be able to say mathematically equivalent but distinct definitions of structures should be equivalent in some sense, e.g. defining groups with an existence statement about an inverse (groups1) vs. defining group with an inverse operation (groups2).</p>\n<p>Ideally, we want a notion of equivalence which gives us the ability to exchange the types in appropriate circumstances, e.g. taking the example with groups, we should be able to say something like \"every theorem about groups1 is a theorem about groups2\", but of course this isn't precisely true. What is the right way to think about this problem in the context of formalization: how can we formally say \"your definition is the same as mine\"?</p>\n<p>It is worth noting I asked this question on Math Stack Exchange; <a href=\"https://math.stackexchange.com/questions/3676075/equivalence-or-isomorphism-of-types\">more context/examples are given there</a>.</p>",
        "id": 197680961,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1589544386
    },
    {
        "content": "<p>there is a notion of equivalence of types in lean which is simply the type of functions <code>A -&gt; B</code> with two-sided inverse -- you can find the definition and theorems in <code>data.equiv.basic</code>. so for example </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"err\">≃</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">prod_comm</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"err\">≃</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">arrow_arrow_equiv_prod_arrow</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n</code></pre></div>\n\n\n<p>we can also <code>import tactic.equiv_rw</code>, to rewrite along equalities like so</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">equiv_rw</span> <span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">prod_comm</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>now, this can do what we want from equality to some extent, but we can't lift equivalence to equality in general (we do not have univalence in Lean, my understanding is that it would break proof irrelevance). but since we have <code>propext : ∀ {a b : Prop}, (a ↔ b) → a = b</code> (and <code>funext</code>), we can prove things like equality of inductively defined sets, which might cover some of your needs -- see this kata for an example: <a href=\"https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226/lean\">https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226/lean</a></p>",
        "id": 197687811,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1589548255
    }
]
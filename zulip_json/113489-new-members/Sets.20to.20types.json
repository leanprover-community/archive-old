[
    {
        "content": "<p>I'm struggling to translate basic set theory constructs into type theory. I'm trying to define <code>disjoint</code> but I believe in type theory all terms only belong to a single type, so generically if I have two types A and B, every a : A is not a term of B, hence they are disjoint in some sort of trivial way.  I guess I want to define disjoint using equality? disjoint A B is true if  forall a : A, there does not exist  b : B such that a = b ?</p>",
        "id": 197717390,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589560325
    },
    {
        "content": "<p>disjoint doesn't make sense as a concept in types</p>",
        "id": 197717530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589560364
    },
    {
        "content": "<p>when this happens you should <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> analyze the question</p>",
        "id": 197717648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589560401
    },
    {
        "content": "<p>what caused you to want the ability to say this?</p>",
        "id": 197717762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589560440
    },
    {
        "content": "<p>I'm just trying to do basic set theory stuff in Lean but was told to not use the set  type but now I dont know how to proceed</p>",
        "id": 197717963,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589560504
    },
    {
        "content": "<p>that's not <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> enough. What are you trying to do and why</p>",
        "id": 197718052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589560532
    },
    {
        "content": "<p>if it's just set theory for the sake of set theory, first see whether <code>set A</code> is a better setting, and then ask whether it is needed at all</p>",
        "id": 197718218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589560575
    },
    {
        "content": "<p><a href=\"#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197718432\">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197718432</a></p>",
        "id": 197718701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589560755
    },
    {
        "content": "<p>I guess I just need to skip these pages. I think I can understand how an equivalence relation can be defined type theoretically quite analogously to the set way. But since things like disjointedness dont make sense, I just shouldnt think in those terms. I can move on and get to defining a group</p>",
        "id": 197718709,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589560759
    },
    {
        "content": "<p>A bare type behaves exactly in the same way as a set, except that its \"elements\" are terms (not types, so they don't have elements themselves).</p>",
        "id": 197718844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589560822
    },
    {
        "content": "<p>My goal was to do this exercise in Algebra: Chapter 0: Prove that if <code>~</code> is an equivalence relation on a set <code>S</code>, then the corresponding set of equivalence classes is a partition of the set <code>S</code>, i.e. that its elements are nonempty, disjoint and their union is <code>S</code></p>",
        "id": 197718991,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589560907
    },
    {
        "content": "<p>So in fact when you learnt equivalence relations in set theory, you took elements <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">a,b\\in X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and asked if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∼</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\sim b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>. But you never asked what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∩</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\cap b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> was, even though this strictly speaking makes sense because at the end of the day, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> <em>are actually sets</em>. Because you never used this extra setty functionality for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> and instead just treated them like \"atoms\" or \"terms\", this is why it all goes through immediately in type theory.</p>",
        "id": 197719072,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589560932
    },
    {
        "content": "<p>A relation on a set S is a function S -&gt; S -&gt; Prop. It is not a type</p>",
        "id": 197719098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589560954
    },
    {
        "content": "<p>That exercise is a joy to do in Lean. Shall we just do it now together?</p>",
        "id": 197719143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589560980
    },
    {
        "content": "<p>Hah yes please</p>",
        "id": 197719180,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589560995
    },
    {
        "content": "<p>It is therefore meaningful to talk about disjointness of equivalence classes (which are S -&gt; Prop, aka <code>set S</code>)</p>",
        "id": 197719182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589560998
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">data.equiv.basic  is the import which gives you the type `equiv X Y`, the type of</span>\n<span class=\"cm\">bijections from X to Y.</span>\n\n<span class=\"cm\">Here&#39;s the definition of equiv from that file.</span>\n\n<span class=\"cm\">structure equiv (α : Sort*) (β : Sort*) :=</span>\n<span class=\"cm\">(to_fun    : α → β)</span>\n<span class=\"cm\">(inv_fun   : β → α)</span>\n<span class=\"cm\">(left_inv  : left_inverse inv_fun to_fun)</span>\n<span class=\"cm\">(right_inv : right_inverse inv_fun to_fun)</span>\n\n<span class=\"cm\">To make a term of type `equiv α β` you have to supply a function α → β,</span>\n<span class=\"cm\">a function β → α, and proofs that both composites are the identity function.</span>\n\n<span class=\"cm\">Let&#39;s see how to create the bijection ℤ → ℤ sending x to -x.</span>\n<span class=\"cm\">-/</span>\n<span class=\"c1\">-- let&#39;s prove that x ↦ -x can be extended to</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"c1\">-- this is data</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">,</span>  <span class=\"c1\">-- this is data</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"c1\">-- this is a proof</span>\n    <span class=\"n\">change</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"c1\">-- that&#39;s the question</span>\n    <span class=\"n\">exact</span> <span class=\"n\">neg_neg</span><span class=\"o\">,</span> <span class=\"c1\">-- note: I guessed what this function was called.</span>\n                   <span class=\"c1\">-- If it had been called &quot;lemma 12&quot; I would not have been able to guess</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">neg_neg</span> <span class=\"c1\">-- another proof, this time in term mode</span>\n<span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q1 Define the type of partitions of a type.</span>\n<span class=\"cm\">A partition of X is a set of subsets of X with the property that each subset</span>\n<span class=\"cm\">is non-empty and each element of X is in precisely one of the subsets.</span>\n<span class=\"cm\">NB : this is one of the harder questions here.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"bp\">.</span> <span class=\"c1\">-- remove `.`  and fill in -- look at def of equiv above</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Equivalence relations are in core Lean -- we don&#39;t need any imports.</span>\n<span class=\"cm\">Here&#39;s an example: I&#39;ll prove that the &quot;always true&quot; relation on a set is</span>\n<span class=\"cm\">an equivalence relation.</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">always_true</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">true</span>\n\n<span class=\"c1\">-- and now here&#39;s the proof that it&#39;s an equivalence relation.</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_refl</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_symm</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_trans</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">transitive</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">Hab</span> <span class=\"n\">Hbc</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- note pointy brackets to make a term of type &quot;A ∧ B ∧ C&quot;</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">):</span> <span class=\"n\">equivalence</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">always_true_refl</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">always_true_symm</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">always_true_trans</span> <span class=\"n\">X</span><span class=\"bp\">⟩</span>\n<span class=\"c1\">-- autocomplete made that proof really easy to type. It&#39;s really</span>\n<span class=\"c1\">-- lucky that I didn&#39;t call these lemmas lemma 12, lemma 13 and lemma 14.</span>\n\n<span class=\"c1\">-- if X is a type, then `setoid X` is is the type of equivalence relations on X.</span>\n<span class=\"c1\">-- I&#39;ll now make a term of type `setoid X` corresponding to that equivalence</span>\n<span class=\"c1\">-- relation above.</span>\n\n<span class=\"c1\">-- note squiggly brackets and commas at the end of each definition to make a structure</span>\n<span class=\"n\">def</span> <span class=\"n\">always_true_setoid</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">always_true_equiv</span> <span class=\"n\">X</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q2 : If X is a type then `setoid X` is the type of equivalence relations on X,</span>\n<span class=\"cm\">and `partitions X` is the type of partitions of X. These two concepts are in</span>\n<span class=\"cm\">some sort of &quot;canonical&quot; bijection with each other (interesting exercise: make</span>\n<span class=\"cm\">this statement mathematically meaningful -- I know we all say it, but what</span>\n<span class=\"cm\">does it *mean*?).</span>\n\n<span class=\"cm\">Let&#39;s prove that these sets biject with each other by defining</span>\n<span class=\"cm\">a term of type equiv (setoid X) (partitions X)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q3 : now define a map the other way</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q4 : now finally prove that the composite of maps in both directions</span>\n<span class=\"cm\">is the identity</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">FG_eq_id</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">GF_eq_id</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q5 : now finally construct the term we seek.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">partitions_biject_with_equivalence_relations</span> <span class=\"o\">:</span>\n  <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">setoid</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 197719259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561035
    },
    {
        "content": "<p>Your move <span class=\"user-mention\" data-user-id=\"243102\">@Brandon Brown</span></p>",
        "id": 197719319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561047
    },
    {
        "content": "<p>Kevin it seems you have played this game before</p>",
        "id": 197719418,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589561106
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"err\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 197719692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561239
    },
    {
        "content": "<p><code>set</code> is a function from <code>Type u \\to Type u</code>, that's what someone was telling me earlier that <code>set</code> is a subset?</p>",
        "id": 197720245,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589561467
    },
    {
        "content": "<p><code>set X</code> is the type of subsets of <code>X</code>.</p>",
        "id": 197720324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561483
    },
    {
        "content": "<p>A term of type <code>set X</code> should be thought of as a subset of <code>X</code>.</p>",
        "id": 197720358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561498
    },
    {
        "content": "<p>Don't worry about how it's implemented.</p>",
        "id": 197720401,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561521
    },
    {
        "content": "<p>ok</p>",
        "id": 197720449,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589561530
    },
    {
        "content": "<p>If <code>x : X</code> and <code>S : set X</code> then <code>x ∈ S</code> makes sense and is a Proposition, i.e. a true/false statement.</p>",
        "id": 197720491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Sets.20to.20types/near/197719418\">said</a>:</p>\n<blockquote>\n<p>Kevin it seems you have played this game before</p>\n</blockquote>\n<p>It's some partly-written teaching material.</p>",
        "id": 197720561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589561600
    },
    {
        "content": "<p>Why is <code>def F (S : setoid X) : partition X := sorry</code> giving me an error of \"type expected at partition X\".  An equivalence relation on X implies a partition on X. The def makes sense in english</p>",
        "id": 197721799,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589562155
    },
    {
        "content": "<p>It makes sense to me too, so it must be for some reason we cannot see.</p>",
        "id": 197722675,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589562566
    },
    {
        "content": "<p>I'm reviewing how structures work</p>",
        "id": 197723162,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589562789
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">data.equiv.basic  is the import which gives you the type `equiv X Y`, the type of</span>\n<span class=\"cm\">bijections from X to Y.</span>\n\n<span class=\"cm\">Here&#39;s the definition of equiv from that file.</span>\n\n<span class=\"cm\">structure equiv (α : Sort*) (β : Sort*) :=</span>\n<span class=\"cm\">(to_fun    : α → β)</span>\n<span class=\"cm\">(inv_fun   : β → α)</span>\n<span class=\"cm\">(left_inv  : left_inverse inv_fun to_fun)</span>\n<span class=\"cm\">(right_inv : right_inverse inv_fun to_fun)</span>\n\n<span class=\"cm\">To make a term of type `equiv α β` you have to supply a function α → β,</span>\n<span class=\"cm\">a function β → α, and proofs that both composites are the identity function.</span>\n\n<span class=\"cm\">Let&#39;s see how to create the bijection ℤ → ℤ sending x to -x.</span>\n<span class=\"cm\">-/</span>\n<span class=\"c1\">-- let&#39;s prove that x ↦ -x can be extended to</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"c1\">-- this is data</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">,</span>  <span class=\"c1\">-- this is data</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"c1\">-- this is a proof</span>\n    <span class=\"n\">change</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"c1\">-- that&#39;s the question</span>\n    <span class=\"n\">exact</span> <span class=\"n\">neg_neg</span><span class=\"o\">,</span> <span class=\"c1\">-- note: I guessed what this function was called.</span>\n                   <span class=\"c1\">-- If it had been called &quot;lemma 12&quot; I would not have been able to guess</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">neg_neg</span> <span class=\"c1\">-- another proof, this time in term mode</span>\n<span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q1 Define the type of partitions of a type.</span>\n<span class=\"cm\">A partition of X is a set of subsets of X with the property that each subset</span>\n<span class=\"cm\">is non-empty and each element of X is in precisely one of the subsets.</span>\n<span class=\"cm\">NB : this is one of the harder questions here.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ℱ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"err\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Equivalence relations are in core Lean -- we don&#39;t need any imports.</span>\n<span class=\"cm\">Here&#39;s an example: I&#39;ll prove that the &quot;always true&quot; relation on a set is</span>\n<span class=\"cm\">an equivalence relation.</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">always_true</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">true</span>\n\n<span class=\"c1\">-- and now here&#39;s the proof that it&#39;s an equivalence relation.</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_refl</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_symm</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_trans</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">transitive</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">Hab</span> <span class=\"n\">Hbc</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- note pointy brackets to make a term of type &quot;A ∧ B ∧ C&quot;</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">always_true_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">):</span> <span class=\"n\">equivalence</span> <span class=\"o\">(</span><span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">always_true_refl</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">always_true_symm</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">always_true_trans</span> <span class=\"n\">X</span><span class=\"bp\">⟩</span>\n<span class=\"c1\">-- autocomplete made that proof really easy to type. It&#39;s really</span>\n<span class=\"c1\">-- lucky that I didn&#39;t call these lemmas lemma 12, lemma 13 and lemma 14.</span>\n\n<span class=\"c1\">-- if X is a type, then `setoid X` is is the type of equivalence relations on X.</span>\n<span class=\"c1\">-- I&#39;ll now make a term of type `setoid X` corresponding to that equivalence</span>\n<span class=\"c1\">-- relation above.</span>\n\n<span class=\"c1\">-- note squiggly brackets and commas at the end of each definition to make a structure</span>\n<span class=\"n\">def</span> <span class=\"n\">always_true_setoid</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">always_true</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">always_true_equiv</span> <span class=\"n\">X</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q2 : If X is a type then `setoid X` is the type of equivalence relations on X,</span>\n<span class=\"cm\">and `partitions X` is the type of partitions of X. These two concepts are in</span>\n<span class=\"cm\">some sort of &quot;canonical&quot; bijection with each other (interesting exercise: make</span>\n<span class=\"cm\">this statement mathematically meaningful -- I know we all say it, but what</span>\n<span class=\"cm\">does it *mean*?).</span>\n\n<span class=\"cm\">Let&#39;s prove that these sets biject with each other by defining</span>\n<span class=\"cm\">a term of type equiv (setoid X) (partitions X)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q3 : now define a map the other way</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q4 : now finally prove that the composite of maps in both directions</span>\n<span class=\"cm\">is the identity</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">FG_eq_id</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">GF_eq_id</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q5 : now finally construct the term we seek.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">partitions_biject_with_equivalence_relations</span> <span class=\"o\">:</span>\n  <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">setoid</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>This file works for me.</p>",
        "id": 197723806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589563100
    },
    {
        "content": "<p>If that exact file is giving you errors then update your Lean and mathlib.</p>",
        "id": 197724104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589563259
    },
    {
        "content": "<p>Okay it's working now. I must have accidentally messed something up</p>",
        "id": 197724266,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1589563332
    },
    {
        "content": "<p>Feel free to write the official solutions; I don't seem to have written them down.</p>",
        "id": 197724348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589563378
    },
    {
        "content": "<p>I have official solutions for a completely different teaching file on the same material, with far fewer comments. If you've played the natural number game and you know how to make a term whose type is a structure (hint: write <code>:= {! !}</code> and then click on the light bulb and select the bottom but one option, assuming some mathlib is imported).</p>",
        "id": 197724582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589563481
    },
    {
        "content": "<p>I had to go through the natural number game first before attempting this. I have some unsightly proofs of G and F. Still working on proving they compose to identity.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">setoid</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">open</span> <span class=\"n\">setoid</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"err\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">F</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">partition</span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n<span class=\"o\">(</span>\n     <span class=\"n\">classes</span> <span class=\"n\">S</span>\n<span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"c1\">-- ⊢ (disjoint : ∀ A B ∈ ℱ, A ≠ B → A ∩ B = ∅)</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eq_of_subset_of_subset</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">intros</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mem_empty_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">a_1</span><span class=\"o\">,</span>\n      <span class=\"c1\">--have F : set (set X), from classes S,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">eq_of_mem_classes</span><span class=\"o\">,</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">},</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">apply</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">empty_subset</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"c1\">-- ⊢ (cover : ∀ x : X, ∃ A ∈ ℱ, x ∈ A)</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"c1\">-- ⊢ (nonempty : ∀ A ∈ ℱ, A ≠ ∅)</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">aqn</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">empty_not_mem_classes</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"err\">←</span> <span class=\"n\">aqn</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">F</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Q3 : now define a map the other way</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">setoid_of_disjoint_union</span><span class=\"o\">,</span>\n    <span class=\"n\">swap</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">F</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eq_of_subset_of_subset</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">p1</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">trivial</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">p1</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">cover</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">pairwise_disjoint</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">pairwise_on</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">disjoint</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∩</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">disjoint</span><span class=\"o\">,</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">},</span>\n    <span class=\"n\">finish</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 199301305,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1590922713
    },
    {
        "content": "<p>Oh thanks! You'll need two proofs of course, one for each round trip. Then you're done</p>",
        "id": 199312262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590943132
    },
    {
        "content": "<p>You should probably be using structure notation to make these structures though. I am busy with real life right now unfortunately</p>",
        "id": 199312275,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590943192
    },
    {
        "content": "<p>You made a partition structure as follows</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"err\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>To prove two partitions are equal, I assume I have to make my own <code>.ext</code> definition?</p>",
        "id": 200744431,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1592014721
    },
    {
        "content": "<p>It'll be a lemma, but yeah.</p>",
        "id": 200744468,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592014786
    },
    {
        "content": "<p>Back in 2018, I wrote some code on partitions (with a lot of help from folks here, especially Simon Hudon, see e.g. <a href=\"#narrow/stream/113488-general/topic/tutorial\">this thread</a>) in a \"tutorials\" branch: <a href=\"https://github.com/leanprover-fork/mathlib-backup/blob/tutorials/tutorials/partitions.lean\">https://github.com/leanprover-fork/mathlib-backup/blob/tutorials/tutorials/partitions.lean</a></p>\n<p>I think some of the code eventually made it in to <code>data.setoid.partition</code> but not the <code>partition</code> structure. The code was written when I knew a lot less about Lean, so there are probably lots of things which are done poorly. Nonetheless, I tried to write a lot of comments, so you might find it interesting.</p>\n<p>It's based on a very old version of mathlib (using the now-ancient Lean 3.4.1!) but <code>leanproject</code> and <code>elan</code> should make it fairly easy to get it up and running (modulo some compiling time):</p>\n<div class=\"codehilite\"><pre><span></span><code>leanproject get https://github.com/leanprover-fork/mathlib-backup:tutorials\n<span class=\"nb\">cd</span> mathlib-backup_tutorials\n<span class=\"c1\"># this is a version of mathlib from before we started uploading oleans to the cloud,</span>\n<span class=\"c1\"># so unfortunately you&#39;ll have to do some compiling yourself</span>\nlean --make tutorials/partitions.lean\n</code></pre></div>\n\n\n<p>Then you can open up <code>mathlib-backup_tutorials/</code> in VS Code and then look at <code>tutorials/partitions.lean</code>.</p>",
        "id": 200745239,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592016085
    },
    {
        "content": "<p>very helpful, thank you!</p>",
        "id": 200745472,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1592016519
    },
    {
        "content": "<p>Actually, you can just write <code>@[ext]</code> immediately before the structure, and you'll get an automatically generated <code>ext</code> lemma. It may not be the one you actually want.</p>",
        "id": 200749228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1592023784
    }
]
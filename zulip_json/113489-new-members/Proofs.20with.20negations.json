[
    {
        "content": "<p>Still working through TPIL and totally flummoxed by proofs of negations. For example, working through De Morgan's laws, and have gotten this to work by copying the very terse <code>mathlib</code> proof, but I don't understand how it works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">not_or_dist_left</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">hnpq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">),</span>\n  <span class=\"k\">show</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span>\n    <span class=\"k\">assume</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">hnpq</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hp</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I've assumed <code>p</code>, provided that to <code>¬(p ∨ q)</code> and demonstrated <code>¬p</code>? It all feels very mindtwisty like there's a proof by contraction without stating <code>by_contradiction</code> or <code>absurd</code>.</p>",
        "id": 300601052,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664072686
    },
    {
        "content": "<p>keep in mind that <code>¬p</code> is equivalent to <code>p → false</code>, so if you want to prove <code>¬p</code> all you need to do is assume <code>p</code> and derive <code>false</code> somehow</p>",
        "id": 300601215,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664072903
    },
    {
        "content": "<p>also, since <code>¬p</code> is equivalent to <code>p → false</code>, if you have a proof of <code>¬p</code> and you apply <code>p</code> to it, you get <code>false</code> back (because what you're really doing is applying <code>p</code> to <code>p → false</code>)</p>",
        "id": 300601371,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664073144
    },
    {
        "content": "<p>what the above proof is doing is this:</p>\n<p>1) we assume the premise, <code>¬(p ∨ q)</code><br>\n2) we want to prove <code>¬p</code> which is actually proving <code>p → false</code>, so we assume <code>p</code> is true and our goal is to prove <code>false</code><br>\n3) since <code>p</code> is true, we know that <code>p ∨ q</code> is true (this is what <code>or.inl hp</code> is doing)<br>\n4) now we know <code>p ∨ q</code> is true (represented by <code>or.inl hp</code>), and we also assumed <code>¬(p ∨ q)</code> is true (represented by <code>hnpq</code>), so we combine those to get <code>false</code> in the final line and we're done</p>",
        "id": 300601583,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664073463
    },
    {
        "content": "<p>Cool, so it's a sort of proof by contraction because we <em>want</em> <code>false → p</code>...?</p>",
        "id": 300601782,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664073625
    },
    {
        "content": "<p>not exactly... we don't want to derive <code>p</code> from <code>false</code>, but the other way around</p>",
        "id": 300602133,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664074092
    },
    {
        "content": "<p>though certainly, once you have <code>false</code> you can derive whatever you want</p>",
        "id": 300602138,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664074110
    },
    {
        "content": "<p>but the goal is to start with <code>p</code> and end up producing <code>false</code> somehow</p>\n<p><code>¬p</code> just <em>is</em> <code>p → false</code> within Lean... that's how it's represented</p>",
        "id": 300602218,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664074223
    },
    {
        "content": "<p>in other words, when you see <code>¬p</code> you should think to yourself \"that's a function from <code>p</code> to <code>false</code>\"</p>",
        "id": 300602257,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664074291
    },
    {
        "content": "<p>(at least that's how I think of it, being a software engineer by trade... if you're a mathematician you can think of it as being equivalent to \"if p, then false\")</p>",
        "id": 300602312,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664074380
    },
    {
        "content": "<p>but yes, it's a proof by contradiction in the sense that you prove <code>not p</code> by assuming <code>p</code> and deriving <code>false</code></p>",
        "id": 300602469,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664074566
    },
    {
        "content": "<p>Thanks -- also software engineering by background and having a hard time reasoning over types here. I suppose like most things Lean I'll just get used to it.</p>",
        "id": 300602551,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664074686
    },
    {
        "content": "<p>yeah, it's a bit weird at first but eventually it starts to click</p>",
        "id": 300602642,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664074821
    },
    {
        "content": "<p>So to check understanding, this bit:<br>\n<code>assume hp: p</code> is the premise to the function and we show <code>false</code> by <code>hnpq (or.inl hp)</code></p>\n<p>And in the other side of the double implication we do the same thing for <code>¬(p ∨ q)</code> by assuming <code>p ∨ q</code> and showing each case leads to false...</p>",
        "id": 300607761,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664081573
    },
    {
        "content": "<p>We don't actually assume <code>p v q</code>. The statement we're trying to prove is \"<strong>if</strong> ¬(p ∨ q), <strong>then</strong> ¬p\". In other words, we need to produce a function that takes in a proof of <code>¬(p ∨ q)</code> and returns a proof of <code>¬p</code>.</p>",
        "id": 300608693,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664082623
    },
    {
        "content": "<p>So we assume <code>¬(p ∨ q)</code> at the start, and our goal is to return <code>¬p</code> (which is equivalent to saying that our goal is return a function from <code>p</code> to <code>false</code>).</p>",
        "id": 300608731,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664082689
    },
    {
        "content": "<p>At the point where we assumed <code>p</code>, we were able to derive <code>p v q</code> from that because it logically follows: \"if P is true, then P or Q is true\"</p>",
        "id": 300608812,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664082821
    },
    {
        "content": "<p>If <code>assume</code> is confusing, just remember that it's shorthand for <code>λ a</code>... it's just another way of declaring a function argument</p>",
        "id": 300608982,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664083061
    },
    {
        "content": "<p>Here's another way to write out the same proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">not_or_dist_left</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">not_p_or_q</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- we need a function from p to false</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">proof_of_p</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">p_or_q</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">or.inl</span> <span class=\"n\">proof_of_p</span> <span class=\"k\">in</span>\n    <span class=\"n\">not_p_or_q</span> <span class=\"n\">p_or_q</span>\n</code></pre></div>",
        "id": 300609351,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664083535
    },
    {
        "content": "<p>Does it make more sense if you write the goal as <code>(p ∨ q → false) → (p → false)</code>?</p>",
        "id": 300619532,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664093415
    },
    {
        "content": "<p>I also picture this proof in my mind as a proof by contradiction.  Maybe, with the comments below, the argument makes more sense?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">not_or_dist_left</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">hnpq</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">),</span>  <span class=\"c1\">-- Suppose that `p ∨ q` is false</span>\n  <span class=\"k\">show</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span>         <span class=\"c1\">-- We want to show that `p` itself must be false</span>\n    <span class=\"k\">assume</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span>         <span class=\"c1\">-- By contradiction, suppose that `p` is true instead</span>\n    <span class=\"n\">hnpq</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hp</span><span class=\"o\">))</span>     <span class=\"c1\">-- If `p` is true, then `p ∨ q` is true (this is the `or.inl` part),</span>\n                          <span class=\"c1\">-- contrary to the assumption `hnpq` that `p ∨ q` is false</span>\n</code></pre></div>",
        "id": 300620923,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1664094522
    },
    {
        "content": "<p>Thanks for all of this , and I think I'm understanding. At the type level, our function is really <code>p ∨ q → false) → (p → false)</code>, inside the proof in the <code>show, from</code> step we are actually constructing a function <code>p→ false</code>, which, since it typechecks, constitutes proof,  but the sugared logical flow in that step looks like a proof by contradiction (assuming <code>p</code>, showing that it leads to <code>false</code>.</p>",
        "id": 300657381,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664116328
    },
    {
        "content": "<p>I am <em>absurd</em>ly pleased by this, which took me far too much time to work out.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"o\">(</span>\n    <span class=\"n\">or.elim</span> <span class=\"o\">(</span><span class=\"n\">em</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span> <span class=\"k\">assume</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">hrs</span><span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n      <span class=\"n\">hrs.elim</span>\n      <span class=\"o\">(</span> <span class=\"k\">assume</span> <span class=\"n\">hr</span><span class=\"o\">:</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">hpr</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">hp₂</span><span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n        <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">or.inl</span> <span class=\"n\">hpr</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span> <span class=\"k\">assume</span> <span class=\"n\">hs</span><span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">hps</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">hp₂</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n        <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">or.inr</span> <span class=\"n\">hps</span><span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n    <span class=\"o\">(</span> <span class=\"k\">assume</span> <span class=\"n\">hnp</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">hpr</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">hp</span> <span class=\"n\">hnp</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">or.inl</span> <span class=\"n\">hpr</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span>\n</code></pre></div>\n<p>It seems that Lean knows that the three lambda expressions here occur in a context where it is already known that <code>p</code> is <code>true</code> or <code>false</code> as the case may be??</p>",
        "id": 300898875,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664225878
    },
    {
        "content": "<p>Lean doesn't consider propositions to be true or false per se -- we consider a proposition to be \"true\" if we have a proof of it in context.</p>",
        "id": 300907458,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"542196\">@Arien Malec</span> What programming language are you the most familiar with? I ask because there isn't really any magic going on in the above code (Lean doesn't have to \"know\" anything), and perhaps I can rewrite it in a way that demonstrates that</p>",
        "id": 300907527,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664230093
    },
    {
        "content": "<p>It might be helpful to see the proof with a bunch of the syntactic sugar removed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n    <span class=\"n\">or.elim</span> <span class=\"o\">(</span><span class=\"n\">em</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n      <span class=\"k\">have</span> <span class=\"n\">hrs</span><span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n      <span class=\"n\">hrs.elim</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">r</span><span class=\"o\">),</span>\n        <span class=\"k\">have</span> <span class=\"n\">hpr</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">hp₂</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n        <span class=\"n\">or.inl</span> <span class=\"n\">hpr</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n        <span class=\"k\">have</span> <span class=\"n\">hps</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">hp₂</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n        <span class=\"n\">or.inr</span> <span class=\"n\">hps</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">),</span>\n      <span class=\"k\">have</span> <span class=\"n\">hpr</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">hp</span> <span class=\"n\">hnp</span><span class=\"o\">,</span>\n      <span class=\"n\">or.inl</span> <span class=\"n\">hpr</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 300907543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230111
    },
    {
        "content": "<p>I still left the <code>have</code> clauses, which are yet another way to write lambda expressions</p>",
        "id": 300907570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230137
    },
    {
        "content": "<p>The <code>show</code> clauses weren't completely necessary since you can get the goal from the goal view in VS Code or Emacs. There's no harm in keeping them, and I removed them just to illustrate that they're not doing any magic.</p>",
        "id": 300907688,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230203
    },
    {
        "content": "<p>Most relevant, Rust, enough Haskell to do stuff, but not be typesystem dangerous.</p>\n<p><code>λ hp₂ : p, hr</code> is an anonymous lambda, which can be called with any value? It could be called in a context where <code>p</code> is <code>false</code>, yeah? But we know that we are are calling in in a context where <code>p</code> is true...</p>",
        "id": 300907804,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664230280
    },
    {
        "content": "<p>Here's it with all the have's removed too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n    <span class=\"n\">or.elim</span> <span class=\"o\">(</span><span class=\"n\">em</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n      <span class=\"n\">or.elim</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hp₂</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">hr</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">or.inr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hp₂</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">hs</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">),</span>\n      <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">absurd</span> <span class=\"n\">hp</span> <span class=\"n\">hnp</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 300907927,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230328
    },
    {
        "content": "<p>Yes, <code>λ hp₂ : p, hr</code> can be called with any proof <code>hp₂</code> of <code>p</code>. It can only be called when <code>p</code> is \"true\" for that reason.</p>",
        "id": 300907971,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230356
    },
    {
        "content": "<p>It can only be called in a context when <code>p</code> is \"false\" when <code>p</code> is also \"true\" (i.e., when there's a logical contradiction)</p>",
        "id": 300908077,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230428
    },
    {
        "content": "<p>it's also true that <code>λ hp₂ : p, hr</code> by itself is a valid proof of <code>p → r</code> in a context where you already have a proof of <code>r</code> in a variable <code>hr</code></p>",
        "id": 300908199,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664230477
    },
    {
        "content": "<blockquote>\n<p>we are calling it in a context where <code>p</code> is true</p>\n</blockquote>\n<p>maybe there's a misunderstanding because we're not \"calling \" <code>(hp₂ : p), hr</code> anywhere (I think)</p>",
        "id": 300908584,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664230713
    },
    {
        "content": "<p>we're writing it out as a proof of the proposition <code>(p → r)</code>, and then using it to prove <code>(p → r) ∨ (p → s)</code></p>",
        "id": 300908661,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664230772
    },
    {
        "content": "<p>(I'll mention that it's a Lean theorem that if you have <code>h : p</code> (i.e., <code>p</code> is \"true\" since we have a proof of it) then you can conclude that <code>p = true</code>. But Lean generally won't replace <code>p</code> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/true\">docs#true</a> on its own.)</p>",
        "id": 300908682,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664230781
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"542196\">@Arien Malec</span> I'm curious why you said we were \"calling\"  <code>λ hp₂ : p, hr</code>... are you imagining that the function has to be \"called\" to create a proof of <code>p → r</code>? Because it doesn't... the function <em>is</em> the proof.</p>",
        "id": 300911724,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664232521
    },
    {
        "content": "<p>In the H-M type system languages I've used in anger (Ocaml, Rust, Swift, Haskell), if I define, say <code>|p: bool|  -&gt; bool {r}</code>, <code>r</code> in the lambda body is bound and captured, but <code>p</code> is free, and I'm saying \"whatever <code>p</code> is, return the bound value of <code>r</code>\",  which is a stronger proof than we want, yeah? It's a function from <code>¬p</code> to <code>r</code> as well. I have to know that <code>p</code> as well?</p>\n<p>Put it another way, out of context that <code>p</code>, how could <code>λ h : p, hr</code> constitute a proof <code>(p → r)</code>?</p>",
        "id": 300911749,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664232538
    },
    {
        "content": "<p><code>p → r</code> means \"if you give me a proof of <code>p</code>, I'll give you a proof of <code>r</code>\"... in other words, a function that takes in a proof of <code>p</code> and returns a proof of <code>r</code></p>",
        "id": 300911959,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664232663
    },
    {
        "content": "<p>in this case, it so happens that we already have a proof of <code>r</code> in the variable <code>hr</code></p>",
        "id": 300911990,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664232694
    },
    {
        "content": "<p>it doesn't matter that we might not have a proof of <code>p</code>... an implication is just a hypothetical, saying <em>if</em> this is the case, <em>then</em> that is the case</p>",
        "id": 300912167,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664232801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Proofs.20with.20negations/near/300911724\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> I'm curious why you said we were \"calling\"  <code>λ hp₂ : p, hr</code>... are you imagining that the function has to be \"called\" to create a proof of <code>p → r</code>? Because it doesn't... the function <em>is</em> the proof.</p>\n</blockquote>\n<p>I think I've got that (or it's getting grokked slowly). But it's only a proof when we already know that <code>p</code>, right?</p>\n<p>If I dropped the same function  in to the other branch of the <code>elim</code>, it would constitute a proof of the opposite, right?</p>\n<p><code>(λ (hnp : ¬p),  (λ (hr : r), or.inl (λ (hp₂ : p), hr))</code> in that context would be a proof that <code>¬p → r</code>?</p>",
        "id": 300912265,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664232847
    },
    {
        "content": "<p>Or…would that fail to typecheck, because <code>p</code> and <code>¬p</code> aren't values of a <code>bool</code>, they are totally different types…</p>",
        "id": 300912382,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664232935
    },
    {
        "content": "<p>the thing is that the implication doesn't require <code>p</code> to be true</p>",
        "id": 300912384,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664232939
    },
    {
        "content": "<p>in fact, you could replace the exact same function in the same place with <code>(hp₂ : ¬p), hr</code> and you would have a proof of <code>¬p → r</code></p>",
        "id": 300912489,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233017
    },
    {
        "content": "<p>but Lean would be confused because the goal at that point is to prove <code>p → r</code></p>",
        "id": 300912540,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233054
    },
    {
        "content": "<p>I think the lighbulb moment here is \"p and ¬p aren't values of a bool, they are totally different types\"</p>",
        "id": 300912546,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664233057
    },
    {
        "content": "<p><code>(λ (hnp : ¬p),  (λ (hr : r), or.inl (λ (hp₂ : p), hr))</code> would be a proof of <code>¬p → r → p ∨ r</code></p>",
        "id": 300912778,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233191
    },
    {
        "content": "<p>which is just true in any context</p>",
        "id": 300912833,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233204
    },
    {
        "content": "<p>it's like we need to prove \"if aliens are real, then your name is Arien Malec\" and we have a proof that your name is Arien Malec</p>",
        "id": 300912916,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233276
    },
    {
        "content": "<p>I'm walking around with a mental model of <code>Prop</code> being like <code>bool</code>, when <code>p: Prop</code> is already an assertion that <code>p</code>.</p>",
        "id": 300912988,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664233320
    },
    {
        "content": "<p><code>p : Prop</code> is a proposition named <code>p</code>, it doesn't assert anything. However, <code>hp : p</code> is a proof of <code>p</code>.</p>",
        "id": 300913043,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233337
    },
    {
        "content": "<p>the \"propositions are types and proofs are terms of them\" model can be a bit tricky to wrap your mind around, for sure</p>",
        "id": 300913282,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233507
    },
    {
        "content": "<p>it's a bit confusing because the proposition <em>is</em> the type, while <code>Prop</code> is the type of propositions</p>",
        "id": 300913431,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233604
    },
    {
        "content": "<p>so if you had a variable <code>h</code> whose type was <code>∃ n, n &gt; 0</code>, then it would be a proof that there's a number greater than 0</p>",
        "id": 300913540,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233685
    },
    {
        "content": "<p>Mathlib has that there's a bijection between <code>Prop</code> and <code>bool</code>, so <code>Prop</code> being like <code>bool</code> isn't so far off (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.Prop_equiv_bool\">docs#equiv.Prop_equiv_bool</a>)</p>\n<p>The big difference is that when you have a term of <code>bool</code> in hand, you can tell whether it is <code>tt</code> or <code>ff</code> by computing long enough. But when you have <code>p : Prop</code>, there's no procedure you can use to decide (in general) whether <code>p = true</code> or <code>p = false</code>. You can only infer that <code>p = true</code> if you manage to find a proof <code>h : p</code> or that <code>p = false</code> if you manage to find a proof <code>h : ¬p</code>.</p>",
        "id": 300913605,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664233738
    },
    {
        "content": "<p>There's also the big difference that <code>bool</code> and <code>Prop</code> are at different \"levels\", as Matt has mentioned.  Here's a diagram that tries to illustrate this: <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723</a></p>",
        "id": 300913731,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664233823
    },
    {
        "content": "<p>right... Propositions are not necessarily decidable</p>",
        "id": 300913733,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233824
    },
    {
        "content": "<p>The \"typechecking is proof\" paradigm is super deep. Playing around with my proof the issue with proving <code> p ∨ r</code> in the <code>¬p</code> context is not the <code>p</code> vs <code>¬p</code> issue but that <em>I haven't found a proof <code>hr: r</code> in that context</em>.</p>",
        "id": 300913784,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664233871
    },
    {
        "content": "<p>yeah that sounds right, in the sense that you're able to prove <code>p ∨ r</code> if you have a proof of <code>r</code> (though you could also prove it if you had a proof of <code>p</code>)</p>",
        "id": 300913899,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664233954
    },
    {
        "content": "<p>Really appreciate the help getting my head wrapped the right way around these concepts.</p>",
        "id": 300913940,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664233985
    },
    {
        "content": "<p>no problem!</p>",
        "id": 300914039,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664234047
    },
    {
        "content": "<p>(did you mean to write <code>p → r</code> instead of <code>p ∨ r</code>above? if so, then you've got the right idea)</p>",
        "id": 300914691,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664234470
    },
    {
        "content": "<p>I was interpreting that as, if you want to prove <code>p ∨ r</code> but you have <code>¬p</code>, then you know you need a proof of <code>r</code>.</p>",
        "id": 300914805,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1664234548
    },
    {
        "content": "<p>oh right... that also makes sense</p>\n<blockquote>\n<p><code>(λ (hnp : ¬p),  (λ (hr : r), or.inl (λ (hp₂ : p), hr))</code> would be a proof of <code>¬p → r → p ∨ r</code></p>\n</blockquote>\n<p>I wrote this above and I just realized it's not true, so I was hoping I didn't confuse him... the point is that it proves <code>(p → r) ∨ [anything else]</code>, not <code>p ∨ r</code></p>\n<p>I'm sure he'll figure it out</p>",
        "id": 300915060,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1664234732
    },
    {
        "content": "<p>I got it modulo typos!</p>",
        "id": 300919201,
        "sender_full_name": "Arien Malec",
        "timestamp": 1664237270
    }
]
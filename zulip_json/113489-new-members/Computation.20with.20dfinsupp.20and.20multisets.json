[
    {
        "content": "<p>I'm doing some work that involves a theory over dfinsupp (functions with finite support), which I'm using over finsupp specifically for computation. It looks like I can reduce <code>dfinsupp.support</code> fine, but I was having trouble with <code>multiset.sort</code>. For example, the following theorem doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.multiset.sort</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">reduce_multiset_sort</span> <span class=\"o\">:</span>\n  <span class=\"n\">multiset.sort</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl.</span>\n</code></pre></div>\n<p>and furthermore <code>#reduce</code> doesn't work (after a while it produces \"(deterministic) timeout\"):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#reduce</span> <span class=\"n\">multiset.sort</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Am I doing something wrong?</p>",
        "id": 297988806,
        "sender_full_name": "Tej Chajed",
        "timestamp": 1662734508
    },
    {
        "content": "<p>I did just discover that <code>#eval</code> works, which I guess uses the VM instead. Is there a way to access that from tactics (along with other forms of normalization)?</p>",
        "id": 298002089,
        "sender_full_name": "Tej Chajed",
        "timestamp": 1662738382
    },
    {
        "content": "<p>when you run code in a tactic it's using the equivalent of <code>#eval</code></p>",
        "id": 298002296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662738450
    },
    {
        "content": "<p>if you have access only to the expression you need to use <code>eval_expr</code> to turn it into a multiset and evaluate it</p>",
        "id": 298002499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662738512
    },
    {
        "content": "<p>What I want to do is make one definition be the normalization of another, and ideally I'd know how to do that with <code>unfold</code>/<code>simp</code>/<code>#eval</code>. I thought I'd use a tactic block to do this, but I'm not sure how that would work. I'm basically trying to mimic Coq's <code>eval compute in ...</code>.</p>",
        "id": 298003615,
        "sender_full_name": "Tej Chajed",
        "timestamp": 1662738858
    },
    {
        "content": "<p>I may want to do more metaprogramming in Lean 3, but I'm not able to find much in the way of resources. There is the mathlib generated documentation (eg, <a href=\"https://leanprover-community.github.io/mathlib_docs/init/meta/interactive.html#tactic.interactive.simp\">https://leanprover-community.github.io/mathlib_docs/init/meta/interactive.html#tactic.interactive.simp</a>), which is helpful, but I'm wondering if there's a resource I don't know about.</p>",
        "id": 298005641,
        "sender_full_name": "Tej Chajed",
        "timestamp": 1662739345
    },
    {
        "content": "<p>As a subproblem I figured out how to evaluate <code>list.merge_sort</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">reduce_list_sort</span> <span class=\"o\">:</span> <span class=\"n\">list.merge_sort</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">list.merge_sort_cons_cons</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.merge_sort</span><span class=\"o\">],</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> `refl` should work here if `list.merge` reduces nicely -/</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.merge</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.merge</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I understand that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.merge_sort\">docs#list.merge_sort</a> is defined using well-founded recursion so we need to rewrite by non-defeq equational lemmas, but I'm surprised that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.merge\">docs#list.merge</a> also behave similarly. Indeed when I <code>#print list.merge._main._pack</code> I see <code>has_well_founded.wf.fix</code> in it. Surely we can redefine <code>list.merge</code> to have good reduction behavior?</p>",
        "id": 298011256,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662740993
    },
    {
        "content": "<p>For <code>reduce_multiset_sort</code> you can start with <code>change list.merge_sort (≤) [1,2,3] = _,</code> but I haven't found a short and automatic way to do it.</p>",
        "id": 298013083,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662741617
    },
    {
        "content": "<p>does <code>dec_trivial</code> not work?</p>",
        "id": 298013742,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1662741797
    },
    {
        "content": "<p>It doesn't.</p>",
        "id": 298014354,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662741965
    },
    {
        "content": "<p>IIRC there is a set_option you can use to force unfolding lemmas to make <code>dec_trivial</code> work on wf recursions</p>",
        "id": 298014609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662742063
    },
    {
        "content": "<p>By the way when I do <code>simp [list.merge_sort, list.merge], dsimp,</code>it reduces to something involving <code>and.rec</code> that doesn't seem to reduce further.</p>",
        "id": 298014616,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662742067
    },
    {
        "content": "<p>I think it would be simpler to just prove the result is sorted and a permutation of the input</p>",
        "id": 298014838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662742137
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">reduce_list_sort</span> <span class=\"o\">:</span> <span class=\"n\">list.merge_sort</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">list.eq_of_perm_of_sorted</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">list.sorted_merge_sort</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">])</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">list.perm_merge_sort</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 298014840,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1662742137
    },
    {
        "content": "<p>works for me</p>",
        "id": 298014843,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1662742139
    },
    {
        "content": "<p>^ that</p>",
        "id": 298014886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662742155
    },
    {
        "content": "<p>Oh I see that wf.fix is used essentially, because in <code>| (a :: l) (b :: l') := if r a b then a :: merge' l (b :: l') else b :: merge' (a :: l) l'</code> only one of the two arguments becomes smaller, so maybe we can't make list.merge reduce nicely.</p>\n<p>Eric's solution is nice, but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.decidable_perm\">docs#list.decidable_perm</a> seems to be quadratic rather than linear, so it would be nicer if list.merge_sort could compute.</p>",
        "id": 298018066,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662743185
    },
    {
        "content": "<p>I forgot that double induction is actually easy to make computable; the following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">r</span><span class=\"o\">]</span>\n<span class=\"kn\">include</span> <span class=\"n\">r</span>\n<span class=\"kd\">def</span> <span class=\"n\">merge'</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">fl</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">id</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">l'</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">l'</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">l'</span> <span class=\"n\">fl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">fl</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">fl'</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">merge'_nil_left</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">merge'</span> <span class=\"n\">r</span> <span class=\"o\">[]</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">merge'_nil_right</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">merge'</span> <span class=\"n\">r</span> <span class=\"n\">l</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">l</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">merge'_cons_cons</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">merge'</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">merge'</span> <span class=\"n\">r</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">merge'</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">merge'</span>\n<span class=\"c\">/-</span><span class=\"cm\"> list.rec id</span>\n<span class=\"cm\">    (λ (a : α) (l : list α) (fl : list α → list α) (l' : list α),</span>\n<span class=\"cm\">       list.rec (a :: l) (λ (b : α) (l' fl' : list α), ite (r a b) (a :: fl (b :: l')) (b :: fl')) l')</span>\n<span class=\"cm\">    l -/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n</code></pre></div>",
        "id": 298048334,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662755165
    },
    {
        "content": "<p>I've found some old discussions about <a href=\"https://github.com/leanprover/lean/issues/654\">stuck terms involving <code>acc.rec</code></a> and about <code>acc</code> being <a href=\"https://github.com/leanprover/lean/pull/1803#issuecomment-324716518\">inefficient to compute with</a> in the kernel of Lean and Coq. Presumably the stuck term makes <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.fix_F_eq\">docs#well_founded.fix_F_eq</a> not a rfl lemma. Maybe there's something in Mario's thesis as well. So there's still no satisfying solution to this?</p>",
        "id": 298049059,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662755486
    },
    {
        "content": "<p>Interestingly, Lean can realize that <code>fix_F_eq</code> is defeq if we insert an <code>id</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">well_founded</span>\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kn\">local</span> <span class=\"kd\">infix</span> <span class=\"bp\">`≺`</span><span class=\"o\">:</span><span class=\"mi\">50</span>    <span class=\"o\">:=</span> <span class=\"n\">r</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">≺</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fix_F_eq'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acx</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"n\">acx</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≺</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">acc.inv</span> <span class=\"n\">acx</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">acc.intro</span> <span class=\"n\">x</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">acx.inv</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\"> The original proof: acc.drec (λ x r ih, rfl) acx -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> by { dsimp only [← acc.eq_intro_inv], refl } doesn't work, where</span>\n<span class=\"cm\">  lemma acc.eq_intro_inv (x : α) (acx : acc r x) : acc.intro x (λ y, acx.inv) = acx := rfl -/</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">fix_F_eq'</span> <span class=\"c\">/-</span><span class=\"cm\"> id (eq.refl (fix_F F x (acc.intro x (λ (y : α), acx.inv)))) -/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">well_founded</span>\n</code></pre></div>",
        "id": 298067213,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662765473
    },
    {
        "content": "<p>I'm confused upon reading <a href=\"https://github.com/leanprover/lean/pull/1803#issuecomment-324897405\">issue 1803</a>. From the discussion it seems well-founded recursion should actually compute, contrary to what I observed in <code>fix_F_eq</code>, which doesn't seem to involve anything like propext or choice that causes a term to be stuck. Has anything changed since then? It seems to be a fairly recent issue (as far as official Lean3 is concerned).<br>\n(Update: from <a href=\"https://github.com/leanprover/lean/issues/1694#issuecomment-310672276\">this other issue</a> it seems computation isn't supposed to work: \"a function application f a b cannot be reduced definitionally (using the equational lemmas) if f was defined by well founded recursion.\")</p>",
        "id": 298079421,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662777497
    },
    {
        "content": "<p>Another example of defeq non-transitivity could be extracted from my previous post:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">well_founded</span>\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kn\">local</span> <span class=\"kd\">infix</span> <span class=\"bp\">`≺`</span><span class=\"o\">:</span><span class=\"mi\">50</span>    <span class=\"o\">:=</span> <span class=\"n\">r</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">≺</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fix_F_eq0</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acx</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"n\">acx</span> <span class=\"bp\">=</span> <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">acc.intro</span> <span class=\"n\">x</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">acx.inv</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fix_F_eq1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acx</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">acc.intro</span> <span class=\"n\">x</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">acx.inv</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">$</span> <span class=\"n\">acx.inv</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fix_F_eq2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acx</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"n\">acx</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">fix_F</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">$</span> <span class=\"n\">acx.inv</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c\">/-</span><span class=\"cm\"> fails -/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">well_founded</span>\n</code></pre></div>",
        "id": 298082200,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662781060
    },
    {
        "content": "<p>It's a bit mysterious why the following doesn't work; is it because of some special support for <code>acc.rec</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">acc</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acx</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">rec_eq0</span> <span class=\"o\">:</span> <span class=\"n\">acx.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">acc.intro</span> <span class=\"n\">x</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">acx.inv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c\">/-</span><span class=\"cm\"> fails -/</span>\n<span class=\"kd\">end</span> <span class=\"n\">acc</span>\n</code></pre></div>\n<p><code>set_option pp.all true</code> show the two sides agree except for the proof of <code>acc r x</code>.<br>\n<code>lemma eq_intro : acx = acc.intro x (λ y, acx.inv) := rfl</code> works without problem.</p>",
        "id": 298082372,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662781248
    }
]
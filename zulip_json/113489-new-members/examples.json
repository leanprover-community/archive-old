[
    {
        "content": "<p>How can I close the following goal?<br>\n<code>example (h :card I = 0) (i : I) : false := sorry</code></p>",
        "id": 245619635,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626026947
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.ne_zero_iff_nonempty\">docs#cardinal.ne_zero_iff_nonempty</a></p>",
        "id": 245619861,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626027283
    },
    {
        "content": "<p>And even <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.eq_zero_iff_is_empty\">docs#cardinal.eq_zero_iff_is_empty</a></p>",
        "id": 245619895,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626027333
    },
    {
        "content": "<p>Do you need more help using such lemmas?</p>",
        "id": 245619967,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626027406
    },
    {
        "content": "<p>Thanks and I will try!</p>",
        "id": 245621533,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626029762
    },
    {
        "content": "<p>This is simple to prove <code>example (a : ℚ): - ((λ i, a) : α → ℚ) = (λ i, -a) := by {ext, simp}</code>.<br>\nBut are there any built-in lemmas pushing or pulling scalars around maps?</p>",
        "id": 246130797,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626371268
    },
    {
        "content": "<p>In this case, it turns out to be true definitionally:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">):</span> <span class=\"bp\">-</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 246131549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1626371609
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.neg_def\">docs#pi.neg_def</a></p>",
        "id": 246134607,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626373008
    },
    {
        "content": "<p>Hmm. We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.add_def\">docs#pi.add_def</a></p>",
        "id": 246134669,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626373041
    },
    {
        "content": "<p>Want to PR that missing lemma?</p>",
        "id": 246134694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626373055
    },
    {
        "content": "<p>Yes! (but perhaps not by me :) )</p>",
        "id": 246134890,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626373144
    },
    {
        "content": "<p>Let me know when things are PRed :)</p>",
        "id": 246135112,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626373244
    },
    {
        "content": "<p>I'm guessing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.sub_def\">docs#pi.sub_def</a> is also missing</p>",
        "id": 246135690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626373487
    },
    {
        "content": "<p>Weird</p>",
        "id": 246135708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626373494
    },
    {
        "content": "<p>I haven't checked -- would <code>@[simps]</code> be able to add these definition lemmas? I'm partly not sure if it would work at all, and partly not sure how it interacts with <code>to_additive</code>.</p>",
        "id": 246137085,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1626374171
    },
    {
        "content": "<p>Yes, but it would mark them simp which might not be helpful</p>",
        "id": 246138082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626374656
    },
    {
        "content": "<p>How should I prove </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">a.pred</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 246433607,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626686988
    },
    {
        "content": "<p>Some sort of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.pred_eq_sub_one\">docs#nat.pred_eq_sub_one</a> followed by <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_cast\">tactic#norm_cast</a>?</p>",
        "id": 246433696,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1626687031
    },
    {
        "content": "<p>(Note that this is only true for <code>0 &lt; a</code>)</p>",
        "id": 246433704,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1626687041
    },
    {
        "content": "<p><code>0.pred = 0</code></p>",
        "id": 246433727,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1626687057
    },
    {
        "content": "<p>In fact, there is just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.cast_pred\">docs#nat.cast_pred</a></p>",
        "id": 246433780,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1626687092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"408694\">@Alex Zhang</span> you really want to move away from <code>nat.pred</code> and <code>nat.sub</code>. They are very poorly behaved functions mathematically, and you can always rewrite in terms of addition.</p>",
        "id": 246433783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626687095
    },
    {
        "content": "<p>Just like we don't use &gt; and &gt;= because we can rewrite in terms of &lt; and &lt;=.</p>",
        "id": 246433805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626687116
    },
    {
        "content": "<p>I guess they are not provable actually as Eric pointed out.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat.pred</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 246434199,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626687394
    },
    {
        "content": "<p>Right, but the corresponding addition versions are true and provable.</p>",
        "id": 246434230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626687426
    },
    {
        "content": "<p>I unfortunately encountered <code>pred</code> as I used <code>finset.card_erase_of_mem</code></p>",
        "id": 246434650,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626687726
    },
    {
        "content": "<p>But in that situation you can prove that you're not taking pred of 0</p>",
        "id": 246434674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626687750
    },
    {
        "content": "<p>there are other card_erase lemmas that don't use pred I think</p>",
        "id": 246434691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626687759
    },
    {
        "content": "<p>looks like most users just use something along the lines of <code>rw [finset.card_erase_of_mem, nat.pred_succ]</code></p>",
        "id": 246434845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626687875
    },
    {
        "content": "<p>I am just rewriting </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finset.card_erase_of_mem'</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">finset.erase</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">finset.card</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 246434884,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626687912
    },
    {
        "content": "<p>This is a better lemma because it's a stronger statement.</p>",
        "id": 246434918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626687952
    },
    {
        "content": "<p>It's not a good rewrite lemma though</p>",
        "id": 246434973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626687965
    },
    {
        "content": "<p>what's the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> here? How did you get here</p>",
        "id": 246434978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626687970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/examples/near/246434973\">said</a>:</p>\n<blockquote>\n<p>It's not a good rewrite lemma though</p>\n</blockquote>\n<p>perhaps change the direction?</p>",
        "id": 246435403,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626688272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/examples/near/246434978\">said</a>:</p>\n<blockquote>\n<p>what's the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> here? How did you get here</p>\n</blockquote>\n<p>I am proving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">fn</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eg</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">I</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fn</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_ite</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.filter_ne'</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.card_erase_of_mem</span><span class=\"o\">],</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 246435423,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626688291
    },
    {
        "content": "<p>you have a <code>-</code> in the theorem statement</p>",
        "id": 246435531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626688348
    },
    {
        "content": "<p>how about writing it as <code>(∑ (i : I), fn i j) + 1 = fintype.card I</code> instead</p>",
        "id": 246435632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626688404
    },
    {
        "content": "<p>It will not be super helpful</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">eg</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fn</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_ite</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.filter_ne'</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.card_erase_of_mem</span><span class=\"o\">],</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I have got around this by writing an \"add\" version for <code>finset.card_erase_of_mem</code>, which is easy.</p>",
        "id": 246436079,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1626688692
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 247183017,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627293562
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">nat.le_of_dvd</span> <span class=\"n\">dec_trivial</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">interval_cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">revert</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">revert</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 247183477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627293881
    },
    {
        "content": "<p>Even better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">nat.le_of_dvd</span> <span class=\"n\">dec_trivial</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">interval_cases</span> <span class=\"n\">a</span><span class=\"bp\">;</span>\n  <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 247183543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627293960
    },
    {
        "content": "<p>Many thanks, Kevin!</p>",
        "id": 247183608,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627293983
    },
    {
        "content": "<p>I didn't know <code>interval_cases</code> before</p>",
        "id": 247183702,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627294067
    },
    {
        "content": "<p>How can I prove that the <code>card</code> of a field is <code>&gt;= 1</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.gptf</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.card</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">card</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 247229567,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627318249
    },
    {
        "content": "<p>I got it! <code>example : 1 ≤ card F := fintype.card_pos_iff.mpr ⟨1⟩</code></p>",
        "id": 247229837,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627318383
    },
    {
        "content": "<p>Is there a way to improve <code>tauto!</code> a little bit such that it can close goals like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>or is there any other tactic(s) that are able to close this goal?<br>\nI noticed <code>tauto {closer := tac}</code> in <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#tautology\">https://leanprover-community.github.io/mathlib_docs/tactics.html#tautology</a>. But not sure how to use this feature.</p>",
        "id": 248492385,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1628176770
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">;</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I am a bit surprised that <code>tauto!</code> doesn't close this.</p>",
        "id": 248493112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628177077
    },
    {
        "content": "<p>Oh, I guess <code>tauto</code> just does plain logic, and this proof needs transitivity of =.</p>",
        "id": 248493282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628177151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/examples/near/248493282\">said</a>:</p>\n<blockquote>\n<p>Oh, I guess <code>tauto</code> just does plain logic, and this proof needs transitivity of =.</p>\n</blockquote>\n<p>Exactly!</p>",
        "id": 248493352,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1628177167
    },
    {
        "content": "<p>It seems that <code>tauto {closer := tac}</code> is able to improve it, but not quite sure about this.</p>",
        "id": 248493401,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1628177196
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tidytauto</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">tidy</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"bp\">!</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">tidytauto</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 248493554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628177278
    },
    {
        "content": "<p>I didn't know this trick for combining tactics.</p>",
        "id": 248493908,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1628177429
    },
    {
        "content": "<p>it makes for unreadable code so it's not really used much in practice.</p>",
        "id": 248494159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628177529
    },
    {
        "content": "<p>How can I make this a local or private definition?</p>",
        "id": 248494759,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1628177820
    },
    {
        "content": "<p>and why isn't <code>meta def tidytauto := </code>[ tauto!, tidy]` able to close the goal?</p>",
        "id": 248495201,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1628178006
    },
    {
        "content": "<p>because <code>tauto!</code> fails (rather than succeeding and leaving two goals) and <code>tidy</code> would only work on one goal.</p>",
        "id": 248495385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628178094
    },
    {
        "content": "<p>The answer to your question is simply that <code>tauto!, tidy</code> does not close the goal. You can see the errors yourself.</p>",
        "id": 248495499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628178135
    },
    {
        "content": "<p>Because <code>tauto!</code> is a finishing tactic, so doesn't <code>tidy</code> actually do anything in <code>tauto!, tidy</code>?</p>",
        "id": 248496091,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1628178402
    },
    {
        "content": "<p>I always thought such things like <code>tidytauto</code> should be in the <code>tactic.interactive</code> namespace. Why isn't it the case? It seems all my rudimentary knowledge about tactics is wrong :)</p>",
        "id": 248510929,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1628185396
    },
    {
        "content": "<p>How can I prove that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">fintype.card</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 250296659,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1629671843
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.card_eq_one_iff\">docs#fintype.card_eq_one_iff</a></p>",
        "id": 250296807,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1629672016
    },
    {
        "content": "<p>actually, <code>simp</code> does it - did you even try that?</p>",
        "id": 250296822,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1629672052
    },
    {
        "content": "<p>I don't think <code>simp</code> itself will do. I tried <code>simp</code>.</p>",
        "id": 250297082,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1629672460
    },
    {
        "content": "<p><code>simp [fintype.card_eq_one_iff]</code> closes the goal!</p>",
        "id": 250297123,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1629672490
    },
    {
        "content": "<p>Simp works on my local machine. Are uou on the latest mathlib?</p>",
        "id": 250297998,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1629673936
    },
    {
        "content": "<p>No. Thanks for letting me know this! :)</p>",
        "id": 250298199,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1629674301
    },
    {
        "content": "<p>Is \"<code>b⁻¹ *_</code> is an equivalence for nonzero <code> b </code> in a field \" established in mathib?</p>",
        "id": 250477462,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1629808447
    },
    {
        "content": "<p>I don't think so, but here's a quick bit of code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">units.mul_equiv</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">≃</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">group_with_zero.nonzero_mul_equiv</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group_with_zero</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">units.mk0</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_equiv</span>\n</code></pre></div>",
        "id": 250478187,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1629808821
    },
    {
        "content": "<p>In particular, these are linear equivs if you have an algebra structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">units.mul_lequiv</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span> <span class=\"n\">u.mul_equiv</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">algebra.lmul</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">u</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">group_with_zero.nonzero_mul_lequiv</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">units.mk0</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_lequiv</span>\n</code></pre></div>",
        "id": 250478823,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1629809111
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.mul_left\">docs#equiv.mul_left</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.mul_left'\">docs#equiv.mul_left'</a>?</p>",
        "id": 250490807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629814435
    },
    {
        "content": "<p>That's weird, I tried various permutations of <code>library_search</code> and <code>grep equiv.l?mul</code> but couldn't find these.</p>",
        "id": 250491364,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1629814670
    },
    {
        "content": "<p>And even <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_iso.mul_left\">docs#order_iso.mul_left</a></p>",
        "id": 250495005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629816144
    },
    {
        "content": "<p>I don't know if we have the add_equiv version for division rings</p>",
        "id": 250495688,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629816417
    }
]
[
    {
        "content": "<p>Hi, trying to define some custom well-founded order for use in recursive definitions, failing, and simplifying until I get a reasonably simple case where things still fail and I don't get why:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">toto</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">shorter</span> <span class=\"o\">:</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">shorter</span> <span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">z</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">shorter_wf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"o\">(</span><span class=\"n\">shorter</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">well_founded</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n        <span class=\"n\">induction</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">ys</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">xs_ih</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_well_founded</span> <span class=\"o\">(</span><span class=\"n\">toto</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">shorter</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">shorter_wf</span> <span class=\"n\">V</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fold</span> <span class=\"o\">:</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"o\">[]</span><span class=\"bp\">⟩</span>    <span class=\"o\">:=</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">shorter</span> <span class=\"n\">V</span> <span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">shorter</span><span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n        <span class=\"n\">fold</span> <span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>Lean tells me that it cannot show <code>shorter V {val := xs} {val := x :: xs}</code> even though I have <code>h</code> in the state which states exactly that, and lean telling me that it will try to use <code>assumption</code>. What am I missing?</p>",
        "id": 184616285,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1577917904
    },
    {
        "content": "<p>Usually the answer would be \"if <code>assumption</code> fails, try <code>convert</code> instead and it will tell you why\" but here I don't know how to try that ...</p>",
        "id": 184616338,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1577917991
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">toto</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">shorter</span> <span class=\"o\">:</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">shorter</span> <span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">z</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fold</span> <span class=\"o\">:</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"o\">[]</span><span class=\"bp\">⟩</span>    <span class=\"o\">:=</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">fold</span> <span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 184619515,
        "sender_full_name": "Joe",
        "timestamp": 1577923946
    },
    {
        "content": "<p>I think this works just fine. But I don't understand what is happening.</p>",
        "id": 184619695,
        "sender_full_name": "Joe",
        "timestamp": 1577924289
    },
    {
        "content": "<p>Yes because it is probably generating something like sizeof automatically, but that fails in my real use case ...</p>",
        "id": 184644293,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1577964186
    },
    {
        "content": "<p>Or inferring structural induction or something</p>",
        "id": 184644304,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1577964213
    },
    {
        "content": "<blockquote>\n<p>Usually the answer would be \"if <code>assumption</code> fails, try <code>convert</code> instead and it will tell you why\" but here I don't know how to try that ...</p>\n</blockquote>\n<p>I don't think this can be it, because if you prepend <code>set_option pp.all true</code> you can see that they really are the same term:</p>\n<div class=\"codehilite\"><pre><span></span>h : shorter V (@toto.mk V xs) (@toto.mk V (@list.cons.{0} V x xs))\n⊢ shorter V (@toto.mk V xs) (@toto.mk V (@list.cons.{0} V x xs))\n</pre></div>",
        "id": 184645647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577965915
    },
    {
        "content": "<p>You need the <code>using_well_founded</code> keyword. This code works.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">toto</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">shorter</span> <span class=\"o\">:</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">shorter</span> <span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">z</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">shorter_wf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"o\">(</span><span class=\"n\">shorter</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">well_founded</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n        <span class=\"n\">induction</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">ys</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">xs_ih</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_well_founded</span> <span class=\"o\">(</span><span class=\"n\">toto</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">shorter</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">shorter_wf</span> <span class=\"n\">V</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fold</span> <span class=\"o\">:</span> <span class=\"n\">toto</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"o\">[]</span><span class=\"bp\">⟩</span>    <span class=\"o\">:=</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">shorter</span> <span class=\"n\">V</span> <span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">shorter</span><span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n        <span class=\"n\">fold</span> <span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"bp\">⟩</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span> <span class=\"n\">rel_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">shorter_wf</span> <span class=\"n\">V</span><span class=\"bp\">⟩</span><span class=\"o\">],</span>\n  <span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>I wrote some docs a while ago about <code>using_well_founded</code> at <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md\">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md</a></p>",
        "id": 184647223,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1577967784
    },
    {
        "content": "<p>Extended an example from article ... <a href=\"https://ahelwer.ca/post/2020-04-05-lean-assignment/\">https://ahelwer.ca/post/2020-04-05-lean-assignment/</a></p>\n<p>receiving the error(s) in rows 45 and 71 see attached.</p>\n<p><a href=\"/user_uploads/3121/1wEQk9VWder3PmZz_xg7mvmO/love02_definitions_and_statements_examples.lean\">love02_definitions_and_statements_examples.lean</a> </p>\n<p>Still fairly new to Lean...Appreciate any help. -K</p>",
        "id": 257792150,
        "sender_full_name": "Kieran Beltran",
        "timestamp": 1634350381
    },
    {
        "content": "<p>Some fixes to convince Lean they're well-defined:</p>\n<p>Line 45</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum_of_first_n_even_nat</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">sum_of_first_n_even_nat</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Line 71</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum_of_first_n_odd_nat</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(((</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">sum_of_first_n_odd_nat</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>The proofs in the file still hold without any further modification.</p>",
        "id": 257793897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1634352157
    },
    {
        "content": "<p>I'm guessing Lean's not certain that <code>n-1</code> in the original definition is actually less than <code>n</code> (since <code>0-1 = 0</code>).  I'm not sure what's changed since April 2020 that made it stop working.</p>",
        "id": 257794009,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1634352297
    },
    {
        "content": "<p>Thank-you Kyle. I guess in this simple example shows, having the recursion step defined (pattern matching on naturals) so as to ensure the recursion index doesn't result in f(0-1) = f(0) makes good sense. When I write it out by hand it appears simpler also. -K</p>",
        "id": 257818425,
        "sender_full_name": "Kieran Beltran",
        "timestamp": 1634377517
    }
]
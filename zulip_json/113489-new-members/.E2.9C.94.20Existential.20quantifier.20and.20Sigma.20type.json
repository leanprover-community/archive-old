[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> has marked this topic as resolved.</p>",
        "id": 264694748,
        "sender_full_name": "Notification Bot",
        "timestamp": 1639395945
    },
    {
        "content": "<p>TPIL chapter 7.3.<br>\n<a href=\"/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png\">image.png</a> <br>\nThis inaccuracy (<code>{α : Type*}</code> instead of <code>{α : Sort*}</code> or <code>{α : Sort u}</code>) is intentional, right?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png\"></a></div>",
        "id": 268436402,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531032
    },
    {
        "content": "<p>Actually, is there any good use case for an existential quantifier with <code>{α : Prop}</code> as the type of the quantified object?<br>\n\"There is a proof of proposition P such that (...)\"</p>",
        "id": 268437316,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531445
    },
    {
        "content": "<p>We cannot extract any information from inside the proof, right?</p>",
        "id": 268437671,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531641
    },
    {
        "content": "<p>So, would it restrict us in anything if the existential quantifier were defined really for <code>{α : Type*}</code> as TPIL says?</p>",
        "id": 268437804,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531691
    },
    {
        "content": "<p>Yes, it is sometimes useful, if you need to pass the proof of P to a function that appears in the second part (e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nth_le\">docs#list.nth_le</a>)</p>",
        "id": 268437850,
        "sender_full_name": "Reid Barton",
        "timestamp": 1642531713
    },
    {
        "content": "<p>It also automatically shows up with \"collection binders\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>That's short for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 268437892,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642531739
    },
    {
        "content": "<p>Note that <code>∃ (p : P), Q</code> is equivalent to <code>P ∧ Q</code>.</p>",
        "id": 268438451,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642531975
    },
    {
        "content": "<p>Right, so <code>∃</code> on a proposition is a kind of \"dependent AND\".</p>",
        "id": 268440517,
        "sender_full_name": "Reid Barton",
        "timestamp": 1642532881
    },
    {
        "content": "<p>Why cannot the code above be translated simply to ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/\\</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 268440752,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642532978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440517\">said</a>:</p>\n<blockquote>\n<p>Right, so <code>∃</code> on a proposition is a kind of \"dependent AND\".</p>\n</blockquote>\n<p>Every existential quantification is afaik a dependent sum type which is a generalization of the product type. Curry-Howard correspondence says that the product type models AND so yes.</p>",
        "id": 268441153,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642533156
    },
    {
        "content": "<p>Probably easier to understand it is when you replace \"dependent sum type\" by \"dependent tuple\" and \"product type\" by \"tuple\".</p>",
        "id": 268441238,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642533210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440517\">said</a>:</p>\n<blockquote>\n<p>Right, so <code>∃</code> on a proposition is a kind of \"dependent AND\".</p>\n</blockquote>\n<p>TLDR: <code>∃</code> on anything is a dependent tuple; AND is a tuple. You are right.</p>",
        "id": 268441815,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642533474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440752\">said</a>:</p>\n<blockquote>\n<p>Why cannot the code above be translated simply to ?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/\\</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Except for the fact it should be <code>x ∈ s</code> rather than <code>s x</code> since it's a <code>set</code>, it <em>could</em> be translated to that (and in fact, once you <code>simp</code> it the inner exists becomes a conjunction), but from the Lean parser's point of view, it's simpler to do it the first way.</p>\n<p>This does not explain <em>why</em> <code>Exists</code> is the way it is. I looked into the history, and the collection binders feature was added July 2016 by Leo (who called them \"cute binders\" in the commit message). Even after this feature was introduced, the definition of <code>Exists</code> was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exists</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Exists</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>(<a href=\"https://github.com/leanprover-community/lean/blob/f461b53a7fa7477c367edddb386252b261c2014e/library/init/logic.lean#L530\">link</a>)</p>\n<p>It wouldn't be until Sep 2016 that <code>Exists</code> got universe variables</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exists</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Exists</span>\n</code></pre></div>\n<p>(<a href=\"https://github.com/leanprover-community/lean/blob/5e8f2add8439226027cc9df186f3f7442f038e05/library/init/logic.lean#L574\">link</a>)</p>\n<p>I believe this is back when <code>Type 0</code> was <code>Prop</code>. Perhaps this explains the inaccuracy in TPIL?</p>",
        "id": 268451472,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642537922
    },
    {
        "content": "<p>So why is there the variable <code>(H : x ∈ s)</code> if I can write it the simpler way?</p>",
        "id": 268453092,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642538814
    },
    {
        "content": "<p>Would it be still relevant if there was the existential quantifier only?</p>",
        "id": 268453360,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642538984
    },
    {
        "content": "<p>I think the intention was to have a quantifier-polymoprhic pattern. For example, <code>(∃ (x ∈ s), P x)</code> is logically equivalent to <code>(∃ x, x ∈ s ∧ P x)</code>, and <code>(∀ (x ∈ s), P x)</code> is logically equivalent to <code>(∀ x, x ∈ s → P x)</code>. So, you would need to handle them separately when implementing the pattern (and you would already have to define conjunction to use it). On the other hand, you can write the first one as <code>(∃ x, ∃ (H : x ∈ s), P x)</code> and the second one as <code>(∀ x, ∀ (H : x ∈ s), P x)</code>. So, in general, it is translated to <code>(? x, ? (H : x ∈ s), P x)</code> for some binder <code>?</code>. So, for example, Lean can translate <code>(∃! (x ∈ s), P x)</code> to <code>(∃! x, ∃! (H : x ∈ s), P x)</code> without knowing anything about how <code>∃!</code> is implemented.</p>",
        "id": 268456493,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642540419
    },
    {
        "content": "<p>I don't know whether this works for any binder, though.</p>",
        "id": 268456518,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642540430
    },
    {
        "content": "<p>it doesn't really work for <code>∃!</code> (in the sense that this isn't what multiple <code>∃!</code> is supposed to mean usually)</p>",
        "id": 268457083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642540717
    },
    {
        "content": "<p>but the desugaring does work in this way uniformly for any binder, and surprisingly often it gets the mathematically right answer</p>",
        "id": 268457179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642540764
    },
    {
        "content": "<p>Actually, <code>∃! (x ∈ s), P x</code> does basically work because <code>∃! (H : p), q</code> is also equivalent to <code>p /\\ q</code>, but <code>∃! x y : A, P x y</code> does not work as one would expect</p>",
        "id": 268457690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642540988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268457083\">said</a>:</p>\n<blockquote>\n<p>it doesn't really work for <code>∃!</code> (in the sense that this isn't what multiple <code>∃!</code> is supposed to mean usually)</p>\n</blockquote>\n<p>Wait. Was multiple <code>∃!</code> actually supposed to mean _anything_?</p>",
        "id": 268458848,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642541579
    },
    {
        "content": "<p>If you say \"there exists a unique x, y such that P(x,y)\" in mathematics it usually means what you would write as <code>∃! p : A × A, P p.1 p.2</code> in lean</p>",
        "id": 268460688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642542565
    },
    {
        "content": "<p>\"there exists a unique x such that there exists a unique y such that P(x, y)\" is a very weird thing that I don't think ever comes up</p>",
        "id": 268460798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642542612
    },
    {
        "content": "<p>This is an accurate depiction of me today:<br>\n<a href=\"/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png\">I_fear_no_quantifier.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png\" title=\"I_fear_no_quantifier.png\"><img src=\"/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png\"></a></div>",
        "id": 268461142,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642542810
    },
    {
        "content": "<p>ORIGINAL IMAGE:<br>\nTeam Fortress 2 [teamfortress]. (2012, June 27). Meet the Pyro [Digital image / screen capture]. YouTube. Retrieved January 18, 2022, from <a href=\"https://ahseeit.com/?qa=16537/i-fear-no-man-meme\">https://ahseeit.com/?qa=16537/i-fear-no-man-meme</a></p>",
        "id": 268463043,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642543705
    },
    {
        "content": "<p>I've never seen a meme come with a citation before <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 268467114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642546009
    },
    {
        "content": "<p>Clear difference between discord and zulip.</p>",
        "id": 268467248,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642546107
    },
    {
        "content": "<p>Indeed, <code>(∃! (x y : α), P x y)</code> is not the same thing as <code>(∃! (xy : α × α), P xy.fst xy.snd)</code>. Can you actually construct a counterexample where they differ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">generalize</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">∨</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"n\">exists_unique</span><span class=\"o\">,</span> <span class=\"n\">push_neg</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hp</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">rcases</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">),</span> <span class=\"n\">cases</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">}},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 268472332,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642549035
    },
    {
        "content": "<p>Metamath has a fascinating series of theorems about this, see <a href=\"http://us.metamath.org/mpeuni/mmtheorems26.html#2eu1\">2eu1</a> and other theorems around it</p>",
        "id": 268472762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642549409
    },
    {
        "content": "<p>The only way I know to reliably write n-ary existential uniqueness without product types is</p>\n<p><code>∃ x1 ... xn, ∀ y1 ... yn, P y1 ... yn &lt;-&gt; x1 = y1 /\\ ... /\\ xn = yn</code></p>",
        "id": 268473072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642549669
    },
    {
        "content": "<p>which does not lend itself well to a compositional formulation</p>",
        "id": 268473153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642549707
    },
    {
        "content": "<p>Reminds me of Euler's 36 officer problem (aka orthogonal Latin squares) whose quantum version is recently in the news is basically about finding 4-ary predicate P on <code>fin 6</code> such that <br>\n<code>P x1 x2 x3 x4 /\\ P y1 y2 y3 y4 /\\ x1 = y1 /\\ x2 = y2 -&gt; x3 = y3 /\\ x4 = y4</code> for all <code>xi, yi</code> and the same for all permutations of 1,2,3,4. Wondering whether an impossibility proof has been formalized (not sure about the least amount of computation required among proofs now known).<br>\n(edit: this isn't quite right, needs some condition to ensure there are at least 36 elements that evaluates to true.)</p>",
        "id": 268474834,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642550859
    },
    {
        "content": "<p>golfed Patrick Johnson's example using <code>bor</code>, and provided a proof that the latter always implies the former, intuitionistically:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">||</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">⟩,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">hx</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span><span class=\"o\">}⟩)</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span><span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span><span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">xy</span><span class=\"o\">,</span><span class=\"n\">he</span><span class=\"o\">,</span><span class=\"n\">hu</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">xy.fst</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">xy.snd</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">(</span><span class=\"n\">xy.fst</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)⟩,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hy</span><span class=\"o\">⟩,</span> <span class=\"n\">congr_arg</span> <span class=\"n\">prod.fst</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">hy.1</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n</div></div>\n<p>Observations: if <code>bool</code> is replaced by <code>Prop</code>, the example won't work without excluded middle.<br>\nIf <code>example</code> is replaced by <code>lemma</code>, then it seems the statement become universe polymorphic, and one would have to write <code>{α : Type}</code>.</p>",
        "id": 268482750,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642557328
    },
    {
        "content": "<p>I would guess that you can still prove the example over <code>Prop</code> without excluded middle</p>",
        "id": 268482866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642557444
    },
    {
        "content": "<p>Hmm, I think you're right.</p>",
        "id": 268483560,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642558095
    },
    {
        "content": "<p>Now this only depends on propext:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">eq_true</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">or</span> <span class=\"o\">⟨</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"n\">trivial</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y.elim</span> <span class=\"n\">false.elim</span> <span class=\"n\">eq_true_intro</span><span class=\"o\">⟩,</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">heu</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">eq_false.symm</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">heu</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hy</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hy</span><span class=\"o\">))</span> <span class=\"n\">hy</span><span class=\"o\">)⟩)</span>\n    <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">trivial</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">trivial</span><span class=\"o\">)))</span>\n</code></pre></div>\n</div></div>",
        "id": 268485571,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642560333
    },
    {
        "content": "<p>It was tricky to find a proof not using propext, but it's possible:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">×</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hy.2</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hy.1.1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"k\">have</span> <span class=\"n\">H'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hy.2</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">hq</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">true_ne_false</span> <span class=\"o\">((</span><span class=\"n\">H'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">H'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">P</span> <span class=\"n\">this</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"n\">ne.symm</span> <span class=\"n\">true_ne_false</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">true_ne_false</span> <span class=\"o\">(</span><span class=\"n\">prod.mk.inj</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">T</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>\n</div></div>",
        "id": 268487420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642562184
    },
    {
        "content": "<p>If you want an example in <code>Prop</code> without propext you can simply do this, which is a more direct translation of the <code>bor</code> example:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">true_ne_false</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">))</span>\n    <span class=\"o\">⟨</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hu.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">true_ne_false</span> <span class=\"n\">he.symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span> <span class=\"n\">and.right</span><span class=\"o\">⟩,</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">heu</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hs</span><span class=\"o\">,</span><span class=\"n\">hu</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">heu</span> <span class=\"k\">in</span>\n        <span class=\"n\">hs.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">heu</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">ht</span><span class=\"o\">))</span> <span class=\"n\">and.left</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)))</span>\n</code></pre></div>\n</div></div>\n<p>My last example translating <code>bor</code> to <code>or</code> is the most direct translation IMO, and I'm glad it works intuitionistically, thanks to your hint.</p>",
        "id": 268492188,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642567978
    },
    {
        "content": "<p>With propext, I've been able to show or, implication, and reverse implication are all binary predicates on Prop that serve as counterexamples: <a href=\"https://gist.github.com/alreadydone/0d8c00290751e1d20c6eefeb6040430e\">https://gist.github.com/alreadydone/0d8c00290751e1d20c6eefeb6040430e</a><br>\nHowever, it seems NAND can't be shown to be a counterexample intuitionistically: not(x and y) is equivalent to y-&gt;not x, which is true when y=not x and when y=false. If there is a unique y such that y-&gt;not x, then false=not x, which is equivalent to not(not x), which doesn't imply x=true intuitionistically.<br>\nSince Prop with propext is a Heyting algebra (and maybe every Heyting algebra can serve as a model for intuitionistic Prop), this is a problem about whether a binary operation P satisfies ∃! (x y : α), P x y = ⊤ for all Heyting algebra α, where P is defined in terms of the operations of Heyting algebras (join, meet, implication, top, bot) so it makes sense for any Heyting algebra. And it would be a fun problem to classify all operations satisfying <code>eu_eu_and_not_eu_prod</code>. I don't know if anything changes if <code>(∃! (x y : α), P x y) ∧ ¬(∃! (xy : α × α), P xy.fst xy.snd)</code> is changed to <code>¬((∃! (x y : α), P x y) → (∃! (xy : α × α), P xy.fst xy.snd))</code>; the former implies the latter but not vice versa.</p>",
        "id": 269941042,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643559062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/269941042\">said</a>:</p>\n<blockquote>\n<p>maybe every Heyting algebra can serve as a model for intuitionistic Prop</p>\n</blockquote>\n<p>That was precisely Heyting's motivation!</p>",
        "id": 269944923,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643563728
    }
]
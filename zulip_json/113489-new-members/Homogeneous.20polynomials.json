[
    {
        "content": "<p>I'm trying to prove something about polynomials and their Waring Rank: The waring rank is the least number of summands such that a polynomial can be written as some of homogeneous linear forms raised to some power.</p>\n<p>3 questions about the example below:</p>\n<ol>\n<li>Are the definitions reasonable? Anything I could rewrite to make life easier, especially given the questions below?</li>\n<li>the \"have factoid\" line has a type error, and I guess it's because I need to somehow promote to an element of the homogeneous ideal. I can't really find a way to construct a homogeneous polynomial from the start.</li>\n<li>How would I set up the use statement? I imagine I need to feed in all the conditions, but I wouldn't know where to start on that. </li>\n</ol>\n<p>Thanks in advance:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.polynomial.homogeneous</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">is_waring_decomposition</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">mv_polynomial.homogeneous_submodule</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">i.2</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">i.1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p</span>\n\n<span class=\"c1\">-- Is this an okay formulation?</span>\n<span class=\"kd\">def</span> <span class=\"n\">waring_rank</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">Inf</span> <span class=\"o\">({</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">mv_polynomial.homogeneous_submodule</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">is_waring_decomposition</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">sizeof</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∈</span>  <span class=\"n\">mv_polynomial.homogeneous_submodule</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">le_equiv</span> <span class=\"o\">:</span> <span class=\"n\">waring_rank</span> <span class=\"n\">p</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">waring_rank</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">valid_rank_one</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">mv_polynomial.homogeneous_submodule</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"mi\">1</span><span class=\"o\">))),</span> <span class=\"n\">is_waring_decomposition</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">sizeof</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">},</span>\n      <span class=\"o\">{</span>\n        <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">h_lin_form</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial.monomial</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"n\">mv_polynomial.monomial</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"bp\">∈</span> <span class=\"n\">mv_polynomial.homogeneous_submodule</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span>\n          <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n        <span class=\"o\">},</span>\n        <span class=\"k\">have</span> <span class=\"n\">factoid</span><span class=\"o\">:</span>  <span class=\"n\">is_waring_decomposition</span> <span class=\"n\">p</span> <span class=\"o\">{(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial.monomial</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"n\">mv_polynomial.monomial</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">β</span><span class=\"o\">))},</span>\n        <span class=\"o\">{</span>\n             <span class=\"c1\">-- how to promote to element of homogeneous submodule,</span>\n        <span class=\"o\">},</span>\n        <span class=\"c1\">-- how to do this use</span>\n        <span class=\"c1\">-- use ({(2, (mv_polynomial.monomial (finsupp.single 0 1) α + mv_polynomial.monomial (finsupp.single 1 1) β))} : finset (ℕ × ↥(mv_polynomial.homogeneous_submodule (fin 2) ℂ 1))),</span>\n        <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"n\">exact</span> <span class=\"n\">cInf_le</span> <span class=\"n\">valid_rank_one</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 292337081,
        "sender_full_name": "Pim Otte",
        "timestamp": 1659902714
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span> The assumption <code>p ∈ ...</code> in your <code>test</code> lemma doesn't generate the assumptions that you would expect. That's because in type theory you need to write <code>p : ...</code>. Does that help getting you unstuck?</p>",
        "id": 292359100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1659932231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519269\">@Pim Otte</span>  Here are some simplifications and comments about the code, including an answer to question 2. Turns out the <code>p ∈ </code> is unproblematic. I don't understand what \"the statement\" means in question 3 though.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.polynomial.homogeneous</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">mv_polynomial</span> <span class=\"c\">/-</span><span class=\"cm\"> so that you can remove the `mv_polynomial.` prefixes. -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_waring_decomposition</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">homogeneous_submodule</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">i.2</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">i.1</span> <span class=\"bp\">=</span> <span class=\"n\">p</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The formulation looks reasonable, but if you care about the case of infinite Waring rank, you</span>\n<span class=\"cm\">  may consider using `with_top ℕ`. Otherwise `Inf` returns a junk value when it's infinite. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">waring_rank</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">is_waring_decomposition</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">homogeneous_submodule</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">le_equiv</span> <span class=\"o\">:</span> <span class=\"n\">waring_rank</span> <span class=\"n\">p</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat.Inf_le</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> automatically give you `valid_rank_one` -/</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">h_lin_form</span> <span class=\"o\">:</span>\n        <span class=\"n\">monomial</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"n\">monomial</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">β</span>\n        <span class=\"bp\">∈</span> <span class=\"n\">homogeneous_submodule</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> Only need type annotation ( : fin 2) at one place.</span>\n<span class=\"cm\">        Usually written:</span>\n<span class=\"cm\">        have h_lin_form : C α * X (0 : fin 2) + C β + X 1 ∈ homogeneous_submodule (fin 2) ℂ 1, -/</span>\n\n      <span class=\"k\">have</span> <span class=\"n\">factoid</span> <span class=\"o\">:</span> <span class=\"n\">is_waring_decomposition</span> <span class=\"n\">p</span> <span class=\"o\">{(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">C</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩)},</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> `homogeneous_submodule σ R 1` in `finset (ℕ × homogeneous_submodule σ R 1)` is</span>\n<span class=\"cm\">        coerced from a submodule to a (sub)type, and a term of a subtype consists of a term `q`</span>\n<span class=\"cm\">        of the ambient type (here `mv_polynomial σ R`) and a proof `h` that it lies in the subtype</span>\n<span class=\"cm\">        (i.e. `q ∈ homogeneous_submodule σ R 1`), and can be written as `⟨q, h⟩`. In the above</span>\n<span class=\"cm\">        I write an underscore _ for `h`, so that Lean creates a goal for you to fill in. -/</span>\n      <span class=\"n\">swap</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> The following proves that</span>\n<span class=\"cm\">          `C α * X (0 : fin 2) + C β * X 1 ∈ homogeneous_submodule (fin 2) R 1`;</span>\n<span class=\"cm\">          note that `∈ homogeneous_submodule` is defined to mean `is_homogeneous`, see</span>\n<span class=\"cm\">           `mv_polynomial.mem_homogeneous_submodule`.` -/</span>\n        <span class=\"n\">apply</span> <span class=\"n\">submodule.add_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">is_homogeneous_C</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">is_homogeneous_X</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> You can also do : -/</span>\n      <span class=\"k\">have</span> <span class=\"n\">factoid'</span> <span class=\"o\">:</span> <span class=\"n\">is_waring_decomposition</span> <span class=\"n\">p</span> <span class=\"o\">{</span><span class=\"n\">_</span><span class=\"o\">},</span>\n      <span class=\"n\">swap</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">C</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">submodule.add_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">is_homogeneous_C</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">is_homogeneous_X</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 292365833,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659941148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Thanks a lot, this is very insightful! I was aware of the infinite case. It's good to know that this could be handled using with_top. In this particular case, it turns out that Waring rank is always finite, so it doesn't really matter.</p>\n<p>The final question was about the commented out use statement in my sample to fulfill the existential quantifier, but knowing how the term of the coerced type works actually solved my issues with that too.</p>",
        "id": 292377206,
        "sender_full_name": "Pim Otte",
        "timestamp": 1659949791
    }
]
[
    {
        "content": "<p>Hi, I'm trying to refactor the <code>quiver</code> code a bit and got into some instance troubles.<br>\n<a href=\"https://github.com/bottine/mathlib/blob/3263f73f5f6d243f38f8bf64ce886739d23bd6ad/src/combinatorics/quiver/connected_component.lean#L57\">here</a>, lean doesn't find the necessary <code>quiver</code> instance on <code>V</code>, even though I have an instance as a variable.<br>\nI'm pretty sure it's related to universe incompatibilities, but can't really figure out where they come from.<br>\nI can't really get a MWE out of that: what kind of approach should I take to debug this?</p>",
        "id": 304201094,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665840546
    },
    {
        "content": "<p>Try <code>set_option pp.universes true</code></p>",
        "id": 304201966,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665841038
    },
    {
        "content": "<p>OK, I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">wide_subquiver.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">symmetrify.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"bp\">?</span><span class=\"n\">l_2</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">V</span>\n</code></pre></div>\n<p>which I guess is related to the transition to <code>psum</code>, maybe?</p>",
        "id": 304202191,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665841149
    },
    {
        "content": "<p>Yeah, very possible...</p>",
        "id": 304202286,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665841198
    },
    {
        "content": "<p>Alright… I'm a bit clueless as to how to fix that so I might leave that aside for a while. Thanks!</p>",
        "id": 304203103,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665841527
    },
    {
        "content": "<p>This feels like a <code>Type</code> vs <code>Sort</code> issue</p>",
        "id": 304203480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665841744
    },
    {
        "content": "<p>Indeed, but no idea what's the cause</p>",
        "id": 304204534,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842341
    },
    {
        "content": "<p>Do things become more obvious if you use <code>[quiver.{v} V]</code> for a new universe <code>v</code>?</p>",
        "id": 304205025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665842555
    },
    {
        "content": "<p>I would guess that <code>quiver.{v+1} V</code> solves the issue</p>",
        "id": 304205286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665842700
    },
    {
        "content": "<p>let me see</p>",
        "id": 304205357,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842726
    },
    {
        "content": "<p>lol, it does…</p>",
        "id": 304205391,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842745
    },
    {
        "content": "<p>But am I risking a kind of domino effect here where the <code>+1</code> has to be appended everytime?</p>",
        "id": 304205472,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842771
    },
    {
        "content": "<p>I expect the real solution is to change a <code>Type</code> to a <code>Sort</code> somewhere</p>",
        "id": 304206009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843045
    },
    {
        "content": "<p>One of the thing I did was change <code>symmetrify</code> from being defined as  <code>sum (x --&gt; y) (y --&gt; X)</code> to <code>psum …</code>, so that I can symmetrify a <code>Prop</code>ositional quiver. This could mean that this is simply incompatible with doing things cleanly?</p>",
        "id": 304206492,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843286
    },
    {
        "content": "<p>Does <code>V : Sort*</code> work?</p>",
        "id": 304206957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843558
    },
    {
        "content": "<p>quivers take <code>V : Type*</code>, so doing that would imply redefining quivers themselves, no?</p>",
        "id": 304207352,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843763
    },
    {
        "content": "<p>I'm trying, but it's not entirely mechanical afaict</p>",
        "id": 304207377,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843777
    },
    {
        "content": "<p>(and redefining quivers would redefine categories I guess… which looks quite dangerous to me)</p>",
        "id": 304207467,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843821
    },
    {
        "content": "<p>Do they? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver\">docs#quiver</a></p>",
        "id": 304207469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843823
    },
    {
        "content": "<p>Yes, there's a difference between the index type and the return type of the homs.</p>",
        "id": 304207556,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665843849
    },
    {
        "content": "<p>Yes. Then my <code>Sort</code> suggestion is a bad idea!</p>",
        "id": 304207574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843857
    },
    {
        "content": "<p>(haha I'm relieved I don't have to go there :) )</p>",
        "id": 304207642,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843898
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib_docs/find/wide_subquiver\">docs#wide_subquiver</a> is the issue?</p>",
        "id": 304207869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665844016
    },
    {
        "content": "<p>Mmh, that would make sense, and then I'd only have to \"up\" the level there, but I actually get other errors somewhere else also related to bad universes.</p>\n<p>To be more precise: now it's <code>category_theory/groupoid/free_groupoid.lean</code> that complains: the abbreviations at the beginning fail already.</p>",
        "id": 304208523,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665844367
    },
    {
        "content": "<p>Doesn't <code>set</code> support <code>Prop</code> types?</p>",
        "id": 304208760,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665844493
    },
    {
        "content": "<p>Bargh, got to go, thanks for the help debugging this!</p>",
        "id": 304209357,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665844758
    },
    {
        "content": "<p>Scott Morrison once tried to generalise the category theory library so that it allowed morphisms to take values in Sort u rather than Type u and after some struggling he gave up on the idea and reverted. This feels like the same sort of thing</p>",
        "id": 304210595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665845382
    },
    {
        "content": "<p>... which is really a shame, because that would allow us to unify orders and categories.</p>",
        "id": 304210780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665845488
    },
    {
        "content": "<p>mmh, that's sad indeed</p>",
        "id": 304217797,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665849252
    },
    {
        "content": "<p>The <code>symmetrify</code> code has been ported to mathlib4, and it seems the universe problem disappears, so that one should be able to take <code>symmetrify V</code> as a <code>PSum</code> rather than a <code>Sum</code>. Is making such a change incompatible with the port having to be kind of 1-1 ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Copyright (c) 2021 David Wärn. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: David Wärn</span>\n<span class=\"cm\">Ported by: Joël Riou</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.Quiver.Subquiver</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.Quiver.Path</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sum.Basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">## Weakly connected components</span>\n\n<span class=\"cm\">For a quiver `V`, we build a quiver `Symmetrify V` by adding a reversal of every edge.</span>\n<span class=\"cm\">Informally, a path in `Symmetrify V` corresponds to a 'zigzag' in `V`. This lets us</span>\n<span class=\"cm\">define the type `WeaklyConnectedComponent V` as the quotient of `V` by the relation which</span>\n<span class=\"cm\">identifies `a` with `b` if there is a path from `a` to `b` in `Symmetrify V`. (These</span>\n<span class=\"cm\">zigzags can be seen as a proof-relevant analogue of `EqvGen`.)</span>\n\n<span class=\"cm\">Strongly connected components have not yet been defined.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Quiver</span>\n\n<span class=\"sd\">/-- A type synonym for the symmetrized quiver (with an arrow both ways for each original arrow).</span>\n<span class=\"sd\">    NB: this does not work for `Prop`-valued quivers. It requires `[Quiver.{v+1} V]`. -/</span>\n<span class=\"c1\">-- Porting note: no hasNonemptyInstnace linter yet</span>\n<span class=\"kd\">def</span> <span class=\"n\">Symmetrify</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">V</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">symmetrifyQuiver</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">↦</span> <span class=\"n\">PSum</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"n\">a</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A quiver `HasReverse` if we can reverse an arrow `p` from `a` to `b` to get an arrow</span>\n<span class=\"sd\">    `p.reverse` from `b` to `a`.-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasReverse</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- the map which sends an arrow to its reverse -/</span>\n  <span class=\"n\">reverse'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Reverse the direction of an arrow. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">reverse</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HasReverse.reverse'</span>\n\n<span class=\"sd\">/-- A quiver `HasInvolutiveReverse` if reversing twice is the identity.`-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"kd\">extends</span> <span class=\"n\">HasReverse</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `reverse` is involutive -/</span>\n  <span class=\"n\">inv'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">reverse_reverse</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">h.inv'</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasReverse</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n            <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">f</span>\n            <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span>\n    <span class=\"n\">HasInvolutiveReverse</span>\n      <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toHasReverse</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n  <span class=\"n\">inv'</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- Reverse the direction of a path. -/</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Path.reverse</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">Path</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">Path</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Path.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Path.nil</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Path.cons</span> <span class=\"n\">p</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPath.comp</span> <span class=\"n\">p.reverse</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Path.reverse_toPath</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">f.toPath.reverse</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPath</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">quiver.path.reverse_to_path</span> <span class=\"n\">Quiver.Path.reverse_toPath</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Path.reverse_comp</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"bp\">=</span> <span class=\"n\">q.reverse.comp</span> <span class=\"n\">p.reverse</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">q</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Path.reverse_reverse</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">p.reverse.reverse</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Path.reverse</span><span class=\"o\">,</span> <span class=\"n\">Path.reverse_comp</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Path.reverse_toPath</span><span class=\"o\">,</span> <span class=\"n\">Quiver.reverse_reverse</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- The inclusion of a quiver in its symmetrification -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Symmetrify.of</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">PSum.inl</span>\n\n<span class=\"sd\">/-- Given a quiver `V'` with reversible arrows, a prefunctor to `V'` can be lifted to one from</span>\n<span class=\"sd\">    `Symmetrify V` to `V'` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Symmetrify.lift</span> <span class=\"o\">{</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Prefunctor</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">V'</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">φ.obj</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">φ.map</span> <span class=\"n\">g</span>\n  <span class=\"bp\">|</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">φ.map</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Symmetrify.lift_spec</span> <span class=\"o\">(</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Symmetrify.of.comp</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fapply</span> <span class=\"n\">Prefunctor.ext</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Symmetrify.lift_reverse</span> <span class=\"o\">(</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Quiver.reverse</span> <span class=\"o\">((</span><span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Symmetrify.lift</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">f</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h.inv'</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- `lift φ` is the only prefunctor extending `φ` and preserving reverses. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Symmetrify.lift_unique</span> <span class=\"o\">(</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">Symmetrify.of.comp</span> <span class=\"bp\">Φ</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">Φ</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n      <span class=\"bp\">Φ.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Quiver.reverse</span> <span class=\"o\">(</span><span class=\"bp\">Φ.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">Φ</span> <span class=\"bp\">=</span> <span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst_vars</span>\n  <span class=\"n\">fapply</span> <span class=\"n\">Prefunctor.ext</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span>\n    <span class=\"n\">cases</span> <span class=\"n\">f</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"bp\">Φ</span><span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">quiver.symmetrify.lift_unique</span> <span class=\"n\">Quiver.Symmetrify.lift_unique</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Two vertices are related in the zigzag setoid if there is a</span>\n<span class=\"sd\">    zigzag of arrows from one to the other. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">zigzagSetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Path</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">Path.nil</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n    <span class=\"o\">⟨</span><span class=\"n\">p.reverse</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"sd\">/-- The type of weakly connected components of a directed graph. Two vertices are</span>\n<span class=\"sd\">    in the same weakly connected component if there is a zigzag of arrows from one</span>\n<span class=\"sd\">    to the other. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">WeaklyConnectedComponent</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient</span> <span class=\"o\">(</span><span class=\"n\">zigzagSetoid</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">WeaklyConnectedComponent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The weakly connected component corresponding to a vertex. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Quotient.mk'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">zigzagSetoid</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeTC</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">WeaklyConnectedComponent.mk</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">show</span> <span class=\"n\">V</span> <span class=\"k\">from</span> <span class=\"n\">default</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Path</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.eq'</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">WeaklyConnectedComponent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Without the explicit universe level in `Quiver.{v+1}` Lean comes up with</span>\n<span class=\"c1\">-- `Quiver.{max u_2 u_3 + 1}`. This causes problems elsewhere, so we write `Quiver.{v+1}`.</span>\n<span class=\"sd\">/-- A wide subquiver `H` of `Symmetrify V` determines a wide subquiver of `V`, containing an</span>\n<span class=\"sd\">    an arrow `e` if either `e` or its reversal is in `H`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">wideSubquiverSymmetrify</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">WideSubquiver</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">WideSubquiver</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Quiver</span>\n</code></pre></div>",
        "id": 315305321,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670831112
    },
    {
        "content": "<p>My instinct is that the port should be 1-1 and any refractors should be done after it's complete.</p>",
        "id": 315308404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670832386
    }
]
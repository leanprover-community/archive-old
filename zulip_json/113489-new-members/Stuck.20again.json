[
    {
        "content": "<p>Previously (e.g. with lean 3.28.0 and mathlib commit 2ad4a4ce6afc3008272627320370f74cd2020c7f) lean was happy to write goal accomplished at the end of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_pow_le_N</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"bp\">∥</span><span class=\"n\">n</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">,</span>\n    <span class=\"k\">calc</span> <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span> <span class=\"n\">n</span><span class=\"bp\">•</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>  <span class=\"o\">}</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">n</span><span class=\"bp\">•</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">+</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">norm_add_le</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">+</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_le_add_iff_right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">*∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n.succ</span><span class=\"o\">)</span><span class=\"bp\">*∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_pow_le_Z</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∥</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">int.of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"k\">calc</span> <span class=\"bp\">∥</span><span class=\"n\">n</span><span class=\"bp\">•</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">group_pow_le_N</span><span class=\"o\">,</span>  <span class=\"o\">}</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">nat.abs_cast</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥↑</span><span class=\"n\">n</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">real.norm_eq_abs</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">rfl.ge</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">}</span>\n  <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">int.neg_succ_of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span>   <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">int.neg_succ_of_nat_coe</span><span class=\"o\">,</span> <span class=\"n\">neg_smul</span><span class=\"o\">,</span> <span class=\"n\">norm_neg</span><span class=\"o\">,</span> <span class=\"n\">norm_neg</span><span class=\"o\">],</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- Is there a way to avoid repeating the argument above?</span>\n      <span class=\"k\">calc</span> <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">•</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">group_pow_le_N</span><span class=\"o\">,</span>  <span class=\"o\">}</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">norm_cast</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥↑</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">real.norm_eq_abs</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">exact</span> <span class=\"n\">rfl.ge</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"kd\">end</span>\n</code></pre></div>\n<p>It wasn't very pretty, but it worked. Now (lean 3.31.0, mathlib commit 0c024a6270e43657c28aaf9664565a85593b3865) lean objects to the final calc with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥↑</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥↑</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span>\n</code></pre></div>\n<p>I've spent hours playing around rewriting this in different ways, but I don't seem to be able to fix it. Please can someone give me a hint?</p>\n<p>It's rather disheartening to be stuck on something one thought one had already proved.</p>\n<p>Thanks,</p>\n<p>Christopher</p>",
        "id": 248781547,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1628445760
    },
    {
        "content": "<p>The casting logic got changed so it went a level deeper than before. Direct helper lemma here would be &lt;-int.coe_nat_succ. In terms of repeating the argument, you could case on whether a &lt;= -a or -a &lt;= a, wlog extract the natural that corresponds to the nonnegative element.</p>",
        "id": 248782249,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628446828
    },
    {
        "content": "<p>Put <code>exact_mod_cast</code> before the calc, for a quick and dirty solution. Your main issue, however, is that you're using non-terminal simps; the simp lemmata can change between pull to pull and so it's considered to change all simps not at the end of the proof into simp only using squeeze_simp, so this exact issue doesn't happen</p>",
        "id": 248782270,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1628446901
    },
    {
        "content": "<p>(@zulip mods: is there a link like #nng for non-terminal simps?)</p>",
        "id": 248782321,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1628446945
    },
    {
        "content": "<p>I don't think the simp is directly the issue here, because each calc step explicitly sets the goal up.</p>",
        "id": 248782324,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628446948
    },
    {
        "content": "<p>Yes, but the issue seems to be that the overall calc isn't defeq to the goal,no?</p>",
        "id": 248782341,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1628446997
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 248782343,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628447005
    },
    {
        "content": "<p>Sorry, let me rephrase. The culprit here is the explicit coercion arrow. Just because the arrow is outside the parens doesn't mean the coercion is limited to the n + 1 term. The logic changed such that the arrow automatically pushes in to the n term.</p>",
        "id": 248782399,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628447091
    },
    {
        "content": "<p>So yes, it's not defeq to the goal like you said.</p>",
        "id": 248782460,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628447175
    },
    {
        "content": "<p>Casing on the <code>of_nat</code>/<code>neg_succ_of_nat</code> constructors tends to lead to somewhat annoying proofs; one other approach is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">group_pow_le_Z</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">int.nat_abs_eq</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">neg_smul</span><span class=\"o\">,</span> <span class=\"n\">norm_neg</span><span class=\"o\">,</span> <span class=\"n\">gsmul_coe_nat</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">group_pow_le_N</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">norm</span><span class=\"o\">,</span> <span class=\"n\">int.cast_nat_abs</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 248782626,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1628447459
    },
    {
        "content": "<p>There's also int.induction_on</p>",
        "id": 248782716,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628447596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span> Are you wanting to prove these yourself, or would you be happy to use the mathlib lemmas?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">group_pow_le_N</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"bp\">∥</span><span class=\"n\">n</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">norm_nsmul_le</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">group_pow_le_Z</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"bp\">∥</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">b</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">norm_gsmul_le</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 248782722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628447604
    },
    {
        "content": "<p>(These are newer than the version of mathlib you were previously using, having been added 2 months ago.)</p>",
        "id": 248782855,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628447766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks - I'd be happy to use the mathlib lemmas. I fear my progress is so slow that mathlib will keep overtaking me!</p>",
        "id": 248782932,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1628447888
    },
    {
        "content": "<p>You can keep bumping mathlib -- this is what I usually do with a longer project.</p>",
        "id": 248784679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628450317
    }
]
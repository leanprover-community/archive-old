[
    {
        "content": "<p>I can't find this in the documentation. How would I define <code>c</code> below?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- F x says that x is king of France</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">only_one</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">definition</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"s2\">\"the x such that F x\"</span>\n</code></pre></div>",
        "id": 252510377,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1631125909
    },
    {
        "content": "<p>You can use the axiom of choice to get a witness for there-exists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- F x says that x is king of France</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">only_one</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">definition</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">only_one.some</span>  <span class=\"c1\">-- short for Exists.some only_one</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">c_property</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">only_one.some_spec</span>\n</code></pre></div>",
        "id": 252510651,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126035
    },
    {
        "content": "<p>You need to write <code>noncomputable</code> to tell Lean that it's not something it's able to actually compute -- the reason you need it is a technical non-classical-math thing you can ignore if you want.</p>",
        "id": 252510860,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126120
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>! Is there a way without Choice? (I am not against Choice but logically it shouldn't be needed here...)</p>",
        "id": 252510899,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1631126145
    },
    {
        "content": "<p>If I tell you there exists a unique King of France, how would you tell me who it is? This is the issue.</p>",
        "id": 252511000,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126181
    },
    {
        "content": "<p>This is an alternative:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- F x says that x is king of France</span>\n<span class=\"kd\">constant</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">U</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">only_one</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 252511183,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126258
    },
    {
        "content": "<p>There exists a King of France, and it's <code>c</code>.  This avoids the axiom of choice.</p>\n<p>There are also ways to deal with this by using sigma types instead of existentials.</p>",
        "id": 252511377,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126328
    },
    {
        "content": "<p>Here's the kind of example that helped me understand why choice was needed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ex1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ex1</span> <span class=\"bp\">=</span> <span class=\"n\">ex2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 252511722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126466
    },
    {
        "content": "<p>I don't know if this is a type theory thing, but in regular first-order logic we would just expand the language with a new constant... or agree that any reference to <code>c</code> is officially supposed to be an abbreviation for a more elaborate statement. For instance, <code>c</code> is bald officially means: there is one and only one king of France, and he is bald.</p>",
        "id": 252511914,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1631126552
    },
    {
        "content": "<p>Both <code>ex1</code> and <code>ex2</code> are proofs that there is a positive natural number.  For the first, I use <code>1</code>, and for the second, I use <code>2</code>.  You'd think you could just get that witness from a proof when you want to have a positive natural number.  However, in Lean all proofs of the same proposition are equal by definition (that's proof irrelevance).</p>\n<p>So, if we could extract the number from the proof, we'd get the contradictory result that <code>1 = 2</code>.</p>",
        "id": 252511973,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126583
    },
    {
        "content": "<p>There's basically no interesting way to eliminate Props into Types without choice, since the proof of a Prop doesn't contain any data (it's represented by nothing at all). If you want computable \"unique choice\", then you should use <code>trunc</code> instead of <code>Prop</code> (and <code>trunc</code>-ated sigma types instead of existentials).</p>",
        "id": 252511977,
        "sender_full_name": "David Wärn",
        "timestamp": 1631126584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"347475\">Bjørn Kjos-Hanssen</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252511914\">said</a>:</p>\n<blockquote>\n<p>I don't know if this is a type theory thing, but in regular first-order logic we would just expand the language with a new constant...</p>\n</blockquote>\n<p>This is more or less what Lean's version of the axiom of choice is.  It introduces a whole family of constants, one for every existential. (Technically, one for every nonempty type.)</p>",
        "id": 252512120,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126650
    },
    {
        "content": "<p>Yeah, I think this is a type theory thing (my understanding is that the analogous construction in ZFC would be unproblematic). It's because Prop forgets its proofs, but Type is data, so moving from Prop to Type requires magic.</p>",
        "id": 252512295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631126751
    },
    {
        "content": "<p>The Axiom:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">classical.choice</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>The <code>Exists.some</code> function uses this indirectly, but it really is effectively giving a new constant for each existential.  The name of this constant (given your first example) is <code>Exists.some only_one</code>.</p>",
        "id": 252512427,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252511977\">said</a>:</p>\n<blockquote>\n<p>There's basically no interesting way to eliminate Props into Types without choice</p>\n</blockquote>\n<p>It's all a matter of taste, but I think subsingletons are interesting.</p>",
        "id": 252512673,
        "sender_full_name": "Chris B",
        "timestamp": 1631126927
    },
    {
        "content": "<p>As Kevin says, every definition that involves a non-<code>Prop</code> type has some obligation to be computable in some way (I'm not sure if this is a type theory thing, or a CS-people-like-computing-things thing).  Using the definitions from my example, <code>Exists.some ex1</code> does not promise to be able to actually provide a natural number.</p>",
        "id": 252512681,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631126932
    },
    {
        "content": "<p>However, on a case-by-case basis you can get a bona-fide computed thing.  The natural numbers have their own version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists.some\">docs#Exists.some</a> called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find\">docs#nat.find</a>, which will give the first number satisfying the predicate.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ex2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">num</span> <span class=\"o\">:=</span> <span class=\"n\">nat.find</span> <span class=\"n\">ex2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">num</span>\n<span class=\"c1\">-- 1</span>\n</code></pre></div>\n<p>This depends on the structure of the natural numbers (induction).  In contrast, the type <code>U</code> of people in your example doesn't have any sort of structure that could be used to obtain the King.</p>",
        "id": 252513174,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631127161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252512673\">said</a>:</p>\n<blockquote>\n<p>It's all a matter of taste, but I think subsingletons are interesting.</p>\n</blockquote>\n<p>Subsingletons are interesting but the point here is that in Lean you <em>can't</em> eliminate into the from Props without choice. What you can do is eliminate <code>h : a = b</code> using <code>eq.rec</code>, which is a little more limited.</p>",
        "id": 252514030,
        "sender_full_name": "David Wärn",
        "timestamp": 1631127530
    },
    {
        "content": "<p>Basically Lean without choice makes a distinction which is absent in ZFC, roughly speaking between \"constructions\" and \"properties of constructions\". In ZFC all you do is prove things about the universe of sets,  so you are only working in the latter world. In Lean without choice you have access to both worlds, but going from the latter to the former is mostly verboten.</p>",
        "id": 252514943,
        "sender_full_name": "David Wärn",
        "timestamp": 1631127896
    },
    {
        "content": "<p>I think there's a typo in there, so I don't know exactly what you mean. My point was that subsingletons can eliminate from Prop to an arbitrary Sort without invoking choice.</p>",
        "id": 252515644,
        "sender_full_name": "Chris B",
        "timestamp": 1631128152
    },
    {
        "content": "<p>I think maybe there is some confusion between subsingleton elimination and <code>subsingleton</code>.</p>",
        "id": 252515946,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631128304
    },
    {
        "content": "<p>There's a joke about them being equal in there somewhere.</p>",
        "id": 252516461,
        "sender_full_name": "Chris B",
        "timestamp": 1631128536
    },
    {
        "content": "<p>Ah right, you can eliminate from Props that are syntactic subsingletons, but basically this is the least interesting case.</p>",
        "id": 252516482,
        "sender_full_name": "David Wärn",
        "timestamp": 1631128549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252511977\">said</a>:</p>\n<blockquote>\n<p>the proof of a Prop doesn't contain any data (it's represented by nothing at all)</p>\n</blockquote>\n<p>I learned a while back (to my surprise -- the only real reason I'm sharing) that Lean actually <em>does</em> represent proofs by data(*).  Lean actually will reduce proof terms, and there are examples of proofs that don't normalize <a href=\"#narrow/stream/113488-general/topic/Defeq.20is.20algorithmic.20in.20HoTT/near/243115821\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defeq.20is.20algorithmic.20in.20HoTT/near/243115821</a></p>\n<p>(*) I believe it erases proofs when evaluating with the VM, though.  That and proof irrelevance mean the situation's that proofs effectively have no data.</p>\n<p>(Another place that proof representation apparently can matter is with <code>simp</code>, again a bit of a surprise, though this doesn't count since it's operating syntactically.)</p>",
        "id": 252516616,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631128590
    },
    {
        "content": "<p>Now I think there is some confusion between \"proofs\" (as in the things that supposedly inhabit propositions) and proof terms. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 252516963,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631128711
    },
    {
        "content": "<p>It would be nice if we had a better name for the first one.</p>",
        "id": 252517031,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631128748
    },
    {
        "content": "<p>I guess my main surprise wasn't that there were proof terms, but that they mattered in any way.</p>",
        "id": 252517191,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631128823
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span>'s description in terms of two worlds is a good one. But more generally, while Lean-with-<code>choice</code> corresponds to ZFC plus some universes, Lean-without-<code>choice</code> definitely doesn't correspond to anything like ZF. For example, Lean-without-<code>choice</code> doesn't prove LEM (as far as we know??)</p>",
        "id": 252517901,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631129159
    },
    {
        "content": "<p>You could cook up some system of axioms to replace <code>choice</code> (like LEM and \"unique choice\") to get something that looks approximately like ZF, but there is not that much practical reason to do so.</p>",
        "id": 252518003,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631129198
    },
    {
        "content": "<p>(If a \"proof\" is a proof term, maybe an \"oath\" is a proof-modulo-irrelevance.  Lean solemnly swears it's seen the proof.)</p>",
        "id": 252518054,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631129217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252517901\">said</a>:</p>\n<blockquote>\n<p>I think <span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span>'s description in terms of two worlds is a good one. But more generally, while Lean-with-<code>choice</code> corresponds to ZFC plus some universes,</p>\n</blockquote>\n<p>I would say it is closer to ZF+GC (\"global choice\"), in which there is a class function that selects elements from every nonempty set, or alternatively a well ordering of the universe</p>",
        "id": 252519397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631129732
    },
    {
        "content": "<p>In ZFC, you usually can't construct definable functions that make use of a choice witness; it all has to be behind an existential</p>",
        "id": 252519561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631129798
    },
    {
        "content": "<p>It would be possible to get something more like ZFC in lean if the axiom was instead <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.axiom_of_choice\">docs#classical.axiom_of_choice</a></p>",
        "id": 252519682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631129849
    },
    {
        "content": "<p>If we interpret each <code>Type n</code> as a universe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> then <code>choice.{n}</code> only needs choice over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which is a set. But then ZFC + some universes is maybe too much rather than too little. Anyways, it wasn't really the point but I should have said something less precise there.</p>",
        "id": 252521256,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631130433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252518054\">said</a>:</p>\n<blockquote>\n<p>(If a \"proof\" is a proof term, maybe an \"oath\" is a proof-modulo-irrelevance.  Lean solemnly swears it's seen the proof.)</p>\n</blockquote>\n<p>I think this is still too syntactic. An element of a proposition is more of a hypothetical than an actual proof - Lean <em>hasn't</em> seen the proof, it's just assuming the proposition to be true. These elements are elements in the same way that <code>real</code> has uncountably many elements even though there are only countably many terms of type <code>real</code></p>",
        "id": 252521257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631130433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252521256\">said</a>:</p>\n<blockquote>\n<p>If we interpret each <code>Type n</code> as a universe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> then <code>choice.{n}</code> only needs choice over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which is a set. But then ZFC + some universes is maybe too much rather than too little. Anyways, it wasn't really the point but I should have said something less precise there.</p>\n</blockquote>\n<p>Even though it's a set (and thus amenable to the axiom of choice), you still don't get an explicit witness, except behind an existential, so it doesn't let you construct definable functions, unless you fix a set of choice functions \"at the outset\", which is messy because the choice of choice function becomes a parameter on every theorem</p>",
        "id": 252521679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631130584
    },
    {
        "content": "<p>Jacques Carette suggested the term \"omniscient\" to describe, as I understand it, the non-constructive aspect of classical mathematics that doesn't distinguish between knowing that there is exactly one king of France and knowing who the king of France is. (Or for a more practical example, not distinguishing between knowing that a given element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi><msup><mo stretchy=\"false\">)</mo><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">(\\mathbb{Z}/p)^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.021331em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> can be expressed as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>g</mi><mi>e</mi></msup></mrow><annotation encoding=\"application/x-tex\">g^e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.858832em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span></span></span></span></span></span></span></span> for a unique <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> mod <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7777700000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, and being able to compute <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>.)</p>",
        "id": 252522239,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631130796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252521679\">said</a>:</p>\n<blockquote>\n<p>unless you fix a set of choice functions \"at the outset\", which is messy because the choice of choice function becomes a parameter on every theorem</p>\n</blockquote>\n<p>Oh right, this part is indeed a bit weird.</p>",
        "id": 252522292,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631130824
    },
    {
        "content": "<p>I didn't mean to suggest that Lean actually has seen a proof -- we're taking Lean at its word.  That's its oath. (At least as far as asserting the proposition is true.)</p>\n<p>Point taken about using language that makes it seem like there actually are proof terms for every true proposition.</p>",
        "id": 252523379,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631131235
    },
    {
        "content": "<p>Has anyone successfully downloaded lean3 on a macOS with an M1 chip? Seems to be a lot of issues.</p>",
        "id": 252524341,
        "sender_full_name": "Ania Misiorek",
        "timestamp": 1631131594
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"438769\">@Ania Misiorek</span> Welcome! Please start a new thread for your question. (You can edit your message and change the title.)</p>",
        "id": 252524483,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631131654
    },
    {
        "content": "<p>you might want to ask this in a more appropriate thread? We're talking about the King of France here. Search for M1 before you do though (use the search bar at the top of the app), because this has come up before.</p>",
        "id": 252524492,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631131658
    },
    {
        "content": "<p>(I apologize immensely for the following name idea in advance...  A term of a proposition could be called a \"troof.\")</p>",
        "id": 252524929,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631131826
    },
    {
        "content": "<p>Kyle, you're now the one in the wrong thread ;b</p>",
        "id": 252525398,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1631131952
    },
    {
        "content": "<p>(fixed -- and apparently took you with me)</p>",
        "id": 252526101,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631132223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252510651\">said</a>:</p>\n<blockquote>\n<p>You can use the axiom of choice to get a witness for there-exists:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- F x says that x is king of France</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">only_one</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">definition</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">only_one.some</span>  <span class=\"c1\">-- short for Exists.some only_one</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">c_property</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">only_one.some_spec</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Unfortunately I get this cryptic error message:<br>\n\"invalid field notation, 'some' is not a valid \"field\" because environment does not contain 'Exists.some'<br>\n  only_one\"</p>",
        "id": 252540949,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1631138833
    },
    {
        "content": "<p>Ah, right, you need a mathlib theorem for that.  If you add</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.basic</span>\n</code></pre></div>\n<p>it will work.  (I had <code>import tactic</code> at the top of my file, which imports it transitively.)</p>",
        "id": 252541190,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631138928
    },
    {
        "content": "<p>(That error message means \"I see <code>only_one</code> is an <code>Exists</code>.  I see you are asking for <code>.some</code>.  I looked for <code>Exists.some</code>, but I don't know what that is.\"  This usually shows up if either (1) Lean guessed the types wrong, (2) you're missing some imports, or (3) you mistyped the stuff after the dot.)</p>",
        "id": 252541779,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631139201
    },
    {
        "content": "<p>Thanks again <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  now I got it to work, even with \"every country has a unique king\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- F a x says that x is king of a</span>\n\n<span class=\"kd\">definition</span> <span class=\"n\">is_only_one</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">only_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">is_only_one</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">definition</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">only_one</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span>  <span class=\"c1\">-- short for Exists.some only_one</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">c_property</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">,</span>  <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">only_one</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span>\n</code></pre></div>",
        "id": 252542254,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1631139429
    },
    {
        "content": "<p><code>is_only_one</code> is called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_unique\">docs#exists_unique</a> btw</p>",
        "id": 252542340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631139476
    },
    {
        "content": "<p>Terminology attempt number three: <em>proof term</em> vs <em>truth term</em>, or a <em>proof</em> vs a <em>truth</em>.  We syntactically construct proof terms for a proposition, but these just witness the singular truth term whose type is the given proposition.</p>\n<p>(I've heard a model theorist use truth term as thing that evaluates the truth of a proposition with respect to a model, so there's mild overloading.)</p>",
        "id": 252545671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631141269
    }
]
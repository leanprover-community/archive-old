[
    {
        "content": "<p>Is there some theorem in lean that proves composition of cone morphism is a cone morphism? I cant find it in cone.lean or limit.lean</p>",
        "id": 178972996,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1571936352
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simps</span><span class=\"o\">]</span> <span class=\"kn\">instance</span> <span class=\"n\">cone</span><span class=\"bp\">.</span><span class=\"n\">category</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span>  <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">cone_morphism</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"err\">‚â´</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">,</span>\n    <span class=\"n\">w&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">intro</span> <span class=\"n\">j</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">assoc</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">w</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">id</span>   <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 178973934,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571936920
    },
    {
        "content": "<p>that they form a category</p>",
        "id": 178973940,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571936926
    },
    {
        "content": "<p>that also means you shouldn't use <code>cone_morphism</code> explicitly, but rather <code>A \\hom B</code></p>",
        "id": 178973972,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571936947
    },
    {
        "content": "<p>I have the following code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">comm_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚âÖ</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">let</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n<span class=\"k\">let</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)),</span>\n<span class=\"k\">have</span> <span class=\"n\">comp12</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">),</span> <span class=\"n\">apply</span> <span class=\"n\">uniq_cone_morphism</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">is_limit</span><span class=\"o\">((</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">))</span>\n\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The last have line is a sketch of what I want to say, right now it is giving me an error. I want to apply uniq_cone_morphism to get a goal to show that both H1 &gt;&gt; H2 and the identity are cone morphisms. The statement for uniq_cone_morphism is:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">uniq_cone_morphism</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f&#39;</span>\n</pre></div>\n\n\n<p>So I need to say that the equalizer is the limit and here is where I get confused. Equalizer is defined as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">abbreviation</span> <span class=\"n\">equalizer</span> <span class=\"o\">:=</span> <span class=\"n\">limit</span> <span class=\"o\">(</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>But limit is defined to be the object of the cone that is the limit:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">has_limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">‚•§</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cone</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_limit</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"n\">cone</span> <span class=\"bp\">.</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">cone</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">‚•§</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_limit</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">has_limit</span><span class=\"bp\">.</span><span class=\"n\">cone</span> <span class=\"n\">F</span>\n\n<span class=\"n\">def</span> <span class=\"n\">limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">‚•§</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_limit</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">X</span>\n</pre></div>\n\n\n<p>So my question is: from the object (limit) equalizer f g how do I refer back to the cone (whilst preserving the information that it is indeed a limit)</p>",
        "id": 179120606,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572086891
    },
    {
        "content": "<p>what imports do you need to get this running?</p>",
        "id": 179120610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572086926
    },
    {
        "content": "<p>I should really learn this stuff at some point</p>",
        "id": 179120612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572086940
    },
    {
        "content": "<p>import category_theory.limits.shapes.equalizers<br>\nimport category_theory.limits.limits</p>\n<p>open category_theory</p>\n<p>namespace category_theory.limits<br>\nnamespace is_limit</p>",
        "id": 179120621,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572086955
    },
    {
        "content": "<p>I still have errors</p>",
        "id": 179120672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087026
    },
    {
        "content": "<p>just make a new scratch file and minimise</p>",
        "id": 179120674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087039
    },
    {
        "content": "<p><code>unknown identifier 'equalizer'</code> being the most serious one</p>",
        "id": 179120684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087115
    },
    {
        "content": "<p><code>unknown identifier 'f'</code> being the next one</p>",
        "id": 179120728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087133
    },
    {
        "content": "<p>Oh I got variables. I will send them</p>",
        "id": 179120782,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572087249
    },
    {
        "content": "<p>variables {C : Type u} [ùíû : category.{v} C]<br>\ninclude ùíû<br>\nvariables {X Y : C}<br>\nvariables (f g : X ‚ü∂ Y)<br>\nvariables [has_limit (parallel_pair f g)]  [has_limit (parallel_pair g f)]</p>",
        "id": 179120783,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572087261
    },
    {
        "content": "<p>Now I have errors on parallel_pair. Just create a new file, get it working at your end, and paste the whole thing</p>",
        "id": 179120788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087290
    },
    {
        "content": "<p>Ok</p>",
        "id": 179120797,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572087312
    },
    {
        "content": "<p>I don't know anything, I don't know what is defined where, but I'm very interested in this project you're doing</p>",
        "id": 179120802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087341
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">shapes</span><span class=\"bp\">.</span><span class=\"n\">equalizers</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">is_limit</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"err\">ùíû</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">ùíû</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_limit</span> <span class=\"o\">(</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)]</span>  <span class=\"o\">[</span><span class=\"n\">has_limit</span> <span class=\"o\">(</span><span class=\"n\">parallel_pair</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">comm_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚âÖ</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">let</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n<span class=\"k\">let</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)),</span>\n<span class=\"k\">have</span> <span class=\"n\">comp12</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">),</span> <span class=\"n\">apply</span> <span class=\"n\">uniq_cone_morphism</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">is_limit</span><span class=\"o\">((</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">))</span>\n<span class=\"kn\">end</span>\n\n\n<span class=\"kn\">end</span> <span class=\"n\">is_limit</span>\n<span class=\"kn\">end</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n</pre></div>\n\n\n<p>this is enough for me</p>",
        "id": 179120920,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572087542
    },
    {
        "content": "<p>Oh!</p>",
        "id": 179120959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087569
    },
    {
        "content": "<p>I am using a mathlib from July, that must be the problem. Sorry!</p>",
        "id": 179121011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087614
    },
    {
        "content": "<p>Mario would tell you to use <code>refine</code> not <code>apply</code> because <code>apply</code> is in core and has a bug which we can't fix</p>",
        "id": 179121085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087767
    },
    {
        "content": "<p>Oh, thats good to know thanks!</p>",
        "id": 179121100,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572087813
    },
    {
        "content": "<p>So the error is this:</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  limits.is_limit.uniq_cone_morphism limits.limit.is_limit\nterm\n  limits.limit.is_limit\nhas type\n  Œ† (F : ?m_1 ‚•§ ?m_3) [_inst_3 : limits.has_limit F], limits.is_limit (limits.limit.cone F) : Type (max\n        (max ? ?)\n        ?\n        ?)\nbut is expected to have type\n  limits.is_limit ?m_6 : Type (max ? ?)\nAdditional information:\n/home/buzzard/Encfs/Computer_languages/Lean/lean-projects/natural_number_game/scratch/scratch.lean:22:9: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message\n  too many arguments\n</pre></div>",
        "id": 179121151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087864
    },
    {
        "content": "<p>yeah</p>",
        "id": 179121160,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572087890
    },
    {
        "content": "<p>so it says \"<code>limits.limit.is_limit</code> wants an <code>F</code> but you didn't give it an <code>F</code>\"?</p>",
        "id": 179121179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087936
    },
    {
        "content": "<p>Is this progress: <code>  refine uniq_cone_morphism (limit.is_limit (equalizer f g) (H1 ‚â´ H2) (ùüô (equalizer f g)))</code>? Or have I misunderstood something?</p>",
        "id": 179121235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088054
    },
    {
        "content": "<p>yeah thats the problem, I gave equalizer but thats the limit object</p>",
        "id": 179121238,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088063
    },
    {
        "content": "<p>Does <code>\\gg</code> do composition in \"the wrong order\"?</p>",
        "id": 179121286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088106
    },
    {
        "content": "<p>oh yes I can just check its type and see that it does</p>",
        "id": 179121296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088124
    },
    {
        "content": "<p>wait it does?</p>",
        "id": 179121308,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088183
    },
    {
        "content": "<p>Isn't it at this point that you just type <code>tidy</code> or some other fancy tactic and you're done?</p>",
        "id": 179121309,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088191
    },
    {
        "content": "<p>You are using gg correctly</p>",
        "id": 179121312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088198
    },
    {
        "content": "<p>I was just thrown for a second</p>",
        "id": 179121358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088232
    },
    {
        "content": "<p>neither tidy or simp works</p>",
        "id": 179121359,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088245
    },
    {
        "content": "<p>Why does </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">have</span> <span class=\"n\">comp12</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"n\">uniq_cone_morphism</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n</pre></div>\n\n\n<p>not work?</p>\n<div class=\"codehilite\"><pre><span></span>invalid type ascription, term has type\n  ?m_8 = ?m_9\nbut is expected to have type\n  H1 ‚â´ H2 = ùüô (limits.equalizer f g)\n</pre></div>",
        "id": 179121418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088323
    },
    {
        "content": "<p>Yeah I got to there now as well</p>",
        "id": 179121422,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088346
    },
    {
        "content": "<p>I didnt have to give the cone, I had to give the diagram (parallel_pair f g)</p>",
        "id": 179121434,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088368
    },
    {
        "content": "<p>Now one thing Im not sure of is if lean 'knows' that the identity and composition of H1 and H2 are cone morphisms. As kenny said earlier the fact that they form a category is in mathlib, but maybe we need to provide this explictly</p>",
        "id": 179121515,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088528
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">uniq_cone_morphism</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"o\">:</span> <span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n</pre></div>\n\n\n<p>doesn't work either</p>",
        "id": 179121517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088537
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">uniq_cone_morphism</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n</pre></div>\n\n\n<p>gives</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  category_struct.comp H1\nterm\n  H1\nhas type\n  limits.equalizer f g ‚ü∂ limits.equalizer g f : Type v\nbut is expected to have type\n  ?m_6 ‚ü∂ ?m_7 : Type ?\n</pre></div>\n\n\n<p>Is this a universe issue??</p>",
        "id": 179121575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088630
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">uniq_cone_morphism</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"err\">‚â´</span> <span class=\"n\">H2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n</pre></div>\n\n\n<p>shows it isn't. </p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  category_struct.comp H1\nterm\n  H1\nhas type\n  limits.equalizer f g ‚ü∂ limits.equalizer g f\nbut is expected to have type\n  ?m_6 ‚ü∂ ?m_7\n</pre></div>",
        "id": 179121630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088732
    },
    {
        "content": "<p>Now I need to count to see which is the 6th <code>_</code></p>",
        "id": 179121637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088747
    },
    {
        "content": "<p>I think we need to show that H1 and H2 are cone morphisms</p>",
        "id": 179121746,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088937
    },
    {
        "content": "<p>Because right now they are just maps between some objects</p>",
        "id": 179121747,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088952
    },
    {
        "content": "<p>equalizer is just the object, not the cone</p>",
        "id": 179121750,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572088962
    },
    {
        "content": "<p>right, this seems to me to be just a case of looking carefully at the type of everything</p>",
        "id": 179121754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572088979
    },
    {
        "content": "<p>Just saw this thread, and may have to run in a moment.</p>",
        "id": 179121806,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089035
    },
    {
        "content": "<p>Have a look at <code>def prod.braiding (P Q : C) : P ‚®Ø Q ‚âÖ Q ‚®Ø P := ...</code></p>",
        "id": 179121855,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089064
    },
    {
        "content": "<p>in <code>category_theory/limits/shapes/binary_products.lean</code></p>",
        "id": 179121858,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089077
    },
    {
        "content": "<p>I don't think <code>uniq_cone_morphism</code> is going to be particularly helpful -- why do you want to use that?</p>",
        "id": 179121878,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089156
    },
    {
        "content": "<p>Oh, to prove that the two compositions are the identity, I see.</p>",
        "id": 179121917,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089166
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">tidy</span><span class=\"o\">]</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">case_bash</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">comm_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚âÖ</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)),</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>doesn't quite get there, but it gives two very manageable goals that possibly ought to be simp lemmas.</p>",
        "id": 179121978,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089317
    },
    {
        "content": "<p>(The first incantation <code>local attribute [tidy] tactic.case_bash</code> tells the tidy tactic that it's allowed to case bash on hypotheses which are inductive types. In particular, that means that to prove two natural transformations out of a \"finite\" category are equal, it can check object by object.)</p>",
        "id": 179121992,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089387
    },
    {
        "content": "<p>(Boarding a flight Perth-London, so I'll be offline for a while. :-) Good luck!)</p>",
        "id": 179122060,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572089494
    },
    {
        "content": "<p>Which London?</p>",
        "id": 179122064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572089506
    },
    {
        "content": "<p>I dont really understand the above syntax, how to I continue of what Scott was doing?</p>",
        "id": 179122356,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090117
    },
    {
        "content": "<p>Is the := just like let?</p>",
        "id": 179122398,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090133
    },
    {
        "content": "<p>he's making a structure, isn't he?</p>",
        "id": 179122402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090152
    },
    {
        "content": "<p>Oh right the isomorphism</p>",
        "id": 179122404,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090169
    },
    {
        "content": "<p>But then how do I continue the proof?</p>",
        "id": 179122412,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090186
    },
    {
        "content": "<p>good question! I was trying to figure out what was going on in your proof still.</p>",
        "id": 179122423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090239
    },
    {
        "content": "<p>I think he decided to come to London to help you out personally. It's a bit of an extreme reaction but he has to be applauded.</p>",
        "id": 179122466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090261
    },
    {
        "content": "<p>got it</p>",
        "id": 179122470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090299
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">comm_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚âÖ</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)),</span> <span class=\"o\">},</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 179122476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090308
    },
    {
        "content": "<p>does this help? Now it looks like you have to prove something which looks like a standard diagram chase.</p>",
        "id": 179122532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090418
    },
    {
        "content": "<p>Yes exactly, but it feels like that could be done by some tactic?</p>",
        "id": 179122544,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090477
    },
    {
        "content": "<p>I'm afraid I do't know how the category theory library works at all. For those watching with amusement, we're now on</p>\n<div class=\"codehilite\"><pre><span></span>‚ä¢ limits.equalizer.Œπ f g ‚â´ g = limits.limit.œÄ (limits.parallel_pair f g) limits.walking_parallel_pair.one\n</pre></div>",
        "id": 179122591,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090537
    },
    {
        "content": "<p>Yeah right now im just reading up, hopefully there is some theorem about the fact that the projection commutes with the diagram</p>",
        "id": 179122649,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090614
    },
    {
        "content": "<p>I mean its in the definition but Im not sure how to access that</p>",
        "id": 179122656,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090633
    },
    {
        "content": "<p>you could just wait for about 20 hours and then go and meet him at the airport</p>",
        "id": 179122658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090638
    },
    {
        "content": "<p>Seems like a reasonable plan</p>",
        "id": 179122672,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090712
    },
    {
        "content": "<p>but I think this will help</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">cone</span><span class=\"bp\">.</span><span class=\"n\">w</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">‚•§</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"n\">j&#39;</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">j&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">j</span> <span class=\"err\">‚â´</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">j&#39;</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">convert</span> <span class=\"err\">‚Üê</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span><span class=\"bp\">.</span><span class=\"n\">naturality</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">id_comp</span>\n</pre></div>",
        "id": 179122700,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090723
    },
    {
        "content": "<p>But then the question again becomes how to we access the cone of the equalizer</p>",
        "id": 179122776,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090847
    },
    {
        "content": "<p>I cannot steer this stuff at all.</p>",
        "id": 179122778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572090871
    },
    {
        "content": "<p>steer?</p>",
        "id": 179122782,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572090894
    },
    {
        "content": "<p>I don't even know the basics.</p>",
        "id": 179122864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572091081
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/category_theory/calculating_colimits_in_Top.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/category_theory/calculating_colimits_in_Top.lean\">https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/category_theory/calculating_colimits_in_Top.lean</a></p>",
        "id": 179122901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572091085
    },
    {
        "content": "<p>That's the only documentation I have ever seen.</p>",
        "id": 179122904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572091097
    },
    {
        "content": "<p>ah</p>",
        "id": 179122906,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572091121
    },
    {
        "content": "<p>What I'm saying is that I don't have a clue how to access the cone of the equalizer. In maths I'd just draw a picture and say we were done.</p>",
        "id": 179122908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572091131
    },
    {
        "content": "<p>But I can't work Scott's library</p>",
        "id": 179122916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572091161
    },
    {
        "content": "<p>If it were a car, I'm not saying that I can't drive it, I'm saying I can't even use the steering wheel.</p>",
        "id": 179122919,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572091186
    },
    {
        "content": "<p>I should stress that this is entirely my problem, not Scott's. Furthermore I think that trying to prove math-trivial things such as the equaliser of f and g is isomorphic the equaliser of g and f is exactly the way one should learn these things. Maybe when you meet Scott at the airport you can tell him that I've booked a room at Imperial for the talk he's giving in London which explains all this stuff.</p>",
        "id": 179123064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572091378
    },
    {
        "content": "<p>I made some progress!</p>",
        "id": 179123075,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572091437
    },
    {
        "content": "<p>but minor...</p>",
        "id": 179123077,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572091441
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">comm_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚âÖ</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)),</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">‚Üê</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">w</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 179123125,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572091465
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"err\">‚ä¢</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚â´</span> <span class=\"n\">g</span> <span class=\"bp\">=</span>\n    <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span> <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"err\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"err\">?</span><span class=\"n\">m_2</span>\n</pre></div>",
        "id": 179123135,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572091492
    },
    {
        "content": "<p>Just have to figure out how to supply ?m_1 and ?m_2</p>",
        "id": 179123145,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572091509
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">comm_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚âÖ</span> <span class=\"n\">equalizer</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)),</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">((</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)),</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">‚Üê</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">w</span> <span class=\"o\">(</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">walking_parallel_pair_hom</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">parallel_pair_map_right</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">‚Üê</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">w</span> <span class=\"o\">(</span><span class=\"n\">parallel_pair</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">walking_parallel_pair_hom</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">parallel_pair_map_right</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 179123557,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572092272
    },
    {
        "content": "<p>now it is done. Thank you very much for the help <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 179123599,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572092295
    },
    {
        "content": "<p>Now write some docs! ;-)</p>",
        "id": 179123601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572092302
    },
    {
        "content": "<p>Make a new file in the <a href=\"https://github.com/leanprover-community/mathlib/tree/master/docs/tutorial/category_theory\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/tree/master/docs/tutorial/category_theory\">https://github.com/leanprover-community/mathlib/tree/master/docs/tutorial/category_theory</a> directory and just write down the basic things you need to know to work with equalisers and give this as an example.</p>",
        "id": 179123623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572092376
    },
    {
        "content": "<p>And then Patrick will accept the PR and...oh :-/</p>",
        "id": 179123627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572092392
    },
    {
        "content": "<p>I think I need some more practice first. Now I will try to prove</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">mono_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 179123749,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572092560
    },
    {
        "content": "<p>I am absolutely serious when I say that if you just figure out how to prove three trivial things about equalizers and then just write a little piece saying what the problems are and how to solve them in Lean and dump it as a .md file in that category theory directory then you will be doing a great service to the community, and not least to people like me who see this stuff now, understand it, forget it, and then can't find this thread in 1 month's time -- people like me (old people) and newcomers (beginners) really need documentation.</p>",
        "id": 179123820,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572092696
    },
    {
        "content": "<p>Another trivial lean question:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">right_cancellation</span> <span class=\"o\">:</span> <span class=\"bp\">Œ†</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">‚â´</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"err\">‚â´</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I have the above class and I want to prove</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">mono_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I tried using intro but it says \"Pi\\let expression expected\" What does this mean?</p>",
        "id": 179123888,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572092767
    },
    {
        "content": "<p>Like how do I unfold</p>",
        "id": 179123890,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572092778
    },
    {
        "content": "<blockquote>\n<p>I am absolutely serious when I say that if you just figure out how to prove three trivial things about equalizers and then just write a little piece saying what the problems are and how to solve them in Lean and dump it as a .md file in that category theory directory then you will be doing a great service to the community, and not least to people like me who see this stuff now, understand it, forget it, and then can't find this thread in 1 month's time -- people like me (old people) and newcomers (beginners) really need documentation.</p>\n</blockquote>\n<p>Im thinning I could write it after proving both of these things</p>",
        "id": 179123894,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572092799
    },
    {
        "content": "<blockquote>\n<p>I tried using intro but it says \"Pi\\let expression expected\" What does this mean?</p>\n</blockquote>\n<p>That means \"the goal is not a pi type, it's something else\"</p>",
        "id": 179123913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572092862
    },
    {
        "content": "<p>indeed, <code>mono</code> is a structure</p>",
        "id": 179123959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572092905
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">mono_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">‚ü®_‚ü©</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span><span class=\"o\">,</span>\n</pre></div>",
        "id": 179123967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572092937
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">mono_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">right_cancellation</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">intro</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 179124026,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572093015
    },
    {
        "content": "<p>So I've been trying to answer your original question (\"how do I get my way to work\") and I am slowly beginning to get to the point where you were when you asked the question. </p>\n<div class=\"codehilite\"><pre><span></span>term\n  limits.equalizer f g\nhas type\n  C : Type u\nbut is expected to have type\n  limits.cone ?m_3 : Type (max u v)\n</pre></div>\n\n\n<p>This is the problem, right?</p>",
        "id": 179124448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572093768
    },
    {
        "content": "<p><code>uniq_cone_morphism</code>, the thing you were initially trying to use, does <em>not</em> prove that two morphisms in <code>C</code> are equal, it proves that two morphisms in some category called <code>limits.cone F</code> are equal. This is why you're stuck.</p>",
        "id": 179124530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572093952
    },
    {
        "content": "<p>[or rather why you were stuck 2 hours ago]</p>",
        "id": 179124573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572093968
    },
    {
        "content": "<p>yeah exactly</p>",
        "id": 179124599,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572094063
    },
    {
        "content": "<p>So what I was wondering was how to lift the information to the category of cones</p>",
        "id": 179124609,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572094082
    },
    {
        "content": "<p>limit (diagram) is not the cone, but just the element</p>",
        "id": 179124644,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572094109
    },
    {
        "content": "<p>I have a problem for the last step of the proof, a rewrite in the middle of a function composition:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">mono_of_equalizer</span> <span class=\"o\">:</span> <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">refine</span> <span class=\"bp\">‚ü®_‚ü©</span><span class=\"o\">,</span>\n<span class=\"n\">intros</span> <span class=\"n\">Z</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"n\">comp</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">hom_ext</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n<span class=\"n\">refine</span> <span class=\"n\">comp</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">‚Üê</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">w</span> <span class=\"o\">(</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">walking_parallel_pair_hom</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">comp</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>This is my goal:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">case</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">walking_parallel_pair</span><span class=\"bp\">.</span><span class=\"n\">one</span>\n<span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"err\">ùíû</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">has_limit</span> <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">has_limit</span> <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n<span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"err\">‚â´</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"err\">‚â´</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n<span class=\"err\">‚ä¢</span> <span class=\"n\">h</span> <span class=\"err\">‚â´</span>\n      <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span> <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">walking_parallel_pair</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"err\">‚â´</span>\n        <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">walking_parallel_pair_hom</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"bp\">=</span>\n    <span class=\"n\">i</span> <span class=\"err\">‚â´</span>\n      <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span> <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">walking_parallel_pair</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"err\">‚â´</span>\n        <span class=\"o\">(</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">walking_parallel_pair_hom</span><span class=\"bp\">.</span><span class=\"n\">right</span>\n</pre></div>\n\n\n<p>Now limits.equalizer.Œπ f g (see the comp hypothesis) is just an abbrevation:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">abbreviation</span> <span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"n\">equalizer</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">œÄ</span> <span class=\"o\">(</span><span class=\"n\">parallel_pair</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">zero</span>\n</pre></div>\n\n\n<p>So I should be done with just a simple rewrite using comp, but I get the following error:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kn\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"n\">h</span> <span class=\"err\">‚â´</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">equalizer</span><span class=\"bp\">.</span><span class=\"n\">Œπ</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n</pre></div>",
        "id": 179124944,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572094667
    },
    {
        "content": "<p>FYI on the line <code>refine comp</code> I had the exact same goal, only without the 2nd function composition. Then refine comp worked perfectly to eliminate one of the goals</p>",
        "id": 179124988,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572094735
    },
    {
        "content": "<p>Before <code>rw comp</code> your local context is this:</p>\n<div class=\"codehilite\"><pre><span></span>comp : h ‚â´ limits.equalizer.Œπ f g = i ‚â´ limits.equalizer.Œπ f g\n‚ä¢ h ‚â´\n      limits.limit.œÄ (limits.parallel_pair f g) limits.walking_parallel_pair.zero ‚â´\n        (limits.parallel_pair f g).map limits.walking_parallel_pair_hom.right =\n    i ‚â´\n      limits.limit.œÄ (limits.parallel_pair f g) limits.walking_parallel_pair.zero ‚â´\n        (limits.parallel_pair f g).map limits.walking_parallel_pair_hom.right\n</pre></div>\n\n\n<p>So <code>rw comp</code> will fail because <code>rw</code> works with syntactic equality, and the left hand side of <code>h</code> is not exactly mentioned in the goal.</p>",
        "id": 179125196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095062
    },
    {
        "content": "<p>So can I somehow rewrite the abbrevation first?</p>",
        "id": 179125223,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095155
    },
    {
        "content": "<p>I have no idea how to steer abbreviations. I don't even know what they are.</p>",
        "id": 179125266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095178
    },
    {
        "content": "<p>ah :/</p>",
        "id": 179125271,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095197
    },
    {
        "content": "<p>Is the left hand side of the goal I posted definitionally equal to the left hand side of <code>comp</code> in your opinion?</p>",
        "id": 179125281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095223
    },
    {
        "content": "<p>there are too many &gt;&gt;'s, right?</p>",
        "id": 179125287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095239
    },
    {
        "content": "<p>but the last &gt;&gt; is the same on both sides</p>",
        "id": 179125293,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095263
    },
    {
        "content": "<p>Is &gt;&gt; left associative or right associative?</p>",
        "id": 179125341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095299
    },
    {
        "content": "<p>aah! It's right associative!</p>",
        "id": 179125344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095322
    },
    {
        "content": "<p>Wait now Im confused, isnt it both?</p>",
        "id": 179125345,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095336
    },
    {
        "content": "<p>nonono</p>",
        "id": 179125347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095342
    },
    {
        "content": "<p>oh okay now I see</p>",
        "id": 179125350,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095344
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">notation</span> <span class=\"err\">‚â´</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">notation</span> <span class=\"bp\">+</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">notation</span> <span class=\"err\">^</span>\n</pre></div>",
        "id": 179125353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095348
    },
    {
        "content": "<p>I can never remember whether the difference in numbers means left or right</p>",
        "id": 179125362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095367
    },
    {
        "content": "<p>For <code>+</code> the two numbers are the same, so <code>+</code> is left associative</p>",
        "id": 179125371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095383
    },
    {
        "content": "<p>by which I mean \"when Lean says <code>a+b+c</code>, it means <code>(a+b)+c</code>\"</p>",
        "id": 179125383,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095395
    },
    {
        "content": "<p>So I have to rewrite associativity first</p>",
        "id": 179125429,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095424
    },
    {
        "content": "<p>For <code>^</code> the numbers differ by 1, because it's right associative. So, yes.</p>",
        "id": 179125433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095437
    },
    {
        "content": "<p>what's this lemma called?</p>",
        "id": 179125438,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095467
    },
    {
        "content": "<p>actually, what's this axiom called?</p>",
        "id": 179125441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095477
    },
    {
        "content": "<p>ha ha if I don't even know the names of the axioms this is a pretty good indication of how good I am at categories in Lean :D</p>",
        "id": 179125444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095506
    },
    {
        "content": "<p>category.assoc_symm</p>",
        "id": 179125448,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095518
    },
    {
        "content": "<p>Not <code>assoc</code>??</p>",
        "id": 179125491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095540
    },
    {
        "content": "<p>wow you're right. Maybe it's because it's the other way around to usual because of the different conventions.</p>",
        "id": 179125502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095591
    },
    {
        "content": "<p>I dont know but category.assoc_symm worked</p>",
        "id": 179125505,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095594
    },
    {
        "content": "<p>Thank you. The proof is now completed</p>",
        "id": 179125511,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1572095634
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">notation</span> <span class=\"err\">‚àò</span>\n</pre></div>\n\n\n<p>Usual function composition is left associative, so the convention I guess is that <code>assoc</code> means <code>(a*b)*c=a*(b*c)</code> [for a general infix binary operator]</p>",
        "id": 179125551,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095647
    },
    {
        "content": "<p>and then you apply <code>eq.symm</code> and you get Scott's axiom.</p>",
        "id": 179125554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095663
    },
    {
        "content": "<p>so the rewrite does work. I guess <code>abbreviation</code> really does not change even syntactic equality. Maybe the parser just unfolds it before even passing it to the kernel?</p>",
        "id": 179125639,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572095880
    },
    {
        "content": "<p>they're not <code>lemma</code>s they're <code>def</code>s</p>",
        "id": 179129168,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1572102026
    },
    {
        "content": "<p>It sounds like you've been making good progress. :-) I am actually in London right now, but only for two hours, before heading off to Frankfurt. I wish I could have stopped by Imperial to chat about categories in Lean, but my travel schedule is pretty constrained, so I'm just jumping back and forth for a week at Oberwolfach (for my \"day job\").</p>",
        "id": 179157424,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572157375
    }
]
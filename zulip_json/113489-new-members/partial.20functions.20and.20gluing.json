[
    {
        "content": "<p>Hi all, I'm currently trying to do some basic point-set topology in Lean from the ground up -- partly to learn more about structures and typeclasses. I have looked a bit at topology in mathlib (only a little -- I kind of want to make my own mistakes, and I'm also not really fluent enough to read mathlib at length). I initially followed the first few section of Munkres <em>Topology</em> (open/closed sets, continuous functions).</p>\n<p>I'm currently trying to formalize gluing, specifically gluing a fiber bundle given the data of a local trivialization.</p>\n<p>The topology aspect is mostly all homeomorphisms. So the main challenge has really come from working with lots of subsets and/or subtypes and functions between them. I've read some discussions on here about it being generally preferable to use total functions with junk values. Would that be the right thing to do here? Or is there some way to make this easier?</p>\n<p>For example, say <code>π : E → B</code> is a fiber bundle with fiber <code>F</code> and <code>U : set B</code> is a trivializing open set (i.e. I have the data of a bijection/homeomorphism <code>φ : U × F → π ⁻¹' U</code>). Then I find it surprisingly painful to show that any smaller subset <code>U' ⊆ U</code> is also trivializing. For example showing that <code>φ</code> restricted to <code>U' × F</code> maps to <code>π ⁻¹' U'</code> (and having to treat codomains similar to that one in two slightly different ways depending on whether they show up as a subtype of E or a subtype of <code>π ⁻¹' U</code>, i.e. a sub-subtype of E). </p>\n<p>Here's my setup:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π'</span> <span class=\"o\">:</span> <span class=\"n\">E'</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">E'</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_subset</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">π</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"bp\">↔</span> <span class=\"n\">φ</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">π'</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp_app</span> <span class=\"n\">π'</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">hφ</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">π</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">π'</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fiber_map_subset</span> <span class=\"n\">hφ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">he</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_inj_iff_res_inj</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.injective</span> <span class=\"n\">φ</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_surj_iff_res_surj</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.surjective</span> <span class=\"n\">φ</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">function.surjective</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_bij_iff_res_bij</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.bijective</span> <span class=\"n\">φ</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>For those, filling in the <code>sorry</code>s takes me about 5 lines each. But then proving the analogous iff statements for continuity and inverse-continuity and homeomorphisms takes me 60-70 lines. I won't copy that all here, but the lemma statement is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- I have defined a topology as a set of open sets</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">TB</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">TE</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">TE'</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">E'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_cts_iff_res_cts</span>\n  <span class=\"o\">(</span><span class=\"n\">hπ_cts</span> <span class=\"o\">:</span> <span class=\"n\">cts</span> <span class=\"n\">TE</span> <span class=\"n\">TB</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hπ'_cts</span> <span class=\"o\">:</span> <span class=\"n\">cts</span> <span class=\"n\">TE'</span> <span class=\"n\">TB</span> <span class=\"n\">π'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">topology.cts</span> <span class=\"n\">TE</span> <span class=\"n\">TE'</span> <span class=\"n\">φ</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">TB.opens</span><span class=\"o\">),</span> <span class=\"n\">cts</span> <span class=\"bp\">↑</span><span class=\"n\">TE</span> <span class=\"bp\">↑</span><span class=\"n\">TE'</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n\n<span class=\"c1\">-- proof of the above is 15-20 lines and uses:</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_sub</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">x.val</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">from_sub</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U'</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">U'</span><span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">to_sub_open_iff</span> <span class=\"o\">(</span><span class=\"n\">U'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">opens</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">TX.opens</span><span class=\"o\">,</span> <span class=\"n\">U'</span> <span class=\"bp\">=</span> <span class=\"n\">to_sub</span> <span class=\"n\">A</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">from_sub_open_iff</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">TX.opens</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">opens</span> <span class=\"bp\">↔</span> <span class=\"n\">from_sub</span> <span class=\"n\">A</span> <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"n\">TX.opens</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'd be grateful for any comments or advice!</p>",
        "id": 251825197,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1630647251
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"391579\">@Jake Levinson</span> These issues are painful. Do you have a specific <code>sorry</code> that you want advice on?<br>\nOne complication is that you seem to have built your own topology library, and I have no idea what exactly it looks like. So I have no idea whether those final two <code>sorry</code>s are supposed to be filled by <code>iff.rfl</code>, or that the definitions force you into a 20-line proof.</p>",
        "id": 251829014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630650840
    },
    {
        "content": "<p>Not sure if it will make things much easier, but I think it is better to work with open embeddings and not open subsets.</p>",
        "id": 251855059,
        "sender_full_name": "Reid Barton",
        "timestamp": 1630663646
    },
    {
        "content": "<p>For one thing, your mental picture of what is going on will be a lot closer to Lean's.</p>",
        "id": 251855268,
        "sender_full_name": "Reid Barton",
        "timestamp": 1630663738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Hmm, thanks for the comments. Let me include a bit more of the code, though FWIW this gluing stuff is mostly independent of most earlier lemmas (which were on stuff like bases for a topology, interiors and closures, etc).</p>\n<p>Here are two <code>sorry</code>s I would appreciate advice on.</p>\n<ol>\n<li>For the injectivity/bijectivity lemmas (which are purely about sets and functions, so no other lemmas necessary), I wonder if there is a way to get a one-line proof? For example I have:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_subset'</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">π</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">↔</span> <span class=\"n\">π'</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp_app</span> <span class=\"n\">π'</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">hφ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_surj_iff_res_surj</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.surjective</span> <span class=\"n\">φ</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">function.surjective</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">h</span> <span class=\"n\">U</span> <span class=\"o\">⟨</span><span class=\"n\">e'</span><span class=\"o\">,</span> <span class=\"n\">he'</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">e'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">fiber_map_subset'</span> <span class=\"n\">hφ</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">],</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">set.univ</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">function.surjective</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This is reasonably short, going directly from the definition of surjectivity in both directions of the <code>iff</code>. (My first attempt was longer until I finally wrote the auxiliary lemma <code>fiber_map_subset'</code>). Still a little longer than I had expected.</p>\n<ol start=\"2\">\n<li>For <code>fiber_map_cts_iff_res_cts</code> (see below), I think my proof is pretty messy. Notably, I couldn't find an easy/clean way to deal with the distinction between functions <code>E → E</code> and <code>{e : E // true} → {e : E // true}</code> (this works OK in <code>fiber_map_surj_iff_res_surj</code> above via <code>simp</code> in the <code>iff.mpr</code> direction).</li>\n</ol>\n<p>Here is my code, including my definitions of topology, continuous function, subspace topology (this should all be a working example, if not quite an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">topology</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">topology</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"c1\">-- (should this instead be: is_open : set X → Prop ?)</span>\n<span class=\"o\">(</span><span class=\"n\">empty_open</span> <span class=\"o\">:</span> <span class=\"bp\">∅</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">univ_open</span> <span class=\"o\">:</span> <span class=\"n\">set.univ</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inter₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"bp\">→</span> <span class=\"n\">set.inter</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">sU</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)),</span> <span class=\"n\">sU</span> <span class=\"bp\">⊆</span> <span class=\"n\">opens</span> <span class=\"bp\">→</span> <span class=\"bp\">⋃₀</span> <span class=\"n\">sU</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">TY</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cts</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"n\">TY.opens</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"n\">TX.opens</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">inverse_image_topology</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n  <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">TY.opens</span><span class=\"o\">),</span> <span class=\"n\">W</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span><span class=\"o\">},</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">topology.empty_open</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩,</span>\n  <span class=\"o\">⟨</span><span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">topology.univ_open</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- written on the side</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- written on the side</span>\n<span class=\"o\">⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subspace_topology</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n  <span class=\"n\">inverse_image_topology</span> <span class=\"n\">TX</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a.val</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">topology_to_subspace_topology</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">topology</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">topology</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">TX</span><span class=\"o\">,</span> <span class=\"n\">subspace_topology</span> <span class=\"n\">TX</span> <span class=\"n\">A</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">to_sub</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">x.val</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">from_sub</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U'</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">U'</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Then I proved as many lemmas as I could think of about `to_sub` and `from_sub`. The only two I use below are:</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_sub_open_iff</span> <span class=\"o\">(</span><span class=\"n\">U'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">opens</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">TX.opens</span><span class=\"o\">,</span> <span class=\"n\">U'</span> <span class=\"bp\">=</span> <span class=\"n\">to_sub</span> <span class=\"n\">A</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">from_sub_open_iff</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">TX.opens</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">TX</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">opens</span> <span class=\"bp\">↔</span> <span class=\"n\">from_sub</span> <span class=\"n\">A</span> <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"n\">TX.opens</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">topology</span>\n\n<span class=\"c1\">-- Finally, here is `fiber_map_cts_iff_res_cts`.</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">fiber_bundle</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π'</span> <span class=\"o\">:</span> <span class=\"n\">E'</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">E'</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">TB</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">TE</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">TE'</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">E'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_subset</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">π</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"bp\">↔</span> <span class=\"n\">φ</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">π'</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp_app</span> <span class=\"n\">π'</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">hφ</span><span class=\"o\">]}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_subset'</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">π</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">↔</span> <span class=\"n\">π'</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp_app</span> <span class=\"n\">π'</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">hφ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">π</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">π'</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fiber_map_subset</span> <span class=\"n\">hφ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">he</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fiber_map_cts_iff_res_cts</span> <span class=\"o\">(</span><span class=\"n\">hπ_cts</span> <span class=\"o\">:</span> <span class=\"n\">cts</span> <span class=\"n\">TE</span> <span class=\"n\">TB</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hπ'_cts</span> <span class=\"o\">:</span> <span class=\"n\">cts</span> <span class=\"n\">TE'</span> <span class=\"n\">TB</span> <span class=\"n\">π'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">π'</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">topology.cts</span> <span class=\"n\">TE</span> <span class=\"n\">TE'</span> <span class=\"n\">φ</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">TB.opens</span><span class=\"o\">),</span> <span class=\"n\">cts</span> <span class=\"bp\">↑</span><span class=\"n\">TE</span> <span class=\"bp\">↑</span><span class=\"n\">TE'</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- mp</span>\n  <span class=\"n\">intros</span> <span class=\"n\">hφ_cts</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">V_E'</span> <span class=\"o\">:=</span> <span class=\"n\">from_sub</span> <span class=\"n\">_</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hV_E'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">from_sub_open_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hπ'_cts</span> <span class=\"n\">U</span> <span class=\"n\">hU</span><span class=\"o\">)</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hV</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hφ_cts</span> <span class=\"n\">V_E'</span> <span class=\"n\">hV_E'</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">res_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">U</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"n\">to_sub</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V_E'</span><span class=\"o\">),</span>\n    <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">fiber_map_subset</span> <span class=\"n\">hφ</span> <span class=\"n\">at</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">to_sub_open_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V_E'</span><span class=\"o\">),</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hφ_cts</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- mpr</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hφU_cts</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hφU_cts</span> <span class=\"n\">set.univ</span> <span class=\"n\">TB.univ_open</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hφU_cts</span> <span class=\"o\">(</span><span class=\"n\">to_sub</span> <span class=\"n\">set.univ</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">to_sub_open_iff</span> <span class=\"n\">at</span> <span class=\"n\">hφU_cts</span><span class=\"o\">,</span> <span class=\"n\">specialize</span> <span class=\"n\">hφU_cts</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">from_sub_open_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hπ_cts</span> <span class=\"n\">_</span> <span class=\"n\">TB.univ_open</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">hφU_cts</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hφU_cts</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">fiber_bundle</span>\n</code></pre></div>\n<p>I have no idea if the above is even slightly readable, heh... and I found it very difficult to write. I would highlight that the <code>mpr</code> direction is quite complicated even though I have the hypothesis <code>cts ↑TE ↑TE' (res_subset hφ set.univ)</code>,  i.e. the restriction of <code>φ</code> to <code>π ⁻¹' set.univ</code> is continuous.</p>",
        "id": 251901999,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1630684388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/partial.20functions.20and.20gluing/near/251855059\">said</a>:</p>\n<blockquote>\n<p>Not sure if it will make things much easier, but I think it is better to work with open embeddings and not open subsets.</p>\n</blockquote>\n<p>I considered doing this -- it definitely makes sense to me that there would be advantages to suppressing sets throughout and always replacing <code>U : set X</code> by <code>f : U \\to X</code> and <code>hf : open_immersion f</code>.</p>\n<p>I think my main hesitation was that I think I would then have to replace intersection of open sets by fiber product? I got the feeling that this approach would quickly lead me more towards formalizing category theory rather than topology, if that makes sense...</p>",
        "id": 251902555,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1630684626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"391579\">@Jake Levinson</span> I started following along with your exercise last night to see to get a better idea of what you might be running into.  I have exactly the same definition for <code>topology</code> (sets of sets seem fine to me).  Here's a notation trick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>The square brackets make it take <code>X</code> explicitly, so you can write things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">union_mem</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">U'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"n\">X</span>\n</code></pre></div>",
        "id": 251903280,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630684921
    },
    {
        "content": "<p>For <code>inverse_image_topology</code>, you don't want that to be an instance, since it depends on <code>f</code> and can't be used.</p>\n<p>If you want to be terse for the definition of the open sets, you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">inverse_image_topology</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">opens</span> <span class=\"o\">:=</span> <span class=\"n\">set.preimage</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n   <span class=\"bp\">...</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 251903650,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630685052
    },
    {
        "content": "<p>Once you have that, the subspace topology is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">topology.subspace</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">inverse_image_topology</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(<code>coe</code> is the official way to apply <code>subtype.val</code>)</p>",
        "id": 251903841,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630685135
    },
    {
        "content": "<p>For example, here's a short definition for <code>from_sub</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">from_sub</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">set.image</span> <span class=\"n\">coe</span>\n</code></pre></div>\n<p>and <code>to_sub</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_sub</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">set.preimage</span> <span class=\"n\">coe</span>\n</code></pre></div>",
        "id": 251904700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630685432
    },
    {
        "content": "<p>(I'm not sure I've used it yet, but these are related to another characterization of continuity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">cts.def</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cts</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">set.preimage</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">opens</span> <span class=\"n\">Y</span> <span class=\"bp\">⊆</span> <span class=\"n\">opens</span> <span class=\"n\">X</span>\n</code></pre></div>\n<p>This is saying that <code>set.image (set.preimage f)</code> is the induced map on open sets.)</p>",
        "id": 251905155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630685631
    },
    {
        "content": "<p>I find it somewhat more opaque to use <code>set.image</code> and <code>set.preimage</code> than just writing the sets out, but it's not so bad if you remind yourself what their underlying definitions are.  The benefit is that you get to use whatever lemmas mathlib already has about these sets.</p>",
        "id": 251905537,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630685767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/partial.20functions.20and.20gluing/near/251903280\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"391579\">Jake Levinson</span> I started following along with your exercise last night to see to get a better idea of what you might be running into.  I have exactly the same definition for <code>topology</code> (sets of sets seem fine to me).  Here's a notation trick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>The square brackets make it take <code>X</code> explicitly, so you can write things like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">union_mem</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">U'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">U'</span> <span class=\"bp\">∈</span> <span class=\"n\">opens</span> <span class=\"n\">X</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Wow, this is fantastic!  With that I was able to remove the implicit arguments from nearly everywhere. Thanks! One thing I still have to do is write <code>U \\in topology.opens X</code>, not <code>U \\in opens X</code> as you have. I'm not sure if there's some way to avoid that?</p>\n<p>The other changes you suggested are quite helpful and I went and implemented them all. If you're curious, the repository is here -- <a href=\"https://github.com/mguaypaq/lean-topology\">https://github.com/mguaypaq/lean-topology</a>. The stuff I posted here is in <code>topology.lean</code> and <code>bundles.lean</code>.</p>\n<p>That said, my proof of <code>fiber_map_cts_iff_res_cts</code> remains long and messy.</p>",
        "id": 251953663,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1630710823
    },
    {
        "content": "<p>To do <code>opens</code> by itself, either put the code in the <code>topology</code> namespace or do <code>open topology</code>.  This makes all the names inside <code>topology</code> available without qualification.</p>",
        "id": 251954667,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630711657
    },
    {
        "content": "<p>The set-of-sets version of <a href=\"https://github.com/mguaypaq/lean-topology/blob/main/topology.lean#L16\">this</a> is in <code>data.set.lattice</code>.  There's a predicate on finiteness in <code>data.set.finite</code> that you could use when you want to do just finite intersections (so if <code>s</code> is a set, <code>(h : s.finite)</code> would be how you indicate that you need a proof of finiteness)</p>",
        "id": 251954863,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630711803
    },
    {
        "content": "<p>Oh, I misunderstood what you are doing</p>",
        "id": 251954913,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630711837
    },
    {
        "content": "<p>It tends to be frowned upon overloading notation without using a typeclass, like <code>has_add</code> etc.)</p>",
        "id": 251954943,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630711867
    },
    {
        "content": "<p>For example, this could be <code>open_of_inter_of_finset</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sInter_mem</span> <span class=\"o\">(</span><span class=\"n\">sU</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">sU.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">sU</span> <span class=\"bp\">⊆</span> <span class=\"n\">topology.opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⋂₀</span> <span class=\"n\">sU</span> <span class=\"bp\">∈</span> <span class=\"n\">topology.opens</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">set.finite.induction_on</span> <span class=\"n\">hf</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- the h at the end effectively adds h as an additional induction hypothesis</span>\n  <span class=\"c1\">-- this would be clearer:</span>\n  <span class=\"c1\">--   revert h,</span>\n  <span class=\"c1\">--   refine set.finite.induction_on hf _ _,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">univ_mem</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">sU'</span> <span class=\"n\">hU</span> <span class=\"n\">hf</span> <span class=\"n\">h</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set.sInter_insert</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set.insert_subset</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">inter_mem</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hi.1</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hi.2</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 251955535,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630712379
    },
    {
        "content": "<p>(This also saves you from needing to worry about decidable equality.)</p>",
        "id": 251955790,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630712635
    },
    {
        "content": "<p>That's interesting, I did find the whole decidable-equality thing confusing. (I haven't actually used those finite-intersection lemmas elsewhere -- I just proved them early on, so they're at the top of the file.) I'll try to understand your solution.</p>\n<p>Incidentally -- the <code>topology.lean</code> file is super long since I just kept adding to it as I went. I guess it's probably better to split it into several smaller files at some point. (For instance the sections on interiors and closures, on continuous functions, on bases, on product and subspace topologies, etc).</p>",
        "id": 251957911,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1630714596
    },
    {
        "content": "<p>I wonder if the <code>from_sub</code> and <code>to_sub</code> lemmas can now all be removed to work directly with properties of <code>set.image</code> and <code>set.preimage</code> and <code>coe</code>. I tried doing this a little bit. I was surprised by how annoying those <code>fiber_map</code> lemmas were to prove.</p>",
        "id": 251958186,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1630714869
    }
]
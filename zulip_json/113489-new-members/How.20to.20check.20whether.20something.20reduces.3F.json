[
    {
        "content": "<p>Maybe I'm trying to do too much programming with dependent types than Lean is meant for, but I'm having some trouble figuring out which eliminators I should expect to reduce and which I shouldn't. I've been trying to figure this out experimentally with <code>#reduce</code>, but it seems like that reduces things further than the type checker will. Is there a better way to figure out how much the type checker will reduce something?</p>",
        "id": 274573555,
        "sender_full_name": "Jessie Grosen",
        "timestamp": 1646759972
    },
    {
        "content": "<p>For example (based on what I'm working with right now),</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#reduce</span> <span class=\"bp\">@</span><span class=\"n\">fin.last_cases</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>gives <code>tt</code>, but</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">fin.last_cases</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>fails...</p>",
        "id": 274574393,
        "sender_full_name": "Jessie Grosen",
        "timestamp": 1646760307
    },
    {
        "content": "<p><del>What <code>0</code> is lean inferring there?</del> nevermind, I missed the <code>@</code></p>",
        "id": 274582679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646763690
    },
    {
        "content": "<p>I believe <code>#reduce</code> uses the kernel to reduce, but the typechecker/elaborator has its own term reducer. This one takes into account the <code>reducible</code>/<code>semireducible</code>/<code>irreducible</code> visibility attributes.  With this example, I tried making everything <code>reducible</code>, but it seems to get stuck. I'm guessing it's that <code>fin.reverse_induction</code> is defined using well-founded recursion, which usually is the culprit.</p>\n<p>The expectation seems to be that you'll at some point rewrite using the equation lemmas for the definition, which you can explore with the command</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">prefix</span> <span class=\"n\">fin.reverse_induction.equations</span>\n</code></pre></div>\n<p>The <code>simp</code> tactic uses these lemmas to unfold definitions, and once this is unfolded, <code>refl</code> goes through:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">fin.last_cases</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">fin.last_cases</span><span class=\"o\">,</span> <span class=\"n\">fin.reverse_induction</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 274602490,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1646771606
    },
    {
        "content": "<p>A bit more manually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">fin.last_cases</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fin.last_cases.equations._eqn_1</span><span class=\"o\">,</span> <span class=\"n\">fin.reverse_induction.equations._eqn_1</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 274602678,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1646771683
    },
    {
        "content": "<p>However, a lot of mathlib definitions are designed to be used through an \"API\".  In this case, <code>fin.last_cases</code> has a reduction lemma for this purpose, which you can use after putting <code>0</code> into the right form.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">fin.last_cases</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">fin.last</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ fin.last_cases tt (λ (_x : fin 0), ff) (fin.last 0) = tt</span>\n  <span class=\"n\">rw</span> <span class=\"n\">fin.last_cases_last</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 274603770,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1646772182
    }
]
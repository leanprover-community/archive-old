[
    {
        "content": "<p>Hi everyone, I'm Nilay, a CS PhD student working on a project with Lean. Wow, it's tough! I'm still brand new, so please forgive any grievous mistakes.</p>\n<h2>Problem introduction</h2>\n<p>Part of the project involves redefining things a bit more explicitly. I've been working on redefining a vector space, and here's what I've got so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">vector_space_over_reals</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">smul</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span>  <span class=\"o\">:=</span> <span class=\"n\">has_smul.smul</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">has_add.add</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"bp\">+</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">add_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">has_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">has_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(I'm not worrying about generalizing it to any field yet, just sticking to ℝ  is good enough.)</p>\n<p>Here's an example instantiation for ℝ × ℝ given that it's a module:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- (ℝ × ℝ) is an ℝ-module</span>\n<span class=\"kd\">instance</span> <span class=\"n\">prod.module</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">prod.mk.inj_iff.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">add_smul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">v.fst</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">v.snd</span><span class=\"o\">⟩</span>\n  <span class=\"o\">,</span> <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩,</span> <span class=\"n\">prod.mk.inj_iff.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">module.zero_smul</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module.zero_smul</span> <span class=\"n\">y</span><span class=\"o\">⟩}</span>\n\n<span class=\"c1\">-- (ℝ × ℝ) is an ℝ-vector space</span>\n<span class=\"kd\">instance</span> <span class=\"n\">prod.is_vector_space</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">vector_space_over_reals</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n  <span class=\"o\">,</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n  <span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"n\">prod.add_comm_monoid.add_comm</span>\n  <span class=\"o\">,</span> <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">prod.module.add_smul</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n  <span class=\"o\">,</span> <span class=\"n\">has_one</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">simp</span> <span class=\"kd\">end</span>\n  <span class=\"o\">,</span> <span class=\"n\">has_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">existsi</span> <span class=\"bp\">-</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>I could be way off with these, but I hope they're at least reasonable. </p>\n<h2>Problem with subspaces</h2>\n<p>The problem happens when I try to define a subspace. This definition is based on how subsemigroups are defined in <code>mathlib</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">subspace</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space_over_reals</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">add_mem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">smul_mem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">},</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>However, I have no idea how to prove that a subspace is a vector space. This instance looks totally wrong...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">subspace_is_vector_space</span>\n  <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space_over_reals</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">carrier</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">ℝ</span> <span class=\"n\">carrier</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">carrier</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space_over_reals</span> <span class=\"n\">carrier</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">subspace</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">carrier</span>\n  <span class=\"o\">,</span> <span class=\"n\">add_mem</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"o\">,</span> <span class=\"n\">smul_mem</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>\n<h3>Reversing the definition</h3>\n<p>It would be way more helpful for me if I could define it the other way around:</p>\n<ul>\n<li><code>definition: a subset U of a vector space V is a subspace if U is also a vector space</code></li>\n<li><code>theorem: if a subset U of a vector space V is closed under addition and scalar multiplication, it's a subspace</code></li>\n</ul>\n<p>I tried doing this but got nowhere, fast. My attempt was basically trying to define a subtype:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and try to build the definition of subspace from that. Unfortunately I don't have the attempt saved anymore, but could something like this work? I feel like subtypes are the right thing to use in a type-theory-based language, but my brain is hard-wired for sets still.</p>\n<h2>Summary:</h2>\n<ul>\n<li>Is my definition for <code>vector_space_over_reals</code> a good one? Is there anything I can do to improve it?</li>\n<li>Is my definition for <code>subspace</code> correct? If it is, how do I even begin proving <code>add_mem</code> and <code>smul_mem</code>? I tried for a bit and got nowhere.</li>\n<li>Is it possible to reverse the definitions for subspace? That is, start with \"a subspace is a vector space\", and then show if a subset is closed under add/smul then it's a vector space?</li>\n<li>Can I define a subspace as a vector space over a subtype, where the subtype is just restricted to a particular set?</li>\n</ul>\n<p>Any and all help is very much appreciated, thanks in advance!</p>",
        "id": 312977192,
        "sender_full_name": "Nilay Patel",
        "timestamp": 1669776881
    },
    {
        "content": "<p>Your translation of \"a subspace is a vector space\" is wrong. Currently, it rather reads \"A vector space structure over a random set of a vector space gives a vector subspace\", which is most definitely wrong (the two vector space structures can be completely unrelated).</p>",
        "id": 312978344,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669777838
    },
    {
        "content": "<p>Also note that <code>[has_smul ℝ V] [module ℝ V]</code> gives two (possibly different) meanings to <code>r • v</code>.</p>",
        "id": 312978413,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669777916
    },
    {
        "content": "<p>What you rather want is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_smul</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">vector_space_over_reals</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">subspace</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subspace.add_comm_monoid</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">S.carrier</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subspace.has_smul</span> <span class=\"o\">:</span> <span class=\"n\">has_smul</span> <span class=\"n\">ℝ</span> <span class=\"n\">S.carrier</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subspace.vector_space_over_reals</span> <span class=\"o\">:</span> <span class=\"n\">vector_space_over_reals</span> <span class=\"n\">S.carrier</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 312978559,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1669778039
    },
    {
        "content": "<blockquote>\n<p>Currently, it rather reads \"A vector space structure over a random set of a vector space gives a vector subspace\", which is most definitely wrong (the two vector space structures can be completely unrelated).</p>\n</blockquote>\n<p>Right, that makes sense. I've copied your fix, but one thing is a bit unclear:</p>\n<blockquote>\n<p><code>instance subspace.vector_space_over_reals : vector_space_over_reals S.carrier := sorry</code></p>\n</blockquote>\n<p>Since <code>S.carrier</code> is a particular set of the type <code>set V</code>, is <code>vector_space_over_reals S.carrier</code> constructing a vector space structure over the set <code>S.carrier</code>? And if so, is Lean automatically converting the set <code>S.carrier</code> into a type? Can I then use it like <code>let x : S.carrier</code> or something?</p>\n<p>Thanks again Yaël.</p>",
        "id": 312987866,
        "sender_full_name": "Nilay Patel",
        "timestamp": 1669785052
    },
    {
        "content": "<p>Yes, a <code>set</code> can be automatically treated as a type via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.has_coe_to_sort\">docs#set.has_coe_to_sort</a></p>",
        "id": 312988577,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669785499
    },
    {
        "content": "<p>Thank you Junyan!</p>",
        "id": 312988884,
        "sender_full_name": "Nilay Patel",
        "timestamp": 1669785696
    },
    {
        "content": "<p>In <code>prod.module</code> the assumption <code>[module \\R \\R]</code> means \"let the reals be given a totally random vector space structure over the reals\" (so eg 2 \\bub 1 could be 37), which is probably not what you want.</p>",
        "id": 313000380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1669793161
    },
    {
        "content": "<p>Also, <code>smul := default</code> does not use your default from earlier, it sets <code>a • b = default = 0</code> everywhere</p>",
        "id": 313007896,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669796757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/.28re.29defining.20vector.20spaces.20while.20allowing.20for.20subspaces/near/313000380\">said</a>:</p>\n<blockquote>\n<p>In <code>prod.module</code> the assumption <code>[module \\R \\R]</code> means \"let the reals be given a totally random vector space structure over the reals\" (so eg 2 \\bub 1 could be 37), which is probably not what you want.</p>\n</blockquote>\n<p>So instead, I should be instantiating a specific module structure for <code>module \\R \\R</code> and then removing the assumption?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">real.is_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">prod.is_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 313134588,
        "sender_full_name": "Nilay Patel",
        "timestamp": 1669835443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/.28re.29defining.20vector.20spaces.20while.20allowing.20for.20subspaces/near/313007896\">said</a>:</p>\n<blockquote>\n<p>Also, <code>smul := default</code> does not use your default from earlier, it sets <code>a • b = default = 0</code> everywhere</p>\n</blockquote>\n<p>Fascinating...not sure I totally understand. Where is the <code>default</code> coming from then? Is that from a different typeclass?</p>",
        "id": 313134665,
        "sender_full_name": "Nilay Patel",
        "timestamp": 1669835482
    },
    {
        "content": "<p><code>default</code> is from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inhabited\">docs#inhabited</a>, which the real numbers implement.</p>",
        "id": 313135175,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669835654
    },
    {
        "content": "<p>right here: <a href=\"https://github.com/leanprover-community/mathlib/blob/83871f6cff322a1eafaa382ef70e9515fe240abd/src/data/real/basic.lean#L152\">https://github.com/leanprover-community/mathlib/blob/83871f6cff322a1eafaa382ef70e9515fe240abd/src/data/real/basic.lean#L152</a></p>",
        "id": 313135238,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669835683
    },
    {
        "content": "<p>Ah I see. Thanks!</p>",
        "id": 313135516,
        "sender_full_name": "Nilay Patel",
        "timestamp": 1669835788
    },
    {
        "content": "<p>So going back to one of my initial questions:</p>\n<blockquote>\n<p>It would be way more helpful for me if I could define it the other way around:</p>\n<ul>\n<li><code>definition: a subset U of a vector space V is a subspace if U is also a vector space</code></li>\n<li><code>theorem: if a subset U of a vector space V is closed under addition and scalar multiplication, it's a subspace</code></li>\n</ul>\n</blockquote>\n<p>I've been working on this a little, and this is what I came up with so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">subspace'</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- given a vector space structure on V</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">parent_space</span> <span class=\"o\">:</span> <span class=\"n\">real_vector_space</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- a subspace is a subset that also has a vector space structure</span>\n  <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">is_monoid</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">carrier</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">carrier</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_vector_space</span> <span class=\"o\">:</span> <span class=\"n\">real_vector_space</span> <span class=\"n\">carrier</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ... and has the same smul/add operations as V</span>\n  <span class=\"o\">(</span><span class=\"n\">same_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">is_vector_space.smul</span> <span class=\"n\">r</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">parent_space.smul</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">same_add</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"bp\">+</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I'm interpreting this definition as: \"Given a vector space on <code>V</code>, a <em>subspace</em> is a subset <code>carrier</code> which itself has a vector space structure whose <code>smul</code> and <code>add</code> operations are the same as <code>V</code>'s <code>smul</code> and <code>add</code>.</p>\n<p>Is this right, or am I misinterpreting? </p>\n<p>I tried just doing <code>(same_smul : is_vector_space.smul = parent_space.smul)</code> but of course the types don't exactly line up. Maybe there's something more concise along those lines...</p>\n<p>Thanks yet again, you've all been very helpful.</p>",
        "id": 313387017,
        "sender_full_name": "Nilay Patel",
        "timestamp": 1669932268
    },
    {
        "content": "<p>you <em>might</em> need a <code>same_zero</code> field too unless you can prove that from the other fields. That approach looks like it ought to work, but it's a rather strange design still.</p>",
        "id": 313393710,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669934820
    },
    {
        "content": "<p>Can you show the latest version of <code>real_vector_space</code> too?</p>",
        "id": 313393738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669934832
    },
    {
        "content": "<p>The <code>:=</code>s in the fields should be <code>:</code>s.</p>",
        "id": 313440081,
        "sender_full_name": "Reid Barton",
        "timestamp": 1669966004
    }
]
[
    {
        "content": "<p>I have a collection of proofs (I previously posted about this) that show which elements of dihedral groups can and can't be central. Part of that shows that rotation elements of order at most 2 necessarily commute with all rotations and with all reflections. Now, I know that this means that these elements are central, because every element of the group is of this form. However, I realized that just having these proofs and saying that they imply centrality might be a bit of a handwave. Therefore, it would be beneficial to have a proof explicitly stating that these elements belong to the center, which would be done by providing a proof that, for any given <code>x : dihedral_group n</code> term, that these elements commute with <code>x</code>. The conceptual problem I'm having is how to extend a result of my form to one involving an arbitrary element. The group multiplication of <code>dihedral_group n</code> is defined in a way that is divided into a collection of cases, such as <code>r i * r j</code>, <code>sr i * r j</code>, etc.  How can I get a result about whether two products of group elements are equal if the way they are computed is left up in the air?</p>\n<p>For reference, here are the relevant pieces of code that show commutation for the individual cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.specific_groups.dihedral</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Rotations with order at most 2 commute with all rotations.</span>\n<span class=\"sd\">`i` is any `zmod n` term satisfying `2 * i = 0`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">r_mem_center_r</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"n\">j</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Rotations with order at most 2 commute with all reflections.</span>\n<span class=\"sd\">`i` is any `zmod n` term satisfying `2 * i = 0`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">r_mem_center_sr</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">sr</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">sr</span> <span class=\"n\">j</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_add_neg</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_eq_zero_iff_neg_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">two_mul</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 239425679,
        "sender_full_name": "Alex Griffin",
        "timestamp": 1621431643
    },
    {
        "content": "<p>Can you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of a <code>sorry</code> which you'd like to see filled, rather than just asking a maths question?</p>",
        "id": 239427038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621432149
    },
    {
        "content": "<p>I think you're looking for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">r_mem_center</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">dihedral_group</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now this is easy</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 239429679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621433089
    },
    {
        "content": "<p>Ah, did not realize that <code>cases</code> would work like that. That makes sense. Thank you very much, that did the trick.</p>",
        "id": 239431104,
        "sender_full_name": "Alex Griffin",
        "timestamp": 1621433593
    },
    {
        "content": "<p>Once you do that, I'd recommend you try to fit this into the mathlib structures</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- this stuff should be in mathlib but isn't</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">subgroup</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">S</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">is_scalar_tower_right</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_scalar_tower</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">subgroup</span>\n</code></pre></div>\n<p>I've left the sorries for you to solve for practice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dihedral_group.center</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">dihedral_group</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"n\">i</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"o\">(</span><span class=\"n\">dihedral_group.center</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dihedral_group</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dihedral_group</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul_comm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>With these instances, you can now use lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smul_mul_assoc\">docs#smul_mul_assoc</a></p>",
        "id": 239431144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621433606
    },
    {
        "content": "<p>Yes, I was going to get to that after I'd teased out a MWE :-) Actually making the definition of the centre is more useful than proving a theorem saying precisely which elements are in the centre</p>",
        "id": 239431420,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621433688
    },
    {
        "content": "<p>I think the mathlib definition of \"center\" is implicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[class]</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">subgroup.is_center</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">S</span> <span class=\"n\">G</span> <span class=\"n\">G</span>\n</code></pre></div>",
        "id": 239431664,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621433767
    },
    {
        "content": "<p>But I guess for that definition to make sense you need the other two instances I defined above that aren't in mathlib yet</p>",
        "id": 239432067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621433909
    },
    {
        "content": "<p>PR'd more general version of those instances as <a href=\"https://github.com/leanprover-community/mathlib/issues/7665\">#7665</a></p>",
        "id": 239437875,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621435854
    },
    {
        "content": "<p>Ok, everything in the \"this stuff should be in mathlib but isn't\" code block above is now in mathlib</p>",
        "id": 240363395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622051371
    }
]
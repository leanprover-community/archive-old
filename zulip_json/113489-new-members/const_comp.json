[
    {
        "content": "<p>Suppose that, in a proof, I find the following (<code>{A : Type*} {B : Type*} {C : Type*} (c : C) (f : A → B)</code>)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span>\n</code></pre></div>\n\n\n<p>in the goal. Simp does not simplify it to <code>(λ a : A, c)</code>. Library_search does not find an existing lemma for this but tells me it is true by rfl. In order to simplify it, should I define a lemma</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_const</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n\n\n<p>or am I supposed to use some kind of tactic that simplifies things true by definition that I am not aware of?</p>",
        "id": 201529101,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592736566
    },
    {
        "content": "<p>Have you tried <code>dsimp</code> ?</p>",
        "id": 201529162,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592736688
    },
    {
        "content": "<p>Yeah and it does not work as much as simp (even if I am not sure when I should try simp and when dsimp)</p>",
        "id": 201529243,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592736824
    },
    {
        "content": "<p>I am certainly not an expert in <code>simp</code> but I will note that proving lemmas with <code>rfl</code> because <code>simp</code> needs to know about them is certainly not uncommon in the library -- it <a href=\"https://github.com/leanprover-community/mathlib/blob/8729fe211ebd7f2b40924e0f5ff0f6b5b1e56695/src/data/complex/basic.lean#L67-L77\">happens all the time in data.complex.basic</a> for example.</p>",
        "id": 201531121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592740311
    },
    {
        "content": "<p>The difference between <code>simp</code> and <code>dsimp</code> is that <code>dsimp</code> will only apply <code>simp</code> lemmas whose proof is <code>rfl</code>, so it preserves definitional equality, whereas <code>simp</code> is just a general confluent rewriting system; it will know <code>add_zero</code> and <code>zero_add</code>, even though (at least on <code>nat</code>) only one of these is definitional.</p>",
        "id": 201531172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592740406
    },
    {
        "content": "<p>Oh just throwing random ideas, but sometimes unfolding <code>function.comp</code> helps with tactics.</p>",
        "id": 201531290,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592740592
    },
    {
        "content": "<p>We can only help you if you provide an actual <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>",
        "id": 201531940,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592741868
    },
    {
        "content": "<p>In general <code>∘</code> is not used heavily, so it doesn't surprise me much that this lemma would be absent</p>",
        "id": 201538213,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592752271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201531940\">said</a>:</p>\n<blockquote>\n<p>We can only help you if you provide an actual <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>\n</blockquote>\n<p>Well my question was a general question about rfl lemmas, I am not interested specifically in this example, but if you want to try this case any toy example should work (I do not include my original proof because it is exagerately complicated to illustrate this example), for instance:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">const_comp</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_const</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> Seems not to work for me without the lemmas above -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_const</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 201538861,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592753107
    },
    {
        "content": "<p>Lean works best if you keep things simple so Lean has less trouble working out what to unfold and what to leave alone. f \\circ g can be expressed as <code>lam x, f(g(x))</code> and probably the latter is preferred because more primitive notions are involved.</p>",
        "id": 201538914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592753184
    },
    {
        "content": "<p>The easier way is just to eliminate function composition, like Kevin suggests</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[(</span><span class=\"err\">∘</span><span class=\"o\">)],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_const</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 201538994,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592753296
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_const</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 201538996,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1592753299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201538996\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_const</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>I tried <code>dsimp</code> before and it does not work for me! Are you including any import other than <code>topology.basic</code>?</p>",
        "id": 201539105,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592753420
    },
    {
        "content": "<p>One option here would be to get lazy people to PR their stuff, for instance <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/for_mathlib/topology.lean#L36-L39\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/for_mathlib/topology.lean#L36-L39</a></p>",
        "id": 201539166,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592753503
    },
    {
        "content": "<p>Another option is to fix some stupid binders in mathlib</p>",
        "id": 201539209,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592753552
    },
    {
        "content": "<p>In the mean time you can use the proof term <code>@continuous_const _ _ _ _ b,</code> (without any tactic)</p>",
        "id": 201539237,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592753616
    },
    {
        "content": "<p>A priori having <code>b</code> implicit in <code>continuous_const</code> goes against all rules. But indeed it is tempting since it's almost always clear from context.</p>",
        "id": 201539290,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592753675
    },
    {
        "content": "<p>I feel like it would actually be easy to improve the unifier to handle this problem</p>",
        "id": 201539295,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592753686
    },
    {
        "content": "<p>Of course improving elaboration could also solve this issue, but it's a different game</p>",
        "id": 201539310,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592753715
    },
    {
        "content": "<p>In case my messages are unclear, I mean:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">continuous_of_const</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">continuous</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">is_open_const</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n  <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">fa</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">fb</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">▸</span> <span class=\"n\">fb</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">continuous_const</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">continuous_of_const</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 201539359,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592753821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201538994\">said</a>:</p>\n<blockquote>\n<p>The easier way is just to eliminate function composition, like Kevin suggests</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[(</span><span class=\"err\">∘</span><span class=\"o\">)],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">continuous_const</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>Ok thanks this makes sense! I mean sometimes compositions (as \\circ) just appear in proofs themselves alone without me ever defining something with them (meaning something is defined in terms of them in Mathlib), so I was really looking for a method that works when compositions appear and I guess this would be a standard way to get rid of \\circs</p>",
        "id": 201539361,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592753824
    },
    {
        "content": "<p>This is very sad for mathematicians, but Lean doesn't really like composition.</p>",
        "id": 201539369,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592753866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201539237\">said</a>:</p>\n<blockquote>\n<p>In the mean time you can use the proof term <code>@continuous_const _ _ _ _ b,</code> (without any tactic)</p>\n</blockquote>\n<p>This also works but I feel like <code>simp [(∘)]</code> is more scalable (for example in my original proof I did not have a tactic that could close the goal immediately and I just needed to simplify a very complicated expression)</p>",
        "id": 201539417,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592753919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267205\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201538861\">said</a>:</p>\n<blockquote>\n<p>Patrick Massot <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201531940\">said</a>:</p>\n<blockquote>\n<p>We can only help you if you provide an actual <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>\n</blockquote>\n<p>Well my question was a general question about rfl lemmas, I am not interested specifically in this example, but if you want to try this case any toy example should work (I do not include my original proof because it is exagerately complicated to illustrate this example), for instance:</p>\n</blockquote>\n<p>Did you notice the effect  of posting a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 201539562,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1592754128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267205\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201539105\">said</a>:</p>\n<blockquote>\n<p>I tried <code>dsimp</code> before and it does not work for me! Are you including any import other than <code>topology.basic</code>?</p>\n</blockquote>\n<p>I am not able to reproduce what I did. And indeed it doesn't work!</p>",
        "id": 201539694,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1592754393
    },
    {
        "content": "<p>Note the effect of not posting a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>...</p>",
        "id": 201539754,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592754487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201539754\">said</a>:</p>\n<blockquote>\n<p>Note the effect of not posting a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>...</p>\n</blockquote>\n<p>I am confused! Why is what I posted not a mwe?</p>",
        "id": 201539970,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592754901
    },
    {
        "content": "<p>did you read the definition at the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> link? Ah I see you eventually posted working code</p>",
        "id": 201540060,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1592754995
    },
    {
        "content": "<p>Was replying to Sebastien.</p>",
        "id": 201540067,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592755014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540067\">said</a>:</p>\n<blockquote>\n<p>Was replying to Sebastien.</p>\n</blockquote>\n<p>Oh ok sorry!</p>",
        "id": 201540079,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540060\">said</a>:</p>\n<blockquote>\n<p>did you read the definition at the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> link?</p>\n</blockquote>\n<p>Yes I did! I believe it was a mwe...</p>",
        "id": 201540101,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755074
    },
    {
        "content": "<p>Less interesting that the working example with <code>simp</code>, but in this case you can simply replace it with <code>unfold function.comp</code></p>",
        "id": 201540155,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592755114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201539694\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"267205\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201539105\">said</a>:</p>\n<blockquote>\n<p>I tried <code>dsimp</code> before and it does not work for me! Are you including any import other than <code>topology.basic</code>?</p>\n</blockquote>\n<p>I am not able to reproduce what I did. And indeed it doesn't work!</p>\n</blockquote>\n<p>Maybe it was because you did not comment out the two simp lemmas I wrote and dsimp used them!</p>",
        "id": 201540172,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267205\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540101\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540060\">said</a>:</p>\n<blockquote>\n<p>did you read the definition at the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> link?</p>\n</blockquote>\n<p>Yes I did! I believe it was a mwe...</p>\n</blockquote>\n<p>patrick was trying to point out that your first post didn't have working code, so you got imprecise answers, and then when you eventually posted working code, ou got more precise answers. I think patrick was trying to suggest that you should <em>start</em> with a working example in the future</p>",
        "id": 201540179,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1592755161
    },
    {
        "content": "<p>I actually tend to unfold <code>function.comp</code> really often because composition really blocks things sometimes</p>",
        "id": 201540195,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592755188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540179\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"267205\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540101\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540060\">said</a>:</p>\n<blockquote>\n<p>did you read the definition at the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> link?</p>\n</blockquote>\n<p>Yes I did! I believe it was a mwe...</p>\n</blockquote>\n<p>patrick was trying to point out that your first post didn't have working code, so you got imprecise answers, and then when you eventually posted working code, ou got more precise answers. I think patrick was trying to suggest that you should <em>start</em> with a working example in the future</p>\n</blockquote>\n<p>He wasn't replying to Patrick's post I think</p>",
        "id": 201540254,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592755232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201540195\">said</a>:</p>\n<blockquote>\n<p>I actually tend to unfold <code>function.comp</code> really often because composition really blocks things sometimes</p>\n</blockquote>\n<p>Ok thanks I will keep this in mind!</p>",
        "id": 201540602,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755354
    },
    {
        "content": "<p>It's surprising -- function.comp seems like a really natural thing, but it's just adding some \"extra step\" which Lean then has to unravel. This sort of phenomenon shows up everywhere. We like to package things up because it makes stuff neater, but not too much because how does Lean know what to unpack? It's not so obvious. Say Lean has a question about the real numbers. Should it unfold the definition of the real numbers and consider the equivalence class of Cauchy sequences? Almost certainly not! But should it unfold function composition? Maybe, maybe not. Humans are so good at this sort of thing. Machines are quite dumb. A lot of effort has gone into giving users access to various ways to give Lean hints about what to unfold when but it's still a hard problem.</p>",
        "id": 201541236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592755557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201541236\">said</a>:</p>\n<blockquote>\n<p>It's surprising -- function.comp seems like a really natural thing, but it's just adding some \"extra step\" which Lean then has to unravel. This sort of phenomenon shows up everywhere. We like to package things up because it makes stuff neater, but not too much because how does Lean know what to unpack? It's not so obvious. Say Lean has a question about the real numbers. Should it unfold the definition of the real numbers and consider the equivalence class of Cauchy sequences? Almost certainly not! But should it unfold function composition? Maybe, maybe not. Humans are so good at this sort of thing. Machines are quite dumb. A lot of effort has gone into giving users access to various ways to give Lean hints about what to unfold when but it's still a hard problem.</p>\n</blockquote>\n<p>Is it not possible to modify <code>simp</code> so that it always unfolds composition when it sees it?</p>",
        "id": 201541536,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755658
    },
    {
        "content": "<p>It is possible but is it a good idea?</p>",
        "id": 201541620,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592755695
    },
    {
        "content": "<p>If you always want to unfold composition in <code>simp</code> then why not just write the unfolded version in the first place?</p>",
        "id": 201541631,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592755711
    },
    {
        "content": "<p>then you also handle situations where you don't use simp</p>",
        "id": 201541636,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592755725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201541631\">said</a>:</p>\n<blockquote>\n<p>If you always want to unfold composition in <code>simp</code> then why not just write the unfolded version in the first place?</p>\n</blockquote>\n<p>Because it's much harder to read long statement full of lambda expressions for a mathematician when it is easier to read it with compositions!</p>",
        "id": 201541658,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755781
    },
    {
        "content": "<p>II mean composition is easier to process instantaneously for humans</p>",
        "id": 201541707,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755810
    },
    {
        "content": "<p>And it makes statements more elegant and more symmetric being similar to a group operation as far as notation is concerned</p>",
        "id": 201541723,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592755867
    },
    {
        "content": "<p>If you want to put <code>\\circ</code> into results because you think it adds to readability, then just start your proofs with <code>simp only [(\\circ)]</code>.</p>",
        "id": 201541726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592755875
    },
    {
        "content": "<p>at some point you have to bridge the gap between what a human can read and what a computer can read</p>",
        "id": 201541786,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1592755941
    },
    {
        "content": "<p>The whole <code>simp</code> theory is very well-understood by computer scientists, it goes under the name of confluent rewriting systems. One idea is that things should be in some kind of normal form. Normal forms are decided, perhaps by computer scientists. At some point it was decided that function.comp wasn't part of the story. From a mathematician's perspective some of these decisions can be difficult to understand, especially if you're focussed on human-readability (and if you've looked at some of mathlib you'll know that not everyone here is). But <code>simp</code> is an amazing tool, and as someone who doesn't understand it I just accept how it's set up and learn how to use it. Perhaps an even better approach would be to understand it properly and then try and figure out how to add function.comp to the picture.</p>",
        "id": 201541855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592756054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201531172\">said</a>:</p>\n<blockquote>\n<p>The difference between <code>simp</code> and <code>dsimp</code> is that <code>dsimp</code> will only apply <code>simp</code> lemmas whose proof is <code>rfl</code>, so it preserves definitional equality, whereas <code>simp</code> is just a general confluent rewriting system; it will know <code>add_zero</code> and <code>zero_add</code>, even though (at least on <code>nat</code>) only one of these is definitional.</p>\n</blockquote>\n<p>Do you know if there is a way to get the output of <code>dsimp</code> as with <code>squeeze_simp</code> for <code>simp</code>?</p>",
        "id": 201542642,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592757423
    },
    {
        "content": "<p>(I would guess squeeze_simp should produce it but it happened to me in the past that <code>dsimp</code> did something when <code>simp</code> could not do anything: I cannot easily ricreate a mwe of this right now but I can try to do it if you have no idea about what I am talking about)</p>",
        "id": 201543196,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592758300
    },
    {
        "content": "<p>I don't think there's a squeeze_dsimp. Note however that if <code>dsimp</code> changes your goal to <code>X</code> then you can replace the call to <code>dsimp</code> with <code>change X</code> or <code>show X</code> (they are the same), because change and show will change a goal from Y to X if Y and X are definitionally equivalent.</p>",
        "id": 201543603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592758917
    },
    {
        "content": "<p>You could also use the trace output for simplify to get this, but I also do what Kevin suggests here</p>",
        "id": 201543948,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1592759515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/113489-new-members/topic/const_comp/near/201543948\">said</a>:</p>\n<blockquote>\n<p>You could also use the trace output for simplify to get this, but I also do what Kevin suggests here</p>\n</blockquote>\n<p>Thanks! What is the syntax for this?</p>",
        "id": 201544527,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1592760486
    },
    {
        "content": "<p><code>set_option trace.simplify true</code> or <code>set_option trace.simplify.rewrite true</code> for just the successful rewrites. See <a href=\"https://leanprover-community.github.io/extras/simp.html\">https://leanprover-community.github.io/extras/simp.html</a></p>",
        "id": 201546996,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592764087
    }
]
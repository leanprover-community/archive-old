[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">natural</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">natural</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">natural</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"o\">:=</span>\n<span class=\"n\">natural</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span> <span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">pred_n</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">natural</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span> <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">02</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">15</span>   <span class=\"mi\">3</span> <span class=\"n\">error</span>           <span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n   <span class=\"n\">plus</span>\n <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">natural</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">02</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">15</span>  <span class=\"mi\">10</span> <span class=\"n\">error</span>           <span class=\"n\">ill</span><span class=\"bp\">-</span><span class=\"n\">formed</span> <span class=\"k\">match</span><span class=\"bp\">/</span><span class=\"n\">equation</span> <span class=\"n\">expression</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">02</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">16</span>   <span class=\"mi\">3</span> <span class=\"n\">error</span>           <span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n   <span class=\"n\">plus</span>\n <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">natural</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">02</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">17</span>   <span class=\"mi\">3</span> <span class=\"n\">error</span>           <span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n   <span class=\"n\">plus</span>\n <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">natural</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">02</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">17</span>  <span class=\"mi\">10</span> <span class=\"n\">error</span>           <span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n   <span class=\"n\">plus</span>\n <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">natural</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190786613,
        "sender_full_name": "Iocta",
        "timestamp": 1584396786
    },
    {
        "content": "<p>What's wrong?</p>",
        "id": 190786656,
        "sender_full_name": "Iocta",
        "timestamp": 1584396820
    },
    {
        "content": "<p>looks like it wants a function in those <code>_</code>s, but why/which function?</p>",
        "id": 190786989,
        "sender_full_name": "Iocta",
        "timestamp": 1584397034
    },
    {
        "content": "<p>Stuff to the left of the colon like <code>(m n : natural)</code> doesn't participate in the pattern match. You need to write <code>def plus : natural -&gt; natural -&gt; natural | ...</code></p>",
        "id": 190787177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584397146
    },
    {
        "content": "<p>That stuff is also fixed/implicitly passed to the recursive call, which is why Lean is saying that <code>plus</code> is not a function</p>",
        "id": 190787231,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584397193
    },
    {
        "content": "<p>Moving the arguments to the right of the colon will fix that as well.</p>",
        "id": 190787301,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584397208
    },
    {
        "content": "<p>ok that's progress</p>",
        "id": 190787460,
        "sender_full_name": "Iocta",
        "timestamp": 1584397340
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">plus</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>now it wants <code>⊢ natural.sizeof (pred a) &lt; natural.sizeof a</code> which I guess makes sense</p>",
        "id": 190787783,
        "sender_full_name": "Iocta",
        "timestamp": 1584397573
    },
    {
        "content": "<p>Don't use <code>pred a</code> like that</p>",
        "id": 190787819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584397604
    },
    {
        "content": "<p>have a case for <code>succ a</code> and use <code>a</code></p>",
        "id": 190787829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584397615
    },
    {
        "content": "<p>(<code>pred a</code> is not smaller than <code>a</code> when <code>a = 0</code>, and Lean doesn't \"know\" that <code>a</code> is not equal to <code>0</code> in the last case. Plus this definition would be awkward to prove things about anyways.)</p>",
        "id": 190787879,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584397654
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">plus</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190787881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584397654
    },
    {
        "content": "<p>yeah that works</p>",
        "id": 190787903,
        "sender_full_name": "Iocta",
        "timestamp": 1584397676
    },
    {
        "content": "<p>(the first case is unnecessary)</p>",
        "id": 190787969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584397702
    },
    {
        "content": "<p>mhmm</p>",
        "id": 190788002,
        "sender_full_name": "Iocta",
        "timestamp": 1584397736
    },
    {
        "content": "<p>What's happening with the scope in <code> | here :=</code>? looks like it's referencing <code>zero</code> and <code>succ</code> but also defining <code>a</code> and <code>b</code>.</p>",
        "id": 190788387,
        "sender_full_name": "Iocta",
        "timestamp": 1584397995
    },
    {
        "content": "<p>iow, how does it know whether to bind a name or reference a name?</p>",
        "id": 190788467,
        "sender_full_name": "Iocta",
        "timestamp": 1584398052
    },
    {
        "content": "<p>perhaps it's just \"define a name unless it's already defined, then use it\"?</p>",
        "id": 190788725,
        "sender_full_name": "Iocta",
        "timestamp": 1584398228
    },
    {
        "content": "<p>it's a pattern</p>",
        "id": 190788750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584398255
    },
    {
        "content": "<p>you can use the names of constructors, but everything else becomes a new bound variable</p>",
        "id": 190788762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584398274
    },
    {
        "content": "<p>it helps here if you have ever used a functional programming language with pattern matching capabilities</p>",
        "id": 190788844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584398319
    },
    {
        "content": "<p>I see, <code>| a succ := succ</code> doesn't rebind <code>succ</code> because <code>succ</code> is a constructor</p>",
        "id": 190788990,
        "sender_full_name": "Iocta",
        "timestamp": 1584398434
    },
    {
        "content": "<p>but given <code>def foo := 5</code> I can rebind \"foo\" with <code>| a foo := foo</code></p>",
        "id": 190789031,
        "sender_full_name": "Iocta",
        "timestamp": 1584398480
    },
    {
        "content": "<p>because <code>foo</code> isn't a constructor of <code>natural</code></p>",
        "id": 190789060,
        "sender_full_name": "Iocta",
        "timestamp": 1584398502
    },
    {
        "content": "<p>right?</p>",
        "id": 190789122,
        "sender_full_name": "Iocta",
        "timestamp": 1584398523
    },
    {
        "content": "<p>I mean like </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span>\n\n<span class=\"n\">def</span> <span class=\"n\">plus</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190789196,
        "sender_full_name": "Iocta",
        "timestamp": 1584398584
    },
    {
        "content": "<p>ok this makes sense</p>",
        "id": 190789249,
        "sender_full_name": "Iocta",
        "timestamp": 1584398626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253355\">Iocta</span> <a href=\"#narrow/stream/113489-new-members/topic/(no.20topic)/near/190788725\" title=\"#narrow/stream/113489-new-members/topic/(no.20topic)/near/190788725\">said</a>:</p>\n<blockquote>\n<p>perhaps it's just \"define a name unless it's already defined, then use it\"?</p>\n</blockquote>\n<p>Yes. To be fair, this is different from how it works in Haskell; I don't remember what ML-family languages do here</p>",
        "id": 190789637,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584398943
    },
    {
        "content": "<p>You actually have to be a bit careful here because if the constructor is in a namespace, then lean will interpret it as a variable instead. The following defines the constant <code>A</code> function, not the identity function:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">B</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">B</span> <span class=\"c1\">-- equation compiler error, equation #2 has not been used in the compilation, note that the left-hand-side of equation #1 is a variable</span>\n</pre></div>",
        "id": 190789742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584399017
    },
    {
        "content": "<p>the identity function is actually this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">B</span>\n</pre></div>",
        "id": 190789785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584399069
    },
    {
        "content": "<p>wait I'm confused, isn't your example also the identity function, but for the wrong reason?</p>",
        "id": 190789813,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584399089
    },
    {
        "content": "<p>aha, you're right</p>",
        "id": 190789832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584399105
    },
    {
        "content": "<p>if I had <code>| A := foo.A</code> it would be the constant function but that's too obvious</p>",
        "id": 190789885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584399125
    },
    {
        "content": "<p><code>| A := B</code> and <code>| B := A</code> would make the issue more clear since on the first line you would get \"unknown identifier 'B'\"</p>",
        "id": 190789934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584399174
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">natural</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">natural</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">natural</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"o\">:=</span>\n<span class=\"n\">natural</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span> <span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">pred_n</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span> <span class=\"bp\">→</span> <span class=\"n\">natural</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n\n<span class=\"kn\">theorem</span> <span class=\"n\">add_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">),</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">zero_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">),</span> <span class=\"n\">add</span> <span class=\"n\">zero</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">succ_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">),</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">add</span>\n\n\n<span class=\"kn\">theorem</span> <span class=\"n\">add_succ</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">),</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>How do I fill the <code>sorry</code>?</p>",
        "id": 190806168,
        "sender_full_name": "Iocta",
        "timestamp": 1584417382
    },
    {
        "content": "<p><code>succ_add</code> should be provable by <code>rfl</code></p>",
        "id": 190807960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584420169
    },
    {
        "content": "<p><code>add_succ</code> can be proven similar to <code>zero_add</code></p>",
        "id": 190807967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584420213
    },
    {
        "content": "<p>(your names for <code>succ_add</code> and <code>add_succ</code> appear reversed)</p>",
        "id": 190807973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584420238
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">succ_add</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">),</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_succ</span><span class=\"o\">,</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">succ_add</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>works. I didn't expect to be able to access <code>succ_add</code> in the <code>rw</code>, but apparently that's ok</p>",
        "id": 190809433,
        "sender_full_name": "Iocta",
        "timestamp": 1584422583
    },
    {
        "content": "<p>it's because you are using the equation compiler to write the theorem. It's just like when you used <code>add</code> in the second clause for the definition of <code>add</code></p>",
        "id": 190811902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584426794
    },
    {
        "content": "<p>If you attempted to use <code>succ_add</code> in the wrong way to make a circular proof, the equation compiler would complain about nontermination</p>",
        "id": 190811919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584426830
    },
    {
        "content": "<p>ok</p>",
        "id": 190812621,
        "sender_full_name": "Iocta",
        "timestamp": 1584427909
    },
    {
        "content": "<p>The equation compiler is just a glorified <code>rec</code></p>",
        "id": 190818404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584433777
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">),</span> <span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">succ_add</span><span class=\"o\">,</span> <span class=\"n\">succ_add</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>proves the same point as </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">natural</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">natural</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span>\n<span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span> <span class=\"o\">])</span>\n<span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">natural</span><span class=\"o\">)</span> <span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">ih</span><span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"k\">calc</span>\n    <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">ih</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">apply</span> <span class=\"n\">succ_add</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>but in a different style. Can lean tell that these are similar, or can I convince it that they are?</p>",
        "id": 190911641,
        "sender_full_name": "Iocta",
        "timestamp": 1584479682
    },
    {
        "content": "<p>given one of them, can it generate the other in case I want to see the <code>calc</code> version?</p>",
        "id": 190911837,
        "sender_full_name": "Iocta",
        "timestamp": 1584479800
    },
    {
        "content": "<p>more generally, given a tactic proof can it generate a term proof?</p>",
        "id": 190911999,
        "sender_full_name": "Iocta",
        "timestamp": 1584479891
    },
    {
        "content": "<p>You can see the term that Lean generates from a tactic proof with <code>#print add_comm</code>.</p>",
        "id": 190912515,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584480204
    },
    {
        "content": "<p>Oh neat</p>",
        "id": 190913771,
        "sender_full_name": "Iocta",
        "timestamp": 1584480860
    },
    {
        "content": "<p>Would it be hard to write a function that transforms that output into a <code>calc</code>-based proof?</p>",
        "id": 190914211,
        "sender_full_name": "Iocta",
        "timestamp": 1584481136
    },
    {
        "content": "<p>It's certainly too hard for me to do.</p>",
        "id": 190915391,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584481891
    },
    {
        "content": "<p>Sounds like it's pretty hard then :-)</p>",
        "id": 190915730,
        "sender_full_name": "Iocta",
        "timestamp": 1584482044
    },
    {
        "content": "<p>Why does <code>inductive vector (α : Type u) : nat → Type u</code> have <code>\\to Type u</code> and not <code>\\to \\a</code>?</p>",
        "id": 190916125,
        "sender_full_name": "Iocta",
        "timestamp": 1584482242
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span>   <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190916157,
        "sender_full_name": "Iocta",
        "timestamp": 1584482258
    },
    {
        "content": "<p>For each natural number n you want the type of vectors of objects of type alpha with length n</p>",
        "id": 190916362,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584482360
    },
    {
        "content": "<p>This is indeed in Type u</p>",
        "id": 190916374,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584482367
    },
    {
        "content": "<p>ok I see</p>",
        "id": 190916561,
        "sender_full_name": "Iocta",
        "timestamp": 1584482466
    },
    {
        "content": "<p>I had </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n</pre></div>\n\n\n<p>and I thought this would help</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">zero_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">nil</span>  <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>but I'm not sure how to eliminate the <code>0 +</code></p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">04</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">40</span>  <span class=\"mi\">28</span> <span class=\"n\">error</span>           <span class=\"n\">equation</span> <span class=\"n\">compiler</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">create</span> <span class=\"n\">auxiliary</span> <span class=\"n\">declaration</span> <span class=\"err\">&#39;</span><span class=\"n\">zero_add</span><span class=\"bp\">._</span><span class=\"n\">main&#39;</span>\n <span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">message</span><span class=\"o\">:</span>\n <span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n   <span class=\"n\">a_a</span> <span class=\"bp\">::</span> <span class=\"n\">a_a_1</span>\n <span class=\"n\">term</span>\n   <span class=\"n\">a_a_1</span>\n <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"mi\">0</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n   <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190921510,
        "sender_full_name": "Iocta",
        "timestamp": 1584485704
    },
    {
        "content": "<p>you need to use <code>zero_add</code></p>",
        "id": 190921887,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584485928
    },
    {
        "content": "<p>Welcome to dependent type theory.</p>",
        "id": 190921929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584485959
    },
    {
        "content": "<p>You can do it like this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span>   <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">vector</span>\n\n<span class=\"n\">def</span> <span class=\"n\">zero_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">zero_add</span> <span class=\"n\">at</span> <span class=\"n\">v</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">vector</span>\n</pre></div>\n\n\n<p>but this is a complete disaster because I used tactics to define data, so <code>zero_add</code> will be hard to use in practice. The computer scientists know tricks around this. <a href=\"#narrow/stream/116395-maths/topic/CDGAs/near/167848869\" title=\"#narrow/stream/116395-maths/topic/CDGAs/near/167848869\">here</a> is a situation where this issue is really quite embedded and you have to dig hard to get out.</p>",
        "id": 190923106,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584486778
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span>   <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span>  <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190923575,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584487091
    },
    {
        "content": "<p>this is what I meant</p>",
        "id": 190923580,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584487094
    },
    {
        "content": "<p>This is some sort of a dark art, which fortunately doesn't seem to come up in the kind of mathematics I tend to formalise (which is one of the reasons I'm not very good at it)</p>",
        "id": 190923730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584487233
    },
    {
        "content": "<p>hmm I'd actually tried </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">zero_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">nil</span>  <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>which I think is the same, but it didn't work for me: </p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">04</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">37</span>   <span class=\"mi\">5</span> <span class=\"n\">error</span>           <span class=\"n\">equation</span> <span class=\"n\">compiler</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">create</span> <span class=\"n\">auxiliary</span> <span class=\"n\">declaration</span> <span class=\"err\">&#39;</span><span class=\"n\">zero_add</span><span class=\"bp\">._</span><span class=\"n\">main&#39;</span>\n <span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">message</span><span class=\"o\">:</span>\n <span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n   <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"n\">id_rhs</span> <span class=\"o\">(</span><span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a_a</span> <span class=\"bp\">::</span> <span class=\"err\">⁇</span><span class=\"o\">))</span>\n <span class=\"n\">term</span>\n   <span class=\"n\">id_rhs</span> <span class=\"o\">(</span><span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a_a</span> <span class=\"bp\">::</span> <span class=\"err\">⁇</span><span class=\"o\">)</span>\n <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n   <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)),</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a_a</span> <span class=\"bp\">::</span> <span class=\"n\">a_a_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n <span class=\"mi\">08</span><span class=\"bp\">.</span><span class=\"mi\">04</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"err\">…</span>    <span class=\"mi\">40</span>  <span class=\"mi\">30</span> <span class=\"n\">error</span>           <span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n   <span class=\"n\">zero_add</span> <span class=\"n\">t</span>\n <span class=\"n\">term</span>\n   <span class=\"n\">t</span>\n <span class=\"n\">has</span> <span class=\"n\">type</span>\n   <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n   <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"err\">?</span><span class=\"n\">m_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">checker</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190923794,
        "sender_full_name": "Iocta",
        "timestamp": 1584487318
    },
    {
        "content": "<p>the resulting type of <code>vector.cons</code> had to be <code>vector (nat.succ n)</code></p>",
        "id": 190923883,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584487401
    },
    {
        "content": "<p>What is the implication of that?</p>",
        "id": 190924147,
        "sender_full_name": "Iocta",
        "timestamp": 1584487607
    },
    {
        "content": "<p>Lean fails to unite <code>nat.succ n</code> with <code>?1 + 1</code></p>",
        "id": 190924966,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584488301
    },
    {
        "content": "<p>Is it possible to use <code>@</code> with the recursive call? <code>@zero_add n t</code>?</p>",
        "id": 190925014,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584488368
    },
    {
        "content": "<p>Just to remark that these issues aren't there with what Mario calls the \"untyped approach\" in that CDGA thread linked to above:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"n\">def</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">++</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length_append</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">⟩</span> <span class=\"c1\">-- easy</span>\n</pre></div>",
        "id": 190925738,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584489014
    },
    {
        "content": "<p>I don't see Mario's comments in that thread</p>",
        "id": 190926459,
        "sender_full_name": "Iocta",
        "timestamp": 1584489625
    },
    {
        "content": "<p>scratch that</p>",
        "id": 190926501,
        "sender_full_name": "Iocta",
        "timestamp": 1584489689
    },
    {
        "content": "<p>Just to clarify in case I missed the point.. what was the conclusion of this conversation?: is there a way to fill this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span>   <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n</pre></div>",
        "id": 190943659,
        "sender_full_name": "Iocta",
        "timestamp": 1584514560
    },
    {
        "content": "<p>Here's a definition that sidesteps the definitional equality problems:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">n</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"bp\">_</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190950648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584520782
    },
    {
        "content": "<p>To make this work, you need the recursion to follow the same structure on the vectors and on nat. Since addition is defined by recursion on the second argument, but append is defined by recursion on the first vector, that's why the addends are swapped</p>",
        "id": 190950760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584520876
    },
    {
        "content": "<p>If you really want the addends to be in the right order, I don't think you can do better than just having a <code>cast</code> function that transports along equality for the type. (This is actually a special case of <code>eq.subst</code>, but it computes better if you really want to do this dependent type stuff.)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">append&#39;</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">n</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"bp\">_</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">append&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">},</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"mi\">0</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"bp\">_</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n  <span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">inj</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">append&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190957263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584524831
    },
    {
        "content": "<p>Thanks, gonna have to process this :-)</p>",
        "id": 191026530,
        "sender_full_name": "Iocta",
        "timestamp": 1584557866
    },
    {
        "content": "<p>I have seen this phenomenon several times now -- great, you can now append, but is this really what you want to be doing? You will presumably have to fight dependent type theory when you want to make your next definition on vectors. The approach where you define them as lists of a certain length removes all this headache.</p>",
        "id": 191026756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584557979
    },
    {
        "content": "<p>Iocta is probably working through TPIL, where you're asked to implement append for vectors in 8.9.5</p>",
        "id": 191027590,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1584558326
    },
    {
        "content": "<p>harsh!</p>",
        "id": 191027614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584558342
    },
    {
        "content": "<p>Is the ability to write this sort of code important in formalising? I just try and avoid it...</p>",
        "id": 191027739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584558400
    },
    {
        "content": "<p>I think you are only asked to write down the type of vector append in TPIL</p>",
        "id": 191027773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584558418
    },
    {
        "content": "<p>\"Following the examples in Section 8.6, define a function that will append two vectors. This is tricky; you will have to define an auxiliary function.\"</p>",
        "id": 191027824,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1584558440
    },
    {
        "content": "<p>oh mario posted spoilers!</p>",
        "id": 191027870,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584558463
    },
    {
        "content": "<p>it's probably not very important, but the vector example is used very commonly when motivating DTT, especially in programming languages with DTT. my only DTT experience is with lean - is this stuff less painful in any other DTT language?</p>",
        "id": 191028018,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1584558538
    },
    {
        "content": "<p>I don't think so, the issues that come up are basically to do with DTT itself and not lean's implementation of it</p>",
        "id": 191028106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584558592
    },
    {
        "content": "<p>I think it's telling that both the definitions of vector that we have in mathlib are not this one.</p>",
        "id": 191028188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584558616
    },
    {
        "content": "<p>We have \"lists of length n\" and \"functions fin n -&gt; alpha\"</p>",
        "id": 191028217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584558632
    },
    {
        "content": "<p>kind of weird that everyone uses the vector example to motivate DTT then, if it isn't practical anywhere</p>",
        "id": 191028259,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1584558660
    },
    {
        "content": "<blockquote>\n<p>the vector example is used very commonly when motivating DTT</p>\n</blockquote>\n<p>I also think it's telling that the very things that motivate DTT are the things that are most difficult to deal with in DTT</p>",
        "id": 191028277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584558668
    },
    {
        "content": "<p>They should just get beginners doing commutative algebra :-)</p>",
        "id": 191028348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584558701
    },
    {
        "content": "<p>when i started formalizing things for my bsc thesis, i also started working with vectors when i wanted to carry around some length invariant.<br>\ni think i wrote two definitions and then decided that this isn't a good use of my time :p</p>",
        "id": 191028450,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1584558753
    },
    {
        "content": "<p>At Big Proof 2, Gilles Dowek was ranting against vectors being presented as the motivation for DTT. He claims that <code>∀ x, P x</code> is the actual motivation.</p>",
        "id": 191034661,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584561842
    },
    {
        "content": "<p>Exactly! The statement of Fermat's Last Theorem!</p>",
        "id": 191034737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584561866
    },
    {
        "content": "<p>For every n&gt;=3, some statement which depends on n is true.</p>",
        "id": 191034774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584561890
    },
    {
        "content": "<p>But systems based on, say, first order logic don't have any trouble with such statements either</p>",
        "id": 191037316,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584563218
    },
    {
        "content": "<p>I think that if you follow the \"untyped style\" with data + proofs, then you are essentially rejecting curry howard, because proofs and data become entirely separate classes, with the thing that makes dependent type theory actually dependent, namely the use of terms inside types (not counting props), being avoided. If you follow this subset strictly, I think you land essentially in HOL.</p>\n<p>But then this makes me wonder: we've argued before that HOL is too weak to represent some \"real maths\", like schemes and such. If that's the case, then this must be using \"real dependent types\", and there is probably an associated dependent type hell to be had. So how does it manifest?</p>",
        "id": 191038530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584563769
    },
    {
        "content": "<p>Recall that a sheaf of types is, amongst other things, a way of associating a type to each open subset of a topological space. We can make these types rings or abelian groups, and then talk about sheaves of modules over a sheaf of rings. I've always suspected that this is problematic in HOL because you won't be able to use typeclasses.</p>",
        "id": 191040933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584564924
    },
    {
        "content": "<p>Right, so my question is what happens after that, when you do it in DTT. My general prediction is that anything that is impossible in HOL is DTT hell in DTT</p>",
        "id": 191041899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584565409
    },
    {
        "content": "<p>I think in this case it shows up in some struggles you had about a year ago with using the restriction map for equal sets like <code>U \\cap U = U</code></p>",
        "id": 191042071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584565492
    },
    {
        "content": "<p>I suspect that sheaves of modules over a fixed sheaf of rings should be some monoidal category (except that I only just found out what these were the other day). That might be a nice exercise :-)</p>",
        "id": 191042312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584565605
    },
    {
        "content": "<p>and this is reminding me of some recent comments of Thorsten Altenkirch on the cross-mailing list DTT thread:</p>\n<blockquote>\n<p>But more practically: indeed you are right if you accept this point (i.e. univalence) then you have to give up some properties of equality in particular that it is propositional, i..e a property. This can be annoying because it may mean that you have to deal with coherence issues when using equality, but I suspect you should be used to this. However, as long as you only deal with simple objects, i.e. as in the “world of numbers” everything is fine and nothing changes. It is only when you leave the realm of “set level Mathematics” and talk about structures (as in the Grothendieck example) you encounter equalities which are not propositions (but structures themselves).</p>\n</blockquote>",
        "id": 191042511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584565732
    },
    {
        "content": "<p>\"coherence issues when using equality\" sounds like trouble</p>",
        "id": 191042539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584565752
    },
    {
        "content": "<p>This monoidal category stuff is exactly some sort of attempt to get around it -- Type is a monoidal category because product is not associative, it's only associative up to canonical isomorphism. But carrying around canonical isomorphisms is less painful than carrying around isomorphisms</p>",
        "id": 191042679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584565821
    },
    {
        "content": "<p>Mario, did you carefully look at what Sébastien explained to us in Pittsburgh, and the corresponding mathlib code?</p>",
        "id": 191042696,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584565833
    },
    {
        "content": "<p>probably not? I'm not sure what you are referring to</p>",
        "id": 191042804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584565912
    },
    {
        "content": "<p>Sébastien's motivation for leaving the automated world of Isabelle is not sheaf theory.</p>",
        "id": 191042875,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584565938
    },
    {
        "content": "<p>I'm not saying that HOL is the answer, but rather that DTT has only slightly improved the situation from \"you can't do it\" to \"you <em>can</em> do it, but only if you are a masochist\"</p>",
        "id": 191042944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584565988
    },
    {
        "content": "<p>(or to put it more positively: if you like tricky technical puzzles)</p>",
        "id": 191043015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584566041
    },
    {
        "content": "<p>Is it clear that <code>vector</code> (terms inside types) is really the same kind of issue as sheaves (types inside terms)?</p>",
        "id": 191043145,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584566106
    },
    {
        "content": "<p>that's an interesting way to put it</p>",
        "id": 191043251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584566163
    },
    {
        "content": "<p>DTT (as implemented by lean) brings more than just terms in types, it also brings universes, which allows you to have types as terms. This use isn't particularly problematic AFAIK</p>",
        "id": 191043412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584566257
    },
    {
        "content": "<p>It should be noted that we have not yet defined Picard groups in Lean (isomorphism classes of certain sheaves of modules, with group law being tensor product)</p>",
        "id": 191043594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584566347
    },
    {
        "content": "<p>is that actually a group? It sounds like a 2-group</p>",
        "id": 191043648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584566387
    },
    {
        "content": "<p>It's a group because of the phrase \"isomorphism classes of\". It is true it is the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of a 2-group or something.</p>",
        "id": 191043772,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584566451
    },
    {
        "content": "<p>aren't those isomorphism classes proper?</p>",
        "id": 191043957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584566542
    },
    {
        "content": "<p>It's isomorphism classes of so-called invertible sheaves of modules. This saves you.</p>",
        "id": 191043998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584566569
    },
    {
        "content": "<p>All sheaves of modules, you're doomed. An example of a scheme is: choose a field K. Now let the top space be 1 point, and let the sheaf of rings send the empty set to the zero ring, and the whole space to K.</p>",
        "id": 191044058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584566621
    },
    {
        "content": "<p>A sheaf of modules for that scheme is just a K-vector space. An invertible sheaf of modules is a 1-dimensional K-vector space.</p>",
        "id": 191044150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584566646
    },
    {
        "content": "<p>Tensor product of two 1-dimensional spaces is 1-dimensional; if V is 1-dimensional then the linear dual of V is its inverse. But it turns out they're all isomorphic to K anyway, so the Picard group is trivial.</p>",
        "id": 191044222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584566691
    },
    {
        "content": "<p>it's still a proper class if you are talking about all 1D K-vector spaces, but I guess there is a small set of representatives</p>",
        "id": 191044312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584566762
    },
    {
        "content": "<p>The group is the isomorphism classes so it's trivial</p>",
        "id": 191044385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584566795
    },
    {
        "content": "<p>and in general you do some small set trickery to show the group is a set</p>",
        "id": 191044399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584566808
    },
    {
        "content": "<p>If you took all the definitions literally in ZFC + one universe U (used to interpret \"small\" things) then the Picard group of a field would be a group with a single element which is not a member of U (hence neither is the group). But the group is isomorphic to the trivial group, so we pretend it is the trivial group and in particular small.</p>",
        "id": 191044866,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584567113
    },
    {
        "content": "<p>Similarly if you wrote down all the definitions in Lean you would get a group in <code>Type 1</code> (or <code>Type (u+1)</code>) but it's isomorphic (as a group) to some \"ordinary\"-sized group</p>",
        "id": 191045008,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584567194
    },
    {
        "content": "<p>I envisage a future where we're doing etale cohomology or Picard schemes or condensed sets in Lean and every time the answer is in type <code>u+n</code> this means that there are <code>n</code> problems for the ZFC guys to sort out at a future date</p>",
        "id": 191051183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584570740
    },
    {
        "content": "<p>Well there are two issues here. One is how to remove the \"+U\" part of ZFC+U when you want to \"export\" a Lean proof to ZFC. But even if you are happy to assume ZFC+U, you will probably still want operations like Pic, K-theory, etc. to not increase the universe level.</p>",
        "id": 191051766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584571142
    },
    {
        "content": "<p>Yeah but I figure that it's not my problem.</p>",
        "id": 191052393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584571568
    },
    {
        "content": "<p>I've worked through enough of these arguments to know that it will all be fine and hey, that's what universe polymorphism is for, right?</p>",
        "id": 191052467,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584571630
    },
    {
        "content": "<p>The people who are interested in reading section 4 of Scholze etale cohomology of diamonds can fix it up later</p>",
        "id": 191052523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584571674
    },
    {
        "content": "<p>I wonder which universe the ideal class group of a number field will end up in</p>",
        "id": 191052628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584571745
    },
    {
        "content": "<p>See, I expect the second one will eventually become your problem, though I admit I don't have a compelling example at the moment</p>",
        "id": 191052768,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584571836
    },
    {
        "content": "<p>The best I can do so far is <a href=\"https://ncatlab.org/nlab/show/red-shift+conjecture\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/red-shift+conjecture\">the red-shift conjecture</a> which, if you take it as a statement about iterated K-theory, can't be stated in Lean without arranging for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K(R)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> to live in the same universe as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, but in the general formulation described on the nlab can be.</p>",
        "id": 191053233,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584572149
    },
    {
        "content": "<p>Maybe we should ask Leo for a universe for every countable ordinal?</p>",
        "id": 191054898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584573301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> There are actually things that feel OK in HOL and considered hell in DTT. Namely, inductive predicates. HOL's inductive predicates are built on top of Knaster-Tarski and not encoded as inductive types (Curry-Howard). They work quite smoothly. Whereas in CIC, one ends up with the evil \"vector\" essentially, and dependently typed matching, etc. Maybe this is an argument against Curry-Howard -- or maybe it just shows that Lean's \"induction/cases/match\" could be improved.</p>\n<p>I tried (with Johannes) to build a course that would almost exclusively remain in the HOL fragment of Lean, but in the end I had to give up because of inductive predicates. Now I'll even teach the (suboptimal) way of doing \"vector\", so that I can show the parallel with inductive predicates -- Curry-Howard in action.</p>",
        "id": 191077924,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1584603048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Concerning \"you _can_ do it, but only if you are a masochist\", I think things like dependent pairs (and structures) and higher-rank polymorphism are useful and not hellish.</p>",
        "id": 191078040,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1584603170
    },
    {
        "content": "<p>Equality of structures is hellish but in a lot of mathematics it turns out that we don't use the concept. We do use _some_ kind of equivalence relation, but it seems to be not any of the ones that these systems make available to us</p>",
        "id": 191078672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584603758
    },
    {
        "content": "<p>the major hellish aspect of DTT here is what I call \"rigid parameters\" like the <code>n</code> in <code>vector A n</code>. Here we have a type <code>nat</code> about which we have a bunch of useful (propositional) equalities, but by putting the parameter in a type dependency, only defeq matters, and this isn't what we want, so we have to fight it with casts and things and it's downhill from there.</p>",
        "id": 191079337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604339
    },
    {
        "content": "<p>This is different from the issue that HoTT tries to solve, which is how to replace isomorphism of various kinds with equality (not defeq). You still have to use casts on rigid parameters, and the casts carry information now so you have coherences all over the place</p>",
        "id": 191079490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604478
    },
    {
        "content": "<p>Why? You could <code>transfer</code> a <code>vector A n</code> to a <code>vector A m</code> along <code>h : n = m</code>, right?</p>",
        "id": 191079717,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584604650
    },
    {
        "content": "<p>that's just another way to use <code>cast</code></p>",
        "id": 191079853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604744
    },
    {
        "content": "<p>the problem is that because <code>vector</code> is data, that <code>cast</code> is not being used in a proof, it is being used in a definition and that means you will have to destructure this later</p>",
        "id": 191079892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604778
    },
    {
        "content": "<p>and that usually means second order <code>cast</code></p>",
        "id": 191079897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604786
    },
    {
        "content": "<p>Well, sure. But my impression was that HoTT has better support for higher order cast. It's what you're supposed to be doing.</p>",
        "id": 191080065,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584604876
    },
    {
        "content": "<p>For example, I wrote down a definition of <code>append</code> above, using a <code>cast</code>. Proving that <code>append</code> is associative is both not fun and impossible because of type constraints</p>",
        "id": 191080112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604898
    },
    {
        "content": "<p>Do you run into the same problem with HoTT?</p>",
        "id": 191080193,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584604925
    },
    {
        "content": "<p>(I don't know, I never tried it.)</p>",
        "id": 191080202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584604931
    },
    {
        "content": "<p>Yes, HoTT encourages analysis of the structure of higher order cast. That's why everyone gets distracted with this and forgets to get back to the maths</p>",
        "id": 191080233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584604952
    },
    {
        "content": "<p>My guess is that with HoTT you would be able to write down a higher homotopy that proves the assoc. And probably it's not even ugly.</p>",
        "id": 191080243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584604968
    },
    {
        "content": "<p>one theoretical fact that's not so nice is that you can never be \"done\" with your library of theorems about equality. You can prove that eq is symmetric, but that's a definition; now you want to prove that this definition has an inverse, and that's another higher order thing, then you want that your associator satisfies a pentagon lemma, and it just keeps going</p>",
        "id": 191080397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584605106
    },
    {
        "content": "<p>with a proof irrelevant equality it bottoms out at the first level, and then all equalities you need are just true</p>",
        "id": 191080419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584605139
    },
    {
        "content": "<p>in HoTT it feels like you can never just say that a fact is true, because how it was proved always comes back later</p>",
        "id": 191080471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584605171
    },
    {
        "content": "<p>Sure, but it shifts the problem. Because when you're doing tensor products of modules, you end up with those pentagon lemmas anyway (but with lesser support). Higher-order equality is a real thing in math. And we need to be able to rewrite along it effortlessly.</p>",
        "id": 191080535,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584605267
    },
    {
        "content": "<p>I'm not convinced that HoTT actually makes dealing with any of it nicer than you can already do in lean, it just makes these problems pervasive</p>",
        "id": 191080607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584605318
    },
    {
        "content": "<p>To put it another way, when you have Prop, every theorem tells you a little bit more about the mathematical structures of interest. In HoTT, every theorem is a definition, every answer results in several more questions, and no matter how much you work at it there is always a \"raw end\" where you haven't proven all the important theorems about some definition, because it's turtles all the way down. It's psychologically unsatisfying</p>",
        "id": 191080836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584605534
    },
    {
        "content": "<p>which is why it's no surprise that people get distracted with the higher order stuff</p>",
        "id": 191080894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584605607
    },
    {
        "content": "<p>Well, you can prove that definition <code>X</code> is an <code>hProp</code> (assuming that it is the analogue of some Lean <code>Prop</code>). And you can prove once and for all that <code>hProp foobar</code> is an <code>hProp</code> for all <code>foobar</code>. So I think the turtles do become extremely trivial at some point.</p>",
        "id": 191080985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584605689
    },
    {
        "content": "<p>In mathlib we have <code>unique_unique</code>, but not <code>unique_unique_unique</code>...</p>",
        "id": 191081111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584605790
    },
    {
        "content": "<p>But it's not like the h-levels exhaust the type universe, and why make an assumption if it's not needed? So you study general types instead and there is no bottom there</p>",
        "id": 191081127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584605801
    },
    {
        "content": "<p>I think that ultimately there is a big question: what happens if you try to do the mathematics which Johan and I think of as normal, but which turns out to be a million miles from anything done in these provers, and I don't think it's clear what the answer will be. I don't need the pentagon axiom to do Picard groups because an element of that group is an isomorphism class of shaves of modules and all I need to know for associativity in that group is that (A tensor B) tensor C is isomorphic to A tensor (B tensor C) and I don't seem to care about compatibilities. For this particular topic mathematicians are happy to truncate. For others, we just don't know. Do I need the pentagon axiom to prove Fermat's last theorem? I'm not so sure.</p>",
        "id": 191086687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584609683
    },
    {
        "content": "<p>This question is all about your \"category number\", i.e. what level in the hierarchy of n-categories you can/need/want to truncate at.</p>",
        "id": 191135968,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584634271
    },
    {
        "content": "<p>Nearly all mathematicians' category number is one higher than they realise it is. :-)</p>",
        "id": 191136003,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584634288
    },
    {
        "content": "<p>But maybe 50% of mathematicians have category number 0, another 40% category number 1, then 9% 2. (And then add +1 to most of those numbers when it's time to formalise their hunches about how things work. :-)</p>",
        "id": 191136126,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584634348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191136003\" title=\"#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191136003\">said</a>:</p>\n<blockquote>\n<p>Nearly all mathematicians' category number is one higher than they realise it is. :-)</p>\n</blockquote>\n<p>Sadly, this is one of those rules that sometimes still applies even after you've taken into account that it applies.... It's a slippery slope!</p>",
        "id": 191136252,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584634409
    },
    {
        "content": "<p>(And of course those percentages are total garbage.)</p>",
        "id": 191136381,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584634456
    },
    {
        "content": "<p>I just saw this thread now, after Kevin pinged me. Of course many people are now interested in homotopified mathematics and brave new algebra and what-not, but the large majority are happy with sets and groupoids and the occasional 2-type.</p>",
        "id": 191355821,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1584810528
    },
    {
        "content": "<p>working mathematicians certainly work like this. Is it possible to work like this in a HoTT theory without any inconvenience? I guess I am hoping for concrete examples. I am hoping that Johan or others will soon show me such things.</p>",
        "id": 191356010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584810821
    },
    {
        "content": "<p>I don't see why not, we already have quite a bit of algebra done like this in some of the HoTT libraries.</p>",
        "id": 191356105,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1584810907
    },
    {
        "content": "<p>Which ones and what algebra? Can you answer in the thread on the HoTT Zulip? I am interested in a detailed overview of some of these systems, the README.md for these HoTT repos does not give this.</p>",
        "id": 191356314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584811190
    },
    {
        "content": "<p>I was thinking about defining Noetherian rings and then it occurred to me that some of these systems might not currently have a workable definition of a finite type. This is thousands of lines of Lean code.</p>",
        "id": 191356364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584811221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191356314\" title=\"#narrow/stream/113489-new-members/topic/more.20more.20basics/near/191356314\">said</a>:</p>\n<blockquote>\n<p>Which ones and what algebra? Can you answer in the thread on the HoTT Zulip?</p>\n</blockquote>\n<p>OK, let's continue there.</p>",
        "id": 191356377,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1584811244
    }
]
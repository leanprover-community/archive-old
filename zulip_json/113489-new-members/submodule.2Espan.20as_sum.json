[
    {
        "content": "<p>Dear All,</p>\n<p>is something like the lemma below already available in mathlib?</p>\n<p>Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">submodule.span_as_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">su</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n    <span class=\"n\">c.support</span> <span class=\"bp\">=</span> <span class=\"n\">su</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">c.support</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">su</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227978597,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614367460
    },
    {
        "content": "<p>I think the forward direction of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.mem_span_iff_total\">docs#finsupp.mem_span_iff_total</a> might help?</p>",
        "id": 227985273,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1614370134
    },
    {
        "content": "<p>Thank you, this seems very close to what I want!</p>",
        "id": 227986873,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614370737
    },
    {
        "content": "<p>You could probably drop <code>su</code> completely and just sum over <code>c.support</code> (assuming this is a <code>finset</code>).</p>",
        "id": 227993035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614373149
    },
    {
        "content": "<p>Kevin, yes, thanks!  I initially have  a version where the support of <code>c</code> was contained in <code>su</code>, but not necessarily equal to it, since it seemed useful, but then I managed to prove it in this form and did not look back at it.  You are right that, as is, <code>su</code> is determined by everything else!</p>",
        "id": 227994944,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614374010
    },
    {
        "content": "<p>It is not pretty, but it works...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">submodule.span_as_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c.support</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">c.support</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">Tv</span><span class=\"o\">,</span> <span class=\"n\">mT</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mem_span_finite_of_mem_span</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">mT</span> <span class=\"n\">Tv</span> <span class=\"n\">m</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">s</span> <span class=\"n\">ms</span> <span class=\"n\">es</span> <span class=\"n\">me</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">me</span><span class=\"o\">⟩)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">S</span> <span class=\"n\">ms</span> <span class=\"n\">ih</span> <span class=\"n\">m1</span> <span class=\"n\">s</span> <span class=\"n\">m1s</span> <span class=\"n\">ims</span> <span class=\"n\">m1i</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.coe_insert</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">m1i</span><span class=\"o\">,</span>\n  <span class=\"n\">choose</span> <span class=\"n\">a</span> <span class=\"n\">z</span> <span class=\"n\">hz</span> <span class=\"n\">ide</span> <span class=\"n\">using</span> <span class=\"n\">mem_span_insert.mp</span> <span class=\"n\">m1i</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">ide</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c1</span><span class=\"o\">,</span> <span class=\"n\">c1ss</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">z</span> <span class=\"n\">S</span> <span class=\"n\">hz</span> <span class=\"n\">rfl.subset</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">c1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">ims</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_insert_of_mem</span> <span class=\"o\">(</span><span class=\"n\">c1ss</span> <span class=\"n\">hg</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">zero_smul</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">mc1</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∉</span> <span class=\"n\">c1.support</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">ms</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_coe.mp</span> <span class=\"o\">(</span><span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"n\">h</span> <span class=\"n\">c1ss</span><span class=\"o\">)),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">c1</span> <span class=\"bp\">+</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">ims</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">finset.insert_eq</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_union</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_singleton</span><span class=\"o\">],</span>\n    <span class=\"n\">obtain</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">∨</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">c1.support.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span><span class=\"o\">,</span>\n      <span class=\"n\">finset.union_comm</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"n\">hs</span> <span class=\"n\">finsupp.support_add</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"n\">F</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"o\">(</span><span class=\"n\">finset.coe_subset.mp</span> <span class=\"n\">c1ss</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">clear</span> <span class=\"n\">m1i</span> <span class=\"n\">m1s</span> <span class=\"n\">hz</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">dc1m</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">c1.support</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">finset.disjoint_singleton.mpr</span> <span class=\"n\">mc1</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">cpa</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"bp\">+</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">=</span> <span class=\"n\">c1.support</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">finsupp.support_add</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">refine</span> <span class=\"n\">finset.mem_of_subset</span> <span class=\"o\">(</span><span class=\"n\">eq.subset</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">finsupp.support_add_eq</span> <span class=\"n\">dc1m</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"bp\">+</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_singleton</span><span class=\"o\">,</span> <span class=\"n\">finsupp.coe_add</span><span class=\"o\">,</span> <span class=\"n\">pi.add_apply</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">finsupp.single_eq_same</span><span class=\"o\">],</span>\n      <span class=\"n\">refine</span> <span class=\"n\">add_left_eq_self.mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.not_mem_support_iff.mp</span> <span class=\"n\">mc1</span><span class=\"o\">,</span> <span class=\"n\">zero_smul</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cpa</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_union</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span> <span class=\"n\">at</span> <span class=\"n\">dc1m</span><span class=\"o\">),</span> <span class=\"n\">add_comm</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">finsupp.coe_add</span><span class=\"o\">],</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">pi.add_apply</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_add_distrib</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">add_right_inj</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">add_right_eq_self.mpr</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">refine</span> <span class=\"n\">finset.sum_eq_zero</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">xc1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">convert</span> <span class=\"n\">zero_smul</span> <span class=\"n\">_</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finsupp.not_mem_support_iff</span><span class=\"o\">,</span> <span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">finset.not_mem_singleton</span><span class=\"o\">],</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mc1</span> <span class=\"n\">xc1</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 228039864,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614409768
    },
    {
        "content": "<p>Damiano surely the first line is <code>  apply span_induction hm,</code> and then you should have four straightforward goals.</p>",
        "id": 228057549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614431425
    },
    {
        "content": "<p>If you can't get it from what is already there then it should be straightforward to prove directly by induction.</p>",
        "id": 228057567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614431456
    },
    {
        "content": "<p>I'm trying it and it seems a bit shorter but it's still a struggle :-(</p>",
        "id": 228058737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614432803
    },
    {
        "content": "<p>I agree, it puts stuff in the right places, but the proof does not seem much shorter.  It is more \"guided\", certainly!</p>",
        "id": 228059033,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614433191
    },
    {
        "content": "<p>You should be using <code>finsupp.sum</code> I think</p>",
        "id": 228059073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614433205
    },
    {
        "content": "<p>Of course in my opinion you should be avoiding finsets completely and using finsum ;-)</p>",
        "id": 228059109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614433255
    },
    {
        "content": "<p>ok, but, to be honest, I lost the strength to continue with this, now that it is proved and proof irrelevance will not look at how...  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 228059121,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614433271
    },
    {
        "content": "<p>Besides, this is simply a step to prove something for the liquid project</p>",
        "id": 228059136,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614433286
    },
    {
        "content": "<p>Your goal is <code>∃ c : M →₀ R, (c.support : set M) ⊆ s ∧ (finsupp.sum c (λ m r, r • m)) = m</code></p>",
        "id": 228059191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614433326
    },
    {
        "content": "<p>I can now prove that if, in a Z-module with a pairing, you take the dual of a set containing a basis, then the dual is entirely on one side of a hyperplane!</p>",
        "id": 228059202,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614433331
    },
    {
        "content": "<p>Not especially exciting, but it is getting the machinery working for lattice stuff</p>",
        "id": 228059212,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614433348
    },
    {
        "content": "<p>Ok, I may give this <code>finsupp.sum</code> instead of <code>finset.sum</code> a go, but later.  I actually did not know that there was a difference and simply went for what Lean accepted as a well-formed statement and that was correct mathematically...</p>",
        "id": 228059306,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614433474
    },
    {
        "content": "<p><code>finsupp.sum</code> is much better because it knows the key fact that summing over <code>support f</code> is the same as summing over any set containing <code>support f</code>.</p>",
        "id": 228059333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614433513
    },
    {
        "content": "<p>Ah, this would save indeed a few lines, certainly towards the bottom of the proof, and likely earlier than that as well!</p>",
        "id": 228059406,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614433581
    },
    {
        "content": "<p>Another trick with <code>finsupp.sum</code> (which I'm learning as I'm proving) is that it's better to work with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">zero_smul</span> <span class=\"n\">_</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">m</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Does this map already have a name?</p>",
        "id": 228059760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614433967
    },
    {
        "content": "<p>Is this the \"orbit of <code>m</code>\" map?  I am simply trying to parse the math side, not implying that if it is, then I know what it is in Lean!</p>",
        "id": 228059952,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614434199
    },
    {
        "content": "<p><code>(smul_add_hom R M).flip m</code></p>",
        "id": 228059954,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1614434206
    },
    {
        "content": "<p>Thanks Scott. The reason it's useful is that stuff like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.sum_add_index'\">docs#finsupp.sum_add_index'</a> needs not just that the map you're summing over is M -&gt; R -&gt; M but M -&gt; R -&gt;+ M.</p>",
        "id": 228059996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614434274
    },
    {
        "content": "<p>Here's my effort:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finsupp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">submodule.span_as_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c.support</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">c.support</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">change</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c.support</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"n\">finsupp.sum</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">span_induction</span> <span class=\"n\">hm</span><span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">hm</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">m</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">mem_support_single</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">rwa</span> <span class=\"n\">hx.1</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">set.subset.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.union_subset</span> <span class=\"n\">hc</span> <span class=\"n\">hd</span><span class=\"o\">),</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finset.coe_union</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_subset</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">support_add</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">sum_smul_index'</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.map_finsupp_sum</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n      <span class=\"n\">ext</span> <span class=\"n\">m</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It taught me a bunch about <code>finsupp.sum</code> (e.g. its existence!)</p>",
        "id": 228061543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614436133
    },
    {
        "content": "<p>I wonder if it would have been less painful if the support was just a set -- several times I had to do a finset &lt;-&gt; set dance. The goal is (exists x, X and Y) so after the induction and the split there are eight goals; each one only took a few lines but it all adds up...</p>",
        "id": 228061705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614436325
    },
    {
        "content": "<p>Thanks Kevin!  I like how structured your proof is.  Besides, it can be broken into 4 shorter lemmas, which is good!</p>\n<p>Do you think it should be in mathlib?  I am using it in <code>toric</code>.</p>",
        "id": 228065338,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614440414
    },
    {
        "content": "<p>Whenever I see a lemma like this I wonder whether in fact it's needed in the intended application or whether one can get away with just doing induction. I would definitely consider changing the statement of the lemma to what I <code>change</code> it to on line 1, but I don't see why it can't go in mathlib, I would imagine that there's a better way of proving <code>r • (c x) ≠ 0 -&gt; (c x) ≠ 0</code> rather than <code>intro h1, apply hx, simp [h1]</code> but everything else looks OK to me.</p>",
        "id": 228067789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614443149
    },
    {
        "content": "<p>Does <code>rw [finsupp.coe_smul] at hx,   exact right_ne_zero_of_mul hx</code> appear better?</p>",
        "id": 228068069,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614443455
    },
    {
        "content": "<p>If it seems alright, this is a slightly shortened version of your proof that, I think, is still readable.  I could compress it further, but not much, I think.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">submodule.span_as_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c.support</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">c.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">span_induction</span> <span class=\"n\">hm</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">hm</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">finsupp.single</span> <span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">mem_support_single</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">hy.1</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">set.subset.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.union_subset</span> <span class=\"n\">hc</span> <span class=\"n\">hd</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finset.coe_union</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_subset</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">support_add</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hc</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.coe_smul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">right_ne_zero_of_mul</span> <span class=\"n\">hx</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">sum_smul_index'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.map_finsupp_sum</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n        <span class=\"n\">ext</span> <span class=\"n\">m</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(((</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 228068804,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614444224
    },
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib/issues/6457\">#6457</a></p>",
        "id": 228071024,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614446530
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 228071337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614446889
    },
    {
        "content": "<p>No problem!</p>\n<p>In the actual version, I begun the proof with a <code>classical</code>, since otherwise some of the finsets would complain.</p>\n<p>I agree that using the definition of the submodule spanned as \"the infimum of the submodules [...]\" should be the standard approach, but sometimes I think that using linear combinations can be simpler/shorter.</p>",
        "id": 228071592,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614447136
    },
    {
        "content": "<p>The other notable difference, is that I made implicit the assumptions <code>{m : M}</code> and <code>{s : set M}</code>, since they can be read off from the last assumption <code>(hm : m ∈ submodule.span R s)</code>.</p>\n<p>(This change already appears in the shortened version above.)</p>",
        "id": 228072751,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614448451
    },
    {
        "content": "<p>Something strange happens with <code>M</code> when I try to apply Kevin's version.  This is what the checks say:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Kevin's formulation</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">submodule.span_as_sum</span>\n<span class=\"n\">submodule.span_as_sum</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">},</span>\n    <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">c.support</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">c.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">((</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- original formulation</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">submodule.span_as_sum_mine</span>\n<span class=\"n\">submodule.span_as_sum_mine</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">},</span>\n    <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">c.support</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">c.support</span><span class=\"o\">,</span> <span class=\"bp\">⇑</span><span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This actually means that I can apply the older version, but not the newer one.  Am I doing something wrong?</p>",
        "id": 228073434,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449276
    },
    {
        "content": "<p>Try <code>refine</code> -- <code>apply</code> isn't always as smart as it could be. But it could be the problem with the smul_add_hom. I bet <code>convert</code> works.</p>",
        "id": 228073532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614449363
    },
    {
        "content": "<p>actually, this is what I was doing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">csup</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">span_as_sum_mine</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 228073619,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449438
    },
    {
        "content": "<p>I could try with explicit type ascription.</p>",
        "id": 228073623,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449449
    },
    {
        "content": "<p>oh wait what -- you have universe issues, right?</p>",
        "id": 228073683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614449498
    },
    {
        "content": "<p>Yes, some <code>max {...}</code> weirdness</p>",
        "id": 228073752,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449567
    },
    {
        "content": "<p>That's the problem, Lean won't be able to unify the universes</p>",
        "id": 228073788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614449595
    },
    {
        "content": "<p>Type ascription is not looking good either</p>",
        "id": 228073791,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449600
    },
    {
        "content": "<p>I can't even get your version of my proof to compile -- can you post a MWE?</p>",
        "id": 228073868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614449671
    },
    {
        "content": "<p>My version doesn't have the universe issues</p>",
        "id": 228073887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614449701
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finsupp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">submodule.span_as_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c.support</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">c.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">span_induction</span> <span class=\"n\">hm</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">hm</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">finsupp.single</span> <span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">mem_support_single</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">hy.1</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">set.subset.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.union_subset</span> <span class=\"n\">hc</span> <span class=\"n\">hd</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finset.coe_union</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_subset</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">support_add</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hc</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.coe_smul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">right_ne_zero_of_mul</span> <span class=\"n\">hx</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">sum_smul_index'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.map_finsupp_sum</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n        <span class=\"n\">ext</span> <span class=\"n\">m</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(((</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">  Ideally, I would be able to prove this using the lemma above, but I cannot... -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">submodule.span_as_sum_mine</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">submodule.span</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c.support</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">c.support</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- the element `m` is in the span of `s`, if it is in the span of a finite subset `T ⊆ s`</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">Tv</span><span class=\"o\">,</span> <span class=\"n\">mT</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mem_span_finite_of_mem_span</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now that we know that our element `m` is in the span of `T ⊆ S`, we no longer need to carry</span>\n  <span class=\"c1\">-- around that it is also in the span of `S`</span>\n  <span class=\"n\">clear</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- prepare for doing induction on</span>\n  <span class=\"n\">revert</span> <span class=\"n\">m</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- induction on the finset `T`: the base case `T = ∅` is trivial.</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">s</span> <span class=\"n\">es</span> <span class=\"n\">me</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">me</span><span class=\"o\">⟩)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- clear unneded clutter (not sure why this did not go away on its own)</span>\n  <span class=\"n\">clear</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- induction step: we add an element `m1` to the finset `T`, we have an element `m`</span>\n  <span class=\"c1\">-- in the span of `T ∪ {m1}`</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">m1</span> <span class=\"n\">T</span> <span class=\"n\">m1T</span> <span class=\"n\">ih</span> <span class=\"n\">m</span> <span class=\"n\">s</span> <span class=\"n\">ims</span> <span class=\"n\">m1i</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- move sets/finsets around</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.coe_insert</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">m1i</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- we isolate the coefficient `a` of `m1`</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"bp\">↑</span><span class=\"n\">T</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">m1</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n    <span class=\"n\">mem_span_insert.mp</span> <span class=\"n\">m1i</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- apply the induction hypothesis to obtain the coefficients for the elements of `T`</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c1</span><span class=\"o\">,</span> <span class=\"n\">c1ss</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">c.support</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span> <span class=\"bp\">∧</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">c.support</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n    <span class=\"n\">ih</span> <span class=\"n\">rfl.subset</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- separate the cases in which the coefficient `a` of the \"new\" element `m1` vanishes...</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">a0</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- in this case, the coefficients that we get by induction work straight away</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">c1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">ims</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_insert_of_mem</span> <span class=\"o\">(</span><span class=\"n\">c1ss</span> <span class=\"n\">hg</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">zero_smul</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- or the new coefficient `a` is non-zero</span>\n  <span class=\"c1\">-- the new element `m1` is not in the support of the coefficients for `m` arising from the</span>\n  <span class=\"c1\">-- induction hypothesis</span>\n  <span class=\"k\">have</span> <span class=\"n\">mc1</span> <span class=\"o\">:</span> <span class=\"n\">m1</span> <span class=\"bp\">∉</span> <span class=\"n\">c1.support</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">m1T</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_coe.mp</span> <span class=\"o\">(</span><span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"n\">h</span> <span class=\"n\">c1ss</span><span class=\"o\">)),</span>\n  <span class=\"c1\">-- by construction, the support of `c1` does not contain `m1`</span>\n  <span class=\"k\">have</span> <span class=\"n\">dc1m</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">c1.support</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">m1</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finset.disjoint_singleton.mpr</span> <span class=\"n\">mc1</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- moreover, the involved coefficients are really the coefficients appearing in the support</span>\n  <span class=\"c1\">-- of `c1` and `{m1}`</span>\n  <span class=\"k\">have</span> <span class=\"n\">cpa</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"bp\">+</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">m1</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">=</span> <span class=\"n\">c1.support</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">m1</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">finsupp.support_add</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">finset.mem_of_subset</span> <span class=\"o\">(</span><span class=\"n\">eq.subset</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finsupp.support_add_eq</span> <span class=\"n\">dc1m</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- of course, `m` is the sum of the coefficients coming from the induction and</span>\n  <span class=\"c1\">-- the new coefficient `a` for `m1`</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">c1</span> <span class=\"bp\">+</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">m1</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">ims</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- make sure that the support is still contained in `T ∪ {m1}`</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- we use `hs`, once we undo trivialities</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cpa</span><span class=\"o\">,</span> <span class=\"n\">finset.union_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">set.mem_of_mem_of_subset</span> <span class=\"n\">hs</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finset.insert_eq</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_insert</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_insert</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set.insert_subset_insert</span> <span class=\"n\">c1ss</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- in this branch, we show that the element `m` really is the sum that we claim it is</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- remove clutter from the proof</span>\n    <span class=\"n\">clear</span> <span class=\"n\">m1i</span> <span class=\"n\">m1T</span> <span class=\"n\">hz</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- a complicated way of writing `a • m1`, as a sum over the singleton `{m1}`</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">m1</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"bp\">+</span> <span class=\"n\">finsupp.single</span> <span class=\"n\">m1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">m1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_singleton</span><span class=\"o\">,</span> <span class=\"n\">finsupp.coe_add</span><span class=\"o\">,</span> <span class=\"n\">pi.add_apply</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">finsupp.single_eq_same</span><span class=\"o\">],</span>\n      <span class=\"n\">refine</span> <span class=\"n\">add_left_eq_self.mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsupp.not_mem_support_iff.mp</span> <span class=\"n\">mc1</span><span class=\"o\">,</span> <span class=\"n\">zero_smul</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"c1\">-- we start by matching up term, first one of the sums equals `a • m1`</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cpa</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_union</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span> <span class=\"n\">at</span> <span class=\"n\">dc1m</span><span class=\"o\">),</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n      <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">finsupp.coe_add</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- next, we split the other sum</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">pi.add_apply</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_add_distrib</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- now we clear `a • m1` and one of the sums, since they are equal on both sides</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">add_right_inj</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">add_right_eq_self.mpr</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"c1\">-- we show that the remaining sum vanishes, by showing that all its terms vanish</span>\n    <span class=\"n\">refine</span> <span class=\"n\">finset.sum_eq_zero</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">xc1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"c1\">-- it suffices to show that we are `smul`ling by `0`</span>\n    <span class=\"n\">convert</span> <span class=\"n\">zero_smul</span> <span class=\"n\">_</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- for this, it suffices to show that `x` is not equal to `m1`</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finsupp.not_mem_support_iff</span><span class=\"o\">,</span> <span class=\"n\">finsupp.support_single_ne_zero</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">finset.not_mem_singleton</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- since `x` is in the support of `c1`, it follows that `x ≠ m1`, the proof is by contradiction</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mc1</span> <span class=\"n\">xc1</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">submodule.span_as_sum</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">submodule.span_as_sum_mine</span>\n</code></pre></div>",
        "id": 228073892,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449703
    },
    {
        "content": "<p>These are your proof first, then mine.  I changed your statement to the statement after the <code>change</code> in your original proof.</p>",
        "id": 228073933,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449745
    },
    {
        "content": "<p>In my VSCode, they compile.  I am on <code>toric</code> in lean liquid</p>",
        "id": 228074017,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614449821
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">finsupp</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">submodule.span_as_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>seems to fix the universe issues. No idea what's going on there.</p>",
        "id": 228074054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614449872
    },
    {
        "content": "<p>This is very strange.  Should I then change the PR as well?</p>",
        "id": 228074207,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614450006
    },
    {
        "content": "<p>With universes on, the <code>M : Type*</code> version of mine compiles to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">submodule.span_as_sum.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">semiring.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group.</span><span class=\"o\">{(</span><span class=\"n\">max</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">)}</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">semimodule.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">)}</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set.</span><span class=\"o\">{(</span><span class=\"n\">max</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">)}</span> <span class=\"n\">M</span><span class=\"o\">},</span>\n    <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">span.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">)}</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n       <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">c.support</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">c.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">((</span><span class=\"n\">smul_add_hom.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">)}</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so it introduces three universes but never spots that <code>max u_2 u_3</code> is the only time <code>u_2</code> and <code>u_3</code> are used.</p>",
        "id": 228074220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614450017
    },
    {
        "content": "<p>Yes, it does compile, but I could not apply it.</p>\n<p>In any case, I added the explicit universe in the PR as well and now I can apply it in my other file!</p>",
        "id": 228074339,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614450192
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 228074342,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614450194
    },
    {
        "content": "<p>Oh lol, I didn't use <code>finsupp.coe_smul</code>because my mathlib was 2 days old and it was added yesterday :P (that's why your version of my proof didn't compile for me).</p>\n<p>I asked about the universe issue in <a class=\"stream\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general\">#general</a></p>",
        "id": 228074723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614450667
    },
    {
        "content": "<p>The importance of a fresh copy of mathlib... Ahaha</p>\n<p>I saw the universe issue question, thanks!</p>",
        "id": 228074936,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1614450863
    },
    {
        "content": "<p>It's nice to see lemmas I add being used immediately :)</p>",
        "id": 228076493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614452691
    },
    {
        "content": "<p>Turns out the proof of the lemma was:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.image_id</span> <span class=\"n\">s</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp_rw</span> <span class=\"bp\">←</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">finsupp.mem_span_iff_total</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.mem_span_iff_total\">docs#finsupp.mem_span_iff_total</a></p>",
        "id": 228280739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614622987
    },
    {
        "content": "<p>Yeah Alex pointed that out ages ago</p>",
        "id": 228283824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614624085
    }
]
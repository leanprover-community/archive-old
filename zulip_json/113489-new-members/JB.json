[
    {
        "content": "<p>Hello, my name is Jáchym Barvínek. I am a PhD student from CTU in Prague. I am mainly doing research in logic-based AI. I have recently started learning LEAN (have played with other dependently typed systems before). I would be very happy if could look for help here with LEAN novice issues or perhaps have people criticize my code.</p>",
        "id": 234040140,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618143066
    },
    {
        "content": "<p>You've come to the right place! Feel free to post code snippets (try to make them a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, please), or links to github branches/repos.</p>",
        "id": 234040436,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618143370
    },
    {
        "content": "<p>You may also be interested in the \"Machine Learning for Theorem Proving\" stream here.</p>",
        "id": 234040449,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618143397
    },
    {
        "content": "<p>One thing I am currently working on concerns holonomic (a.k.a. P-recursive) sequences. I have tried to define them using lean. I think the following code mostly captures the idea, but I have no clue whether the code is \"good\" in terms of something that would be useful for working with in proofs. I would be happy if someone points me in a better direction :) </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n<span class=\"kn\">open</span> <span class=\"n\">vector</span>\n\n\n<span class=\"kd\">structure</span> <span class=\"n\">HolnomicSequence</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">initial_values</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">ℤ</span> <span class=\"n\">order</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">representing_polynomials</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">order</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">initial_values_cert</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">order</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">nth</span> <span class=\"n\">initial_values</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">seq</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">recurrence</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">order</span><span class=\"o\">),</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">order</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">nth</span> <span class=\"n\">representing_polynomials</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">seq</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n      <span class=\"n\">indices</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">order</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"n\">fintype.elems</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">order</span><span class=\"o\">)</span>\n      <span class=\"k\">in</span>\n    <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">indices.sum</span> <span class=\"n\">f</span>\n  <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234041454,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618144390
    },
    {
        "content": "<p>It looks pretty good. I only have a few tips:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">polynomial</span> <span class=\"n\">vector</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">HolonomicSequence</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">representing_polynomials</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">order</span> <span class=\"bp\">→</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">recurrence</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">order</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">order</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">representing_polynomials</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">seq</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234042204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618145097
    },
    {
        "content": "<ul>\n<li>You should use <code>fin n -&gt; A</code> for finite sequences instead of <code>vector</code>. There's a type alias for this but I forget the name</li>\n<li>Use <code>finset.univ</code> instead of <code>fintype.elems A</code>.</li>\n<li><code>fintype.univ.sum f</code> has special notation <code>∑ a : A, f a</code>, available through <code>open_locale big_operators</code></li>\n<li>The <code>initial_values</code> field is unnecessary since it is uniquely determined by <code>seq</code>. Instead, prove an extensionality lemma saying that two holonomic sequences that agree on the first <code>order</code> values are equal, and an existence lemma saying that given values at the first <code>order</code> elements it is possible to fill in the rest using the recurrence.</li>\n<li>You should generally avoid lets in statements since they get in the way when proving theorems.</li>\n<li><code>∀ (i ≥ order),</code> expands to <code>∀ (i) (H : i ≥ order),</code> so <code>recurrence had two </code>i` binders in it.</li>\n</ul>",
        "id": 234042546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618145437
    },
    {
        "content": "<p>This looks a bit like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_recurrence\">docs#linear_recurrence</a>, which might have some API design you could copy</p>",
        "id": 234042547,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618145441
    },
    {
        "content": "<p>Should that be <code>i - m</code> instead of <code>m - i</code>? The latter is always 0 given that  <code>i ≥ order</code> and <code>m &lt; order</code></p>",
        "id": 234042694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618145616
    },
    {
        "content": "<p>Mario Carneiro, thanks for the insight. Your solution looks much cleaner.  I have one more nooby question:  If I want to make and study a specific instance with, say <code>order := 2</code>, how do I actually construct a specific instance of <code>fin 2 → whatever</code>. Can I somehow pattern match on <code>fin 2</code>? So far, I was unable to figure out how to write that. I know this should be very basic.</p>",
        "id": 234063060,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618163173
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">asd</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">123</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"c1\">-- this is a contradiction</span>\n</code></pre></div>\n<p>The actual theorem name that shows that <code>h</code> is a contradiction is vanishing from my mind right now, but this is the main idea</p>",
        "id": 234064254,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618164223
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">asd</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">123</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 234064507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618164480
    },
    {
        "content": "<p><code>def asd := ![1, 123]</code> is easier</p>",
        "id": 234070872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618170613
    },
    {
        "content": "<p>(<code>import data.matrix.notation</code> first)</p>",
        "id": 234070911,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618170643
    },
    {
        "content": "<p>Thanks for the support guys. Where I could learn more about using the big operators? I am currently stuck at trying to prove the obvious thing that: <code>∀ (f : fin 2 → ℤ), ((∑ (x : fin 2), f) = f 0 + f 1)</code></p>",
        "id": 234074475,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618174024
    },
    {
        "content": "<p><code>by simp [fin.sum_univ_succ]</code></p>",
        "id": 234074721,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618174214
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.sum_univ_succ\">docs#fin.sum_univ_succ</a></p>",
        "id": 234074724,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618174222
    },
    {
        "content": "<p>Lemmas about sum are usually stated in term of <code>prod</code>, and are scattered across different files.</p>",
        "id": 234074766,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618174287
    },
    {
        "content": "<p>Ah, I was just missing the argument <code>x</code> inside the summation and nothing seemed to work, including <code>simp</code>. But, explicitly using the <code>simp [fin.sum_univ_succ]</code> rule helped reveal that.</p>",
        "id": 234075085,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618174593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/JB/near/234070872\">said</a>:</p>\n<blockquote>\n<p><code>def asd := ![1, 123]</code> is easier</p>\n</blockquote>\n<p>woah thats really cool notation, thanks Eric!</p>",
        "id": 234079122,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618177930
    },
    {
        "content": "<p>I am confused about the polynomials library. There is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- `eval x p` is the evaluation of the polynomial `p` at `x` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">eval₂</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"sd\">/-- `monomial s a` is the monomial `a * X^s` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">monomial</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">finsupp.lsingle</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>So according to the documentation,  I would expect that: <code>eval (monomial (2 : ℕ) (3 : ℤ)) (5 : ℤ)</code> would corresponds to</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo separator=\"true\">,</mo><mi>x</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">3x^2, x = 5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0585479999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span></span></p>\n<p>which evaluates to 75.  But instead lean tells me that: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>I guess this must be somehow related to the <code>ring_hom.id</code> in definition of <code>eval</code>, which I do not I understand precisely, but it makes the result somehow live in the same space  of polynomials over ℤ  instead of ℤ, but that should not be a problem in itself if I can just prove it's constant and extract the value? So how do I get the \"expected\" behavior with <code>eval₂</code>? Do I need to construct a ring homomorphism from polynomials ℤ to ℤ or something?</p>",
        "id": 234080517,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618179269
    },
    {
        "content": "<p>You have the arguments to <code>eval</code> the wrong way around.</p>",
        "id": 234082005,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1618180897
    },
    {
        "content": "<p>You are evaluating the constant polynomial <code>5 : polynomial (polynomial ℤ)</code> at the polynomial <code>monomial (2 : ℕ) (3 : ℤ)</code></p>",
        "id": 234082064,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1618180935
    },
    {
        "content": "<p>oh, wow, thanks, I feel kinda dumb now, but at the same impressed that this has passes the typecheck, haha.</p>",
        "id": 234082388,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618181312
    },
    {
        "content": "<p>Still struggling working with the big operators. Using the <code>simp [fin.sum_univ_succ]</code> works only partially for me and I cannot understand why it's not possible to simplify some things in the sums, where I would expect <code>rewrite</code> to do the job, but it does not. Modified the above example based on your various tips:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">polynomial</span> <span class=\"n\">vector</span> <span class=\"n\">nat</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">HolonomicSequence</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">representing_polynomials</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Inspired by the API of linear_recurrence.is_solution</span>\n<span class=\"c1\">-- Does not consider initial sequence terms now (for simplicity)</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_solution</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">HolonomicSequence</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">A.order</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n             <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">A.order</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n                <span class=\"n\">eval</span> <span class=\"bp\">↑</span><span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">A.representing_polynomials</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">seq</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n             <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"sd\">/-- Representation of factorial as a holonomic sequence --/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">factorial_rep</span> <span class=\"o\">:</span> <span class=\"n\">HolonomicSequence</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">representing_polynomials</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">monomial</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">monomial</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">factorial_holonomic</span> <span class=\"o\">:</span> <span class=\"n\">is_solution</span> <span class=\"n\">factorial_rep</span> <span class=\"bp\">↑</span><span class=\"n\">factorial</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">ho</span> <span class=\"o\">:</span> <span class=\"n\">factorial_rep.order</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"c1\">--rewrite ho, -- Attempt to rewrite `factorial_rep.order` inside goal.</span>\n                <span class=\"c1\">-- But that doesn't work, why?</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- simp fails to expand the sum completely.</span>\n  <span class=\"c1\">-- Apparently because `fin (factorial_rep.order + 1)` was unevaluated.</span>\n  <span class=\"c1\">-- but how to evaluate that when rewrite can't do that?</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234125097,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618217901
    },
    {
        "content": "<p>Does this help?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">factorial_holonomic</span> <span class=\"o\">:</span> <span class=\"n\">is_solution</span> <span class=\"n\">factorial_rep</span> <span class=\"bp\">↑</span><span class=\"n\">factorial</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">ho</span> <span class=\"o\">:</span> <span class=\"n\">factorial_rep.order</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">factorial_rep</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">ho</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">],</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>You can't rewrite for several technical reasons. The first is that the <code>rw</code> tactic can't see under binders (like a sum). The second is that you have \"motive is not type correct\" issues -- the rewrite changes the type <code>fin (order + 1)</code> to <code>fin 1 + 1</code> and then terms of that type get confused. This is a subtle issue and there are lots of solutions. The easiest way to get around it is the <code>subst</code> tactic, but this doesn't work either, immediately at least, because we need to take <code>factorial_rep</code> apart before we can get to the term we want to substitute.</p>",
        "id": 234126688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618218700
    },
    {
        "content": "<p>PS actually here's a better approach. You have made this definition <code>factorial_rep</code> and I think the first thing to do is just to remove it -- this solves all your problems immediately. I also tidied up the polynomials -- you don't really want be working directly with <code>monomial</code>s I don't think.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">polynomial</span> <span class=\"n\">vector</span> <span class=\"n\">nat</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">HolonomicSequence</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">representing_polynomials</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Inspired by the API of linear_recurrence.is_solution</span>\n<span class=\"c1\">-- Does not consider initial sequence terms now (for simplicity)</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_solution</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">HolonomicSequence</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">A.order</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n             <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">A.order</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n                <span class=\"n\">eval</span> <span class=\"bp\">↑</span><span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">A.representing_polynomials</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">seq</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n             <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n<span class=\"sd\">/-- Representation of factorial as a holonomic sequence --/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">factorial_rep</span> <span class=\"o\">:</span> <span class=\"n\">HolonomicSequence</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">representing_polynomials</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"c1\">-- much more readable</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">factorial_holonomic</span> <span class=\"o\">:</span> <span class=\"n\">is_solution</span> <span class=\"n\">factorial_rep</span> <span class=\"bp\">↑</span><span class=\"n\">factorial</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">factorial_rep</span><span class=\"o\">,</span> <span class=\"c1\">-- remove this def ASAP and now it's fine</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"c1\">-- tidy up the mess left by the def</span>\n  <span class=\"k\">assume</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">],</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234127494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618219128
    },
    {
        "content": "<p>Here's another way to state your condition that may or may not be better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_solution</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">HolonomicSequence</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">m</span> <span class=\"k\">in</span> <span class=\"n\">finset.nat.antidiagonal</span> <span class=\"n\">A.order</span><span class=\"o\">,</span>\n                <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">A.order</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A.representing_polynomials</span> <span class=\"n\">m.1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">seq</span> <span class=\"o\">(</span><span class=\"n\">m.2</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n             <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 234128489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618219653
    },
    {
        "content": "<p>Actually, that's probably akward due to the mixture of fin and nat</p>",
        "id": 234128624,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618219725
    },
    {
        "content": "<p>OK, thanks all, I managed to complete the proof of the \"obvious by definition for a human\" fact, that factorial is holonomic. I am kinda proud of myself :D but also concerned how long the proof seems given the triviality of the problem. But I guess that may be inevitable in many cases with proof assistants?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">factorial_holonomic</span> <span class=\"o\">:</span> <span class=\"n\">is_solution</span> <span class=\"n\">factorial_rep</span> <span class=\"bp\">↑</span><span class=\"n\">factorial</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rewrite</span> <span class=\"n\">factorial_rep</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"c1\">--dsimp at *, -- has aesthetic value, but technically not needed</span>\n  <span class=\"k\">assume</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">],</span>\n  <span class=\"k\">let</span> <span class=\"n\">i_pred</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h_i_pred</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">i_pred</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"n\">pred_inj</span> <span class=\"n\">i_bound</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">factorial_rec</span> <span class=\"o\">:</span> <span class=\"n\">factorial</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">factorial</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"n\">rewrite</span> <span class=\"n\">h_i_pred</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold_coes</span><span class=\"o\">,</span>\n  <span class=\"n\">rewrite</span> <span class=\"n\">factorial_rec</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234139212,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618225343
    },
    {
        "content": "<p>It becomes a lot easier if you avoid <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lift_fn_range\">docs#lift_fn_range</a> (which <code>↑factorial</code> uses):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">factorial_holonomic</span> <span class=\"o\">:</span> <span class=\"n\">is_solution</span> <span class=\"n\">factorial_rep</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">factorial</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rewrite</span> <span class=\"n\">factorial_rep</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">nat.exists_eq_add_of_le</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"mi\">1</span> <span class=\"n\">x</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234140708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618226320
    },
    {
        "content": "<p>That seems much more reasonable, Eric. Is there a simple way to search for the useful simplification rules (<code>fin.sum_univ_succ, add_comm 1 x</code> here)? I doubt that I would be able to find any of those in the library myself. Do we mostly have to rely on naming conventions and text search or is there any automation like with <code>library_search</code> or <code>suggest</code>?</p>",
        "id": 234142119,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618227144
    },
    {
        "content": "<p>I reached for <code>add_comm</code> because I had <code>(1 + x).factorial</code> but knew that the simp lemma was for <code>x.succ.factorial = (x + 1).factorial</code></p>",
        "id": 234142573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618227383
    },
    {
        "content": "<p><code>suggest</code> might have been able to find <code>fin.sum_univ_succ</code></p>",
        "id": 234142593,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618227396
    },
    {
        "content": "<p>Inspired by your solution i managed to solve the coercion by a single <code>unfold_coes</code> even for the lifted case.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">is_solution</span> <span class=\"n\">factorial_rep</span> <span class=\"bp\">↑</span><span class=\"n\">factorial</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rewrite</span> <span class=\"n\">factorial_rep</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i_pred</span><span class=\"o\">,</span> <span class=\"n\">h_i_pred</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_eq_add_of_le</span> <span class=\"n\">i_bound</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold_coes</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">,</span> <span class=\"n\">h_i_pred</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"mi\">1</span> <span class=\"n\">i_pred</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234150808,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618231573
    },
    {
        "content": "<p>I guess this should be a very common question, but still: What is the closest I get in LEAN to Isabelle's sledgehammer? I use <code>suggest</code>, <code>hint</code> and <code>library_search</code> for some automation, but often that's not much. Is there more? I understand it is difficult to reasonably run a resolution-based prover when using higher order logics, but perhaps it would be possible in some limited contexts?</p>",
        "id": 234524874,
        "sender_full_name": "Jáchym Barvínek",
        "timestamp": 1618415626
    },
    {
        "content": "<p>The closest you get is <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>'s  work on a hammer for Lean, which I think is waiting for Lean 4.</p>",
        "id": 234526284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618416098
    },
    {
        "content": "<p>PS I am only tagging Gabriel because you have adopted a rather poor naming policy for your threads.</p>",
        "id": 234526423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618416138
    },
    {
        "content": "<p>Yes, I hope to pick up the hammer again now that Lean 4 is out.  There is a Lean 3 prototype, but it's way too slow to be useful.</p>",
        "id": 234526990,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1618416332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"404588\">@Jáchym Barvínek</span> there's also <code>tidy</code> which can be quite helpful at times.</p>",
        "id": 234528578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618416905
    }
]
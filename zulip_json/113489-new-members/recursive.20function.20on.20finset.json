[
    {
        "content": "<p>I am trying to define voting systems in Lean, so that I can formalize theorems about these voting systems. I am hoping to define recursive voting systems like <a href=\"https://en.wikipedia.org/wiki/Instant-runoff_voting\">Instant Runoff Voting</a> which iteratively remove candidates until a winner is chosen. </p>\n<p>In particular, I am working to define \"Simple Stable Voting\" in Lean.  Here is the <a href=\"https://arxiv.org/pdf/2108.00542v1.pdf\">paper</a> I am looking at, and here is a <a href=\"/user_uploads/3121/iPgzgnHOYw2HIKWFJ4DPx4lK/simple-stable-voting.png\">description</a>  of the voting system from that paper: </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/iPgzgnHOYw2HIKWFJ4DPx4lK/simple-stable-voting.png\" title=\"description\"><img src=\"/user_uploads/3121/iPgzgnHOYw2HIKWFJ4DPx4lK/simple-stable-voting.png\"></a></div><p>I have sketched up a rough framework for defining this kind of voting system in Lean (<a href=\"/user_uploads/3121/1oBUKayyO1iiHLTFz_s7ku_o/stable_voting_mwe.lean\">mwe with more explanation</a>): </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">election_profile</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">candidates</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">voters</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">υ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ballots</span> <span class=\"o\">:</span> <span class=\"n\">υ</span> <span class=\"bp\">→</span> <span class=\"n\">χ</span> <span class=\"bp\">→</span> <span class=\"n\">χ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_stable_voting</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">election_profile</span> <span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">prof</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">prof</span> <span class=\"k\">with</span> <span class=\"n\">X</span> <span class=\"n\">V</span> <span class=\"n\">R</span><span class=\"bp\">ᵢ</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I figure I will need to perform some kind of induction on the <code>finset</code> <code>X</code>. I have tried to read through Chapter 8 on recursion and induction in <em>TPIL</em>, and I think I understand how to define simple recursive functions on natural numbers, but I have no clue where to start when it comes to defining a recursive function on a <code>finset</code>.</p>",
        "id": 262248793,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637512355
    },
    {
        "content": "<p>I assume I will need to handle three cases. If the set of candidates is empty, then the function outputs a junk value (the empty set) because you can't pick a winner from 0 candidates. If there is one candidate, then the function should output a <code>finset</code> with only that candidate as a winner. Then, I need to perform some kind of recursion on this base case to handle further cases.</p>",
        "id": 262248880,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637512475
    },
    {
        "content": "<p>You probably want to induct on the size of the finset</p>",
        "id": 262248901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637512518
    },
    {
        "content": "<p>Normally you could use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.induction\">docs#finset.induction</a> but in this case you want to remove a particular element from the set (the losing candidate) in the recursive call</p>",
        "id": 262248958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637512575
    },
    {
        "content": "<p>Hm, let's say I define <code>n</code> to be the size of <code>X</code> like this: <code>n : ℕ := X.card</code>. How can I actually induct on that natural number in this case? Like I understand how to use the <code>induction</code> tactic or apply the <code>finset.induction_on</code> lemma when I am trying to prove a proposition, but I don't understand how to use these things so well when I'm trying to define a function</p>",
        "id": 262249223,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637512963
    },
    {
        "content": "<p>For example, Lean doesn't like this because Lean fails to create a new goal: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simple_stable_voting</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">election_profile</span> <span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">prof</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">prof</span> <span class=\"k\">with</span> <span class=\"n\">X</span> <span class=\"n\">V</span> <span class=\"n\">R</span><span class=\"bp\">ᵢ</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">X.card</span> <span class=\"k\">with</span> <span class=\"n\">hX</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262249299,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637513052
    },
    {
        "content": "<p>Random idea, but maybe you can first define the voting system on <code>list</code>?</p>",
        "id": 262249391,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637513163
    },
    {
        "content": "<p>Like handle a list of candidates instead of a finset of candidates, because <code>list</code> is a more primitive object, so induction might be a bit easier?</p>",
        "id": 262249431,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637513267
    },
    {
        "content": "<p>Maybe that could be a good first step to wrap my head around this stuff.</p>",
        "id": 262249494,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637513367
    },
    {
        "content": "<p><code>let</code>/<code>set</code> screws up <code>induction</code> because it doesn't know how to deal with <code>let</code> variables in the context. Use <code>generalize</code> instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simple_stable_voting</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">election_profile</span> <span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">prof</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">prof</span> <span class=\"k\">with</span> <span class=\"n\">X</span> <span class=\"n\">V</span> <span class=\"n\">R</span><span class=\"bp\">ᵢ</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">generalizing</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262249555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1637513439
    },
    {
        "content": "<p>Exciting, thank you Mario!!! I will play with this and see if it turns out fruitful.</p>",
        "id": 262249656,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637513577
    },
    {
        "content": "<p>Actually, another quick question. Is there an easy way to split off the <code>X.card=0</code> case AND the <code>X.card=1</code> case before proceeding with the recursion? Similar to this example in TPIL: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span>            <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">zero</span><span class=\"o\">)</span>     <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 262249832,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637513798
    },
    {
        "content": "<p>You can do <code>cases n with d</code> just before the induction and you'll be left with n=0 and n=succ(d), and then you can do <code>cases d with t</code> and you'll be left with the cases d=0 and d=succ(t).</p>",
        "id": 262249912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637513972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366882\">Andrew  Souther</span> <a href=\"#narrow/stream/113489-new-members/topic/recursive.20function.20on.20finset/near/262249431\">said</a>:</p>\n<blockquote>\n<p>Like handle a list of candidates instead of a finset of candidates, because <code>list</code> is a more primitive object, so induction might be a bit easier?</p>\n</blockquote>\n<p>Yes. Once you do this, you then have to prove your algorithm doesn't depend on the order the list was in, and then you can make it a function on <code>multiset</code>s.</p>",
        "id": 262253012,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637518257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366882\">Andrew  Souther</span> has marked this topic as unresolved.</p>",
        "id": 262262804,
        "sender_full_name": "Notification Bot",
        "timestamp": 1637531828
    },
    {
        "content": "<p>Is it ok to unresolve? Or is it encouraged to open a new conversation?</p>",
        "id": 262262823,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637531859
    },
    {
        "content": "<p>I just want to ask further questions about the definition Kyle posted above</p>",
        "id": 262262831,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637531873
    },
    {
        "content": "<p>back in the old days (last month or so) it was impossible to resolve questions, and I think half of us are still just ignoring this feature. So just keep going.</p>",
        "id": 262262875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637531898
    },
    {
        "content": "<p>I am just trying to prove some simple lemmas using this definition, get a sense what the difficulties are, so perhaps that can inform a cleaner definition going forward.</p>\n<p>First, I am trying to prove that when there is only one candidate, <code>simple_stable_voting</code> simply outputs the set of candidates. This is the second \"case\" in teh recursive definition of the function. </p>\n<p>I have found that <code>finish</code> does the job, but I want to be more explicit: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">election_profile</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">candidates</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">candidates.card</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">voters</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">υ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">voters.card</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ballots</span> <span class=\"o\">:</span> <span class=\"n\">υ</span> <span class=\"bp\">→</span> <span class=\"n\">χ</span> <span class=\"bp\">→</span> <span class=\"n\">χ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"n\">s.nonempty</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">finset.card_pos</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_stable_voting'</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">voters</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ballots</span> <span class=\"o\">:</span> <span class=\"n\">υ</span> <span class=\"bp\">→</span> <span class=\"n\">χ</span> <span class=\"bp\">→</span> <span class=\"n\">χ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">χ</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">decidable_rel</span> <span class=\"o\">(</span><span class=\"n\">ballots</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">candidates</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">candidates.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">cpos</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">nat.not_lt_zero</span> <span class=\"n\">_</span> <span class=\"n\">cpos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"n\">candidates</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">candidates</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">cands</span> <span class=\"n\">hn</span> <span class=\"n\">cpos</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span>\n  <span class=\"c1\">-- whether c wins when candidate rem is removed</span>\n  <span class=\"n\">still_wins</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">rem</span> <span class=\"o\">:</span> <span class=\"n\">χ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rem_prop</span> <span class=\"o\">:</span> <span class=\"n\">rem</span> <span class=\"bp\">∈</span> <span class=\"n\">cands</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">simple_stable_voting'</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cands.erase</span> <span class=\"n\">rem</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.card_erase_of_mem</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">rem_prop</span><span class=\"o\">],</span> <span class=\"o\">})</span>\n          <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- the margin for candidate c vs c'</span>\n  <span class=\"n\">margin</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">c'</span> <span class=\"o\">:</span> <span class=\"n\">χ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">voters.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ballots</span> <span class=\"n\">v</span> <span class=\"n\">c</span> <span class=\"n\">c'</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">voters.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ballots</span> <span class=\"n\">v</span> <span class=\"n\">c'</span> <span class=\"n\">c</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- the set of pairs (c, c') of candidates such that when c' is removed, c is a winner.</span>\n  <span class=\"n\">viable</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"bp\">×</span> <span class=\"n\">χ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">finset.image</span> <span class=\"n\">coe</span> <span class=\"bp\">$</span>\n    <span class=\"o\">(</span><span class=\"n\">cands.product</span> <span class=\"n\">cands</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">attach.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">cands.product</span> <span class=\"n\">cands</span><span class=\"o\">),</span>\n      <span class=\"n\">still_wins</span> <span class=\"n\">p.1.1</span> <span class=\"n\">p.1.2</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">p_property</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">p_property.2</span><span class=\"o\">,</span> <span class=\"o\">})),</span>\n  <span class=\"c1\">-- find the maximal margin (using 0 if viable is somehow empty)</span>\n  <span class=\"n\">best_margin</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">viable.nonempty</span> <span class=\"k\">then</span> <span class=\"n\">viable.sup'</span> <span class=\"n\">hn</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">margin</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n<span class=\"k\">in</span> <span class=\"n\">finset.image</span> <span class=\"n\">prod.fst</span> <span class=\"bp\">$</span> <span class=\"n\">viable.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">margin</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span> <span class=\"bp\">=</span> <span class=\"n\">best_margin</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simple_stable_voting</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">prof</span> <span class=\"o\">:</span> <span class=\"n\">election_profile</span> <span class=\"n\">χ</span> <span class=\"n\">υ</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">χ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">decidable_rel</span> <span class=\"o\">(</span><span class=\"n\">prof.ballots</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">χ</span> <span class=\"o\">:=</span>\n<span class=\"n\">simple_stable_voting'</span> <span class=\"n\">prof.voters</span> <span class=\"n\">prof.ballots</span> <span class=\"n\">prof.candidates.card</span> <span class=\"n\">prof.candidates</span> <span class=\"n\">rfl</span> <span class=\"n\">prof.cpos</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ssv_singleton</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">prof</span> <span class=\"o\">:</span> <span class=\"n\">election_profile</span> <span class=\"n\">χ</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hcands</span> <span class=\"o\">:</span> <span class=\"n\">prof.candidates.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">χ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">decidable_rel</span> <span class=\"o\">(</span><span class=\"n\">prof.ballots</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">simple_stable_voting</span> <span class=\"n\">prof</span> <span class=\"bp\">=</span> <span class=\"n\">prof.candidates</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">simple_stable_voting</span><span class=\"bp\">;</span> <span class=\"n\">finish</span>\n</code></pre></div>",
        "id": 262263060,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637532104
    },
    {
        "content": "<p>After unfolding <code>simple_stable_voting</code>, how can I actually use <code>hcands</code> to convince Lean we are on that second case of the definition where the number of candidates equals 1?</p>",
        "id": 262263119,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1637532153
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ssv_singleton</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">prof</span> <span class=\"o\">:</span> <span class=\"n\">election_profile</span> <span class=\"n\">χ</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hcands</span> <span class=\"o\">:</span> <span class=\"n\">prof.candidates.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">χ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">decidable_rel</span> <span class=\"o\">(</span><span class=\"n\">prof.ballots</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">simple_stable_voting</span> <span class=\"n\">prof</span> <span class=\"bp\">=</span> <span class=\"n\">prof.candidates</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">simple_stable_voting</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">simple_stable_voting'</span><span class=\"o\">,</span> <span class=\"n\">hcands</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262263310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637532435
    },
    {
        "content": "<p><code>simp only</code> works too. You're dancing around \"motive is not type correct\" here if you try to do it manually.</p>",
        "id": 262263381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637532506
    },
    {
        "content": "<p><code>#print prefix simple_stable_voting'</code> gives you access to the things the simplifier knows and which it's hiding from you; looks like <code>simple_stable_voting'._main.equations._eqn_2</code> is what you want.</p>",
        "id": 262263481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637532656
    },
    {
        "content": "<p>You have some complex inductive definition, it's usually best to let the simplifier deal with these foundational issues.</p>",
        "id": 262263651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637532868
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ssv_singleton</span> <span class=\"o\">{</span><span class=\"n\">χ</span> <span class=\"n\">υ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">prof</span> <span class=\"o\">:</span> <span class=\"n\">election_profile</span> <span class=\"n\">χ</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hcands</span> <span class=\"o\">:</span> <span class=\"n\">prof.candidates.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">χ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">decidable_rel</span> <span class=\"o\">(</span><span class=\"n\">prof.ballots</span> <span class=\"n\">v</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">simple_stable_voting</span> <span class=\"n\">prof</span> <span class=\"bp\">=</span> <span class=\"n\">prof.candidates</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">simple_stable_voting</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">simple_stable_voting'._main.equations._eqn_2</span> <span class=\"n\">prof.voters</span> <span class=\"n\">prof.ballots</span> <span class=\"n\">_</span> <span class=\"n\">hcands</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hcands</span><span class=\"o\">],</span>\n  <span class=\"n\">congr'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262263898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637533185
    },
    {
        "content": "<p>If you instead of <code>simp only [hcands]</code> you write <code>show_term {simp only [hcands]}</code> you can see the explicit argument it finds. Oh -- <code>refl</code> works instead of <code>congr'</code>.</p>",
        "id": 262264086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637533434
    }
]
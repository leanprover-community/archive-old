[
    {
        "content": "<p>I'm trying to state the following in lean:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">every</span> <span class=\"n\">A</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"n\">may</span> <span class=\"n\">be</span> <span class=\"n\">expressed</span> <span class=\"n\">one</span> <span class=\"n\">and</span> <span class=\"n\">only</span> <span class=\"n\">one</span> <span class=\"n\">way</span> <span class=\"n\">as</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"err\">∑</span><span class=\"bp\">_</span><span class=\"n\">r</span> <span class=\"n\">Ar</span> <span class=\"n\">where</span> <span class=\"n\">Ar</span> <span class=\"err\">∈</span> <span class=\"n\">Gr</span> <span class=\"n\">and</span> <span class=\"n\">all</span> <span class=\"n\">but</span> <span class=\"n\">finitely</span> <span class=\"n\">many</span> <span class=\"n\">Ar</span> <span class=\"n\">vanish</span><span class=\"bp\">.</span>\n</code></pre></div>\n\n\n<p>I've attempted to write that as </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">graded_algebra_iso</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">graded_algebra_components</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"n\">r</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_inj</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">from_fun</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"c1\">-- to_fun is injective</span>\n<span class=\"o\">(</span><span class=\"n\">from_iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">∑</span> <span class=\"n\">r</span> <span class=\"k\">in</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"n\">r</span> <span class=\"n\">g</span><span class=\"o\">)))</span> <span class=\"c1\">-- the domain of `from_fun r` covers all of `G`</span>\n</code></pre></div>\n\n\n<p>but the <code>∑ </code> is unhappy because <code>ℕ</code> is not a <code>finset</code>. I think the issue is my definition does not account for the \" all but finitely many Ar vanish\" part.</p>",
        "id": 202589859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593620401
    },
    {
        "content": "<p>Solved!</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">from_iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">rs</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"err\">∉</span> <span class=\"n\">rs</span><span class=\"o\">,</span> <span class=\"n\">from_fun</span> <span class=\"n\">r</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"err\">∑</span> <span class=\"n\">r</span> <span class=\"k\">in</span> <span class=\"n\">rs</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"n\">r</span> <span class=\"n\">g</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 202593715,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593622208
    },
    {
        "content": "<p>We also have <a href=\"https://leanprover-community.github.io/mathlib_docs/data/finsupp.html#top\"><code>finsupp</code>s</a>, which might be useful here.</p>",
        "id": 202594016,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593622338
    },
    {
        "content": "<p>It's not immediately clear to me how to apply that</p>",
        "id": 202594664,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593622652
    },
    {
        "content": "<p>Yes, it will definitely take some wrangling. Maybe looking at how it's used in <code>linear_algebra.basis</code> will help, particularly e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_basis.repr\">docs#is_basis.repr</a> and other theorems around there.</p>",
        "id": 202595806,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593623175
    },
    {
        "content": "<p>Defining an infinite-dimensional geometric algebra is that it is essential to the treatment of manifolds in Chapter 4 of Clifford Algebra to Geometric Calculus.</p>",
        "id": 202652373,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593668961
    },
    {
        "content": "<p>Is there code to do this for infinitely many Ar? We'll eventually need it.</p>",
        "id": 202652441,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593669006
    },
    {
        "content": "<p>As David Sheets is working on this in Agda.</p>",
        "id": 202652680,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593669331
    },
    {
        "content": "<p>It's better if we can assume nothing of the finiteness of the dimension at the outset and have a finite version later.</p>",
        "id": 202652763,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593669412
    },
    {
        "content": "<p>linear algebra in mathlib seems to be doing exactly this.</p>",
        "id": 202652770,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593669433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113489-new-members/topic/Expressing.20a.20sum.20with.20finitely.20many.20nonzero.20terms/near/202652441\">said</a>:</p>\n<blockquote>\n<p>Is there code to do this for infinitely many Ar? We'll eventually need it.</p>\n</blockquote>\n<p>What is Ar?</p>",
        "id": 202652776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593669449
    },
    {
        "content": "<p><code>A r</code> as in <code>(A : ℕ → Type u)</code></p>",
        "id": 202652840,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593669526
    },
    {
        "content": "<p>It doesn't matter what it is concretely here. The question is only about summing (multiplying) infinitely with the familiar <code>big_operators</code> in Lean.</p>",
        "id": 202653006,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593669738
    },
    {
        "content": "<p>Aha, as opposed to <code>A : (fin n) → Type</code>?</p>",
        "id": 202653141,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593669940
    },
    {
        "content": "<p>Yes</p>",
        "id": 202653144,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593669954
    },
    {
        "content": "<p>I think it's nontrivial to allow for both <code>nat</code> and <code>fin n</code> as indexing types. But it can be done.</p>",
        "id": 202653183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593669968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Would it be safe to take <code>A : nat → Type</code> as a field of a structure, and an axiom <code>\\for k, n &lt; k → A k = empty</code>?</p>",
        "id": 202653215,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670025
    },
    {
        "content": "<p>type equality bad</p>",
        "id": 202653233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593670075
    },
    {
        "content": "<p>Yup... guessed that...</p>",
        "id": 202653278,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670093
    },
    {
        "content": "<p><code>\\for k, n &lt; k, \\not nonempty (A k)</code> is better</p>",
        "id": 202653279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593670095
    },
    {
        "content": "<p>or <code>A k -&gt; false</code> if you prefer</p>",
        "id": 202653288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593670113
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> And now you could do this for <code>n : enat</code>, and then you would have merged <code>nat</code> and <code>fin n</code>.</p>",
        "id": 202653308,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670166
    },
    {
        "content": "<p>if you use <code>nat</code>, then why is the sum finite?</p>",
        "id": 202653366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593670209
    },
    {
        "content": "<p>I guess because you are looking at the direct sum of the <code>A i</code></p>",
        "id": 202653478,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593670389
    },
    {
        "content": "<p>One way to write <code>from_iso</code> using <code>dfinsupp</code> is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">from_iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"err\">₀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">from_fun</span> <span class=\"n\">r</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 202653667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593670626
    },
    {
        "content": "<p>alternatively you can bake this into <code>from_fun</code> by reordering the arguments to</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π</span><span class=\"err\">₀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 202653821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593670820
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">graded_algebra_iso</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">graded_algebra_components</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"n\">r</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π</span><span class=\"err\">₀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">to_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">from_fun</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">from_iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>(untested)</p>",
        "id": 202653903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593670936
    },
    {
        "content": "<p>It's much more readable now!</p>\n<p>To be sure, <code>Π₀ r</code> allows optional <code>fin r</code> and it can also work like the ordinary <code>Π r</code> which assumes no finiteness?</p>",
        "id": 202654489,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593671699
    },
    {
        "content": "<p>I'm confused by what you mean/want.</p>",
        "id": 202654627,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593671851
    },
    {
        "content": "<p>I was thinking about an approach that we first do everything about <code>ℕ</code> assuming no finiteness, then do things about <code>fin n</code> assuming the finiteness. But the <code>enat</code> and <code>Π₀</code> gave me the impressions that I can merge two steps into one but I can't see how lemmas only apply to the finite version interact with the infinite version (could be more general (so every lemma in the infinite version apply to the finite version)or could have its own special lemmas).</p>\n<p>But I won't know whether this impression is correct until I try some proofs with the defs with <code>enat</code> and <code>Π₀</code>. (I'm guessing I'm wrong)</p>",
        "id": 202655069,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593672394
    },
    {
        "content": "<p>I think you can merge the definitions.</p>",
        "id": 202655275,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593672632
    },
    {
        "content": "<p>Q: what is this number called, the maximal <code>r</code> such that <code>A r</code> is non-trivial?</p>",
        "id": 202655295,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593672656
    },
    {
        "content": "<p>with this approach, you only ever use <code>nat</code>, and the <code>Π₀</code> ensures that the <code>A r</code> are eventually trivial</p>",
        "id": 202655982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593673274
    },
    {
        "content": "<p>I don't get what's the triviality being talked about here.</p>",
        "id": 202656082,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593673337
    },
    {
        "content": "<p><code>A r = {0}</code></p>",
        "id": 202656093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593673349
    },
    {
        "content": "<p>I see. But it can also be non-trivial even for <code>A \\inf</code>, right?</p>",
        "id": 202656241,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593673461
    },
    {
        "content": "<p>Actually I think the version I wrote allows for this to not happen</p>",
        "id": 202656249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593673471
    },
    {
        "content": "<p>there is no <code>A inf</code> in the version I wrote, or the version you wrote at the beginning</p>",
        "id": 202656295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593673517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> We are mixing <code>A : nat → Type</code> and <code>n : enat</code>.</p>",
        "id": 202656396,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593673593
    },
    {
        "content": "<p>I think Johan thinks that these conditions imply that there are only finitely many nonzero <code>A r</code> sets, but the finiteness is different for each <code>g : G</code> so I think that's not necessarily the case</p>",
        "id": 202656405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593673602
    },
    {
        "content": "<p>I could be wrong though, this is an unusual definition that I don't know much about</p>",
        "id": 202656424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593673625
    },
    {
        "content": "<p>No, there can be infinitely many nonzero <code>A r</code>, if I understand Utensil correctly</p>",
        "id": 202656573,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593673774
    },
    {
        "content": "<p>Yes, there can be infinitely many nonzero <code>A r</code></p>",
        "id": 202656640,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593673812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> Is there a name for the maximal degree (possibly inf) for which <code>A r</code> is nonzero?</p>",
        "id": 202656644,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593673820
    },
    {
        "content": "<p>I think the original text description given by Eric at the start of this thread doesn't match the statement of <code>to_inj</code></p>",
        "id": 202656806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593673990
    },
    {
        "content": "<p>I think the uniqueness should be something like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"n\">r</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π</span><span class=\"err\">₀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">from_iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">from_fun</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 202656886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593674069
    },
    {
        "content": "<p>That is also enough to prove that <code>\\all r (v : A r), from_fun (to_fun v) = single r v</code></p>",
        "id": 202657281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593674380
    },
    {
        "content": "<p>also the names of <code>from_fun</code> and <code>to_fun</code> seem to be swapped</p>",
        "id": 202657301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593674395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Expressing.20a.20sum.20with.20finitely.20many.20nonzero.20terms/near/202656644\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> Is there a name for the maximal degree (possibly inf) for which <code>A r</code> is nonzero?</p>\n</blockquote>\n<p>I don't see explicitly naming it in literature. But it's equal to the dimension of the vector space that Clifford Algebra is extending. If one begins with a real countably infinite-dimensional vector space and assumes sufficient structure on this space, a Clifford algebra will be generated, the same for the finite-dimensional case. The infinite-dimensional Clifford algebra contains all finite-dimensional Clifford algebras.</p>",
        "id": 202658094,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593675032
    },
    {
        "content": "<p>So in the infinite dimensional case you don't want indexing by <code>nat</code> by some ordinal or something?</p>",
        "id": 202658812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593675618
    },
    {
        "content": "<p>Is enat enough? How about <code>fin' n</code> for <code>n : enat</code>?</p>",
        "id": 202659186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593675976
    },
    {
        "content": "<p>The <code>dfinsupp</code> definition doesn't require anything for the type of <code>r</code> except that it have a 0 so that <code>A 0</code> makes sense</p>",
        "id": 202659352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593676200
    },
    {
        "content": "<p>in fact <code>A 0</code> could just be some other ring here</p>",
        "id": 202659403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593676214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Expressing.20a.20sum.20with.20finitely.20many.20nonzero.20terms/near/202658812\">said</a>:</p>\n<blockquote>\n<p>So in the infinite dimensional case you don't want indexing by <code>nat</code> by some ordinal or something?</p>\n</blockquote>\n<p>In the relevant proofs, it seems it's always lazily and relatively indexed. Like assuming <code>A p</code> and <code>A q</code> then later there would be <code>A p+q</code>in the proof.</p>",
        "id": 202660427,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593677165
    },
    {
        "content": "<p>I could not find <code>fin'</code></p>",
        "id": 202660612,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593677355
    },
    {
        "content": "<p>It doesn't exist.</p>",
        "id": 202660613,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593677362
    },
    {
        "content": "<p>Kevin was proposing if it should be defined</p>",
        "id": 202660620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593677370
    },
    {
        "content": "<p>I've seen a few <code>sth'</code> or <code>sth2</code> in mathlib. Shouldn't this be discouraged?</p>",
        "id": 202661462,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593678137
    },
    {
        "content": "<p>It could be enat.fin if you like</p>",
        "id": 202661870,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593678437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Expressing.20a.20sum.20with.20finitely.20many.20nonzero.20terms/near/202656886\">said</a>:</p>\n<blockquote>\n<p>I think the uniqueness should be something like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"n\">r</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">from_fun</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π</span><span class=\"err\">₀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">from_iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">from_fun</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>Thanks for this. Unfortunately, that example fails for me due to inability to synthesize a type class instance for <code>Π (i : ℕ) (x : A i), decidable (x ≠ 0)</code></p>",
        "id": 202664335,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593680303
    },
    {
        "content": "<p><code>open_locale classical</code></p>",
        "id": 202665193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593680999
    },
    {
        "content": "<p>Now I'm left with the problem of synthesizing <code>semimodule (A 0) (Π₀ (r : ℕ), A r)</code> from<code>∀ r, module (A 0) (A r)</code> - which is presumably because I need something captureing both <code>→ₗ</code> and <code>Π₀</code></p>",
        "id": 202665301,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593681065
    },
    {
        "content": "<p>that should be in mathlib</p>",
        "id": 202665409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593681154
    },
    {
        "content": "<p>\"I think its there already\" or \"it should be there if it isn't\"?</p>",
        "id": 202665430,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593681180
    },
    {
        "content": "<p>both</p>",
        "id": 202665451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593681195
    },
    {
        "content": "<p>Maybe I need to update</p>",
        "id": 202665470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593681217
    },
    {
        "content": "<p>it is there, but it's not an instance. Try <code>attribute [instance] dfinsupp.to_semimodule</code></p>",
        "id": 202665487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593681227
    },
    {
        "content": "<p>Sure enough, that does the trick</p>",
        "id": 202665550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593681251
    },
    {
        "content": "<p>Should that be an instance?</p>",
        "id": 202665556,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593681254
    },
    {
        "content": "<p>I think so</p>",
        "id": 202665565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593681262
    },
    {
        "content": "<p>it's probably leftover from a change to <code>module</code> before which it could not safely be an instance</p>",
        "id": 202665594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593681293
    },
    {
        "content": "<p>I'm confused about the effect of <code>attribute [instance]</code></p>",
        "id": 202667514,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593682790
    },
    {
        "content": "<p>It marks the bundled field as elegible for type class lookup, I think</p>",
        "id": 202667585,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593682813
    },
    {
        "content": "<p><code>@[instance] def</code> is the same as <code>instance</code></p>",
        "id": 202667589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593682816
    },
    {
        "content": "<p>What's its natural form</p>",
        "id": 202667598,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593682821
    },
    {
        "content": "<p>It's just a tag on definitions saying \"hey type class inference system, look at me\"</p>",
        "id": 202667630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593682851
    },
    {
        "content": "<p>and you can mark a def as an instance after the fact using <code>attribute [instance]</code> or more commonly <code>local attribute [instance]</code></p>",
        "id": 202667646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593682864
    },
    {
        "content": "<p><code>instance</code> (with a proof) v.s. <code>@[instance]</code> v.s. <code>attribute [instance]</code></p>",
        "id": 202667660,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593682873
    },
    {
        "content": "<p><code>[instance]</code> is an attribute that you can stick on definitions just like <code>@[simp]</code> and others</p>",
        "id": 202667751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593682924
    },
    {
        "content": "<p>Can <code>@[instance]</code> be used in this case?</p>",
        "id": 202667752,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593682928
    },
    {
        "content": "<p>You use <code>@[instance]</code> at the moment you're making the def</p>",
        "id": 202667765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593682942
    },
    {
        "content": "<p><code>instance foo</code> is the same as <code>@[instance] def foo</code></p>",
        "id": 202667775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593682949
    },
    {
        "content": "<p>and only at the moment?</p>",
        "id": 202667779,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593682955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Expressing.20a.20sum.20with.20finitely.20many.20nonzero.20terms/near/202667646\">said</a>:</p>\n<blockquote>\n<p>and you can mark a def as an instance after the fact using <code>attribute [instance]</code> or more commonly <code>local attribute [instance]</code></p>\n</blockquote>",
        "id": 202667794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593682967
    },
    {
        "content": "<p>I mean: is it that<code>@</code> can only be used at the moment of definition and <code>attribute</code> can only be used after the definition?</p>",
        "id": 202667820,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593683003
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"c1\">-- Option 1 --</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">37</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n\n<span class=\"c1\">-- Option 2 --</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">37</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n\n<span class=\"c1\">-- Option 3 --</span>\n<span class=\"n\">def</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">37</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n<span class=\"kn\">section</span>\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">foo</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">foo</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 202668049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593683208
    },
    {
        "content": "<p>You can also write <code>attribute [instance] def nat.foo : foo nat := ⟨37⟩</code> instead but this is usually not used</p>",
        "id": 202668090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593683278
    },
    {
        "content": "<p>The <code>@[attr]</code> form only works immediately before a keyword like <code>def</code> or <code>theorem</code></p>",
        "id": 202668151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593683308
    },
    {
        "content": "<p>The <code>attribute [attr] nat.foo</code> form works as a standalone command but requires the name of the definition(s) being marked</p>",
        "id": 202668193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593683352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Expressing.20a.20sum.20with.20finitely.20many.20nonzero.20terms/near/202657281\">said</a>:</p>\n<blockquote>\n<p>That is also enough to prove that <code>\\all r (v : A r), from_fun (to_fun v) = single r v</code></p>\n</blockquote>\n<p>Any tips for that proof?</p>",
        "id": 202668499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593683579
    },
    {
        "content": "<p>Applying <code>from_iso</code>, you have to prove <code>to_fun v = (single r v).sum (λ r, to_fun)</code>, which follows from <code>sum_single_index</code></p>",
        "id": 202668628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593683697
    },
    {
        "content": "<p>Thanks, will see what I can come up with, then ask how to simplify my proof :)</p>",
        "id": 202668706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593683756
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  <span class=\"kn\">lemma</span> <span class=\"n\">from_zulip</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">select</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">dfinsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">r</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">from_iso</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dfinsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">r</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n    <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">dfinsupp</span><span class=\"bp\">.</span><span class=\"n\">sum_single_index</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202669170,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593684082
    },
    {
        "content": "<p>you can write that in term mode if you want, probably something like <code>((from_iso _ _).2 (dfinsupp.sum_single_index _ (linear_map.map_zero _)).symm).symm</code> although I can't say for sure without an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 202669548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593684339
    },
    {
        "content": "<p>Would it be sensible to define my <code>from_iso</code> with the both equalities reversed to avoid needing the symm?</p>",
        "id": 202669641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593684401
    },
    {
        "content": "<p>I would wait to see 5 or 6 uses of the theorem before taking a guess on which direction is more common</p>",
        "id": 202669716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593684456
    },
    {
        "content": "<p>One final question before I write all this up - is this a suitable set of precedences for notation?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">notation</span> <span class=\"bp\">`⟨`</span><span class=\"n\">g</span><span class=\"bp\">`⟩_`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"n\">r</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">graded_algebra_iso</span><span class=\"bp\">.</span><span class=\"n\">from_fun</span> <span class=\"n\">g</span> <span class=\"n\">r</span>\n</code></pre></div>\n\n\n<p>The problem I'm having is that for <code>v : A r</code>, I can't seem to write <code>⟨v : G⟩_r</code> but have to add parentheses for the syntax to be understood as  <code>⟨(v : G)⟩_r</code></p>",
        "id": 202670818,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593685317
    },
    {
        "content": "<p>I guess in the spirit of the tail recursion, it's usually better to add the \"new\" thing to the right and proofs usually start cracking it from the right. But I don't know how to apply this principle to this case...</p>",
        "id": 202671485,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593685803
    },
    {
        "content": "<p>Wrapped this up at <a href=\"https://github.com/pygae/lean-ga/pull/5\">https://github.com/pygae/lean-ga/pull/5</a> for anyone interested.</p>",
        "id": 202691686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593698334
    },
    {
        "content": "<p>A related question: how to express \"generated by\" in Lean?</p>",
        "id": 202798521,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593779380
    },
    {
        "content": "<p>What I can find is in <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/noetherian.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/noetherian.lean</a></p>\n<h2>Main definitions</h2>\n<p>Let <code>R</code> be a ring and let <code>M</code> and <code>P</code> be <code>R</code>-modules. Let <code>N</code> be an <code>R</code>-submodule of <code>M</code>.</p>\n<ul>\n<li><code>fg N : Prop</code> is the assertion that <code>N</code> is finitely generated as an <code>R</code>-module.</li>\n<li><code>is_noetherian R M</code> is the proposition that <code>M</code> is a Noetherian <code>R</code>-module. It is a class,<br>\n  implemented as the predicate that all <code>R</code>-submodules of <code>M</code> are finitely generated.</li>\n</ul>",
        "id": 202798830,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593779580
    },
    {
        "content": "<p>Did you look at the implementation of <code>fg</code> or <code>is_noetherian</code>?</p>",
        "id": 202799450,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1593780009
    },
    {
        "content": "<p>The subobject generated by X is typically called <code>span X</code>, and \"X generates A\" is typically just written <code>span X = \\top</code></p>",
        "id": 202799815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593780295
    },
    {
        "content": "<p>I don't understand it when the implementation reaches the part about complete lattices.</p>",
        "id": 202800348,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593780628
    },
    {
        "content": "<p>Complete lattices by itself look well defined, but I don't understand the necessity of using it to express/implement a pretty elementary concept <code>span</code>.</p>",
        "id": 202800684,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593780854
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/CZU1pJJoXa6QMxLTXFuBhVVe/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/CZU1pJJoXa6QMxLTXFuBhVVe/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/CZU1pJJoXa6QMxLTXFuBhVVe/image.png\"></a></div>",
        "id": 202800773,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593780927
    },
    {
        "content": "<p>Where is that image from?</p>",
        "id": 202800803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593780954
    },
    {
        "content": "<p>Mathlib paper</p>",
        "id": 202800887,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593780990
    },
    {
        "content": "<p>There is a \"bottom-up\" and a \"top-down\" way to define span</p>",
        "id": 202800905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593781006
    },
    {
        "content": "<p>The \"top-down\" way is to define the foo-span of the set X as the intersection of all the foos which contain X</p>",
        "id": 202800955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593781046
    },
    {
        "content": "<p>The bottom-up way is to make some new set recursively, which contains X and is closed under all the foo axioms</p>",
        "id": 202801034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593781083
    },
    {
        "content": "<p>Ah, I see how this applies to linear algebra.</p>",
        "id": 202801912,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593781680
    },
    {
        "content": "<p>But the question at our hand seems to be:</p>\n<p>If we think of Grassmann Algebra as a vector space generated by its subspaces, this seems to be sufficient. But the subspaces, in turn, are generated by vectors. So how to express the concept of Grassmann Algebra is \"generated\" by vectors via wedge product?</p>",
        "id": 202801962,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593781697
    },
    {
        "content": "<p>(using Grassmann Algebra for a simpler analogy of Clifford Algebra)</p>",
        "id": 202802016,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593781755
    },
    {
        "content": "<p>You can apply the same method to subalgebras.</p>",
        "id": 202802350,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593781988
    },
    {
        "content": "<p>So in this case, I was kind of thinking about things like generators in group theory.</p>",
        "id": 202802373,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593782000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Expressing.20a.20sum.20with.20finitely.20many.20nonzero.20terms/near/202802350\">said</a>:</p>\n<blockquote>\n<p>You can apply the same method to subalgebras.</p>\n</blockquote>\n<p>So do I have to use a two-level <code>span</code> here?</p>",
        "id": 202802403,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593782028
    },
    {
        "content": "<p>Also, I don't get the remark of the \"tension\" <a href=\"#narrow/stream/113489-new-members/topic/cleaning.20up.20this.20tactic.20proof.20%28regarding.20closures%29/near/193043418\">here</a>.</p>",
        "id": 202802529,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593782117
    },
    {
        "content": "<p>I need more help to help you here. Which part you don't get?</p>",
        "id": 202802888,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593782362
    },
    {
        "content": "<p>Is it the non-zero characteristic thing?</p>",
        "id": 202803005,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593782446
    },
    {
        "content": "<p>\"the fact (seen as the subspace of multilinear maps) is clearly wrong in positive characteristic where (seen as a quotient of the tensor algebra)\"</p>",
        "id": 202803056,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593782510
    },
    {
        "content": "<p>I understand what's in the parentheses and not the sentence connecting them.</p>",
        "id": 202803131,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593782540
    },
    {
        "content": "<p>Where do you see this quote?</p>",
        "id": 202803258,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593782638
    },
    {
        "content": "<p>I see</p>\n<blockquote>\n<p>There is a tension between having <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Λ</mi><mi>k</mi></msup><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Lambda^k V^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Λ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> seen as the subspace of multilinear maps from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">V^k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> to the base field which happen to be antisymmetric, which is nice and concrete, and the fact this is clearly wrong in positive characteristic where there is no other choice than seeing it as a <em>quotient</em> of the tensor algebra.</p>\n</blockquote>",
        "id": 202803337,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593782661
    },
    {
        "content": "<p>Let me try again. In any case, there is a very concrete elementary thing  which is the subspace of multilinear forms made of antisymmetric forms. And there is a slightly more abstract thing which is a quotient of the space of multilinear forms by some subspace. In characteristic zero, there is an isomorphism between those things, so there is not much loss in forgetting about the abstract one. In positive characteristic you can't.</p>",
        "id": 202803550,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593782810
    },
    {
        "content": "<p>I see</p>",
        "id": 202803767,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593782983
    },
    {
        "content": "<p>So the approach might be using the latter as a general definition, and prove the former is isomorphic to the latter in characteristic zero?</p>",
        "id": 202803903,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593783065
    },
    {
        "content": "<p>Probably yes, but this kind of question is hard to answer with total confidence without trying. Note that there is an additional complication: in the positive characteristic world, characteristic 2 is a world of its own. In characteristic 2, you'll also have to be careful that alternating and antisymmetric are not the same thing.</p>",
        "id": 202804282,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593783346
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/wbGSy-i03J8mgmJIaarLBYLU/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wbGSy-i03J8mgmJIaarLBYLU/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/wbGSy-i03J8mgmJIaarLBYLU/image.png\"></a></div><p><a href=\"/user_uploads/3121/5GLsuZV5Mg1udm92Aa81HlE3/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/5GLsuZV5Mg1udm92Aa81HlE3/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/5GLsuZV5Mg1udm92Aa81HlE3/image.png\"></a></div><p>from Clifford Algebras and Spinor Structures.</p>\n<p>It elaborates on the issue here and there seems possible to have some reasonable solutions to this. But, yeah, hard to answer without trying.</p>",
        "id": 202805607,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593784282
    },
    {
        "content": "<p>Back to \"generated by\". <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> used a pretty elementary way to \"generate\" subobjects (i.e. r-blade) by orthogonal vectors, but I don't know how can that be connected to the abstract way(complete lattices) of expressing <code>span</code>.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_rblade</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- a product of orthogonal vectors an a scalar</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">G₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">pairwise_ortho_vector</span> <span class=\"n\">r</span><span class=\"o\">),</span>\n   <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">fₛ</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"err\">ᵥ</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>as in <a href=\"https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean#L108\">https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean#L108</a></p>",
        "id": 202806724,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593784957
    },
    {
        "content": "<p>I had a variant of the definition on <a href=\"https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean#L228\">https://github.com/pygae/lean-ga/blob/master/src/geometric_algebra/nursery/chisolm.lean#L228</a> that used lattices via <code>def Mᵣ (r : ℕ) := ⨆ s &lt;= r, Gᵣ s</code>, if that helps</p>",
        "id": 202807016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593785144
    },
    {
        "content": "<p>I think I accidentally merged your two PRs with parallel designs in mind into one file which happens to have no conflict</p>",
        "id": 202807307,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593785303
    },
    {
        "content": "<p><del>You 100% did</del> I thought so too, but can't see any evidence of the second one</p>",
        "id": 202807743,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1593785624
    },
    {
        "content": "<p>I see</p>",
        "id": 202808236,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593785956
    },
    {
        "content": "<p>The branch in <a href=\"https://github.com/pygae/lean-ga/issues/4\">pygae/lean-ga#4</a> is based on <a href=\"https://github.com/pygae/lean-ga/issues/3\">pygae/lean-ga#3</a> (which deleted the whole <a href=\"https://github.com/pygae/lean-ga/issues/3\">pygae/lean-ga#3</a> in <a href=\"https://github.com/pygae/lean-ga/commit/9235ca262b12b4e7f8861a7dfcfd0cdc401069de\">https://github.com/pygae/lean-ga/commit/9235ca262b12b4e7f8861a7dfcfd0cdc401069de</a> ) .</p>",
        "id": 202808368,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593786019
    },
    {
        "content": "<p>The meta-question here might be how to connect the more elementary presentation of a subject with the mathematical rigorous and abstract treatment. Both can be done in Lean, but it's difficult to establish a link. Geometric Algebra, as reformulated by Hestenes and many from Clifford Algebra, is meant to be more elementary and application-oriented. This more elementary formalism (which is meant to do \"application\" level reasoning) is unlikely to be PRed into mathlib, but mathlib would certainly have a general version of Clifford Algebra, which would be of little interest of the intended audience here. But it would be nice to show the elementary version is isomorphic to the general version under certain conditions.</p>",
        "id": 202808492,
        "sender_full_name": "Utensil Song",
        "timestamp": 1593786112
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Free_algebra\">Free module</a> seems to be related, see also <a href=\"https://gist.github.com/sflicht/53bdcdb1e3536e668736f7b4eb63cd79\">free.lean</a> discussed <a href=\"#narrow/stream/116395-maths/topic/f.2Eg.2E.20free.20modules/near/199450926\">here</a>, seems that it hasn't made into mathlib yet.</p>",
        "id": 203473258,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594362391
    }
]
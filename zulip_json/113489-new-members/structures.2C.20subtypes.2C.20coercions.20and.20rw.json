[
    {
        "content": "<p>I have two questions that puzzle me.<br>\nThe context is similar in both, a group <code>G</code> acting on a type <code>X</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>1) The first one is about <code>is_pretransitive</code>, defined as a structure.<br>\nAssume I have <code>H: subgroup G</code> and the hypothesis <code>h: is_pretransitive ↥H X</code> (meaning that <code>H</code>acts pretransitively on <code>X</code>), as well as two members <code>x y : X</code>. <br>\nI want to recover the defining property of <code>is_pretransitive</code>,  <code>exists_smul_eq</code>, which expands as <code>∀ (x y : X), ∃ (g : ↥H), g • x = y</code>, and apply it to <code>x</code>and <code>y</code>, to recover <code>g</code>, but while the following </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">h.exists_smul_eq</span><span class=\"o\">,</span>\n<span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">z</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>gives me what I want, namely, <code>g: ↥H</code> and <code>h: g • x = y</code>, the following </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.exists_smul_eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>returns a cryptic </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span>\n<span class=\"n\">function</span> <span class=\"bp\">'</span><span class=\"n\">mul_action.is_pretransitive.exists_smul_eq'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">explicit</span> <span class=\"n\">argument</span>\n<span class=\"k\">with</span> <span class=\"n\">type</span> <span class=\"o\">(</span><span class=\"n\">mul_action.is_pretransitive</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>2)  Anyway, at that point, I arrive at the following context, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span>  <span class=\"n\">X</span>\n<span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">H</span>\n<span class=\"n\">hgxy</span><span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n<span class=\"n\">z'</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">mul_aut.conj</span> <span class=\"bp\">↑</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">T</span> <span class=\"n\">x</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">H</span> <span class=\"bp\">⊔</span> <span class=\"n\">T</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>but I get coercions <code>↑g</code> that prevent me to <code>rw z'</code>. Can you explain me what I did wrong, or what goes on?<br>\nThank you !</p>",
        "id": 260344264,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1636065465
    },
    {
        "content": "<p>Can you paste a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? Then people can start playing with the code</p>",
        "id": 260344775,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1636065785
    },
    {
        "content": "<p>I think I got it. Don't worry, Ruben.</p>",
        "id": 260344947,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636065900
    },
    {
        "content": "<p>This works for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">mul_action.is_pretransitive</span> <span class=\"n\">H</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kn\">include</span> <span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"n\">H</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">H</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mul_action.exists_smul_eq</span> <span class=\"n\">H</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260345392,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1636066216
    },
    {
        "content": "<p>For 1), <code>is_pretransitive</code> is a <code>class</code> which makes it awkward to use values of the type directly--you're intended to write---what Adam just wrote.</p>",
        "id": 260345407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636066232
    },
    {
        "content": "<p>For 2), hard to say without knowing where <code>z'</code> came from</p>",
        "id": 260345447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636066287
    },
    {
        "content": "<p>I guess that <code>hgxy</code> is about the action of <code>H</code> while <code>z'</code> is about the action of <code>G</code>--are these the same by definition? If so you might be able to use <code>change</code> to massage <code>z'</code> into the form you want</p>",
        "id": 260345701,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636066445
    },
    {
        "content": "<p>or you can rewrite using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.smul_def\">docs#subgroup.smul_def</a></p>",
        "id": 260345801,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636066548
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/260344775\">said</a>:</p>\n<blockquote>\n<p>Can you paste a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? Then people can start playing with the code</p>\n</blockquote>\n<p>Here it is !</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">is_conj</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mul_aut.conj</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">is_generator</span><span class=\"o\">:</span> <span class=\"n\">supr</span> <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_pretransitive</span> <span class=\"n\">H</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">H</span> <span class=\"bp\">⊔</span> <span class=\"n\">T</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span>   <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">hHX</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">le_top</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">is_generator</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">supr</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">Sup_le</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">,</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hKy</span><span class=\"o\">⟩:=</span> <span class=\"n\">hK</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hKy</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">hHX.exists_smul_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">z</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">z'</span> <span class=\"o\">:=</span> <span class=\"n\">is_conj</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260345921,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1636066625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/260345447\">said</a>:</p>\n<blockquote>\n<p>For 2), hard to say without knowing where <code>z'</code> came from</p>\n</blockquote>\n<p>As you can see on the MWE, I have an hypothesis <code>is_conj: ∀ g: G, ∀ x : X, T (g • x) = mul_aut.conj g • (T x)</code> and I create <code>z'</code> by <code>let z' := is_conj (g:G) x</code>.</p>",
        "id": 260346536,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1636067022
    },
    {
        "content": "<p>I think using <code>subgroup.smul_def</code> is the way to go</p>",
        "id": 260347248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636067466
    },
    {
        "content": "<p>A new question that puzzled me for a few hours : <br>\nI need to make sense of something like this :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"bp\">↑</span><span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>What I could do is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but I am stuck of ideas to help me pass from the elementary second example to something that looks like the first one.</p>\n<p>Actually, this comes from a more complicated context, <code>group A</code>, <code>B : subgroup A</code>, and ultimately, I will need to apply <code>subgroup.closure</code> to both sets to identify <code>subgroup.closure { a : A | p a }</code> with <code>subgroup.closure { b : B | p ↑b }</code>.</p>",
        "id": 262448248,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637670266
    },
    {
        "content": "<p>This looks like you got lost in subtyping hell. Can you give the original problem instead?</p>",
        "id": 262448745,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637670591
    },
    {
        "content": "<p>Can the first example even be proved? The structure of the two types are different: you have <code>(x : { b : B | p b }).1.1.1 : α</code> but <code>(x : { b : A | p b }).1.1 : α</code>.</p>",
        "id": 262449231,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637670909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262448745\">said</a>:</p>\n<blockquote>\n<p>This looks like you got lost in subtyping hell. Can you give the original problem instead?</p>\n</blockquote>\n<p>Sure. I want to prove that the alternating group is simple, and to start with, that it is perfect (<code>commutator (alternating_group α) = ⊤</code>).<br>\nI have already proved : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">three_cycle_is_commutator</span> <span class=\"c1\">-- {α : Type*} [decidable_eq α] [fintype α]</span>\n  <span class=\"o\">[</span><span class=\"n\">h5</span><span class=\"o\">:</span> <span class=\"mi\">5</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">alternating_group</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"n\">is_three_cycle</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">commutator</span> <span class=\"o\">(</span><span class=\"n\">alternating_group</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- g^2 est conjugué de g : g^2 = h g h⁻¹ , donc hg = [h,g]</span>\n  <span class=\"k\">let</span> <span class=\"n\">hg2</span> <span class=\"o\">:=</span> <span class=\"n\">hg.is_three_cycle_sq</span><span class=\"o\">,</span> <span class=\"c1\">-- g^2 is a 3-cycle</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">subgroup.coe_mul</span> <span class=\"n\">_</span> <span class=\"n\">g</span> <span class=\"n\">g</span> <span class=\"n\">at</span> <span class=\"n\">hg2</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hh</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">alternating_group.is_three_cycle_is_conj</span> <span class=\"n\">h5</span> <span class=\"n\">hg</span> <span class=\"n\">hg2</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- g^2 is conjugate to g ;  hh :  g^2 * h = h * g</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">subgroup.closure_le_normal_closure</span> <span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subgroup.subset_closure</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">this.symm</span><span class=\"o\">⟩},</span>\n  <span class=\"n\">exact</span> <span class=\"k\">calc</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>  <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span>  <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hh.symm</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and I want to combine this with <br>\n<code>alternating_group.closure_three_cycles_eq_alternating :  closure {σ : perm α | is_three_cycle σ} = alternating_group α</code><br>\n(which is in <code>alternating.lean</code>) to get my result.</p>",
        "id": 262449290,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637670960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262449231\">said</a>:</p>\n<blockquote>\n<p>Can the first example even be proved? The structure of the two types are different: you have <code>(x : { b : B | p b }).1.1.1 : α</code> but <code>(x : { b : A | p b }).1.1 : α</code>.</p>\n</blockquote>\n<p>No, the types are different, but I need somehow to tell Lean that the two sets are equal, so that they will generate the same stuff afterwards…</p>",
        "id": 262449382,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637671002
    },
    {
        "content": "<p>This typechecks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">subtype.val</span> <span class=\"bp\">''</span> <span class=\"o\">{</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"bp\">↑</span><span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 262449446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637671039
    },
    {
        "content": "<p>Right, like <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> suggested, we need a map to translate <code>closure_three_cycles_eq_alternating</code>, a statement on subgroups of <code>perm α</code> to a statement on subgroups of <code>alternating_group α</code> like your goal and <code>three_cycle_is_commutator</code>.</p>",
        "id": 262449627,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637671170
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">subtype.val</span> <span class=\"bp\">''</span> <span class=\"o\">{</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"bp\">↑</span><span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_image</span><span class=\"o\">,</span> <span class=\"n\">set_coe.exists</span><span class=\"o\">,</span> <span class=\"n\">exists_and_distrib_right</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span>\n    <span class=\"n\">exists_eq_right</span><span class=\"o\">,</span> <span class=\"n\">subtype.exists</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hpa</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span> <span class=\"n\">_</span> <span class=\"n\">hpa</span><span class=\"o\">,</span> <span class=\"n\">hpa</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">H1</span><span class=\"o\">,</span> <span class=\"n\">H2</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">H2</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262449811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637671278
    },
    {
        "content": "<p>So what we're actually after is the dual form, <code>subtype.val '⁻¹ {a : A | p a} = {b : B | p B}</code>. Or in group-theoretic language <code>comap (alternating_group α).subtype (closure {σ : perm α | is_three_cycle σ}) = \\top</code>.</p>",
        "id": 262450018,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637671412
    },
    {
        "content": "<p>Every time I see <code>.subtype</code> I think it's a pretty horrible name for the inclusion map.</p>",
        "id": 262450208,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637671534
    },
    {
        "content": "<p>I'm confused, isn't <code>comap H.subtype H' = ⊤</code> simply saying that <code>H'</code> contains <code>H</code>?</p>",
        "id": 262450384,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637671655
    },
    {
        "content": "<p>Wouldn't it be better to write <code>H ≤ H'</code> in that case?</p>",
        "id": 262450402,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637671673
    },
    {
        "content": "<p>Indeed, that would be the next step towards proving the result :)</p>",
        "id": 262450484,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637671718
    },
    {
        "content": "<p>At least, I'm thinking of a proof of the lines </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">calc</span> <span class=\"n\">commutator</span> <span class=\"o\">(</span><span class=\"n\">alternating_group</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">conjugates_of_set</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">alternating_group</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">is_three_cycle</span> <span class=\"n\">σ</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">comap_subtype_eq_top</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(with <code>comap_subtype_eq_top</code> exactly what you mentioned)</p>",
        "id": 262450760,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637671880
    },
    {
        "content": "<p>(Some of these <code>=</code>es can equivalently be replaced <code>≤</code>s of course.)</p>",
        "id": 262450819,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637671920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262450208\">said</a>:</p>\n<blockquote>\n<p>Every time I see <code>.subtype</code> I think it's a pretty horrible name for the inclusion map.</p>\n</blockquote>\n<p>Note that for <code>subalgebra</code> it's called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subalgebra.val\">docs#subalgebra.val</a> instead</p>",
        "id": 262458797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637676004
    },
    {
        "content": "<p>Which makes sense, I guess. Although I think <code>.incl</code> is even more descriptive.</p>",
        "id": 262460639,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637676846
    },
    {
        "content": "<p>I think we use that name elsewhere for the inclusion map between two subobjects <code>p1 ≤ p2</code></p>",
        "id": 262461257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637677150
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.inclusion\">docs#submonoid.inclusion</a>?</p>",
        "id": 262461305,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637677174
    },
    {
        "content": "<p>Right, we want both</p>",
        "id": 262461491,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637677259
    },
    {
        "content": "<p>I suppose <code>incl</code> and <code>incl_of_le</code> would be reasonable names</p>",
        "id": 262464222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637678453
    },
    {
        "content": "<p>Although you could maybe argue that <code>subtype.val</code> should be renamed to <code>subtype.incl</code> too...</p>",
        "id": 262464274,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637678480
    },
    {
        "content": "<p>The difference is that <code>x.val</code> is dot-notation on a term of a subtype, whereas <code>H.incl</code> is dot-notation on a <code>subgroup</code> (or whatever).<br>\nBoth are also function-like gadgets. But <code>subtype.val</code> doesn't involve a <code>coe_to_sort</code>, whereas <code>H.incl</code> does.<br>\nMaybe <code>set.incl</code> should exist.</p>",
        "id": 262464653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637678629
    },
    {
        "content": "<p>Your discussion lost me! I'm trying to understand what <code>subtype.val</code> does… Is it the inclusion map from a <code>B</code> (viewed as a subtype of <code>A</code>) to <code>A</code>?</p>",
        "id": 262470064,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637680965
    },
    {
        "content": "<p>Thanks ! Now, to go back to my context, where I have <code>group A</code> and <code>B: subgroup A</code>, it seems that what I need to compare a given subgroup of <code>B</code>with another given subgroup of <code>A</code>, such as in </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- does not type - fill in ...</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">subgroup.closure</span> <span class=\"o\">({</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"bp\">...</span> <span class=\"o\">(</span><span class=\"n\">subgroup.closure</span><span class=\"o\">({</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">}))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 262472079,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637681864
    },
    {
        "content": "<p>Indeed! And the thing you want to fill for the dots are <code>subgroup.map B.subtype</code>, or what I think will turn out to be easier: put <code>subgroup.comap B.subtype</code> on the left instead.</p>",
        "id": 262472480,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637682023
    },
    {
        "content": "<p>(Easier means here: \"saves one rewrite step\", if we did it right.)</p>",
        "id": 262472583,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1637682066
    },
    {
        "content": "<p>BTW <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> <code>[B  : subgroup A]</code> should probably be <code>(B : subgroup A)</code> or <code>{B : subgroup A}</code>, as <code>subgroup</code> is not a class so square brackets won't do anything. The point is that 99 times out 100 a type has at most one group structure on it, but certainly it's commonplace that a group can have two subgroups, so <code>subgroup</code> shouldn't be a class.</p>",
        "id": 262476057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637683548
    },
    {
        "content": "<p>I'm making progress… but don't you find that the following sequence of instructions is absolutely ridiculous ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"n\">C</span> <span class=\"bp\">↔</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">hH</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.mem_map.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">((⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">eq.symm</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">set_like.coe_mk</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">hH</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subgroup.coe_subtype</span><span class=\"o\">,</span> <span class=\"n\">subgroup.coe_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hH</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">hH</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set_like.coe_eq_coe</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hH</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hH</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">subgroup.mem_map.mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subgroup.coe_subtype</span><span class=\"o\">,</span> <span class=\"n\">subgroup.coe_mk</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262493435,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637691282
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"n\">C</span> <span class=\"bp\">↔</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">tidy</span>\n</code></pre></div>",
        "id": 262494062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637691605
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"n\">C</span> <span class=\"bp\">↔</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262494428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637691791
    },
    {
        "content": "<p>I also found <code>by { simp [subgroup.mem_map, set_like.exists], tauto }</code> which may or may not be considered good style</p>",
        "id": 262494681,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637691923
    },
    {
        "content": "<p>Golfed further:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup.basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">subgroup</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"n\">C</span> <span class=\"bp\">↔</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">function.injective.mem_set_image</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">subtype.coe_injective</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 262500176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637694656
    },
    {
        "content": "<p>Y'all, you're sorcerers…</p>",
        "id": 262503666,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637696544
    },
    {
        "content": "<p>Would you have a link to a description of what <code>rintro</code> is used, especially with<code>rfl</code>?</p>",
        "id": 262504145,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637696814
    },
    {
        "content": "<p>Hopefully <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#rintro\">tactic#rintro</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases\">tactic#rcases</a> is helpful (edit: I guess you need to read both <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 262504429,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637696990
    },
    {
        "content": "<p>Thanks ! Meanwhile, I tried entering <code>rintro</code>in the google search window, and guess what?…</p>",
        "id": 262504653,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637697106
    },
    {
        "content": "<p>Just for fun, here is an incomprehensible version of Kevin's proof ;)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"n\">C</span> <span class=\"bp\">↔</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span><span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"bp\">λ</span><span class=\"n\">h</span><span class=\"o\">,⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>",
        "id": 262516361,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1637703085
    },
    {
        "content": "<p><code>⟨a,_⟩</code> can be <em>golfed</em> to <code>⟨_,_⟩</code></p>",
        "id": 262516927,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1637703408
    },
    {
        "content": "<p>That last <code>rfl</code> is doing it's job!</p>",
        "id": 262516977,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1637703439
    },
    {
        "content": "<p>I say <code>⟨λ⟨⟨_,_⟩,h,rfl⟩,h,λh,⟨_,h,rfl⟩⟩</code></p>",
        "id": 262516999,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1637703452
    },
    {
        "content": "<p>I am surprised this works -- I thought the <code>rfl</code> hack would not work with a lambda in term mode.</p>",
        "id": 262517161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637703553
    },
    {
        "content": "<p>And now with even more underscores:<br>\n<code>⟨λ⟨⟨_,_⟩,_,rfl⟩,‹_›,λ_,⟨⟨_,_⟩,‹_›,rfl⟩⟩</code></p>",
        "id": 262517291,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1637703611
    },
    {
        "content": "<p>Wow!! I've never really understood what <code>‹_›</code> means, but it's very nice</p>",
        "id": 262517412,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1637703691
    },
    {
        "content": "<p>it's basically just a short way to write <code>by assumption</code>!</p>",
        "id": 262517917,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1637703939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> here's an example of the rfl hack:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- recall that surjective f := ∀ y : Y, ∃ x : X, f x = y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">surjective</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- goal `⊢ ∃ (x : X), (g ∘ f) x = z`</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hg</span> <span class=\"n\">z</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- `hy : g y = z`</span>\n  <span class=\"c1\">-- so we have a *formula* for z now, it's g(y)</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hf</span> <span class=\"n\">y</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- and now `hx : f x = y`</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  z : Z</span>\n<span class=\"cm\">  y : Y</span>\n<span class=\"cm\">  hy : g y = z</span>\n<span class=\"cm\">  x : X</span>\n<span class=\"cm\">  hx : f x = y</span>\n<span class=\"cm\">  ⊢ (g ∘ f) x = z</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"c1\">-- there are now several ways to finish, e.g.</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- goal got closed because it's now refl and rw tries this</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">surjective</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- goal `⊢ ∃ (x : X), (g ∘ f) x = z`</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hg</span> <span class=\"n\">z</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"c1\">-- *define* z to be g(y)</span>\n  <span class=\"c1\">-- goal now `⊢ ∃ (a : X), (g ∘ f) a = g y`</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hf</span> <span class=\"n\">y</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- now there are no y's or z's in the local context, just</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  x: X</span>\n<span class=\"cm\">  ⊢ ∃ (a : X), (g ∘ f) a = g (f x)</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- goal was rfl so got closed because `use` tries `triv` which tries `refl`</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262518132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637704038
    },
    {
        "content": "<p>Little progress, Lean knows that the alternating group is perfect… With coercion hacks showing that I didn't really understand what y'all told me yesterday. See <a href=\"https://github.com/leanprover-community/mathlib/issues/10253\">#10253</a></p>",
        "id": 262589210,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637761203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> What do you think of the following approach?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- still quite stupid, but maybe not too bad</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ok_lemma</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">g</span><span class=\"o\">}</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)}</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- If n ≥ 5, then the alternating group on n letters is perfect -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">alternating_group_is_perfect</span> <span class=\"o\">(</span><span class=\"n\">h5</span> <span class=\"o\">:</span> <span class=\"mi\">5</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">commutator</span> <span class=\"o\">(</span><span class=\"n\">alternating_group</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">alternating_group</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_three_cycle</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_top_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">subgroup.closure_le</span><span class=\"o\">],</span>\n    <span class=\"n\">intros</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">three_cycle_mem_commutator</span> <span class=\"n\">h5</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">closure_three_cycles_eq_alternating</span><span class=\"o\">,</span> <span class=\"n\">ok_lemma</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262593359,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637763146
    },
    {
        "content": "<p>Let my try that, thanks! <br>\n(On the other hand, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> noted that the <code>ugly_lemma</code> matches  <code>submodule.comap_subtype_self</code> and should be put in <code>subgroup/basic.lean</code>  (Aside : how to refer to a file of the library or to a function so that it adds a link?)</p>",
        "id": 262594139,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637763506
    },
    {
        "content": "<p>you can type <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.comap_subtype_self\">docs#submodule.comap_subtype_self</a> or <a href=\"https://tqft.net/mathlib/group_theory/subgroup/basic\">file#group_theory/subgroup/basic</a> in Zulip, if that's what you mean</p>",
        "id": 262594662,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637763742
    },
    {
        "content": "<p>Is <code>ok_lemma</code> at all related to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure_closure_coe_preimage\">docs#subgroup.closure_closure_coe_preimage</a>?</p>",
        "id": 262594768,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637763800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262594768\">said</a>:</p>\n<blockquote>\n<p>Is <code>ok_lemma</code> at all related to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure_closure_coe_preimage\">docs#subgroup.closure_closure_coe_preimage</a>?</p>\n</blockquote>\n<p>Ugh! That statement is unreadable in the docs <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 262595433,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637764028
    },
    {
        "content": "<p>But I think it is exactly <code>ok_lemma</code></p>",
        "id": 262595457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637764049
    },
    {
        "content": "<p>It would be nice if we could teach doc-gen (or maybe the pretty-printer?) to show  unapplied<code>coe</code> with a type annotation</p>",
        "id": 262595907,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637764273
    },
    {
        "content": "<p>It seems my bersion of subgroup.basic.lean is not recent enough… I tried <code>leanproject get-cache</code>, <code>leanproject up</code>, <code>leanproject pull</code> but nothing happens.…</p>",
        "id": 262597753,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637765256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> Please take these steps:</p>\n<ol>\n<li>save and commit whatever you've still open</li>\n<li>run <code>git pull</code></li>\n<li>run <code>git merge master</code></li>\n<li>run <code>leanproject get-cache</code></li>\n</ol>",
        "id": 262598527,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637765599
    },
    {
        "content": "<p>Here's my own proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">_root_.subgroup.subtype_injective</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">function.injective</span> <span class=\"n\">H.subtype</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.val_injective</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">_root_.subgroup.map_top</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">subgroup.map</span> <span class=\"n\">f</span> <span class=\"bp\">⊤</span> <span class=\"bp\">=</span> <span class=\"n\">f.range</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iff_self</span><span class=\"o\">,</span> <span class=\"n\">mem_map</span><span class=\"o\">,</span> <span class=\"n\">monoid_hom.mem_range</span><span class=\"o\">,</span> <span class=\"n\">exists_true_left</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">mem_top</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">_root_.subgroup.map_closure</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">subgroup.map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_map</span><span class=\"o\">],</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">closure_induction</span> <span class=\"n\">hg</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">hh</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">subset_closure</span> <span class=\"o\">(</span><span class=\"n\">set.mem_image_of_mem</span> <span class=\"n\">_</span> <span class=\"n\">hh</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">f.map_one</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">one_mem</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">hh₁</span> <span class=\"n\">hh₂</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">f.map_mul</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">mul_mem</span> <span class=\"n\">_</span> <span class=\"n\">hh₁</span> <span class=\"n\">hh₂</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">hh</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">f.map_inv</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">inv_mem</span> <span class=\"n\">_</span> <span class=\"n\">hh</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">closure_induction</span> <span class=\"n\">hh</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">subset_closure</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">one_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f.map_one</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">g₁</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">g₂</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span><span class=\"o\">,</span> <span class=\"n\">mul_mem</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">f.map_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">inv_mem</span> <span class=\"n\">_</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">f.map_inv</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">_root_.set.coe_image_subtype_coe</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">coe</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">subtype</span> <span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">set.mem_image</span><span class=\"o\">,</span> <span class=\"n\">subtype.exists</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">h2</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ok_lemma</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">map_injective</span> <span class=\"o\">(</span><span class=\"n\">subgroup.subtype_injective</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subgroup.map_closure</span><span class=\"o\">,</span> <span class=\"n\">subgroup.map_closure</span><span class=\"o\">,</span> <span class=\"n\">subgroup.map_top</span><span class=\"o\">,</span> <span class=\"n\">subtype_range</span><span class=\"o\">,</span>\n    <span class=\"n\">subgroup.coe_subtype</span><span class=\"o\">],</span>\n  <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">set.coe_image_subtype_coe</span><span class=\"o\">],</span> <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">subset_closure</span> <span class=\"n\">hg</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262598573,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637765630
    },
    {
        "content": "<p>Looks like there's a bunch of missing lemmas. (At least I couldn't find them.)</p>",
        "id": 262598630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637765645
    },
    {
        "content": "<p><code>subgroup.map_top</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.range_eq_map\">docs#monoid_hom.range_eq_map</a></p>",
        "id": 262598741,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765704
    },
    {
        "content": "<p><del><code>subgroup.map_closure</code> might be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure_image\">docs#subgroup.closure_image</a></del></p>",
        "id": 262598893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765768
    },
    {
        "content": "<p>This works nicely, without any additional lemma !</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If n ≥ 5, then the alternating group on n letters is perfect -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">alternating_group_is_perfect</span> <span class=\"o\">(</span><span class=\"n\">h5</span> <span class=\"o\">:</span> <span class=\"mi\">5</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">commutator</span> <span class=\"o\">(</span><span class=\"n\">alternating_group</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">alternating_group</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_three_cycle</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_top_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">subgroup.closure_le</span><span class=\"o\">],</span>\n    <span class=\"n\">intros</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">three_cycle_mem_commutator</span> <span class=\"n\">h5</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">closure_three_cycles_eq_alternating</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">subgroup.closure_closure_coe_preimage</span> <span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262598954,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637765800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262598527\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> Please take these steps:</p>\n<ol>\n<li>save and commit whatever you've still open</li>\n<li>run <code>git pull</code></li>\n<li>run <code>git merge master</code></li>\n<li>run <code>leanproject get-cache</code></li>\n</ol>\n</blockquote>\n<p>What is the difference with <code>leanproject rebase</code>, which ultimately worked?<br>\n (I had done a <code>git stash</code> to preserve my modifications, and a <code>git stash pop</code> afterwards!)</p>",
        "id": 262599093,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637765868
    },
    {
        "content": "<p>Aah, I didn't yet know about <code>leanproject rebase</code>. But it does almost the same thing under the hood.</p>",
        "id": 262599868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637766233
    },
    {
        "content": "<p>In fact, I'm not sure, I had an ugly <code>git merge</code> to do, but the new PR is done !</p>",
        "id": 262600070,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637766346
    },
    {
        "content": "<p>Is it reasonable that I <code>merge 232 commits into master</code> ? <br>\nIt seems I should rather revert my previous commit…</p>",
        "id": 262601668,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637767145
    },
    {
        "content": "<p>Yeah, that doesn't sound good.</p>",
        "id": 262602457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637767507
    },
    {
        "content": "<p>The merge should rather go in the other direction</p>",
        "id": 262602467,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637767515
    },
    {
        "content": "<p>This is what I think too. <br>\nI tried to do a revert, but that didn't change anything.</p>",
        "id": 262603165,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637767822
    },
    {
        "content": "<p>(I think GitHub diff is just confused possibly, looking at and merging the branch locally it looks fine to me)</p>",
        "id": 262603639,
        "sender_full_name": "Julian Berman",
        "timestamp": 1637768048
    },
    {
        "content": "<p>What's your branch called?</p>",
        "id": 262603653,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1637768056
    },
    {
        "content": "<p>It sounds like you made this classic mistake:</p>\n<ul>\n<li><code>git rebase</code></li>\n<li><code>git push</code>, which errors saying that upstream has diverged</li>\n<li><code>git pull</code> (the mistake)</li>\n</ul>\n<p>After a rebase, you have to <code>git push -f</code>, not <code>git pull</code></p>",
        "id": 262604240,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768345
    },
    {
        "content": "<p>So now, what should I do ? <br>\nI have tried to revert to the earlier stuff (and I have a copy of the files in their correct versions).</p>",
        "id": 262604357,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637768407
    },
    {
        "content": "<p>What do you mean by \"revert\"?</p>",
        "id": 262604702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768595
    },
    {
        "content": "<p>do you mean <code>git revert</code> or <code>git reset</code>?</p>",
        "id": 262604720,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768604
    },
    {
        "content": "<p><code>revert</code> is not \"undo the git action I just did\", it's \"create a new commit that restores the files to how they were before the action I just did, on top of that action\"</p>",
        "id": 262604835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768652
    },
    {
        "content": "<p>I meant <code>revert</code>.…</p>",
        "id": 262604934,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637768727
    },
    {
        "content": "<p><code>git reset --hard THE_BAD_MERGE_COMMIT^</code> should get you back to where you were before the merge (and discard your local changes)</p>",
        "id": 262605194,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768853
    },
    {
        "content": "<p>You might want to stash before that</p>",
        "id": 262605223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768870
    },
    {
        "content": "<p>why not just make the PR and see what happens before doing anything drastic?</p>",
        "id": 262605245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637768882
    },
    {
        "content": "<p>bors squashes commits though no Eric? So yeah there's a bunch of noise there but technically it should be fine no? I think you can probably get the diff un-confused even by just pushing an empty commit, or if not just opening a new PR?</p>",
        "id": 262605267,
        "sender_full_name": "Julian Berman",
        "timestamp": 1637768883
    },
    {
        "content": "<p>I would generally not suggest <code>reset --hard</code> to someone who doesn't know what that does :)</p>",
        "id": 262605364,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1637768926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262605245\">said</a>:</p>\n<blockquote>\n<p>why not just make the PR and see what happens before doing anything drastic?</p>\n</blockquote>\n<p>The best time to unbork git history is immediatey after you bork it</p>",
        "id": 262605373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768928
    },
    {
        "content": "<p>Otherwise you build actual work on top of it and then you're in trouble</p>",
        "id": 262605387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637768941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262605245\">said</a>:</p>\n<blockquote>\n<p>why not just make the PR and see what happens before doing anything drastic?</p>\n</blockquote>\n<p>Nothing is really drastic, I have copies of the two files which I have modified.</p>",
        "id": 262605420,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637768959
    },
    {
        "content": "<p>then why not just make a new branch off master and copy-paste the files in :-)</p>",
        "id": 262605450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637768980
    },
    {
        "content": "<p>that's what I usually do ;-)</p>",
        "id": 262605478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637768997
    },
    {
        "content": "<p>There's no need to use a new branch; just <code>git reset --hard origin/master</code> and paste the files in</p>",
        "id": 262605499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637769003
    },
    {
        "content": "<p>That way you can reuse the existing PR</p>",
        "id": 262605536,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637769007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/structures.2C.20subtypes.2C.20coercions.20and.20rw/near/262605194\">said</a>:</p>\n<blockquote>\n<p><code>git reset --hard THE_BAD_MERGE_COMMIT^</code> should get you back to where you were before the merge (and discard your local changes)</p>\n</blockquote>\n<p>I retract this comment, it looks like you added extra commits after you made the offending merge in <code>e5552fd2add5b8c1b157345c525484617b36d1a2</code>, so the cleanup is much harder.</p>",
        "id": 262605646,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637769079
    },
    {
        "content": "<p>All the commits that came afterwards were inoccuous.</p>",
        "id": 262605799,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1637769129
    },
    {
        "content": "<p>Then probably the quickest recovery is:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>git reset --hard d1ca2d4c03cff5087afa52545b2f35bfd7449a0b\n\n<span class=\"c1\"># paste back over your files and check if anything changed that you weren't expecting, and commit them</span>\n\ngit push --force\n</code></pre></div>",
        "id": 262605949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637769193
    },
    {
        "content": "<p>Perhaps <code>leanproject rebase</code> should have some heavy warnings, since using it without understanding a <code>git rebase</code> that well gets you in this trap.</p>",
        "id": 262606125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637769269
    }
]
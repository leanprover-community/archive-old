[
    {
        "content": "<p>Are there any good tips for dealing with ite cases? The following seems unnecessarily verbose.</p>\n<p>I'd greatly appreciate any advice. Thanks in advance for any suggestions.</p>\n<div class=\"codehilite\"><pre><span></span>example : ∀ a b c : ℕ, ite (a ≤ b) c (c + 1) ≤ (c + 2) :=\nbegin\n   intros a b c,\n   by_cases (a ≤ b),\n   simp [h], apply nat.le_add_right,\n   simp [h], apply nat.add_le_add_left,\n\n   -- Is there an easier way to show 1 ≤ 2?\n\n   apply nat.succ_le_succ, exact zero_le_one\nend\n</pre></div>",
        "id": 177678376,
        "sender_full_name": "Chu-Wee Lim",
        "timestamp": 1570590235
    },
    {
        "content": "<p>use the <code>split_ifs</code> tactic after the <code>intros</code></p>",
        "id": 177678787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1570590916
    },
    {
        "content": "<p>the <code>1 &lt;= 2</code> can be solved by <code>norm_num</code> or <code>exact dec_trivial</code></p>",
        "id": 177678838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1570590992
    },
    {
        "content": "<p>This is very useful - <code>split_ifs</code> seems to make handling the cases of if-then-else very convenient. However I'd still like to understand a bit more about how <code>simp</code> deals with if-then-else.</p>\n<p>Like Chu-Wee, I had hit upon the strategy of using <code>by_cases</code> on the branching condition, and then using <code>simp</code>. The following (a slight variation of Chu-Wee's code) is a MWE demonstrating the situation I was playing around with.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n        <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"err\">‹</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"err\">›</span><span class=\"o\">],},</span>\n        <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"err\">‹</span><span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"err\">›</span><span class=\"o\">],},</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>But then I read in the documentation for <code>simp</code> that it is bad practice to use it in the middle of a proof (OK, here it is at the end of each case's proof, but this is just a MWE, and in general I might need to do further proving). So I used the <code>set_option trace.simplify.rewrite true</code> option to display the lemmas that <code>simp</code> found and used, with the aim of replacing the use of <code>simp</code> with <code>rewrite</code> using these lemmas. Taking the first case (<code>a = b</code>), I got the following output.</p>\n<div class=\"codehilite\"><pre><span></span>0. [simplify.rewrite] [h]: a ==&gt; b\n0. [simplify.rewrite] [eq_self_iff_true]: b = b ==&gt; true\n0. [simplify.rewrite] [if_true]: ite true 0 0 ==&gt; 0\n0. [simplify.rewrite] [eq_self_iff_true]: 0 = 0 ==&gt; true\n</pre></div>\n\n\n<p>Things seem to start off well, but I quickly hit a snag:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">...</span>\n<span class=\"n\">by_cases</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"c1\">-- Current goal is ite (a = b) 0 0 = 0</span>\n        <span class=\"n\">rw</span> <span class=\"err\">‹</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"err\">›</span><span class=\"o\">,</span> <span class=\"c1\">-- Current goal is ite (b = b) 0 0 = 0</span>\n        <span class=\"n\">rw</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span>  <span class=\"c1\">-- rewrite tactic failed, motive is not type correct</span>\n</pre></div>\n\n\n<p>Using the <code>set_option trace.check true</code>, I got the following information about the failure.</p>\n<div class=\"codehilite\"><pre><span></span>[check] application type mismatch at\n  ite _a\nargument type\n  decidable (b = b)\nexpected type\n  decidable _a\n</pre></div>\n\n\n<p>The goal that I would expect to see after this last rewrite is <code>ite (true) 0 0 = 0</code>. So I understand that what is going wrong here is that <code>ite</code> is taking an implicitly inserted argument, which is a proof that the branching condition is decidable. For the goal <code>ite (b = b) 0 0 = 0</code> I'm guessing the proof that is implicitly synthesised is probably <code>decidable.is_true rfl : decidable (b = b)</code>. Now, after the rewrite <code>a = b ==&gt; true</code>, I imagine that the branching condition <code>(b = b)</code> in <code>ite (b = b) 0 0 = 0</code> is being transformed, but not the decidability proof, and the source of the above error is that this is a witness for <code>decidable (b = b)</code> but not for <code>decidable (true)</code>.</p>\n<p>So, I don't understand how <code>simp</code> is using the <code>eq_self_iff_true</code> lemma in a rewrite.</p>\n<p>I also noticed that it then uses the lemma <code>if_true</code>, and after digging around in the library I found that <code>if_true</code> actually uses the lemma:</p>\n<p><code>if_pos {c : Prop} [h : decidable c] (hc : c) {α : Sort u} {t e : α} : (ite c t e) = t</code></p>\n<p>I was able to use this directly in the following calculational proof of the case.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">calc</span>\n   <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">refl</span>\n     <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">if_pos</span> <span class=\"err\">‹</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"err\">›</span><span class=\"o\">,</span>\n</pre></div>\n\n\n<p>So, my question here is: what proof is <code>simp</code> finding in this situation?</p>",
        "id": 181263723,
        "sender_full_name": "Reuben Rowe",
        "timestamp": 1574294920
    },
    {
        "content": "<p>You can always use <code>#print</code> to see the proof term like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">aa</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"err\">‹</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"err\">›</span><span class=\"o\">],</span>\n  <span class=\"kn\">end</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">aa</span>\n</pre></div>\n\n\n<p>this is a bit ugly but we can see the names of some key lemmas like <code>if_simp_congr</code> which says two <code>ite</code>s are equal if their arguments are all equal and the props are equivalent. You can use this via</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n        <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"err\">‹</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"err\">›</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">if_simp_congr</span> <span class=\"o\">(</span><span class=\"n\">eq_self_iff_true</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">),</span>\n        <span class=\"n\">rw</span> <span class=\"n\">if_true</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n        <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"err\">‹</span><span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"err\">›</span><span class=\"o\">],},</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p><code>if_simp_congr</code> is a version of  <code>if_congr</code> with less decidability assumptions than <code>if_congr</code>.</p>",
        "id": 181264948,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1574296226
    },
    {
        "content": "<p>The <code>simp</code> rule is that you should only use it to close a goal, so both applications in <span class=\"user-mention\" data-user-id=\"244587\">@Reuben Rowe</span> 's example above are fine (by the way if you write <code> ```lean </code> at the top instead of just <code> ``` </code> when quoting code then you get syntax highlighting i.e. colours)</p>",
        "id": 181283438,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574323331
    },
    {
        "content": "<p>As for the motive not being type correct, <code>simp</code> is more powerful than <code>rw</code> here. You can use <code>simp only [eq_self_iff_true]</code> to get from <code>ite (b = b) 0 0 = 0</code> to <code>ite true 0 0 = 0</code> and <code>simp only</code> is Ok in the middle of a proof.</p>",
        "id": 181283739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574323692
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> and <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , this is really helpful.</p>",
        "id": 181293627,
        "sender_full_name": "Reuben Rowe",
        "timestamp": 1574333701
    },
    {
        "content": "<p>I see what is going on: <code>set_option trace.simplify.rewrite true</code> is only showing the lemmas with the <code>[simp]</code> attribute, even though the <code>simp</code> tactic uses other things, like <code>[congr]</code> lemmas.</p>",
        "id": 181293717,
        "sender_full_name": "Reuben Rowe",
        "timestamp": 1574333777
    }
]
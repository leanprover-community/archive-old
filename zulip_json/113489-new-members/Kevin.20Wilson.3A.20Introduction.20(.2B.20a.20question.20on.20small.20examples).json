[
    {
        "content": "<p>Hi there,</p>\n<p>My name is Kevin Wilson. Currently I run the data science group at The Policy Lab at Brown University and generally think about organizing and utilizing administrative data nowadays, but in a former life I got a Ph.D. in number theory. A friend of mine and I were discussing his work in theorem provers the other day, and he mentioned how much the lean and mathlib communities had grown, so I figured I'd check it out!</p>\n<p>First off, thank you for all the wonderful resources. Lean and mathlib installed exactly as advertised in the docs, and both the tutorial and the natural number game were excellent introductions.</p>\n<p>So I thought I'd try to prove something on my own from my own branch of math: The number of squarefree integers less than X is ~ X/zeta(2).  That seemed a good deal to bite off, so I figured I'd try an example:</p>\n<p>The set of squarefree integers at most 9 is {1, 2, 3, 5, 6, 7}.</p>\n<p>I quickly found myself lost in the thickets of the documentation of <code>finset</code> and so I wondered if I could prove the set of squarefree integers at most 1 has size 1. I got to here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set_squarefree_le_x</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">finset.filter</span> <span class=\"n\">squarefree</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sq_1_eq_1</span> <span class=\"o\">:</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">set_squarefree_le_x</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">set_squarefree_le_x</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.card_eq_succ</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">∅</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.eq_singleton_iff_unique_mem</span><span class=\"o\">,</span>\n  <span class=\"c1\">--- etc</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>At this point I got this in the interactive pane:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">?</span><span class=\"n\">m_3</span><span class=\"o\">}</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"mi\">2</span> <span class=\"n\">goals</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">finset.filter</span> <span class=\"n\">squarefree</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"bp\">⊢</span> <span class=\"bp\">∅.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I stared at this for a long while (and eventually came up with a much longer proof to get around this), but I realized I must be approaching this the wrong way.</p>\n<p>I was curious if there's some advice on approaching these sort of small, concrete examples, especially about subsets of the integers or subgroups of specific finite groups?</p>\n<p>Thanks in advance for any help here, and thank you for the great work on this library!</p>\n<p>Kevin</p>",
        "id": 269141116,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643045802
    },
    {
        "content": "<p>I would do this saying that <code>finset.filter squarefree (finset.range (N + 1))</code> is a subset of <code>finset.range (N + 1)</code>, so the cardinality is smaller.</p>",
        "id": 269142178,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643046286
    },
    {
        "content": "<p>The cardinality of <code>finset.range</code> is surely in mathlib, so you have that the cardinality is at most <code>2</code>.</p>",
        "id": 269142367,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643046367
    },
    {
        "content": "<p>Hey! Welcome. Small concrete calculations are usually the worst, so I'm not sure what to answer.</p>",
        "id": 269142391,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643046388
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.squarefree.decidable_pred\">docs#nat.squarefree.decidable_pred</a>, so in such a small case the calculation can actually be done automatically.</p>",
        "id": 269142518,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643046445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span> Welcome! There is something called <code>decidable_pred</code>. It basically means that there is an algorithm that you can run to find out the truth of a certain predicate/proposition. If you are lucky, someone has already shown that <code>squarefree</code> is a decidable predicate on the natural numbers. If so, your lemma should be provable in one line: <code>dec_trivial</code>.<br>\nBut this proof method will probably become unbearably slow for <code>N ≥ 10</code>. Maybe even earlier.</p>",
        "id": 269142532,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643046456
    },
    {
        "content": "<p>But I agree with Yael, the rest is annoying, you have to prove that <code>0</code> is not in the filter, so it is actually a subset of <code>erase</code> and blah blah</p>",
        "id": 269142670,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643046499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/269142532\">said</a>:</p>\n<blockquote>\n<p>But this proof method will probably become unbearably slow for <code>N ≥ 10</code>. Maybe even earlier.</p>\n</blockquote>\n<p>Erhm...</p>",
        "id": 269143181,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643046715
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"mi\">50000</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">squarefree</span>\n</code></pre></div>",
        "id": 269143210,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643046722
    },
    {
        "content": "<p><code>list.length</code> of that yields <code>30401</code>.</p>",
        "id": 269143393,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643046823
    },
    {
        "content": "<p>(Sorry, not used to Zulip so sent this  before I saw the later messages! Please give me a moment while I read them!)</p>\n<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I did think about that, but eventually you have to show that it's ≤ 1, so you'll eventually need to enumerate <code>finset.range (1 + 1)</code> and check each element. Hence I figured I'd just show in this case, it was equal to <code>{1}</code>. :-)</p>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Sadness. If there are examples, though, I'd be happy to take a look, even if they're the worst!</p>",
        "id": 269143398,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643046824
    },
    {
        "content": "<p>In that case, your pain also came from using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.range\">docs#finset.range</a> rather than <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.range\">docs#list.range</a>. Finsets are unordered, so they lack an easy induction treatment, as opposed to lists. For small calculations, lists are usually better.</p>",
        "id": 269143607,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643046900
    },
    {
        "content": "<p>If you're interested, here's a PR that does precisely this: small calculations in a smart way using lists. <a href=\"https://github.com/leanprover-community/mathlib/pull/10645\">#10645</a></p>",
        "id": 269143792,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643046970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Yeah I was confused by the <code>decideable_pred</code> because it was clearly already in the <code>algebra.squarefree</code> packages as <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> points out. It was unclear if I needed to hint that somehow to the rewriter and even how to do such things.</p>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> this makes sense. I was drawn to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.range\">docs#finset.range</a> because, well, it seemed like what I was going for. I'll take a look at this small Roth number computation and see if I can make this work! Thanks!</p>",
        "id": 269144131,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643047136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> This doesn't work, do you know why?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sq_1_eq_1</span> <span class=\"o\">:</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">set_squarefree_le_x</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">delta</span> <span class=\"n\">set_squarefree_le_x</span><span class=\"o\">,</span>\n  <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 269144174,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643047159
    },
    {
        "content": "<p>Because it's a <code>finset</code>, Johan. Replace that with a <code>list</code> and it will work out.</p>",
        "id": 269144226,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643047188
    },
    {
        "content": "<p>Why the heck is that a problem? Lean should be able to compute with <code>finset.range 2</code>.</p>",
        "id": 269144353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643047219
    },
    {
        "content": "<p>Hmm, maybe I said bullshit. This doesn't work either</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">list.range</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">squarefree</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 269144507,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643047267
    },
    {
        "content": "<p>Is it that <code>#eval</code> can do stuff that <code>rfl</code> or <code>dec_trivial</code> can't?</p>",
        "id": 269144606,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643047308
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span> ! I'm also at Brown, new this year to the CS department, and taught a <a href=\"https://cs.brown.edu/courses/cs1951x/\">course using Lean</a> this fall. Nice to see someone else nearby getting into it!</p>",
        "id": 269144630,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1643047320
    },
    {
        "content": "<p>But it's a problem with <code>squarefree</code>, because <code>example : ((list.range 2).filter ⊤).length = 2 := rfl</code> works</p>",
        "id": 269145019,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643047445
    },
    {
        "content": "<p>Ahah! Is it some reducibility setting maybe?</p>",
        "id": 269145233,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643047549
    },
    {
        "content": "<p>Nice to meet you, <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> ! I'll definitely take a look at this course. I might bug you for a coffee at some point as well!</p>",
        "id": 269145472,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643047639
    },
    {
        "content": "<p>how do you trace dec_trivial calls? this is something I've wanted to know for a while and never found an answer sadly</p>",
        "id": 269147908,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643048706
    },
    {
        "content": "<p>something is very weird in that example...</p>",
        "id": 269147938,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643048719
    },
    {
        "content": "<p>Finsets have an induction on them, what do you mean Yael that they don't have an easy one?</p>",
        "id": 269154533,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643051250
    },
    {
        "content": "<p>I think I got confused by the error.</p>",
        "id": 269154572,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643051270
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span>, nice to see you here!</p>",
        "id": 269169057,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1643056561
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> ! Long time no see!!</p>",
        "id": 269181893,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643063356
    },
    {
        "content": "<p>Indeed!  Well, if we get you addicted here, it may be short time much see!</p>",
        "id": 269182088,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1643063463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/269145233\">said</a>:</p>\n<blockquote>\n<p>Ahah! Is it some reducibility setting maybe?</p>\n</blockquote>\n<p>This is a sort of error I asked about a couple weeks ago, and Mario was saying it's something to do with which axioms appear in the definition, and some of them make it get \"stuck.\"</p>\n<p>Some examples to show some behavior (but not explaining what's wrong with <code>squarefree</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">squarefree</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">squarefree</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">squarefree</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_true</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat.squarefree_iff_nodup_factors</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">norm_num</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 269184200,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643064679
    },
    {
        "content": "<p>I suspect the problem is that <code>n.factors.nodup</code> gets stuck on <code>n.factors</code>, which involves division, so well-founded recursion. (But I don't really know.)</p>",
        "id": 269184267,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643064720
    },
    {
        "content": "<p>New guess: it's that <code>factors</code> itself depends on well-founded recursion. Those don't seem to work with <code>dec_trivial</code>...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">factors</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">min_fac</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"k\">have</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">factors_lemma</span><span class=\"o\">,</span>\n  <span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">factors</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 269184453,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643064831
    },
    {
        "content": "<p>It looks like it's possible to get it to work with an auxiliary algorithm for <code>squarefree</code>. I wrote a terrible one that does trial division with a naive upper bound:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">squarefree'_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">t'</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">t'</span><span class=\"bp\">*</span><span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">ff</span> <span class=\"k\">else</span> <span class=\"n\">squarefree'_aux</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">squarefree'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">squarefree'_aux</span> <span class=\"n\">n</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">squarefree_iff_squarefree'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">squarefree</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">squarefree'</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">squarefree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"k\">if</span> <span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">squarefree'</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">_</span> <span class=\"k\">else</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_true</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">squarefree_iff_squarefree'</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_false</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">squarefree_iff_squarefree'</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">squarefree</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"mi\">37</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 269185529,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643065460
    },
    {
        "content": "<p>Can't you use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/decidable_of_iff'\">docs#decidable_of_iff'</a> to shorten <code>foo</code>?</p>",
        "id": 269185909,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643065715
    },
    {
        "content": "<p>I thought when I'd tried that the examples got stuck, but I guess that works too. (I wrote it in a way where I could be sure it definitely wouldn't get stuck, since this isn't so fun to debug <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>). <em>Replaced in code block</em></p>",
        "id": 269186504,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643066107
    },
    {
        "content": "<p>I think <code>decidable_of_iff</code> and <code>decidable_of_iff'</code> were explicitly designed not to get stuck.</p>",
        "id": 269186833,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643066310
    },
    {
        "content": "<p>I wonder how you can write <code>factors</code> to be similarly efficient but still not get stuck. Maybe you can have an auxiliary function that you give \"gas\" (i.e., the number of recursive steps it will ever apply), and you can estimate how much gas you'll ever need? For example, <code>factors</code> won't ever give more factors than <code>n</code>, so that can serve as the gas to power the recursion. (And of course <code>nat.min_fac</code> uses well-founded recursion, too...)</p>",
        "id": 269187875,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643067107
    },
    {
        "content": "<p>I'd be curious if there is, because by attempts at proving this squarefree number asymptotic seems to keep getting stymied at <code>dec_trivial</code>s that seemingly get stuck on things like <code>squarefree</code> and <code>factors</code> and <code>divisors</code>.</p>",
        "id": 269302713,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643135852
    },
    {
        "content": "<p>If you are trying to prove an asymptotic dec_trivial likely won't be too helpful anyway, its just a way of forcing lean to evaluate closed expressions. So its useful to do small calculations when a problem is inherently finite, but will not be able to really prove much more than that. Where are you stuck exactly?</p>",
        "id": 269303744,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643136226
    },
    {
        "content": "<p>There's a lot of induction lying around in proving some rearrangement equals some other rearrangement. So the base cases end up looking like needing to prove <code>f 1 = 1</code>. I can type <code>#eval f 1</code> and it shows me <code>1</code>. Writing it out by hand is, well, quite nightmarish!</p>",
        "id": 269304951,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643136745
    },
    {
        "content": "<p>Also I must tell you that you probably didn't pick the easiest problem to start with!</p>",
        "id": 269305310,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643136887
    },
    {
        "content": "<p>Gotta challenge yourself! :-)</p>",
        "id": 269305341,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643136898
    },
    {
        "content": "<p>(we don't even have the Zeta function)</p>",
        "id": 269305381,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643136910
    },
    {
        "content": "<p>But I'm definitely realizing that!</p>",
        "id": 269305387,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643136912
    },
    {
        "content": "<p>Conveniently, the standard proof doesn't directly use the zeta function. But it does involve proving things like $\\sum_{d^2 \\mid n} \\mu(d) = 1$ if and only if $n$ is squarefree.</p>",
        "id": 269305576,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643136981
    },
    {
        "content": "<p>And that proof essentially goes: a) prove that function is multiplicative; b) prove it for prime powers. I saw there were <code>arithmetic_functions</code>, <code>moebius</code>, and even the notion of a multiplicative arithmetic function, so I figured at least the foundation is there!</p>",
        "id": 269305864,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643137096
    },
    {
        "content": "<p>Ok <code>dec_trivial</code> could be helpful but maybe another good way when the definitions are a bit more complicated is to coax <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_num\">tactic#norm_num</a> into unfolding the right things and evaluating them (normally this involves passing it extra function names / lemmas, like for simp, so that it rewrites the right things until it gets to a point it can actually do the calculation)</p>",
        "id": 269306309,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643137249
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span> Did you finish the proof in your first post? I took a stab at it and got through mostly with <code>simp</code>, <code>ext</code>, <code>norm_num</code>, and <code>interval_cases</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set_squarefree_le_x</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">finset.filter</span> <span class=\"n\">squarefree</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sq_1_eq_1</span> <span class=\"o\">:</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">set_squarefree_le_x</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">set_squarefree_le_x</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.card_eq_succ</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">∅</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hsf</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">interval_cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hsf</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 269306482,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643137315
    },
    {
        "content": "<p>With a somewhat cleaned-up proof (I <code>squeeze_simp</code>ed to fix non-terminal <code>simp</code>s, and I added braces for goals):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sq_1_eq_1</span> <span class=\"o\">:</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">set_squarefree_le_x</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">set_squarefree_le_x</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.card_eq_succ</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">finset.not_mem_empty</span><span class=\"o\">,</span> <span class=\"n\">insert_emptyc_eq</span><span class=\"o\">,</span> <span class=\"n\">finset.card_empty</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">,</span>\n    <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_filter</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_range</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hsf</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">interval_cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hsf</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 269306963,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643137478
    },
    {
        "content": "<p>(Aside <span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span>: on zulip you can write latex/math using double dollars: <code>$$a^2 + b^2 \\in \\mathbb R$$</code> yields <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><mo>∈</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">a^2 + b^2 \\in \\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8532em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>.)</p>",
        "id": 269307134,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643137557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/269306309\">said</a>:</p>\n<blockquote>\n<p>Ok <code>dec_trivial</code> could be helpful but maybe another good way when the definitions are a bit more complicated is to coax <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_num\">tactic#norm_num</a> into unfolding the right things and evaluating them (normally this involves passing it extra function names / lemmas, like for simp, so that it rewrites the right things until it gets to a point it can actually do the calculation)</p>\n</blockquote>\n<p>I guess <code>norm_num</code> doesn't know what to do with <code>square_free</code> as of today, right?</p>",
        "id": 269307311,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643137635
    },
    {
        "content": "<p>That is correct :-)</p>",
        "id": 269307329,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643137646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  I did finish a proof, but it was quite a bit longer. I hadn't come across the <code>ext</code> tactic, which does make this a lot easier! I ended up with several auxiliary lemmas whose purpose was essentially to get me <code>ext</code></p>",
        "id": 269307444,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643137695
    },
    {
        "content": "<p>Here's a slightly different version, but still annoyingly long to be honest</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sq_1_eq_1</span> <span class=\"o\">:</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">set_squarefree_le_x</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">set_squarefree_le_x</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">finset.filter</span> <span class=\"n\">squarefree</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hh</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">interval_cases</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"c1\">-- reorders goals?</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hh</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">},</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset.card_singleton</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 269309829,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643138728
    },
    {
        "content": "<p>And for a bit of fun I wrote a different decidable instance for squarefree, its also trial division I suppose, I just approach the setup a bit differently</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">nat.decidable_is_unit</span> <span class=\"o\">:</span> <span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_unit</span> <span class=\"n\">ℕ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">decidable_of_iff</span> <span class=\"n\">_</span> <span class=\"n\">nat.is_unit_iff.symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">nat_sq</span> <span class=\"o\">:</span> <span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">squarefree</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">not_squarefree_zero</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">decidable.false</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">is_unit</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">squarefree</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">forall_congr</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">intros</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hx</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat.le_of_dvd</span> <span class=\"o\">(</span><span class=\"n\">zero_lt_iff.mpr</span> <span class=\"n\">hz</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">by_contra</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">not_le</span><span class=\"o\">,</span> <span class=\"n\">nat.lt_one_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">mul_le_mul'</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h'.trans</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">decidable_of_iff</span> <span class=\"n\">_</span> <span class=\"n\">this.symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"mi\">130</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 269340737,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643153088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/269307311\">said</a>:</p>\n<blockquote>\n<p>I guess <code>norm_num</code> doesn't know what to do with <code>square_free</code> as of today, right?</p>\n</blockquote>\n<p>Already on the case</p>",
        "id": 269342952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643154534
    },
    {
        "content": "<p>This is very cool! Thank you for the intro to all the internals as well!</p>",
        "id": 269355486,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1643164678
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11666\">#11666</a></p>",
        "id": 269356889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643166309
    },
    {
        "content": "<p>And here's an application to use <code>norm_num</code> to sum up all the squarefrees up to a bound:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">list.range</span> <span class=\"mi\">50</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">squarefree</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">count</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"mi\">31</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">norm_num</span> <span class=\"o\">[</span><span class=\"n\">list.range</span><span class=\"o\">,</span> <span class=\"n\">list.range_core</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I had to write it in a slightly funny way because this is just relying on <code>simp</code> to simplify the list stuff, there isn't any custom evaluation code for it. It also doesn't seem be be able to handle very large numbers; there are much better algorithms for calculating the sum of squarefrees up to a bound than just expanding out the list and simplifying.</p>",
        "id": 269357488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643167082
    },
    {
        "content": "<p>The actual underlying algorithm seems to be able to handle pretty large numbers so I guess it is the surrounding simp stuff that is expensive</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"mi\">99302206</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 269357619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643167216
    },
    {
        "content": "<p>So I finished my goal: the \"usual\" proof on the asymptotics of squarefree numbers. <a href=\"https://github.com/khwilson/squarefree_asymptotics\">https://github.com/khwilson/squarefree_asymptotics</a></p>\n<p>It turned out to be quite long, but I'd love to record my experiences somewhere at least as a tutorial for others. And I'd love any comments on how this could have been done better. Indeed, I think my biggest conundrum was that it was hard to find good examples of \"how to approach an integral problem\" or \"how to prove that two functions differ on a set of measure 0.\"</p>\n<p>Thanks again for all the early help!</p>",
        "id": 275156281,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647180561
    },
    {
        "content": "<p>Wow, that's amazing!</p>",
        "id": 275156713,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647181129
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 275156715,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647181133
    },
    {
        "content": "<p>(we were originally a bit sorry for you that you had chosen such a hard item)</p>",
        "id": 275156734,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647181167
    },
    {
        "content": "<p>Never underestimate the power of \"doing things while watching Downton Abbey [or your preferred mindless television show]\" :-)</p>",
        "id": 275157228,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647181800
    },
    {
        "content": "<p>Congratulations!! A good way to get feedback is to try to PR what you proved.</p>\n<p>You can start with some preliminary lemmas (try to open several short PRs rather than a big one).</p>",
        "id": 275157311,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647181894
    },
    {
        "content": "<p>I was having a look at the readme on your page, and I see there that you are asking if there is a good way of formalising the notion of \"for sufficiently large parameters, ...\". The answer is that we are already using this a lot, and this is called filters. You can grep the library for <code>∀ᶠ.*in at_top</code> to see how it is used.</p>",
        "id": 275161190,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1647186893
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> great idea! Do you have a recommendation for a PR that was good in your opinion? Especially for PRs that depend on each other? (Always a problem in software!) </p>\n<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>  Yeah with the filters, I spent a lot of time in the code and in the docs trying to find good examples and I couldn’t quite figure out how to put it altogether, at least in an elegant way. Hence the notes at the bottom that I couldn’t quite grok them or how to prove that two sets differ on a set of measure 0 😅</p>\n<p>If you have a favorite example, I’d love a pointer!</p>\n<p>Thanks again!</p>",
        "id": 275173319,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647203272
    },
    {
        "content": "<p>You can just open one or two PR with the basic material (mentioning what the final goal is), and once they are accepted you can remove the result from your repository. There is no need to PR everything at the same time, especially if this means a lot of dependent PR.</p>",
        "id": 275205111,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647246395
    },
    {
        "content": "<p>I briefly looked at <code>general.lean</code> to see if there were a lemma or two that could be a small PR, but I got sidetracked with <code>one_le_of_ne_zero</code>, since it seemed like it just had to be in mathlib already in some form. If you do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">one_le_of_ne_zero</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">library_search</span>\n</code></pre></div>\n<p>it gives <code>nat.one_le_iff_ne_zero</code>.  Similarly, the lemma <code>two_le_prime</code> is <code>nat.prime.two_le</code>. I couldn't find <code>prime_squarefree</code> immediately by the same tactic, but searching for \"prime squarefree\" in the online docs turned up <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prime.squarefree\">docs#prime.squarefree</a></p>\n<p>These seem to be new:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sqrt_one_eq_one</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">sqrt</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">eq_sqrt</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">linarith</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">one_le_sqrt</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">sqrt</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sqrt_one_eq_one</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">sqrt_le_sqrt</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 275206486,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647247317
    },
    {
        "content": "<p>Btw, <code>lemma sqrt_one_eq_one</code> is probably more mathlib-like formulated with the equality in the opposite way: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sqrt_one_eq_one</span> <span class=\"o\">:</span> <span class=\"n\">sqrt</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>The guiding principle being that the RHS should be \"<code>simp</code>ler\" than the LHS.</p>",
        "id": 275206949,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647247659
    },
    {
        "content": "<p>Also, <code>convert nat.sqrt_eq 1</code> might simplify the proof, leaving only a <code>mul_one</code> (untested).<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.sqrt_eq\">docs#nat.sqrt_eq</a></p>",
        "id": 275207357,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647247932
    },
    {
        "content": "<p>I swear <code>sqrt 1 = 1</code> has to be <code>rfl</code> (if we're talking about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.sqrt\">docs#nat.sqrt</a>)</p>",
        "id": 275207837,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647248285
    },
    {
        "content": "<p>well you would be wrong</p>",
        "id": 275208810,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647248882
    },
    {
        "content": "<p>Thank you for the comments. I'll take a stab at migrating some of those!</p>\n<p>One thing that was confusing to me throughout was when the naming convention called for \"object notation\" (e.g., <code>prime.two_le</code>) versus [not sure what it should be called but the opposite] notation, (e.g., <code>two_le_prime</code>). Never quite figured out the patter!</p>",
        "id": 275230073,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647261974
    },
    {
        "content": "<p>You can look on zulip for \"<del>not</del> dot notation\", there are quite a lot of threads, but the idea is that we like it and we try to use it.</p>\n<p>Take for example <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.monic.pow\">docs#polynomial.monic.pow</a>: it says that the power of a monic polynomial is monic, so it has as an assumption <code>hp : p.monic</code>. The idea of dot notation is that we can use it writing <code>hp.pow n</code> instead of <code>monic.pow hp n</code>.</p>",
        "id": 275230586,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647262273
    },
    {
        "content": "<p>But at beginning don't worry too much about this, it will be part of the review process</p>",
        "id": 275230704,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647262325
    },
    {
        "content": "<blockquote>\n<p>\"not notation\"</p>\n</blockquote>\n<p>dot notation :-)</p>",
        "id": 275230933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647262445
    },
    {
        "content": "<p>Made <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> 's changes (love small change requests that reduce code!) <a href=\"https://github.com/khwilson/squarefree_asymptotics/pull/1\">https://github.com/khwilson/squarefree_asymptotics/pull/1</a></p>",
        "id": 275231247,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647262600
    },
    {
        "content": "<p>Also, I think I found <code>prime.squarfree</code> but everything fails to unify if you use that. I think because N isn't a monoid according to Lean? (I hit this sort of thing several times.)</p>",
        "id": 275232032,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647262960
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prime_squarfree</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">prime.squarefree</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 275232043,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647262975
    },
    {
        "content": "<p>Leads to</p>",
        "id": 275232063,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647262989
    },
    {
        "content": "<p>Surely N is a monoid?</p>",
        "id": 275232065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647262989
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">prime.squarefree</span> <span class=\"n\">hp</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">hp</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">prime</span> <span class=\"n\">p</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">prime</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">cancel_comm_monoid_with_zero.to_comm_monoid_with_zero</span> <span class=\"n\">ℕ</span> <span class=\"n\">nat.cancel_comm_monoid_with_zero</span><span class=\"o\">)</span> <span class=\"n\">p</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">prime</span> <span class=\"n\">p</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">squarefree</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 275232080,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647262996
    },
    {
        "content": "<p>The issue there I suspect is that there is more than one notion of prime in play.</p>",
        "id": 275232122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263025
    },
    {
        "content": "<p>We have a bit of description of how nice dot notation can be at the end of the section <a href=\"https://leanprover-community.github.io/tips_and_tricks.html#avoiding-many-nested-parentheses-with-\">https://leanprover-community.github.io/tips_and_tricks.html#avoiding-many-nested-parentheses-with-</a> of the tips and tricks page</p>",
        "id": 275232186,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1647263050
    },
    {
        "content": "<p>Also, I definitely agree the dot notation is nice! I just couldn't quite grok when to use dot notation instead of the <code>_of_</code> notation (and especially when to search with the dot notation instead of the <code>_of_</code> notation :-) )</p>",
        "id": 275232264,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263107
    },
    {
        "content": "<p>Yes, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.prime\">docs#nat.prime</a> is not the same as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prime\">docs#prime</a></p>",
        "id": 275232316,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647263136
    },
    {
        "content": "<p>But we surely know somewhere that they are equivalent</p>",
        "id": 275232339,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647263150
    },
    {
        "content": "<p>Can you post fully working code? I can't reproduce your error. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prime_squarfree</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">prime.squarefree</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>gives the problem I'm flagging -- <code>nat.prime</code> isn't the same as <code>prime</code> (but my error is much more sensible than yours)</p>",
        "id": 275232340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263150
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> yes, you're correct. Reading that error it definitely seems that N is a monoid! But perhaps there's some Lean magic to get it to work</p>",
        "id": 275232403,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263169
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.prime_iff\">docs#nat.prime_iff</a></p>",
        "id": 275232408,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647263174
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.squarefree</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prime_squarfree</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">prime.squarefree</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 275232526,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> ^^^</p>",
        "id": 275232546,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263252
    },
    {
        "content": "<p>Oh you have <code>open nat</code>, yeah that makes the same error look a lot more exotic :-)</p>",
        "id": 275232566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263261
    },
    {
        "content": "<p>Hah still not exactly sure what counts as \"minimum\" and how to debug :-)</p>",
        "id": 275232664,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263292
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prime_squarfree</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">squarefree</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat.prime_iff</span> <span class=\"n\">at</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">prime.squarefree</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>as Riccardo said. There are two primes here, and with <code>open nat</code> they're both called <code>prime</code>.</p>",
        "id": 275232696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263304
    },
    {
        "content": "<p>Ah well that would explain that. I'm guessing <code>nat.prime</code> has special features that <code>prime</code> doesn't have?</p>",
        "id": 275232785,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263354
    },
    {
        "content": "<p>By the way I would recommend you avoid <code>open_locale classical</code>, it was a \"hammer\" approach to decidability problems popular a few years ago; we now have far more precise tools to deal with these issues.</p>",
        "id": 275232798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263358
    },
    {
        "content": "<p><code>nat.prime</code> and <code>prime</code> are simply two different things.</p>",
        "id": 275232823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263375
    },
    {
        "content": "<p>Oh I just meant that why don't you just <em>define</em> <code>nat.prime</code> via <code>nat.prime_iff</code> ?</p>",
        "id": 275232930,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263418
    },
    {
        "content": "<p><code>nat.prime</code> is about naturals, <code>prime</code> is a far more general algebraic concept which works for commutative rings and has a different definition. This is why you need <code>nat.prime_iff</code> to glue the two concepts together.</p>",
        "id": 275232935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263420
    },
    {
        "content": "<p>It's not for me to say why definitions are as they are. Perhaps historical? <code>nat.prime</code> was defined by the computer scientists before we mathematicians came along telling them that there was a far more general concept of primality?</p>",
        "id": 275233012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263476
    },
    {
        "content": "<p>Hah! \"Path dependence\" is almost always the answer</p>",
        "id": 275233048,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263499
    },
    {
        "content": "<p>Yeah, it might also be that :-)</p>",
        "id": 275233065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263513
    },
    {
        "content": "<p>yeah, that's what happened</p>",
        "id": 275233141,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647263532
    },
    {
        "content": "<p>We changed the definition recently, didn't we? Using <code>irreducible</code>.</p>",
        "id": 275233152,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647263538
    },
    {
        "content": "<p>But I may be wrong</p>",
        "id": 275233175,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647263548
    },
    {
        "content": "<p>Indeed it seems that <code>nat.prime</code> was refactored 3 months ago in <a href=\"https://github.com/leanprover-community/mathlib/pull/11031\">#11031</a></p>",
        "id": 275233225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263578
    },
    {
        "content": "<p>Yeah, but it takes &gt; 500 lines to prove that irreducible implies prime for nat</p>",
        "id": 275233233,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647263581
    },
    {
        "content": "<p>...by Ruben :-)</p>",
        "id": 275233258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647263594
    },
    {
        "content": "<p>We could probably turn it around, but that was more work than I wanted to take on at that point</p>",
        "id": 275233291,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647263612
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/81a31ca4a8c0287bf0b0ce40f1a0df16543b7abe/src/data/nat/prime.lean\">https://github.com/leanprover-community/mathlib/blob/81a31ca4a8c0287bf0b0ce40f1a0df16543b7abe/src/data/nat/prime.lean</a> this is the old version, which also isn't <code>prime</code></p>",
        "id": 275233310,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647263623
    },
    {
        "content": "<p>there's like a zillion things in the library that are specialised for nat just so we can get the rest of the theory going, which is annoying but I guess how it has to be</p>",
        "id": 275233426,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647263660
    },
    {
        "content": "<p>Gotta start somewhere :-)</p>",
        "id": 275233803,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647263853
    },
    {
        "content": "<p>It would be \"neat\" (and very probably terrible) if there was some sort of shim overtop \"CS nat\" that obviated this for folks like me, but I guess if mathlib is C in this analogy,  this would be asking for Python [or your even higher level language of choice]</p>",
        "id": 275234099,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647264012
    },
    {
        "content": "<p>Anyway, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> removed the <code>open_locale classical</code>'s. They showed up early due to an auxiliary function.</p>",
        "id": 275236368,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647265176
    },
    {
        "content": "<p><a href=\"https://github.com/khwilson/squarefree_asymptotics/pull/2\">https://github.com/khwilson/squarefree_asymptotics/pull/2</a></p>",
        "id": 275236371,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647265179
    },
    {
        "content": "<p>Before disappearing to the day job, the contributing notice for mathlib notes that I'm supposed to \"ask for write access to non-master branches of the mathlib repository.\" Where do I ask this question? (If it is here, I'm <code>khwilson</code> on github. :-) )</p>",
        "id": 275236688,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647265347
    },
    {
        "content": "<p>Let me see if I am able to do it with my phone</p>",
        "id": 275237530,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647265733
    },
    {
        "content": "<p>You should have an invitation</p>",
        "id": 275237805,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647265868
    },
    {
        "content": "<p>Invitation received! Thank you!</p>",
        "id": 275238036,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647265963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"474023\">Kevin Wilson</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/275236368\">said</a>:</p>\n<blockquote>\n<p>Anyway, <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> removed the <code>open_locale classical</code>'s. They showed up early due to an auxiliary function.</p>\n</blockquote>\n<p>If you need classical assumptions (e.g. decidability) in the statement of a theorem or definition, put them in explicltly; if you just need them in a proof, use the <code>classical</code> tactic beforehand. That's the (simplified version of the) modern mantra.</p>",
        "id": 275238125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647266010
    },
    {
        "content": "<p>Makes a lot of sense. As you can see from the start of this thread, decidability was a lot to grok early on! (\"Why is this red squiggly appearing just because I wrote <code>ite</code> ?!?! )</p>",
        "id": 275238413,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647266140
    },
    {
        "content": "<p>It seems like redefining <a href=\"http://nat.prime\">nat.prime</a> := prime might be workable after all - I'll see if I have time to work it out thus week</p>",
        "id": 275242906,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647267955
    },
    {
        "content": "<p>I'd argue that <code>nat.prime</code> and <code>prime</code> are different definitions in mathematics too, as reflected in almost any number theory book (e.g., Apostol). That is, if you say \"the definition of <code>nat.prime</code> is is really the definition for <code>irreducible</code> in a more general context\", I think this will ring a bell for most mathematicians.</p>",
        "id": 275244365,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1647268630
    },
    {
        "content": "<p>It's unfortunate that what we call a prime number in primary school is actually an irreducible element in N. But that's life I guess</p>",
        "id": 275245901,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1647269294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/275244365\">said</a>:</p>\n<blockquote>\n<p>I'd argue that <code>nat.prime</code> and <code>prime</code> are different definitions in mathematics too, as reflected in almost any number theory book (e.g., Apostol). That is, if you say \"the definition of <code>nat.prime</code> is is really the definition for <code>irreducible</code> in a more general context\", I think this will ring a bell for most mathematicians.</p>\n</blockquote>\n<p>sure, but they're equivalent, and considering we have <code>prime.irreducible</code> things work out pretty nicely in the general case</p>",
        "id": 275246579,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647269569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/275232935\">said</a>:</p>\n<blockquote>\n<p><code>nat.prime</code> is about naturals, <code>prime</code> is a far more general algebraic concept which works for commutative rings and has a different definition. This is why you need <code>nat.prime_iff</code> to glue the two concepts together.</p>\n<p>It's not for me to say why definitions are as they are. Perhaps historical? <code>nat.prime</code> was defined by the computer scientists before we mathematicians came along telling them that there was a far more general concept of primality?</p>\n</blockquote>\n<p>I very much doubt \"computer science\" motivations are at play here. Most likely this is something like <span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> wanting simple proofs about primality like <code>exists_infinite_primes</code> to actually be comprehensible as an introductory example to first-year students. This tends not to last long before being refactored away in current mathlib, though.</p>",
        "id": 275286826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647286183
    },
    {
        "content": "<p>OK, I have started migrating various lemmas over to mathlib with some success (two PRs in!). But in the process I figured I'd try to generalize and simplify various things. Then I hit a weird issue I'm not sure how to debug. Specifically, I need the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.instances.real</span>\n<span class=\"kn\">import</span> <span class=\"n\">order</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">real_tendsto_implies_nat_tendsto</span>\n<span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">filter.tendsto</span> <span class=\"n\">f</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n<span class=\"n\">filter.tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">filter.at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">filter.tendsto_at_top'</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">filter.tendsto_at_top'</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hf</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hf</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">⌈</span><span class=\"n\">a</span><span class=\"bp\">⌉₊</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">ha</span> <span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">⌈</span><span class=\"n\">a</span><span class=\"bp\">⌉₊</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"k\">calc</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"bp\">↑⌈</span><span class=\"n\">a</span><span class=\"bp\">⌉₊</span> <span class=\"o\">:</span> <span class=\"n\">nat.le_ceil</span> <span class=\"n\">a</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"bp\">↑</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat.cast_le.mpr</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ha</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Of course, this should be true for basically anything where all the elements are defined, so I attempted to do the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.instances.real</span>\n<span class=\"kn\">import</span> <span class=\"n\">order</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">real_tendsto_implies_nat_tendsto'</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semilattice_sup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_closed_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">filter.at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">filter.tendsto_at_top'</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Fails</span>\n  <span class=\"n\">rw</span> <span class=\"n\">filter.tendsto_at_top'</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This seemed odd, so I did some experimentation and it seems to be failing with a bit of a strange (to me!) error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.instances.real</span>\n<span class=\"kn\">import</span> <span class=\"n\">order</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">real_tendsto_implies_nat_tendsto''</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">aa</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">bb</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">order_closed_topology</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">filter.at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">filter.tendsto_at_top'</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Fails with detailed error</span>\n  <span class=\"c1\">-- type mismatch at application</span>\n  <span class=\"c1\">--   tendsto_at_top'.mp hf</span>\n  <span class=\"c1\">-- term</span>\n  <span class=\"c1\">--   hf</span>\n  <span class=\"c1\">-- has type</span>\n  <span class=\"c1\">--   @tendsto α β f</span>\n  <span class=\"c1\">--     (@at_top α</span>\n  <span class=\"c1\">--       (@partial_order.to_preorder α</span>\n  <span class=\"c1\">--           (@ordered_cancel_add_comm_monoid.to_partial_order α</span>\n  <span class=\"c1\">--             (@ordered_semiring.to_ordered_cancel_add_comm_monoid α</span>\n  <span class=\"c1\">--                 (@linear_ordered_semiring.to_ordered_semiring α _inst_1)))))</span>\n  <span class=\"c1\">--     (𝓝 a)</span>\n  <span class=\"c1\">-- but is expected to have type</span>\n  <span class=\"c1\">--   @tendsto α β f (@at_top α (@partial_order.to_preorder α (@semilattice_sup.to_partial_order α bb))) (𝓝 a)</span>\n  <span class=\"k\">let</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">filter.tendsto_at_top'</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">aa</span> <span class=\"n\">bb</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Which I interpret as an issue that the preorder can arise either from the explicit <code>semilattice_sup</code> or the implicit <code>linear_order</code>coming from a <code>linear_ordered_ring</code>. This works fine for <code>α = ℝ</code> because <code>ℝ</code>'s <code>semilattice_sup</code> structure explicitly comes from its <code>linear_order</code> structure <a href=\"https://leanprover-community.github.io/mathlib_docs/data/real/basic.html#real.semilattice_sup\">https://leanprover-community.github.io/mathlib_docs/data/real/basic.html#real.semilattice_sup</a></p>\n<p>So my question is: what's the right way to specify, \"I mean things where the <code>semilattice_sup</code> structure comes from the <code>linear_order</code> structure?\"</p>\n<p>Thanks again!</p>",
        "id": 275467452,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647406467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span> To jump immediately to your original motivation:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">real_tendsto_implies_nat_tendsto</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">filter.tendsto</span> <span class=\"n\">f</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">filter.tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">filter.at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">hf.comp</span> <span class=\"n\">tendsto_coe_nat_at_top_at_top</span>\n</code></pre></div>\n</div></div>",
        "id": 275469498,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647409274
    },
    {
        "content": "<p>And to answer the question you asked:  <code>linear_order</code> implies <code>semilattice_sup</code>, so you can assume just the former and the latter will be silently inferred where needed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 275469853,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647409720
    },
    {
        "content": "<p><code>example</code> is the keyword! Very cool :-)</p>\n<p>As for the spoiler proof, that's amazing. Half the battle is searching for the right lemma :-)</p>\n<p>Though, notably, the lemma I wrote supposes a <code>linear_ordered_semiring</code>, whereas <code>archimedean</code> (an assumption of <code>tendsto_coe_nat_at_top_at_top</code>) implies <code>floor_ring</code>(<a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/order/archimedean.html#archimedean.floor_ring\">https://leanprover-community.github.io/mathlib_docs/algebra/order/archimedean.html#archimedean.floor_ring</a>).</p>",
        "id": 275512820,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647438751
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span> I think it's the other way, right?  <code>floor_ring</code> implies <code>archimedean</code>.  And the lemma <code>tendsto_coe_nat_at_top_at_top</code> is stated for <code>archimedean</code>, the weaker one, so it applies for (eg) the nonnegative reals, too.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.archimedean</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">nnreal</span>\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">at_top</span> <span class=\"n\">at_top</span> <span class=\"o\">:=</span> <span class=\"n\">tendsto_coe_nat_at_top_at_top</span>\n</code></pre></div>",
        "id": 275539396,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647448558
    },
    {
        "content": "<p>No, Heather. <code>archimedean</code> also noncomputably imply <code>floor_ring</code>.</p>",
        "id": 275540562,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647448970
    },
    {
        "content": "<p>I suspect that you can make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[X]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> into a linear ordered ring by demanding that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">0&lt;|X|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span></span></span></span> but that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">|X|&lt;\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span> for all positive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span>, and then following your nose (I didn't check this but I think I've checked it in the past). This might well be a <code>floor_ring</code> which is not archimedean -- something for the <code>counterexamples</code> folder? (there might be simpler examples)</p>",
        "id": 275542072,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647449544
    },
    {
        "content": "<p>Ridiculously, the reason I was thinking about this a few years ago was working with <span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> on decimal expansions! He started off wanting to define them for the reals, but I pointed out that it should work for the rationals, and then we started wondering exactly which rings decimal expansions should work for, and we thought that <code>floor_ring</code>s were an excellent choice! And then realised that perhaps the decimal expansion of a number might not sum back up to the number again because of examples like this :-)</p>",
        "id": 275542578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647449730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/275542072\">said</a>:</p>\n<blockquote>\n<p>I suspect that you can make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[X]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> into a linear ordered ring by demanding that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">0&lt;|X|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span></span></span></span> but that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">|X|&lt;\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span> for all positive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span>, and then following your nose (I didn't check this but I think I've checked it in the past). This might well be a <code>floor_ring</code> which is not archimedean -- something for the <code>counterexamples</code> folder? (there might be simpler examples)</p>\n</blockquote>\n<p>This would be a fun counterexample to try to construct using what we have in mathlib for model theory! Take an ultrapower of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> w.r.t. a nonprincipal ultrafilter on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>n</mi><msub><mo stretchy=\"false\">)</mo><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\epsilon = (1/n)_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> be an infinitesimal element in this ultrapower. Now prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span> is transcendental over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, etc.</p>",
        "id": 275543331,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1647449987
    },
    {
        "content": "<p>Wait I'm confused now--I think there are multiple notions of archimedean here (I mean besides the p-adic related one).</p>",
        "id": 275570463,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647461401
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/archimedean\">docs#archimedean</a></p>",
        "id": 275570548,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1647461431
    },
    {
        "content": "<p>I would argue this isn't the definition that most people would guess</p>",
        "id": 275570571,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647461446
    },
    {
        "content": "<p>Yes, have a look at the WIkipedia page.</p>",
        "id": 275570581,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647461450
    },
    {
        "content": "<p>but it doesn't matter for fields</p>",
        "id": 275570587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647461456
    },
    {
        "content": "<p>To <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , I think that is correct. All sorts of weird orderings on polynomial rings that Groebner bases make use of! See theorem 2.5 <a href=\"https://people.math.wisc.edu/hans/paper_archive/scanned_papers/hs021.pdf\">here</a> and then take the floor to be the floor of the constant coefficient.</p>",
        "id": 275575517,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647463955
    },
    {
        "content": "<p>Speaking of, <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> everything in <a href=\"https://github.com/leanprover-community/mathlib/blob/c459d2b5a246e2e14aebd7713daec2b71cc6c144/src/order/filter/archimedean.lean#L31\">the file</a> with <code>tendsto_coe_nat_at_top_at_top</code> seems to be implied by the lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/order/archimedean.html#exists_nat_ge\"><code>exists_nat_ge</code></a>. Now this lemma is _also_ true in a <code>floor_semiring</code> (just take the <code>ceil</code> of an element and use the Galois connection).</p>\n<p>I don't actually use this lemma at this level of generality, but I'm happy while I'm here to swap out the lemmas in the file to use this (slightly) more general lemma. However, as <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> pointed out, archimedean rings are only _noncomputably_ <code>floor_ring</code>s. I honestly do not know the implications of this for the library, so I'm also happy _not_ to do this and just use Heather's trick for my purposes!</p>",
        "id": 275590078,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1647473107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Kevin.20Wilson.3A.20Introduction.20.28.2B.20a.20question.20on.20small.20examples.29/near/275542072\">said</a>:</p>\n<blockquote>\n<p>I suspect that you can make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[X]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> into a linear ordered ring by demanding that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">0&lt;|X|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span></span></span></span> but that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>X</mi><mi mathvariant=\"normal\">∣</mi><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">|X|&lt;\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span> for all positive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span>, and then following your nose</p>\n</blockquote>\n<p>This is just the lexicographic order on R^(order_dual N) (restricted to finsupp), right?</p>",
        "id": 275591681,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1647474509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"474023\">@Kevin Wilson</span> Please go ahead!  I (I'll even say \"we\") don't care about noncomputability at all.</p>",
        "id": 275591742,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647474583
    },
    {
        "content": "<p>Hi again! I've now gotten several PRs merged, including the fact that <code>sqrt 1 = 1</code> and Moebius function is multiplicative! Always amazing to be a first time contributor to a project :-)</p>\n<p>A quick question as I continue slowly merging in these 3kloc: I still have a lot of lemmas that I couldn't find a good representation of in mathlib but which are very useful for analytic number theory. For instance, these two:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">integral_tendsto_of_has_deriv_at</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hderiv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Ici</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">has_deriv_at</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hvanish</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">Ici</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">interval_integrable</span> <span class=\"n\">f'</span> <span class=\"n\">volume</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"bp\">∫</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">a..b</span><span class=\"o\">,</span> <span class=\"n\">f'</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and its consequence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">integral_rpow_tendsto_at_top</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">):</span>\n<span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"bp\">∫</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">a..y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>My general question: What is the etiquette for figuring out _where_ a lemma should go? E.g., should I just continue posting on this now very long thread, or should I post in something like \"Is there code for X?\"</p>\n<p>And a follow up: If this is the appropriate forum, where's the best place to put those above lemmas? :-)</p>\n<p>Thanks again!</p>",
        "id": 276744360,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1648326737
    },
    {
        "content": "<p>A great way to figure this out is to look up the lemmas you used in the proof and see whether you can stick yours in their file.</p>",
        "id": 276744398,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648326822
    },
    {
        "content": "<p>Thanks! That's been my strategy so far, but this one had me a little stumped b/c OTOH, it's basically identical to a lemma in the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/interval_integral\">docs#interval_integral</a> and OTOH, there's an entire file <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.ae_cover\">docs#measure_theory.ae_cover</a> which is sort of meant to handle these things.</p>\n<p>Is it better to \"take a guess\" and post a PR and discuss there, or would you all prefer a discussion on Zulip?</p>",
        "id": 276744617,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1648327107
    },
    {
        "content": "<p>Asking doesn't hurt <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 276744631,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648327149
    },
    {
        "content": "<p>:-)</p>",
        "id": 276744695,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1648327208
    },
    {
        "content": "<p>(Also, sorry about the docs links, was trying to figure out how exactly they worked!)</p>\n<p>In the spirit of asking, do y'all have a preference before I make a PR for those two lemmas?</p>",
        "id": 276744716,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1648327285
    },
    {
        "content": "<p>Personally, no. The measure theory library is quite alien to me! <span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> will have opinions, however.</p>",
        "id": 276744950,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648327603
    },
    {
        "content": "<p>Excellent. I'll wait for a ruling before barging ahead on those!</p>",
        "id": 276745173,
        "sender_full_name": "Kevin Wilson",
        "timestamp": 1648327936
    }
]
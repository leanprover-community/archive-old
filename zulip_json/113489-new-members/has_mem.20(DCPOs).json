[
    {
        "content": "<p>I'm trying to define DCPOs and I'm sure I'm doing a zillion things wrong but mostly I don't understand the behavior of has_mem, which seems to be needed somehow in part of my code. I see has_mem is in a lot of other mathlib files used for defining things like subgroups, subrings with lines like <code>instance : has_mem G (subgroup G) := ⟨λ m K, m ∈ (K : set G)⟩</code> which I have tried to mimic but I can't get  this message to go away:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">,</span>\n<span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">to_partial_order</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n<span class=\"n\">to_has_sup</span> <span class=\"o\">:</span> <span class=\"n\">has_sup</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n<span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">to_partial_order</span> <span class=\"o\">:=</span> <span class=\"n\">partial_order.le</span><span class=\"o\">,</span>\n<span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">to_partial_order</span> <span class=\"o\">:=</span> <span class=\"n\">partial_order.lt</span><span class=\"o\">,</span>\n<span class=\"n\">le_refl</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">to_partial_order</span> <span class=\"o\">:=</span> <span class=\"n\">partial_order.le_refl</span><span class=\"o\">,</span>\n<span class=\"n\">le_trans</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c_1</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c_1</span><span class=\"o\">)</span>\n  <span class=\"n\">to_partial_order</span> <span class=\"o\">:=</span>\n  <span class=\"n\">partial_order.le_trans</span><span class=\"o\">,</span>\n<span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n   <span class=\"n\">auto_param</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">name.mk_string</span> <span class=\"s2\">\"order_laws_tac\"</span> <span class=\"n\">name.anonymous</span><span class=\"o\">))</span>\n  <span class=\"n\">to_partial_order</span> <span class=\"o\">:=</span>\n  <span class=\"n\">partial_order.lt_iff_le_not_le</span><span class=\"o\">,</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">to_partial_order</span> <span class=\"o\">:=</span>\n  <span class=\"n\">partial_order.le_antisymm</span><span class=\"o\">,</span>\n<span class=\"n\">sup</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">has_sup</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">dset</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"n\">to_has_sup</span> <span class=\"o\">:=</span> <span class=\"n\">has_sup.sup</span><span class=\"o\">,</span>\n<span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dset</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_mem</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">dset</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I guess I don't really know why all those other mathlib files need this has_mem instance, or why it's showing up in my infoview. Here's roughly what I have so far. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">dset</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">]:=</span>\n    <span class=\"o\">(</span><span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span> <span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">is_directed</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}:</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">D</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_sup</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">dset</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">dcpo</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">has_sup</span> <span class=\"n\">P</span><span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">le_sup</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">dset</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">sup</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Any help would be appreciated!</p>",
        "id": 217539571,
        "sender_full_name": "Aram Bingham",
        "timestamp": 1606030793
    },
    {
        "content": "<p><code>has_mem</code> is a <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#inferring-notation\">notation type class</a> associated to the symbol <code>∈</code>. To provide a <code>has_mem P (dset P)</code> instance, you need to supply a function of type <code>P → dset P → Prop</code>.</p>",
        "id": 217539826,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1606031299
    },
    {
        "content": "<p>I'm guessing something like the following is what you want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">dset</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">dP</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">dP.D</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 217539905,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1606031518
    },
    {
        "content": "<p>It might end up being more convenient to first provide a coercion from <code>dset P</code> to <code>set P</code>, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">dset</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">dset.D</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">dset</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">dP</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">dP</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 217540009,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1606031707
    },
    {
        "content": "<p>ahhh ok thank you this works! so is the idea that i have to tell lean what it means for terms of type  P to be in a directed set by coercing dsets to be sets<br>\n and then the symbol <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∈</mo></mrow><annotation encoding=\"application/x-tex\">\\in</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span></span></span></span> makes sense?</p>",
        "id": 217540235,
        "sender_full_name": "Aram Bingham",
        "timestamp": 1606032147
    },
    {
        "content": "<p>An instance of <code>has_mem</code> tells Lean what <code>∈</code> should mean, and the instance of <code>has_coe (dset P) (set P)</code> tells Lean how to coerce something of type <code>dset P</code> to type <code>set P</code>. That's used in the expression <code>(dP : set P)</code> in the second <code>has_mem</code> instance I defined above.</p>",
        "id": 217540320,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1606032306
    },
    {
        "content": "<p>Gotcha this is making much more sense now, thank you!</p>",
        "id": 217540389,
        "sender_full_name": "Aram Bingham",
        "timestamp": 1606032467
    },
    {
        "content": "<p>OK so now I'm trying to show that DCPOs are also <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-CPOs. To do this, I want to be able to coerce chains into directed sets and I'm trying to do this in stages by first defining the set that is the image of the underlying function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\"> \\N \\to \\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> of a chain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span>. Something is not type-checking with the first part already</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">chain</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">infer_instance</span> <span class=\"o\">(</span><span class=\"n\">has_coe_to_fun</span> <span class=\"bp\">$</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→ₘ</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">has_coe_to_dset</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">chain</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">dset</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span><span class=\"n\">D</span><span class=\"o\">:=</span> <span class=\"n\">set.image</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n     <span class=\"n\">is_directed</span><span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>where I get  the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">has_coe_to_fun</span> <span class=\"n\">c</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">c</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">chain</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Sort</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span>\n</code></pre></div>\n<p>I don't have a great grasp of what this means, but when I go to the mathlib file omega_complete_partial_order and try to check the same thing with  <code>#check has_coe_to_fun c</code>  I get a very similar error. What's going wrong?</p>",
        "id": 217566862,
        "sender_full_name": "Aram Bingham",
        "timestamp": 1606074802
    },
    {
        "content": "<p>nvm, I think I got around it by defining </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">chain_image</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">chain</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 217568130,
        "sender_full_name": "Aram Bingham",
        "timestamp": 1606076595
    },
    {
        "content": "<p>OK, i've been able to show that chains give directed sets, now I think it makes sense to create an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-CPO as an instance of a DCPO but having a new trouble</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">dcpo</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ωcpo</span> <span class=\"n\">P</span><span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">ωsup</span><span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n      <span class=\"n\">le_ωsup</span><span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n      <span class=\"n\">ωsup_le</span><span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>gives the error<br>\n<code>invalid definition, a declaration named 'ωcpo' has already been declared</code><br>\nI assume I have bad syntax somewhere but I was just trying to copy examples from lftcm2020 so I'm not sure where...</p>",
        "id": 217575990,
        "sender_full_name": "Aram Bingham",
        "timestamp": 1606087562
    },
    {
        "content": "<p>You should name the instance if it doesn't get a good name</p>",
        "id": 217576110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606087730
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">dcpo.to_ωcpo</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">dcpo</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ωcpo</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 217576130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606087761
    },
    {
        "content": "<p>aha! thank you, so it was that the instance was trying to take on the name <code>ωcpo</code> by default ?</p>",
        "id": 217576316,
        "sender_full_name": "Aram Bingham",
        "timestamp": 1606087986
    }
]
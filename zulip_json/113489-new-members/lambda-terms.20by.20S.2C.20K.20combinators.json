[
    {
        "content": "<p>Hello, I am trying to implement a version of the SKI calculus, and I got stuck at defining λ-terms by combinators. What I have is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">ground</span> <span class=\"o\">:</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">compose</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"n\">type</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`&gt;&gt;`</span> <span class=\"o\">:=</span> <span class=\"n\">type.compose</span>\n\n<span class=\"c1\">-- for each type τ, variables of type τ are represented by natural indices</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">var</span>\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">of_var</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">var</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"n\">σ</span>\n<span class=\"bp\">|</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"bp\">$</span> <span class=\"n\">τ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">σ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"n\">σ</span> <span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">σ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">τ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ρ</span>\n\n<span class=\"c1\">-- is_free_var x t means that x occurs in t</span>\n<span class=\"c1\">-- Probably needed for the following definition, I left out its body</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">is_free_var</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">var</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">decidable_is_free_var</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"n\">σ</span><span class=\"o\">},</span> <span class=\"n\">decidable</span> <span class=\"bp\">$</span> <span class=\"n\">is_free_var</span> <span class=\"n\">x</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now, for variables <code>x</code> and terms <code>t</code> of any type, we define a term<code>λ x . t</code> by<br>\n<code>λ x . x := S K K</code><br>\n<code>λ x . a := K a, if x is not a variable in a</code><br>\n<code>λ x . (a x) := a, if x is not a variable in a</code><br>\n<code>λ x . (a b) := S (λ x . a) (λ x. b), otherwise</code><br>\nfor combinators of appropriate types. I've been trying for some time to implement this definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lambda</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">var</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The main problem is that the definition does not follow the inductive structure of terms, so I end up with a lot of nested case-checks (which can't even be easily written for variables, since I cannot write x = y with x : var τ and y : var σ),  which end up not typechecking, or rendering Lean unable to prove the recursions are terminating or other errors. I can post some of my unsuccessful attempts if it helps. Am I missing a cleaner way of writing this definition?</p>",
        "id": 226351816,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1613373771
    }
]
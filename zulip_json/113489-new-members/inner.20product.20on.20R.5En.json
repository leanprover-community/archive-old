[
    {
        "content": "<p>Shouldn't lean be able to infer that inner x y is a real number in this context?<br>\n<a href=\"/user_uploads/3121/lS0eSZG44WkMGd2tBholP2OD/Untitled.png\">Untitled.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/lS0eSZG44WkMGd2tBholP2OD/Untitled.png\" title=\"Untitled.png\"><img src=\"/user_uploads/3121/lS0eSZG44WkMGd2tBholP2OD/Untitled.png\"></a></div>",
        "id": 214892629,
        "sender_full_name": "Jean-Philippe Burelle",
        "timestamp": 1603916511
    },
    {
        "content": "<p>We recommend pasting code blocks instead of images</p>",
        "id": 214894873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603917753
    },
    {
        "content": "<p>A vector space can exist over multiple scalar fields, so the result type is not determined</p>",
        "id": 214895158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603917892
    },
    {
        "content": "<p>I see these in the <code>normed_space.inner_product</code> file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫</span><span class=\"n\">_ℝ</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫</span><span class=\"n\">_ℂ</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"n\">ℂ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n\n<p>so you should probably use these to force the result type</p>",
        "id": 214895268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603917940
    },
    {
        "content": "<p>from these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">localized</span> <span class=\"s2\">\"notation `⟪`x`, `y`⟫` := @inner ℝ _ _ x y\"</span> <span class=\"k\">in</span> <span class=\"n\">real_inner_product_space</span>\n<span class=\"n\">localized</span> <span class=\"s2\">\"notation `⟪`x`, `y`⟫` := @inner ℂ _ _ x y\"</span> <span class=\"k\">in</span> <span class=\"n\">complex_inner_product_space</span>\n</code></pre></div>\n\n<p>it follows that you can <code>open_locale real_inner_product_space</code> to say you want the unadorned notation to refer to the real inner product</p>",
        "id": 214895376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603917986
    },
    {
        "content": "<p>If I look at the instances for <code>inner_product_space</code>, I think there is no inner-product space structure (yet) on <code>euclidean_space</code>. There should be one on <code>pi_Lp 2 one_le_two (λ _ : fin n, ℝ)</code> (which is the same space), however, it doesn't work for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">constants</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pi_Lp</span> <span class=\"mi\">2</span> <span class=\"n\">one_le_two</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span>\n</code></pre></div>\n\n<p>This is worrying. The problem from the trace seems to be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">x_12</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">inner_product_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"bp\">?</span><span class=\"n\">x_8</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">is_R_or_C.inner_product_space</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_13</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_14</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n</code></pre></div>",
        "id": 214896312,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1603918478
    },
    {
        "content": "<p>This is really weird. If I replace the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>by</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">inner_product_space</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">pi_Lp</span> <span class=\"mi\">2</span> <span class=\"n\">one_le_two</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">ℝ</span><span class=\"o\">)),</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n</code></pre></div>\n\n<p>everything seems to work fine. In the example the typeclass search seems to fail to find the instance <code>real.is_R_or_C</code>, but in the <code>#check</code> line it finds it immediately.</p>",
        "id": 214919212,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603937433
    },
    {
        "content": "<p>This is really ridiculous -- this fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">constants</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pi_Lp</span> <span class=\"mi\">2</span> <span class=\"n\">one_le_two</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">pi_Lp</span> <span class=\"mi\">2</span> <span class=\"n\">one_le_two</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>whereas this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">constants</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pi_Lp</span> <span class=\"mi\">2</span> <span class=\"n\">one_le_two</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">pi_Lp</span> <span class=\"mi\">2</span> <span class=\"n\">one_le_two</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">inner_product_space.to_has_inner</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 214920363,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603938951
    },
    {
        "content": "<p>Even though the first and only thing it tries for that <code>_</code> is <code>inner_product_space.to_has_inner</code>.</p>",
        "id": 214920448,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603939030
    },
    {
        "content": "<p>So even this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">constants</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pi_Lp</span> <span class=\"mi\">2</span> <span class=\"n\">one_le_two</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">inner_product_space.to_has_inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>I have no idea what's going on.</p>",
        "id": 214921179,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603939898
    },
    {
        "content": "<p>Hmmm, can we have a type class expert look at this?</p>",
        "id": 214929680,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603951726
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span></p>",
        "id": 214929681,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603951732
    },
    {
        "content": "<p>I would add these instances.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">inner_product_space.to_has_inner_real</span> <span class=\"o\">{</span><span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">inner_product_space.to_has_inner</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">_</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">inner_product_space.to_has_inner_complex</span> <span class=\"o\">{</span><span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">inner_product_space.to_has_inner</span> <span class=\"n\">ℂ</span> <span class=\"n\">E</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 214949925,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1603967955
    },
    {
        "content": "<p>That seems to fix it for ℝ and ℂ, but if we do the same example for some <code>[is_R_or_C 𝕜]</code> we get the same problem...</p>",
        "id": 214962091,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603976296
    },
    {
        "content": "<p>The original problem came up when I was trying to use the Cauchy-Schwarz inequality (as implemented) <code>real_inner_mul_inner_self_le</code> in a concrete setting. I still don't know how to prove, say, <code>(x1*y1 + x2*y2)^2 &lt;= (x1*x1 + x2*x2)*(y1*y1 + y2*y2)</code> from that theorem without running into problems. Even when <code>inner</code> returns a real number, I couldn't get it to unfold into a sum of products in the case of <code>euclidean_space ℝ (fin 2)</code>. So far I have :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">cauchyschwarz</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">euclidean_space</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"k\">have</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">real_inner_mul_inner_self_le</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n   <span class=\"n\">unfold</span> <span class=\"n\">inner</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n   <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>which gets me a bunch of terms like <code>finset.univ.sum (λ (x_1 : fin 2), x x_1 * y x_1)</code>. Where do I go from here?</p>",
        "id": 215125771,
        "sender_full_name": "Jean-Philippe Burelle",
        "timestamp": 1604078788
    },
    {
        "content": "<p>The whole issue is that the inner product is defined in terms of sums over the underlying type (here <code>fin 2</code>), and it turns out that showing that the sum is equal to a sequence of additions is not so easy (or at least I don't know how to do it cleanly). Otherwise it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">cauchyschwarz</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">euclidean_space</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">h₃</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">real_inner_mul_inner_self_le</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 215161129,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1604099591
    },
    {
        "content": "<p>Using <code>0</code> and <code>1</code> instead of <code>1</code> and <code>2</code> as indices would be a good idea (though <code>2 = 0</code> in <code>fin 2</code>), then <code>by { simp [fin.sum_univ_succ, add_assoc], refl }</code> works for those sums.</p>",
        "id": 215214426,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1604182447
    },
    {
        "content": "<p>If you follow that suggestion, those <code>sorry</code>s should be <code>rfl</code>.</p>",
        "id": 215228829,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1604208971
    },
    {
        "content": "<p>So, to summarize the suggestions above,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchyschwarz</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">euclidean_space</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">real_inner_mul_inner_self_le</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">using</span> <span class=\"mi\">2</span><span class=\"bp\">;</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">fin.sum_univ_succ</span><span class=\"o\">,</span> <span class=\"n\">inner</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 215259671,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1604261026
    },
    {
        "content": "<p>Also this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchyschwarz</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">euclidean_space</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">real_inner_mul_inner_self_le</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">;</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">inner</span><span class=\"o\">,</span> <span class=\"n\">list.pmap</span><span class=\"o\">,</span> <span class=\"n\">is_R_or_C.conj_to_real</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">nat.add_def</span><span class=\"o\">,</span>\n             <span class=\"n\">fin.mk_eq_subtype_mk</span><span class=\"o\">,</span> <span class=\"n\">list.foldr</span><span class=\"o\">,</span> <span class=\"n\">fin.mk_one</span><span class=\"o\">,</span> <span class=\"n\">list.map</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 215259889,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1604261330
    },
    {
        "content": "<p>which just uses the output of <code>squeeze_simp [inner]</code></p>",
        "id": 215259901,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1604261344
    },
    {
        "content": "<p>But wouldn't a more basic proof of this be on expanding polynomials?</p>",
        "id": 215259984,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1604261461
    }
]
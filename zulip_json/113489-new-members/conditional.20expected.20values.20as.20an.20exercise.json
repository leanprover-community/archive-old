[
    {
        "content": "<p>As a way to try to familiarize myself with writing math in Lean, I tried conditional expected values (they were the easiest actual math definition I could think of). I did not immediately find them implemented in mathlib yet, but even if they exist or if someone serious is already working on them, it doesn't matter at all --- my only goal here is to see if I can get to the point of doing anything in Lean. (I also only have time for trying this very irregularly.)</p>\n<p>I imagined a certain sequence of mathematically trivial steps that might constitute a good exercise for myself, starting from the definition(s) and sanity-check lemmas, including a.e.-uniqueness. Next would be some standard properties, of which I would probably pick and choose for the purposes of my exercise. Many of the early steps would actually not yet involve the existence of conditional expected values. Existence is slightly nontrivial --- it commonly done with the Radon-Nikodym theorem (which I believe is not yet in mathlib), although in my exercise I would like to actually approach it via first doing it only in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">L^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> by orthogonal projections to closed subspaces (completeness of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi>μ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^2(\\mu)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">μ</span><span class=\"mclose\">)</span></span></span></span> appeared to be there, other stuff I didn't check). Anyways, the point is I had a (rough) sequence of mathematically very easy definitions and lemmas in mind. And the other important thing: the purpose was an exercise, not a contribution to mathlib (I'm nowhere close to the level yet).</p>\n<p>Predictably, I not only failed at the sanity-check stage, but I even largely failed to reach that stage...</p>\n<p>I will have some questions below about complete trivialities. If someone is patient and willing to help despite the fact I'm stuck at the syntax and trivialities at step 0, and despite the fact that this is not an attempt at a mathlib contribution, I will be very grateful!</p>",
        "id": 232845601,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617324229
    },
    {
        "content": "<p>I don't know what is the best way to pose the questions. For now, I created a single file &lt;<a href=\"https://github.com/kkytola/lean-questions/blob/main/cond_exp-question-20210401.lean\">https://github.com/kkytola/lean-questions/blob/main/cond_exp-question-20210401.lean</a>&gt;, which contains some of the first steps I already stumbled with. I will try to describe some actual questions below, in particular because the file is not a mwe.</p>",
        "id": 232845684,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617324288
    },
    {
        "content": "<p>It seemed like the first thing should be to define sub-sigma-algebras <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">G</mi><mo>⊂</mo><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathscr{G} \\subset \\mathscr{F}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7391em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.17322em;\">G</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.13634em;\">F</span></span></span></span></span> of a given sigma-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathscr{F}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.13634em;\">F</span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_subsigmaalg</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁.</span><span class=\"n\">is_measurable'</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂.</span><span class=\"n\">is_measurable'</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Of course, after actually doing this, I realized that the set of <code>measurable_space</code>s on a given set is an instance of a <code>complete_lattice</code>, so the appropriate <code>le</code> is unsurprisingly already there in mathlib <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span>. Well, at least my definition coincided with the actual one <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> --- I could prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_subsigmaalg_iff_le</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span> <span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_subsigmaalg</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"bp\">↔</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">≤</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Nevertheless, I still had trouble using some of the syntax for the existing <code>complete_lattice</code>. For example, I don't know how to get the trivial sigma-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">G</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">∅</mi><mo separator=\"true\">,</mo><mi>S</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\mathscr{G} = \\{ \\emptyset , S \\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.17322em;\">G</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">∅</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">}</span></span></span></span> as the minimal element of the complete lattice. I ended up using the following definition, which certainly feels redundant given what already exists...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_trivial_sigmaalg</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Γ.</span><span class=\"n\">is_measurable'</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Any hints on using <code>complete_lattice</code> for this directly?</p>",
        "id": 232845993,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617324541
    },
    {
        "content": "<p>Have you looked at how bundled subobjects are done in mathlib?</p>",
        "id": 232846214,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617324755
    },
    {
        "content": "<p>My current (almost surely not satisfactory) definition of a conditional expected value is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">cond_exp_enn</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">Γ</span><span class=\"n\">sub</span> <span class=\"bp\">Γ</span><span class=\"n\">full</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hsub</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span><span class=\"n\">sub</span> <span class=\"bp\">≤</span> <span class=\"bp\">Γ</span><span class=\"n\">full</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measure_theory.measure</span> <span class=\"n\">S</span> <span class=\"bp\">Γ</span><span class=\"n\">full</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">)</span>\n    <span class=\"o\">(</span> <span class=\"n\">is_submeasurable</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">S</span> <span class=\"n\">ennreal</span> <span class=\"bp\">Γ</span><span class=\"n\">sub</span> <span class=\"n\">_</span> <span class=\"n\">to_fun</span> <span class=\"o\">)</span>\n    <span class=\"o\">(</span> <span class=\"n\">equal_subintegrals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"bp\">Γ</span><span class=\"n\">sub.is_measurable'</span> <span class=\"n\">E</span> <span class=\"bp\">→</span>\n        <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">E</span> <span class=\"o\">,</span> <span class=\"n\">to_fun</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∂</span> <span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">E</span> <span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∂</span> <span class=\"n\">μ</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>I don't know if this is any good... I would appreciate comments on:</p>\n<ul>\n<li>Is <code>structure</code> at all reasonable for such definitions?</li>\n<li>In the current version I am not requiring measurability and integrability of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, or that the measure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span> is a probability measure. All of these would almost always be needed, so should they be a part of the definition?<ul>\n<li>(I suppose constructing instances would become harder, but lemmas could then avoid repeatedly the same assumptions.)</li>\n</ul>\n</li>\n<li>Here I'm already using some <code>@</code>s to specify implicit arguments. Later I ended up doing much much more of that, to the extent that I think I'm doing something wrong. Does this sound like a common beginners' tendency that I could learn to avoid?</li>\n<li>The above works with functions and is going to be only a.e. unique, but I suppose one can have a parallel definition with equivalence classes like in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">L^p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span>-spaces (?). Then one will have actual uniqueness etc.</li>\n<li>Anything else that an experienced person can tell me <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></li>\n</ul>\n<p>Quite embarrassingly, I failed to do a coercion to a function <code> f : S → ennreal</code>. I have seen some analogous coercions in the tutorials I did, but none of my imitations of the syntax seemed to work. Besides <em>\"Go to definition\"</em>, I only found this documentation &lt;<a href=\"https://leanprover-community.github.io/mathlib_docs/init/coe.html#has_coe_to_fun\">https://leanprover-community.github.io/mathlib_docs/init/coe.html#has_coe_to_fun</a>&gt;. After seeing both I am at loss... even about whether <code>is_coe_to_fun</code> is a <code>structure</code> or a <code>class</code> (and I frankly forgot what little I learned about their differences anyway).</p>\n<p>Here's my attempt at a minimal example in which I can't figure out the syntax...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">@[instance]</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo.has_coe_to_fun</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">foo</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">,</span>\n  <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 232846224,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617324771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/conditional.20expected.20values.20as.20an.20exercise/near/232846214\">said</a>:</p>\n<blockquote>\n<p>Have you looked at how bundled subobjects are done in mathlib?</p>\n</blockquote>\n<p>No, I'm afraid not... I did some tutorials, but I don't remember encountering those (or possibly I wasn't paying attention or understanding). Where would I find information about them?</p>",
        "id": 232846353,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617324877
    },
    {
        "content": "<blockquote>\n<p>Quite embarrassingly, I failed to do a coercion to a function  f : S → ennreal. I have seen some analogous coercions in the tutorials I did, but none of my imitations of the syntax seemed to work. Besides \"Go to definition\", I only found this documentation &lt;<a href=\"https://leanprover-community.github.io/mathlib_docs/init/coe.html#has_coe_to_fun\">https://leanprover-community.github.io/mathlib_docs/init/coe.html#has_coe_to_fun</a>&gt;.</p>\n</blockquote>\n<p>Coercions are explained at the very end of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html?highlight=priority#coercions-using-type-classes\">TPiL</a>.</p>",
        "id": 232846401,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617324926
    },
    {
        "content": "<p>You could read the <code>subgroup</code> code -- you bundle the carrier set and the properties retained. I think <code>data/set_like</code> was merged in, which gives a nice general framework for such bundles.</p>",
        "id": 232846510,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617325025
    },
    {
        "content": "<p>I should look at the <code>set_like</code> code too, since I've always been a bit uncomfortable with subobjects...</p>",
        "id": 232846580,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617325083
    },
    {
        "content": "<p>Oops. I did subgroups as a part of the first half of Kevin Buzzard's course, so I evidently didn't learn something I should have... I will take another look.</p>\n<p>Just a clarification: is the bundled thing supposed to be for the definition of the conditional expected value itself or something else I'm getting wrong? (I suppose there's quite a bit...)</p>",
        "id": 232846641,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617325124
    },
    {
        "content": "<p>Just for the subsigmaalgebra bit</p>",
        "id": 232847053,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617325399
    },
    {
        "content": "<p>For the <code>has_coe_to_fun</code>, in most cases, you won't need to fill out the <code>coe</code> field if you fill in the <code>F</code> field. In your case, <code>F := foo.to_fun</code></p>",
        "id": 232847167,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617325508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/113489-new-members/topic/conditional.20expected.20values.20as.20an.20exercise/near/232845601\">said</a>:</p>\n<blockquote>\n<p>Existence is slightly nontrivial --- it commonly done with the Radon-Nikodym theorem (which I believe is not yet in mathlib), although in my exercise I would like to actually approach it via first doing it only in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">L^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> by orthogonal projections to closed subspaces (completeness of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi>μ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^2(\\mu)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">μ</span><span class=\"mclose\">)</span></span></span></span> appeared to be there, other stuff I didn't check). </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span> Some pointers:</p>\n<ul>\n<li>yes, we have the inner product structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi>μ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^2(\\mu)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">μ</span><span class=\"mclose\">)</span></span></span></span> and its completeness as of last month!  <a href=\"https://github.com/leanprover-community/mathlib/issues/6596\">#6596</a>, <a href=\"https://github.com/leanprover-community/mathlib/issues/6563\">#6563</a></li>\n<li>orthogonal projection: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orthogonal_projection\">docs#orthogonal_projection</a> </li>\n<li><span class=\"user-mention\" data-user-id=\"247798\">@Martin Zinkevich</span> has a proof of Radon-Nikodym at<br>\n<a href=\"https://github.com/google/formal-ml/blob/master/src/formal_ml/radon_nikodym.lean\">https://github.com/google/formal-ml/blob/master/src/formal_ml/radon_nikodym.lean</a><br>\nwhich he has gradually been PR'ing.</li>\n</ul>\n<p>For other things, feel free to ask!</p>",
        "id": 232849011,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617327266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/113489-new-members/topic/conditional.20expected.20values.20as.20an.20exercise/near/232845993\">said</a>:</p>\n<blockquote>\n<p>Nevertheless, I still had trouble using some of the syntax for the existing <code>complete_lattice</code>. For example, I don't know how to get the trivial sigma-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">G</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">∅</mi><mo separator=\"true\">,</mo><mi>S</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\mathscr{G} = \\{ \\emptyset , S \\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.17322em;\">G</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">∅</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">}</span></span></span></span> as the minimal element of the complete lattice. I ended up using the following definition, which certainly feels redundant given what already exists...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_trivial_sigmaalg</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Γ.</span><span class=\"n\">is_measurable'</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Any hints on using <code>complete_lattice</code> for this directly?</p>\n</blockquote>\n<p>The trivial subalgebra is the smallest element in the lattice, so it is called bot (for bottom), and typed as <code>⊥</code> (\\bot in vscode).</p>",
        "id": 232863225,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617342302
    },
    {
        "content": "<p>I think the conditional expectation of a function should just be a function, together with statements that assert it behaves like you want. Something along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.bochner_integration</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span>\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cond_exp_enn</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">measurable_cond_exp_enn</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">measurable</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">F</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">cond_exp_enn</span> <span class=\"n\">F</span> <span class=\"n\">μ</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_cond_exp_enn</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">measurable_set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"n\">cond_exp_enn</span> <span class=\"n\">F</span> <span class=\"n\">μ</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The real work is in the definition of <code>cond_exp_enn</code> to make sure that the other lemmas work, of course.</p>",
        "id": 232866089,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617345169
    },
    {
        "content": "<p>Thank you Sebastien!</p>\n<p>To be honest, it took me a while to get what you mean at all (but I knew that you are an expert at this, so tried to unravel).</p>\n<p>Why I was very puzzled at first is the following. In my opinion, in math we give the defining property of conditional expected value and then we prove <strong>(1)</strong> that the property uniquely defines the conditional expected value (modulo modification on a zero measure set) and <strong>(2)</strong> that the conditional expected value of an integrable random variable exists. My exercise was structured like this, too. At first I could not see at all what you meant by defining conditional expected values and then proving that (what I think of as) the defining property is satisfied by the given definition...</p>\n<p>But I think I ultimately got what you mean --- please correct me if I'm wrong. The analogy with real numbers might be that we want the Lean definition to be something, say equivalence classes of Cauchy sequences of rationals, and then the <em>axiomatic</em> (\"defining\") properties are proven from that definition (as opposed to giving axioms and proving existence and uniqueness). So do I get it right that with conditional expected values you suggest to take the Lean definition to be an actual construction? Such a construction might be e.g. <strong>(1)</strong> a suitable Radon-Nikodym derivative or <strong>(2)</strong> an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^1(\\mathsf{P})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">P</span></span><span class=\"mclose\">)</span></span></span></span>-limit of orthogonal projections to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Ω</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">G</mi><mo separator=\"true\">,</mo><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">)</mo><mo>⊂</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Ω</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">F</mi><mo separator=\"true\">,</mo><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^2(\\Omega,\\mathscr{G},\\mathsf{P}) \\subset L^2(\\Omega,\\mathscr{F},\\mathsf{P})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Ω</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.17322em;\">G</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Ω</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.13634em;\">F</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span></span><span class=\"mclose\">)</span></span></span></span> of truncations which are in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">)</mo><mo>⊂</mo><msup><mi>L</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^2(\\mathsf{P}) \\subset L^1(\\mathsf{P})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">P</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">P</span></span><span class=\"mclose\">)</span></span></span></span> (no point taking an equivalence class of such sequences, I guess, since a good sequence is quite constructive?).</p>\n<p>I have no doubt your suggestion is the better formalization strategy. For the purposes of my exercise, however, I will still consider whether it is your suggestion or simply a \"defining property\" <code>structure</code> that is easier for incremental playing around. In principle, if the second approach would ever reach a sufficiently complete stage, I suppose refactoring towards your suggested approach (or just writing a second version from scratch) might be a way to get to mathlib quality. (Just don't count on me ever getting that far!)</p>\n<p>I really appreciate your insight, thank you! Your advice definitely helps me understand good formalization. But given that I'm still very much stuck at the syntax it will take me very very long before I can put that into actual practice.</p>",
        "id": 233009735,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617459749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113489-new-members/topic/conditional.20expected.20values.20as.20an.20exercise/near/232863225\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/113489-new-members/topic/conditional.20expected.20values.20as.20an.20exercise/near/232845993\">said</a>:</p>\n<blockquote>\n<p>Nevertheless, I still had trouble using some of the syntax for the existing <code>complete_lattice</code>. For example, I don't know how to get the trivial sigma-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">G</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">∅</mi><mo separator=\"true\">,</mo><mi>S</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\mathscr{G} = \\{ \\emptyset , S \\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.17322em;\">G</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">∅</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">}</span></span></span></span> as the minimal element of the complete lattice.</p>\n</blockquote>\n<p>The trivial subalgebra is the smallest element in the lattice, so it is called bot (for bottom), and typed as <code>⊥</code> (\\bot in vscode).</p>\n</blockquote>\n<p>Thank you!</p>\n<p>I had actually guessed that <code>bot</code> or <code>⊥</code> would be the right thing, but I had not figured out the syntax. With <code>variable (α : Type*)</code> I had tried things like <code>(measurable_space α).⊥</code> and <code>(measurable_space α).complete_lattice.⊥</code>, which to me seemed like the most likely things that <code>instance : complete_lattice (measurable_space α)</code> might do (well, it doesn't).</p>\n<p>The one thing I had not tried was <code>(⊥ : measurable_space α)</code>, because that would have been too simple. And of course it not only works <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>, but it is probably the most natural syntax a mathematician could hope for...</p>\n<p>What I guess I learned (at least until the next time) in this exercise is the usefulness of <code>#check</code>. It is way quicker (although I prefer not to elaborate on how long I spent on, e.g.,  <code>⊥</code>) to test with <code>#check</code> than to try to get the syntax right where it is used. So finally, for any other new members, the following <em>is</em> the trivial sigma algebra, and it actually works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">measurable_space</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233049898,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617503663
    },
    {
        "content": "<p>The following is not important at all, but it is somewhat related to the above, and I feel like these sort of things should not be as complicated as I make them look like.</p>\n<p>I checked that my one line condition for triviality coincides with that in <code>⊥ : measurable_space S</code>. What I came up with was not short. Among other things, it takes me three lines to prove that <code>univ : set S</code> is measurable <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span> (I have used this a number of times, and it always takes me three lines). There are surely other terrible choices as well. In case someone has hints on more efficient writing, I'll appreciate. However, this is obviously not of any importance (besides my own very very slow learning).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">open</span> <span class=\"n\">measurable_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_trivial_sigmaalg</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Γ.</span><span class=\"n\">measurable_set'</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_trivial_sigmaalg_iff_bot</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span> <span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">is_trivial_sigmaalg</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span> <span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">htriv</span> <span class=\"o\">,</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">,</span>\n        <span class=\"bp\">Γ.</span><span class=\"n\">measurable_set'</span> <span class=\"n\">E</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">measurable_set'</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ext</span> <span class=\"n\">this</span> <span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">E</span> <span class=\"o\">,</span>\n    <span class=\"n\">split</span> <span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hE</span> <span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">measurable_set_bot_iff.mpr</span> <span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">htriv</span> <span class=\"n\">E</span> <span class=\"n\">hE</span> <span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hE</span> <span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_set_bot_iff.mp</span> <span class=\"n\">hE</span> <span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">key</span> <span class=\"k\">with</span> <span class=\"n\">hEemp</span> <span class=\"n\">hEuniv</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hEemp</span> <span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">measurable_set_empty</span> <span class=\"bp\">Γ</span> <span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hEuniv</span> <span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">mbleempc</span> <span class=\"o\">:=</span> <span class=\"bp\">Γ.</span><span class=\"n\">measurable_set_compl</span> <span class=\"bp\">∅</span> <span class=\"bp\">Γ.</span><span class=\"n\">measurable_set_empty</span> <span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">mbleempc</span> <span class=\"o\">,</span>\n        <span class=\"n\">assumption</span> <span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">,</span>\n      <span class=\"o\">}</span> <span class=\"o\">,</span>\n    <span class=\"o\">}</span> <span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">hbot</span> <span class=\"n\">E</span> <span class=\"n\">hE</span> <span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hbot</span> <span class=\"n\">at</span> <span class=\"n\">hE</span> <span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">measurable_set_bot_iff.mp</span> <span class=\"n\">hE</span> <span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 233050032,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617503853
    },
    {
        "content": "<p>I still have a lot of trivial questions about the syntax, but I will first try to internalize the many very helpful answers to the questions I already posed before posing new ones...</p>\n<p>Thank you to all who have helped me so far!</p>",
        "id": 233050209,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617504083
    },
    {
        "content": "<p>I started implementing a conditional expectation during the last weeks, not for ennreal functions as in the code suggested by Sebastien, but for functions with values in a Hilbert space. Most of the work is on <a href=\"https://github.com/leanprover-community/mathlib/tree/conditional_expectation\">branch#conditional_expectation</a> (mostly in the measure_theory/conditional_expectation file). It is full of <code>sorry</code> for mostly simple but tedious lemmas and globally a big mess, but a lot of the work is done. (it is also somewhat outdated and I should merge master to use some recent results about bounded functions and Lp)</p>\n<p>My strategy is to define the conditional expectation first for L2 as an orthogonal projection to a subspace of L2, then express it as a continuous linear map from the simple functions of L1 to L1 (that it is linear is easy, since I build it by composing three linear maps L1simple -&gt; L2 -&gt; L2 subspace -&gt; L1, but proving the continuity needs work), then extend to a continuous linear map from L1 to L1.<br>\nIt got more difficult than expected from the very first step: I wanted to write the conditional expectation with respect to sigma-algebra <code>m</code> as the orthogonal projection of functions of L^2 (defined with sigma-algebra <code>m0</code>) to the subspace of <code>m</code>-measurable elements of L^2. But with the objects that we have the 0 element of L^2 may not even be <code>m</code>-measurable, so no subspace there. That 0 is however <code>µ</code>-almost-everywhere equal to an <code>m</code>-measurable function for a measure <code>µ</code> defined on <code>m0</code>, and that is the property that should define the subspace.  Proving the completeness of that subspace was something that did not follow that easily from results that we already had, which surprised me.</p>\n<p>I will not detail all steps of the construction but here are a few remarks about how the experience went:</p>\n<ul>\n<li>our library is written with only one <code>measurable_space</code> structure in mind, which is most often an implicit argument in lemmas. As soon as there are two different ones on the same space the code gets more tedious (and you need to write a lot of <code>@</code>).</li>\n<li>there are many different structures involved, which could all represent the same function: simple functions, simple functions seen as elements of L1, L1 functions, L2 functions... the API for converting between those needs more lemmas.</li>\n<li>and an important point, not lean-related, which I was not aware of: many things are not as quick to prove in a generic Hilbert space as they are for R. For some results I used the following approach: first prove it for R, then prove it for indicator functions by writing an indicator function as the scalar product of a real function and an element of the space, then go to simple functions and so on. The book \"analysis in Banach spaces\" (volume 1) was useful.</li>\n</ul>",
        "id": 233190466,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1617637671
    },
    {
        "content": "<p>Regarding the first point, if you want to work with multiple measures you can, the type <code>measure X</code> is there for this. If you want multiple measurable spaces this is less common but should still be possible. Do you have any particular examples in mind?</p>",
        "id": 233199855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617642326
    },
    {
        "content": "<p>It is indeed possible to have multiple <code>measurable_space</code> and that is what I did. I don't really have a problem there, and the main point of my message is just to let <span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span>  know that I am also working on this.</p>\n<p>The library is simply less convenient if there are several <code>measurable_space</code> on a same space.<br>\nThe issue is that since every lemma in the library uses <code>[measurable_space α]</code> and not an explicit argument you will need to use <code>@</code> if you have two and you want to use the one that is not guessed. In the particular example of the conditional expectation for functions in L1: those (equivalence classes of) functions are defined with respect to a measure <code>µ</code> on a <code>m0 : measurable_space α</code>, and the conditional expectation with respect to <code>m &lt;= m0</code> is an <code>m</code>-measurable function. There are naturally two <code>measurable_space</code> around, <code>m0</code> and <code>m</code>. Then if I want to say that a function <code>f</code> is <code>m0</code>-measurable I may write <code>measurable f</code>but to write the same thing with <code>m</code> I have to use <code>@measurable _ _ m _ f</code>. And for some more involved statements the number of <code>_</code> may be large. One of my proofs is full of <code>_ _ _ _ _</code>.</p>\n<p>So working with several <code>measurable_space</code> is totally feasible, it is just not very convenient. As a last remark: until I started working on the conditional expectation, not having to type the name of the <code>measurable_space</code> everywhere was great.</p>",
        "id": 233203170,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1617643923
    },
    {
        "content": "<p>One trick that is used in the topology library when dealing with e.g. continuous functions with multiple topologies on the same space is to define a local notation like <code>notation `measurable'` m f := @measurable _ _ m _ f</code> so that you can supply it when you need to, and use <code>measurable</code> when the default is fine</p>",
        "id": 233208724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617646550
    },
    {
        "content": "<p>for example <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_iff_coinduced_le/src\">src#continuous_iff_coinduced_le</a></p>",
        "id": 233208845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617646591
    },
    {
        "content": "<p>Thanks, I did not know that trick. That can indeed be useful. Although looking at my code, the lemmas that produce the <code>_ _ _ _</code> are quite diverse. At least, <code>@measurable</code> appears several times and will most probably get a notation. Thanks!</p>",
        "id": 233209932,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1617647097
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span>!</p>\n<p>Thank you for letting me know! I am excited to hear that someone serious is working on this!</p>\n<p>I found the branch and file you mentioned, thanks! In principle I would like to be able to offer help, but unfortunately I'm not yet at the level to be able to do so, and I also only have time very irregularly. I will instead try to follow what you do; I will almost surely learn various things from that. Meanwhile I'll probably play a bit more with my own exercise also just to learn a bit more.</p>\n<p>Nice to hear that you also chose the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">L^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>-approach to conditional expected values. I hardly even got started so far, but a number of the things you mention corresponded to my observations as well. Multiple measurable spaces simultaneously on the same type were ultimately not that bad (except for lots of <code>@</code>s and learning syntax). But exactly as you say, the inclusions among the spaces of suitable functions were not easy. In particular, while it is quite straightforward (with lots of <code>@</code>s) to define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Ω</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">G</mi><mo separator=\"true\">,</mo><mi mathvariant=\"sans-serif\">P</mi><msub><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"script\">G</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^2(\\Omega,\\mathscr{G},\\mathsf{P}|_{\\mathscr{G}})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Ω</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.17322em;\">G</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span></span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33999999999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathscr mtight\" style=\"margin-right:0.17322em;\">G</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, I did not yet manage to realize this as a closed subspace of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Ω</mi><mo separator=\"true\">,</mo><mi mathvariant=\"script\">F</mi><mo separator=\"true\">,</mo><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^2(\\Omega,\\mathscr{F},\\mathsf{P})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Ω</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathscr\" style=\"margin-right:0.13634em;\">F</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">P</span></span><span class=\"mclose\">)</span></span></span></span>, so I did not get to use any orthogonal projections yet. As you say, more measure theory lemmas for embedding functions from various spaces to each other would seem useful.</p>\n<p>Thanks again for letting me know, and very glad to hear you're working on this topic!</p>",
        "id": 233213905,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1617649061
    }
]
[
    {
        "content": "<p>Hello everyone,</p>\n<p>I'm not sure this is where I'm supposed to write this, feel free to move the topic if it should. I recently started getting interested in lean/mathlib and after fiddling a bit I decided to start a basic implementation of unoriented multigraphs to learn more about it. Up until now, I've managed to deal with all the mistakes that came up but the last one I got is very strange. Basically, I'm trying to prove that if you have a walk (a sequence of vertices such that one vertice is linked to the following one by an edge) that goes from one vertice to another then you can find a path between them (basically the same as a walk, but which does not go through any vertice more than once). I am doing this constructively if that matters. I wrote several definitions and lemmas before proving this, and I am now writing this (please endure the awful code) : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">finite_graph.are_connected_path</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">v'</span> <span class=\"o\">:</span> <span class=\"n\">F.V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">F.simple</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">F.are_connected</span> <span class=\"n\">v</span> <span class=\"n\">v'</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">F.path</span><span class=\"o\">,</span> <span class=\"n\">p.start</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">p.end</span> <span class=\"bp\">=</span> <span class=\"n\">v'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span><span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">hp</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">p.to_walk</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">F.V</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hwl</span> <span class=\"o\">:=</span> <span class=\"n\">F.list_gives_walk_from_walk</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hwn</span> <span class=\"o\">:=</span> <span class=\"n\">w.nempty_l</span><span class=\"bp\">ᵥ</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hs1</span> <span class=\"o\">:=</span> <span class=\"n\">rmv_head</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span> <span class=\"n\">hwn</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">finite_graph.walk.start</span> <span class=\"n\">finite_graph.walk.end</span> <span class=\"n\">at</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hw</span> <span class=\"k\">with</span> <span class=\"n\">hw1</span> <span class=\"n\">hw2</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hw1</span><span class=\"o\">,</span><span class=\"bp\">←</span>  <span class=\"n\">hw2</span><span class=\"o\">],</span>\n    <span class=\"n\">clear</span> <span class=\"n\">hw1</span> <span class=\"n\">hw2</span> <span class=\"n\">v</span> <span class=\"n\">v'</span><span class=\"o\">,</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">swap</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"n\">l</span><span class=\"bp\">ᵥ</span> <span class=\"o\">:=</span> <span class=\"n\">rmv_unt</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span><span class=\"o\">,</span>\n      <span class=\"n\">lₑ</span> <span class=\"o\">:=</span> <span class=\"n\">F.get_list_edges</span> <span class=\"n\">hs</span> <span class=\"o\">(</span><span class=\"n\">rmv_unt</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F.rmv_unt_gives_walk</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span> <span class=\"n\">hwl</span><span class=\"o\">),</span>\n      <span class=\"n\">is_adj</span> <span class=\"o\">:=</span>\n      <span class=\"kd\">begin</span>\n        <span class=\"k\">have</span> <span class=\"n\">hu</span> <span class=\"o\">:=</span> <span class=\"n\">finite_graph.inc_prop_from_list_vertices</span> <span class=\"o\">(</span><span class=\"n\">rmv_unt</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">F.rmv_unt_gives_walk</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span> <span class=\"n\">hwl</span><span class=\"o\">)</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n        <span class=\"n\">cases</span> <span class=\"n\">hu</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span><span class=\"o\">,</span>\n      <span class=\"n\">vertex_unicity</span> <span class=\"o\">:=</span> <span class=\"n\">rmv_nodup</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span><span class=\"o\">,</span>\n      <span class=\"n\">is_open</span> <span class=\"o\">:=</span>\n      <span class=\"kd\">begin</span>\n        <span class=\"n\">unfold</span> <span class=\"n\">finite_graph.walk.closed</span> <span class=\"n\">finite_graph.path.start</span> <span class=\"n\">finite_graph.path.end</span><span class=\"o\">,</span>\n        <span class=\"n\">unfold</span> <span class=\"n\">finite_graph.walk.start</span> <span class=\"n\">finite_graph.walk.end</span><span class=\"o\">,</span>\n        <span class=\"n\">push_neg</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">nodup_head_eq_tail_length_1</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">rmv_nodup</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span> <span class=\"o\">},</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">finite_graph.path.start</span> <span class=\"n\">finite_graph.walk.start</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">rmv_head</span><span class=\"o\">,</span>\n      <span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This last refl gives me the following error :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"n\">w.l</span><span class=\"bp\">ᵥ.</span><span class=\"n\">head</span> <span class=\"bp\">=</span> <span class=\"n\">w.l</span><span class=\"bp\">ᵥ.</span><span class=\"n\">head</span>\n<span class=\"k\">with</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span>\n</code></pre></div>\n<p>which seems very weird to me. Does anyone know why this happens, and how I can solve it ? Here is a link to the two files that I use with all my definitions if it is needed : <a href=\"https://github.com/Junkyards3/lean_graphs\">https://github.com/Junkyards3/lean_graphs</a> . Thanks in advance !</p>",
        "id": 255450475,
        "sender_full_name": "Albert Laforet",
        "timestamp": 1632940458
    },
    {
        "content": "<p>Your git repo suggests you're not using <code>leanproject</code>, which means that your code doesn't specify which version of mathlib it needs. Can I suggest you run <code>leanproject new</code> in your project and commit the resulting <code>leanpkg.toml</code>?</p>",
        "id": 255451208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632940706
    },
    {
        "content": "<p>This also doesn't answer your question, but note that there are have been some previous discussions on Zulip about proving that two vertices connected by a walk are also connected by a path: <a href=\"#narrow/stream/252551-graph-theory/topic/Construct.20path.20from.20walk.3F/near/219041776\">https://leanprover.zulipchat.com/#narrow/stream/252551-graph-theory/topic/Construct.20path.20from.20walk.3F/near/219041776</a></p>\n<p>cc: <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span></p>",
        "id": 255452747,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1632941238
    },
    {
        "content": "<p>In zulip, we also try and get <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for all issues, as this makes everyone's jobs easier. However, I did toy with your code and it's as I suspected; there's some instance hidden there that's messing up with it</p>",
        "id": 255457947,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1632943112
    },
    {
        "content": "<p>in this case, there's  two different <code>[inhabited]</code> instances, so you can try <code>convert rfl</code> to see where you differ</p>",
        "id": 255457985,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1632943133
    },
    {
        "content": "<p>every time you see <code>invalid apply tactic</code> and a pattern that look like it matches, you should start looking at instances + implicits in my experience</p>",
        "id": 255458299,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1632943256
    },
    {
        "content": "<p>It was indeed the problem, I didn't know that different instances led to different data (I thought that once instances existed, they were \"the same\", as in, their only use is existing). I guess I should read a bit more on how instances actually work. Thanks !<br>\nAlso, I do use leanproject and have leanpkg.toml. I just uploaded my files to github really fast without using the actually good machinery... I should learn to use it</p>",
        "id": 255459968,
        "sender_full_name": "Albert Laforet",
        "timestamp": 1632943872
    },
    {
        "content": "<p><code>Prop</code> instances are like that. Anything that lives in <code>Type*</code> has data that has to be compared :) in <code>inhabited</code>'s case, it actually defines a \"default\" element, so it's certainly not true that they're always equal!</p>",
        "id": 255460353,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1632944021
    },
    {
        "content": "<p>In case you want to take a look, here's an un-merged branch that deals with walks and paths for simple graphs -- the approach would be essentially the same for multigraphs.  This in particular is the function that converts walks to paths: <a href=\"https://github.com/leanprover-community/mathlib/blob/affa4bf4bdcd51ee2298d0aff9c7ca74a6a97802/src/combinatorics/simple_graph/connectivity.lean#L813\">https://github.com/leanprover-community/mathlib/blob/affa4bf4bdcd51ee2298d0aff9c7ca74a6a97802/src/combinatorics/simple_graph/connectivity.lean#L813</a></p>\n<p>It uses a custom type for walks rather than lists, but the hope is that there are enough definitions and lemmas to connect the theory up to <code>list</code> when convenient.</p>",
        "id": 255465034,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1632945828
    }
]
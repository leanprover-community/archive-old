[
    {
        "content": "<p>I want to be able to use a proposition to show that a match case is impossible.<br>\nSomething like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">non_empty_list</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"o\">[]}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">extract_first</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">non_empty_list</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">l.val</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- prove impossible</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Anyone know how to do this?</p>",
        "id": 261880027,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637204020
    },
    {
        "content": "<p>If you match on <code>l.val</code>, Lean won't specialize <code>h.property</code> to the different cases.</p>\n<p>You can match on <code>l</code> itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">extract_first</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">non_empty_list</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨[],</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm using the angle bracket notation, which can be used for any inductive type with only one constructor (like <code>subtype</code>).</p>",
        "id": 261880227,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637204227
    },
    {
        "content": "<p>This is also a place where you can merge the <code>match</code> into the <code>def</code> syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">extract_first</span> <span class=\"o\">:</span> <span class=\"n\">non_empty_list</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨[],</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 261880318,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637204306
    },
    {
        "content": "<p>(This actually has some consequences to how Lean generates the \"equation lemmas\".  When you fold in the <code>match</code> syntax, you get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">extract_first.equations._eqn_1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">list.nil</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span><span class=\"o\">),</span> <span class=\"n\">extract_first</span> <span class=\"o\">⟨</span><span class=\"n\">list.nil</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">_.elim</span>\n<span class=\"n\">extract_first.equations._eqn_2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">_x</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span><span class=\"o\">),</span> <span class=\"n\">extract_first</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">_x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>but if you keep the <code>match</code> separate you get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">extract_first.equations._eqn_1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">non_empty_list</span><span class=\"o\">),</span> <span class=\"n\">extract_first</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">extract_first._match_1</span> <span class=\"n\">l</span>\n<span class=\"n\">extract_first._match_1.equations._eqn_1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">list.nil</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span><span class=\"o\">),</span> <span class=\"n\">extract_first._match_1</span> <span class=\"o\">⟨</span><span class=\"n\">list.nil</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">_.elim</span>\n<span class=\"n\">extract_first._match_1.equations._eqn_2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">_x</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span><span class=\"o\">),</span> <span class=\"n\">extract_first._match_1</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">_x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>As I understand it, the difference is in what happens when you unfold definitions in a proof.  The second one will unfold into <code>extract_first._match_1</code>, but if you unfold this, too, they're otherwise identical.)</p>",
        "id": 261880723,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637204689
    }
]
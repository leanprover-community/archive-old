[
    {
        "content": "<p>Hi! I'm going through <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> 's \"formalizing mathematics\" (wishing I were again an undergraduate), and stumbled already at week 1, part B. There's a lemma<br>\n<code>lemma union_subset_union (hWX : W ⊆ X) (hYZ : Y ⊆ Z) : W ∪ Y ⊆ X ∪ Z := ...</code> which I could do, and the next exercise is <code>lemma union_subset_union_left (hXY : X ⊆ Y) : X ∪ Z ⊆ Y ∪ Z := ...</code>. Now I would like to say it's a special case of union_subset_union; so the proof should be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">union_subset_union</span> <span class=\"n\">hXY</span> <span class=\"o\">(</span><span class=\"n\">subset_refl</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Unfortunately none of the command I tried (rw, exact, apply, various combinations and variants) seem to work; and the homework solutions give a direct proof rather than apply the previous lemma. I thought that application of previous lemmas was done by rewriting, but obviously I'm missing something.</p>\n<p>Meta-question: where do I find the answer to such questions without harassing everyone on Zulip? :)</p>",
        "id": 230560854,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1615917209
    },
    {
        "content": "<p><code>rw</code> is for applying lemmas with an <code>=</code> or an <code>iff</code> in their statement. Yours is neither, but the goal state of the lemma you want to apply is exactly the same as the one you're aiming for; so you want the <code>apply</code> tactic.</p>",
        "id": 230561088,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615917289
    },
    {
        "content": "<p>But since you've worked out the arguments already, you can use <code>exact</code> instead</p>",
        "id": 230561118,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615917302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> wow, thanks for the quick reply! <code>exact</code> is indeed something I tried; but <code>exact union_subset_union hXY (subset_refl Z)</code> causes the error message <code>hXY has type X \\subset Y : Prop but is expected to have type Type : Type1</code></p>",
        "id": 230561600,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1615917460
    },
    {
        "content": "<p>here's how I like to handle this sort of thing. Don't write the <code>exact</code> right away. Start by writing <code>have key := union_subset_union,</code>. Then you can see what <code>union_subset_union</code> expects next. You can then add in the arguments one at a time. Once <code>key</code> looks like your goal, you can switch to an exact statement.</p>",
        "id": 230562873,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1615917844
    },
    {
        "content": "<p>(For ease of reference, I guess the worksheet in question is here: <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_1/Part_B_sets.lean\">https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_1/Part_B_sets.lean</a> )</p>",
        "id": 230562901,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1615917856
    },
    {
        "content": "<p>Indeed, because there are round parentheses on <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics/blob/master/src/week_1/Part_B_sets.lean#L5\">line 5</a>, <code>union_subset_union</code> will require several additional arguments before <code>hXY</code>. I think things should work if you insert a sufficient number of underscores before <code>hXY</code> (the underscores tell Lean to try to infer the arguments automatically).</p>",
        "id": 230563113,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1615917948
    },
    {
        "content": "<p>Here's a little animation of me going through this proof using <code>refine</code> (similar to the suggestion of using <code>have</code> that Thomas mentioned above)<br>\n<a href=\"/user_uploads/3121/wNL8VlwHAWkb_GjtGSa9L8UU/out.gif\">out.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wNL8VlwHAWkb_GjtGSa9L8UU/out.gif\" title=\"out.gif\"><img src=\"/user_uploads/3121/wNL8VlwHAWkb_GjtGSa9L8UU/out.gif\"></a></div>",
        "id": 230564897,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1615918605
    },
    {
        "content": "<p>Fantastic! For posterity, if one wants to stick with \"exact\", the answer is <code>exact union_subset_union Ω Y Z Z X hXY (subset_refl Ω Z),</code></p>",
        "id": 230582163,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1615925263
    },
    {
        "content": "<p>Usually a terminal <code>refine (something)</code> can be replaced with <code>exact (something)</code>, so I suspect <code>exact union_subset_union _ _ _ _ _ hXY (subset_refl _ _),</code> works just as well.</p>",
        "id": 230583330,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1615925670
    },
    {
        "content": "<p>Okay, so I finished week 2 of the @Kevin Buzzard's  course, which introduces groups and subgroups. I'm lost with syntax questions: for context Kevin defines</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">has_one</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">has_inv</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"c\">/-</span><span class=\"cm\"> group axioms -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> and membership axioms/proofs for one mul, inv -/</span>\n</code></pre></div>\n<p>I tried to add a few lemmas, but can't even get their statements right, and it seems that I'm confused between which things are sets, types, and properties. For example, how should one implement the follewing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- for every H : subgroup G, H.carrier is a group by itself</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup_is_group</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"bp\">↑</span><span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I seemingly can construct some examples of subgroups, say the trivial subgroup and full group, but I don't see how they can be useful: I would have expected I could define a lemma <code>lemma trivial_is_subgroup {group G} : ({(1:G)} : subgroup G)</code>, but the closest I can do is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- for every group G, {1} is a subgroup</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">trivial_subgroup</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">)},</span> <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- for every group G, G is a subgroup</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">whole_group</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>so if at some moment in another proof I have a hypothesis <code>h : K = {1}</code>, how will I conclude <code>⊢ K : subgroup G</code>?</p>",
        "id": 231207952,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1616323123
    },
    {
        "content": "<p>You can never conclude <code>K : subgroup G</code> from <code>h : K = {1}</code>, because these objects don't have the same type: when you write <code>K = {1}</code>, the type of <code>K</code> is <code>set G</code>, not <code>subgroup G</code>. What you can hope to do is promote <code>K</code> to a subgroup, i.e., claim that there is <code>K' : subgroup G</code> such that the carrier of <code>K'</code> is <code>K</code> (which can be expressed with coercions as <code>(K' : set G) = K</code>).</p>",
        "id": 231208946,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616324326
    },
    {
        "content": "<p>Your \"lemma\"s aren't lemmas because they're definitions. I agree that trying to work out the difference between types and terms and sets and etc is confusing, somehow the point of that class was just to show people what abstract mathematics looked like in lean.</p>",
        "id": 231209057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616324409
    },
    {
        "content": "<p>In practice, however, this is not how things are done: usually, it is much more efficient to work directly in <code>subgroup G</code> (for which we have a lot of constructors, like: the kernel of a group morphism is by definition a subgroup of <code>G</code>, not a subset of <code>G</code>; the product of two subgroups is a subgroup of the product group, and so on).</p>",
        "id": 231209066,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616324420
    },
    {
        "content": "<p>Yes, the problem with using my home-made subgroup is that you then have to make all the machinery yourself. Of course this can be quite good fun :-) but one thing you've just realised you've needed is an extensionality lemma -- two subgroups are equal iff they have the same underlying subset.</p>",
        "id": 231209175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616324548
    },
    {
        "content": "<p>Great, I understand better why my attempts at the last two lemmas are useless. About the first: if I try</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subgroup_is_group</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I'm told that lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_mul</span> <span class=\"bp\">↥</span><span class=\"n\">H</span>\n</code></pre></div>\n<p>but my understanding is that if I can get this to work and then <code>def commutative (group G) := ∀ x y, x*y = y*x</code> then I should be able to prove <code>lemma sub_com (H : subgroup G) (C : commutative G) -&gt; commutative (subgroup_is_group H)</code>.</p>\n<p>Can someone help me walk baby-steps along this? Thanks!</p>",
        "id": 231210616,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1616326272
    },
    {
        "content": "<p>Given the last error message you got, I would go to the empty line above <code>lemma subgroup_is_group</code> and start typing <code>instance (H : subgroup G) : has_mul H := ...</code></p>",
        "id": 231210957,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616326662
    },
    {
        "content": "<p>because you need to tell Lean what multiplication you intend to use on <code>H</code>.</p>",
        "id": 231211012,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616326699
    },
    {
        "content": "<p>I will write up a brief framework now which will show you how to do the things you want to do.</p>",
        "id": 231211257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616327052
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- all within namespace `xena.subgroup`</span>\n\n<span class=\"c1\">-- treat a subgroup as a type in its own right</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">//</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span><span class=\"o\">}⟩</span>\n\n<span class=\"c1\">-- key things to know for the proofs below: a term of type `↥H` is a *pair*</span>\n<span class=\"c1\">-- consisting of a term `a : G` and a proof `ha : a ∈ H`.</span>\n<span class=\"c1\">-- If `x : ↥H` then you can do `cases x with a ha`</span>\n<span class=\"c1\">-- to get to the elements of the pair. If you don't want to take</span>\n<span class=\"c1\">-- `x` apart then `x.1` is the term of type `G` and `x.2` is the proof it's in `H`.</span>\n<span class=\"c1\">-- if you have `x y : ↥H` and want to reduce a proof of `x = y`</span>\n<span class=\"c1\">-- to a proof that the corresponding elements of `G` are equal</span>\n<span class=\"c1\">-- then you can do `cases x with a ha, cases y with b hb, ext, dsimp`</span>\n<span class=\"c1\">-- Also, because Lean has groups already, you will run into the</span>\n<span class=\"c1\">-- problem that `rw mul_assoc` will be ambiguous :-(</span>\n<span class=\"c1\">-- `rw xena.group.mul_assoc`. It is extremely difficult to fix</span>\n<span class=\"c1\">-- this without just using different names to the standard Lean</span>\n<span class=\"c1\">-- names, which is somehow not a good idea :-(</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subgroup_is_group</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"bp\">↥</span><span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">a.1</span> <span class=\"bp\">*</span> <span class=\"n\">b.1</span><span class=\"o\">,</span> <span class=\"n\">H.mul_mem</span> <span class=\"n\">a.2</span> <span class=\"n\">b.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">H.one_mem</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">a.1</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">H.inv_mem</span> <span class=\"n\">a.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">To do this next one you need to know the basic API for sets. For</span>\n<span class=\"cm\">example</span>\n\n<span class=\"cm\">set.mem_singleton a : a ∈ {a}</span>\n<span class=\"cm\">set.mem_singleton_iff : a ∈ {b} ↔ a = b</span>\n\n<span class=\"cm\">You might want to just `open set` so that you don't have</span>\n<span class=\"cm\">to write \"set.\" everywhere</span>\n\n<span class=\"cm\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">)},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">To do this one, you need to know the basic API for `true`,</span>\n<span class=\"cm\">which is that you can prove it using the `trivial` tactic.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 231212498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616328489
    },
    {
        "content": "<p>The weird type-theoretic thing which is new here is that the way to make <code>G</code> into a group in Lean is <code>(G : Type) [h : group G]</code>. We don't normally name <code>h</code> because a system called the type class inference system looks after <code>h</code> for us. <code>h</code> is all the data associated with the group structure on <code>G</code>, i.e. the multiplication, the proof that it is associative etc. Here <code>G</code> is a type and <code>h</code> is a term. The Lean model for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">a\\in G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is <code>a : G</code> -- the terms of the type <code>G</code>.</p>\n<p>Subgroups however are not like this. If <code>H : subgroup G</code> then <code>H</code> is a <em>term</em> not a type, so <code>h : H</code> does not even make sense. the first thing we need to do is to tell Lean how to make terms of type <code>subgroup G</code> into types in their own right -- this is the \"coercion to Sort\" (Sort means \"Type or Prop\", the two universes in my course). Once we have this, one has to learn to control the fact that terms of type <code>↥H</code> (the \"coerced H\") are <em>pairs</em> consisting of an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and a proof that it's in the subgroup <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span>. </p>\n<p>I did this stuff in week 2 because I thought it would be good to get onto something which was \"recognisably mathematics\" very early on, however I realised when I did it that there was very limited scope for further exploration because I had not talked about several other things. I'm currently reworking all the material and one thing I discovered during the course was that I really wished I had done stuff with sets a lot earlier, so next year when I teach this I will probably do a bunch of set stuff before I start on groups.</p>\n<p>Let me know if you have any more questions Laurent!</p>",
        "id": 231212840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616328872
    },
    {
        "content": "<p>Also, let me point out that there is some flexibility in the design space. Instead of defining a type <code>subgroup G</code>, we could work with subsets of <code>G</code> and use a predicate <code>is_subgroup K</code> (where <code>K : set G</code> and <code>is_subgroup K</code> asserts that the subset <code>K</code> contains <code>1</code> and is stable under multiplication and inversion). The first approach, in which <code>K : subgroup G</code> is more than a subset, is called the <em>bundled</em> approach, while the second one, in which ones uses subsets and asserts something on them, is called the unbundled approach. In mathlib, we started with the unbundled approach (which corresponds more closely to what you were trying to do, Laurent), but after a lot of experimentations and refactors we came to the conclusion that the bundled approach is more efficient, so that's the way things are now set up.</p>",
        "id": 231214616,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1616331070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  thanks, that helps a lot -- though I can't try your code directly: <code>instance : has_coe_to_sort (subgroup G) := ⟨_, λ H, {g : G // g ∈ H}⟩\ninstance subgroup_is_group (H : subgroup G) : group ↑H := {...}</code> produces at the \"<code>↑H</code>\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_lift_t</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>I feared it was an interference of the previous <code>instance : has_coe (subgroup G) (set G) := ⟨λ H, H.carrier⟩</code> but commenting that line out doesn't help. Trying random variations of <code>instance : has_lift_t (subgroup G) := sorry</code> (I feel like a monkey at a typewriter) doesn't work either.</p>\n<p>Do I understand correctly that the original coercion, in your work2 file, forced a subgroup into a subset (in which \\in tests membership), while the new one forces a subgroup into a group (in which : tests membership)? Then I guess both are incompatible. I also guess that it's a good idea to define as many \"coercions\" as possible, in that lean/mathlib will silently apply them in many useful cases.</p>",
        "id": 231230599,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1616349143
    },
    {
        "content": "<p>I think you have the wrong up arrow!</p>",
        "id": 231230732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616349265
    },
    {
        "content": "<p>You want <code>\\u-|</code> not <code>\\u</code></p>",
        "id": 231230776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616349293
    },
    {
        "content": "<p>You want <code>\\u-|</code> not <code>\\u</code></p>",
        "id": 231231065,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616349599
    },
    {
        "content": "<p>You want <code>\\u-|</code> not <code>\\u</code></p>",
        "id": 231231120,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616349613
    },
    {
        "content": "<p>Yes, there are unfortunately three kinds of coercions (things that mathematicians would just regard as invisible) -- you can coerce a term to another term (e.g. <code>H : subgroup G</code> into <code>H : set G</code>), a term into a type (e.g. <code>H : subgroup G</code> into <code>\\u-| H : Type</code>) or a term into a function (e.g. we use this for group homomorphisms -- there is a type <code>monoid_hom G H</code> and if <code>f : monoid_hom G H</code> then <code>\\u= f : G -&gt; H</code>).</p>",
        "id": 231232107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616350646
    },
    {
        "content": "<p>I feel I'm making good progress... I could finish all of Kevin's goals. Here's now what I tried -- and got stuck at:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_commutative</span> <span class=\"n\">K</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_commutative_def</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative</span> <span class=\"n\">K</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">K.comm</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_of_com</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative</span> <span class=\"bp\">↥</span><span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_commutative_def</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_commutative_def</span> <span class=\"n\">at</span> <span class=\"n\">h0</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h0</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>There is an error at the <code>dsimp</code> which cannot progress (while it went fine in the <code>subgroup_is_group</code> example). Comments and advice on the style are most welcome (in particular, does one really have to define a class and a lemma?)</p>",
        "id": 231241032,
        "sender_full_name": "Laurent Bartholdi",
        "timestamp": 1616360709
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 231242561,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616362388
    },
    {
        "content": "<p>This presumably isn't matching your definitions, but this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_commutative'</span> <span class=\"n\">K</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_commutative_def</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative'</span> <span class=\"n\">K</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">K.comm</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_of_com</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative'</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative'</span> <span class=\"bp\">↥</span><span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_commutative_def</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_commutative_def</span> <span class=\"n\">at</span> <span class=\"n\">h0</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h0</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231242699,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616362526
    },
    {
        "content": "<p><code>dsimp</code> is failing because it can't simplify what it sees, namely <code>↑(x * y) = ↑(y * x)</code>. This doesn't mean it can't be simplified, it just means that not enough things have been tagged with <code>simp</code> and proved with <code>refl</code>. Here's a proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sub_of_com</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative</span> <span class=\"bp\">↥</span><span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_commutative_def</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_commutative_def</span> <span class=\"n\">at</span> <span class=\"n\">h0</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">y.1</span> <span class=\"bp\">=</span> <span class=\"n\">y.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h0</span> <span class=\"n\">x.1</span> <span class=\"n\">y.1</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The <code>change</code> tactic will replace any goal by a definitionally equal goal. Note however that the <code>exact</code> tactic works up to definitional equality, so you can just delete the <code>change</code> line and the proof still compiles.</p>",
        "id": 231245021,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616365213
    },
    {
        "content": "<p>As for style, this is tricky. You could make an <code>is_commutative</code> class on top of <code>group</code>, or you could just make a new class <code>comm_group</code> extending <code>group</code>. But you're being inconsistent with your lemma -- if <code>is_commutative</code> is to be a class then you should write <code>[is_commutative G]</code> instead of <code>(h0 : is_commutative G)</code> and now it's a pain to access <code>h0</code>. The way one would usually do this is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_commutative</span> <span class=\"n\">K</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_commutative_def</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">h.comm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_of_com</span> <span class=\"o\">[</span><span class=\"n\">is_commutative</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_commutative</span> <span class=\"bp\">↥</span><span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h0</span> <span class=\"o\">:=</span> <span class=\"n\">is_commutative_def</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h0</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Let me stress that even for a professional mathematician, writing definitions in Lean is hard. In my course I supplied every definition and just let the students fill in the theorems. Writing definitions means you have to deal with the idea of implementation issues -- e.g. there are 11 definitions of a discrete valuation ring on Wikipedia, but Lean only wants one, so there is a decision to be made here. Other issues such as structure or class, type or term etc etc just make matters worse. There are plenty of things I still don't understand here myself, for example I know that in mathlib they don't do commutativity the way you're suggesting -- they make an entirely new class <code>comm_group</code> extending <code>group</code> -- but I would not be able to tell you why.</p>",
        "id": 231245474,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616365697
    },
    {
        "content": "<p>In addition, there are various relations like <code>commute x y</code> that can state that some specific elements commute for some op, even if in general they do not. So stating that elements in a normal subgroup commute might use that <code>commute</code>.</p>",
        "id": 231245958,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616366294
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/commute\">docs#commute</a></p>",
        "id": 231245967,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616366299
    },
    {
        "content": "<blockquote>\n<p>you should write [is_commutative G] instead of (h0 : is_commutative G) and now it's a pain to access h0.</p>\n</blockquote>\n<p>One would normally write <code>is_commutative.comm</code> to access h0 (not <code>h0.comm</code>)</p>",
        "id": 231248648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616369553
    }
]
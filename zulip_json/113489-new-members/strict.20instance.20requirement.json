[
    {
        "content": "<p>I'm trying to use <a href=\"https://leanprover-community.github.io/mathlib_docs/data/finset/lattice.html#finset.exists_mem_eq_sup\">finset.exists_mem_eq_sup</a> when <code>β</code> is nat but it wants a <code>[complete_linear_order β]</code>. And I'm guessing nat isn't a <code>complete_linear_order</code>? But when I rewrite the theorem with nat and without requiring <code>[complete_linear_order ℕ]</code>, with the exact same proof, then the theorem compiles. I'm also finding it hard to figure out which instances are actually being used in the proof.</p>\n<p>Am I missing something or are the requirements on the theorem too strict?</p>",
        "id": 231697898,
        "sender_full_name": "Pontus Sundqvist",
        "timestamp": 1616615464
    },
    {
        "content": "<p>you're missing a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> so we can all figure out the details of what you're talking about.</p>",
        "id": 231698082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616615544
    },
    {
        "content": "<p>I agree that <code>nat</code> isn't a complete linear order, because an arbitrary collection of naturals might not have a (finite) sup.</p>",
        "id": 231698249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616615628
    },
    {
        "content": "<p>PS you can just do <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.exists_mem_eq_sup\">docs#finset.exists_mem_eq_sup</a> to save you having to cut and paste the full URL.</p>",
        "id": 231698415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616615693
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.lattice</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">order_dual</span> <span class=\"n\">multiset</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u_1</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_mem_eq_sup'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">s.sup</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.induction_on</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">hxm</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">not_nonempty_empty</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">sup_insert</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">xs.sup</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_insert_self</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_left.mpr</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hxs</span> <span class=\"o\">:</span> <span class=\"n\">xs.nonempty</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ham</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">hxs</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">ham</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_right</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">le_of_not_le</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">not_nonempty_iff_eq_empty.mp</span> <span class=\"n\">hxs</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_singleton_self</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n</code></pre></div>\n<p>I've managed to reproduce.</p>",
        "id": 231698860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616615877
    },
    {
        "content": "<p>Thanks. You're right, I should have posted that to begin with.</p>",
        "id": 231699408,
        "sender_full_name": "Pontus Sundqvist",
        "timestamp": 1616616092
    },
    {
        "content": "<p>It seems to me that the proof for general beta needs <code>semilattice_sup_bot</code> and <code>linear_order</code>; both of these extend <code>partial_order</code> unfortunately, so it's difficult (for me) to put both structures on a type at once in a compatible way.</p>",
        "id": 231699439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616616105
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n<span class=\"kd\">class</span> <span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">linear_order</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_mem_eq_sup'</span> <span class=\"o\">[</span><span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">s.sup</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">finset.induction_on</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">hxm</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">not_nonempty_empty</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">sup_insert</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">xs.sup</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_insert_self</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_left.mpr</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hxs</span> <span class=\"o\">:</span> <span class=\"n\">xs.nonempty</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ham</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">hxs</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">ham</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_right</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">le_of_not_le</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">not_nonempty_iff_eq_empty.mp</span> <span class=\"n\">hxs</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_singleton_self</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231699751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616616233
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">),</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">linear_order</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 231700373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616616499
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">complete_linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">),</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span> <span class=\"c1\">-- fails</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch at field 'bot_le'</span>\n<span class=\"cm\">  semilattice_sup_bot.bot_le</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ∀ (a : β),</span>\n<span class=\"cm\">    @has_le.le β</span>\n<span class=\"cm\">      (@preorder.to_has_le β</span>\n<span class=\"cm\">         (@partial_order.to_preorder β</span>\n<span class=\"cm\">            (@partial_order.mk β (@semilattice_sup_bot.le β (show semilattice_sup_bot β, from ?m_1))</span>\n<span class=\"cm\">               (@semilattice_sup_bot.lt β (show semilattice_sup_bot β, from ?m_1))</span>\n<span class=\"cm\">               _</span>\n<span class=\"cm\">               _</span>\n<span class=\"cm\">               _</span>\n<span class=\"cm\">               _)))</span>\n<span class=\"cm\">      (@has_bot.bot β (@has_bot.mk β (@semilattice_sup_bot.bot β (show semilattice_sup_bot β, from ?m_1))))</span>\n<span class=\"cm\">      a</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ∀ (a : β),</span>\n<span class=\"cm\">    @has_le.le β</span>\n<span class=\"cm\">      (@preorder.to_has_le β</span>\n<span class=\"cm\">         (@partial_order.to_preorder β</span>\n<span class=\"cm\">            (@partial_order.mk β</span>\n<span class=\"cm\">               (@linear_order.le β (show linear_order β, from @complete_linear_order.to_linear_order β _inst_1))</span>\n<span class=\"cm\">               (@linear_order.lt β (show linear_order β, from @complete_linear_order.to_linear_order β _inst_1))</span>\n<span class=\"cm\">               _</span>\n<span class=\"cm\">               _</span>\n<span class=\"cm\">               _</span>\n<span class=\"cm\">               _)))</span>\n<span class=\"cm\">      (@has_bot.bot β (@has_bot.mk β (@semilattice_sup_bot.bot β (show semilattice_sup_bot β, from ?m_1))))</span>\n<span class=\"cm\">      a</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>aargh</p>",
        "id": 231700574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616616594
    },
    {
        "content": "<p>Got it working:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.lattice</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">order_dual</span> <span class=\"n\">multiset</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u_1</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n<span class=\"kd\">class</span> <span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">linear_order</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">),</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">linear_order</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">complete_linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">instance</span> <span class=\"n\">bar</span> <span class=\"o\">[</span><span class=\"n\">complete_linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">baz</span> <span class=\"o\">[</span><span class=\"n\">complete_linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">foo</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">bar</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_mem_eq_sup'</span> <span class=\"o\">[</span><span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">s.sup</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">etc</span> <span class=\"n\">etc</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n</code></pre></div>",
        "id": 231701034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616616795
    },
    {
        "content": "<p>so yes you're right, one can get away with weaker typeclass assumptions, however it seems to me that it might involve making a new typeclass.</p>",
        "id": 231701176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616616860
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">baz</span> <span class=\"o\">[</span><span class=\"n\">complete_linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot_linear_order_mashup</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Got it working -- dunno why I had that weird error (which I blamed on a diamond but which might not be the case) earlier.</p>",
        "id": 231701565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616617054
    },
    {
        "content": "<p>Would the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.exists_mem_eq_sup\">docs#finset.exists_mem_eq_sup</a> lemma have worked for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/conditionally_complete_linear_order\">docs#conditionally_complete_linear_order</a>?</p>",
        "id": 231719460,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616624740
    },
    {
        "content": "<p>I wrote that lemma to try and prove to <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> that some graph theory degree stuff was overkill and that there was already enough api about finsets, but concluded that actually the API was too sparse to be useful.</p>",
        "id": 231719671,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616624854
    },
    {
        "content": "<p>Ah, I think I remember getting stuck because <code>order.conditionally_complete_lattice</code> can't be imported in <code>data.finset.lattice</code>. And also that typeclass doesn't work anyway.</p>",
        "id": 231720530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616625353
    },
    {
        "content": "<p>Note that every <code>linear_order</code> is already a lattice, so this mashup is just <code>linear_order_with_bot</code></p>",
        "id": 231721493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616625962
    },
    {
        "content": "<p>In other words a linear order where all finite sups exist. Examples are nat and nnreal</p>",
        "id": 231760751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616659744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247136\">@Pontus Sundqvist</span> I think this lemma should work for <code>nat</code> now.</p>",
        "id": 234459690,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1618388375
    }
]
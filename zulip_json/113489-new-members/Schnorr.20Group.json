[
    {
        "content": "<p>Hi everyone, I am trying to prove a simple theorem about Schnorr  group ( <a href=\"https://en.wikipedia.org/wiki/Schnorr_group\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Schnorr_group\">https://en.wikipedia.org/wiki/Schnorr_group</a> ), but getting some typeclass synthesis error for hypothesis Hh1 Hh2 Hg.  </p>\n<div class=\"codehilite\"><pre><span></span>import data.zmod.basic data.nat.prime\n  data.zmod.quadratic_reciprocity\n\nnamespace ElGamal\n\n/-\nA Schnorr group is a large prime-order subgroup of ℤ∗𝑝,\nthe multiplicative group of integers modulo 𝑝.\nTo generate such a group, we find 𝑝=𝑞𝑟+1 such that 𝑝 and 𝑞\nare prime. Then, we choose any ℎ\nin the range 1&lt;ℎ&lt;𝑝 such that ℎ^r ≠ 1 (mod𝑝)\nThe value 𝑔=ℎ^𝑟(mod𝑝) is a generator of a subgroup ℤ∗𝑝 of order 𝑞.\nBy Fermat&#39;s little theorem\ng^q = h^(rq) = h^(p-1) = 1 (mod p)\n-/\n\nvariables\n  (p : ℕ) (q : ℕ) (r : ℕ+)\n  (Hp : nat.prime p)\n  (Hq : nat.prime q)\n  (Hdiv : p = q * r + 1)\n  (h : zmodp p Hp)\n  (Hh₁ : 1 &lt; h &lt; p)\n  (Hh₂ : h^r ≠ 1)\n  (g : zmodp p Hp) /- generator of a subgroup of ℤ⋆p of order q -/\n  (Hg : g = h^r)\n\ninclude p q r Hp Hq Hdiv h Hh₁ Hh₂ Hg\ntheorem generate_proof : g ^ q = 1 :=\nbegin\n  /-\n   rewrite Hg,\n   associativity would turn the goal\n   (h ^ r) ^ q = 1  into h ^ (r * q).\n   r * q = p - 1.\n   Use Fermat little theorem from\n   fermat little to prove it -/\n\nend\n\n\n\n\n\n\n\nend ElGamal\n</pre></div>",
        "id": 191378165,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584848425
    },
    {
        "content": "<p>The typeclass is <code>has_lt (zmodp p Hp)</code> so lean is telling you it doesn't know what <code>&lt;</code> means for <code>zmodp</code> which makes sense, there is no nice notion of <code>lt</code>on integers modulo a prime .</p>",
        "id": 191380564,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584853174
    },
    {
        "content": "<p>The sentiment you are trying to express with <code>Hh1</code> is really just that the residue class <code>h</code> is not 0.</p>",
        "id": 191380615,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584853206
    },
    {
        "content": "<p>The second one is <code>has_pow (zmodp p Hp) ℕ+</code>which is telling you that lean can't take a positive natural power of an element of this type, you could argue that this is an oversight. But the easiest fix is to take <code>h^r.val</code> instead.</p>",
        "id": 191380630,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584853300
    },
    {
        "content": "<p>You could also take <code>r</code> of type nat instead. That might be less work in the long run.</p>",
        "id": 191380737,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584853446
    },
    {
        "content": "<p>Spoilers below:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n  <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">quadratic_reciprocity</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ElGamal</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">A Schnorr group is a large prime-order subgroup of ℤ∗𝑝,</span>\n<span class=\"cm\">the multiplicative group of integers modulo 𝑝.</span>\n<span class=\"cm\">To generate such a group, we find 𝑝=𝑞𝑟+1 such that 𝑝 and 𝑞</span>\n<span class=\"cm\">are prime. Then, we choose any ℎ</span>\n<span class=\"cm\">in the range 1&lt;ℎ&lt;𝑝 such that ℎ^r ≠ 1 (mod𝑝)</span>\n<span class=\"cm\">The value 𝑔=ℎ^𝑟(mod𝑝) is a generator of a subgroup ℤ∗𝑝 of order 𝑞.</span>\n<span class=\"cm\">By Fermat&#39;s little theorem</span>\n<span class=\"cm\">g^q = h^(rq) = h^(p-1) = 1 (mod p)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">variables</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hp</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hq</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hdiv</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hh₁</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hh₂</span> <span class=\"o\">:</span> <span class=\"n\">h</span><span class=\"err\">^</span><span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> generator of a subgroup of ℤ⋆p of order q -/</span>\n  <span class=\"o\">(</span><span class=\"n\">Hg</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">Hh₁</span>\n<span class=\"n\">include</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">Hp</span> <span class=\"n\">Hq</span> <span class=\"n\">Hdiv</span> <span class=\"n\">h</span> <span class=\"n\">Hh₁</span> <span class=\"n\">Hh₂</span> <span class=\"n\">Hg</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">generate_proof</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">^</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n   <span class=\"n\">rewrite</span> <span class=\"n\">Hg</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n   <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pred_eq_of_eq_succ</span> <span class=\"n\">Hdiv</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n   <span class=\"n\">exact</span> <span class=\"n\">zmodp</span><span class=\"bp\">.</span><span class=\"n\">fermat_little</span> <span class=\"n\">Hp</span> <span class=\"n\">Hh₁</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n\n\n\n\n\n\n<span class=\"kn\">end</span> <span class=\"n\">ElGamal</span>\n</pre></div>",
        "id": 191380806,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584853579
    },
    {
        "content": "<p>Thanks for the answer <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> . Now, I am wondering about the error. <br>\nIf I comment the proof 'generator_proof', then the error goes way. </p>\n<div class=\"codehilite\"><pre><span></span>variables\n  (p : ℕ) (q : ℕ) (r : ℕ)\n  (Hr : 2 ≤ r)\n  (Hp : nat.prime p)\n  (Hq : nat.prime q)\n  (Hdiv : p = q * r + 1)\n  (h : zmodp p Hp)\n  (Hh₁ : h ≠ 0)\n  (Hh₂ : h^r ≠ 1)\n  (g : zmodp p Hp) /- generator of a subgroup of ℤ⋆p of order q -/\n  (Hg : g = h^r)\n\n\ninclude Hg\ntheorem generator_proof : g ^ q = 1 :=\nbegin\n  rw [Hg, &lt;- pow_mul, mul_comm],\n  have Ht : p - 1 = q * r := nat.pred_eq_of_eq_succ Hdiv,\n  rw &lt;- Ht, exact zmodp.fermat_little Hp Hh₁\nend\n\nvariables\n  (prikey : zmodp q Hq) /- private key -/\n  (pubkey : zmodp p Hp) /- public key -/\n  (Hrel : pubkey = g^prikey.val)\n\ndef elgamal_enc (m : zmodp p Hp) (r : zmodp q Hq) :=\n  (g^r.val, g^m.val * h^r.val)\n\nkernel failed to type check declaration &#39;elgamal_enc&#39; this is usually due to a buggy tactic or a bug in the builtin elaborator\nelaborated type:\n  Π (p q : ℕ) (Hp : nat.prime p) (Hq : nat.prime q) (h g : zmodp p Hp),\n    g = h ^ r → ℕ → zmodp p Hp → zmodp q Hq → zmodp p Hp × zmodp p Hp\nelaborated value:\n  λ (p q : ℕ) (Hp : nat.prime p) (Hq : nat.prime q) (h g : zmodp p Hp) (Hg : g = h ^ r) (r : ℕ) (m : zmodp p Hp)\n  (r : zmodp q Hq), (g ^ r.val, g ^ m.val * h ^ r.val)\nnested exception message:\nfailed to add declaration to environment, it contains local constants\n</pre></div>",
        "id": 191384045,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584860708
    },
    {
        "content": "<p>This goes away for me if I wrap the previous declaration and preceding <code>include</code> in <code>section ... end</code> it seems lean doesn't like including these extra hypotheses.</p>",
        "id": 191384381,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584861276
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n  <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">quadratic_reciprocity</span>\n\n<span class=\"kn\">variables</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hr</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hp</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hq</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hdiv</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hh₁</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hh₂</span> <span class=\"o\">:</span> <span class=\"n\">h</span><span class=\"err\">^</span><span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> generator of a subgroup of ℤ⋆p of order q -/</span>\n  <span class=\"o\">(</span><span class=\"n\">Hg</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span>\n<span class=\"n\">include</span> <span class=\"n\">Hg</span> <span class=\"n\">Hdiv</span> <span class=\"n\">Hh₁</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">generator_proof</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">^</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Hg</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">Ht</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pred_eq_of_eq_succ</span> <span class=\"n\">Hdiv</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Ht</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">zmodp</span><span class=\"bp\">.</span><span class=\"n\">fermat_little</span> <span class=\"n\">Hp</span> <span class=\"n\">Hh₁</span>\n<span class=\"kn\">end</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">variables</span>\n  <span class=\"o\">(</span><span class=\"n\">prikey</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">q</span> <span class=\"n\">Hq</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> private key -/</span>\n  <span class=\"o\">(</span><span class=\"n\">pubkey</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> public key -/</span>\n  <span class=\"o\">(</span><span class=\"n\">Hrel</span> <span class=\"o\">:</span> <span class=\"n\">pubkey</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">elgamal_enc</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">q</span> <span class=\"n\">Hq</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">elgamal_enc</span>\n</pre></div>\n\n\n<p>works</p>",
        "id": 191384386,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584861293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Schnorr.20Group/near/191384381\" title=\"#narrow/stream/113489-new-members/topic/Schnorr.20Group/near/191384381\">said</a>:</p>\n<blockquote>\n<p>This goes away for me if I wrap the previous declaration and preceding <code>include</code> in <code>section ... end</code> it seems lean doesn't like including these extra hypotheses.</p>\n</blockquote>\n<p>I tried to move all the variable declared after the proof 'generator_proof' before it, but the error is still the same.    <br>\nAnyway, your solution is working, so it's fine.</p>",
        "id": 191384685,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584862054
    },
    {
        "content": "<p>Right the issue is the include line which adds the unneeded hypotheses (for elgamal_enc) <code>Hg Hdiv Hh₁</code> to all following declarations.</p>",
        "id": 191385428,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584863671
    },
    {
        "content": "<p>Why does this find is not returning any lemma?  I want to prove Ht1. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"err\">^</span> <span class=\"bp\">_</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">elgamal_enc</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">q</span> <span class=\"n\">Hq</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">pubkey</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">elgamal_dec</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span> <span class=\"bp\">×</span>  <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"err\">^</span><span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>\n\n<span class=\"n\">include</span> <span class=\"n\">Hrel</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">elgama_enc_dec_identity</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">elgamal_dec</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">Hp</span> <span class=\"n\">Hq</span> <span class=\"n\">prikey</span>\n      <span class=\"o\">(</span><span class=\"n\">elgamal_enc</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">Hp</span> <span class=\"n\">Hq</span> <span class=\"n\">g</span> <span class=\"n\">pubkey</span> <span class=\"n\">m</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">elgamal_enc</span> <span class=\"n\">elgamal_dec</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Hrel</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pow_mul</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">Ht₁</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">Ht₂</span> <span class=\"o\">:</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span>\n       <span class=\"n\">mul_comm</span> <span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Ht₂</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_inv_cancel</span> <span class=\"n\">Ht₁</span><span class=\"o\">],</span> <span class=\"n\">ring</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 191385536,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584863893
    },
    {
        "content": "<p>What is <code>elgamal_dec</code>? You might find the tactic <code>library_search</code> more useful than <code>find</code></p>",
        "id": 191387840,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584868753
    },
    {
        "content": "<p>Updated the code.</p>",
        "id": 191388272,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584869688
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">elgamal_enc</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">q</span> <span class=\"n\">Hq</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">pubkey</span><span class=\"err\">^</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">elgamal_dec</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span> <span class=\"bp\">×</span>  <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"err\">^</span><span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>\n\n<span class=\"n\">include</span> <span class=\"n\">Hrel</span> <span class=\"n\">Hg</span> <span class=\"n\">Hh₁</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">elgama_enc_dec_identity</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">elgamal_dec</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">Hp</span> <span class=\"n\">Hq</span> <span class=\"n\">prikey</span>\n      <span class=\"o\">(</span><span class=\"n\">elgamal_enc</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">Hp</span> <span class=\"n\">Hq</span> <span class=\"n\">g</span> <span class=\"n\">pubkey</span> <span class=\"n\">m</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"err\">^</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">elgamal_enc</span> <span class=\"n\">elgamal_dec</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Hrel</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pow_mul</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">rw</span> <span class=\"n\">Hg</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">pow_ne_zero</span> <span class=\"n\">r</span> <span class=\"n\">Hh₁</span><span class=\"o\">,</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">Ht₁</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">pow_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">Ht₂</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">*</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span>\n       <span class=\"n\">mul_comm</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">prikey</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Ht₂</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_inv_cancel</span> <span class=\"n\">Ht₁</span><span class=\"o\">],</span> <span class=\"n\">ring</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 191388766,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584870436
    },
    {
        "content": "<p>You need g nonzero</p>",
        "id": 191388775,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584870469
    },
    {
        "content": "<p>For which you need h nonzero</p>",
        "id": 191388779,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584870480
    },
    {
        "content": "<p>Thanks Alex.  I am looking for a vector library, and I see two vector library in mathlib, vector2 and vector3.</p>",
        "id": 191391707,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584875637
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/78ffbae077c50ed8ee060b3ac544f6f1d4359f39/src/number_theory/dioph.lean#L109\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/78ffbae077c50ed8ee060b3ac544f6f1d4359f39/src/number_theory/dioph.lean#L109\">https://github.com/leanprover-community/mathlib/blob/78ffbae077c50ed8ee060b3ac544f6f1d4359f39/src/number_theory/dioph.lean#L109</a></p>",
        "id": 191391758,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584875672
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/c718a22925872db4cb5f64c36ed6e6a07bdf647c/src/data/vector2.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/c718a22925872db4cb5f64c36ed6e6a07bdf647c/src/data/vector2.lean\">https://github.com/leanprover-community/mathlib/blob/c718a22925872db4cb5f64c36ed6e6a07bdf647c/src/data/vector2.lean</a></p>",
        "id": 191391836,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584875791
    },
    {
        "content": "<p>Which one would suggest to use ?</p>",
        "id": 191391839,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584875810
    },
    {
        "content": "<p>Use vector</p>",
        "id": 191392164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584876305
    },
    {
        "content": "<p>Thanks Kevin.</p>",
        "id": 191392580,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584877011
    },
    {
        "content": "<p>By the way Coq has a nice extraction facility, and you can extract any Coq program into Haskell, OCaml, or Scheme. I am wondering if there is something like this in Lean?</p>",
        "id": 191392704,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584877220
    },
    {
        "content": "<p>In lean 4 you should be able to extract to...umm...C? I don't have a clue about this stuff</p>",
        "id": 191395571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584881915
    },
    {
        "content": "<p>We really should give <code>#find</code> some additional love.</p>",
        "id": 191420721,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584917749
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  That would make the life easier for new comers used to Coq's search pattern. I found linear_search quite nice because it just gives me some lemma from the remote corners of the mathlib library.</p>",
        "id": 191424796,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584924939
    },
    {
        "content": "<p>I am looking for a lemma to prove that </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">),</span>\n<span class=\"bp\">_</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">ms</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">rs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">zmodp</span> <span class=\"n\">q</span> <span class=\"n\">Hq</span><span class=\"o\">),</span>\n<span class=\"bp\">_</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">rs</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"err\">⊢</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">zip_with</span> <span class=\"n\">f</span>  <span class=\"n\">ms</span> <span class=\"n\">rs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n</pre></div>\n\n\n<p>I could find anything using  <strong> find </strong>  or  <strong>library_search</strong></p>",
        "id": 191439246,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584948937
    },
    {
        "content": "<p>I agree that <code>list.zip_with</code> doesn't seem to have been given much love in mathlib! It's defined in core, and for some of these things <code>data.list.basic</code> just makes an API, but apparently not here. I think it might be a hole in the library, although I would imagine it's not hard to prove by induction on n?</p>",
        "id": 191440038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584949675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>   If, say, my goal is to prove equality x = x, then I can use tactic or write the exact terms.  I am wondering how can I see the terms build using the tactics ?</p>",
        "id": 191459587,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584962500
    },
    {
        "content": "<p><code>#print</code></p>",
        "id": 191467620,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584967749
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 191467621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584967749
    },
    {
        "content": "<p>#print is just printing the type signature.  For this code</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">vector_ciphertext_mult</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span> <span class=\"bp\">×</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span> <span class=\"bp\">×</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span>\n  <span class=\"n\">vector</span> <span class=\"o\">(</span><span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span> <span class=\"bp\">×</span> <span class=\"n\">zmodp</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">cs₁</span> <span class=\"o\">,</span> <span class=\"n\">Hc₁</span><span class=\"bp\">⟩</span>  <span class=\"bp\">⟨</span><span class=\"n\">cs₂</span><span class=\"o\">,</span> <span class=\"n\">Hc₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">⟨</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">zip_with</span> <span class=\"o\">(</span><span class=\"n\">ciphertext_mult</span> <span class=\"n\">p</span> <span class=\"n\">Hp</span><span class=\"o\">)</span> <span class=\"n\">cs₁</span>  <span class=\"n\">cs₂</span><span class=\"o\">,</span>\n    <span class=\"k\">begin</span>\n      <span class=\"k\">have</span> <span class=\"n\">Ht</span> <span class=\"o\">:</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">cs₁</span> <span class=\"bp\">=</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">cs₂</span> <span class=\"o\">:=</span>\n      <span class=\"k\">begin</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Hc₁</span><span class=\"o\">,</span> <span class=\"n\">Hc₂</span><span class=\"o\">]</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Hc₁</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">zip_with_len_l</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">Ht</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span> <span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>The output of #print vector_ciphertext_mult </p>\n<div class=\"codehilite\"><pre><span></span>def ElGamal.vector_ciphertext_mult : Π (p : ℕ) (Hp : nat.prime p) {n : ℕ},\n  vector (zmodp p Hp × zmodp p Hp) n → vector (zmodp p Hp × zmodp p Hp) n → vector (zmodp p Hp × zmodp p Hp) n :=\nλ (p : ℕ) (Hp : nat.prime p) {n : ℕ}, vector_ciphertext_mult._main p Hp\n</pre></div>\n\n\n<p>But I want to see the CIC terms build by tactics.</p>",
        "id": 191540210,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1584999471
    },
    {
        "content": "<p>The proof term is there, it's everything after the <code>:=</code>.</p>",
        "id": 191540532,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1584999653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>  Seems like something I  misunderstood about Lean, so let me give a similar analogy from Coq. In Coq, when you write tactic to solve some goal, under the hood it is constructing a Gallina (CIC) term (which you could have written manually, but no one does this because it is very cumbersome). Now at any point of the time, if you want to see the CIC (Gallina) terms, then you simply write 'Show Proof', and it will print all the Gallina (CIC) terms constructed so far. </p>\n<p>In my 'vector_ciphertext_mult' program, there are two things: a list (which I believe is in CIC) and a proof (but written in tactic mode). I want to see how the proof terms  appears in CIC (or core language) because I don't think tactics are part of core language in Lean.</p>",
        "id": 191543401,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1585001201
    },
    {
        "content": "<p>Sorry, I guess I was a bit unclear, I meant the part after <code>:=</code> in the output of <code>#print vector_ciphertext_mult</code>, namely: <code>λ (p : ℕ) (Hp : nat.prime p) {n : ℕ}, vector_ciphertext_mult._main p Hp</code>. </p>\n<p>That is a term, not a tactic. I don't know if you would consider that in the \"core\" language of Lean since you can also <a href=\"https://github.com/leanprover-community/lean/blob/master/doc/export_format.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean/blob/master/doc/export_format.md\">export</a> something even lower level. I've never played around with that though.</p>",
        "id": 191548790,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1585004444
    },
    {
        "content": "<p>I think you just have to keep digging. Can you see that your definition is essentially <code>vector_ciphertext_mult._main</code>? Why don't you <code>#print</code> that, and then keep printing stuff?</p>\n<p>Hey -- do you know about <code>set_option pp.all true</code>? Try that before a #print statement, it gives you much more information.</p>",
        "id": 191549864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585005191
    },
    {
        "content": "<p>Sorry for the confusion. Some how I missed   the <code>._main</code> part in the <code> vector_ciphertext_mult._main p Hp </code>.  Thanks again <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> .</p>",
        "id": 191558695,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1585013128
    }
]
[
    {
        "content": "<p>Is it possible to prove that a case for a function is impossible?</p>\n<p>Suppose you define a map (or dictionary in Python) as a list of key/value pairs (see the definition below).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">map</span>\n<span class=\"bp\">|</span> <span class=\"n\">build</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">map</span><span class=\"o\">):</span> <span class=\"n\">map</span>\n</code></pre></div>\n<p>I could define a function that, given a key k, returns me the value v that is associated with that key (see definition below). This function would probably use an option type in case the key is not in the map.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mget</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span>             <span class=\"o\">:=</span> <span class=\"n\">option.none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k1</span> <span class=\"n\">v1</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">k1</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"n\">option.some</span> <span class=\"n\">v1</span> <span class=\"k\">else</span> <span class=\"n\">mget</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>But if I know that key k is in the keyset of this map (see the function below that returns the keyset), I know it is impossible that <code>mget</code> returns none.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">keys</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_union</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k</span> <span class=\"n\">_</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">has_insert.insert</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The reason I want to define such a function is that, if I have a prove for  <code>(mget k m).is_some</code> (where k is a key, m is a map). I can use option.get on that proof to return me something (with the type of the values). But don't think I can reason about that value, which is what I need. Right? For this question I do not know whether this last statement is true or not, but my attempts at proving something using mget almost always return in a goal that looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">option.get</span> <span class=\"n\">_</span> <span class=\"bp\">\\</span><span class=\"k\">in</span> <span class=\"n\">keys</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>(where _ is <code>(mget k m).is_some</code>)</p>",
        "id": 223553915,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611255194
    },
    {
        "content": "<p>Yes it is possible to prove that cases are impossible, and <code>option.get</code> is an example. You should see how it is implemented - it cases on the option and then proves that the none case yields false</p>",
        "id": 223554723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611255524
    },
    {
        "content": "<p><code>[has_union (finset α)]</code> &lt;-- you don't want this</p>",
        "id": 223554795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611255556
    },
    {
        "content": "<p>Aa, the answer was closer than I thought. I will try that, don't know what the none case for option.get exactly says, but I can figure it out.<br>\nthakn you!</p>",
        "id": 223558097,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611257105
    },
    {
        "content": "<p>Btw, why wouldn't I want [has_union (finset \\a)]? Maybe I am reading it wrong, but this says that you can do somefinset \\union otherfinset, which should be fine right?</p>",
        "id": 223559642,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611257762
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/option.get/src\">src#option.get</a></p>",
        "id": 223561140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611258411
    },
    {
        "content": "<p>There is already a definition of <code>has_union (finset A)</code>. By asking for a different one it might not have the right properties, for example it might say that the union of any two finsets is empty, in which case your theorems won't be provable</p>",
        "id": 223561300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611258486
    },
    {
        "content": "<p>if you just delete that typeclass argument you will still be able to use union on finsets</p>",
        "id": 223561411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611258544
    },
    {
        "content": "<p>Also <code>map</code> should take its type arguments explicitly, i.e. <code>inductive map (α β: Type) : Type</code>. They can't be inferred from context which is why you are having to write <code>@map α β</code> all the time</p>",
        "id": 223561579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611258618
    },
    {
        "content": "<p>As for your actual question, could you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with the theorem you want to prove? It's a little vague what the problem is</p>",
        "id": 223561638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611258655
    },
    {
        "content": "<p>Let me first explain the context of the question before giving the mwe. I am taking a course called Logical Verification (Jasmin Blanchette as the teacher). This is part of the project I am working on for that course. He mentioned that i could ask question here. So, I am trying to ask questions about smaller problems I have (I feel like I should at least mention this, just so it does not look suspicious or anything). I will mention your name if I use anything you post here.</p>",
        "id": 224237126,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611776673
    },
    {
        "content": "<p>MWE coming in a bit</p>",
        "id": 224237138,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611776681
    },
    {
        "content": "<p>Again I want to stress that I do not want a the proof (as that would be cheating), but I was allowed to ask questions regarding smaller problems.</p>\n<p>So my MWE is here, it is a bit long though</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">multiset</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">mapfuncs</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">map</span>\n<span class=\"bp\">|</span> <span class=\"n\">build</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">map</span><span class=\"o\">):</span> <span class=\"n\">map</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">values</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">values</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">keys</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_union</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k</span> <span class=\"n\">_</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">has_insert.insert</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">mget</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span>             <span class=\"o\">:=</span> <span class=\"n\">option.none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k1</span> <span class=\"n\">v1</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">k1</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"n\">option.some</span> <span class=\"n\">v1</span> <span class=\"k\">else</span> <span class=\"n\">mget</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">keygetfromvalue</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"n\">option.none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k</span> <span class=\"n\">v1</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">v1</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"k\">then</span> <span class=\"n\">option.some</span> <span class=\"n\">k</span> <span class=\"k\">else</span> <span class=\"n\">keygetfromvalue</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">keygetfromvaluesome</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">option.is_some</span> <span class=\"o\">(</span><span class=\"n\">keygetfromvalue</span> <span class=\"n\">v</span> <span class=\"n\">m</span><span class=\"o\">)):</span> <span class=\"n\">α</span>\n<span class=\"o\">:=</span> <span class=\"n\">option.get</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lemma_to_proof</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">values</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">mget</span> <span class=\"n\">k</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">option.some</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hvinvalm</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">exists.intro</span> <span class=\"o\">(</span><span class=\"n\">keygetfromvaluesome</span> <span class=\"n\">v</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)),</span> <span class=\"c1\">-- I do have a proof here, but it involves a longer lemma.</span>\n      <span class=\"n\">apply</span> <span class=\"n\">and.intro</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span>\n        <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">keygetfromvaluesome</span><span class=\"o\">],</span>\n          <span class=\"c1\">-- αβ: Type</span>\n          <span class=\"c1\">-- _inst_1: decidable_eq α</span>\n          <span class=\"c1\">-- _inst_2: decidable_eq β</span>\n          <span class=\"c1\">-- v: β</span>\n          <span class=\"c1\">-- m: map</span>\n          <span class=\"c1\">-- hvinvalm: v ∈ values m</span>\n          <span class=\"c1\">-- ⊢ option.get _ ∈ keys m</span>\n        <span class=\"gr\">sorry</span> <span class=\"c1\">-- The problem is the state here. I can't get any info on the key itself.</span>\n      <span class=\"o\">},</span>\n      <span class=\"o\">{</span>\n        <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">keygetfromvaluesome</span><span class=\"o\">],</span><span class=\"c1\">-- same problem here</span>\n        <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n      <span class=\"o\">}</span>\n  <span class=\"kd\">end</span>\n<span class=\"kd\">end</span> <span class=\"n\">mapfuncs</span>\n</code></pre></div>",
        "id": 224238566,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611777358
    },
    {
        "content": "<p>The map inductive type is the same, for completeness sake I have included the definitions of values and keys (but I do not think they matter in this case). I gave a different example here, but the problem is the same.</p>\n<p>Now I want to define a function (which I call keygetfromvalue) that, given a value v, gets <em>a</em> key associated with that value. When i use that function in my proof I get the problem that I have a goal that looks like <code>option.get _ \\in someset</code> (see the two \"sorry\"s in the lemma_to_proof). Now I want to define a new function (lets call that valuetokey) that given a value v and a proof that there is a key associated with it, returns me v (so not option.some v).</p>",
        "id": 224239073,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611777600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381693\">Ömer Şakar</span> <a href=\"#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224237126\">said</a>:</p>\n<blockquote>\n<p>Let me first explain the context of the question before giving the mwe. I am taking a course called Logical Verification (Jasmin Blanchette as the teacher).</p>\n</blockquote>\n<p>Now where have I heard that name before? :)</p>",
        "id": 224241193,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1611778606
    },
    {
        "content": "<p>My first instinct is that you might be able to use case distinction on <code>m</code>, like in <code>keygetfromvalue</code> to prove that <code>↥((keygetfromvalue v m).is_some)</code> implies that <code>option.get this</code> is in the keys.</p>",
        "id": 224241563,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1611778789
    },
    {
        "content": "<p>Yes, but unfortunately the way that <code>map</code> is defined, there is no connection between <code>a</code> and <code>b</code> currently.</p>",
        "id": 224242183,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611779125
    },
    {
        "content": "<p>No lemma showing that</p>",
        "id": 224242190,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611779129
    },
    {
        "content": "<p>Right, it would probably have to be in the form of a new lemma (couple of new lemmas?) proved by pattern matching. Basically what I mean is duplicate <code>keygetfromvalue</code> but return a proof instead of a key.</p>",
        "id": 224242694,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1611779364
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lemma_to_proof</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">values</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">mget</span> <span class=\"n\">k</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">option.some</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span> <span class=\"n\">hm</span> <span class=\"n\">generalizing</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">values</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- false because we would have `v ∈ values map.nil`</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">values</span><span class=\"o\">,</span> <span class=\"n\">keys</span><span class=\"o\">,</span> <span class=\"n\">mem_insert</span><span class=\"o\">,</span> <span class=\"n\">list.mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">list.singleton_append</span><span class=\"o\">],</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">H</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mget</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hm</span> <span class=\"n\">_</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">mget</span><span class=\"o\">],</span>\n        <span class=\"gr\">sorry</span> <span class=\"c1\">-- you can't prove this because there is no relationship between `b` and `v`</span>\n      <span class=\"o\">},</span>\n    <span class=\"o\">}</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224242946,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611779473
    },
    {
        "content": "<p>That is because <code>map.build 0 1 (map.build 0 0 map.nil)</code> has <code>values = [0, 1]</code> but <code>keys = {0}</code>!</p>",
        "id": 224243196,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611779584
    },
    {
        "content": "<p>Here's how I suggest you set this up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mapfuncs</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">map</span>\n<span class=\"bp\">|</span> <span class=\"n\">build</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">map</span><span class=\"o\">):</span> <span class=\"n\">map</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map.values</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">m.values</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map.keys</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k</span> <span class=\"n\">_</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"n\">k</span> <span class=\"n\">m.keys</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map.get</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span>             <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k1</span> <span class=\"n\">v1</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">k1</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">v1</span> <span class=\"k\">else</span> <span class=\"n\">map.get</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map.by_value</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">k</span> <span class=\"n\">v1</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">v1</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">k</span> <span class=\"k\">else</span> <span class=\"n\">map.by_value</span> <span class=\"n\">m</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">def map.get_by_value {α β: Type*} [decidable_eq β]</span>\n<span class=\"cm\">  (v: β) (m: map α β) (h: option.is_some (map.by_value v m)) : α :=</span>\n<span class=\"cm\">option.get h</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map.mem_by_value</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">m.by_value</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">m.get</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map.mem_keys</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">m.keys</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">m.get</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map.mem_values</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">m.values</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">m.get</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">mapfuncs</span>\n</code></pre></div>",
        "id": 224243622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611779772
    },
    {
        "content": "<p>I removed the <code>k ∈ (keys m)</code> conjunct from <code>map.mem_values</code> because it's implied by the second conjunct <code>v ∈ m.get k</code></p>",
        "id": 224243763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611779840
    },
    {
        "content": "<p>You don't need the <code>keygetfromvaluesome</code> function at all for these proofs, so it's commented out</p>",
        "id": 224243966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611779931
    },
    {
        "content": "<p>Actually, now that I come to think about it, it's possible to prove <code>map.mem_values</code> directly by induction on <code>m</code>, rather than splitting the forward and reverse directions into two theorems</p>",
        "id": 224244210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611780070
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224242694\">said</a>:</p>\n<blockquote>\n<p>Right, it would probably have to be in the form of a new lemma (couple of new lemmas?) proved by pattern matching. Basically what I mean is duplicate <code>keygetfromvalue</code> but return a proof instead of a key.</p>\n</blockquote>\n<p>Hi Anne, long time no see:)</p>",
        "id": 224245576,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611780791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224242183\">said</a>:</p>\n<blockquote>\n<p>Yes, but unfortunately the way that <code>map</code> is defined, there is no connection between <code>a</code> and <code>b</code> currently.</p>\n</blockquote>\n<p>Hmm I thought that if they are within the same constructor case, that that would be the association. But I guess not... (I only realize that now).</p>",
        "id": 224245745,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611780856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224243622\">said</a>:</p>\n<blockquote>\n<p>Here's how I suggest you set this up:<br>\n</p>\n</blockquote>\n<p>Interesting. So if I understand it correctly, is the difference with my approach that I rely on a proof (from which you cannot extract any info) and your approach (besides looking more structured) associates the map.by_value and map.get functions?</p>",
        "id": 224246591,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611781269
    },
    {
        "content": "<p>The main point with these lemmas is to have something that can be proven straightforwardly by induction. Once you have them you can use them to prove theorems about the <code>get_by_value</code> function if you want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map.get_by_value_mem_keys</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m.get_by_value</span> <span class=\"n\">v</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">m.keys</span> <span class=\"o\">:=</span>\n<span class=\"n\">map.mem_keys.2</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map.mem_by_value</span> <span class=\"o\">(</span><span class=\"n\">option.get_mem</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 224251500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611783574
    },
    {
        "content": "<p>Also as pointed out by Yakov, some of these theorems aren't true because there is no constraint on <code>m</code> having unique keys. You might find it easier to work with the relation <code>(k, v) ∈ m.entries</code> in place of <code>v ∈ m.get k</code> in the theorems, where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">map.entries</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">map.nil</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">map.build</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">m.entries</span>\n</code></pre></div>",
        "id": 224252606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611784153
    },
    {
        "content": "<p>The reason I did not constraint m on having unique keys is that I wanted to model a map as a list of entries. The keyset has unique keys (because by definition elements in a set a unique).</p>",
        "id": 224253929,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611784803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224251500\">said</a>:</p>\n<blockquote>\n<p>The main point with these lemmas is to have something that can be proven straightforwardly by induction. Once you have them you can use them to prove theorems about the <code>get_by_value</code> function if you want:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map.get_by_value_mem_keys</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m.get_by_value</span> <span class=\"n\">v</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">m.keys</span> <span class=\"o\">:=</span>\n<span class=\"n\">map.mem_keys.2</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map.mem_by_value</span> <span class=\"o\">(</span><span class=\"n\">option.get_mem</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Hmmm, i think i get what you mean, I will try it out. Thank you (Anne and Yakov) a lot!</p>",
        "id": 224254158,
        "sender_full_name": "Ömer Şakar",
        "timestamp": 1611784844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381693\">Ömer Şakar</span> <a href=\"#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224253929\">said</a>:</p>\n<blockquote>\n<p>The reason I did not constraint m on having unique keys is that I wanted to model a map as a list of entries. The keyset has unique keys (because by definition elements in a set a unique).</p>\n</blockquote>\n<p>The keyset as defined by <code>map.keys</code> is unique, but you're still able to construct that <code>keys = {0}, values = [0, 1]</code> map, where, depending on how you define retrieval function, some of those values might be unreachable</p>",
        "id": 224255285,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611785245
    },
    {
        "content": "<p>One way to express that the map has unique keys using the <code>map.keys</code> finset is <code>m.keys.card = m.values.length</code>, although that's not the most convenient. If <code>map.keys</code> was a list then you could say <code>m.keys.nodup</code> to express that there are no duplicate keys (and hence you can upgrade this list to a finset without losing duplicate elements)</p>",
        "id": 224255947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611785588
    }
]
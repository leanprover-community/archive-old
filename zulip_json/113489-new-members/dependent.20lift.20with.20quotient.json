[
    {
        "content": "<p>What's the right way to have a dependent definition on a quotient? I have defined my own setoid on list which is whether two lists are rotations of one another:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_rotated</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">l.rotate</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">l'</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">1000</span> <span class=\"o\">:=</span> <span class=\"n\">is_rotated</span>\n\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_rotated.setoid</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">is_rotated</span><span class=\"o\">,</span> <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">is_rotated.eqv</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>so I can define a <code>cycle</code> via a quotient:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cycle</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_rotated.setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In fact, properties like <code>nodup</code> can be lifted into the quotient</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_rotated.nodup_iff</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">nodup</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n<span class=\"n\">h.perm.nodup_iff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">quot.lift_on</span> <span class=\"n\">s</span> <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l₂</span><span class=\"o\">),</span> <span class=\"n\">propext</span> <span class=\"bp\">$</span> <span class=\"n\">e.nodup_iff</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I've also defined a cyclical permutation from the list, and shown that it is invariant to rotation</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">form_perm</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zip_with</span> <span class=\"n\">equiv.swap</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">tail.prod</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">form_perm_eq_of_is_rotated</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">form_perm</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">form_perm</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.def</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">form_perm_rotate</span> <span class=\"n\">l</span> <span class=\"n\">hd</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>My question is, what's the right invocation to make this dependent definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">perm</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">quot.lift_on</span> <span class=\"n\">s</span>\n  <span class=\"n\">_</span> <span class=\"c1\">-- list α → s.nodup → equiv.perm α</span>\n  <span class=\"n\">_</span> <span class=\"c1\">-- ∀ (a b : list α), setoid.r a b → ⁇ a = ⁇ b</span>\n</code></pre></div>",
        "id": 234427623,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618363749
    },
    {
        "content": "<p>Do I instead use <code>quot.induction_on</code>?</p>",
        "id": 234427660,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618363801
    },
    {
        "content": "<p>What's wrong with <code>quot.lift_on</code>?</p>",
        "id": 234428420,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1618364399
    },
    {
        "content": "<p>I don't know how to unlift the provided <code>cycle.nodup s</code> to provide me <code>list.nodup</code> with the proof I supply for the last argument of <code>lift_on</code></p>",
        "id": 234428626,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618364574
    },
    {
        "content": "<p>Could you please post an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> that others can copy+paste to make experiments?</p>",
        "id": 234428857,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1618364791
    },
    {
        "content": "<p>It seems that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quot.lift_on\">docs#quot.lift_on</a> is for non-dependent functions.</p>",
        "id": 234428928,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1618364857
    },
    {
        "content": "<p>There is a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.hrec_on'\">docs#quotient.hrec_on'</a></p>",
        "id": 234429033,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1618364934
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.rotate</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.erase_dup</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.perm.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_rotated</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">l.rotate</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">l'</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">1000</span> <span class=\"o\">:=</span> <span class=\"n\">is_rotated</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_rotated.setoid</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">is_rotated</span><span class=\"o\">,</span> <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_rotated.perm</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n<span class=\"n\">exists.elim</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">hl</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">rotate_perm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_rotated.nodup_iff</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">nodup</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span>\n<span class=\"n\">h.perm.nodup_iff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">form_perm</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zip_with</span> <span class=\"n\">equiv.swap</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">tail.prod</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">form_perm_eq_of_is_rotated</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">form_perm</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">form_perm</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cycle</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_rotated.setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">cycle</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">quot.mk</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">quot.lift_on</span> <span class=\"n\">s</span> <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l₂</span><span class=\"o\">),</span> <span class=\"n\">propext</span> <span class=\"bp\">$</span> <span class=\"n\">e.nodup_iff</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">perm</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">quot.lift_on</span> <span class=\"n\">s</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">form_perm</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">simp</span> <span class=\"n\">only</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">perm'</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">quot.rec_on</span> <span class=\"n\">s</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">form_perm</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">cycle</span>\n</code></pre></div>",
        "id": 234429231,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618365103
    },
    {
        "content": "<p><code>hrec</code> leads to a <code>heq</code> I'm not sure how to discharge:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">perm'</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">quot.hrec_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">form_perm</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>  <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 234429981,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618365710
    },
    {
        "content": "<p>Thank you Yury! Here's my solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">perm</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">cycle</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">quot.hrec_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">form_perm</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l₂</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">is_rotated.nodup_iff</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"n\">heq_of_eq</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">form_perm_eq_of_is_rotated</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h1</span> <span class=\"o\">}</span> <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 234430434,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618366038
    },
    {
        "content": "<p>Another quotient problem: what about defining a dependent product on a multiset if I know that the multiplication is commutative within the multiset?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.fold</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">multiset</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">def</span> <span class=\"n\">noncomm_prod'</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">⦃</span><span class=\"n\">y</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">commute</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n  <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">quotient.hrec_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">l.prod</span><span class=\"o\">)</span> <span class=\"c1\">-- how do I build the output to encode `h` as well?</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span> <span class=\"n\">l'</span><span class=\"o\">),</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">refine</span> <span class=\"n\">imp_congr</span> <span class=\"n\">h.mem_iff</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">exact</span> <span class=\"n\">imp_congr</span> <span class=\"n\">h.mem_iff</span> <span class=\"n\">iff.rfl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">heq_iff_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"n\">h.prod_eq'</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span> <span class=\"c1\">-- no access to `h` here</span>\n    <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">multiset</span>\n</code></pre></div>",
        "id": 237753946,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620350113
    },
    {
        "content": "<p>Do I have to use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">pprod</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">⦃</span><span class=\"n\">y</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">commute</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 237754067,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620350204
    },
    {
        "content": "<p>And then define another function to extract it?</p>",
        "id": 237754096,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620350226
    },
    {
        "content": "<p>(no <code>pprod.ext</code> =C )</p>",
        "id": 237754187,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620350290
    },
    {
        "content": "<p>Oh I guess I threw away the info, didn't need the pprod</p>",
        "id": 237754689,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620350723
    }
]
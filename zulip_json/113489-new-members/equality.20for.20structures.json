[
    {
        "content": "<p>Here is a lemma I am stuck on:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">bundle</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">space</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">space</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bundle_map</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">E.space</span> <span class=\"bp\">→</span> <span class=\"n\">F.space</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F.π</span> <span class=\"bp\">∘</span> <span class=\"n\">map</span> <span class=\"bp\">=</span> <span class=\"n\">E.π</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bundle_map.eq_of_map</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">φ1</span> <span class=\"n\">φ2</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">φ1.map</span> <span class=\"bp\">=</span> <span class=\"n\">φ2.map</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">φ1</span> <span class=\"bp\">=</span> <span class=\"n\">φ2</span> <span class=\"o\">:</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> invalid apply tactic, failed to unify</span>\n<span class=\"cm\">  φ1 = φ2</span>\n<span class=\"cm\">  with</span>\n<span class=\"cm\">  ?m_2 = ?m_2 -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I thought that <code>split</code> or <code>cases</code> or something should work here. For example I can prove associativity of compositions (which involves showing that two <code>bundle_map</code>s are equal) that way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bundle_map.comp</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">φ'</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">φ'.map</span> <span class=\"bp\">∘</span> <span class=\"n\">φ.map</span><span class=\"o\">,</span>\n  <span class=\"n\">h</span>   <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp.assoc</span><span class=\"o\">,</span> <span class=\"n\">φ'.h</span><span class=\"o\">,</span> <span class=\"n\">φ.h</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`∘∘`</span><span class=\"o\">:</span><span class=\"mi\">110</span> <span class=\"o\">:=</span> <span class=\"n\">bundle_map.comp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bundle_map.comp.assoc</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">φ''</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ'</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">φ''</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ'</span><span class=\"o\">)</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">φ''</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ'</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">split</span>\n</code></pre></div>\n<p>Thanks for any help!</p>",
        "id": 252380782,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631053974
    },
    {
        "content": "<p>For this, you need an extensionality lemma.  The <code>@[ext]</code> attribute is a way to generate one for you automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">bundle_map</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">E.space</span> <span class=\"bp\">→</span> <span class=\"n\">F.space</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F.π</span> <span class=\"bp\">∘</span> <span class=\"n\">map</span> <span class=\"bp\">=</span> <span class=\"n\">E.π</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bundle_map.eq_of_map</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">φ1</span> <span class=\"n\">φ2</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">φ1.map</span> <span class=\"bp\">=</span> <span class=\"n\">φ2.map</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">φ1</span> <span class=\"bp\">=</span> <span class=\"n\">φ2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>  <span class=\"c1\">-- or ext1 to just do a single level; follow by `exact h1`</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 252381016,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631054144
    },
    {
        "content": "<p>Cases works for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">bundle_map.eq_of_map</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">φ1</span> <span class=\"n\">φ2</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">φ1.map</span> <span class=\"bp\">=</span> <span class=\"n\">φ2.map</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">φ1</span> <span class=\"bp\">=</span> <span class=\"n\">φ2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">φ1</span> <span class=\"k\">with</span> <span class=\"n\">map1</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">φ2</span> <span class=\"k\">with</span> <span class=\"n\">map2</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 252381033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631054158
    },
    {
        "content": "<p>(Kyle's answer is in some sense \"the same as mine\", because you prove ext lemmas for structures precisely by doing cases on the components)</p>",
        "id": 252381129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631054206
    },
    {
        "content": "<p>Thank you both!</p>",
        "id": 252381166,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631054250
    },
    {
        "content": "<p>PS your <code>by split</code> proof is bogus:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">bundle_map.comp.assoc</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">φ''</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ'</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">φ''</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ'</span><span class=\"o\">)</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">φ''</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ'</span> <span class=\"bp\">∘∘</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 252381190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631054276
    },
    {
        "content": "<p>Oooh.</p>",
        "id": 252381286,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631054327
    },
    {
        "content": "<p><code>split</code> never closes goals unless they are somehow degenerate, in my experience.</p>",
        "id": 252381317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631054360
    },
    {
        "content": "<p>Also, <code>split</code> is for splitting a goal that's a constructor of some kind (something with parts) -- the goal is an equality, which can't be split.</p>\n<p>Using Kevin's direct proof, you'd want <code>congr</code>, like <code>cases φ1, cases φ2, congr, exact h1,</code></p>",
        "id": 252381579,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631054524
    },
    {
        "content": "<p>I should have been paying more attention... you're <em>proving</em> the extensionality lemma that <code>@[ext]</code> generates of course, so my suggestion is sort of absurd.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">bundle_map</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">E.space</span> <span class=\"bp\">→</span> <span class=\"n\">F.space</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F.π</span> <span class=\"bp\">∘</span> <span class=\"n\">map</span> <span class=\"bp\">=</span> <span class=\"n\">E.π</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bundle_map.eq_of_map</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">bundle</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">φ1</span> <span class=\"n\">φ2</span> <span class=\"o\">:</span> <span class=\"n\">bundle_map</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">φ1.map</span> <span class=\"bp\">=</span> <span class=\"n\">φ2.map</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">φ1</span> <span class=\"bp\">=</span> <span class=\"n\">φ2</span> <span class=\"o\">:=</span> <span class=\"n\">bundle_map.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h1</span>\n</code></pre></div>",
        "id": 252381950,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631054814
    },
    {
        "content": "<p>Thanks Kyle and Kevin! That's very helpful.</p>",
        "id": 252384489,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1631056445
    }
]
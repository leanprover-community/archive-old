[
    {
        "content": "<p>In order to complete a proof, lean is asking me to show that <a href=\"https://github.com/leanprover-community/mathlib/pull/8673#discussion_r700433171\"><code>lattice_of_linear_order = germ.lattice</code></a> which I think means:</p>\n<p>\"Given a filter and a linear order β, the linear order induces a lattice structure on β, which induces a lattice structure on the germ. The linear order also induces a linear order on the germ, which in turn induces a lattice structure on the germ. Show that the two lattice structures coincide.\"</p>\n<p>The trouble is, I can't figure out how to formulate this as a lemma, even to be proved with <code>sorry</code>. I'm trying something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">lattice_of_linear_order</span> <span class=\"n\">linear_order</span> <span class=\"o\">(</span><span class=\"n\">filter.germ</span> <span class=\"n\">l</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">lattice</span><span class=\"o\">(</span><span class=\"n\">filter.germ</span> <span class=\"n\">l</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But <code>lattice_of_linear_order</code> seems to be a different sort of beast to <code>lattice</code> and <code>linear_order</code> in that it doesn't map types to types.</p>\n<p>Having stared at this for several hours, I'm now hopelessly confused about everything.</p>\n<p>Hoping someone can shed some light?</p>\n<p>Thanks.</p>\n<p>Christopher</p>",
        "id": 251685652,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1630573265
    },
    {
        "content": "<p>Do I understand correctly that your question is more \"how do I phrase the type of <code>test</code>\" than \"what do I fill in for <code>sorry</code>\"?</p>",
        "id": 251686213,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630573546
    },
    {
        "content": "<p>First of all, from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.germ.linear_order\">docs#filter.germ.linear_order</a> it looks like <code>l</code> has to be an ultrafilter.</p>",
        "id": 251686546,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630573697
    },
    {
        "content": "<p>This typechecks for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.germ</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.hyperreal</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">lattice_of_linear_order</span> <span class=\"o\">(</span><span class=\"n\">filter.germ</span> <span class=\"bp\">↑</span><span class=\"n\">l</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">filter.germ.linear_order</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">filter.germ.lattice</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 251686684,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630573797
    },
    {
        "content": "<p>Here's my thought process. We want to state that the two different constructions give rise to the same structure, so we look up what the constructions are called. The first one \"a linear order on the germ, which in turn induces a lattice structure on the germ\" is called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lattice_of_linear_order\">docs#lattice_of_linear_order</a>, and \" a lattice structure on β, which induces a lattice structure on the germ\" is called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.germ.lattice\">docs#filter.germ.lattice</a>. So let's write that out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.germ</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.hyperreal</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">lattice_of_linear_order</span> <span class=\"bp\">=</span> <span class=\"n\">filter.germ.lattice</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- Error: don't know how to synthesize placeholder ⊢ Type ?</span>\n</code></pre></div>\n<p>The error means we need to give hints to the elaborator, in order to figure out what type we're actually trying to instantiate the lattice structure on.</p>\n<p>The first thing I try is to write out the expected type with a type ascription:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.germ</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.hyperreal</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">lattice_of_linear_order</span> <span class=\"o\">:</span> <span class=\"n\">lattice</span> <span class=\"o\">(</span><span class=\"n\">filter.germ</span> <span class=\"bp\">↑</span><span class=\"n\">l</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">filter.germ.lattice</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- Error: don't know how to synthesize placeholder ⊢ Type ?</span>\n</code></pre></div>\n<p>Seems like this isn't enough, probably because Lean doesn't quite know how to get back the <code>β</code> from <code>filter.germ l β</code>.</p>\n<p>Instead of a type ascription, turning the implicit parameters explicit with <code>@</code> and supplying the correct arguments works, as shown in the above code.</p>",
        "id": 251687561,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630574247
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lattice_of_linear_order\">docs#lattice_of_linear_order</a> is dangerous as it constructs new data that forms nondefeq typeclass diamonds</p>",
        "id": 251687937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630574459
    },
    {
        "content": "<p>This same instance just came up in <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>'s thread elsewhere</p>",
        "id": 251688007,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630574509
    },
    {
        "content": "<p>Now for filling the <code>sorry</code>: I know that lattices on a type <code>α</code> are uniquely defined by their order, so this should be either available via <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#ext\">tactic#ext</a>, or at least available as a theorem named something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lattice.ext\">docs#lattice.ext</a>. Turns out the former doesn't work, but the latter does, so we need to show <code>∀ (x y : filter.germ ↑l β), x ≤ y ↔ x ≤ y</code>. (Where the <code>≤</code> on the left comes from <code>lattice_of_linear_order</code> and the <code>≤</code> on the right comes from <code>filter.germ.lattice</code>.) Checking the sources, both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.germ.linear_order/src\">src#filter.germ.linear_order</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.germ.lattice/src\">src#filter.germ.lattice</a> have the same definition of <code>≤</code> coming from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.germ.partial_order\">docs#filter.germ.partial_order</a>, so the two orders are the same by definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.germ</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.hyperreal</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lattice_of_linear_order</span> <span class=\"o\">(</span><span class=\"n\">filter.germ</span> <span class=\"bp\">↑</span><span class=\"n\">l</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">filter.germ.linear_order</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">filter.germ.lattice</span> <span class=\"o\">:=</span>\n<span class=\"n\">lattice.ext</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">iff.rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 251688186,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630574608
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/issues/609\">lean#609</a> fixed this diamond, we just need to wait for a lean release.</p>",
        "id": 251691243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630576418
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> - thank you very much for the quick response and explaining your working. It appears to solve the problem I was having.</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> - thank you for letting me know that a fix to lean is coming.</p>",
        "id": 251692489,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1630577152
    }
]
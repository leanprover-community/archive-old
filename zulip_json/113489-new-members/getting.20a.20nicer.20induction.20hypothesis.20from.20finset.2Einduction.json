[
    {
        "content": "<p>I'm working on formalizing a proof where the idea is to induct on the size of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi><mo>∖</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">Y \\setminus X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mbin\">∖</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> for two finsets <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X, Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>. I've currently set up something like the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">r</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">union_subset</span> <span class=\"n\">hX</span> <span class=\"n\">hY</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"n\">hX</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"err\">\\</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"kn\">using</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">induction</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">S</span> <span class=\"n\">ha</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  case h₁</span>\n<span class=\"cm\">  α : Type u_1,</span>\n<span class=\"cm\">  _inst_1 : decidable_eq α,</span>\n<span class=\"cm\">  E X Y : finset α,</span>\n<span class=\"cm\">  hX : X ⊆ E,</span>\n<span class=\"cm\">  hY : Y ⊆ E,</span>\n<span class=\"cm\">  h : Y \\ X = ∅</span>\n<span class=\"cm\">  ⊢ r _ = r hX</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"c1\">-- I have handled the empty case</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  case h₂</span>\n<span class=\"cm\">  α : Type u_1,</span>\n<span class=\"cm\">  _inst_1 : decidable_eq α,</span>\n<span class=\"cm\">  E X Y : finset α,</span>\n<span class=\"cm\">  hX : X ⊆ E,</span>\n<span class=\"cm\">  hY : Y ⊆ E,</span>\n<span class=\"cm\">  a : α,</span>\n<span class=\"cm\">  S : finset α,</span>\n<span class=\"cm\">  ha : a ∉ S,</span>\n<span class=\"cm\">  ih : Y \\ X = S → r _ = r hX, -- How do I use this?</span>\n<span class=\"cm\">  h : Y \\ X = insert a S</span>\n<span class=\"cm\">  ⊢ r _ = r hX</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The current <code>ih</code>, which in full form reads <code>ih : Y \\ X = S → r (union_subset hX hY) = r hX</code>, seems impossible to for me to apply since it requires <code>Y \\ X = S</code>, but we have <code>h : Y \\ X = insert a S</code>. I suspect I'm abusing the tactic here, since the target doesn't contain <code>Y \\ X</code> in it directly. I would be happy and the theorem would be proved if I had instead <code>ih : r (union_subset hX hS) = r hX</code> where <code>hS : S  ⊆ E</code> (and the rest of the tactic state the same).  Is there some way to set that up?</p>",
        "id": 134558327,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537824918
    },
    {
        "content": "<p>I managed to massage the goal so that now <code>ih : Y \\ X = S → r hXuY' = r hX</code> where <code>hXuY' : X ∪ Y \\ X ⊆ E</code>. This seems closer though I'm still not sure if my current approach is going anywhere or not. Not that I could apply this here yet, but is there any way to take a term of type <code>a = b → P a</code>and produce <code>P b</code>?</p>",
        "id": 134565383,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537834320
    },
    {
        "content": "<p>You need to generalize <code>Y</code> and <code>X</code> in the induction</p>",
        "id": 134565694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537834877
    },
    {
        "content": "<p>Why are you working on subsets of a finset <code>E</code> instead of just restricting the type?</p>",
        "id": 134565749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537834955
    },
    {
        "content": "<p>You could just assume <code>fintype α</code></p>",
        "id": 134565754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537834981
    },
    {
        "content": "<p>Ah, so that's what <code>generalizing</code> does! I wasn't able to make sense of that part of the docstring. As for fintype, I can see that will make things much easier. I just kind of rushed ahead without looking beyond <code>finset</code> when I started this. Thanks!</p>",
        "id": 134566466,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537836273
    }
]
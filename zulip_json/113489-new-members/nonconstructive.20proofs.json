[
    {
        "content": "<p>Is it possible to write non constructive proofs in LEAN??</p>",
        "id": 251257248,
        "sender_full_name": "Lucas Teixeira",
        "timestamp": 1630341852
    },
    {
        "content": "<p>yes</p>",
        "id": 251257403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630341915
    },
    {
        "content": "<p>Yes, using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.choice\">docs#classical.choice</a></p>",
        "id": 251257405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630341915
    },
    {
        "content": "<p>Most mathematics in mathlib makes no attempt to be constructive</p>",
        "id": 251257497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630341956
    },
    {
        "content": "<p>Mathematicians like playing in easy mode. They can get much further on in the quest that way.</p>",
        "id": 251273746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630348567
    },
    {
        "content": "<p>What fraction of the results in mathlib, if they were proved constructively, would produce a useful algorithm?</p>",
        "id": 251274795,
        "sender_full_name": "Will Sawin",
        "timestamp": 1630349009
    },
    {
        "content": "<p>if it were useful it would be in core Lean, right?</p>",
        "id": 251275920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630349452
    },
    {
        "content": "<p>The stuff where you can clearly do it constructively is in my experience mostly done constructively.  Sometimes this makes it harder to use (or perhaps harder for beginners to use).</p>",
        "id": 251276117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630349534
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230900\">@Will Sawin</span> Sometimes we use constructive results. But running time blows up quickly.</p>",
        "id": 251276184,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630349573
    },
    {
        "content": "<p>I think that Chris used it a couple of times when doing computations modulo small <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, when he formalized quadratic reciprocity and sum of 4 squares</p>",
        "id": 251276264,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630349612
    },
    {
        "content": "<p>Because for small <code>n</code> you can just do computations by brute force, and if stuff is done constructively, the algorithm for the brute force is handed to you by Lean.</p>",
        "id": 251276379,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630349657
    },
    {
        "content": "<p>But in most cases the definitions that are good for elegant proofs are bad for fast computations.</p>",
        "id": 251276444,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630349690
    },
    {
        "content": "<p>We do computed proofs often via <code>norm_num</code> =)</p>",
        "id": 251276754,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630349825
    },
    {
        "content": "<p>But in terms of data structures, or enumerating over inductive data types, yes, a lot of algorithms are very slow.</p>",
        "id": 251276899,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630349878
    },
    {
        "content": "<p>Maybe another illustrative example is finite sets.  To be as generic as possible, they're defined to be duplicate-free lists up to reordering. The only requirement they have is that there be an algorithm for testing equality.  The only possible algorithm for testing set membership in this situation takes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> time, since every element of that list must be compared for equality.</p>\n<p>If finite sets could require that there be a computable total order, then that could be dropped down to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>ln</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\ln n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">ln</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> using a tree representation for the finite set.  Practical finite sets use hashing, which have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> set membership (for small enough finite sets... so not completely accurate).</p>\n<p>So, while finite sets are constructive, and most operations on them are constructive (in that they are backed by algorithms), they're not exactly the algorithms you'd <em>want</em> to use in practice.</p>\n<p>There doesn't seem to be a good way to have multiple algorithms and data structures with different characteristics for the same mathematical object, short of redefining the object and proving all its properties multiple times...</p>\n<p>It would be cool if there were a way to have the pure math version of an object then provide computational definitions along with hints for how Lean should evaluate something. Maybe even if there were a way to write a typeclass that could give computational meaning to <code>noncomputable</code> definitions, which I don't think is possible with the way <code>noncomputable</code> works.</p>",
        "id": 251278707,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630350563
    },
    {
        "content": "<p>Isn't this Lean 4's <code>@implementedBy</code>?</p>",
        "id": 251279087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630350706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/251276444\">said</a>:</p>\n<blockquote>\n<p>But in most cases the definitions that are good for elegant proofs are bad for fast computations.</p>\n</blockquote>\n<p>A fabulous case in point being the natural numbers. Ever tried to prove multiplication is associative by binary induction (i.e. induction on length of binary representation of number)?</p>",
        "id": 251280025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630351094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> That's a bit different -- as far as I understand, it gives just one implementation for something. It would be nice if you could have different implementations depending on which typeclasses are available, since additional structure can allow for faster algorithms. You sort have to go for the lowest common denominator without this.</p>",
        "id": 251280420,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630351263
    },
    {
        "content": "<p>You could have a version of the function that has more constraints (your typeclass constraints), and that one is <code>implementedBy</code></p>",
        "id": 251280536,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630351316
    },
    {
        "content": "<p>Right -- for example matrix multiplication is done very differently for sparse matrices compared with the generic case.</p>",
        "id": 251280621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630351346
    },
    {
        "content": "<p>The sparse matrix case is hard, because how do you infer that you have a sparse matrix?</p>",
        "id": 251280675,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630351378
    },
    {
        "content": "<p>Because the user tells you? This is for people wanting to do computations, right? Don't ask me :-)</p>",
        "id": 251280735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630351408
    },
    {
        "content": "<p>That's how it works in computer algebra packages, you just use the matrix multiplication function but give it some added switch to say \"please use this algo at this point\"</p>",
        "id": 251280837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630351448
    },
    {
        "content": "<p><a href=\"https://doc.sagemath.org/html/en/tutorial/tour_linalg.html#sparse-linear-algebra\">example using Sage</a></p>",
        "id": 251281202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630351649
    },
    {
        "content": "<p>One way it seems you can work with noncomputable definitions and then provide (multiple) ways to compute them is through a \"classicalized\" version of a type.  Every noncomputable value can be represented as a singleton set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">sval</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span>\n\n<span class=\"kd\">prefix</span> <span class=\"bp\">`!`</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">sval</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sval.incl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>For example, the infimum of a set of natural numbers in <code>noncomputable</code>, but we can erase this keyword using this type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Inf'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span><span class=\"n\">Inf</span> <span class=\"n\">s</span><span class=\"o\">},</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>The next ingredient is a typeclass similar to <code>decidable</code> that provides a computation (when one is available):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">computable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">compute</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">compute_spec</span> <span class=\"o\">:</span> <span class=\"n\">compute</span> <span class=\"bp\">∈</span> <span class=\"n\">v.s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sval.compute</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">computable</span> <span class=\"n\">v</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">computable.compute</span> <span class=\"n\">v</span>\n</code></pre></div>\n<p>For example, the infimum is computable if the set has decidable membership and if nonemptiness is decidable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">nat.Inf'_computable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"n\">s.nonempty</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">computable</span> <span class=\"o\">(</span><span class=\"n\">Inf'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">...</span> <span class=\"n\">something</span> <span class=\"n\">involving</span> <span class=\"n\">nat.find</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>It can also be computable if you know exactly what the set is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">nat.Inf'_interval</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">computable</span> <span class=\"o\">(</span><span class=\"n\">Inf'</span> <span class=\"o\">(</span><span class=\"n\">set.Ici</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Inf'</span><span class=\"o\">]⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Inf'</span> <span class=\"o\">(</span><span class=\"n\">set.Ici</span> <span class=\"mi\">100</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">compute</span>\n<span class=\"c1\">-- 100</span>\n</code></pre></div>",
        "id": 252677422,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631214057
    },
    {
        "content": "<p>By the way, <code>sval</code> is also known as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/erased\">docs#erased</a></p>",
        "id": 252677749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631214193
    },
    {
        "content": "<p>It's not the most convenient to work with, but there are a few interesting Lean-computable equivalences.</p>\n<ul>\n<li><code>set (!α) ≃ set α</code></li>\n<li><code>!set α ≃ set α</code></li>\n<li><code>!(Π (x : α), β x) ≃ (Π (x : α), !β x)</code> and <code>!(α → β) ≃ (α → !β)</code></li>\n</ul>\n<p>It's also a monad, so at least that's something.</p>",
        "id": 252677836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631214233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thanks, I knew there had to be something like this already.</p>",
        "id": 252677924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631214259
    },
    {
        "content": "<p>Here's a gist <a href=\"https://gist.github.com/kmill/a67dae0e6cdf8ff8897d37a0563f8d4b\">https://gist.github.com/kmill/a67dae0e6cdf8ff8897d37a0563f8d4b</a> with the experiment</p>",
        "id": 252678141,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631214345
    },
    {
        "content": "<p>(I'd wanted to try making some <code>computable</code> classes that would demonstrate you could use <code>ordset</code> as an intermediate representation when taking some unions of finsets, but I didn't get to it, if it's even possible.)</p>",
        "id": 252678454,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631214481
    },
    {
        "content": "<p>That's nice that <code>erased</code> erases its data -- I'd worried about whether <code>sval</code> would develop enormous symbolic representations.</p>",
        "id": 252678662,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631214571
    },
    {
        "content": "<p>One more example of <code>computable</code>, for noncomputable finite sets (showing only some illustrative definitions and lemmas):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">finset'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"n\">finset</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_union</span> <span class=\"o\">(</span><span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">⟨{</span><span class=\"n\">u</span> <span class=\"bp\">|</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">s.val</span> <span class=\"bp\">∪</span> <span class=\"n\">t.val</span> <span class=\"o\">}},</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_union</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">sval.incl</span> <span class=\"n\">_</span> <span class=\"bp\">↔</span> <span class=\"n\">_</span><span class=\"o\">,</span>  <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">computable</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">computable</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">computable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sval.incl</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sval.incl</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∪</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">compute</span>\n<span class=\"c1\">-- {1, 2, 3, 4}</span>\n</code></pre></div>\n<p>(This needs <code>a</code> and <code>b</code> to be reducible since it's relying on another instance that says anything created with <code>sval.incl</code> is computable.)</p>",
        "id": 252679708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631215018
    },
    {
        "content": "<p>This is pretty neat but it's worth considering the trade-off compared to something in the style of <code>norm_num</code> (or even <code>simp</code>). As an extreme example, in order to prove that a given number is composite, <code>norm_num</code> could invoke an external program to factor the number.</p>",
        "id": 252680314,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631215288
    },
    {
        "content": "<p>Also, <code>norm_num</code> is allowed to fail sometimes, while decidability instances generally can't, unless you do the bulk of the computation in the typeclass inference search itself</p>",
        "id": 252680550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631215388
    },
    {
        "content": "<p>The biggest advantage of something like <code>computable</code> is that you get a meta-level proof that there is an algorithm to compute the thing... but if you only really care about <em>actually computing</em> it then this isn't really necessary.</p>",
        "id": 252680554,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631215391
    },
    {
        "content": "<p>(this is basically the same as Mario's point that <code>norm_num</code> is allowed to fail)</p>",
        "id": 252680713,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631215473
    },
    {
        "content": "<p>Yeah, I don't think this is very useful for compile-time (the likes of <code>norm_num</code> and <code>simp</code>).  It seems like it could be useful for when you want to compile programs and want to be able to automatically select good-ish algorithms.</p>",
        "id": 252680790,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631215516
    },
    {
        "content": "<p>while also being able to use the standard mathematical definitions, which come with a whole library of lemmas</p>",
        "id": 252680840,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631215549
    },
    {
        "content": "<p>It's definitely an improvement over trying to make your algorithm be the definition, I think.</p>",
        "id": 252680922,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631215584
    },
    {
        "content": "<p>For example, for interval arithmetic computations on real numbers it is convenient to make the calculation blow up if you divide by zero, but that means that the space of successfully evaluating terms is very complicated and depends on the output of previous computations</p>",
        "id": 252680928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631215588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/252680554\">said</a>:</p>\n<blockquote>\n<p>The biggest advantage of something like <code>computable</code> is that you get a meta-level proof that there is an algorithm to compute the thing... but if you only really care about <em>actually computing</em> it then this isn't really necessary.</p>\n</blockquote>\n<p>This all applies to <code>decidable</code> too, right?</p>\n<p>One reason I was looking into this was to see whether <code>decidable</code> could feasibly be removed from all the mathematical definitions, and whether it could be relegated to <code>computable</code> instances.</p>",
        "id": 252682038,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631216098
    },
    {
        "content": "<p>Yes, <code>decidable</code> has roughly the same characteristics as <code>computable</code> here</p>",
        "id": 252682217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631216172
    },
    {
        "content": "<p><code>decidable</code> can't be removed from definitions with computational content, whether it is spelled <code>decidable</code> or <code>computable</code></p>",
        "id": 252682336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631216228
    },
    {
        "content": "<p>Note that your <code>finset'</code> definition does not make <code>finset</code> obsolete, because it depends on <code>finset</code></p>",
        "id": 252682523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631216307
    },
    {
        "content": "<p>the theorems about <code>finset</code> would continue to have all the same decidability assumptions</p>",
        "id": 252682551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631216326
    },
    {
        "content": "<p>I designed <code>computable</code> to be the <code>Type</code>-level version of <code>decidable</code> -- I meant the question rhetorically.</p>\n<p>And sure, I used <code>finset</code> to implement <code>finset'</code>, but I didn't have to.  The point of the example is that <code>finset</code> can be used as a computational backend to the classical notion of a finite set.  <code>finset</code> certainly needs its decidability assumptions.</p>",
        "id": 252683426,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631216689
    },
    {
        "content": "<p>It's not clear that we gain that much by having <code>finset'</code> though, compared to <code>open_locale classical</code> + <code>finset</code></p>",
        "id": 252683645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631216778
    },
    {
        "content": "<p>It's certainly possible to have a version of <code>finset</code> with no computational content; <code>finite</code> does basically that</p>",
        "id": 252683766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631216844
    },
    {
        "content": "<p>explicitly erasing computational content isn't usually that productive, since it just removes some <code>noncomputable</code> markings</p>",
        "id": 252683956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631216928
    },
    {
        "content": "<p>Based on your saying \"whether it is spelled <code>decidable</code> or <code>computable</code>\" I'm thinking what I said isn't clear:<br>\n<span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/252682038\">said</a>:</p>\n<blockquote>\n<p>One reason I was looking into this was to see whether <code>decidable</code> could feasibly be removed from all the mathematical definitions, and whether it could be relegated to <code>computable</code> instances.</p>\n</blockquote>\n<p>This is what I'm referring to specifically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">computable</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">computable</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">computable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>It's moving any trace of <code>decidable</code> from definitions and lemmas about mathematical definitions to descriptions of how you might compute them.</p>",
        "id": 252683960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631216930
    },
    {
        "content": "<p>This is also a much more precise way to give computational meaning to expressions, since you can make use of any additional typeclasses the types might satisfy.</p>",
        "id": 252684132,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631216995
    },
    {
        "content": "<p>It's still not good enough for e.g. selecting sparse matrix vs dense matrix representation, but sure, this works alright for <code>decidable</code></p>",
        "id": 252684635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631217102
    },
    {
        "content": "<p>so for example, get rid of <code>ite</code> with its <code>decidable</code> argument, and instead write a <code>computable</code> instance for it which carries the <code>decidable</code> hypothesis</p>",
        "id": 252684665,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631217115
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- ite, but without decidability -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ite'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">x.s</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">y.s</span><span class=\"o\">)},</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">x.val</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">y.val</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- When the proposition is decidable, compute the ite' with ite. -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">ite'.compute</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">computable</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">computable</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">computable</span> <span class=\"o\">(</span><span class=\"n\">ite'</span> <span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">ite</span> <span class=\"n\">c</span> <span class=\"n\">x.compute</span> <span class=\"n\">y.compute</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">ite'</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">{</span><span class=\"n\">contextual</span><span class=\"o\">:=</span><span class=\"n\">tt</span><span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 252684763,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631217151
    },
    {
        "content": "<p>This is using the <code>!</code> type, which is annoying -- I wish it were more seamless -- but in principle it seems to work.</p>",
        "id": 252684878,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631217210
    },
    {
        "content": "<p>I was thinking of a noncomputable version</p>",
        "id": 252684911,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631217227
    },
    {
        "content": "<p>You can write <code>ite'</code> more simply as <code>launder (by classical; exact ite c x y)</code> where <code>launder</code> is an identity function on <code>!α</code> that makes any term computable</p>",
        "id": 252684925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631217238
    },
    {
        "content": "<p>Proving these things can be annoying for recursive functions though</p>",
        "id": 252685296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631217408
    },
    {
        "content": "<p>I would rather come at this from the other direction: introduce <code>ite'</code> and use it only when the decidability argument gets in the way</p>",
        "id": 252685482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631217506
    },
    {
        "content": "<p>(and it would be defined simply as <code>by classical; exact ite c x y</code>, <code>noncomputable</code> notwithstanding)</p>",
        "id": 252685574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631217557
    },
    {
        "content": "<p>It would be nice if there were a way to coerce <code>noncomputable</code> terms to <code>!α</code>.  It's not clear to me how you'd do it without the coercion itself being <code>noncomputable</code>.</p>",
        "id": 252685772,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631217629
    },
    {
        "content": "<p>I didn't fully understand what <code>launder</code> was about -- did you mean it would be this coercion?</p>",
        "id": 252685897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631217684
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.erased</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">magic</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">magic'</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">magic</span> <span class=\"c1\">-- if we use it directly, it is noncomputable</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">magic''</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">magic.1</span><span class=\"o\">,</span> <span class=\"n\">magic.2</span><span class=\"o\">⟩</span> <span class=\"c1\">-- laundering it makes it computable</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">launder</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s.1</span><span class=\"o\">,</span> <span class=\"n\">s.2</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Using launder directly doesn't work, because lean doesn't unfold it</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">magic'''</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">launder</span> <span class=\"n\">magic</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">launder</span><span class=\"bp\">`</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s.1</span><span class=\"o\">,</span> <span class=\"n\">s.2</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- @[inline] also doesn't work (and lean 3 doesn't have macroInline), but a notation does</span>\n<span class=\"kd\">def</span> <span class=\"n\">magic''''</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">launder</span> <span class=\"n\">magic</span>\n</code></pre></div>",
        "id": 252687109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631218199
    },
    {
        "content": "<p>Oh, looks like <code>abbreviation</code> works, wasn't expecting that</p>",
        "id": 252688137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631218587
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , I found this thread by searching for \"nonconstructive <code>ite</code>\". Did anything like this end up getting added to mathlib? (I hope it's ok to respond to an old thread)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/252683645\">said</a>:</p>\n<blockquote>\n<p>It's not clear that we gain that much by having <code>finset'</code> though, compared to <code>open_locale classical</code> + <code>finset</code></p>\n</blockquote>\n<p>Quick comment -- I ran into problems a few weeks ago from trying to use <code>open_locale classical</code> + <code>finset</code>, problems coming from decidability diamonds. Basically the solution I was told was to explicitly provide decidability instances rather than using <code>open_locale classical</code>.</p>\n<p>I don't really understand decidability,  but (now that I'm trying to use it appropriately) I just ran into a similar kind of problem with two superficially identical <code>ite</code> expressions with different decidability instances. It would definitely be very nice to have a way to do this that doesn't involve any decidability at all.</p>",
        "id": 273931887,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1646291479
    },
    {
        "content": "<p>Yes, <code>open_locale classical</code> was an attempt to fix some decidability issues but now there are better ways (the rule of thumb is that if the statement of a declaration needs one then add it as an assumption, and if a proof needs one then use the <code>classical</code> tactic). This is what you do in the other thread but you still seem to get into problems :-/</p>",
        "id": 273939026,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646296390
    },
    {
        "content": "<p>I do appreciate your help <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 273939636,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1646296700
    }
]
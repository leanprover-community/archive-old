[
    {
        "content": "<p>Hello there, not sure if this is the right stream to ask this, but hopefully someone can point me in the right direction, I'm new to the community.</p>\n<p>I'm going through Donald Knuth's lovely book on Surreal Numbers and formalizing it as a learning exercise. In short, a surreal number is composed of a pair of sets of surreal numbers, and I'm struggling to express this in a simple way in Lean.</p>\n<p>Recursive structures don't seem to be supported. I then tried this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">surreal</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">surreal</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">surreal</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">surreal</span>\n</code></pre></div>\n<p>But it throws: <code>arg #1 of 'surreal.surreal.mk' has a non positive occurrence of the datatypes being declared</code></p>\n<p>It seems like this is fundamentally contradictory, which is fair enough.<br>\n<a href=\"#narrow/stream/116395-maths/topic/question.20about.20game.20theory/near/162067308\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/question.20about.20game.20theory/near/162067308</a></p>\n<p>I then instead tried this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">surreal</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">surreal</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">surreal</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">surreal</span>\n</code></pre></div>\n<p>But it also throws this, which I don't entirely understand: <code>inductive type being declared can only be nested inside the parameters of other inductive types</code></p>\n<p>I am aware the surreal numbers are already defined in mathlib. They are defined as a quotient type of pre-games, which is defined as a pair of sets of arbitrary type (the are not actually <code>set</code>s but <code>(t: Type*) -&gt; pgame</code> constructors).</p>\n<p>But for the time being, I'd like to make my own isolated definition of surreal numbers. Is there a simpler way to do this without having to resort to this rather convoluted pre-game construction?</p>",
        "id": 312811357,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669718009
    },
    {
        "content": "<p>I suppose a more abstract type will always be needed, since surreal numbers are not just a set of two sets of surreal numbers. All the left numbers need to be smaller than all the right numbers. This is defined in mathlib as <code>pgame.numeric</code>. And there's also an equivalence relation which can be naturally modelled as a quotient.</p>\n<p>Still it would be more ergonomic to have something like (just roughly):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">surreal</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">surreal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">surreal</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">surreal</span>\n</code></pre></div>",
        "id": 312814313,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669719016
    },
    {
        "content": "<p><code>inductive type being declared can only be nested inside the parameters of other inductive types</code> has to do with how Lean handles these sorts of nested types. It transforms the inductive type you're defining to be an equivalent one that doesn't mention the other inductive type. The problem with <code>finset</code> is that it's got a <code>quot</code> nested in there, which I guess it can't handle.</p>\n<p>For example, if you used ordered finite sets (a.k.a. lists) it works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">surreal</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">surreal</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">surreal</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">surreal</span>\n</code></pre></div>",
        "id": 312815602,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669719486
    },
    {
        "content": "<p>I think this should be equivalent to your <code>finset</code>-based <code>surreal</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">presurreal</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">presurreal</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">presurreal</span> <span class=\"bp\">→</span> <span class=\"n\">presurreal</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">presurreal_eqv</span> <span class=\"o\">:</span> <span class=\"n\">presurreal</span> <span class=\"bp\">→</span> <span class=\"n\">presurreal</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"n\">y</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">presurreal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">~</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">~</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">presurreal_eqv</span> <span class=\"o\">(</span><span class=\"n\">presurreal.mk</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">presurreal.mk</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">surreal</span> <span class=\"o\">:=</span> <span class=\"n\">quot</span> <span class=\"n\">presurreal_eqv</span>\n</code></pre></div>",
        "id": 312816119,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669719661
    },
    {
        "content": "<p>Oh, right, I forgot non-duplication</p>",
        "id": 312816165,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669719679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"568906\">Jon Ezeiza</span> has marked this topic as unresolved.</p>",
        "id": 312880893,
        "sender_full_name": "Notification Bot",
        "timestamp": 1669739193
    },
    {
        "content": "<p>I've kept persisting and trying many alternatives (most not workable), this is the best I've come up with so far, let me know what you think.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Rule 1: Every number corresponds to two sets of previously created numbers, such that no member of</span>\n<span class=\"cm\">the left set is greater than or equal to any member of the right set.</span>\n\n<span class=\"cm\">Rule 2: One number is less than or equal to another number if an only if no member of the first</span>\n<span class=\"cm\">number's left set is greater than or equal to the second number, and no member of the second</span>\n<span class=\"cm\">number's right set is less than or equal to the first number.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_surreal</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"n\">right</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">∈</span> <span class=\"n\">left</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">right</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">≥</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">surreal</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">le</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">left</span> <span class=\"n\">right</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">is_surreal</span> <span class=\"n\">α</span> <span class=\"n\">left</span> <span class=\"n\">right</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">∈</span> <span class=\"n\">left</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">≥</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">right</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">surreal</span>\n</code></pre></div>\n<p>It's quite a mess, maybe someone can propose some ways to make it less verbose.</p>\n<p>I've kept pushing because I feel like there is nothing fundamentally complex about the two rules that define surreal numbers. I'm trying to understand why they are so hard to encode directly in Lean, without having to define rather abstract auxiliary mathematical objects like <code>pgame</code> from mathlib.</p>\n<p>I understand that the core challenge is that the definition of the type requires a defined ordering, which in turn requires the type to be defined. It's hard to bootstrap it without another underlying type.</p>\n<p>I wonder if it is possible to define an inductive type whose constructors can only output valid surreal numbers with some smart composition operators. I've tried a few drafts but nothing conclusive so far. I still feel like there should be a way to express the two rules directly, they would be needed anyways to prove that such an inductive type works as intended.</p>",
        "id": 312884448,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669740152
    },
    {
        "content": "<p>It might be easier to define a set in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Set\">docs#Set</a> (ZFC sets). With ZFC sets, at least on paper, it's easy to make a set that's closed with respect to containing all ordered pairs of subsets. (You define a family of sets indexed by the natural numbers, each the closure of the previous, then take the union of all of these.)</p>",
        "id": 312887251,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669740899
    },
    {
        "content": "<p>Type theory doesn't have this sort of union, which seems to be the main difficulty.</p>\n<p>I guess you could use some of the category theory library for this, since you could take the colimit of a sequence of types that each have an inclusion into the next...</p>",
        "id": 312887676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669741015
    },
    {
        "content": "<p>Interesting, I'm not familiar with ZFC, I will take a look.</p>\n<p>So it is a fundamental limitation of type theory? Why do these two simple rules require anything more than the simple axiomatic definition of a set?</p>",
        "id": 312887997,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669741110
    },
    {
        "content": "<p>A type of surreal numbers exists, as evidenced by mathlib's surreal type. It can just be tricky getting to it; for example, the <code>inductive</code> command does what it can to try to create a type for you given your specification, but it's somewhat conservative. In principle, I think (in my ignorance as a non-type-theory-expert) there could be a more complicated command that could handle <code>quot</code> nesting.</p>",
        "id": 312888616,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669741260
    },
    {
        "content": "<p>Damn it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>, just wanted to have a chill time formalizing the nice Surreal Numbers book<br>\n<a href=\"https://www-cs-faculty.stanford.edu/~knuth/sn.html\">https://www-cs-faculty.stanford.edu/~knuth/sn.html</a></p>\n<p>It's rather simple maths in itself, but I understand it might be tricky to link it to the axiomatic foundations of Lean.<br>\nI think I'll just stop being stubborn, use the mathlib type and prove the books theorems on it, instead of trying to define it from scratch.</p>",
        "id": 312888786,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669741309
    },
    {
        "content": "<p>I'm just suggesting that in ZFC it might be easier because you can do unions of any set of sets. In type theory, you can't even ask whether two types are disjoint or not, so plain unions don't make sense.</p>",
        "id": 312888884,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669741330
    },
    {
        "content": "<p>I haven't looked at the book -- does Knuth <em>really</em> prove that surreals exist? Or is it just convincing enough that you bought into them?</p>",
        "id": 312889006,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669741371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312887251\">said</a>:</p>\n<blockquote>\n<p>it's easy to make a set that's closed with respect to containing all ordered pairs of subsets.</p>\n</blockquote>\n<p>I'm not sure I understand this; say the set is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>; then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, so that we should have for instance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>S</mi><mo separator=\"true\">,</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">(S, S) \\in S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>?</p>",
        "id": 312889150,
        "sender_full_name": "Reid Barton",
        "timestamp": 1669741414
    },
    {
        "content": "<p>Did you mean finite subsets?</p>",
        "id": 312889218,
        "sender_full_name": "Reid Barton",
        "timestamp": 1669741430
    },
    {
        "content": "<p>Can you critique the last draft I proposed. I can feel it's not right, but can you tell me what are the issues with it?</p>",
        "id": 312889227,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669741432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312822931\">said</a>:</p>\n<blockquote>\n<p>I think bogosort is when you <em>randomly</em> try permutations. This one is more principled, you try <em>all</em> of them <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.decidable_perm\">docs#list.decidable_perm</a> works by iterating through elements in the first list and for each element, looking for it in the second list, and removing it from both lists when found (and return false when not found). I think this is O(n^2) rather than O(n*n!).</p>",
        "id": 312889434,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669741484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"568906\">@Jon Ezeiza</span> If you use <code>finset</code> or <code>list</code> I think you only get the dyadic rationals, not even all rational numbers.</p>",
        "id": 312889542,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669741516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312889006\">said</a>:</p>\n<blockquote>\n<p>I haven't looked at the book -- does Knuth <em>really</em> prove that surreals exist? Or is it just convincing enough that you bought into them?</p>\n</blockquote>\n<p>I don't think so, I haven't finished it. It's not an academic book, it's framed as a conversation between two students. They find the definition \"in an ancient inscription\" and they have some fun developing the concept and proving a bunch of theorems. I thought it would be a pleasant introduction to the field, so I can bootstrap my knowledge to read the more formal works on surreal numbers, and possibly expand mathlib's coverage of the concept.</p>",
        "id": 312889888,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669741608
    },
    {
        "content": "<p>Since the definition <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Set\">docs#Set</a> involves quotient, I don't think you can use it to define inductive types like you can use <code>list</code>. (maybe I just don't understand how you intend to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Set\">docs#Set</a>)</p>",
        "id": 312890085,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669741666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Ah, I see my mistake, oops. Here's what I was thinking: set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">S_0=\\varnothing</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6633em;vertical-align:-0.0817em;\"></span><span class=\"mord amsrm\">∅</span></span></span></span> and for each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>S</mi><mi>n</mi></msub><mo>∪</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>∣</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>t</mi><mo>⊆</mo><msub><mi>S</mi><mi>n</mi></msub><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">S_{n+1}=S_n\\cup \\{(s,t)\\mid s,t\\subseteq S_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>. Then let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mo>⋃</mo><mi>n</mi></msub><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">S=\\bigcup_n S_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">⋃</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. Then, uh, that's a set! That contains just some subset of the surreals.</p>",
        "id": 312890304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669741714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312818644\">said</a>:</p>\n<blockquote>\n<ul>\n<li>define the surreals as well formed pgames and take a quotient to get extensionality (<code>surreal</code>)</li>\n</ul>\n</blockquote>\n<p>Notice that the equivalence relation on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame\">docs#pgame</a> is <code>a ≤ b ∧ b ≤ a</code> rather than extensionality (that's the equivalence relation on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet\">docs#pSet</a>).</p>",
        "id": 312890429,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669741750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312888884\">said</a>:</p>\n<blockquote>\n<p>I'm just suggesting that in ZFC it might be easier because you can do unions of any set of sets.</p>\n</blockquote>\n<p>Ah, this can't work. There's no set of all surreals (I wasn't really thinking about how they generalize ordinals).</p>",
        "id": 312891219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669741959
    },
    {
        "content": "<p>In set theory, there are \"bigger sets\" called proper classes. In Lean's type theory, there are types in higher type universes, like <code>Type 1</code> and above.</p>",
        "id": 312891457,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669742040
    },
    {
        "content": "<p>If anyone is interested, here's a great interview with Knuth about the book I'm going through<br>\n<a href=\"https://www.youtube.com/watch?v=mPn2AdMH7UQ\">https://www.youtube.com/watch?v=mPn2AdMH7UQ</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"mPn2AdMH7UQ\" href=\"https://www.youtube.com/watch?v=mPn2AdMH7UQ\"><img src=\"https://uploads.zulipusercontent.net/dc3a67133e0ecb0225c8decff6da82f7c8a02cf1/68747470733a2f2f692e7974696d672e636f6d2f76692f6d506e3241644d483755512f64656661756c742e6a7067\"></a></div>",
        "id": 312892026,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669742208
    },
    {
        "content": "<p>Hmm, I guess I don't even know how to state whether a set is a surreal number in the language of ZFC...</p>",
        "id": 312894936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669742995
    },
    {
        "content": "<p>With second-order logic you can at least define what it means for a proper class to have the properties of the surreals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.zfc.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_surreal_class</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(and of course this doesn't actually show there is such an <code>S</code>)</p>\n<p>Is there a first-order statement that says whether a given element of <code>Set</code> is a surreal though?</p>",
        "id": 312895743,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669743199
    },
    {
        "content": "<p>Isn't this a superset of surreals? Your class will include non-valid pairs of \"recursive sets\". Was that intended?</p>\n<blockquote>\n<p>such that no member of the left set is greater than or equal to any member of the right set</p>\n</blockquote>",
        "id": 312897441,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669743696
    },
    {
        "content": "<blockquote>\n<p>Hmm, I guess I don't even know how to state whether a set is a surreal number in the language of ZFC...</p>\n</blockquote>\n<p>You probably need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Set.has_well_founded\">docs#Set.has_well_founded</a> (axiom of regularity/foundation) and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.fix\">docs#well_founded.fix</a>. By the way I think you want <code>Set.pair a b</code> rather than <code>{a, b}</code> which is an unordered pair.</p>",
        "id": 312898464,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669743978
    },
    {
        "content": "<p>I guess that doesn't answer your question. Maybe take a look at <a href=\"https://en.wikipedia.org/wiki/Axiom_of_infinity#Alternative_method\">this Wikipedia page</a>, where the natural numbers is defined as the intersection of all inductive sets.</p>",
        "id": 312900345,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669744508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312900345\">said</a>:</p>\n<blockquote>\n<p>Maybe that doesn't answer your question. Maybe take a look at <a href=\"https://en.wikipedia.org/wiki/Axiom_of_infinity#Alternative_method\">this Wikipedia page</a>, where the natural numbers is defined as the intersection of all inductive sets.</p>\n</blockquote>\n<p>It doesn't, but I've always liked that trick.</p>",
        "id": 312900692,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669744611
    },
    {
        "content": "<p>This is a definition of surreal numbers similar to the definition of natural numbers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.zfc.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_surreal_class'</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">Set.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Set.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}⦄,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"bp\">∪</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.pair</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">surreal</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">Set.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Set.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"bp\">⋂₀</span> <span class=\"n\">is_surreal_class'</span> <span class=\"c\">/-</span><span class=\"cm\"> sorry for abusing defeq -/</span>\n</code></pre></div>",
        "id": 312903804,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669745506
    },
    {
        "content": "<p>Modulo defining the <code>lt</code> operation, that seems to give the <code>set</code> of surreals, but that's using second-order logic (it's quantifying over subsets of <code>Set</code>). Is there a first-order way to at least state that a given set is a surreal number?</p>",
        "id": 312904765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1669745775
    },
    {
        "content": "<p>I see. Your concern is whether the surreals is actually a class (i.e. definale in ZFC). The easiest way to show this I can see is to define the surreals born by day<code>o</code> for every (von Neumann) ordinal <code>o</code> by transfinite recursion (which probably requires axiom of replacement), then take the union over all von Neumann ordinals (which is indeed definable, a fact I under-appreciated). In fact, to show <code>is_surreal_class'</code> isn't empty, we probably need some construction like this.</p>",
        "id": 312909792,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669747351
    },
    {
        "content": "<p>Here's a really simple definition of the surreals in ZFC: <a href=\"https://us.metamath.org/mpeuni/df-no.html\">https://us.metamath.org/mpeuni/df-no.html</a></p>",
        "id": 312934835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669754776
    },
    {
        "content": "<p>the trick is to not use sets of pairs and instead use a different definition, involving sequences of <code>+</code> and <code>-</code> indexed by an ordinal</p>",
        "id": 312934973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669754824
    },
    {
        "content": "<p>the hard part is showing that this is isomorphic to the usual definition</p>",
        "id": 312935132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669754873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"568906\">Jon Ezeiza</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312889888\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312889006\">said</a>:</p>\n<blockquote>\n<p>I haven't looked at the book -- does Knuth <em>really</em> prove that surreals exist? Or is it just convincing enough that you bought into them?</p>\n</blockquote>\n<p>I don't think so, I haven't finished it. It's not an academic book, it's framed as a conversation between two students. They find the definition \"in an ancient inscription\" and they have some fun developing the concept and proving a bunch of theorems. I thought it would be a pleasant introduction to the field, so I can bootstrap my knowledge to read the more formal works on surreal numbers, and possibly expand mathlib's coverage of the concept.</p>\n</blockquote>\n<p>Ah, only now I reallize you are talking about Knuths book... Try \"ONAG\" - i.e. \"On numbers and games\" by Conway himself, that one provides the ground definitions (and doesn't even talk about set's - as he doesn't need much of the constructs of set theory to build games, of which the surreals form just a part).</p>\n<p>I think ONAG is the \"original\", Knuth his book followed later... but I haven't checked.</p>",
        "id": 313084681,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1669822020
    },
    {
        "content": "<p>I think Conway also take the left and right options to be sets of \"already constructed\" surreals/games, and transfinite recursion is the most straightforward interpretation in ZFC of such a construction, which isn't straightforward to formalize in Lean's type theory. I didn't check Knuth's book but from this thread I guess it's similar.</p>",
        "id": 313088736,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1669823107
    },
    {
        "content": "<p>Indeed, Knuth says \"two sets of previously created numbers\", here's the initial informal definition.</p>\n<blockquote>\n<p>Rule 1: Every number corresponds to two sets of previously created numbers, such that no member of<br>\nthe left set is greater than or equal to any member of the right set.</p>\n</blockquote>\n<blockquote>\n<p>Rule 2: One number is less than or equal to another number if an only if no member of the first<br>\nnumber's left set is greater than or equal to the second number, and no member of the second<br>\nnumber's right set is less than or equal to the first number.</p>\n</blockquote>",
        "id": 313467650,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669976784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/defining.20surreal.20numbers/near/312889006\">said</a>:</p>\n<blockquote>\n<p>I think ONAG is the \"original\", Knuth his book followed later... but I haven't checked.</p>\n</blockquote>\n<p>Kinda, Knuth's book was technically written first. They had a lunch where Conway explained the rough ideas and wrote the axioms in a napkin, then Knuth independently derived a chunk of the theory for his informal book before Conway finished his.</p>\n<p>The full context is explained here:<br>\n<a href=\"https://www.youtube.com/watch?v=mPn2AdMH7UQ\">https://www.youtube.com/watch?v=mPn2AdMH7UQ</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"mPn2AdMH7UQ\" href=\"https://www.youtube.com/watch?v=mPn2AdMH7UQ\"><img src=\"https://uploads.zulipusercontent.net/dc3a67133e0ecb0225c8decff6da82f7c8a02cf1/68747470733a2f2f692e7974696d672e636f6d2f76692f6d506e3241644d483755512f64656661756c742e6a7067\"></a></div>",
        "id": 313468530,
        "sender_full_name": "Jon Ezeiza",
        "timestamp": 1669977017
    }
]
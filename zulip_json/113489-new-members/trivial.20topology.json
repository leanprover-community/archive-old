[
    {
        "content": "<p>Hello, this is another easy exercise that I got stuck on. Any hints on solving the sorry? It boils down to doing cases on <code>S ⊆ {∅, univ}</code> I think, but I don't know how to go about it in Lean.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">topology</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">has_univ</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_sUnion</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">τ</span><span class=\"o\">,</span> <span class=\"bp\">⋃₀</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_inter</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U₁</span> <span class=\"n\">U₂</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">,</span> <span class=\"n\">U₁</span> <span class=\"bp\">∩</span> <span class=\"n\">U₂</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">trivial_topology</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span>\n  <span class=\"n\">τ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">},</span>\n  <span class=\"n\">has_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">has_sUnion</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">has_inter</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finish</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 214049183,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603286961
    },
    {
        "content": "<p>This might be considered overkill but I think I would first prove a lemma like <code>s ∈ {∅, univ} &lt;-&gt; \\ex p, (\\all x, (x ∈ s) &lt;-&gt; p)</code></p>",
        "id": 214050133,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603287387
    },
    {
        "content": "<p>I'd probably use a structure like <code> has_sUnion := by { rintros S hs, by_cases univ ∈ S, sorry },</code></p>",
        "id": 214050994,
        "sender_full_name": "Andreas Steiger",
        "timestamp": 1603287790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/trivial.20topology/near/214050133\">said</a>:</p>\n<blockquote>\n<p>This might be considered overkill but I think I would first prove a lemma like <code>s ∈ {∅, univ} &lt;-&gt; \\ex p, (\\all x, (x ∈ s) &lt;-&gt; p)</code></p>\n</blockquote>\n<p>Did you mean <code>s ⊆ {∅, univ} &lt;-&gt; \\ex p, (\\all x, (x ∈ s) &lt;-&gt; p)</code>? Cuz it doesn't check out haha</p>",
        "id": 214052013,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603288247
    },
    {
        "content": "<p>No</p>",
        "id": 214052107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603288313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303635\">Andreas Steiger</span> <a href=\"#narrow/stream/113489-new-members/topic/trivial.20topology/near/214050994\">said</a>:</p>\n<blockquote>\n<p>I'd probably use a structure like <code> has_sUnion := by { rintros S hs, by_cases univ ∈ S, sorry },</code></p>\n</blockquote>\n<p>I got as far as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">has_sUnion</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">S</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">univ</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n</code></pre></div>\n\n<p>left with the goal, which seems sooo close. but im completely lost</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">ℚ</span><span class=\"o\">),</span>\n<span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">},</span>\n<span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">,</span>\n<span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">},</span>\n<span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">univ</span><span class=\"o\">},</span>\n<span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 214052337,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603288423
    },
    {
        "content": "<p>Reid is suggesting that an arbitrary union of subsets corresponding to constant predicates is also a subset corresponding to a constant predicate.</p>",
        "id": 214052851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603288634
    },
    {
        "content": "<p>Using <code>by_cases</code> you shouldn't need to do all 4, because every <code>by_cases</code> splits up in 2 anyway. If you do <code>by_cases univ ∈ S</code>, you get two goals: Prove the statement if <code>univ \\in S</code>, and prove the statement if <code>univ \\notin S</code>. These should suffice, no need to split up further.</p>",
        "id": 214052894,
        "sender_full_name": "Andreas Steiger",
        "timestamp": 1603288658
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">∨</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">∨</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"bp\">;</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hS</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">finish</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">finish</span> <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hS</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">finish</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">finish</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hS</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">finish</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">finish</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 214055628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603289811
    },
    {
        "content": "<p>Of course it would be rather less fun doing this for a set of size 4. For some stuff like this there are tactics, e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#fin_cases\">tactic#fin_cases</a>, but I'm not sure about this one.</p>",
        "id": 214055871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603289925
    },
    {
        "content": "<p>Omg this is awesome! Thank you all so much, now I got two ways to prove it!</p>\n<p>Also, what I meant by 'couldn't check out' was I didn't know how to fix the error that lean kept giving. Turns out that it just couldn't guess the type of {∅, univ}, not that I doubted your lemma hahah no idea how you came up with it but it's amazing.</p>",
        "id": 214056432,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603290193
    }
]
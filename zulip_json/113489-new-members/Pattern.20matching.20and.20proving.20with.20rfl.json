[
    {
        "content": "<p>[Lean4]</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">nat.add</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span> <span class=\"c1\">-- removing this case makes the theorem below work</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">nat.add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">nat.zero</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- type mismatch</span>\n</code></pre></div>\n<p>I understand the second case in my nat.add is unnecessary, but why does it result in the theorem not being provable by rfl anymore? <code>a + zero = a</code> is still true by definition in the add function.</p>",
        "id": 238084136,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1620619262
    },
    {
        "content": "<p>Also is there any reason why the pattern matching in the induction doesn't accept parentheses around (succ a)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">zero_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">zero</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>  <span class=\"c1\">-- error with \"(succ a) c\" but not with \"succ a c\"</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_succ</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 238085705,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1620620977
    },
    {
        "content": "<p>My guess for the first question (which I could check if I was sitting in front of lean) is that like lean 3 when you do random matches like you're doing, the equation compiler has to make some sense of what's going on and so will probably just end up splitting into the obvious four cases internally, meaning that aou'll have to do cases on a before refl will work</p>",
        "id": 238095087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620629925
    },
    {
        "content": "<p>Think about it this way: you defined zero+succ(b) twice and so you can't expect to predict which choice is the one which is true by definition, which then means that you can't expect to predict what is going on by definition more generally</p>",
        "id": 238095341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620630072
    },
    {
        "content": "<p>I've just tried to verify my claim with Lean 4 and unlike with Lean 3 I don't know how to do it. In <code>mathlib4_experiments</code> there is <code>#print prefix</code> but it only gives this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">nat.add</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"n\">nat.add._cstage1</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"n\">nat.add._cstage2</span> <span class=\"o\">:</span> <span class=\"n\">_obj</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span>\n<span class=\"n\">nat.add._sunfold</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"n\">nat.add._unsafe_rec</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"n\">nat.add.match_1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"n\">nat.zero</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n      <span class=\"o\">((</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">nat.zero</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"n\">nat.add.match_1._cstage1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"n\">nat.zero</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n      <span class=\"o\">((</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">nat.zero</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"n\">nat.add.match_1._cstage2</span> <span class=\"o\">:</span> <span class=\"n\">_neutral</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span>\n<span class=\"n\">nat.add.match_1._rarg._cstage2</span> <span class=\"o\">:</span> <span class=\"n\">_obj</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span> <span class=\"bp\">→</span> <span class=\"n\">_obj</span>\n</code></pre></div>",
        "id": 238098605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620632122
    },
    {
        "content": "<p>In Lean 3 you get <code>equation compiler error, equation #2 has not been used in the compilation (possible solution: delete equation)</code></p>",
        "id": 238098837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620632282
    },
    {
        "content": "<p>PS can you fix your example so it's a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? You haven't defined notation <code>+</code> but you're using it.</p>",
        "id": 238098983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620632364
    },
    {
        "content": "<p>Lean 4 is not (yet) generating equation lemmas for definitions</p>",
        "id": 238103867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620635000
    }
]
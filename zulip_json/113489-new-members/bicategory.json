[
    {
        "content": "<p>In these days I write a formalization of bicategories. I have finished writing a proof that the collection of pseudofunctors between bicategories have a bicategory structure, so I would like to PR it to mathlib. </p>\n<p>When writing basic lemmas on bicategories, almost all  lines are copied from <code>category_theory/monoidal/category.lean</code>. I added 0-morphisms and replaced tensors with left and right whiskerings.</p>\n<p>Currently, I use the following notations</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixr</span> <span class=\"bp\">`◃`</span><span class=\"o\">:</span> <span class=\"mi\">70</span><span class=\"o\">:</span> <span class=\"bp\">=</span> <span class=\"n\">bicategory.whisker_left</span>\n<span class=\"kd\">infixr</span> <span class=\"bp\">`▹`</span><span class=\"o\">:</span> <span class=\"mi\">70</span><span class=\"o\">:</span> <span class=\"bp\">=</span> <span class=\"n\">bicategory.whisker_right</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">α_</span><span class=\"bp\">`</span><span class=\"o\">:</span> <span class=\"bp\">=</span> <span class=\"n\">bicategory.associator</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`λ</span><span class=\"n\">_</span><span class=\"bp\">`</span><span class=\"o\">:</span> <span class=\"bp\">=</span> <span class=\"n\">bicategory.left_unitor</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">ρ_</span><span class=\"bp\">`</span><span class=\"o\">:</span> <span class=\"bp\">=</span> <span class=\"n\">bicategory.right_unitor</span>\n</code></pre></div>\n<p>that are used in the nlab (<a href=\"https://ncatlab.org/nlab/show/bicategory\">https://ncatlab.org/nlab/show/bicategory</a>), but I'm not sure if this is good or not.</p>",
        "id": 265897077,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1640250822
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, who also formalized bicategories</p>",
        "id": 265897225,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640250908
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span>, I just noticed your <a href=\"https://github.com/leanprover-community/mathlib/compare/bicategory-functor\">bicategory-functor</a> branch by accident and want you know about my ongoing work at <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecd\">lax_grothendieck</a>, where I defined <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-fcba77084af1e1dafef32f2c3674793f357a0495bad381534804a4c025ce28de\">lax functors</a> from a 1-category to the 2-category of categories <code>Cat</code>, and use it to make the Grothendieck construction of fibration of categories. I see a few issues that would prevent my branch from using your development, and I hope you have these in mind during your development:</p>\n<p>(1) you only defined pseudofunctors and not general lax functors, i.e. you require map_id and map_comp to be <code>iso</code>s, but I think the more general lax functors are preferable, and shouldn't take much more effort; my earlier idea is to make the structure <code>pseudofunctor</code> by extending <code>lax_functor</code> by the <code>is_iso</code> conditions, but now I think we don't need to define <code>pseudofunctor</code> separately, and can just rely on the type class mechanism to infer the <code>is_iso</code> instances for <code>map_id</code> and <code>map_comp</code>. In fact in my construction of colimits in Grothendicek categories, only <code>map_comp</code> is required to be iso.</p>\n<p>(2) The direction of your <code>map_id</code> and <code>map_comp</code> are in the opposite direction to mine. Your direction agrees with nLab, but mine is the natural direction to make the Grothendieck construction in the current form. (I am refactoring the existing Grothendieck construction that only applied to strict functors, and the old setup forces me to adopt this direction.)</p>\n<p>Thanks for your work and your consideration!</p>",
        "id": 266573274,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641068048
    },
    {
        "content": "<p>Thank you for the comments and letting me know about your ongoing work <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> !  I was a little hesitant to use <code>is_iso</code> because it doesn't have the inverse as data, but I'll try to use it.  My choice of the directions of <code>map_id</code> and <code>map_comp</code> was completely random, and I have no idea which direction should be chosen for pseudofunctors. (A similar choice appears in the definition of pseudonatural transformations.)</p>",
        "id": 266579376,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1641076137
    },
    {
        "content": "<p>I think the Yoneda lemma for bicategories needs <code>pseudofunctor</code> as a structure.</p>",
        "id": 266579505,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1641076308
    },
    {
        "content": "<p>I think it might be worthwhile to define pseudofunctors with isos instead of is_iso for exactly the reason that sometimes it may be useful to have the inverse as data. Besides, if we have lax pseudofunctors, we would presumably also want oplax pseudofunctors, so choosing one direction doesn't make much sense.</p>",
        "id": 266579687,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641076511
    },
    {
        "content": "<p>I don't think we need oplax functors for the same reason we don't need contravariant functors; it makes no sense to duplicate the functor API. Oplax can be obtained from lax by taking opposites of the same categories (the fiber categories in the Grothendieck construction case).</p>",
        "id": 266579940,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641076858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"438192\">Yuma Mizuno</span> <a href=\"#narrow/stream/113489-new-members/topic/bicategory/near/266579505\">said</a>:</p>\n<blockquote>\n<p>I think the Yoneda lemma for bicategories needs <code>pseudofunctor</code> as a structure.</p>\n</blockquote>\n<p>If that's the case then indeed that would be a reason to introduce the structure. Literature suggests that we also need pseudofunctor to show the projection functor from the Grothendieck construction is a Grothendieck fibration of categories, which I plan to do after the colimit work.</p>",
        "id": 266579961,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641076896
    },
    {
        "content": "<p>And by the way, I did come up with an example of lax natural transformation in my colimit work: <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecdR242\">https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecdR242</a></p>",
        "id": 266580054,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641077041
    },
    {
        "content": "<p>My direction of arrows is natural in the sense that if we have colimits in the base and fiber categories, then we get colimits in the total (Grothendieck) category, and it also agrees with the old Grothendieck construction. <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span> 's direction would lead straightforwardly to PresheafedSpace and alike, but there we need colimits in the base category and limits in the fiber categories to get colimits in the total category (e.g. PresheafedSpace).</p>",
        "id": 266580369,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641077449
    },
    {
        "content": "<p>Also, the <code>inv</code> in an <code>iso</code> here isn't actually data, as it's uniquely determined by the <code>hom</code>. In general I think it's OK to replace sugsingletons with Props, except maybe for the purpose of defeq. e.g. <code>is_limit</code> could be made a Prop (in fact <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.presheaf.is_sheaf\">docs#Top.presheaf.is_sheaf</a> is defined as <code>nonempty is_limit</code>), but <code>is_left_adjoint</code> is actually data. When I get to work on Grothendieck fibrations, I'd probably make <code>is_fibration</code> carry the data of a cleavage.</p>",
        "id": 266581545,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641079089
    },
    {
        "content": "<p>There are times where it's very useful to be able to actually use the definition of an inverse. There is a reason why we have both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso\">docs#category_theory.iso</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso\">docs#category_theory.is_iso</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.equivalence\">docs#category_theory.equivalence</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_equivalence\">docs#category_theory.is_equivalence</a> (edit: this is not a great example, since the inverse is part of this structure), and even why <code>has_inv</code> is required for a group structure.</p>",
        "id": 266582196,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641079741
    },
    {
        "content": "<p>We have <code>equiv</code> and <code>function.bijective</code></p>",
        "id": 266582211,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641079775
    },
    {
        "content": "<p>category.equivalence is not a good example also because the inverse is only unique up to isomorphism. Maybe you can come up with examples where the inverse of map_id or map_comp are useful? In all examples I have in mind they're either eq_to_hom or eq_to_hom transferred across adjunction in an abstract way, and only one direction is needed to define the category structure on the Grothendieck construction. If you want to use the definition of the inverse, you could show <code>exists.some</code> is equal to the definition and rewrite, barring defeq issues.</p>",
        "id": 266582981,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641081143
    },
    {
        "content": "<p>I updated <a href=\"https://github.com/leanprover-community/mathlib/compare/bicategory-functor\">bicategory-functor</a> and changed <code>iso</code> to <code>hom</code> in the definition.  I think it is not a bad idea to start with <code>hom</code> instead of <code>iso</code> as a first step, whether or not we really need pseudofunctors. I also reversed the directions of <code>hom</code> s in the definition, in the hope that it will fit well <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> 's ongoing work.</p>",
        "id": 266628422,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1641150594
    },
    {
        "content": "<p>By the way, 2-categories have two types of opposites. I don't have a good idea for implementation of these concepts. My naive idea is to duplicate the contents in <a href=\"https://leanprover-community.github.io/mathlib_docs/data/opposite.html\">data/oppoiste</a>.</p>",
        "id": 266628842,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1641151248
    },
    {
        "content": "<p>Currently if a type C carries a category instance, then C^op carries the opposite category instance. I think in order to make four types to carry the four possible opposite bicategory instances, we would need to introduce another ^op operation that yields a new type given an old type, possibly called ^hop for \"hom op\" (I think that name isn't taken yet), which only reverses arrows in the hom categories. But we would face the problem that (C^op)^hop is not the same as (C^hop)^op, which is similar to the problem that +1 and -1 don't commute definitionally when people attempted to define chain complexes. But I think it's not too bad as we can show they are equivalent, like the equivalence between C and (C^op)^op already in mathlib.</p>",
        "id": 266651584,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641185557
    },
    {
        "content": "<p>I think would occasionally be hard to rewrite because of dependent type issues.<br>\nWould it be possible for a pseudofunctor to accept a field of a nat_iso and a proof that the two are equal?<br>\nThe same thing could probably also be tried on the monoidal category library.</p>",
        "id": 266651922,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641186049
    },
    {
        "content": "<p>To Yuma Mizuno: I see you encountered issues with \"obviously\" from your commit messages. I think they can sometimes be useful, but sometimes they produce timeouts. When it timeouts, you can just supply the field with a faster explicit proof to avoid the timeout. Sometimes when you just finish the definition of earlier fields but has not supplied some \"obvious\" fields, the orange bar may take a long time to disappear, which indicates that Lean is trying to fill in the \"obvious\" fields, and once you add <code>, some_field_name := ,</code> indicating you're gonna supply <code>some_field_name</code> explicitly, the orange bar may disappear much faster. So in general I think removing \"obviously\" doesn't buy you anything and you should try to keep them, if there're no issues that I'm unaware of.</p>",
        "id": 266652018,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641186222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113489-new-members/topic/bicategory/near/266651922\">said</a>:</p>\n<blockquote>\n<p>I think would occasionally be hard to rewrite because of dependent type issues.</p>\n</blockquote>\n<p>At least when the target of the pseudo/oplax functor is Cat, map_id and map_comp are nat_iso / nat_trans and rewriting won't break the .app ... It may be best to wait until when we actually use the inverses (like the Yoneda lemma) to decide which approach to adopt.</p>",
        "id": 266652946,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641187712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/bicategory/near/266652018\">said</a></p>\n<blockquote>\n<p>So in general I think removing \"obviously\" doesn't buy you anything and you should try to keep them, unless there're issues that I'm unaware of.</p>\n</blockquote>\n<p>The timeout I encountered occurred when defining oplax functors by the structure command. In a new commit I succeeded in preserving <code>obviously</code> by adding an auxiliary definition for a long equation in the axiom of oplax functors. This seems to work well because <code>restate axiom</code> automatically expands the auxiliary definitions and generates a desired lemma.</p>",
        "id": 266657626,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1641194763
    },
    {
        "content": "<p>I've written down a definition of bicategories in terms of the composition functor; this shortens the definition by encapsulating many axioms into properties of functors and natural transformations. However, the pentagon and triangle axioms are quite lengthy when expressed as equality of natural transformations, and it may be easier to write them down as equality between the .app after ≫, ◁, ▷ are defined in terms of the composition functor. For simplicity I replaced isos with homs.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.products.associator</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">universes</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kd\">class</span> <span class=\"n\">bicategory</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hom_category</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">tactic.apply_instance</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n<span class=\"c1\">-- encompass `whisker_left_(id,comp), whisker_right_(id,comp), whisker_exchange (category.theory.bifunctor.diagonal)`</span>\n<span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">⟶</span>\n   <span class=\"n\">prod.associator</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">⋙</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"c1\">-- encompass naturality</span>\n<span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_unitor</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prod.sectr</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">⋙</span> <span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right_unitor</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">prod.sectl</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"c1\">-- encompass naturality</span>\n<span class=\"o\">(</span><span class=\"n\">pentagon</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">let</span>\n  <span class=\"n\">l1</span> <span class=\"o\">:=</span> <span class=\"n\">whisker_right</span> <span class=\"o\">(</span><span class=\"n\">nat_trans.prod</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">d</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n  <span class=\"n\">l2</span> <span class=\"o\">:=</span> <span class=\"n\">whisker_left</span> <span class=\"o\">((</span><span class=\"n\">prod.associator</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">⋙</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n  <span class=\"n\">l3</span> <span class=\"o\">:=</span> <span class=\"n\">whisker_left</span> <span class=\"o\">((</span><span class=\"n\">prod.associator</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">prod.associator</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">whisker_right</span> <span class=\"o\">(</span><span class=\"n\">nat_trans.prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">e</span><span class=\"o\">)),</span>\n  <span class=\"n\">r1</span> <span class=\"o\">:=</span> <span class=\"n\">whisker_left</span> <span class=\"o\">(((</span><span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n  <span class=\"n\">r2</span> <span class=\"o\">:=</span> <span class=\"n\">whisker_left</span> <span class=\"o\">(</span><span class=\"n\">prod.associator</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">⋙</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n  <span class=\"k\">in</span> <span class=\"n\">l1</span> <span class=\"bp\">≫</span> <span class=\"n\">l2</span> <span class=\"bp\">≫</span> <span class=\"n\">l3</span> <span class=\"bp\">=</span> <span class=\"n\">r1</span> <span class=\"bp\">≫</span> <span class=\"n\">r2</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">triangle</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">let</span>\n  <span class=\"n\">l1</span> <span class=\"o\">:=</span> <span class=\"n\">whisker_left</span> <span class=\"o\">((</span><span class=\"n\">prod.sectl</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n  <span class=\"n\">l2</span> <span class=\"o\">:=</span> <span class=\"n\">whisker_right</span> <span class=\"o\">(</span><span class=\"n\">nat_trans.prod</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">left_unitor</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n  <span class=\"n\">l1</span> <span class=\"bp\">≫</span> <span class=\"n\">l2</span> <span class=\"bp\">=</span> <span class=\"n\">whisker_right</span> <span class=\"o\">(</span><span class=\"n\">nat_trans.prod</span> <span class=\"o\">(</span><span class=\"n\">right_unitor</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 267164303,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641545305
    },
    {
        "content": "<p>I don't know if this is a simplification for what you want to do with them, though. I'll look into applying this approach to lax functors tomorrow. Note: the <code>let</code> expressions above are necessary, since if you substitute them in, you'd encounter unification errors and would have to insert <code>≫ eq_to_hom (by exact rfl)</code>.</p>",
        "id": 267164873,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641545769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/bicategory/near/267164303\">said</a>:</p>\n<blockquote>\n<p>For simplicity I replaced isos with homs. (Are such bicategories ever studied in the literature?)</p>\n</blockquote>\n<p>I found they are called skew bicategories in <a href=\"https://arxiv.org/abs/1408.4953\">https://arxiv.org/abs/1408.4953</a>.</p>",
        "id": 267210874,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1641573613
    },
    {
        "content": "<p>I've been able to define oplax functors in terms of <code>map</code> functors, <code>map_id</code> morphisms, and <code>map_comp</code> natural transformations, <a href=\"https://gist.github.com/alreadydone/f0636484e3f0d8b2110cf72ab8343c9a\">posted as a gist</a>.<br>\nHowever, it seems Lean core typechecking is very slow on the map_unitor's, and I get deterministic timeouts unless one of the map_unitor's is commented out. The problem is probably that <code>curry_obj</code> is not defined in terms of <code>sectr</code>, so a lot unfolding is necessary for Lean to see that things are defeq. In contrast, <code>map_associator</code> is parsed/checked very quickly, though I didn't add any <code>obviously</code>. An interesting observation is that unlike the <code>.app</code>/componentwise version in <a href=\"https://github.com/leanprover-community/mathlib/pull/11277\">#11277</a>, in the nat_trans version I must insert <code>t</code> between <code>r1</code> and <code>r23</code>, because the two functors aren't defeq (but are in fact equal): on object level they're actually defeq, so <code>{ app := λ _, 𝟙 _ }</code> is a nat_trans between them, and that's why you don't need to insert <code>t</code> in the componentwise version; on the map level, their equality depends on <code>functor.map_id</code> of the functor <code>map a a</code> (or <code>map b b</code>). In contrast, <code>functor.map_comp</code> isn't required to state the three equalities.</p>",
        "id": 267275565,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641617374
    },
    {
        "content": "<p>Can you insert an identity somewhere to prevent the unfolding? If you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">my_target_is_X</span> <span class=\"bp\">≫</span> <span class=\"n\">my_source_is_X_but_this_needs_heavy_unfolding</span>\n</code></pre></div>\n<p>Then you can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Im_just_id</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">complicated_version_of_X</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span>\n\n<span class=\"n\">my_target_is_X</span> <span class=\"bp\">≫</span> <span class=\"n\">Im_just_id</span> <span class=\"bp\">≫</span> <span class=\"n\">my_source_is_X_but_this_needs_heavy_unfolding</span>\n</code></pre></div>\n<p>Now, if you use <code>Im_just_id</code> multiple times, you've won something. Because you've replaced many heavy rfls by 1 single heavy rfl.</p>",
        "id": 267278999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641622003
    },
    {
        "content": "<p>There's one heavy rfl in the <code>r23</code> in the definition of <code>map_left_unitor</code> and a heavy rfl in the <code>r23</code>in the definition of <code>map_right_unitor</code>, and in each case it appears just once. Of course once the structure <code>oplax_functor</code> is defined, these rfls will be used implicitly whenever you construct a <code>oplax_functor</code>.</p>",
        "id": 267279583,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641623119
    },
    {
        "content": "<p>I think introducing </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">sectr_functor</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span> <span class=\"bp\">×</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"n\">sectr</span> <span class=\"n\">Z</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>in category_theory/products/basic and using it instead of <code>curry_obj</code> would help, and moreover <code>curry_obj</code> can be defined in terms of it, but refactoring it will be a bigger project as currying.lean is imported by four files...</p>",
        "id": 267279695,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641623393
    },
    {
        "content": "<p>today I learned <code>𝟭 C ⋙ F</code> is defeq to <code>F ⋙ 𝟭 D</code>, but neither is defeq to <code>F</code> (as I knew before, and associativity of functor composition is also defeq)...</p>",
        "id": 267282406,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641628041
    },
    {
        "content": "<p>I thought that equality of functors was evil?</p>",
        "id": 267285347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641632472
    },
    {
        "content": "<p>In the <a href=\"https://gist.github.com/alreadydone/f0636484e3f0d8b2110cf72ab8343c9a/revisions#diff-6503605aad4153f5a02d893d06c9c9bf69c76577b3678d1c37af22fc8777afb0L58\"><code>map_left_unitor</code> equality</a>, the type of the target of the left hand side is <code>𝟭 (a ⟶ b) ⋙ map a b</code>, while for the right hand side it is <code>map a b ⋙ 𝟭 (obj a ⟶ obj b)</code>, so it works \"by accident\". I could append unitors (and also insert associators) as is done in <a href=\"https://github.com/leanprover-community/mathlib/blob/b1955dcaac4bd7ce126c3466b251fd13557ece1d/src/category_theory/adjunction/basic.lean#L208\">triangle identities in adjunction</a>, but that feels unnecessary and cumbersome to me, and in my tests it doesn't speed things up. Using <code>sectr_functor</code> or using <code>bicategory.id</code> directly instead of the notation <code>𝟙</code> of the <code>category_structure</code> instance constructed from <code>bicategory</code> also does little to speed.</p>\n<p>The strange thing I observed is that things get slower inside <code>structure</code>. After I introduce <a href=\"https://gist.github.com/alreadydone/f0636484e3f0d8b2110cf72ab8343c9a#file-bicategory_functor-lean-L59\">auxiliary definitions</a>, the <code>structure</code> itself speeds up to ~28s (no longer timeouts). Stuff outside of <code>structure</code> are fast:</p>\n<p>parsing took 3.16ms<br>\n<strong>elaboration of map_associator_aux took 439ms</strong><br>\ntype checking of map_associator_aux took 352ms<br>\ndecl post-processing of map_associator_aux took 0.12ms<br>\ncompilation of category_theory.map_associator_aux took 2.06ms</p>\n<p>parsing took 1.92ms<br>\n<strong>elaboration of map_left_unitor_aux took 3.63s</strong><br>\ntype checking of map_left_unitor_aux took 133ms<br>\ndecl post-processing of map_left_unitor_aux took 0.142ms<br>\ncompilation of category_theory.map_left_unitor_aux took 2.65ms</p>\n<p>parsing took 1.86ms<br>\n<strong>elaboration of map_right_unitor_aux took 3.54s</strong><br>\ntype checking of map_right_unitor_aux took 164ms<br>\ndecl post-processing of map_right_unitor_aux took 0.13ms<br>\nelaboration: tactic compilation took 0.474ms</p>\n<p>But if I inline <code>map_associator</code>, the <code>structure</code> slows down from ~28s to ~47s. With both <code>map_associator</code> and <code>map_left_unitor</code> inlined, it slows down to ~86s, but if you do <code>by { clear map_associator, exact ... }</code> when defining <code>map_left_unitor</code>, then it speeds up to ~49s; so it seems earlier fields will interfere and slow down later fields even when the later field doesn't depend on the earlier field.</p>",
        "id": 267346882,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1641718704
    },
    {
        "content": "<p>I'm trying to adapt my lax_grothendieck branch to the new bicategory API, but I immediately run into a problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.bicategory.locally_discrete</span>\n<span class=\"kd\">universes</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">bicategory.</span><span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">f</span> <span class=\"bp\">⟶</span> <span class=\"n\">f</span>  <span class=\"c1\">-- : Type v</span>\n</code></pre></div>\n<p>while if we import <code>basic</code> instead of <code>locally_discrete</code>, then <code>f ⟶ f</code> will be of <code>Type w</code>, which is what we want. The problem is that once <code>locally_discrete</code> is imported, then <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/bicategory/locally_discrete.html#category_theory.locally_discrete.quiver.hom.category_theory.small_category\">this instance</a> takes precedence, even though <code>X Y : C</code> not <code>X Y : locally_discrete C</code>. How should we avoid this? Make <code>locally_discrete</code> irreducible?</p>\n<p>Making the instance take a [category C] instead of [category_struct C] would solve this particular example, but if C is a strict bicategory, then we get a [category C] instance and so C would still be endowed with the locally_discrete bicategory structure instead of the original one. I wonder why <code>discrete_category</code> doesn't suffer from this problem. This works as intended:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.discrete_category</span>\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">discrete</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"c1\">-- Type v</span>\n<span class=\"k\">#check</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span> <span class=\"c1\">-- Type u</span>\n</code></pre></div>",
        "id": 270871119,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644125637
    },
    {
        "content": "<p>Making <code>locally_discrete</code> irreducible should work (or more precisely, doing whatever we do for <code>opposite</code>). I'm not sure why this is necessary, though--I thought that ordinary <code>def</code>s should not get unfolded during instance search, but with traces enabled it's clear that <code>locally_discrete</code> is getting unfolded.</p>",
        "id": 270882111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644142444
    },
    {
        "content": "<p>I think the <code>discrete</code> analogue works \"by chance\" based on the order of trying instances--except it's not really by chance because we need to go through <code>category C</code>, and I believe the local instance will always be tried first. Whereas in the <code>locally_discrete</code> case there are two paths and the local instance is not used directly at the branch point.</p>",
        "id": 270882150,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644142551
    },
    {
        "content": "<p>The other solutions I can think of are:</p>\n<ol>\n<li>make <code>locally_discrete</code> a structure with one field, which would require certain <code>mk</code> to construct its terms, but using <code>irreducible</code> also requires first defining helper functions like <code>op</code> and <code>unop</code> before making it irreducible.</li>\n<li>tweak the priority of the instance involved, which may be a simpler solution.</li>\n</ol>",
        "id": 270901453,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644169259
    },
    {
        "content": "<p>I guess \"other\" means other than fixing(?) Lean to not expand this definition during instance search</p>",
        "id": 270904896,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644173294
    },
    {
        "content": "<p>Well in solution 1 the new structure isn't the same type as the original one, certainly not defeq, so Lean certainly can't reduce it to the original type during instance inference ...</p>",
        "id": 270909725,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644178924
    },
    {
        "content": "<p><code>irreducible</code> is also effectively making a new type and I'd have to use analogues of <code>op</code>, <code>unop</code> and <code>quiver.hom.op</code> to transfer between objects and morphisms in these two categories on two different types, and this would be the price I have to pay to use the bicategory API to talk about a oplax functor from a 1-category (with locally discrete bicategory structure) to Cat, while I don't have to do this if I take the direct approach in <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck#diff-fcba77084af1e1dafef32f2c3674793f357a0495bad381534804a4c025ce28deR33\">my branch</a>.</p>",
        "id": 270910162,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644179536
    },
    {
        "content": "<p>Personally I like the structure approach. For one, you can use angle brackets as the anonymous constructor, whereas with an irreducible def you have to always remember what you named the constructor</p>",
        "id": 270911764,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644181486
    },
    {
        "content": "<p>I also used <code>set_option trace.class_instances true</code> to take a look.<br>\nThe correct instance is<br>\n<code>@category_struct.to_quiver (X ⟶ Y) (@category.to_category_struct (X ⟶ Y) (@bicategory.hom_category C _inst_1 X Y))</code>, <br>\nwhich is one step shorter than the wrong instance<br>\n<code>@category_struct.to_quiver (X ⟶ Y) (@category.to_category_struct (X ⟶ Y) (@locally_discrete.quiver.hom.category_theory.small_category C (@bicategory.to_category_struct C _inst_1) X Y))</code>, which is puzzling.<br>\nChanging <code>attribute [instance] bicategory.hom_category</code> to <code>[instance, priority 1001]</code> fixes the problem. If no one objects I'm gonna adopt this approach.</p>",
        "id": 270924870,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644200134
    },
    {
        "content": "<p>With the priority tweak, I have been able to define <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck_bicat?expand=1#diff-f1e819633c68f1e84abe51d548554bbf670f92dd268909f4c7fb3faa24b23df6R70\">oplax functors from a 1-category <code>I</code> to a strict bicategory</a> with a simpler definition similar to that in the lax_grothendieck branch, and connect them to general oplax functors from <code>locally_discrete I</code>to the same strict bicategory via an <code>equiv</code>. I think this is a important special case worthy of a separate simpler definition.</p>\n<p>This work revealed certain problems in <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span>'s <code>oplax_functor</code> definition (I regret that I didn't catch them during review), namely that <code>map₂_associator'</code>, <code>map₂_left_unitor'</code> and <code>map₂_right_unitor'</code> are opposite to the simplification direction, so the auto-generated simp lemmas also point to the \"wrong\" direction. This can be seen from the need of <code>.symm</code> in lines 106-110. (For the associator, the direction of simplication should be from (f ≫ g) h to f (g ≫ h), in analogy to f ≫ (g ≫ h) = f ≫ g ≫ h.)</p>",
        "id": 270933635,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644210849
    },
    {
        "content": "<p>For the chaining inferences problem, moving <code>category_theory.discrete_category (X ⟶ Y)</code> into the definition of <code>locally_discrete_bicategory</code> is a possible solution. Although in this approach one cannot give an instance of <code>small_category</code>, but instead just <code>category</code>, this does not seem to cause the elaborator looking for a <code>small_category</code> to miss <code>X ⟶ Y</code> for <code>X Y : locally_discrete C</code> (probably because <code>small_category</code> is defined as <code>abbreviation</code>, not <code>def</code>?).</p>",
        "id": 270938174,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1644215801
    },
    {
        "content": "<p>That's a good idea too! And yes <code>abbreviation</code> is definitely <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Inference.20of.20an.20instance.20through.20a.20definition.2E/near/256019596\">more transparent than</a> <code>def</code>.</p>",
        "id": 270938408,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644216097
    },
    {
        "content": "<p>I just realized that the direction of <code>map₂_associator'</code> etc. are subtle.</p>\n<p>The current direction is natural at least for general bicategories in the sense that the axioms say that \"an oplax functor preserves the associator, left unitor, and right unitor\".</p>",
        "id": 270942028,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1644219660
    },
    {
        "content": "<p>Yeah I now see the subtlety. If you regard a term not involving map₂ to be simpler than terms that involves it, then the current direction is good. But in my use case the part involving map₂ always simplifies to eq_to_hom ...</p>",
        "id": 270944455,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644221476
    },
    {
        "content": "<p>I've certainly seen examples where you seem to want certain lemmas to be simp one way when you're building the API but the other way when you're using it</p>",
        "id": 270944674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644221615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"438192\">Yuma Mizuno</span> <a href=\"#narrow/stream/113489-new-members/topic/bicategory/near/270938174\">said</a>:</p>\n<blockquote>\n<p>For the chaining inferences problem, moving <code>category_theory.discrete_category (X ⟶ Y)</code> into the definition of <code>locally_discrete_bicategory</code> is a possible solution.</p>\n</blockquote>\n<p>I noticed that the elaborator fails to find <code>quiver (X ⟶ Y)</code> for <code>X Y : locally_discrete B</code> in this solution (I don't understand why). So I think <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> 's solution (adjustment of priority) is better. I guess setting <code>locally_discrete.hom_small_category</code> to <code>priority 900</code> (some number less than 1000) also works.</p>",
        "id": 271747662,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1644761016
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span>  Yes I saw you <a href=\"https://github.com/leanprover-community/mathlib/compare/bicategory-free-coherence#diff-f1e819633c68f1e84abe51d548554bbf670f92dd268909f4c7fb3faa24b23df6R43-R44\">changed priority in your PR</a> and was wondering why. Can you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> where the quiver instance doesn't work? The following is working for me in my lax_grothendieck_bicat branch, <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck_bicat#diff-f1e819633c68f1e84abe51d548554bbf670f92dd268909f4c7fb3faa24b23df6R51\">where your suggestion is adopted</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.bicategory.locally_discrete</span>\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">locally_discrete</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>\n<p>(but if C is only a category_struct then the category instance on X ⟶ Y no longer exists)</p>",
        "id": 271752160,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644767729
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.bicategory.locally_discrete</span>\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">locally_discrete</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">tactic.mk_instance failed to generate instance for</span>\n<span class=\"cm\">  Π (X Y : locally_discrete C), category (X ⟶ Y)</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">C : Type u,</span>\n<span class=\"cm\">_inst_1 : category C</span>\n<span class=\"cm\">⊢ Π (X Y : locally_discrete C), category (X ⟶ Y)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Now I understand that the difference between <code>quiver</code> and <code>category</code> is not irrelevant, but the position of arguments is relevant.</p>",
        "id": 271753567,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1644769451
    },
    {
        "content": "<p>Yes whether X Y are under binder matters. <code>λ X Y, by apply_instance</code> works</p>",
        "id": 271753811,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644769888
    },
    {
        "content": "<p>Yes, but I would like to explain why I needed the version of instance whose arguments are under the binder. I defined <code>prelax_functor</code> from <code>locally_discrete (paths B)</code> <a href=\"https://github.com/leanprover-community/mathlib/compare/bicategory-free-coherence#diff-935c0a9ea1e4e45f5fe5be12ba7664d0ec2be5cc027bcdc7d6f9ec2a371c7fddR72\">here</a>, which requires <code>Π (a b : locally_discrete (paths B)), quiver (a ⟶ b)</code> due to the definition of <code>prelax_functor</code>.</p>",
        "id": 271755294,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1644771948
    },
    {
        "content": "<p>interestingly, <code>by apply bicategory.hom_category</code> also works</p>",
        "id": 271766759,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644788132
    },
    {
        "content": "<p>I wonder why this is failing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">x_0</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">bicategory.hom_category</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_1</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_2</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_3</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_4</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n</code></pre></div>",
        "id": 271766905,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1644788323
    }
]
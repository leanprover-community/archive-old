[
    {
        "content": "<p>I'm trying to get a definition working for binary numbers that recurses by doubling of bits (i.e. you can take 2 32-bit numbers and get a 64-bit number). But I don't want to expose the number of bits in the type. I tried following along with vector/rbtree to construct one but I realize now that pattern matching for vector doesn't even do what I would expect.</p>\n<p>I'd like to be able to write a function like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_zero</span><span class=\"o\">:</span> <span class=\"n\">binary_nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">binary_nat.bit</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">binary_nat.intro</span> <span class=\"n\">high</span> <span class=\"n\">low</span> <span class=\"n\">proof</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_zero</span> <span class=\"n\">high</span> <span class=\"bp\">∧</span> <span class=\"n\">is_zero</span> <span class=\"n\">low</span>\n</code></pre></div>\n<p>But I'm having trouble avoiding encoding the proof in the type somehow, i.e. I can get something like this working</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">binary_nat</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">binary_nat.bit</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">binary_nat.intro</span> <span class=\"n\">high</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_zero</span> <span class=\"n\">high</span> <span class=\"bp\">∧</span> <span class=\"n\">is_zero</span> <span class=\"n\">low</span>\n</code></pre></div>\n<p>where I've encoded the height of the \"tree\" in the type itself (which then makes the type annoying to work with).</p>\n<p>I see rbtree uses a well_formed side-car constructor, although it doesn't seem to have a [pattern] attributes, but vector does, although even<br>\nfor vector I can't find where the pattern matching is used, for example this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_zero</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">bool</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vector.nil</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vector.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_zero</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>The closest I think I have something working has been:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">data</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">binary_nat</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">bit</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">):</span> <span class=\"n\">node</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"o\">):</span> <span class=\"n\">node</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">node</span>\n<span class=\"kd\">def</span> <span class=\"n\">height</span><span class=\"o\">:</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">intro</span> <span class=\"n\">u</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">height</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"kd\">end</span> <span class=\"n\">node</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">well_formed</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">node</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">wf_bit</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">):</span> <span class=\"n\">well_formed</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">node.bit</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">wf_intro</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">wn</span><span class=\"o\">:</span> <span class=\"n\">well_formed</span> <span class=\"n\">n.height</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">wm</span><span class=\"o\">:</span> <span class=\"n\">well_formed</span> <span class=\"n\">m.height</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">n.height</span> <span class=\"bp\">=</span> <span class=\"n\">m.height</span><span class=\"o\">):</span> <span class=\"n\">well_formed</span> <span class=\"o\">((</span><span class=\"n\">n.intro</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">height</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n.intro</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">binary_nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">binary_nat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">binary_nat.node</span> <span class=\"bp\">//</span> <span class=\"n\">binary_nat.well_formed</span> <span class=\"n\">n.height</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">binary_nat</span>\n\n<span class=\"kd\">@[pattern]</span> <span class=\"kd\">def</span> <span class=\"n\">bit</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">):</span> <span class=\"n\">binary_nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">node.bit</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">well_formed.wf_bit</span> <span class=\"n\">b</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[pattern]</span> <span class=\"kd\">def</span> <span class=\"n\">intro</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">high</span> <span class=\"n\">low</span><span class=\"o\">:</span> <span class=\"n\">binary_nat</span><span class=\"o\">),</span> <span class=\"n\">high.val.height</span> <span class=\"bp\">=</span> <span class=\"n\">low.val.height</span> <span class=\"bp\">→</span> <span class=\"n\">binary_nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span> <span class=\"n\">high_val</span><span class=\"o\">,</span> <span class=\"n\">high_proof</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span> <span class=\"n\">low_val</span><span class=\"o\">,</span> <span class=\"n\">low_proof</span> <span class=\"o\">⟩</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">node.intro</span> <span class=\"n\">high_val</span> <span class=\"n\">low_val</span><span class=\"o\">,</span> <span class=\"n\">well_formed.wf_intro</span> <span class=\"n\">high_proof</span> <span class=\"n\">low_proof</span> <span class=\"n\">h</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>But lean doesn't seem to think intro looks enough like a constructor,<br>\n\"invalid function application in pattern, it cannot be reduced to a constructor (possible solution, mark term as inaccessible using '.( )')<br>\n  intro high low proof\"<br>\nAlternatively the issue might be getting out high/low back from intro,<br>\n\"don't know how to synthesize placeholder (high)\"<br>\nI'm not sure which of these error messages is the root cause.</p>\n<p>Any pointers to existing types that achieve something similar would be appreciated (or an explanation of how to make vector work so I can follow along).Or if its impossible to do what I want to do, that would be nice to know too.</p>",
        "id": 323125680,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1674511077
    }
]
[
    {
        "content": "<p>Up to now I've been using <code>∃ x ∈ X, P x</code> in theorem statements (or also e.g. <code>∃ X ⊆  Y, Q X</code>) (where X : finset a and a has decidable_eq) without really thinking about it. First of all, they look like what I'm used to, and second of all, I've been able to get things to work with them up to now. In lean, they translate to <code>∃ x, ∃ (h : x ∈ X), P x</code> and <code>∃ X, ∃ (H : X ⊆ Y), Q X</code>, and I've just been mindlessly using extra layers of <code>exists.elim</code> / <code>exists.intro</code> to deal with the <code>h</code>'s and <code>H</code>'s in proofs.</p>\n<p>Recently I've been defining new functions from these existence theorems using <code>encodable.choose</code> and then defining other functions using <code>encodable.choose_spec</code>to prove things about them. While contemplating the prospect of unwrapping these extra \"exists\" again, I've come to the realization that maybe it's just much cleaner to use <code>∃ x, x ∈ X ∧ P x</code> everywhere instead. This turns out to break decidability, but I think I've managed to get that sorted by adding an extra instance.</p>\n<p>Anyways, I just wanted to see whether my conclusion (avoid <code>∃ x ∈ X, P x</code> in favor of <code>∃ x, x ∈ X ∧ P x</code>) makes sense and whether there are other related pitfalls I should be wary of.</p>",
        "id": 134438550,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537624616
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 134439149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537625589
    },
    {
        "content": "<p><code>∃ x ∈ X, P x</code> is a pretty well-established idiom. I'm not that familiar with <code>encodable</code> but I think I would be more inclined to make whatever worked with <code>x ∈ X ∧ P x</code> also work with the nested exists. After all, <code>∃ h : P, Q</code> (with <code>Q</code> not mentioning <code>h</code>) is isomorphic to <code>P ∧ Q</code> anyways.</p>",
        "id": 134439203,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537625687
    },
    {
        "content": "<p>It is indeed possible to make things work both ways, but I'm still thinking the second way is will be easier in the long run. Here's a toy example showing the flavor of how I've been using <code>encodable.choose_spec</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">encodable</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">encodable</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">encodable</span>\n\n<span class=\"c1\">-- implicit nested exists</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">∩</span> <span class=\"n\">G</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">exists_mem_of_ne_empty</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mem_inter</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">mem_inter</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">foo_e</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">∩</span> <span class=\"n\">G</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">choose</span> <span class=\"err\">$</span> <span class=\"n\">foo</span> <span class=\"n\">h</span>\n\n<span class=\"c1\">-- have to unwrap the extra exists in foo here and elsewhere</span>\n<span class=\"n\">def</span> <span class=\"n\">foo_e_spec</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">∩</span> <span class=\"n\">G</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo_e</span> <span class=\"n\">h</span> <span class=\"err\">∈</span> <span class=\"n\">F</span> <span class=\"bp\">∧</span> <span class=\"n\">foo_e</span> <span class=\"n\">h</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">choose_spec</span> <span class=\"err\">$</span> <span class=\"n\">foo</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- only one exists</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">∩</span> <span class=\"n\">G</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">F</span> <span class=\"bp\">∧</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">exists_mem_of_ne_empty</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mem_inter</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">ha</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bar_e</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">∩</span> <span class=\"n\">G</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">choose</span> <span class=\"err\">$</span> <span class=\"n\">bar</span> <span class=\"n\">h</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bar_e_spec</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">∩</span> <span class=\"n\">G</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bar_e</span> <span class=\"n\">h</span> <span class=\"err\">∈</span> <span class=\"n\">F</span> <span class=\"bp\">∧</span> <span class=\"n\">bar_e</span> <span class=\"n\">h</span> <span class=\"err\">∈</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"n\">choose_spec</span> <span class=\"err\">$</span> <span class=\"n\">bar</span> <span class=\"n\">h</span>\n</pre></div>",
        "id": 134440789,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537628652
    },
    {
        "content": "<p>Be sure to read the discussion in <a href=\"#narrow/stream/113488-general/topic/undead\" title=\"#narrow/stream/113488-general/topic/undead\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/undead</a> about nested exist</p>",
        "id": 134442413,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537631732
    },
    {
        "content": "<p>Yeah, I think I tried to use <code>∃! x∈ X</code> once and immediately ran into the issue described there.</p>",
        "id": 134442546,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537631950
    }
]
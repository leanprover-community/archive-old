[
    {
        "content": "<p>is there a standard library structure for isomorphisms, like this type in Idris? <a href=\"https://github.com/idris-lang/Idris-dev/blob/bae730a7ffaeae09a835a35bac132c141f3b50b3/libs/base/Control/Isomorphism.idr#L10-L16\" target=\"_blank\" title=\"https://github.com/idris-lang/Idris-dev/blob/bae730a7ffaeae09a835a35bac132c141f3b50b3/libs/base/Control/Isomorphism.idr#L10-L16\">https://github.com/idris-lang/Idris-dev/blob/bae730a7ffaeae09a835a35bac132c141f3b50b3/libs/base/Control/Isomorphism.idr#L10-L16</a></p>\n<p>i'm not sure what name to search for</p>",
        "id": 134574550,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537851454
    },
    {
        "content": "<p>In mathlib, you may want <code>data.equiv.basic</code></p>",
        "id": 134574597,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537851490
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/blob/master/data/equiv/basic.lean\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/data/equiv/basic.lean\">https://github.com/leanprover/mathlib/blob/master/data/equiv/basic.lean</a></p>",
        "id": 134574603,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537851510
    },
    {
        "content": "<p>thanks, that looks like what i want</p>\n<p>that brings me to another question, though... should i be using mathlib, in general? is it basically just expected that most people will be using it?</p>",
        "id": 134575168,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537852546
    },
    {
        "content": "<p>Most people use mathlib because it's the largest repository of definitions and theorems in Lean and it keeps growing. Most importantly it has a lot of useful stuff</p>",
        "id": 134575317,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537852759
    },
    {
        "content": "<p>That is certainly the intent... it is like the standard library of most programming languages</p>",
        "id": 134575318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537852765
    },
    {
        "content": "<p>is mathlib generally constructive or classical? or at least, does it clearly delimit which things depend on classical axioms? curious if i'll have to \"wary\" and check with <code>#print axioms</code></p>",
        "id": 134578662,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537858768
    },
    {
        "content": "<p>You'll have to be wary. An effort is made to label classical theorems but people still use them pretty loosely</p>",
        "id": 134578810,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537858932
    },
    {
        "content": "<p>mathlib is mostly classical. In particular, we only worry about constructivity in so far as it avoids the <code>noncomputable</code> marking. In any props or theorems we use AC freely</p>",
        "id": 134578812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537858934
    },
    {
        "content": "<p>There really isn't any point in being \"wary\" with <code>#print axioms</code>, because all you will achieve by doing that is get yourself in a tizzy about the many unnecessary uses of AC. Suffice it to say it is used in many difficult to avoid places in the foundation, some of which are in lean core and so are not even accessible to mathlib</p>",
        "id": 134578903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859067
    },
    {
        "content": "<p>is there a discussion somewhere on the pros and cons of being classical for something like mathlib or just Props in general?</p>",
        "id": 134578908,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537859096
    },
    {
        "content": "<p>the mathlib docs i've found so far just don't mention it</p>",
        "id": 134578921,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537859111
    },
    {
        "content": "<p>We've had the discussion off and on for a while. Lean 2 made a concerted effort to be both constructive and classical</p>",
        "id": 134578929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859135
    },
    {
        "content": "<p>At the beginning I held out hope that we could avoid AC when unnecessary, but at this point it's clear this isn't going to happen</p>",
        "id": 134578977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859178
    },
    {
        "content": "<p>I wonder if that's part of why mathlib was able to move quickly too</p>",
        "id": 134579016,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537859263
    },
    {
        "content": "<p>i don't have much understanding of the implications of using such axioms in a system like Lean. i understand <code>noncomputable</code> prevents even bytecode, but any axioms at all prevent the term from evaluating to a normal form, and i'm curious if that can cause problems in practice</p>",
        "id": 134579079,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537859337
    },
    {
        "content": "<p>We don't evaluate proofs at all in practice</p>",
        "id": 134579097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859366
    },
    {
        "content": "<p>it doesn't matter if they are classical or not because they aren't programs</p>",
        "id": 134579099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859379
    },
    {
        "content": "<p>that was my thinking for Prop, but i haven't been able to find much documentation talking about this point</p>",
        "id": 134579154,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537859413
    },
    {
        "content": "<p>The only mechanism we have for evaluating proofs is <code>#reduce</code> and it falls over on all but the most trivial examples</p>",
        "id": 134579155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859415
    },
    {
        "content": "<p>I guess there isn't much docs on this</p>",
        "id": 134579169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859457
    },
    {
        "content": "<p>The VM evaluates anything that is not a Prop and is not <code>noncomputable</code></p>",
        "id": 134579187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859486
    },
    {
        "content": "<p>When computation is involved, you really need to look at defs that are in <code>Type 0</code> and over. Then an effort is often made to be efficient</p>",
        "id": 134579193,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537859506
    },
    {
        "content": "<p>that makes sense, thanks for all the responses</p>",
        "id": 134579239,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537859582
    },
    {
        "content": "<p><span class=\"emoji emoji-1f44d\" title=\"+1\">:+1:</span></p>",
        "id": 134579246,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537859603
    },
    {
        "content": "<p>i realized while talking to a friend just now that an interesting argument in favor of using fewer axioms is that it makes the proof potentially more \"portable\" to different formalisms, but that's somewhat aspirational and lacking it doesn't block anything in mathlib in the meantime</p>",
        "id": 134579260,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537859641
    },
    {
        "content": "<p>Unfortunately, the axioms that really prevent portability of lean proofs aren't turn-off-able</p>",
        "id": 134579308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859679
    },
    {
        "content": "<p>Most systems have some equivalent of the axiom of choice, but few have inductive types and a hierarchy of universes</p>",
        "id": 134579319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859712
    },
    {
        "content": "<blockquote>\n<p>i realized while talking to a friend just now that an interesting argument in favor of using fewer axioms is that it makes the proof potentially more \"portable\" to different formalisms, but that's somewhat aspirational and lacking it doesn't block anything in mathlib in the meantime</p>\n</blockquote>\n<p>I'm a pure mathematician (as are several other people here) and one of the things that attracted me to Lean is precisely the attitude that \"we will do maths like regular pure mathematicians do\" (i.e. assume things like the axiom of choice, which in my circles is regarded as \"just another axiom, with no particular reason to fuss about it\".)</p>",
        "id": 134579850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537860458
    },
    {
        "content": "<blockquote>\n<p>I'm a pure mathematician (as are several other people here) and one of the things that attracted me to Lean is precisely the attitude that \"we will do maths like regular pure mathematicians do\" (i.e. assume things like the axiom of choice, which in my circles is regarded as \"just another axiom, with no particular reason to fuss about it\".)</p>\n</blockquote>\n<p>On the other hand, some of the things that attracted me to Lean included the ability to do constructive mathematics, the nice syntax, a fast theorem prover, and a comprehensive library. <span class=\"emoji emoji-1f642\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 134579993,
        "sender_full_name": "Sean Leather",
        "timestamp": 1537860654
    },
    {
        "content": "<p>i figured some of what i said might have given away my friend's and my bias towards constructive type theories :P</p>\n<p>i can see why Lean attracted pure mathematicians who might have otherwise used Coq or similar, though. the experience out of the box with Lean in VSCode is the best i've seen from any theorem prover</p>",
        "id": 134580185,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537860999
    },
    {
        "content": "<p>I am also attracted to constructive mathematics generally, but the pure mathematicians have worn me down. :) I realize now that lean is not remotely geared towards limiting its axiom strength, and if you want a system for playing with axioms you should look elsewhere. \"Having few axioms\" only means having few interesting subsystems, and none of the available subsystems are recognizable to traditional mathematicians except possibly intuitionistic type theory</p>",
        "id": 134580336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537861275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110045\">@Sean Leather</span> how inconvenient is it for you that mathlib makes such liberal use of classical axioms?</p>",
        "id": 134580385,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537861328
    },
    {
        "content": "<p>Instead, it seems much more likely that lean will be able to support doing logic at the meta level, which is something that few systems can currently do well. This approach is much more flexible, of course, with regards to its axioms and with the permissible methods of proof</p>",
        "id": 134580400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537861371
    },
    {
        "content": "<p>I haven't had any issues so far. I'm not even sure where I would run into any.</p>",
        "id": 134580402,
        "sender_full_name": "Sean Leather",
        "timestamp": 1537861375
    },
    {
        "content": "<p>i figure i'll just adjust my expectations of what exactly i will play with in lean, but it will still be suitable for a lot of the stuff i want to experiment with</p>",
        "id": 134580417,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537861413
    },
    {
        "content": "<p>The only thing is this output:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">b</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"n\">propext</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</pre></div>",
        "id": 134580423,
        "sender_full_name": "Sean Leather",
        "timestamp": 1537861438
    },
    {
        "content": "<p>Is your requirement that functions be computable or actually to avoid the axioms?</p>",
        "id": 134580424,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537861438
    },
    {
        "content": "<p>Computable, I suppose. I don't do anything actively to avoid axioms, but I don't think I use anything that does use the axiom of choice.</p>",
        "id": 134580482,
        "sender_full_name": "Sean Leather",
        "timestamp": 1537861486
    },
    {
        "content": "<p><code>#print axioms &lt;name&gt;</code> will list the axioms used (transitively) for the given thing</p>",
        "id": 134580506,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537861517
    },
    {
        "content": "<p>but as we discussed, this shouldn't be a problem in the bodies of proofs that will never need to be evaluated or examined by other proofs</p>",
        "id": 134580515,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537861558
    },
    {
        "content": "<blockquote>\n<p><code>#print axioms &lt;name&gt;</code> will list the axioms used (transitively) for the given thing</p>\n</blockquote>\n<p>When I create an empty file, <code>#print axioms</code> shows what I wrote above. <span class=\"emoji emoji-263a\" title=\"smile\">:smile:</span></p>",
        "id": 134580569,
        "sender_full_name": "Sean Leather",
        "timestamp": 1537861606
    },
    {
        "content": "<p>yeah, <code>#print axioms</code> just prints the axioms that are currently in scope</p>",
        "id": 134580583,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537861631
    },
    {
        "content": "<p>Can anyone come up with a reasonable (not completely contrived) example of a computable function that uses AC/LEM in its definition?</p>",
        "id": 134580592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537861658
    },
    {
        "content": "<p>I will amend \"not completely contrived\" to not eliminable, in the sense that there isn't a way to write the same function without the axiom, or at least it's not easy to do so</p>",
        "id": 134580884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537862120
    },
    {
        "content": "<p>on nat?</p>",
        "id": 134580946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537862207
    },
    {
        "content": "<p>sure, I doubt it makes a difference but <code>nat -&gt; nat</code> is a fine target</p>",
        "id": 134580963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537862232
    },
    {
        "content": "<p>I'm sure you're right but I'm such a noob at this sort of thing. A year ago I wouldn't even have been able to formalise the question rigorously.</p>",
        "id": 134580976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537862262
    },
    {
        "content": "<p>To give a hint on why it's even possible: <code>nat.find</code> will calculate the smallest value satisfying a predicate, given only a proof that there is such a value (in Prop). This proof can rely on any axioms, and the function will still be computable</p>",
        "id": 134581031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537862327
    },
    {
        "content": "<p>What about f(n)=1 if Fermat's Last Theorem is true and 0 otherwise? It's completely contrived but I'm trying to get the hang of the question. All known proofs of FLT use AC.</p>",
        "id": 134581033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537862331
    },
    {
        "content": "<p>That won't work because <code>f</code> is just the constant function <code>1</code>, it doesn't need any axioms for its definition</p>",
        "id": 134581117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537862417
    },
    {
        "content": "<p>But I think you are on the right track. Can you think of any forall exists theorem on nat that relies on AC?</p>",
        "id": 134581166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537862514
    },
    {
        "content": "<p>I don't know how to formalize that statement but it seems like a computable function like you described cannot be constructed</p>",
        "id": 134581211,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537862533
    },
    {
        "content": "<p>Here is an example that relies on the input being in a nonoptimal form: if the input is a function <code>f : nat -&gt; nat</code> which is not the constant zero function, then you can computably find a nonzero <code>nat</code> in the range of <code>f</code></p>",
        "id": 134581378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537862825
    },
    {
        "content": "<p>That's true. I stand corrected</p>",
        "id": 134581503,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537863030
    },
    {
        "content": "<blockquote>\n<p>What about f(n)=1 if Fermat's Last Theorem is true and 0 otherwise? It's completely contrived but I'm trying to get the hang of the question. All known proofs of FLT use AC.</p>\n</blockquote>\n<p>So by \"computable\" you mean \"externally provable to be equal to a certain given fixed computable function\", rather than \"provable in Lean with/without AC to be equal to a certain given fixed computable function\"</p>",
        "id": 134581579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537863169
    },
    {
        "content": "<p>What about f(n)=1 if RH is true and 0 otherwise? Don't I need LEM to define this?</p>",
        "id": 134581594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537863220
    },
    {
        "content": "<p>I'm still struggling to move away from the \"contrived\" part, as you can see ;-)</p>",
        "id": 134581599,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537863234
    },
    {
        "content": "<p>If you pick something which is definitely not decidable, or not known to be decidable like RH, then the function won't be computable either. By \"computable\" I mean \"passes lean's <code>noncomputable</code> check\"; you can't write <code>def f := if RH then 1 else 0</code> because <code>RH</code> is not decidable</p>",
        "id": 134581758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537863420
    },
    {
        "content": "<p>yeah, that would specifically require the classical instance for <code>decidable</code> that uses LEM internally, which is <code>noncomputable</code>, which forces <code>f</code> to be <code>noncomputable</code></p>",
        "id": 134581831,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537863507
    },
    {
        "content": "<p>Here is something much less contrived but I am much less clear about whether it fits into the scope of this question. Let's say a pure mathematician proves that for every g&gt;=2 there is a computable upper bound <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mo>(</mo><mi>g</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">B(g)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> for the number of rational points on a smooth projective curve of genus g over the rationals, and their proof uses a bunch of algebraic geometry and AC / LEM everywhere. I suspect I could find arithmetic geometers who were prepared to conjecture that this mathematical statement was true. If this result got proved, and it turned out that a deep theorem implied that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mo>(</mo><mi>g</mi><mo>)</mo><mo>=</mo><mn>1</mn><mn>0</mn><mn>0</mn><mn>0</mn><mn>0</mn><mo>∗</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">B(g)=10000*g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">0</span><span class=\"mord mathrm\">0</span><span class=\"mord mathrm\">0</span><span class=\"mord mathrm\">0</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span></span></span></span>, this would <em>not</em> be an example, right? :-/</p>",
        "id": 134581840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537863524
    },
    {
        "content": "<p>You can write <code>def f := if FLT then 1 else 0</code> only if you have already provided a computable proof of <code>decidable FLT</code>, which will involve a proof of FLT. This falls afoul of the second restriction because then you could just replace the definition of <code>f</code> with <code>1</code></p>",
        "id": 134581848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537863543
    },
    {
        "content": "<p>You are right, this is an interesting situation. If we know a bound on the function then we can skip the clever maths and just use the bound</p>",
        "id": 134581943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537863639
    },
    {
        "content": "<p>Somehow it has to be an existence theorem with no bound</p>",
        "id": 134581957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537863670
    },
    {
        "content": "<p>How about <code>f(n)</code> is 1 if the nth turing machine halts and 0 otherwise? If I'm not mistaken the proof that <code>f</code> is total requires LEM.</p>",
        "id": 134582212,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537863975
    },
    {
        "content": "<p>I have been thinking about examples like that, but again it needs to be computable</p>",
        "id": 134582251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537864046
    },
    {
        "content": "<p>But that might be because I've never seen a constructive proof of halting problem</p>",
        "id": 134582254,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537864048
    },
    {
        "content": "<p>To define that function you have to know whether the nth turing machine halts</p>",
        "id": 134582319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537864095
    },
    {
        "content": "<p>Ah in that case I think that it's impossible.</p>",
        "id": 134582433,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537864245
    },
    {
        "content": "<p>As in you can always rewrite the function to not use AC</p>",
        "id": 134582569,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537864430
    },
    {
        "content": "<p>Here's another way to put it: Find computable predicates <code>p(n), q(m,n)</code> such that if <code>p(n)</code> is true then there exists an <code>m</code> such that <code>q(m,n)</code>, but there is no computable upper bound on the least satisfying instance</p>",
        "id": 134582624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537864456
    },
    {
        "content": "<p>so with <code>nat.find</code> we could find the least <code>nat</code> satisfying some predicate while only proving this search will actually terminate with, for example, a proof by contradiction (the kind that requires classical double negation elimination)?</p>",
        "id": 134582743,
        "sender_full_name": "Scott Olson",
        "timestamp": 1537864639
    },
    {
        "content": "<p>I can just run the <code>q</code> machine on each value of <code>m = 0,1,2,...</code> in turn. Since there exists an <code>m</code> where <code>q(m,n)</code> works, that program will halt. Right?</p>",
        "id": 134582749,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537864657
    },
    {
        "content": "<p>yes, that's the idea</p>",
        "id": 134582818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537864719
    },
    {
        "content": "<p>So it's impossible (to find such computable predicates)</p>",
        "id": 134582819,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537864726
    },
    {
        "content": "<p>that's the computable function</p>",
        "id": 134582821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537864728
    },
    {
        "content": "<p>hm, you may be right. The very constraint that makes it lean-computable will also produce a computable upper bound, namely this function</p>",
        "id": 134582980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537864966
    },
    {
        "content": "<p>but I think maybe \"computable upper bound\" isn't what I want either; it needs to be an upper bound that you can't prove using lean without AC</p>",
        "id": 134583041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865048
    },
    {
        "content": "<p>you can't use this function as a proof because it requires a proof that it will halt to run</p>",
        "id": 134583046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865075
    },
    {
        "content": "<p>If we use something weaker than DTT, it should be possible to use some Ackermann-like function here</p>",
        "id": 134583092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865161
    },
    {
        "content": "<p>Ok I think I see what you mean now. You want a pair <code>p(n), q(m,n)</code> where the existence of  a satisfying <code>m</code>is proved using AC or LEM.</p>",
        "id": 134583167,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537865264
    },
    {
        "content": "<p>exactly</p>",
        "id": 134583218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865297
    },
    {
        "content": "<p>Can you prove that such a function exists using AC?</p>",
        "id": 134583321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537865488
    },
    {
        "content": "<p>You can use whatever methods you like to prove the existence of such p and q, but they have to be computable functions</p>",
        "id": 134583382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865543
    },
    {
        "content": "<p>Ok, I should have put more emphasis on <em>you</em> in my last post (-;</p>",
        "id": 134583448,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537865647
    },
    {
        "content": "<p>I have no clue at all about all this computability stuff.</p>",
        "id": 134583453,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537865667
    },
    {
        "content": "<p>I don't have a solution to this puzzle</p>",
        "id": 134583461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865701
    },
    {
        "content": "<p>but I believe it is possible</p>",
        "id": 134583474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865715
    },
    {
        "content": "<p>I am still not satisfied that the question is well posed. If I found a <code>p</code> and <code>q</code> with that property. I could take the AC proof, throw it away and replace it with a machine that just tries all <code>m</code>. Eventually it would find the <code>m</code> (which I know but Lean doesn't) and Lean would use that. But then I guess my new program would have to run in unsafe mode.</p>",
        "id": 134583532,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537865783
    },
    {
        "content": "<p>For a fixed <code>n</code> you can do that, but I don't think you can do that for all <code>n</code></p>",
        "id": 134583545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865826
    },
    {
        "content": "<p>i.e. if <code>p(5)</code> is true and it turns out that <code>q(100,5)</code> is the satisfying instance, then you can use an upper bound of 100 in the construction</p>",
        "id": 134583553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865861
    },
    {
        "content": "<p>Mario, do you want a proof that can only prove the upper bound under the assumption of LEM/AC?</p>",
        "id": 134583554,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537865865
    },
    {
        "content": "<p>right</p>",
        "id": 134583555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865876
    },
    {
        "content": "<p>Or is it enough that we know no such proof.</p>",
        "id": 134583557,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537865881
    },
    {
        "content": "<p>Even that would be nice</p>",
        "id": 134583599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865893
    },
    {
        "content": "<p>I'm worried that since no axioms lean has the same consistency strength as lean + AC, it will not be able to prove any new turing machines halt</p>",
        "id": 134583615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537865938
    },
    {
        "content": "<p>So, there are only finitely many abelian varieties of dimension <code>g</code> over <code>rat</code> with good reduction outside <code>{favourite finite list of primes}</code>.</p>",
        "id": 134583617,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537865941
    },
    {
        "content": "<p>I don't think we know any upper bounds on this. The proof is a celebrated theorem of Faltings and uses classical maths all over the place.</p>",
        "id": 134583631,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537865970
    },
    {
        "content": "<p>If your favourite finite list of primes is not empty, then this function is extremely hard to compute.</p>",
        "id": 134583668,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866004
    },
    {
        "content": "<p>(Otherwise it is <code>if g = 0 then 1 else 0</code>.)</p>",
        "id": 134583691,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866014
    },
    {
        "content": "<p>Does this mean that <code>f g = card (abelian varieties of dim g with good reduction outside blah)</code> is not computable?</p>",
        "id": 134583717,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866102
    },
    {
        "content": "<p>Hmmm.... I'm too much of a newbie when it comes to such questions.</p>",
        "id": 134583767,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866134
    },
    {
        "content": "<p>hm, this theorem has AEA quantifier complexity, which is a bit hard to use</p>",
        "id": 134583893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866356
    },
    {
        "content": "<p>AEA?</p>",
        "id": 134583936,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866373
    },
    {
        "content": "<p><code>\\forall \\exists \\forall</code>?</p>",
        "id": 134583941,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866384
    },
    {
        "content": "<p>\"for all g, there exists an n such that all variety things don't have good reduction above n\"</p>",
        "id": 134583954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866405
    },
    {
        "content": "<p>No, I don't think that's what it says.</p>",
        "id": 134583971,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866444
    },
    {
        "content": "<p>I assume there is a way to enumerate abelian varieties?</p>",
        "id": 134583978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866472
    },
    {
        "content": "<p>and the theorem says this enumeration runs dry after a certain point</p>",
        "id": 134584022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866490
    },
    {
        "content": "<p>For all <code>P : finset primes</code> and for all <code>g</code> there exists <code>n</code> such that <code>card { abvar of dim g and good reduction outside P }</code> is less than <code>n</code>.</p>",
        "id": 134584026,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866512
    },
    {
        "content": "<p>Well, an abelian variety is defined by a finite number of polynomials</p>",
        "id": 134584031,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866540
    },
    {
        "content": "<p>right, so we enumerate all such things</p>",
        "id": 134584040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866551
    },
    {
        "content": "<p>and only a finite number of them will have good reduction</p>",
        "id": 134584042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866569
    },
    {
        "content": "<p>Right (the polys are over Q), so we could do that.</p>",
        "id": 134584046,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866576
    },
    {
        "content": "<p>so there is an upper bound on the last one with good reduction</p>",
        "id": 134584054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866583
    },
    {
        "content": "<p>thus AEA</p>",
        "id": 134584057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866588
    },
    {
        "content": "<p>Right, but testing the good reduction has to happen at all primes outside <code>P</code></p>",
        "id": 134584061,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866596
    },
    {
        "content": "<p>So you can't enumerate that.</p>",
        "id": 134584107,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866605
    },
    {
        "content": "<p>oh, I see</p>",
        "id": 134584120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866613
    },
    {
        "content": "<p>But I guess you can compute some discriminant in terms of the polynomials</p>",
        "id": 134584123,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866624
    },
    {
        "content": "<p>the property of having good reduction depends on all p?</p>",
        "id": 134584125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866627
    },
    {
        "content": "<p>and then bad reduction at <code>p</code> implies that <code>p</code> divides the discriminant.</p>",
        "id": 134584132,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866647
    },
    {
        "content": "<p>This works for elliptic curves (the case <code>g = 1</code>)</p>",
        "id": 134584139,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866660
    },
    {
        "content": "<p>then it is AEAE</p>",
        "id": 134584145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866669
    },
    {
        "content": "<p>Lol</p>",
        "id": 134584146,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866679
    },
    {
        "content": "<p>for all g/P, there exists n, such that for all abvars above n, there is a p such that the var has bad reduction at p</p>",
        "id": 134584154,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866711
    },
    {
        "content": "<p>No, it isn't about abvars above <code>n</code>, I think.</p>",
        "id": 134584195,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866740
    },
    {
        "content": "<p>At least I can't parse that.</p>",
        "id": 134584196,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866746
    },
    {
        "content": "<p>Ooh, wait, you enumerated them</p>",
        "id": 134584200,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866757
    },
    {
        "content": "<p>that is to exclude the finite number of things with good reduction</p>",
        "id": 134584204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866767
    },
    {
        "content": "<p>Hmmm.... but we still need a decision procedure to determine if a bunch of polynomials defines an AV</p>",
        "id": 134584212,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866787
    },
    {
        "content": "<p>that's surely decidable</p>",
        "id": 134584213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866796
    },
    {
        "content": "<p>Ok, if you say so... I have no idea how to do that...</p>",
        "id": 134584220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866812
    },
    {
        "content": "<p>I have no idea what an AV is, so there</p>",
        "id": 134584232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866828
    },
    {
        "content": "<p>but it surely can't be more than AE complexity</p>",
        "id": 134584277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537866850
    },
    {
        "content": "<p>It means that there exists a group structure on the solution set defined by the polynomials, and the solution set must be compact (in the algebro-geometric sense of compact)</p>",
        "id": 134584296,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866880
    },
    {
        "content": "<p>Both seem hard to check at first sight.</p>",
        "id": 134584330,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537866910
    },
    {
        "content": "<blockquote>\n<p>For a fixed <code>n</code> you can do that, but I don't think you can do that for all <code>n</code></p>\n</blockquote>\n<p>Is this argument on the right lines?<br>\nIf <code>p</code> and <code>q</code> are computable and we know that  for all <code>n</code>, if <code>p(n)</code> then there exists a <code>m</code> such that <code>q(m,n)</code>. Then there exists a computable function <code>n -&gt; m</code> using AC. So I can find the code which runs that function, and put that in Lean. So <code>n</code> doesn't have to be fixed.</p>",
        "id": 134584389,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537866970
    },
    {
        "content": "<p>but the code that runs that function uses AC</p>",
        "id": 134584411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537867031
    },
    {
        "content": "<p>oh you mean the code of a computable function</p>",
        "id": 134584419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537867050
    },
    {
        "content": "<p>Right but I can find the code outside Lean and just put the code in</p>",
        "id": 134584420,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537867051
    },
    {
        "content": "<p>but then you need to know it codes a (total) computable function</p>",
        "id": 134584427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537867065
    },
    {
        "content": "<p>and the proof of that uses AC</p>",
        "id": 134584429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537867070
    },
    {
        "content": "<p>lean won't just let you run whatever function you like</p>",
        "id": 134584479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537867097
    },
    {
        "content": "<p>I can run the n-&gt;m in unsafe mode because it's not part of the proof. I just need to get the <code>m</code></p>",
        "id": 134584498,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537867175
    },
    {
        "content": "<p>the idea with this reduction is to build a computable function in no axioms lean, right? You can't run in unsafe mode since then you don't have a well defined term</p>",
        "id": 134584554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537867250
    },
    {
        "content": "<p>i.e. the <code>m</code> that you pick depends on <code>n</code>, so there is no closed term you can give for the function without unsafe lean stepping in to provide the <code>m</code></p>",
        "id": 134584582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537867296
    },
    {
        "content": "<p>how about this:<br>\nlet <code>A(n)</code> be some computable predicate that requires either <code>AC</code> or <code>LEM</code> to show that either <code>{n | A(n)}</code> or <code>{n | ~A(n)}</code>is infinite.  (in other words, <code>A</code> witnesses the nonconstructive nature of the infinite pigeon hole principle).</p>\n<p>then let <code>q1(m, n)</code> be the statement that there is an <code>n &lt; x &lt; m</code> such that <code>A(x)</code> holds. and similarly define <code>q2(m, n)</code> with <code>~A(x)</code>.  both of these are computable since <code>A</code> is computable.  since either <code>{n | A(n)}</code> or <code>{n | ~A(n)}</code>is infinite, then for at least one of <code>q1</code> or <code>q2</code>we can show the existence of such an <code>m</code> for any given <code>n</code>.  but we need <code>AC</code> or <code>LEM</code> for the existence of the <code>m</code>s.</p>",
        "id": 134618450,
        "sender_full_name": "Jared Corduan",
        "timestamp": 1537901085
    },
    {
        "content": "<p>is there a tl;dr for this thread?</p>",
        "id": 134618503,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537901141
    },
    {
        "content": "<p>Do you really want me to write it?</p>",
        "id": 134618569,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537901173
    },
    {
        "content": "<p>well this thread is way too long, a tl;dr would be good, I don't see why not</p>",
        "id": 134618618,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537901215
    },
    {
        "content": "<p>Ok, let me try: constructivity questions are pointless.</p>",
        "id": 134618657,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537901257
    },
    {
        "content": "<p>I don't think that's a very faithful summary, nor is it contributing to the discussion at hand</p>",
        "id": 134618804,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537901381
    },
    {
        "content": "<p>I'm sorry, but you explicitly asked for it!</p>",
        "id": 134618832,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537901400
    },
    {
        "content": "<p>Anyway, I should work instead of trolling</p>",
        "id": 134618922,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537901443
    },
    {
        "content": "<p>I don't think that works, although it's so close I can taste it. What is the computable function that we are defining?</p>",
        "id": 134618948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901467
    },
    {
        "content": "<p>(Kenny, the gist is I posed a puzzle <a href=\"#narrow/stream/113489-new-members/subject/mathlib.20.26.20constructivity/near/134580592\" title=\"#narrow/stream/113489-new-members/subject/mathlib.20.26.20constructivity/near/134580592\">here</a> and people are trying to solve it.)</p>",
        "id": 134619027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901531
    },
    {
        "content": "<p>well, it's one of two functions.  either 1) it is <code>f(n)</code> is the least <code>m&gt;n</code>such that <code>A(n)</code> or 2) it is <code>f(n)</code> is the least <code>m&gt;n</code>such that <code>~A(n)</code>.</p>",
        "id": 134619086,
        "sender_full_name": "Jared Corduan",
        "timestamp": 1537901590
    },
    {
        "content": "<p>but I punted on giving you an actual <code>A</code>...</p>",
        "id": 134619105,
        "sender_full_name": "Jared Corduan",
        "timestamp": 1537901615
    },
    {
        "content": "<p>But we can't define either of those functions unless we have a proof (possibly using AC) that A(n) is infinite (resp. co-infinite)</p>",
        "id": 134619126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901638
    },
    {
        "content": "<p>you can prove the infinite pigeon hole with <code>AC</code> and <code>LEM</code>, so all I'm missing is a good <code>A</code>, right?</p>",
        "id": 134619199,
        "sender_full_name": "Jared Corduan",
        "timestamp": 1537901695
    },
    {
        "content": "<p>right, but if we assume <code>A</code> is something about which we can prove very little, then we can't prove <code>A(n)</code> is infinite, so 1) can't be defined, and we can't prove <code>~A(n)</code> is infinite either, so 2) can't be defined</p>",
        "id": 134619312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901765
    },
    {
        "content": "<p>What's the constructive proof that there exists a natural such that a^n=1 in a finite group?</p>",
        "id": 134619345,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1537901802
    },
    {
        "content": "<p>If it is finite, then there is an upper bound on the cardinality, enumerate them all and test for equality</p>",
        "id": 134619367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901829
    },
    {
        "content": "<p>(you need decidable equality)</p>",
        "id": 134619409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901876
    },
    {
        "content": "<p>ok, I might have misunderstood the problem!  I thought we wanted an <code>f</code> that needed <code>AC</code> and/or <code>LEM</code> in order to be defined, though it was built from these computable predicates.</p>",
        "id": 134619454,
        "sender_full_name": "Jared Corduan",
        "timestamp": 1537901889
    },
    {
        "content": "<p>That is what we want, but it also needs to be a term that represents a lean-computable function</p>",
        "id": 134619495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901946
    },
    {
        "content": "<p>It is okay if the proof of existence of the term is nonconstructive, like you tried, but the term itself must contain a proof that it halts since lean expects as much</p>",
        "id": 134619527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537901988
    },
    {
        "content": "<p>ah ok, I'll have to think about that some more!</p>",
        "id": 134619598,
        "sender_full_name": "Jared Corduan",
        "timestamp": 1537902011
    },
    {
        "content": "<p>Could we do something like this? Inside Lean, build a language for programs in STLC or another system which Lean can prove is strongly normalizing, but incorporating the type <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat \\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9523299999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.9523299999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9523299999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span><span style=\"top:-3.25789em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span></span></span></span> = nondecreasing functions nat -&gt; bool. Then the input to our function is a code for a function <code>f</code> from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat \\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9523299999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.9523299999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9523299999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span><span style=\"top:-3.25789em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span></span></span></span> to <code>bool</code> together with a proof that <code>f inf = tt</code> (where <code>inf</code> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∈</mo><mover accent=\"true\"><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\in \\hat \\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9523299999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.9914299999999999em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mrel\">∈</span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9523299999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span><span style=\"top:-3.25789em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span></span></span></span> is the constant function <code>ff</code>); we can enumerate such programs because the system is strongly terminating. In Lean+LEM, we can prove that every such function satisfies <code>f n = tt</code> for some finite <code>n</code>, and we ask that our function return the smallest such <code>n</code>.</p>",
        "id": 134620571,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537902868
    },
    {
        "content": "<p>Actually we don't even need the type <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat \\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9523299999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.9523299999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9523299999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span><span style=\"top:-3.25789em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span></span></span></span>, we can just use the whole type <code>nat -&gt; bool</code>, but with the same idea.</p>",
        "id": 134620748,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537903009
    },
    {
        "content": "<p>If <code>f (const ff) = tt</code>, then there must be some finite <code>n</code> such that <code>f (\\lam x, x &gt; n) = tt</code>.</p>",
        "id": 134620778,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537903042
    },
    {
        "content": "<p>Then we seek <code>g f = </code> the least <code>n</code> for which the above holds, provided that <code>f (const ff) = tt</code>, otherwise 37</p>",
        "id": 134620813,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537903074
    },
    {
        "content": "<p>(Compare <a href=\"http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/\" target=\"_blank\" title=\"http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/\">http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/</a>)</p>",
        "id": 134620905,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537903148
    },
    {
        "content": "<p>Maybe this is actually still computable without LEM though</p>",
        "id": 134620946,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537903196
    },
    {
        "content": "<p>Yeah, I doubt this can be made to work. If you can constructively define a normalizer for your language, then you can presumably modify it to keep track of the invocations of the argument, and return the largest number on which it is invoked, then search up to there. If you can't constructively define a normalizer for your language, then you should just use a normalizer for your language as the function we're looking for.</p>",
        "id": 134621676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537903818
    },
    {
        "content": "<p>Note that one way to \"cheat\" here is to have as input a nondecidable proposition, which you then use in the construction. I did something similar with my example of a function that takes as input a function that is not constant zero and returns a value in the range</p>",
        "id": 134622225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537904267
    },
    {
        "content": "<p>Here again we seem to be stuck: if we use STLC or something provably normalizing, then we won't need LEM to prove the compactness property, and if we use DTT functions then even AC won't help since compactness isn't provable (though true)</p>",
        "id": 134622939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537904770
    },
    {
        "content": "<p>Yes. We would need a language whose power is just right so that the proof of normalization requires LEM, which I have no idea how to go about (or whether it is even plausible that such a language could exist).</p>",
        "id": 134623070,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537904874
    },
    {
        "content": "<p>Can we prove that Lean-with-N-universes is normalizing inside Lean-with-N+1-universes? What do we know about the relative consistency of AC?</p>",
        "id": 134623309,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537905014
    },
    {
        "content": "<p>Any term of type <code>nat -&gt; nat</code> is equal (in a meta sense) to one defined without using universe variables right?</p>",
        "id": 134623359,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537905063
    },
    {
        "content": "<p>I believe that Con(CIC+AC) = Con(CIC) for the same reasons as Con(ZF) = Con(ZFC)</p>",
        "id": 134623378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905079
    },
    {
        "content": "<p>I wonder whether we can just describe a meta-level procedure for taking a function defined in Lean+AC and producing an equal one defined in Lean (using one more universe) explicitly</p>",
        "id": 134623467,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537905128
    },
    {
        "content": "<p>I believe that lean-with-n-universes is normalizing in n+1 universes</p>",
        "id": 134623469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905130
    },
    {
        "content": "<p>I have to prove that lean is normalizing first though :)</p>",
        "id": 134623492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905154
    },
    {
        "content": "<p>any term of type nat -&gt; nat may contain universe variables but is parametric in them, so you get the same result no matter what they are set to</p>",
        "id": 134623545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905210
    },
    {
        "content": "<blockquote>\n<p>Any term of type <code>nat -&gt; nat</code> is equal (in a meta sense) to one defined without using universe variables right?</p>\n</blockquote>\n<p>I heard FLT uses universes</p>",
        "id": 134623572,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537905237
    },
    {
        "content": "<p>Fermat's Last Theorem</p>",
        "id": 134623574,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537905241
    },
    {
        "content": "<p>by writing an evaluator for Lean+AC-in-N-universes in Lean-in-N+1-universes, and then at the meta level looking to see how many universes are actually used, picking N to be bigger than that and writing down a term in the model that corresponds to the given function</p>",
        "id": 134623625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537905259
    },
    {
        "content": "<p>It may be that even without any universe variables you still need type 3 or something in the term</p>",
        "id": 134623652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905279
    },
    {
        "content": "<p>(re: kenny)</p>",
        "id": 134623655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905282
    },
    {
        "content": "<p>but is it just because nobody has cleaned up the proof yet?</p>",
        "id": 134623688,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537905306
    },
    {
        "content": "<p>do we really need type 3?</p>",
        "id": 134623694,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537905308
    },
    {
        "content": "<p>Kenny is taking over for Patrick on trolling duty</p>",
        "id": 134623702,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537905316
    },
    {
        "content": "<p>i'm serious</p>",
        "id": 134623811,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537905385
    },
    {
        "content": "<p>We know that ZFC is equiconsistent with ZF, but I think that may include a double negation translation</p>",
        "id": 134623831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905403
    },
    {
        "content": "<p>(if you use IZF in place of ZF)</p>",
        "id": 134623845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905415
    },
    {
        "content": "<blockquote>\n<p>I believe that Con(CIC+AC) = Con(CIC) for the same reasons as Con(ZF) = Con(ZFC)</p>\n</blockquote>\n<p>This is unclear to me because, in the case of ZF, we start from classical logic, at least in the version I know. But that's not to say that LEM is required for the relative consistency, only that I don't know whether it is.</p>",
        "id": 134623878,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537905450
    },
    {
        "content": "<p>I also know that classical prop calc is equiconsistent with intuitionistic</p>",
        "id": 134623955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537905493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> <a href=\"https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof\" target=\"_blank\" title=\"https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof\">https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof</a> (See the first few answers.)</p>",
        "id": 134624102,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537905613
    },
    {
        "content": "<p>Mario, right, that seems plausible then.</p>",
        "id": 134624631,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537906058
    },
    {
        "content": "<blockquote>\n<p>What's the constructive proof that there exists a natural such that a^n=1 in a finite group?</p>\n</blockquote>\n<p>Let n be the order of the group ;-)</p>",
        "id": 134652603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537947761
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Any term of type <code>nat -&gt; nat</code> is equal (in a meta sense) to one defined without using universe variables right?</p>\n</blockquote>\n<p>I heard FLT uses universes</p>\n</blockquote>\n<p>Kenny that is fake news, but the rumour seems hard to kill. Some people might argue that \"the proof is written using universes\" (because at some point Wiles says the word \"representable functor\" and at some other point uses etale cohomology) but they can easily be expunged using standard tricks.</p>",
        "id": 134652674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537947863
    }
]
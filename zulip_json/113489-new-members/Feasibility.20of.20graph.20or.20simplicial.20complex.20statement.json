[
    {
        "content": "<p>I've very new, but I have one very specific question and one general question. (1) Say I had some proposition that came up about graphs (it's currently phrased in the language of Serre and his book on Trees) about paths/geodesics and how they \"overlap\", would lean be a reasonable place to try to prove it formally? (2) Is there a good source that maps the different proof languages to underlying type systems and compares them - in a way that a math person could read and then decide which is best?</p>",
        "id": 187829752,
        "sender_full_name": "Tony",
        "timestamp": 1581350926
    },
    {
        "content": "<p>The underlying foundation is almost completely irrelevant when it comes to deciding which prover is most suitable for mathematician use</p>",
        "id": 187829854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351001
    },
    {
        "content": "<p>I don't understand question 2, but the answer to question 1 is yes.</p>",
        "id": 187829868,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581351002
    },
    {
        "content": "<p>Mario, you are assuming dependent types here, right?</p>",
        "id": 187829926,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581351028
    },
    {
        "content": "<p>No</p>",
        "id": 187829937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351037
    },
    {
        "content": "<p>Although possibly you are hitting on the \"almost\" in my statement wrt Isabelle limitations</p>",
        "id": 187829960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351064
    },
    {
        "content": "<p>Then I disagree. Simple types are not good enough for mathematicians</p>",
        "id": 187830009,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581351091
    },
    {
        "content": "<p>It's a problem they could fix if they cared to</p>",
        "id": 187830018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351101
    },
    {
        "content": "<p>Who is \"they\" in this message?</p>",
        "id": 187830090,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581351126
    },
    {
        "content": "<p>isabelle community</p>",
        "id": 187830095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351133
    },
    {
        "content": "<p>The problem with simple types is not the axiomatic framework itself, but rather the tooling to support \"dependent\" uses</p>",
        "id": 187830113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351152
    },
    {
        "content": "<p>You mean they could create Isabelle/DTT?</p>",
        "id": 187830114,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581351154
    },
    {
        "content": "<p>They have ZFC already</p>",
        "id": 187830125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351172
    },
    {
        "content": "<p>but as a matter of course, everyone uses Isabelle/HOL and its tactics and they get an impression of the weakness of simple type theory from that</p>",
        "id": 187830159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351209
    },
    {
        "content": "<p>re:Question 2, I'm a non-expert but I would be interested to know if say, system A did dependent types (or your-favorite-thing) and system B didn't. I'd be interested to just have an accurate mapping of which concepts go where even if I didn't understand them - but also interested in which things have practical considerations and which are totally theoretical.</p>",
        "id": 187830251,
        "sender_full_name": "Tony",
        "timestamp": 1581351263
    },
    {
        "content": "<p>Every prover does all math, to a zeroth order approximation</p>",
        "id": 187830347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351328
    },
    {
        "content": "<p>the real things to worry about are whether the prover gives you enough sugar to work with it effectively</p>",
        "id": 187830437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351372
    },
    {
        "content": "<p>nCatLab is occasionally abstruse but it's still very useful just because it names concepts and organizes them. Is there a similar thing in this area? <br>\nI care about which things formally can do what but I'm also asking about the maturity of the libraries and the real human effectiveness</p>",
        "id": 187830485,
        "sender_full_name": "Tony",
        "timestamp": 1581351421
    },
    {
        "content": "<p>Thanks for the answers so far :)</p>",
        "id": 187830629,
        "sender_full_name": "Tony",
        "timestamp": 1581351504
    },
    {
        "content": "<p>That said, if you just want to know what axiomatic system the various provers are using: Coq, Lean - CIC (dependent type theory); HOL, HOL4, HOL Light, Isabelle/HOL - HOL (simple type theory); Mizar, Metamath, Isabelle/ZF - ZFC (set theory); Agda, RedPRL, Cubicaltt, UniMath, NuPRL - specialized logics or HoTT variants</p>",
        "id": 187830764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351601
    },
    {
        "content": "<p>The most \"mature\" libraries are Coq, Isabelle, and Mizar; Lean is a newcomer but it has also learned from its predecessors in a lot of ways and is I think pretty nice to use</p>",
        "id": 187831037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1581351738
    },
    {
        "content": "<p>I suppose there is also Idris? <br>\nThis list helps!<br>\n I'm sort of hoping for me a 1-dimensional simplicial complex with boundary maps etc. will suffice for the graph (maybe this is even already done in lean) and I'll probably have to do my own work to define what I mean by path and some other data</p>\n<p>I'd be interested if there were formal reasons to prefer dependent vs simple types but practically speaking it sounds like dependent+Lean is the way to go.</p>",
        "id": 187831720,
        "sender_full_name": "Tony",
        "timestamp": 1581352148
    },
    {
        "content": "<p>My honest opinion is the community is at least as important as the technology. The community here is very mathematician friendly.</p>",
        "id": 187831921,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581352239
    },
    {
        "content": "<p>As Patrick says, there is nothing in theory to stop one from formalising all of Serre's book on trees in Lean. It would take some time though! I read all the earlier chapters once but I don't recall anything about geodesics.</p>",
        "id": 187837288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581355836
    },
    {
        "content": "<p>I vaguely recall from one of the Lean Together 2020 discussion session streams that someone was going to try to add graph theory to mathlib - is this still work in progress?</p>",
        "id": 187837972,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1581356216
    },
    {
        "content": "<p>With high probability they will use a different definition of \"graph\". IIRC the Lean Together 2020 talk was about finite graphs, and in Serre's book there are infinite trees all over the place.</p>",
        "id": 187839899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581357452
    },
    {
        "content": "<p>In my case I wouldn't need infinite things but I think an infinite path for Serre is implemented as a direct limit.</p>",
        "id": 187840503,
        "sender_full_name": "Tony",
        "timestamp": 1581357791
    },
    {
        "content": "<p>I hope that we'll have a general definition of a graph, then some theorems can assume fintype</p>",
        "id": 187840888,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581358001
    },
    {
        "content": "<p>You will be able to do it in Lean and Coq and Mizar, you may or may not be able to do it in Isabelle/HOL depending on whether you need dependent types or not (e.g. topological spaces don't need dependent types, sheaves on topological spaces do), and who knows whether you'll be able to do it in HoTT because the moment you ask someone about it they'll start talking about infinity-topoi :-(</p>",
        "id": 187840928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581358024
    },
    {
        "content": "<p>BTW, who's working on graphs?</p>",
        "id": 187841048,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581358088
    },
    {
        "content": "<p>Someone gave a talk about it but I can't remember their name :-(</p>",
        "id": 187841720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581358565
    },
    {
        "content": "<p>I tried to implement a few things in graph theory, here <a href=\"https://github.com/vbeffara/lean\" target=\"_blank\" title=\"https://github.com/vbeffara/lean\">https://github.com/vbeffara/lean</a> and went as far as proving that Cayley graphs of the same group are bilipschitz equivalent, and tried to define graph minors but what I did was very awkward all over. I would love to see what someone who knows what they are doing would write :-)</p>\n<p>BTW, is there a canonical way to say \"I wrote something that does not quite fit in a chat like here, is definitely PR material, and I would like to get some feedback\"?</p>",
        "id": 187842633,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581359187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> A pointer to a repository is probably the best thing (-;</p>",
        "id": 187843217,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581359584
    },
    {
        "content": "<p>That's cool! That's very much in my wheelhouse. Also it looks like you're already using the Serre defn</p>",
        "id": 187843223,
        "sender_full_name": "Tony",
        "timestamp": 1581359588
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I was the one who talked about wanting to add graph theory to lean. I am still working on the basic definitions right now (with the help of an undergraduate here at Univ. of Illinois Urbana-Champaign). I hope to have some code ready to show here in a few weeks. We are only getting started.</p>",
        "id": 187843224,
        "sender_full_name": "Vaibhav Karve",
        "timestamp": 1581359591
    },
    {
        "content": "<p>Especially if it works with recent mathlib</p>",
        "id": 187843226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581359595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> You could always take a look at graph libraries in coq. (Disclaimer: I have never actually studied a coq library myself.)</p>",
        "id": 187843257,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581359627
    },
    {
        "content": "<p>Thanks Vaibhav for reminding me :-)</p>",
        "id": 187844096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581359875
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"241485\">@Vaibhav Karve</span> <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> Probably it makes sense for you to collaborate on this. I assume that we don't want to have to choose between two approaches <em>after</em> each of them gets to some advanced stage.</p>",
        "id": 187845607,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581360549
    },
    {
        "content": "<p>Am I right that <code>llist α</code> is the set of nonempty lists?</p>",
        "id": 187845781,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581360636
    },
    {
        "content": "<p>BTW, I wouldn't include <code>symmetric</code> in the basic definition. It makes sense to consider oriented graphs in many cases.</p>",
        "id": 187846102,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581360797
    },
    {
        "content": "<p>You don't have to open <code>section</code> inside a <code>namespace</code>.</p>",
        "id": 187846153,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581360822
    },
    {
        "content": "<blockquote>\n<p>BTW, I wouldn't include <code>symmetric</code> in the basic definition. It makes sense to consider oriented graphs in many cases.</p>\n</blockquote>\n<p>aah it's started already :-) There are 10 different definitions :-)</p>",
        "id": 187846171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581360833
    },
    {
        "content": "<p>Depending on who you talk to, there's a few defn of \"graph\" out there: (1) subset of V x V (2) Serre (3) specialization of cell-complex (simplicial, delta, CW?) to 1-dim.</p>",
        "id": 187846354,
        "sender_full_name": "Tony",
        "timestamp": 1581360925
    },
    {
        "content": "<p>I don't know Serre's definition. I speak based on my math/programming experience with using graphs in other theories.</p>",
        "id": 187846476,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581360986
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"241485\">Vaibhav Karve</span> <span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> Probably it makes sense for you to collaborate on this. I assume that we don't want to have to choose between two approaches <em>after</em> each of them gets to some advanced stage.</p>\n</blockquote>\n<p>Thanks for the suggestion. I have PM'ed him.</p>",
        "id": 187846680,
        "sender_full_name": "Vaibhav Karve",
        "timestamp": 1581361094
    },
    {
        "content": "<p>I don't know if it makes sense to allow multiple edges between a given pair of vertices. On the one hand, sometimes it makes sense (e.g., interpreting a category as a graph). On the other hand, it probably makes the definition/code harder to read.</p>",
        "id": 187846758,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581361148
    },
    {
        "content": "<p>It is nice to be able to have them as a specialization of a cell-complex so you can cone off or add things but it depends on what you're doing. (I don't currently need it but having general cell-complex stuff implemented would be really neat)</p>\n<p>For Serre a graph is a set of edges and vertices where you think of the edges as being directed. Formally there's a map called *  from E to E such that (e<em>)</em>=e and e* != e and a initial and terminal boundary map from E to V that satisfies b_initial(e)=b_terminal(e*)</p>",
        "id": 187846821,
        "sender_full_name": "Tony",
        "timestamp": 1581361190
    },
    {
        "content": "<p>( To get from a Serre graph to a combinatorial graph you can take combinatorial edges to be pairs of directed edges {e, e*} )</p>",
        "id": 187847013,
        "sender_full_name": "Tony",
        "timestamp": 1581361302
    },
    {
        "content": "<p>The results I am interested in in graph theory very much require multi-edges, for example.</p>",
        "id": 187847033,
        "sender_full_name": "Vaibhav Karve",
        "timestamp": 1581361319
    },
    {
        "content": "<p>Then we should have something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"kn\">end</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kn\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kn\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Maybe this should be called <code>MultiGraph</code>, then <code>graph</code> can extend it adding the axiom <code>∀ x y, subsingleton (edges x y)</code>.</p>",
        "id": 187847520,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581361617
    },
    {
        "content": "<p>With the <code>(V, E)</code> approach you'll have a lot of equality assumptions here and there, and you'll have to rewrite on them. With the <code>edges : V → V → Sort v</code> approach you'll have troubles whenever you have <code>(x y y' z : V) (e : edges x y) (e' : edges y' z) (h : y = y') (f : Π x y z, edges x y → edges y z → α)</code> and want to write <code>f _ _ _ e e'</code>.</p>",
        "id": 187848512,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581362175
    },
    {
        "content": "<blockquote>\n<p>Am I right that <code>llist α</code> is the set of nonempty lists?</p>\n</blockquote>\n<p>Yes, precisely. I tried with <code>V \\times list V</code>, lean had trouble with recursion, so then I tried to define everything in terms of something like fold but in the end a type with explicit constructors was easier to work with</p>",
        "id": 187849790,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581362979
    },
    {
        "content": "<blockquote>\n<p>BTW, I wouldn't include <code>symmetric</code> in the basic definition. It makes sense to consider oriented graphs in many cases.</p>\n</blockquote>\n<p>Sure, and whether <code>v</code> should be adjacent to itself (it makes some definitions easier, and graph minors awful with all the loops ...)</p>",
        "id": 187849993,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581363091
    },
    {
        "content": "<blockquote>\n<p>I don't know if it makes sense to allow multiple edges between a given pair of vertices. On the one hand, sometimes it makes sense (e.g., interpreting a category as a graph). On the other hand, it probably makes the definition/code harder to read.</p>\n</blockquote>\n<p>It makes sense in many contexts to have <code>adj : V -&gt; V -&gt; W</code> for some labelling type <code>W</code> that would be <code>Prop</code> (or <code>bool</code> ? I seem to remember that in Coq it makes a huge difference for some reason, probably due to decidability/proof irrelevance/something) for usual graphs, but <code>W = \\nat</code> gives multiplicity, probabilists like <code>W = nnreal</code>, computer scientists like to put a monoid there.</p>\n<p>Is it easy to add that after the fact, or would it be better to start in more generality?</p>",
        "id": 187850349,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581363294
    },
    {
        "content": "<blockquote>\n<p>It is nice to be able to have them as a specialization of a cell-complex so you can cone off or add things but it depends on what you're doing. (I don't currently need it but having general cell-complex stuff implemented would be really neat)</p>\n<p>For Serre a graph is a set of edges and vertices where you think of the edges as being directed. Formally there's a map called *  from E to E such that (e<em>)</em>=e and e* != e and a initial and terminal boundary map from E to V that satisfies b_initial(e)=b_terminal(e*)</p>\n</blockquote>\n<p>That seems to be what they do in Coq libraries, they have types for both vertices and edges rather than an adjacency relation IIRC</p>",
        "id": 187850464,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581363366
    },
    {
        "content": "<blockquote>\n<p>With the <code>(V, E)</code> approach you'll have a lot of equality assumptions here and there, and you'll have to rewrite on them. With the <code>edges : V → V → Sort v</code> approach you'll have troubles whenever you have <code>(x y y' z : V) (e : edges x y) (e' : edges y' z) (h : y = y') (f : Π x y z, edges x y → edges y z → α)</code> and want to write <code>f _ _ _ e e'</code>.</p>\n</blockquote>\n<p>Path concatenation caused me some trouble with the <code>V -&gt; V -&gt; Prop</code> option (with a <code>Path x y</code> type), indeed. Still felt more manageable to me than the <code>(V,E)</code> version.</p>",
        "id": 187850733,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581363599
    },
    {
        "content": "<blockquote>\n<p>You don't have to open <code>section</code> inside a <code>namespace</code>.</p>\n</blockquote>\n<p>I'm doing that because lean told me I couldn't have <code>parameter</code>s outside a <code>section</code>. Does that mean that it is a bad idea to use <code>parameter</code>?</p>",
        "id": 187863020,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581371995
    },
    {
        "content": "<blockquote>\n<p>I'm doing that because lean told me I couldn't have <code>parameter</code>s outside a <code>section</code>. Does that mean that it is a bad idea to use <code>parameter</code>?</p>\n</blockquote>\n<p>AFAIK <code>parameter</code>s will not work in Lean 4. Try <code>variable</code>s.</p>",
        "id": 187868835,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581376419
    },
    {
        "content": "<blockquote>\n<p>BTW, is there a canonical way to say \"I wrote something that does not quite fit in a chat like here, is definitely PR material, and I would like to get some feedback\"?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> , here is some feedback :) </p>\n<p>Let me just look at the first line of your file, i.e.,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>because there is a lot to say on this, and it determines everything that follows. What you are doing here is called a fully bundled approach, i.e., a <code>Graph</code> object contains a carrier type, and additional data on this type. This is the way things are typically done in coq. The usual approach in Lean is just a little bit more unbundled: we would start from a type, say <code>V</code>, and then we would tell Lean that this type has a graph structure by registering a graph typeclass. An advantage of this approach is that you work with a single underlying type, and you can put several structures on it (a graph structure, a group structure, and so on), and you can discuss how they relate \"from the inside\". It would read something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Let me show what the next lines could look like, to show how one uses such typeclasses:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">Graph</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">Graph</span> <span class=\"n\">V&#39;</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">linked</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">relation</span><span class=\"bp\">.</span><span class=\"n\">refl_trans_gen</span> <span class=\"n\">adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"n\">class</span> <span class=\"n\">connected_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">connected</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">linked</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">edge</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>First, I enter a namespace, to make sure that I keep my names separated from other areas where one could use the words <code>edge</code>, for instance, and also to make <code>adj</code> available. Then, I declare some variables and some typeclasses that will be available from this point on, to avoid restating them all the time. The interesting point is when I define <code>linked</code>: there is no explicit reference to the graph structure, but since I am mentioning points on <code>V</code> Lean will try to find the graph structure on <code>V</code> (which is given by the typeclass declared two lines above) and understand by itself that <code>adj</code> refers to this graph structure.</p>\n<p>Then in your file you have two definitions of connected, that I have merged in one single definition because I don't see why we would need two. And I have declared it as a type class extending <code>Graph</code>, which means that you will only need to  declare <code>[connected_graph V]</code> if you want to assume that there is a connected graph structure on <code>V</code>, without writing <code>[Graph V]</code> first.</p>\n<p>If you have some questions about what I have just written, or if you would be interested in the same kind of \"standardification\" on some other parts of your files, don't hesitate to ask!</p>",
        "id": 188012485,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581516575
    },
    {
        "content": "<p>I'm not sure that I like graphs as typeclasses. I assume that typeclasses are for canonical structures, and I can't think of any canonical graph structure on a type.</p>",
        "id": 188014231,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581517737
    },
    {
        "content": "<p>I'd go with <code>structure</code>, though maybe <code>structure Graph V := ...</code>.</p>",
        "id": 188014278,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581517778
    },
    {
        "content": "<p>For instance, if <code>G</code> is a group and <code>S</code> is a generating set, then its Cayley graph <code>Cay S</code> (which, as a type, is just a copy of <code>G</code>, but it really should be distinguished from <code>G</code>) has a canonical graph structure. I think it is important to do it this way because then you want to deduce a distance on <code>Cay S</code> and do some analysis/geometry, for which you need the metric space typeclass. You can not get the metric space typeclass if you don't have first a graph typeclass to start with.</p>",
        "id": 188016043,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581518935
    },
    {
        "content": "<p>You can have a generic type tag <code>graph_dist V G := V</code>.</p>",
        "id": 188016200,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581519015
    },
    {
        "content": "<p>(probably with a better name)</p>",
        "id": 188016275,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581519053
    },
    {
        "content": "<p>Sure, but I don't see the advantage compared to a graph typeclass. If you want to do some finite graph theory, or some automaton theory, you will start with a type with a graph structure, and you will work with this structure, just like you would do with a group structure or with a metric space structure, so typeclasses look like a good choice. Of course, if you start putting several graph structures on the same type, you would need to play the <code>@</code> dance, just like for metric spaces say.</p>",
        "id": 188017279,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581519605
    },
    {
        "content": "<p>In my experience dealing with several graphs on the same type is more common than dealing with several distances.</p>",
        "id": 188017710,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581519850
    },
    {
        "content": "<p>E.g., I'd prefer to do common operations like adding/removing an edge without introducing new type tags.</p>",
        "id": 188017796,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581519916
    },
    {
        "content": "<p>OK. We probably need both :)</p>",
        "id": 188017919,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581519992
    },
    {
        "content": "<p>Something like <code>structure Graph V := ...</code> + <code>class CanonicalGraph V := (G : Graph V)</code>?</p>",
        "id": 188018002,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581520077
    },
    {
        "content": "<p>Or just <code>structure Graph V := ...</code> and <code>attribute [class] Graph</code>, but many theorems would be stated with the structure as an explicit argument. It is a little bit like the problem for measure spaces, where one would like to have an implicit measure when building the theory or when doing probability, but an explicit measure when doing analysis.</p>",
        "id": 188018687,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581520557
    },
    {
        "content": "<p>I'm trying to understand this whole typeclass thing ... I get the unbundling of the carrier type, but certainly</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">edge</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">adj</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>feels more natural to me than</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">edge</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I don't see how having the graph structure being implicit would help comparing two graphs on the same carrier?</p>",
        "id": 188026446,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581524848
    },
    {
        "content": "<p>(At the beginning I did have <code>Graph V</code>, I tried bundling to also try coercions at the same time)</p>",
        "id": 188026745,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581525018
    },
    {
        "content": "<blockquote>\n<p>I don't see how having the graph structure being implicit would help comparing two graphs on the same carrier?</p>\n</blockquote>\n<p>The graph structure being implicit is useful when you have one single graph on some type, and you want to talk about it without ever modifying it. If you want to modify a graph, or have several graph structures, then you should go for the structure approach (but still with <code>Graph V</code> instead of having <code>V</code> as a data inside the graph structure, as this is the way everything is done in Lean, so once you want to interface with other parts of the library it will be much easier this way).</p>\n<p>One subtely though: metric space structures are implicit type classes in all mathlib, because most of the time you use just one such structure on the space, and you don't want to specify it all the time. This means that if you want to put a metric space structure on a type using the graph distance, then different graphs will give you different distances, and things will become messy. A trick in situations like that (which is in fact more than a trick) is to have copies of the same type, but with different names. For instance, if you have a group <code>G</code> and a generating set <code>S</code>, then you could define <code>Cay S</code> to be a copy of <code>G</code>, and endow it with the graph distance coming from the Cayley graph structure for the generating <code>S</code>. In this way, you get different metric spaces structures on the different <code>Cay S</code>, which to Lean kernel are the same, but to typeclass resolution are different. If the graph structure was a typeclass, then this would also work well here, as you would put different graph structures on different <code>Cay S</code>.</p>",
        "id": 188029291,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581526485
    },
    {
        "content": "<p>I'm not sure if this kind of double induction is more or less amenable to how things are done in Lean but it's yet another way: <a href=\"/user_uploads/3121/rDpHF6J6d4nMUCTmod96bGse/Capture.PNG\" target=\"_blank\" title=\"Capture.PNG\">Capture.PNG</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/rDpHF6J6d4nMUCTmod96bGse/Capture.PNG\" target=\"_blank\" title=\"Capture.PNG\"><img src=\"/user_uploads/3121/rDpHF6J6d4nMUCTmod96bGse/Capture.PNG\"></a></div>",
        "id": 188034506,
        "sender_full_name": "Tony",
        "timestamp": 1581529530
    },
    {
        "content": "<p>I think that something like that is certainly possible, but that exact definition will be really awkward to work with.</p>",
        "id": 188035744,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581530229
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 188039120,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581532079
    },
    {
        "content": "<blockquote>\n<p>One subtely though: metric space structures are implicit type classes in all mathlib, because most of the time you use just one such structure on the space, and you don't want to specify it all the time. This means that if you want to put a metric space structure on a type using the graph distance, then different graphs will give you different distances, and things will become messy. A trick in situations like that (which is in fact more than a trick) is to have copies of the same type, but with different names. For instance, if you have a group <code>G</code> and a generating set <code>S</code>, then you could define <code>Cay S</code> to be a copy of <code>G</code>, and endow it with the graph distance coming from the Cayley graph structure for the generating <code>S</code>. In this way, you get different metric spaces structures on the different <code>Cay S</code>, which to Lean kernel are the same, but to typeclass resolution are different. If the graph structure was a typeclass, then this would also work well here, as you would put different graph structures on different <code>Cay S</code>.</p>\n</blockquote>\n<p>This seems to have something to do with the fact that a graph structure given a type is not canonical, while a metric structure given a graph is canonical (are there cases where a graph is endowed with a metric that is not the graph distance ?) At least lurking in this chatroom, and reading some of your comments, makes me afraid to use typeclasses here.</p>",
        "id": 188043683,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581534888
    },
    {
        "content": "<p>Isn't the case where you have one graph structure that you want to talk about covered by <code>parameter (G : Graph V)</code> or perhaps <code>variable {G : Graph V}</code> ?</p>",
        "id": 188043831,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581534985
    },
    {
        "content": "<p>I never used parameters. <code>variable</code> is just a shorthand: it means that instead of writing <code>my_beautiful_theorem {V : Type*} {G : Graph V} ...</code> you can just write <code>my_beautiful_theorem ...</code>. The theorems with one syntax or the other are <em>exactly</em> the same.</p>\n<p>The summary is: if you will just use one graph structure on your type, go for typeclasses. Otherwise, use a structure, and pass it as one of the arguments of all your theorems, eiter as <code>{G : Graph V}</code> if it can be inferred by some other data in the statement of the theorem, or as <code>(G : Graph V)</code> otherwise. This can be done explicitly in all your statements if needed, or using a <code>variable</code> at the beginning of the section to avoid repetitions.</p>",
        "id": 188045312,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581535869
    },
    {
        "content": "<p>So like this ?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">carrier</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">connected_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_dist</span> <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">id_S</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span> <span class=\"o\">(</span><span class=\"n\">Cay</span> <span class=\"n\">S1</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">carrier</span> <span class=\"o\">(</span><span class=\"n\">Cay</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">bilipschitz</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">lipschitz_with</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">id_S</span> <span class=\"n\">S1</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 188051714,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581540418
    },
    {
        "content": "<p>Aside: wouldn't it be more natural to use <code>vertices</code> instead of <code>carrier</code> (in this context)?</p>",
        "id": 188051823,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581540498
    },
    {
        "content": "<blockquote>\n<p>Aside: wouldn't it be more natural to use <code>vertices</code> instead of <code>carrier</code> (in this context)?</p>\n</blockquote>\n<p>It would :-)</p>",
        "id": 188052069,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581540716
    },
    {
        "content": "<p>Shouldn't I be afraid that lean will see through what I am trying to do, unfold (Cay S1).vertices and (Cay S2).vertices, see that they are the underlying group, forget about the graphs, and then fail to select the right instance of has_dist?</p>",
        "id": 188052391,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581540989
    },
    {
        "content": "<p>(Well probably not, since it seems to work...)</p>",
        "id": 188052412,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581541018
    },
    {
        "content": "<p>Typeclass search will never unfold anything, unless it is marked reducible. So, the following would work if you had defined graphs as typeclasses (I understand that you don't want to do it, but still I would like to show how it would work :)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">to_metric_space</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Cay</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">G</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">Cay</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">Cay</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>In the first sorry, you would explain to Lean how a graph structure gives a metric space structure. In the second sorry, you would construct the Cayley graph structure on <code>Cay S</code>, which is just <code>G</code> in disguise. And then Lean knows that <code>Cay S</code> is a graph, and therefore a metric space thanks to the first instance. The last line is only there to check that Lean does indeed know this, but it can be safely removed.</p>",
        "id": 188056365,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581544047
    },
    {
        "content": "<p>OK, thanks, it is beginning to slowly sink in :-)</p>",
        "id": 188058040,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581545265
    },
    {
        "content": "<p>Do we have any reason to believe that fully bundled structures a la category theory will be easier to work with in Lean 4? One nice thing about partially bundled structures is that morphisms are actually functions -- although when you start dealing with e.g. algebra maps then they become types again.</p>",
        "id": 188058162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581545355
    },
    {
        "content": "<p>At least coercions to functions should work better in Lean 4, so applying a morphism as a function should work more reliably. But it mostly works fine already in Lean 3, if the morphism is a variable for instance.</p>",
        "id": 188058272,
        "sender_full_name": "Reid Barton",
        "timestamp": 1581545419
    },
    {
        "content": "<p>One of the downsides of using <code>structure Graph</code> instead of <code>structure Graph V</code> is that with <code>structure Graph</code> it's much harder to consider two graphs on the same type because you can't rely on <code>G.V = G'.V</code> being a <code>rfl</code> anymore.</p>",
        "id": 188070615,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581557087
    },
    {
        "content": "<p>So I tried the type class route, but I'm confused about something:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"n\">class</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"c1\">-- Graph.adj : ?M_1 → ?M_1 → Prop</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">sym</span> <span class=\"c1\">-- Graph.sym : ∀ (V : Type) [c : Graph V], symmetric Graph.adj</span>\n</pre></div>\n\n\n<p>Why is the <code>V</code> parameter implicit (or meta-variable-ish) in <code>adj</code> and not in <code>sym</code>? Is there a way to set things up so that one can use the symmetry assumption as <code>Graph.sym</code> rather than <code>Graph.sym G</code>? In all cases I met, <code>Graph.sym _</code> works just fine ...</p>",
        "id": 188154554,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581629736
    },
    {
        "content": "<p>Second question, still following the type class option, how do you say \"there is a graph structure on type <code>G</code> that satisfies this and that property\"? Is it just <code>∃ C : Graph G</code> and then use all the definitions and theorems with <code>@</code> all over to specify the instance every time?</p>",
        "id": 188155333,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581630216
    },
    {
        "content": "<p>Try adding <code>{}</code> after <code>sym</code> like so: <code>(sym {} : symmetric adj)</code></p>",
        "id": 188155419,
        "sender_full_name": "Reid Barton",
        "timestamp": 1581630252
    },
    {
        "content": "<p>For the second question, usually you should also be able to write <code>∃ C : Graph G, by exactI ...</code></p>",
        "id": 188155463,
        "sender_full_name": "Reid Barton",
        "timestamp": 1581630295
    },
    {
        "content": "<p><code>by exactI ...</code> is a variant of <code>by exact ...</code> (which in turn is more or less the same as just the <code>...</code>) that makes all variables in the context available for instance search.</p>",
        "id": 188155595,
        "sender_full_name": "Reid Barton",
        "timestamp": 1581630372
    },
    {
        "content": "<p>Normally, the rule is that only variables to the left of the <code>:</code> in the def/lemma statement are available. Variables introduced by a pi/exists/etc. are not.</p>",
        "id": 188155691,
        "sender_full_name": "Reid Barton",
        "timestamp": 1581630435
    },
    {
        "content": "<blockquote>\n<p>Try adding <code>{}</code> after <code>sym</code> like so: <code>(sym {} : symmetric adj)</code></p>\n</blockquote>\n<p>Ah, thanks, that works! (but the notation is not easy to guess ;-) )</p>",
        "id": 188155828,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581630523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> I'd go with <code>@[class] structure Graph V := (adj : V → V → Prop)</code>, then you'll have a normal <code>structure</code> for non-canonical graphs while being able to write <code>instance ... : Graph V</code> for canonical graphs.</p>",
        "id": 188156344,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581630844
    },
    {
        "content": "<p>As of now, I see one use case of a canonical graph (auto coercion to a metric space), and I'd do it with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">graph_space</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n<span class=\"kn\">instance</span> <span class=\"n\">graph_space</span><span class=\"bp\">.</span><span class=\"n\">emetric_space</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">emetric_space</span> <span class=\"o\">(</span><span class=\"n\">graph_space</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">edist</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edist</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">}</span>\n<span class=\"kn\">instance</span> <span class=\"n\">graph_space</span><span class=\"bp\">.</span><span class=\"n\">metric_space</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">connected_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">graph_space</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">...</span>\n</pre></div>",
        "id": 188156776,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581631117
    },
    {
        "content": "<p>I agree with Yury that this is probably the best approach. For instance, if you want to do percolation at some point, you will have a bunch of different random graphs on <code>Z^d</code>, so registering them as a type class would be a really bad idea. But having a copy of the space associated to the graph makes it possible to use a metric space structure as he explains.</p>",
        "id": 188159954,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1581633421
    },
    {
        "content": "<p>OK thanks, that feels reasonable. Will it be easy to apply a theorem using <code>[Graph G]</code> to a specific graph <code>(G : Graph V)</code>? Just use lots of <code>@</code> and <code>_</code> and plug <code>G</code> where it expects an instance of <code>[Graph G]</code>? Or would it have to be something weird like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">graph_space</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span>\n</pre></div>",
        "id": 188160927,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1581634143
    },
    {
        "content": "<p>I'd formulate most theorems with <code>(G : Graph V)</code> or <code>{G : Graph V}</code>, then it will be easy to apply them in both scenarios.</p>",
        "id": 188163946,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581636638
    },
    {
        "content": "<p>And you can have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">the_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Graph</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">G</span>\n</pre></div>\n\n\n<p>for those cases when you want to specify explicitly that you're dealing with the canonical graph.</p>",
        "id": 188164066,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1581636723
    }
]
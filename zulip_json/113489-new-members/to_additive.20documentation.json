[
    {
        "content": "<p>I am going to quit for today: here is what I have so far: let me know if you think that something is wrong!  I am still planning to add stuff, but probably not today!</p>\n<p>The <code>to_additive</code> attribute.</p>\n<p>Two of the most common operations are addition <code>(+)</code> and multiplication <code>(+)</code>.  Often,<br>\nyou would like to state and prove an additive and a multiplicative version of the same<br>\nresult.  For instance, the two lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">one_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">zero_add</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>are \"equal\", but of course, actually different.  The <code>to_additive</code> attribute helps you by<br>\nconverting the statement and proof of the <strong>multiplicative</strong> version to a statement and<br>\nproof of the <strong>additive version</strong>.  The attribute also guesses the name for the corresponding<br>\nadditive lemma, but you can override this.</p>\n<p>Here is an example of how the syntax works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_new</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>generates the explicit lemma <code>one_mul_new</code>.  It also generated the lemma <code>zero_add_new</code>,<br>\nas you can see by typing <code>#check @zero_add_new</code>.  If, for some reason, you do not like<br>\nthe auto-generated name, you can overrule it by saying</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive my_better_name]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_newer</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>again, checking the ghost lemma by <code>#check @my_better_name</code>.</p>\n<p>You can combine the <code>to_additive</code> attribute with other attributes, for instance with <code>simp</code>.<br>\nFor instance,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive, simp]</span> <span class=\"c1\">-- autogenerates `zero_add_new`,</span>\n<span class=\"c1\">-- only `one_mul_new` has the `simp` attribute</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_new</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>auto-generates the additive version and gives the <code>simp</code> attribute to the multiplicative verion.<br>\nIf you want the additive version to also acquire the <code>simp</code> attribute, you simply exchange the<br>\norder of the attributes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, to_additive]</span> <span class=\"c1\">-- autogenerates `zero_add_new`,</span>\n<span class=\"c1\">-- both `one_mul_new` and `zero_add_new` have the `simp` attribute</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_new</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>To check the attributes, simply type <code>#print zero_add_new</code> and at the very beginning,<br>\nLean will tell you which attributes the lemma <code>zero_add_new</code> has.</p>\n<p>You cannot use <code>to_additive</code> with <code>structures</code>: if you want two structures, one additive and<br>\none multiplicative, than you need to constructed separately.</p>\n<p>However, you can use the <code>to_additive</code> attribute also for <code>def</code> and <code>theorem</code>.  In the case of<br>\n<code>def</code>, the linter requires a doc-string for all <code>def</code>, <strong>including</strong> the autogenerated ones.</p>\n<p>Here is an example of how to achieve this.<br>\n[example]</p>\n<p>[Kevin:<br>\nYou should write some to_additive doc before you forget everything. The basic things are: (1) basic usage (it makes an additive version of a multiplicative lemma) (2) add the attribute after simp if you want the simp to apply to the additive version (3) for structures (rather than theorems) you have to make the structure yourself and then tag it later (your confusion about adding the attribute at the same time or afterwards) (4) link to the \"dictionary\" which auto-generates things like theorem names (5) how to override docstrings e.g. with add_decl_doc (see for example line 279 of submonoid.basic, I linked to the file above) (6) the gotcha with g^n vs n smul g and how it breaks everything.</p>\n<p>/-- multiplicative docstring -/<br>\n@[to_additive \"additive docstring\"] def gi : galois_insertion...</p>\n<p>and the \"choose another name rather than the auto-generated one\" trick e.g.</p>\n<p>@[to_additive ordered_add_comm_group.add_lt_add_left]<br>\nlemma ordered_comm_group.mul_lt_mul_left' (a b : α) (h : a &lt; b) (c : α) : c * a &lt; c * b :=</p>\n<p>(remove the prime, because there will be some ring version which doesn't have an additive counterpart)]</p>\n<p>[Yakov:<br>\nThe final aspect is tagging something with to_additive \"out of band\", that is, via an attribute ... line like at</p>\n<p>@[simp] lemma order_of_one : order_of (1 : α) = 1 :=<br>\nbegin<br>\n  apply le_antisymm,<br>\n  { exact order_of_le_of_pow_eq_one (nat.one_pos) (pow_one 1) },<br>\n  { exact nat.succ_le_of_lt ( order_of_pos' ⟨1, ⟨nat.one_pos, pow_one 1⟩⟩) }<br>\nend</p>\n<p>@[simp] lemma add_order_of_zero : add_order_of (0 : H) = 1 :=<br>\nby simp [← order_of_of_add_eq_add_order_of]</p>\n<p>attribute [to_additive add_order_of_zero] order_of_one]</p>",
        "id": 233856931,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617987579
    },
    {
        "content": "<p>Here is a version that is closer to final:</p>\n<p>The <code>to_additive</code> attribute.</p>\n<h1>Basic usage:</h1>\n<h2>Automation for converting multiplicative to additive</h2>\n<h3>Lemmas, theorems, definitions</h3>\n<p>Two of the most common operations are addition <code>(+)</code> and multiplication <code>(+)</code>.  Often,<br>\nyou would like to state and prove an additive and a multiplicative version of the same<br>\nresult.  For instance, the two lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">one_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">zero_add</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>are \"equal\", but of course, actually different.  The <code>to_additive</code> attribute helps you by<br>\nconverting the statement and proof of the <strong>multiplicative</strong> version to a statement and<br>\nproof of the <strong>additive version</strong>.  The attribute also guesses the name for the corresponding<br>\nadditive lemma, but you can override this.</p>\n<p>Here is an example of how the syntax works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_new</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>generates the explicit lemma <code>one_mul_new</code>.  It also generated the lemma <code>zero_add_new</code>,<br>\nas you can see by typing <code>#check @zero_add_new</code>.  If, for some reason, you do not like<br>\nthe auto-generated name, you can overrule it by saying</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive my_better_name]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_newer</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>again, checking the ghost lemma by <code>#check @my_better_name</code>.</p>\n<h4>Further attributes</h4>\n<p>You can combine the <code>to_additive</code> attribute with other attributes, for instance with <code>simp</code>.<br>\nFor instance,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive, simp]</span> <span class=\"c1\">-- autogenerates `zero_add_new`,</span>\n<span class=\"c1\">-- only `one_mul_new` has the `simp` attribute</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_new</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>auto-generates the additive version and gives the <code>simp</code> attribute to the multiplicative verion.<br>\nIf you want the additive version to also acquire the <code>simp</code> attribute, you simply exchange the<br>\norder of the attributes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, to_additive]</span> <span class=\"c1\">-- autogenerates `zero_add_new`,</span>\n<span class=\"c1\">-- both `one_mul_new` and `zero_add_new` have the `simp` attribute</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul_new</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">one_mul</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>To check the attributes, simply type <code>#print zero_add_new</code> and at the very beginning,<br>\nLean will tell you which attributes the lemma <code>zero_add_new</code> has.</p>\n<p><strong>Warning.</strong><br>\nYou cannot use <code>to_additive</code> with <code>structures</code>: if you want two structures, one additive and<br>\none multiplicative, than you need to constructed separately.</p>\n<h4><code>to_additive</code> and <code>doc strings</code></h4>\n<p>However, you can use the <code>to_additive</code> attribute also for <code>def</code> and <code>theorem</code>.  In the case of<br>\n<code>def</code>, the linter requires a doc-string for all <code>def</code>, <strong>including</strong> the autogenerated ones.</p>\n<p>Here is an example of how to achieve this.<br>\nvariables {G : Type*} [has_mul G]</p>\n<p>/-- <code>left_mul_one g</code> denotes left multiplication by <code>g</code> -/<br>\n@[to_additive \"<code>left_add_zero g</code> denotes left addition by <code>g</code>\"]<br>\ndef left_mul_one : G → G → G := λ g : G, λ x : G, g * x</p>\n<p>#check @left_mul_one<br>\n#check @left_add_zero</p>\n<p>In VSCode, hovering over the names of the lemmas in the <code>#check [...]</code> lines, shows the two<br>\ndoc strings.</p>\n<p>An alternative is to use <code>add_decl_doc</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A truly trivial multiplicative lemma. -/</span>\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">simple_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- And the truly trivial additive doc string. -/</span>\n<span class=\"n\">add_decl_doc</span> <span class=\"n\">add_submonoid.dense_induction</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">simple_mul</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">simple_add</span>\n</code></pre></div>\n<h3>Structures</h3>\n<p>As we mentioned above, the <code>@[to_additive]</code> attribute cannot be used directly on a <code>structure</code><br>\n(or on a <code>class</code>).  However, after you made the two separate multiplicative and additive<br>\nstructures, you can add the tag afterwards.  Here is an example.</p>\n<p>These are the definitions of a <code>comm_semigroup</code> and of an <code>add_comm_semigroup</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A commutative semigroup is a type with an associative commutative `(*)`. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor semigroup]</span>\n<span class=\"kd\">class</span> <span class=\"n\">comm_semigroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">semigroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A commutative additive semigroup is a type with an associative commutative `(+)`. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor add_semigroup]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_comm_semigroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span> <span class=\"n\">comm_semigroup</span>\n</code></pre></div>\n<p>Notice the line <code>attribute [to_additive] comm_semigroup</code>, following the two definitions.<br>\nYou can add the attribute anywhere <strong>after</strong> the two definitions.  If you want to overrule<br>\nthe auto-generated name, you can use the syntax</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span> <span class=\"n\">my_special_additive_name</span><span class=\"o\">]</span> <span class=\"n\">comm_semigroup</span>\n</code></pre></div>\n<h3>Issues</h3>\n<p>Sometimes, the wonderful automation crumbles.  In trying to define a <code>ℕ</code>-semimodule structure<br>\non an abelian (multiplicative/additive) group, it would be useful to be able to apply <code>to_additive</code>.<br>\nUnfortunately, this is, at the moment, not implemented.  The reason is simple.</p>\n<p>The <code>ℕ</code>-action on an abelian multiplicative group <code>G</code> is via iterated multiplication,<br>\nthat is, via <strong>exponentiation</strong>:<br>\n<code>n ∈ ℕ</code> acts on <code>g ∈ G</code> via <code>n ↦ g ^ n</code>.</p>\n<p>The <code>ℕ</code>-action on an abelian additive group <code>A</code> is via iterated addition, that is <br>\n<strong>(s)multiplication</strong>:<br>\n<code>n ∈ ℕ</code> acts on <code>a ∈ A</code> via <code>n ↦ n • a</code>.</p>\n<p>These two actions are on <strong>different</strong> sides and the <code>to_additive</code> attribute is not flexible<br>\nenough to see through this.  Sadly, for the moment, you will have to duplicate all the lemmas<br>\nrelating to additive/multiplicative actions.</p>",
        "id": 233876618,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617995934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I did not understand your comment<br>\n(4) link to the \"dictionary\" which auto-generates things like theorem names</p>",
        "id": 233876727,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617995996
    },
    {
        "content": "<p>Also, if people are happy with this, where should I put it?</p>",
        "id": 233876778,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617996005
    },
    {
        "content": "<p>We have some docs already at <a href=\"https://leanprover-community.github.io/mathlib_docs/attributes.html#to_additive\">attr#to_additive</a></p>",
        "id": 233879855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617997339
    },
    {
        "content": "<p>So I guess merging what you wrote with that is the way to go</p>",
        "id": 233879955,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617997407
    },
    {
        "content": "<p>I think it is worth mentioning the example you had in your draft that another issue is that sometimes you have 1s you don't want to translate to 0s, like in <code>order_of (1:R)=1</code>. This will fail, if I read the error message correctly, because it tries to translate both 1s to 0s, but the one on the RHS shouldn't be translated.</p>",
        "id": 233881233,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1617997953
    },
    {
        "content": "<p>I think what Kevin meant with (4) was some list which names get translated, like mul - &gt; add, one - &gt; zero, etc (I don't actually know how long that list is)</p>",
        "id": 233881440,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1617998049
    }
]
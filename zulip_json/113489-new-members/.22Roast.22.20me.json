[
    {
        "content": "<p>Hi everyone,  I've been learning on my own for a little while, trying some of <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> s \"material for mathematicians who want to learn Lean\" and other things here and there.<br>\nI figured I should try and stamp out any bad habits now  before they get too ingrained. So if anyone has a minute and fancies critiquing some lean code I'd be very happy to hear at this point what I can do better / differently. Indeed I know there are a lot of more advanced techniques that I don't use so a pointer to the names of and where they can be used below would be great. The code is my attempt at sheet 4 from &lt;<a href=\"https://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html\" target=\"_blank\" title=\"https://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html\">https://wwwf.imperial.ac.uk/~buzzard/lean_together/source/leantogether.html</a>&gt; so some of it is Kevins example code but most (especially after ext) is mine.</p>\n<p>Some actual questions:<br>\n- The biggest problem I had that I spent several hours bashing my head against was not being able to unfold <code>mul</code> if it was written as notation <code>*</code> without first doing <code>simp only [(*)]</code>. Is there any way around this? It seems strange that the presence of notation can have such an impact.<br>\n- Is there a way to have an comm_ring instance automatically get fields from add_comm_group,  or is it instead the case that once the comm_ring instance is proved the add_comm_group one should be deleted?<br>\n- Also I'm pretty sure I overuse ring and squeeze_simp? Is there a better way to go in places like that?</p>\n<p>Thanks!</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">logic</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"c1\">-- now we have the field of real numbers</span>\n\n<span class=\"c1\">-- So now we can build the complex numbers as an ordered pair of reals.</span>\n<span class=\"kn\">structure</span> <span class=\"n\">my_complex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">re&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">im&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"n\">ℂ</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">my_complex</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">my_complex</span>\n\n<span class=\"c1\">-- now some computer science boilerplate.</span>\n\n<span class=\"c1\">-- First define the two projections from the complexes back to the reals.</span>\n<span class=\"c1\">-- These are great examples of &quot;eliminators&quot; -- functions on the complex numbers.</span>\n<span class=\"kn\">definition</span> <span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- You can also use this ⟨x, y⟩ notation to make the constructor.</span>\n<span class=\"c1\">-- Here the 0&#39;s are (0 : ℝ)</span>\n<span class=\"kn\">definition</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">definition</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- zero notation</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"c1\">-- now works</span>\n\n<span class=\"c1\">-- how to make 3 + 4i</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- Now we should prove that the constructor applied to the eliminators</span>\n<span class=\"c1\">-- gets us back to where we started.</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">eta</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">re</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">im</span> <span class=\"n\">z</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">z</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n\n<span class=\"c1\">-- Now we should prove the extensionality lemma for complex numbers;</span>\n<span class=\"c1\">-- two complex numbers are equal if and only if their real and imaginary</span>\n<span class=\"c1\">-- parts are equal. One way is trivial; here&#39;s the other way.</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Hre</span> <span class=\"o\">:</span> <span class=\"n\">re</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">re</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Him</span> <span class=\"o\">:</span> <span class=\"n\">im</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">im</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">eta</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- this is the goal now:</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">re</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">im</span> <span class=\"n\">z</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">Hre</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">Him</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- the goal is now true by definition</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- complex conjugation is a great example of seeing the constructor</span>\n<span class=\"c1\">-- and eliminator both in action.</span>\n<span class=\"kn\">definition</span> <span class=\"n\">conj</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">y</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨-</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">y</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">re_of_neg</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span>  <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">ar</span> <span class=\"n\">ac</span><span class=\"o\">,</span>\n<span class=\"n\">unfold</span> <span class=\"n\">neg</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">im_of_neg</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span>  <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">ar</span> <span class=\"n\">ac</span><span class=\"o\">,</span>\n<span class=\"n\">unfold</span> <span class=\"n\">neg</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">⟩</span> <span class=\"o\">)</span>\n\n<span class=\"c1\">-- add the notation</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">⟩</span> <span class=\"o\">)</span>\n\n<span class=\"c1\">-- add the notation</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">--set_option trace.simp_lemmas true</span>\n\n<span class=\"c1\">-- Can you prove this?</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">add_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)],</span>\n<span class=\"n\">unfold</span> <span class=\"n\">add</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">sub_eq_add_neg</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">],</span>\n<span class=\"n\">apply</span> <span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"k\">by</span> <span class=\"n\">ring</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">mul_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)],</span>\n<span class=\"n\">unfold</span> <span class=\"n\">add</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">sub_eq_add_neg</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">],</span>\n<span class=\"n\">apply</span> <span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"k\">by</span> <span class=\"n\">ring</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- Can you construct terms of these types?</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">cacg</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">+</span><span class=\"o\">)],</span> <span class=\"n\">unfold</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">,</span> <span class=\"n\">add_right_inj</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">]</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">zero</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">repeat</span><span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">zero_add</span><span class=\"o\">},</span> <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"o\">(</span><span class=\"n\">eta</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">+</span><span class=\"o\">)],</span> <span class=\"n\">unfold</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">],</span> <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"o\">(</span><span class=\"n\">eta</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">neg</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">im_of_neg</span><span class=\"o\">,</span> <span class=\"n\">add_left_neg</span><span class=\"o\">,</span> <span class=\"n\">re_of_neg</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">+</span><span class=\"o\">)]</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">add</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">forall_2_true_iff</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">,</span> <span class=\"n\">add_right_inj</span><span class=\"o\">]}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">cacr</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">cacg</span><span class=\"bp\">.</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">zero</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">cacg</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">cacg</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span> <span class=\"o\">:=</span> <span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">cacg</span><span class=\"bp\">.</span><span class=\"n\">add_left_neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">cacg</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">)],</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">repeat</span><span class=\"o\">{</span> <span class=\"n\">ring</span><span class=\"o\">},</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"n\">one</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">ar</span> <span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_add_neg</span><span class=\"o\">],</span> <span class=\"n\">unfold</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">,</span> <span class=\"n\">neg_zero</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">],</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">)],</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">ar</span> <span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">)],</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_add_neg</span><span class=\"o\">],</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">ring</span><span class=\"o\">}</span> <span class=\"kn\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">my_complex</span>\n</pre></div>",
        "id": 164047831,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1556073271
    },
    {
        "content": "<blockquote>\n<ul>\n<li>The biggest problem I had that I spent several hours bashing my head against was not being able to unfold mul if it was written as notation * without first doing simp only [(*)]. Is there any way around this? It seems strange that the presence of notation can have such an impact.</li>\n</ul>\n</blockquote>\n<p>Instead of <code>simp only [(*)]</code>, you could also write <code>unfold has_mul.mul</code>.  But you'll still have to <code>unfold mul</code> afterwards. If you want to avoid that, you could write</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">⟩</span> <span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>instead of </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">im&#39;</span> <span class=\"bp\">⟩</span> <span class=\"o\">)</span>\n\n<span class=\"c1\">-- add the notation</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 164049967,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1556076348
    },
    {
        "content": "<blockquote>\n<ul>\n<li>Is there a way to have an comm_ring instance automatically get fields from add_comm_group, or is it instead the case that once the comm_ring instance is proved the add_comm_group one should be deleted?</li>\n</ul>\n</blockquote>\n<p>You can get the fields from add_comm_group like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">cacr</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">)],</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">repeat</span><span class=\"o\">{</span> <span class=\"n\">ring</span><span class=\"o\">},</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"n\">one</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">ar</span> <span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_add_neg</span><span class=\"o\">],</span> <span class=\"n\">unfold</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">,</span> <span class=\"n\">neg_zero</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">],</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">)],</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">ar</span> <span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"bp\">*</span><span class=\"o\">)],</span> <span class=\"n\">unfold</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_add_neg</span><span class=\"o\">],</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">and</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">ring</span><span class=\"o\">}</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">my_complex</span><span class=\"bp\">.</span><span class=\"n\">cacg</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 164050181,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1556076673
    },
    {
        "content": "<p>Great, this shorter  way  is much neater thanks.</p>\n<p>I'm having a little trouble with the has_mul's though, I'll play around a bit more but it seems to break the proofs in a way I can't fix yet.</p>",
        "id": 164050878,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1556077506
    },
    {
        "content": "<p>I want to turn this \"make your own complex numbers\" thing into a coherent introductory exercise for mathematicians -- thanks very much for this attempt!</p>",
        "id": 164053099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556080722
    },
    {
        "content": "<blockquote>\n<ul>\n<li>The biggest problem I had that I spent several hours bashing my head against was not being able to unfold mul if it was written as notation * without first doing simp only [(*)]. Is there any way around this? It seems strange that the presence of notation can have such an impact.</li>\n</ul>\n</blockquote>\n<p>Use simp lemmas! You will notice that the real <code>data.complex.basic</code> has simp lemmas like <code>(x + y).re = x.re + y.re</code>, which are proven by <code>rfl</code> but when you mark them as <code>@[simp]</code> they will be invoked to simplify an addition or multiplication that is written in terms of projections.</p>",
        "id": 164053581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556081420
    },
    {
        "content": "<p>I won't tell you not to use <code>ring</code> and <code>squeeze_simp</code>, especially on this example. This is one of the best applications of <code>ring</code> out there</p>",
        "id": 164053659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556081536
    },
    {
        "content": "<p>I now think that these are bad definitions:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n</pre></div>\n\n\n<p>[I guess I wrote these, not you].</p>",
        "id": 164054324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556082710
    },
    {
        "content": "<p>The problem with them is that if Lean is just faced with a complex number <code>z</code> it doesn't know how to compute its real part. We have to do cases on <code>z</code> first, to break it up into the pair <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x,y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> before we can run this function, and that is an unnecessary step. I think a better definition is that <code>re z := z.re'</code>.</p>",
        "id": 164054390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556082801
    },
    {
        "content": "<p>I had not understood this subtlety when I wrote that example, I suspect.</p>",
        "id": 164054404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556082826
    },
    {
        "content": "<blockquote>\n<p>Use simp lemmas! You will notice that the real <code>data.complex.basic</code> has simp lemmas like <code>(x + y).re = x.re + y.re</code>, which are proven by <code>rfl</code> but when you mark them as <code>@[simp]</code> they will be invoked to simplify an addition or multiplication that is written in terms of projections.</p>\n</blockquote>\n<p>Yeah I found I really needed these to convince lean that the real and imaginary components of a negative where as expected.<br>\nI'll try and get into the habit of writing as many down as possible after every definition I guess.</p>",
        "id": 164054467,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1556082867
    },
    {
        "content": "<blockquote>\n<p>The problem with them is that if Lean is just faced with a complex number <code>z</code> it doesn't know how to compute its real part. We have to do cases on <code>z</code> first, to break it up into the pair <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(x,y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> before we can run this function, and that is an unnecessary step. I think a better definition is that <code>re z := z.re'</code>.</p>\n</blockquote>\n<p>Oh great, I wondered if something like this could be true,  I'll see how many cases I can remove then ;)</p>",
        "id": 164054506,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1556082935
    },
    {
        "content": "<p>If you redefine re and im then all your code will break, but hopefully fixing it will be less painful than writing it the first time.</p>",
        "id": 164054575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556082975
    },
    {
        "content": "<p>And as Mario says, for all the algebra calculations you can use <code>ring</code></p>",
        "id": 164054590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556082989
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">my_complex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">re&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">im&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">re</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">re&#39;</span>\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> so if I do things like this, do I now have to decide whether the \"official\" version of the real part of <code>z</code> is <code>z.re'</code> or <code>re z</code>? And now all the <code>simp</code> lemmas I make should stick to precisely one of these notations? And should there be a simp lemma <code>z.re' = re z</code> to push Lean into this canonical choice? And which is the best choice for the canonical notation? The function or the projection?</p>",
        "id": 164054750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083183
    },
    {
        "content": "<p>It didn't break after changing re and im it seems? I guess the definition is the same really and if I've got a cases somewhere it still goes through</p>",
        "id": 164054802,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1556083221
    },
    {
        "content": "<p>The use of a prime is a pretty clear indication that it's not the preferred one</p>",
        "id": 164054803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083222
    },
    {
        "content": "<p>You tell Alex to use simp lemmas, but I am not sure I know how to use them myself.</p>",
        "id": 164054807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083224
    },
    {
        "content": "<p>Can't you just call the parts <code>re</code> and <code>im</code>?</p>",
        "id": 164054817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083248
    },
    {
        "content": "<blockquote>\n<p>The use of a prime is a pretty clear indication that it's not the preferred one</p>\n</blockquote>\n<p>But I think I made up this notation myself, I didn't want to confuse the user so I put a prime by an arbitrary one. I think...or did I steal it from mathlib</p>",
        "id": 164054830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083272
    },
    {
        "content": "<blockquote>\n<p>Can't you just call the parts <code>re</code> and <code>im</code>?</p>\n</blockquote>\n<p>Sure I could. What I am trying to ask is which one should be the canonical choice as far as <code>simp</code> is concerned? Have I got this right now? I am supposed to choose a canonical way of talking about the real part of a complex number, and then forget that there are two ways of doing it?</p>",
        "id": 164054887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083330
    },
    {
        "content": "<p>I mean skip the definition</p>",
        "id": 164054890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083344
    },
    {
        "content": "<p>right</p>",
        "id": 164054895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083350
    },
    {
        "content": "<p>Is that the best idea? I have no basis for judgement</p>",
        "id": 164054901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083364
    },
    {
        "content": "<p>just use the projections directly, then there is no question which to use because there's only one</p>",
        "id": 164054902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083364
    },
    {
        "content": "<p>But mathematicians use the functions a lot.</p>",
        "id": 164054913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083388
    },
    {
        "content": "<p>there are some cases where the projection can behave a little strange, or maybe you want to change the namespace, etc</p>",
        "id": 164054914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083390
    },
    {
        "content": "<p>They're part of our interface.</p>",
        "id": 164054915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083394
    },
    {
        "content": "<p>in this case I don't see why it's needed</p>",
        "id": 164054926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083411
    },
    {
        "content": "<p>I think it was me beginning to think about formal APIs</p>",
        "id": 164054930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083424
    },
    {
        "content": "<p>But if you want to make a def then presumably you want to also use a simp lemma to rewrite the projection into that def</p>",
        "id": 164054939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083441
    },
    {
        "content": "<p>If you say so!</p>",
        "id": 164054983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083454
    },
    {
        "content": "<p>I don't know how to use <code>simp</code> at all.</p>",
        "id": 164054984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083461
    },
    {
        "content": "<p>that is, pick a preferred way to write things and use it consistently</p>",
        "id": 164054986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083473
    },
    {
        "content": "<p>But I'm beginning to get the hang of it. I would have guessed what you said</p>",
        "id": 164054989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083476
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132858\">@Ramon Fernandez Mir</span> was complaining the other day that he could not find <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>a</mi><msup><mo>)</mo><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">f(a^n)=f(a)^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span> for ring homoorphisms, and then it turned out it wasn't called something like <code>is_ring_hom.map_pow</code> it was called something like <code>is_monoid_hom.map_pow</code>. I suggested he just defined the former to be the latter, but he wasn't sure if that was mathlib style.</p>",
        "id": 164055024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083549
    },
    {
        "content": "<p>On the other hand, it is the sort of thing a mathematician would expect to find in an interface</p>",
        "id": 164055073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083572
    },
    {
        "content": "<p>That's an alias, we've discussed that before</p>",
        "id": 164055077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083588
    },
    {
        "content": "<p>Mathematicians would expect <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mi>e</mi><mo>(</mo><mi>z</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">Re(z)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathit\">e</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 164055078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083591
    },
    {
        "content": "<p>But does it get defined in mathlib?</p>",
        "id": 164055081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083608
    },
    {
        "content": "<p>Or does it get defined somewhere else?</p>",
        "id": 164055085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083616
    },
    {
        "content": "<p>I'd like better lean support for them, but making theorem copies with different names is one way to achieve it</p>",
        "id": 164055097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083630
    },
    {
        "content": "<p>If I write a new theory and I only want to expose some parts of the API to users, is there a way to do that?</p>",
        "id": 164055104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083654
    },
    {
        "content": "<p>There are only a handful of aliases in mathlib, but they aren't forbidden</p>",
        "id": 164055105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083654
    },
    {
        "content": "<p>I was thinking of offering users a Lean file with constants and axioms, so they can only access what I want them to access.</p>",
        "id": 164055110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083677
    },
    {
        "content": "<p>so e.g. the user would get a complex numbers, but <a href=\"http://z.re\" target=\"_blank\" title=\"http://z.re\">z.re</a>' would not even make sense</p>",
        "id": 164055157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083698
    },
    {
        "content": "<p>because they had to use <code>re z</code></p>",
        "id": 164055161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083707
    },
    {
        "content": "<p>This would make elaboration quicker maybe?</p>",
        "id": 164055164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083719
    },
    {
        "content": "<p>It would make people write different code, possibly better code</p>",
        "id": 164055166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083733
    },
    {
        "content": "<p>the lack of definitional equality will make some things easier and some things impossible</p>",
        "id": 164055167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083735
    },
    {
        "content": "<p>aah I see</p>",
        "id": 164055171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083742
    },
    {
        "content": "<p>if you are trying to teach them not to write theorems that depend on definitional equality it's not a bad plan</p>",
        "id": 164055181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083768
    },
    {
        "content": "<p>like if, say, someone decides to make <code>real</code> irreducible one day and all the proofs break :)</p>",
        "id": 164055190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083799
    },
    {
        "content": "<p>that was still a good change</p>",
        "id": 164055240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083816
    },
    {
        "content": "<p>sure, it was enforcing a contract; it wasn't until we enforced it that we realized it was being completely ignored</p>",
        "id": 164055248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083857
    },
    {
        "content": "<p>One of the questions on the undergraduate analysis example sheet was \"assume a bunch of stuff. Now given a real number, prove that there's a Cauchy sequence consisting entirely of rational numbers which converges to it\". And I just thought \"this isn't too hard in Lean..\"</p>",
        "id": 164055261,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083891
    },
    {
        "content": "<p>Lucky we didn't use Dedekind cuts :-)</p>",
        "id": 164055269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556083912
    },
    {
        "content": "<p>\"now given a real number, show there is a set of rational numbers whose supremum is that number\"</p>",
        "id": 164055320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1556083978
    },
    {
        "content": "<p>It also indicates how mathematicians think about the reals -- just some God-given totally ordered complete archimedean field whose definition(s) they forgot a long time ago.</p>",
        "id": 164055334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556084007
    }
]
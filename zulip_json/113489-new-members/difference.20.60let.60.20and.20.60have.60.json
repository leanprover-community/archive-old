[
    {
        "content": "<p>I am struggling in understanding the sentence \"The difference between <code>let</code> and <code>have</code> is that <code>let</code> introduces a local definition in the context, so that the definition of the local constant can be unfolded in the proof.\" from the Lean Book.</p>",
        "id": 206130930,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596714967
    },
    {
        "content": "<p>In practice, it seems to me that if I want to introduce an object (say, a set) and then state that it has more structure, I should type</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">Z</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"n\">is</span> <span class=\"n\">even</span><span class=\"o\">}</span>\n<span class=\"k\">let</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">subgroup</span>\n</code></pre></div>\n\n\n<p>whereas I would have expected the right tactic to be</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">Z</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"n\">is</span> <span class=\"n\">even</span><span class=\"o\">}</span>\n<span class=\"k\">have</span> <span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">subgroup</span>\n</code></pre></div>\n\n\n<p>I suspect that some type-business is hidden under the scene, as X cannot be a subgroup if it is a set. At any rate, my first question is about the difference between <code>let</code> and <code>have</code> and, secondly, about the \"right\" tactic to introduce an object, giving it a name, and then stating some properties of it.</p>",
        "id": 206131016,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596715059
    },
    {
        "content": "<p>A bit difficult to say more than the book does without a more precise example.</p>",
        "id": 206134253,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596717342
    },
    {
        "content": "<p>In general, for Props, use <code>have</code>. For data, use <code>let v : T := e</code> if the rest of the proof is going to need use the fact that <code>v</code> equals <code>e</code>, otherwise you can use <code>have</code> here as well.</p>",
        "id": 206134465,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596717442
    },
    {
        "content": "<p>Well, in my example, I have a maximal ideal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> in a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and I am defining its \"inverse\", as fractional ideal in the fraction field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>: the localization map is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. So what I did was<br>\n<code>\nlet M1 := {x : K | ∀ y ∈ M, f.is_integer (x * f.to_map y)},\nhave M1 : fractional_ideal f,\n</code><br>\nhaving in mind that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">M1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">1</span></span></span></span> was the definition of a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, and the second line was my claim that it is indeed a fractional ideal. But this creates two hypothesis called <code>M1</code>, whereas I got the advice of writing<br>\n<code>\nlet M1 := {x : K | ∀ y ∈ M, f.is_integer (x * f.to_map y)},\nlet M1 : fractional_ideal f,\n</code><br>\nwhich indeed does the job, but I am puzzled both from the fact that saying \"let M1\" twice sounds odd, and also in properly understanding what's the difference.</p>",
        "id": 206135329,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596717931
    },
    {
        "content": "<p>I think you should check the definition of <code>fractional_ideal</code></p>",
        "id": 206135484,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718005
    },
    {
        "content": "<p>I am also confused why you have two definitions both called <code>M1</code></p>",
        "id": 206135523,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718025
    },
    {
        "content": "<p><code>have M1 : fractional_ideal f,</code><br>\nthis couldn't possibly be correct, since it contains no reference to the original <code>M1</code>, unless there are more lines in between</p>",
        "id": 206135693,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718109
    },
    {
        "content": "<p>You seem to be imagining that <code>fractional_ideal</code> is something like \"<code>is_fractional_ideal</code>\", but it couldn't be because where is the ideal then?</p>",
        "id": 206135752,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718159
    },
    {
        "content": "<p>In the second one, I assume your definition of the second <code>M1</code> refers to the first <code>M1</code>?</p>",
        "id": 206135806,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718201
    },
    {
        "content": "<p>In the second I wanted to state \"M1 belongs to the set of fractional ideals wrt f</p>",
        "id": 206136178,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596718402
    },
    {
        "content": "<p>Oh I see, but that's not how <code>let</code>/<code>have</code> work</p>",
        "id": 206136229,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718437
    },
    {
        "content": "<p>(it's also not how types work)</p>",
        "id": 206136294,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718462
    },
    {
        "content": "<p>I see. Can you explain a bit more?</p>",
        "id": 206136300,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596718469
    },
    {
        "content": "<p><code>have M1 : fractional_ideal f</code> means exactly the same as <code>have M7 : fractional_ideal f</code> except that the new variable is called <code>M1</code> instead of <code>M7</code></p>",
        "id": 206136321,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718489
    },
    {
        "content": "<p>if you reuse the name <code>M1</code>, it just means you end up with two variables with the same name (generally undesirable)</p>",
        "id": 206136401,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718532
    },
    {
        "content": "<p>And what do they (both) mean?</p>",
        "id": 206136403,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596718534
    },
    {
        "content": "<p>And, you can never prove a statement of the form \"such-and-such expression has such-and-such type\" which seems to have been what you were trying to express</p>",
        "id": 206136517,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718571
    },
    {
        "content": "<p>well, they both introduce a variable of type <code>fractional_ideal f</code></p>",
        "id": 206136558,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596718593
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 206136585,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596718603
    },
    {
        "content": "<p>I really need to run now, I will try to contact you later - or study more! Thanks in advance, at any rate.</p>",
        "id": 206136625,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596718624
    },
    {
        "content": "<p>Here I am again-could you speculate a bit on your sentence that \" one can never prove a statement of the form such-and-such expression has such-and-such type\"? Do you mean that every expression comes with its type and it won't change forever?</p>",
        "id": 206146908,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723493
    },
    {
        "content": "<p>every term has a type which does not change</p>",
        "id": 206147102,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723584
    },
    {
        "content": "<p>But do subgroups and normal subgroups have the same type?</p>",
        "id": 206147183,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723607
    },
    {
        "content": "<p>i think normal is a predicate on subgroups, something like <code>is_normal : subgroup G \\to Prop</code></p>",
        "id": 206147226,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723625
    },
    {
        "content": "<p>So, if submodule is a predicate on (sub)sets, I can prove something like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">is_integer</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">to_map</span> <span class=\"n\">y</span><span class=\"o\">)},</span>\n<span class=\"k\">have</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">fractional_ideal</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 206147319,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723674
    },
    {
        "content": "<p>meaning, with the second line, that the first line is a fractional ideal</p>",
        "id": 206147339,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723686
    },
    {
        "content": "<p>no</p>",
        "id": 206147358,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723695
    },
    {
        "content": "<p><code>t : T</code> only makes sense when <code>T</code> is the type of <code>t</code></p>",
        "id": 206147396,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723713
    },
    {
        "content": "<p>the type of <code>M1</code> is <code>set K</code></p>",
        "id": 206147474,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723727
    },
    {
        "content": "<p>if you have a predicate <code>is_fractional_ideal : set K \\to Prop</code></p>",
        "id": 206147529,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723752
    },
    {
        "content": "<p>then you could write <code>have hM1 : is_fractional_ideal M1</code></p>",
        "id": 206147554,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723768
    },
    {
        "content": "<p>ahah! That's what I was looking for, I guess.</p>",
        "id": 206147597,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723788
    },
    {
        "content": "<p>then you get a goal of type <code>is_fractional_ideal M1</code></p>",
        "id": 206147643,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723810
    },
    {
        "content": "<p>after you prove it, you'll have a local variable called <code>hM1</code> which can be thought of as storing the proof</p>",
        "id": 206147684,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723832
    },
    {
        "content": "<p>Is the <code>is_</code> construction automatically built by Lean when one defines something?</p>",
        "id": 206147691,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723834
    },
    {
        "content": "<p>no</p>",
        "id": 206147697,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723837
    },
    {
        "content": "<p>I was giving hypothetical names because I'm not familiar with this part of the library</p>",
        "id": 206147760,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723850
    },
    {
        "content": "<p>Ah, ok: so, the existence of <code>fractional_ideal</code> (which I know to exist) does not imply the existence of <code>is_fractional_ideal</code></p>",
        "id": 206147808,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723871
    },
    {
        "content": "<p>let me go look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fractional_ideal\">docs#fractional_ideal</a></p>",
        "id": 206147845,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596723892
    },
    {
        "content": "<p>(although I suspect this second to exist as well, I am trying to dig into the construction of those things)</p>",
        "id": 206147856,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596723895
    },
    {
        "content": "<p>Have you found a \"predicate\" that seems to do the trick? I haven't, but I might have overlooked it.</p>",
        "id": 206148283,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596724082
    },
    {
        "content": "<p>If you click on \"Equations\" (or just view source) you can see the associated predicate is called <code>is_fractional</code></p>",
        "id": 206148482,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596724158
    },
    {
        "content": "<p>(Presumably, you were going to have to look at the definition of <code>fractional_ideal</code> next no matter what?)</p>",
        "id": 206148676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596724248
    },
    {
        "content": "<p>OkOk, I see the problem I was facing. And going back to the first question, after having defined M1 with <code>let</code>, should I type</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hM1</span> <span class=\"o\">:</span> <span class=\"n\">is_fractional</span> <span class=\"n\">M1</span>\n</code></pre></div>\n\n\n<p>or </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">hM1</span> <span class=\"o\">:</span> <span class=\"n\">is_fractional</span> <span class=\"n\">M1</span>\n</code></pre></div>\n\n\n<p>?</p>",
        "id": 206148862,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1596724345
    },
    {
        "content": "<p>use <code>have hM1 : is_fractional M1,</code></p>",
        "id": 206149386,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596724594
    },
    {
        "content": "<p>that's telling lean: I want to prove this proposition <code>is_fractional M1</code> in tactic mode and then forget about the proof, but keep the statement and call it <code>hM1</code></p>",
        "id": 206149536,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596724665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> as a mathematician coming into this, it can be a bit confusing. There are two ways of working with mathematical objects in Lean -- a \"bundled\" way and an \"unbundled\" way. The other thing you to know is how to orientate your self in Lean's type universe -- there are universes, types and terms. In the universe Type, the types are what we think of as sets and the terms are what we think of as their elements. In the Prop universe, the types are what we think of as theorem statements, and the terms are what we think of as proofs.</p>\n<p>So now let me tell you about groups and subgroups. For whatever reason, the way you say \"let G be a group\" in Lean is that you make a term <code>G : Type</code> (i.e. a set), and then we make a term called something silly like <code>_inst_1</code> of type <code>group G</code>. The type <code>group G</code> is a type, so it's what we think of as a set, and it's the set of all group structures on the set G. So a term of type <code>group G</code> is the data of a multiplication, identity and inverse, plus also the proofs of all the group axioms. The reason the term of type <code>group G</code> has a weird name is that we users never have to say that name in our code -- you write <code>[group G]</code> in square brackets and that means \"leave Lean's type class inference system to deal with all the group structure on G automatically\" -- which means that if <code>a b : G</code> you can write <code>a * b</code> and Lean will know what you mean.</p>\n<p>Now subgroups are dealt with in a completely different way. If G is a group then <code>G : Type</code> and if <code>H</code> is a subgroup then it turns out that <code>H</code> is <em>not</em> a type, it is a term. There is a type <code>subgroup G</code>, which is a type, so it's a set in our language, and it's the set of all subgroups of G. So <code>H : subgroup G</code> means H is a subgroup of G, and so H is actually something like a quadrauple of data under the hood, it's a subset and three proofs (that it's closed under multiplication, inverse and identity). </p>\n<p>If you want to work with fractional ideals you really should read the docstring at the top of <code>fractional_ideal.lean</code>. This tells you all the names of all the important functions and definitions. Finding them in the lean file itself and hovering over them will tell you the types of all these terms, and then you have to start thinking very clearly about what is bundled and what isn't. For example, <code>fractional_ideal f</code> is the type of fractional ideals in P (using notation from the docstring) so a term of type <code>fractional_ideal f</code> is a fractional ideal, which means that it is some sort of n-tuple encoding all the things which a mathematician needs to make a fractional ideal. In particular its name will not be the same as the name of the underlying submodule, which is a different thing because it has a different type.</p>",
        "id": 206244232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596797810
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> is this the start of a blogpost?</p>",
        "id": 206244469,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596798027
    },
    {
        "content": "<p>Please <em>please</em> stop this. Each new message or blog post where Kevin repeats that mathematicians should replace <code>Type</code> by \"set\" and <code>set</code> by \"subset\" is simply adding confusion for no good reason.</p>",
        "id": 206246353,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596799669
    },
    {
        "content": "<p>I know this winds you up Patrick, but this is how to teach a beginner with no knowledge of type theory how to think about types and terms in the context of something they already understand.</p>",
        "id": 206246787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596800095
    },
    {
        "content": "<p>But you are teaching something <em>wrong</em>. What's the point?</p>",
        "id": 206247192,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596800500
    },
    {
        "content": "<p>Why do you say it's wrong? This is literally how the model of lean in set theory works</p>",
        "id": 206247528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596800818
    },
    {
        "content": "<p>so people from a set theory background (inasmuch as this is true for traditional mathematicians) expect this kind of terminology</p>",
        "id": 206247583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596800867
    },
    {
        "content": "<p>The model is not the real thing, and it comes with a lot of extra junk that encourages bad intuition.</p>",
        "id": 206247682,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596800929
    },
    {
        "content": "<p>Now there is an additional bit of learning to make a new distinction in type theory that did not exist in set theory (namely the difference between a set-in-itself and a set-as-subset-of-another), but that can be taught separately</p>",
        "id": 206247695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596800941
    },
    {
        "content": "<p>if you want to draw a parallel between concepts in set theory and concepts in type theory, this is the right parallel</p>",
        "id": 206247725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596800974
    },
    {
        "content": "<p>We now have a lot of data proving this parallel is harmful when learning.</p>",
        "id": 206247806,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801020
    },
    {
        "content": "<p>\"the model is not the real thing\" that depends on your religion</p>",
        "id": 206247807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801020
    },
    {
        "content": "<p>I think it's best to get out of the way early the explanation about types and sets, but then, as soon as possible, to stop conflating them.</p>",
        "id": 206247852,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596801076
    },
    {
        "content": "<p>Certainly when Kevin says \"There is a type <code>subgroup G</code>, which is a type, so it's a set in our language.\" I get sad. :-)</p>",
        "id": 206247950,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596801180
    },
    {
        "content": "<p>If that sentence is to make any sense it should be \"so it's a set in the old language\"?</p>",
        "id": 206247987,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596801223
    },
    {
        "content": "<p>Exactly, this kind of sentence if just piling up confusion.</p>",
        "id": 206248062,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801265
    },
    {
        "content": "<p>I guess you could also use a vaguer word like \"collection\" there</p>",
        "id": 206248274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801464
    },
    {
        "content": "<p>\"The type <code>subgroup G</code> is the collection of all subgroup structures on <code>G</code>\"</p>",
        "id": 206248334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801485
    },
    {
        "content": "<p>but that sentence doesn't seem especially wrong to me even if you substitute the word \"set\" in for \"collection\"</p>",
        "id": 206248379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801535
    },
    {
        "content": "<p>That sentence is just wrong whatever the interpretation.</p>",
        "id": 206248417,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801581
    },
    {
        "content": "<p>it's not, that's literally what the type represents</p>",
        "id": 206248484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801605
    },
    {
        "content": "<p>Did you really intended to put those \"sub\" here?</p>",
        "id": 206248521,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801638
    },
    {
        "content": "<p>what sub? the one in \"subgroup\"?</p>",
        "id": 206248538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801661
    },
    {
        "content": "<p>yes</p>",
        "id": 206248547,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801667
    },
    {
        "content": "<p>Because the sentence you get from removing both \"sub\" makes sense.</p>",
        "id": 206248565,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801683
    },
    {
        "content": "<p>um yes, that's the name of the mathematical concept</p>",
        "id": 206248570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801688
    },
    {
        "content": "<p>The collection of all group structures on <code>G</code> is a completely different type</p>",
        "id": 206248593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801712
    },
    {
        "content": "<p>I'm talking about <code>subgroup G</code></p>",
        "id": 206248615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801723
    },
    {
        "content": "<p>I think I see the confusion, the sentence is also true if you replace <code>subgroup</code> with <code>group</code></p>",
        "id": 206248689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801775
    },
    {
        "content": "<p>A term with type <code>subgroup G</code> is not a structure <em>on</em> <code>G</code>.</p>",
        "id": 206248699,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801785
    },
    {
        "content": "<p>I think Patrick's complaint in this sentence is that a \"subgroup structure\" is an alien concept.</p>",
        "id": 206248701,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596801786
    },
    {
        "content": "<p>I could say \"subgroup of G\" but that just sounds circular</p>",
        "id": 206248724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801811
    },
    {
        "content": "<p>and \"subgroup structure\" makes it clearer that it's more like a tuple than a set</p>",
        "id": 206248748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801836
    },
    {
        "content": "<p>Aren't we discussing how to make things clearer, not more obscure?</p>",
        "id": 206248806,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801860
    },
    {
        "content": "<p>I should hope so</p>",
        "id": 206248820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801874
    },
    {
        "content": "<p>If I understand correctly <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> means that although <code>group G</code> designates the types <strong>group-structure on</strong> <code>G</code>, whereas <code>subgroup G</code> designates the types of subgroups of <code>G</code>, not a \"structure of subgroup\"</p>",
        "id": 206248855,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1596801898
    },
    {
        "content": "<p>it is the type of all subgroup structures of G</p>",
        "id": 206248880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801918
    },
    {
        "content": "<p>as in, an element of the type is a subgroup structure</p>",
        "id": 206248895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801931
    },
    {
        "content": "<p>Mario, that's simply not what mathematicians call structures. That's the programming language notion of structure.</p>",
        "id": 206248984,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801973
    },
    {
        "content": "<p>Anyway, this conversation is going nowhere.</p>",
        "id": 206248998,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801991
    },
    {
        "content": "<p>tuple?</p>",
        "id": 206249002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596801995
    },
    {
        "content": "<p>I'll stop it.</p>",
        "id": 206249009,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596801997
    },
    {
        "content": "<p>give me something to work with here</p>",
        "id": 206249019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596802009
    },
    {
        "content": "<p>(but feel free to continue without me)</p>",
        "id": 206249022,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596802013
    },
    {
        "content": "<p>you are just asserting that things aren't clear without suggesting any alternative</p>",
        "id": 206249034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596802027
    },
    {
        "content": "<p>Maybe that's a french thing, but to me a \"a group structure on a set/type <code>G</code>\" designates the things we add to the \"raw\" <code>G</code> to make it behave like a group. That is, it corresponds to the class <code>group</code> of Lean, because it doesn't \"includes\" the set/type itself</p>",
        "id": 206249275,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1596802223
    },
    {
        "content": "<p>It's at least also a Dutch thing. If I pretend to only be a mathematician, \"a subgroup structure of G\" sounds more like \"an algebraic structure containing all subgroups of G\" than \"an object consisting of a subset of G along with a proof that this is a group\".</p>",
        "id": 206249468,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1596802396
    },
    {
        "content": "<p>It would be clearer for mathematician to say \"<code>subgroups G</code> is the type of subgroups of G, which are represented by a subset of G along with the proofs showing it is a subgroup\"</p>",
        "id": 206249735,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1596802584
    },
    {
        "content": "<p>A word to abbreviate this further would be nice, but I think \"structure\" is not the best choice for that. \"tuple\" might work if you explain that tuples can also contain proofs in type theory. \"object\" would be nice if it didn't have the category theory connotations.</p>",
        "id": 206250110,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1596802887
    },
    {
        "content": "<p>Hmm, how about borrowing the word <code>record</code> from Haskell/Agda? \"<code>subgroup G</code> is the type of records representing a subgroup of G\"?</p>",
        "id": 206250448,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1596803146
    },
    {
        "content": "<p>It's also not too hard to explain the lack of plural as a naming convention, where types in lean are named after the terminology you would use to refer to an element of that type</p>",
        "id": 206250867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596803468
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 206251497,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1596803924
    },
    {
        "content": "<p>Naming conventions are interesting. About a third of the time <code>set X</code> is named correctly. Mathematicians have three totally interchangable ways of thinking about <code>set X</code>. It could be the type of subsets of <code>X</code>, and if you think about it this way then you wish it was called <code>subset X</code>. It could be the type of sets made from elements of <code>X</code>, and here <code>set X</code> is the perfect name. Or you could just observe that the set of subsets of X is the power set of X so it should be called <code>powerset X</code>. The issue seems to be whether the name is being used to describe the type or the terms. </p>\n<p>An interesting example is <code>(T : set (set X))</code> in the definition of a topological space. Mathematicians might say \"T is a set of subsets of X (called the open sets...)\" and here we're using two different words for the same thing in Lean</p>",
        "id": 206255092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596806121
    },
    {
        "content": "<p>I'm still a beginner in mathematics so maybe what I say is irrelevant here, but don't you think you're spending too much energy on \"setifying\" Lean ? I mean, sure, types are not usual in maths, but why not just learn what they are once and then you can just use the exact terminology ? I don't think that's harder than some other concepts of maths</p>",
        "id": 206259837,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1596808829
    },
    {
        "content": "<p>That is such a French response ;-)</p>",
        "id": 206311385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596835535
    },
    {
        "content": "<p>Why not explain the translation? For me they are the same thing, ZFC sets and Lean types, they're just tools to set up maths</p>",
        "id": 206311517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596835607
    },
    {
        "content": "<p>How do you explain that terms of different types can't be compared with equality? That looks different than zfc to me.</p>",
        "id": 206315917,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1596838914
    },
    {
        "content": "<p>I don't think this is a problem because it's not actually a thing mathematicians usually want to do, so it usually only shows up in hypothetical arguments about how weird ZFC is</p>",
        "id": 206316411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596839294
    },
    {
        "content": "<p>OTOH, for many people <code>(2 : ℝ)</code> and <code>(2 : ℕ)</code> is the same number.</p>",
        "id": 206317713,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1596840586
    },
    {
        "content": "<p>Or <code>(2 : ℝ)</code> and <code>(2 : ℝ≥0)</code></p>",
        "id": 206317781,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1596840646
    },
    {
        "content": "<p>What about (2 : N) and (2 : Z/7)?</p>",
        "id": 206317806,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596840679
    },
    {
        "content": "<p>They really aren't the same number</p>",
        "id": 206317812,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596840688
    },
    {
        "content": "<p>Even better, 2 :N and 2 : C_7 (the 7-adic complex numbers). Are these the same?</p>",
        "id": 206317875,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596840742
    },
    {
        "content": "<p>Mathematics is the art of giving the same name to different things</p>",
        "id": 206354396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596904007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> : after I received your first answer, I tried to digest it and did not open Zulip in the meantime. As a result, I missed most of the above conversation and most of <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> 's complaints. They might be relevant for the following questions I had for you, but I am not sure. I'll post them as different messages so that they could be answered more easily. I will at any rate try to read, as you suggest, the intro to the file on <code>fractional ideals</code> to understand that file better.</p>",
        "id": 206678838,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597228215
    },
    {
        "content": "<p>1) You speak about universes and mention <code>Prop</code> and <code>Type</code>. Are there other examples of universes?</p>",
        "id": 206678848,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597228222
    },
    {
        "content": "<p>2) If I understand correctly, you are saying that to create a group one first creates a set <code>G:Type</code>and then produces a term of type <code>group G</code>. But when has the type <code>group G</code> being created? What I mean to ask is that on a given set one can put a trillion of structures (group, ring, topological field, manifold, etc...) and it seems to me that what you are saying is that each of these structures is a term of the relevant type. So we should have a trillion of types from which to pick a term... Or does one first create <code>G:Type</code> then <code>group G:Type</code> and then finally pick a term of the latter type to put a structure on <code>G</code>? And what is the state of affairs after having put this structure, does Lean still understand by <code>G</code> the underlying set or since this has been upgraded to a group, <code>G</code> now denotes the group (so, the set plus the chosen group structure) and is there a way to recover the underlying set?</p>",
        "id": 206678933,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597228306
    },
    {
        "content": "<p>3) A similar question for the type <code>subgroup G</code>: was this type built automatically once a term <code>_ inst_1: group G</code> had been picked up? But more fundamentally, if I want to (1) construct a group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\"> G' </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> and (2) prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>⊂</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\"> G' \\subset G </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.790992em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, it looks as a nightmare, because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> will be of type <code>G': Type</code> with its <code>_inst_1'</code> but I will eventually need <code>G': subgroup G</code> which I won't be able to perform.</p>",
        "id": 206679008,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597228356
    },
    {
        "content": "<p>4) In the same vein, if I produce a subset <code>A:set G</code> (or may be <code>A:set G.val</code> or whatever the name of<br>\nthe underlying set to G is) and want to prove that it is actually a subgroup, I will need to modify its type to <code>A: subset G</code>: is it doable? As a matter of fact, while I am writing this, I realize that may be the true statement is that \"there exists a subgroup of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> whose underlying set is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>\" and this looks more doable-but how, really?</p>",
        "id": 206679066,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597228416
    },
    {
        "content": "<p>1) No, <code>Prop</code> and <code>Type</code> are the only universes, as far as normal mathematics is concerned. Computer scientists also use something called <code>Type u</code> but this is something which doesn't exist in mathematics unless you are doing category theory; whenever I see <code>Type u</code> in mathlib I just pretend it says <code>Type</code>. The only other \"universe\" is <code>Sort u</code> or <code>Sort *</code> which means \"either <code>Prop</code> or <code>Type</code>\". </p>\n<p><a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/</a></p>\n<p>2) Yes, groups are unbundled. A group in ZFC is a set plus a group structure (multiplication, inverse, identity, axioms). In Lean's type theory a group is a type <code>G</code> and a term <code>_inst_1 : group G</code>. To give a term of type <code>group G</code> is to give all the group structure on <code>G</code>. I don't really understand your question. \"But when has the type <code>group G</code> being created?\". The <code>group</code> function (which takes as input a type <code>G</code> and has output the type of all group structures on <code>G</code>) is defined in mathlib. Yes, if you have some ordered Lie group like the reals then you will have to pick lots of terms, terms giving the structures and more terms saying that the structures are compatible. I'm not sure you have a question here. In maths we say \"let R be a commutative topological ring\", in Lean we say <code>variable (R : Type) [ring R] [topological_space R]  [topological_ring R]</code>. But <code>R</code> is still a type -- the \"upgrading\" you're talking about is all done by the type class inference system. In particular if <code>a b : R</code> then I can talk about <code>a * b</code> and the type class inference system finds the multiplication from the term of type <code>ring R</code> precisely because I use these square brackets <code>[]</code> -- that's the point of them.</p>\n<p>3) I have no idea what your mental model of these things are. The <code>subgroup</code> function was \"built automatically\" the moment you imported the relevant mathlib files. So sure, that function was built before you start. But if you now \"build\" G, whatever that means, Lean will not \"build\" <code>subgroup G</code> until you run the <code>subgroup</code> function on the input <code>G</code>. </p>\n<p>If you have two groups G and H and an injective group hom H -&gt; G then you can build the term of type <code>subgroup G</code>; conversely given a term of type <code>subgroup G</code> you can build a group <code>H</code> and an injective hom <code>H -&gt; G</code>. Mathematicians do this automatically but in Lean there is a separation between these two concepts. You say it looks like a nightmare but you're wrong. In practice you are either mostly doing groupy things with H or subgroupy things -- as a mathematician you have never really considered the difference, but Lean will make you do this. If it was a nightmare then we wouldn't have been able to make perfectoid spaces. Mathematicians do this all the time -- the natural number 37, the integer 37, the real number 37, the p-adic number 37 are all different 37's in Lean but this is not blocking progress. When you say \"I will eventually need <code>G' : subgroup G</code> you have misunderstood the solution. You will eventually need the term of type <code>subgroup G</code> corresponding to <code>G'</code> and you are used to also calling this term <code>G'</code> but in Lean it is simply called <code>f(G')</code> for some function f with a name like <code>to_subgroup</code> or something. The fact that <code>G'</code> and <code>f(G')</code> are not literally equal objects in Lean doesn't matter, because you do groupy things with G', and subgroupy things with f(G'), and when you want to relate constructions in the two universes the function is there which relates them, says the diagram commutes, whatever.</p>\n<p><a href=\"https://xenaproject.wordpress.com/2020/04/30/the-invisible-map/\">https://xenaproject.wordpress.com/2020/04/30/the-invisible-map/</a></p>\n<p>4) is the same question as 3 but in another domain. This phenomenon is everywhere when you do mathematics in type theory (as people have been doing for many decades) and they understand it well.</p>\n<p>The point is that as a mathematician you just <em>assume</em> that this set-up will be unworkable, because you can see that in theory this leads to complications, but in practice mathematical arguments either focus on one implementation or the other, so things work out fine in practice. Lean has a very sophisticated system for moving between concepts, typically represented either by weird little up-arrows or by nothing at all (depending on which system is doing the moving) and in practice it does not get in your way (most of the time).</p>",
        "id": 206680672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597229789
    },
    {
        "content": "<p>Thanks: one thing I had overlooked is that <code>group</code> and <code>subgroup</code> could be seen as functions producing a Type from another Type, and this makes sense and much of your answer looks much clearer.  I am not assuming that this set-up is unworkable, I am just trying to understand it and to put as few things as possible (to my brain/knowledge) under the rug. Time will help...</p>",
        "id": 206681570,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597230537
    },
    {
        "content": "<p>Everything is a function in functional programming -- or a constant (like nat).</p>",
        "id": 206682067,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597230966
    },
    {
        "content": "<p>You can be even more extreme and say that a constant is just a constant function that takes no argument</p>",
        "id": 206691600,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1597238109
    },
    {
        "content": "<p>The never-ending lesson one learns from Lean is the delicacy of \"is\".</p>",
        "id": 206795343,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310681
    },
    {
        "content": "<p>First, there are different equalities noticeable in proofs: syntactic equality, definitional equality, propositional equality, and isomorphism etc. And this list can be further divided when it comes to choosing a specific tool (e.g. tactics) for the job.</p>",
        "id": 206795360,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310696
    },
    {
        "content": "<p>Then, there are the \"is\" issues in modeling mathematical structures:</p>\n<p>In type theory, one starts with a hard type, which is a fixed and unbendable identity. This is far different from a set (in the sense of Mathematics), which is a flexible collection summoned by a certain condition (i.e. a proposition).</p>",
        "id": 206795381,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310719
    },
    {
        "content": "<p>This hard type will never be equal to another hard type in the sense of absolute equality. In order to make a hard type flexible enough to interact with other hard types like it \"is\" something (e.g. a group), one can give a mathematical structure to a type (by some proofs). If the type is <code>G</code> and the mathematical structure is <code>group</code> then it looks like <code>group G</code> in Lean.</p>",
        "id": 206795402,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310741
    },
    {
        "content": "<p>But this is not the right mental model to apply universally. One can't directly translate anything in the form of <code>group G</code> to \"<code>G</code> is a <code>group</code>\". An obvious counter-example is <code>subgroup G</code>, in this case, there's something new created as the <code>subgroup</code> \"of\" <code>G</code>. If we apply this counter-example back to <code>group G</code>, we will realize that <code>group G</code> also creates something new as the <code>group</code> structure \"of\" <code>G</code> that's not <code>G</code> itself.</p>",
        "id": 206795458,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310763
    },
    {
        "content": "<p>The same applies to <code>set G</code>. It's a set of <code>G</code> but <code>G</code> is not a set. There's no \"is\" here, only \"of\".</p>",
        "id": 206795475,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310787
    },
    {
        "content": "<p>These mathematical structures are all external to the type, like a role the type plays. And the role interacts with other roles of other types through all sorts of propositions about the roles, like our physical bodies are playing roles following social rules. And all these hard types, roles, propositions are all represented by types (in a general sense) in type theory to have a unified but also diverse solution.</p>",
        "id": 206795505,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310817
    },
    {
        "content": "<p>The situation is even more complicated for multiple parameters. A <code>vector_space K V</code> can be used to describe a vector space V \"over\" a field K, a <code>clifford_algebra R M Q</code> can be used to describe \"the Clifford algebra of a module <code>M</code> <em>over</em> a commutative ring <code>R</code>, <em>equipped with</em> a quadratic_form <code>Q</code>\".</p>",
        "id": 206795529,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310838
    },
    {
        "content": "<p>One might use \"is\" in the former case but \"of\" will be inevitable in the latter case, and both cases involve adverbs. The latter case also demonstrated that the last parameter might not be the thing we imagine to be \"is\" like in <code>vector_space K V</code>, because <code>clifford_algebra R M Q</code> \"is\" not any of <code>R</code>, <code>M</code>, <code>Q</code> but something new created out \"of\" them.</p>",
        "id": 206795542,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597310856
    },
    {
        "content": "<p>What the typeclass mechanism does in this context is just auto-dressing , when a raw type appears in a statement or a proof, it will find a proper role for the type that makes sense in the context, this is called “type class resolution” and when it fails, it complains about “fail to synthesize” and the raw type will start to have difficulties interacting with other roles of other types. There’re little tricks to provide hints for finding the right dress(role).</p>",
        "id": 206799304,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597314115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span>  Thanks for the answer: do you have an accessible and structured reference to study all this?</p>",
        "id": 206816838,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597326639
    },
    {
        "content": "<p>Filippo, you should know that Utensil likes to approach these kinds of questions from a philosophical (or maybe even poetical) point of view. But it doesn't necessarily makes it easier for others to understand, compared to the more conventional approach based on raw facts.</p>",
        "id": 206870276,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597352142
    },
    {
        "content": "<p>In the case at hand, you can first type <code>#check @group</code> (remember the <code>@</code> makes all inputs explicit) to see that <code>group</code> is a function with a single input which is a type and a single output which is a type (in the same universe, but let's ignore universes since they don't play any role here). So <code>group G</code> is meaningful if and only if <code>G</code> is a type. Then you can type <code>#print group</code> to see what would be the definition of <code>group G</code> (using jump to definition would be less useful here because groups are built on top of simpler stuff like monoids). After a couple of meta-data that are technical implementation details, you see</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">group</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">fields</span><span class=\"o\">:</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c_1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c_1</span><span class=\"o\">)</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">α</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">one_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">mul_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">mul_left_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n\n\n<p>The word structure on the first line is much closer to the C language use of this word than Bourbaki's word, it simply means a bunch of things put together. This first line also tells you again the information we got from <code>#check</code>.  Then comes the list of things (\"fields\") that are put together. The capital Pi is a weird notation that is preferred to a good old forall in contexts where data is involved (as opposed to statements). For instance line 3 tells: if you give me a type <code>α</code> and a term <code>c</code> with type <code>group α</code> then I'll give you a multiplication map <code>α → α → α</code>. The next piece of data is two lines down: if you give me a type <code>α</code> and a term <code>c</code> with type <code>group α</code> then I'll give you a term with type <code>α</code> (and denote by one thanks to some trick that is irrelevant here). There is also the inversion map further down. All the other lines are axioms that multiplication and one should satisfy.</p>",
        "id": 206871959,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597352933
    },
    {
        "content": "<p>Fundamentally, everything we need to talk about needs to have a type. And in order to define a type from one or several existing types, you mostly need to tell how to create terms having that type and how to build a function whose domain is your new type. To make this more symmetric, you can say you need to describe how to define function <em>into</em> your new type, and <em>from</em> your new type. There are very few built-in ways to define types. Function types are built in, at the very core of everything. Almost everything else are inductive types, which are defined using the <code>inductive</code> keyword or, in an important special case, the <code>structure</code> (or <code>class</code>) keyword. Building terms of an inductive type is made using a constructor. Structures are inductive types with only one constructor, called <code>mk</code> by default. So you can learn how to build an element whose type is <code>group G</code> by typing <code>#check @group.mk</code> which indeed takes as input all the ingredients listed above. Calling this function directly is not very convenient when proofs are long so we have syntax sugar to help us (using <code>{ mul := ..., one :=...}</code> etc. But really this is calling this constructor function. The other direction is more complicated. To build a function <em>out</em> of <code>group G</code> you use the recursor <code>group.rec</code>. So you can <code>#check @group.rec</code>. It will tell you how to define a function taking as input a type <code>G</code> and a term <code>c</code> of type <code>group G</code> and get some term of type <code>C G</code> (but we can pretend this target type does not depend on <code>G</code> if you are interested in a fixed <code>G</code>). Basically you are allowed to use all the ingredients that go into the definition of a term with type <code>group G</code> but nothing else.</p>",
        "id": 206873295,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597353674
    },
    {
        "content": "<p>All this is explained much better in TPIL.</p>",
        "id": 206873517,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597353807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Thanks so much! This makes many things much clearer, above others that the syntax<br>\n<code>group.one : Π {α : Type u} [c : group α], α</code><br>\nmeans that the result is a term of type <code>α</code> and not <code>α</code> itself. I will play with <code>#check</code> and <code>#print</code> and try to develop some more intuition. Concerning TPIL, I must confess that it is not a very easy read-the examples are very much CS-oriented (at least, this is what I feel), and seldom Math-oriented. But I will try to study more before complaining...</p>",
        "id": 207015507,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1597486985
    },
    {
        "content": "<p>Yes, we're writing mathematics in Lean precisely because the TPIL examples aren't mathematical enough</p>",
        "id": 207015673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597487290
    },
    {
        "content": "<p>Which of course is perfect for some learners but not for my own target audience</p>",
        "id": 207015679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597487314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> <a href=\"#narrow/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60/near/206816838\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span>  Thanks for the answer: do you have an accessible and structured reference to study all this?</p>\n</blockquote>\n<p>What I shared before was merely what I made sense of my observation during breaking things and piecing things together in Lean.</p>\n<p>Systematic learning can be reading any of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> , <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> , #tutorial, <a href=\"https://leanprover-community.github.io/lftcm2020/\">LFTCM 2020 Workshop</a> or my personal first and favorite guide <a href=\"https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf\">The Hitchhiker’s Guide to Logical Verification</a> and doing exercises in them.</p>",
        "id": 207018940,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597493238
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> is the best source if you're looking for a math-oriented tutorial, but the Hitchhiker’s Guide has weaved a right proportion of type theory into the learning process so it's a good supplement for <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>  IMHO. On the other hand, <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> requires you to have an immersive walkthrough with it and examine the technicality carefully, it's easy to get lost in it if you don't already have a big picture.</p>\n<p>I also invested quite some time to read <a href=\"https://leanprover-community.github.io/papers.html\">related papers</a> about Lean &amp; Mathlib, about formalized math, about type foundations, and about the problems Lean 4 tries to solve, as well as the mathlib source and sometimes Lean source.</p>",
        "id": 207018942,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597493241
    },
    {
        "content": "<p>_<strong>Patrick Massot|110031</strong> <a href=\"#narrow/stream/113489-new-members/topic/difference.20.60let.60.20and.20.60have.60/near/206870276\">said</a>:</p>\n<blockquote>\n<p>Filippo, you should know that Utensil likes to approach these kinds of questions from a philosophical (or maybe even poetical) point of view. But it doesn't necessarily make it easier for others to understand, compared to the more conventional approach based on raw facts.</p>\n</blockquote>\n<p>Human's mind is a complicated machine, it never stops modeling raw facts, just as Einstein said, what you can observe depends on the theory you use. Mental models can be subconscious but it's always there, both helping you and creating obstacles for the specific job.</p>\n<p>Besides gathering more raw facts by doing exercise, an important step for adjusting it is trying to explicitly state the inaccurate but partially working mental models. One thing that I particularly appreciate the Zulip chat is that there're the diverse (thus inspiring) metanarratives about modeling math in Lean.</p>",
        "id": 207019831,
        "sender_full_name": "Utensil Song",
        "timestamp": 1597494602
    },
    {
        "content": "<p>While we're listing things to learn from, the opening chapters of the Homotopy Type Theory book are a great introduction to the basics of dependent type theory, for people with a mathematical background.</p>",
        "id": 207020133,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597495082
    }
]
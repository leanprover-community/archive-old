[
    {
        "content": "<p>I have read a couple of discussions of \"dangerous instance\" linter errors, but can't figure out how to fix my specific one (<a href=\"https://github.com/leanprover-community/mathlib/issues/3210\">#3210</a>):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">normed_algebra</span><span class=\"bp\">.</span><span class=\"n\">to_nonzero</span> <span class=\"o\">{</span><span class=\"err\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"err\">ùïú&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"err\">ùïú</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"err\">ùïú&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">normed_algebra</span> <span class=\"err\">ùïú</span> <span class=\"err\">ùïú&#39;</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonzero</span> <span class=\"err\">ùïú&#39;</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">zero_ne_one</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">norm_pos_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">normed_algebra</span><span class=\"bp\">.</span><span class=\"n\">norm_one</span> <span class=\"err\">ùïú</span> <span class=\"err\">ùïú&#39;</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>What is the problem?</p>",
        "id": 202245302,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593364230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  There result only mentions <code>k'</code> but the statement also depends on <code>k</code>.</p>",
        "id": 202245316,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593364270
    },
    {
        "content": "<p>So if it tries to prove <code>nonzero k'</code> then it will go on a wild goose chase to find a <code>k</code>.</p>",
        "id": 202245325,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593364298
    },
    {
        "content": "<p>That's \"dangerous\".</p>",
        "id": 202245330,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593364312
    },
    {
        "content": "<p>Ahh.</p>",
        "id": 202245370,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593364326
    },
    {
        "content": "<p>(Note that your statement doesn't seem to need anything about <code>normed_*</code>. Just fields and algebras would also work.)</p>",
        "id": 202245376,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593364351
    },
    {
        "content": "<p>Oh, really?  I used <code>norm_pos_iff</code> in my proof.</p>",
        "id": 202245381,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593364374
    },
    {
        "content": "<p>Is <code>algebra_map</code> required to be injective in mathlib?</p>",
        "id": 202245387,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593364394
    },
    {
        "content": "<p>I don't actually need this instance, so I can kill it if fixing it is too difficult.  But is there a fix?</p>",
        "id": 202245457,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593364514
    },
    {
        "content": "<p>Ooh wait... I'm silly.</p>",
        "id": 202245739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593364912
    },
    {
        "content": "<p>It doesn't work with just fields.</p>",
        "id": 202245786,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593364933
    },
    {
        "content": "<p>Is there a change I can make to pass the linter?</p>",
        "id": 202246117,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593365472
    },
    {
        "content": "<p>I think we really don't want this instance.</p>",
        "id": 202246192,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593365610
    },
    {
        "content": "<p>It could be a local instance in some situations.</p>",
        "id": 202246195,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593365623
    },
    {
        "content": "<p>OK, then I will just prove the lemma <code>zero_ne_one</code></p>",
        "id": 202246253,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593365693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> You can replace <code>instance</code> with <code>def</code>, and call it with</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">nonzero</span> <span class=\"n\">k&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">normed_algebra</span><span class=\"bp\">.</span><span class=\"n\">to_nonzero</span> <span class=\"n\">k</span> <span class=\"n\">k&#39;</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>whenever you need it.</p>",
        "id": 202246315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593365789
    },
    {
        "content": "<p>Johan, I did actually try replacing <code>instance</code> with <code>def</code>, and got the following linter error:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> INCORRECT DEF/LEMMA: -/</span>\n<span class=\"c1\">-- analysis/normed_space/basic.lean</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">normed_algebra</span><span class=\"bp\">.</span><span class=\"n\">to_nonzero</span> <span class=\"c\">/-</span><span class=\"cm\"> is a def, should be a lemma/theorem -/</span>\n</code></pre></div>",
        "id": 202246489,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593366050
    },
    {
        "content": "<p>Aaah, then just do what it says (-;</p>",
        "id": 202246555,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593366139
    },
    {
        "content": "<p>I.e., make it <code>lemma</code> instead of <code>def</code>.</p>",
        "id": 202246560,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593366150
    },
    {
        "content": "<p>OK, I will.  Is it really possible to have a lemma of non-Prop type?</p>",
        "id": 202248043,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593368314
    },
    {
        "content": "<p>It is a Prop</p>",
        "id": 202248171,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593368550
    },
    {
        "content": "<p>Is this a feature of all structures?  Or just specifically of the structure <code>nonzero</code>, which has one field, of type Prop?</p>",
        "id": 202248254,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593368720
    },
    {
        "content": "<p>It's only a Prop if there is <code>: Prop</code> written before <code>:=</code>.</p>",
        "id": 202248402,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593368928
    },
    {
        "content": "<p>This is a little mysterious to me, but if someone can suggest the appropriate section of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a>, I will read up.</p>",
        "id": 202248434,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593368996
    },
    {
        "content": "<p>Oh it's actually not a structure technically, it's defined as an inductive proposition for some reason</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"kn\">inductive</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span>\n</code></pre></div>",
        "id": 202248508,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593369112
    },
    {
        "content": "<p>whoops I just noticed you were talking about <code>nonzero</code> not <code>nonempty</code>.</p>",
        "id": 202253275,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593375709
    },
    {
        "content": "<p>Anyways <code>class nonzero (Œ± : Type u) [has_zero Œ±] [has_one Œ±] : Prop :=</code> is also declared to be a <code>Prop</code>.</p>",
        "id": 202253330,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593375776
    },
    {
        "content": "<p>I think I see; are there many such classes?  Like, from the user's point of view <code>[nonempty Œ±]</code> and <code>[ring Œ±]</code> look the same; is <code>ring</code> a Prop?</p>",
        "id": 202253857,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593376603
    },
    {
        "content": "<p>No, it can't be because it contains the <code>+</code> and <code>*</code> operations which are data.</p>",
        "id": 202253865,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593376623
    },
    {
        "content": "<p>OK, this is why when I was discussing <code>subsingleton</code> and <code>unique</code> with <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> yesterday, he <a href=\"#narrow/stream/116395-maths/topic/zero.20ring/near/202202519\">noted</a> that <code>unique</code> was data.</p>",
        "id": 202254025,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593376770
    },
    {
        "content": "<p>And why, in the <a href=\"https://github.com/leanprover-community/mathlib/blob/5def1eeb556e98a709a3d352bf10440b1f2ddd82/src/algebra/ring.lean#L179\">code</a> resulting from that discussion, <code>psum</code> is used for <code>unique</code> but <code>‚à®</code> for <code>subsingleton</code>?</p>",
        "id": 202254175,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1593376925
    },
    {
        "content": "<p>We are slowly beginning to refactor algebra so that \"core\" classes like <code>integral_domain</code> are data (they contain the addition, multiplication, 0 and 1) and then there are lots of classes on top called things like <code>is_local_ring R</code>, the idea being that the <code>is</code> tells you what the props are, but then it was decided that <code>local_ring R</code> was smaller, so now you can't tell again.</p>",
        "id": 202254472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593377363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Dangerous.20instance/near/202253865\">said</a>:</p>\n<blockquote>\n<p>No, it can't be because it contains the <code>+</code> and <code>*</code> operations which are data.</p>\n</blockquote>\n<p>I was just looking at this and wondered what is meant here by is/are data? Like they are positive information? How does this work in Lean?</p>",
        "id": 202254573,
        "sender_full_name": "Dave",
        "timestamp": 1593377512
    },
    {
        "content": "<p>types and terms live in the <code>Type</code> universe and are data. Theorems and proofs live in the <code>Prop</code> universe and aren't. The difference between <code>add</code> and <code>add_assoc</code> is that <code>add</code> is a definition, so lives on the <code>Type</code> side of things (its output is a number), but <code>add_assoc</code> is a proof, so lives on the <code>Prop</code> side of things.</p>",
        "id": 202254649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593377609
    },
    {
        "content": "<p>Thank you. This was a very good explanation, I think</p>",
        "id": 202254710,
        "sender_full_name": "Dave",
        "timestamp": 1593377667
    },
    {
        "content": "<p>Kevin has a nice recent blog post that's also related: <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/</a></p>",
        "id": 202254833,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593377820
    },
    {
        "content": "<p>I will read this now, thanks</p>",
        "id": 202254851,
        "sender_full_name": "Dave",
        "timestamp": 1593377860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> you should announce your blogposts somewhere in this Zulip. I always end up seeing them days or weeks after they come out...</p>",
        "id": 202254905,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593377917
    },
    {
        "content": "<p>I tend to announce them on Twitter and the discord -- I think that just an announcement of a blog post is a bit off topic for this site.</p>",
        "id": 202255077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593378122
    },
    {
        "content": "<p>They're all Lean-related, so I don't see why they'd be off-topic.</p>",
        "id": 202255153,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378191
    },
    {
        "content": "<p>Hey so I was reading the blog post and it says that proofs are terms in type theory, but up there you said that terms were types and proofs were props</p>",
        "id": 202255217,
        "sender_full_name": "Dave",
        "timestamp": 1593378246
    },
    {
        "content": "<p>Is there some elaboration that  makes sense of this?</p>",
        "id": 202255227,
        "sender_full_name": "Dave",
        "timestamp": 1593378257
    },
    {
        "content": "<p>Everything is a term in Lean's type theory.</p>",
        "id": 202255235,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378286
    },
    {
        "content": "<p>Some terms are types and some types are props.</p>",
        "id": 202255268,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378339
    },
    {
        "content": "<p>what terms are not types</p>",
        "id": 202255313,
        "sender_full_name": "Dave",
        "timestamp": 1593378371
    },
    {
        "content": "<p><code>1</code> is not a type.</p>",
        "id": 202255317,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378386
    },
    {
        "content": "<p>so things like constants?</p>",
        "id": 202255323,
        "sender_full_name": "Dave",
        "timestamp": 1593378398
    },
    {
        "content": "<p>Not necessarily, you can declare type constants.</p>",
        "id": 202255329,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378420
    },
    {
        "content": "<p>so 1 could be a type?</p>",
        "id": 202255343,
        "sender_full_name": "Dave",
        "timestamp": 1593378449
    },
    {
        "content": "<p>types are sets, terms are their elements</p>",
        "id": 202255347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593378470
    },
    {
        "content": "<p>1 is not a type because it's not a set</p>",
        "id": 202255353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593378478
    },
    {
        "content": "<p>When I wrote <code>1</code>, I meant the term <code>1 : nat</code>. This is not a type and cannot be made a type.</p>",
        "id": 202255390,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378488
    },
    {
        "content": "<p>that analogy seems kinda reasonable. so a proof is a term of the type prop? is that ok to say?</p>",
        "id": 202255412,
        "sender_full_name": "Dave",
        "timestamp": 1593378521
    },
    {
        "content": "<p>oh ok <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span></p>",
        "id": 202255417,
        "sender_full_name": "Dave",
        "timestamp": 1593378537
    },
    {
        "content": "<p><code>proof : P</code> and <code>P : Prop</code>, like <code>1 : real</code> and <code>real : Type</code></p>",
        "id": 202255422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593378546
    },
    {
        "content": "<p><code>proof  : 2+2=4</code> and <code>2+2=4 : Prop</code></p>",
        "id": 202255427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593378561
    },
    {
        "content": "<p>right ok this makes sense</p>",
        "id": 202255432,
        "sender_full_name": "Dave",
        "timestamp": 1593378582
    },
    {
        "content": "<p>I think I learned most of this from chapters 2+3 of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a></p>",
        "id": 202255476,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378606
    },
    {
        "content": "<p>also you said 1 is not a set, but what if you are an evil person and you say something like <code>1 = {{}}</code> ?</p>",
        "id": 202255496,
        "sender_full_name": "Dave",
        "timestamp": 1593378650
    },
    {
        "content": "<p>That's a different <code>1</code> then.</p>",
        "id": 202255504,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378669
    },
    {
        "content": "<p>why because it's something like <code>1 : ordinals</code>instead of <code>1:nat</code> ?</p>",
        "id": 202255540,
        "sender_full_name": "Dave",
        "timestamp": 1593378722
    },
    {
        "content": "<p>Yeah, basically. Any term can only have one type. So two terms with different types cannot be equal.</p>",
        "id": 202255607,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378825
    },
    {
        "content": "<p>there's a very nice picture in hitchhiker's guide to logical verification:<br>\n<a href=\"/user_uploads/3121/BmWONwPG_FNw2RyZU2oNpH8B/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/BmWONwPG_FNw2RyZU2oNpH8B/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/BmWONwPG_FNw2RyZU2oNpH8B/image.png\"></a></div>",
        "id": 202255662,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593378857
    },
    {
        "content": "<p>but i guess whether propositions are types depends on your perspective :)</p>",
        "id": 202255685,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593378918
    },
    {
        "content": "<p>There's a link to the hitchhiker's guide on the website <a href=\"https://leanprover-community.github.io/learn.html#textbooks\">here</a>. I liked it a lot!</p>",
        "id": 202255689,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593378931
    },
    {
        "content": "<p>ok I like this image, thanks- also would <code>1 = {{}}</code> mean that each ordinal is kind of a type on its own?</p>",
        "id": 202255695,
        "sender_full_name": "Dave",
        "timestamp": 1593378940
    },
    {
        "content": "<p>what you are writing has no meaning</p>",
        "id": 202255704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593378956
    },
    {
        "content": "<p>this is not set theory, and you cannot make definitions by just writing down sets</p>",
        "id": 202255748,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593378975
    },
    {
        "content": "<p>oops meant equals there</p>",
        "id": 202255755,
        "sender_full_name": "Dave",
        "timestamp": 1593378981
    },
    {
        "content": "<p>oh ok. I only brought it up because you said types are sets so I thought we could play with sets.</p>",
        "id": 202255770,
        "sender_full_name": "Dave",
        "timestamp": 1593379016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Dangerous.20instance/near/202248508\">said</a>:</p>\n<blockquote>\n<p>Oh it's actually not a structure technically, it's defined as an inductive proposition for some reason</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"kn\">inductive</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>It can't be a structure, because then lean would try to create a projection called <code>val</code> which it can't because of universe restrictions</p>",
        "id": 202267490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593398951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113489-new-members/topic/Dangerous.20instance/near/202254025\">said</a>:</p>\n<blockquote>\n<p>OK, this is why when I was discussing <code>subsingleton</code> and <code>unique</code> with <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> yesterday, he <a href=\"#narrow/stream/116395-maths/topic/zero.20ring/near/202202519\">noted</a> that <code>unique</code> was data.</p>\n<p>And why, in the <a href=\"https://github.com/leanprover-community/mathlib/blob/5def1eeb556e98a709a3d352bf10440b1f2ddd82/src/algebra/ring.lean#L179\">code</a> resulting from that discussion, <code>psum</code> is used for <code>unique</code> but <code>‚à®</code> for <code>subsingleton</code>?</p>\n</blockquote>\n<p>Yup, exactly.</p>",
        "id": 202270294,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593403557
    },
    {
        "content": "<p>I've got a dangerous instance I managed to fix but which I'd still like to understand why is dangerous.<br>\nThe problem is with the following, placed in <code>topology/module</code> right after the definition of topological module:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- A topological algebra, over a semiring which is topological semiring, is an algebra that is</span>\n<span class=\"cm\">both a topological semimodule and a topological semiring. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">topological_algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">extends</span> <span class=\"n\">topological_semimodule</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">topological_semiring</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n\n\n<p>and the Linter says</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> DANGEROUS INSTANCES FOUND.</span>\n<span class=\"cm\">These instances are recursive, and create a new type-class problem which will have metavariables.</span>\n<span class=\"cm\">  Possible solution: remove the instance attribute or make it a local instance instead.</span>\n\n<span class=\"cm\">  Currently this linter does not check whether the metavariables only occur in arguments marked with `out_param`, in which case this linter gives a false positive.: -/</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">topological_algebra</span><span class=\"bp\">.</span><span class=\"n\">to_topological_semiring</span> <span class=\"c\">/-</span><span class=\"cm\"> The following arguments become metavariables. argument 1: (R : Type u) -/</span>\n</code></pre></div>\n\n\n<p>I don't even know what a metavariable is in this case so I guess I'm looking for a very basic answer</p>",
        "id": 203735301,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594656802
    },
    {
        "content": "<p>Hmm... I'm confused about what is dangerous here... <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Could one of you take a look please?</p>",
        "id": 203736758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594657583
    },
    {
        "content": "<p><code>topological_algebra R A</code> has two arguments but has a parent <code>topological_semiring A</code> with only one argument, this is not allowed</p>",
        "id": 203738834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594658759
    },
    {
        "content": "<p>because it means that when determining if a type <code>A</code> has <code>topological_semiring A</code>, it will check if <code>topological_algebra ? A</code> which is bad</p>",
        "id": 203738924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594658800
    },
    {
        "content": "<p>Ooh right, of course... I should have seen this <span aria-label=\"expressionless\" class=\"emoji emoji-1f611\" role=\"img\" title=\"expressionless\">:expressionless:</span></p>",
        "id": 203739179,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594658976
    },
    {
        "content": "<p>What is the most common solution to this? Moving topological ring to the hypotheses?</p>",
        "id": 203745220,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594661829
    },
    {
        "content": "<p>Yup... but I understand that this is becoming really bulky</p>",
        "id": 203745353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594661886
    },
    {
        "content": "<p>You can however move <code>algebra R A</code> to the <code>extends</code></p>",
        "id": 203745384,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594661907
    },
    {
        "content": "<p>Yeah the point is that I do not really need the notion of <code>topological_algebra</code> it was just so to make it closer to normal maths, but from a formal point of view one just needs to write down <code>topological_semiring</code> and <code>topological_module</code> so I guess I'll just remove it completely</p>",
        "id": 203745615,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594662041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Dangerous.20instance/near/203745384\">said</a>:</p>\n<blockquote>\n<p>You can however move <code>algebra R A</code> to the <code>extends</code></p>\n</blockquote>\n<p>I would really like to do this but people did not do it in the past for group, ring etc, so I guess they had some reason not to do it</p>",
        "id": 203745728,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594662112
    },
    {
        "content": "<p>What do you mean? <code>ring</code> extends <code>monoid</code> and <code>add_group</code>...</p>",
        "id": 203745844,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594662160
    },
    {
        "content": "<p>No <code>topological_group</code>, <code>topological_ring</code></p>",
        "id": 203745879,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594662181
    },
    {
        "content": "<p>I see. That's right. Because it allows for easier mixing of algebraic properties and topological ones.</p>",
        "id": 203745947,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594662238
    },
    {
        "content": "<p>Otherwise we would end up with <code>topological_X</code> for all <code>X</code> in the algebra part of the library. And that's quite a lot.</p>",
        "id": 203746032,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594662272
    },
    {
        "content": "<p>Ok it make sense</p>",
        "id": 203746068,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594662290
    },
    {
        "content": "<p>Do you think it'd make sense to have <code>topological_algebra</code> as an abbreviation just as <code>module</code> for <code>semimodule</code>? It's quite useless but probably makes hypotheses clear and forces you not to forget the <code>topological_semiring</code> hypothesis which Lean often does not understand is the correct missing hypothesis from the proof</p>",
        "id": 203746331,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594662445
    },
    {
        "content": "<p>I don't know. At the moment I would just continue without it. If we find out that it really would help, we can always add it later.</p>",
        "id": 203746639,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594662584
    },
    {
        "content": "<p>Okok</p>",
        "id": 203746731,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594662609
    },
    {
        "content": "<p>Every new concept brings the obligation with it to write an interface for it, and connect it to all related concepts...</p>",
        "id": 203746741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594662612
    },
    {
        "content": "<p>Just as a preamble: the following problem arose in geometry but the problem itself has nothing to do with geometry. I believe it is a general problem that probably was probably faced in mathlib many times, so I don't think familiarity with the geometry section of mathlib is necessary to help me here!</p>\n<p>I have a new dangerous instance. This time it is the opposite: I know why it is there but I have no idea about how to fix it.<br>\nWith this definition of Lie_group:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">Lie_group</span> <span class=\"o\">{</span><span class=\"err\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">smooth_mul</span> <span class=\"o\">:</span> <span class=\"n\">smooth</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">√ó</span><span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">smooth_inv</span> <span class=\"o\">:</span> <span class=\"n\">smooth</span> <span class=\"n\">I</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">‚Åª¬π</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>I need this instance</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">to_topological_group</span> <span class=\"o\">{</span><span class=\"err\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">ùïú</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Lie_group</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">topological_group</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">continuous_mul</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">smooth_mul</span><span class=\"bp\">.</span><span class=\"n\">continuous</span><span class=\"o\">,</span>\n  <span class=\"n\">continuous_inv</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">smooth_inv</span><span class=\"bp\">.</span><span class=\"n\">continuous</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>However this produces</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">to_topological_group</span> <span class=\"c\">/-</span><span class=\"cm\"> The following arguments become metavariables.</span>\n<span class=\"cm\">argument 1: {ùïú : Type u_1}, argument 3: {E : Type u_2}, argument 6: {I : model_with_corners ùïú E E} -/</span>\n</code></pre></div>\n\n\n<p>and I really need this instance otherwise I have to write twice every definition applying to <code>topological_group</code>.<br>\nIf you want a mwe I can produce it easily even if I don't know how having code locally could help, since this is an exclusively conceptual problem.<br>\nWhat can I do?</p>",
        "id": 204194538,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594984782
    },
    {
        "content": "<p>Lie group should take <code>[topological_group G]</code> as an instance parameter in this kind of situation. And you can have another constructor that constructs both the topological structure and the Lie group structure out of a structure called something like <code>Lie_group.core</code>. In the same way that you could construct a topology from a charted space structure, but instead charted spaces take the topology as an instance parameter, but there is a constructor in terms of <code>charted_space_core</code></p>",
        "id": 204195651,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594985687
    },
    {
        "content": "<p>Ok thanks I will do that</p>",
        "id": 204195812,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1594985838
    },
    {
        "content": "<p>Nicol√≤, did you watch <a href=\"https://youtu.be/RTfjSlwbKjQ?list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N\">https://youtu.be/RTfjSlwbKjQ?list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N</a> ? It explains this issue pretty nicely.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"RTfjSlwbKjQ\" href=\"https://youtu.be/RTfjSlwbKjQ?list=PLlF-CfQhukNlxexiNJErGJd2dte_J1t1N\"><img src=\"https://i.ytimg.com/vi/RTfjSlwbKjQ/default.jpg\"></a></div>",
        "id": 204197593,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594987440
    }
]
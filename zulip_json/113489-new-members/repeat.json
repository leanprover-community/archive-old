[
    {
        "content": "<p>The documentation for repeat says: \"... the tactic is applied recursively to all the generated subgoals until it eventually fails. The recursion stops in a subgoal when the tactic has failed to make progress.\"</p>\n<p>Which is it: Is it applied recursively until it fails, or until it fails to make progress?</p>",
        "id": 252128379,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1630905982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> has marked this topic as unresolved.</p>",
        "id": 253894896,
        "sender_full_name": "Notification Bot",
        "timestamp": 1632000379
    },
    {
        "content": "<p>I'll reopen this thread and ask again because I just don't understand what I'm seeing. <br>\nThe code I'm working on is a bit too complicated to post an mwe, so hopefully you can bear with me. In the code below, I get an output with two different goals. It reports the error <code>error: solve1 tactic failed, focused goal has not been solved</code> on the final closing bracket. This suggests to me that at the very least , lines 4-6 below are not causing an error. But when I comment those lines out and rerun the program, I get <em>a different output</em>, which only has one goal, (but still says the same error that the goal is not solved by the final bracket).</p>\n<p>This makes no sense to me, because, based om my reading of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/repeat\">docs#repeat</a>, if the middle three lines don't cause a failure, the output of <code>t, repeat { t, },</code> should be the same as <code>repeat { t, },</code>. What gives?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">integral_domain_simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span> <span class=\"k\">with</span> <span class=\"n\">integral_domain_simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">},</span> <span class=\"c1\">-- clear \"found_zero\" if present</span>\n  <span class=\"n\">done</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"kd\">begin</span> <span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span> <span class=\"k\">with</span> <span class=\"n\">integral_domain_simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">},</span> <span class=\"c1\">-- clear \"found_zero\" if present</span>\n    <span class=\"n\">done</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"kd\">begin</span> <span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"kd\">end</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 253895519,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632001165
    },
    {
        "content": "<p>I would suggest replacing <code>repeat</code> with <code>iterate n</code> for different values of <code>n</code> and see for which values it succeeds</p>",
        "id": 253896116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632001887
    },
    {
        "content": "<p>It is worth noting that <code>begin ... end</code> in tactic mode is the same as <code>{ ... }</code>. In particular, it will fail if you haven't closed the goal at the end of the block</p>",
        "id": 253896186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632001963
    },
    {
        "content": "<p>This looks like an error reporting bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">∧</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">done</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">trivial</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">},</span> <span class=\"c1\">-- the error is actually here</span>\n\n  <span class=\"c1\">-- uncommenting this doesn't work</span>\n  <span class=\"c1\">-- refine trivial,</span>\n\n<span class=\"kd\">end</span> <span class=\"c1\">-- but it is reported here</span>\n</code></pre></div>",
        "id": 253896309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002137
    },
    {
        "content": "<p>So what is really happening is that your first <code>begin cases</code> line is failing and the repeat never runs</p>",
        "id": 253896374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/repeat/near/253896186\">said</a>:</p>\n<blockquote>\n<p>It is worth noting that <code>begin ... end</code> in tactic mode is the same as <code>{ ... }</code>. In particular, it will fail if you haven't closed the goal at the end of the block</p>\n</blockquote>\n<p>This is certainly good to know.</p>",
        "id": 253896386,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002220
    },
    {
        "content": "<p>You should use <code>id { ... }</code> instead to group tactics without the implicit <code>done</code> at the end</p>",
        "id": 253896403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002247
    },
    {
        "content": "<p>Sorry, what does <code>id</code> do?</p>",
        "id": 253896505,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002383
    },
    {
        "content": "<p>it's a tactic combinator like <code>try</code></p>",
        "id": 253896562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002406
    },
    {
        "content": "<p>it does nothing, it's the identity function</p>",
        "id": 253896589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002419
    },
    {
        "content": "<p>but the <code>{ ... }</code> is part of the syntax, so it doesn't count as regular focusing brackets</p>",
        "id": 253896620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002460
    },
    {
        "content": "<p>So you mean I should use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"n\">id</span> <span class=\"o\">{</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span> <span class=\"k\">with</span> <span class=\"n\">integral_domain_simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">},</span> <span class=\"c1\">-- clear \"found_zero\" if present</span>\n  <span class=\"n\">id</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>And this will cause it to not fail if the goal is completed by the second line?</p>",
        "id": 253896651,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002513
    },
    {
        "content": "<p>The braces after <code>iterate 2 { ... }</code> are also part of the syntax</p>",
        "id": 253896698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002536
    },
    {
        "content": "<p>so that's not well formed</p>",
        "id": 253896700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002540
    },
    {
        "content": "<p>Immediately after <code>iterate 2</code> though, you already have a tactic block argument, so you don't need the <code>id</code></p>",
        "id": 253896718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002578
    },
    {
        "content": "<p>It's useful in things like <code>done &lt;|&gt; id { ... }</code></p>",
        "id": 253896730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002594
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">iterate</span> <span class=\"mi\">2</span>  <span class=\"o\">{</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span> <span class=\"k\">with</span> <span class=\"n\">integral_domain_simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">},</span> <span class=\"c1\">-- clear \"found_zero\" if present</span>\n  <span class=\"n\">done</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">id</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span> <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 253896742,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002617
    },
    {
        "content": "<p>you can probably replace <code>done &lt;|&gt; id ...</code> with <code>try ...</code> in this case</p>",
        "id": 253896797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002658
    },
    {
        "content": "<p>Wouldn't that loop forever with repeat?</p>",
        "id": 253896821,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002690
    },
    {
        "content": "<p>yes it would</p>",
        "id": 253896825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002697
    },
    {
        "content": "<p>I think <code>done</code> would as well though</p>",
        "id": 253896845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002721
    },
    {
        "content": "<p>if there are no goals then it will just spin with <code>done</code> succeeding every time</p>",
        "id": 253896858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002745
    },
    {
        "content": "<p>See the very first comment in this thread. The docs for repeat should probably be changed to not say \"when the tactic has failed to make progress.\"</p>",
        "id": 253896906,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002766
    },
    {
        "content": "<p>\"make progress\" isn't something lean knows how to detect</p>",
        "id": 253896916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002790
    },
    {
        "content": "<p>Exactly my point</p>",
        "id": 253896923,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002804
    },
    {
        "content": "<p>it assumes that tactics fail when they fail to make progress</p>",
        "id": 253896924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002805
    },
    {
        "content": "<p>which is generally true of front end tactics</p>",
        "id": 253896929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002819
    },
    {
        "content": "<p>But not of all tactics, as I realized to my confusion a few weeks ago.</p>",
        "id": 253897014,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632002924
    },
    {
        "content": "<p>If you use the more explicit structural tactics like <code>done</code> and <code>try</code> that's not quite true anymore</p>",
        "id": 253897029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632002953
    },
    {
        "content": "<p>Ok, I am confused again. <code>iterate { fail_if_success { done }, ... }</code> succeeds in producing 5 new simpler goals in 2 minutes or so. But <code>repeat { fail_if_success { done }, ... }</code> and <code>repeat { ... }</code> both seem to hang, taking at least 5 minutes. Why would these behave differently?</p>",
        "id": 253901067,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632007818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> has marked this topic as unresolved.</p>",
        "id": 253901070,
        "sender_full_name": "Notification Bot",
        "timestamp": 1632007823
    },
    {
        "content": "<p>It would really help if you made <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>'s for this stuff</p>",
        "id": 253901377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632008223
    },
    {
        "content": "<p>Why are these tactics taking minutes? You aren't supposed to exhaust the recursion limit</p>",
        "id": 253901447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632008287
    },
    {
        "content": "<p>Yes, sorry about that. Let me try to make a simpler mwe.</p>",
        "id": 253901458,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632008303
    },
    {
        "content": "<p>Part of the problem is there is a lot of code earlier on in the file that takes a while to run which generates these equations, and it's hard to separate that time from the time taken by the tactics we are talking about.</p>",
        "id": 253901547,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632008409
    },
    {
        "content": "<p>You seem to think that the actual content of the blocks doesn't matter, so make a MWE with a simpler block</p>",
        "id": 253901567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632008461
    },
    {
        "content": "<p>my examples use <code>split</code> and <code>trivial</code> which is usually good enough for interesting branching patterns</p>",
        "id": 253901633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632008525
    },
    {
        "content": "<p>If you need an expensive tactic, use <code>sleep</code></p>",
        "id": 253901667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632008599
    },
    {
        "content": "<p>I wonder if I should <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> your problem though. This all looks very case-bashy and you haven't even shown what the goal is, but it looks like you are factoring a polynomial? I'm like 80% sure there is a better proof approach that involves specifying the factorization</p>",
        "id": 253901941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632008885
    },
    {
        "content": "<p>The problem is I keep making MWEs with simpler blocks and the error doesn't manifest.</p>",
        "id": 253901994,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632008990
    },
    {
        "content": "<p>Your block doesn't seem to reference any lemmas except whatever is in <code>integral_domain_simp</code>, so why not just have a big list of sorry lemmas and then your theorem statement? That will at least skip the top of the file</p>",
        "id": 253902085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009094
    },
    {
        "content": "<p>You can also use <code>trace_state</code> to see how the evaluation is progressing btw. How deep is this recursion?</p>",
        "id": 253902150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009149
    },
    {
        "content": "<p>Isn't it simpler to just use <code>iterate 3</code> or something?</p>",
        "id": 253902158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009162
    },
    {
        "content": "<p>Let me try to answer all these questions:</p>",
        "id": 253902201,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009230
    },
    {
        "content": "<p>What I am trying to do is to prove that a collection of ~50 equations over an integral domain implies a goal equation.</p>",
        "id": 253902274,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009298
    },
    {
        "content": "<p>how in the world did that happen</p>",
        "id": 253902287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009313
    },
    {
        "content": "<p>This problem arises in the context of the proof of soundness of a cryptographic construction called a SNARK.</p>",
        "id": 253902314,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009351
    },
    {
        "content": "<p>ah, well that explains it</p>",
        "id": 253902357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009363
    },
    {
        "content": "<p>I hope you have done everything possible to simplify the problem before the main proof</p>",
        "id": 253902391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009399
    },
    {
        "content": "<p>for example, if two of the equations imply a third equation that is more useful</p>",
        "id": 253902404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009423
    },
    {
        "content": "<p>breaking big proofs into small pieces is good for a bunch of reasons</p>",
        "id": 253902435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009463
    },
    {
        "content": "<p>Indeed, I have been working on this in parallel: I could try to look at the paper proof carefully and see if I could reduce the number of equations. Unfortunately, this doesn't bode well for being able to generalize to other constructions.</p>",
        "id": 253902444,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009474
    },
    {
        "content": "<p>in what way do you want to generalize?</p>",
        "id": 253902493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009492
    },
    {
        "content": "<p>I want to generalize to other SNARK constructions, which have different sets of equations.</p>",
        "id": 253902509,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009519
    },
    {
        "content": "<p>If I hard-code in \"these 30 equations are not necessary\" then I have to do that every time in the future.</p>",
        "id": 253902535,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009554
    },
    {
        "content": "<p>I don't mean to reduce the number of equations, I mean to factor the 50 lemmas -&gt; 1 conclusion proof into a tree like 10 x (5 equations -&gt; 1 concl) -&gt; 2 equations -&gt; 1 concl</p>",
        "id": 253902547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009569
    },
    {
        "content": "<p>It sounds like you want a general mechanism to prove theorems in this language</p>",
        "id": 253902648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009613
    },
    {
        "content": "<p>in which case you should write a custom tactic for it</p>",
        "id": 253902672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009622
    },
    {
        "content": "<p>I considered this.</p>",
        "id": 253902688,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009646
    },
    {
        "content": "<p>The <code>nsatz</code> tactic from coq seems to do what I would want.</p>",
        "id": 253902704,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009667
    },
    {
        "content": "<p>I expect writing a whole tactic from scratch to resolve these equations would be harder to do though.</p>",
        "id": 253902775,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009729
    },
    {
        "content": "<p>I don't think you need to be so ambitious as that</p>",
        "id": 253902814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009798
    },
    {
        "content": "<p>I mean a tactic to coordinate calls to <code>simp only</code> and <code>rw</code></p>",
        "id": 253902825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009815
    },
    {
        "content": "<p>i.e. what you are doing already</p>",
        "id": 253902831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009823
    },
    {
        "content": "<p>you just handle the goal manipulation and control flow</p>",
        "id": 253902884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632009853
    },
    {
        "content": "<p>I guess I don't understand how what you are suggesting is different from what I'm doing.</p>",
        "id": 253902936,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632009924
    },
    {
        "content": "<p>You will have much better control over the equations and recursion ordering. It's hard to demonstrate because you still haven't shown a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 253903051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632010044
    },
    {
        "content": "<p>Ok, here's an mwe I'm working on where iterate and repeat behave differently</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">my_section</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zero_eq_zero</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eq_self_iff_true</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n  <span class=\"n\">iterate</span> <span class=\"o\">{</span>\n    <span class=\"n\">fail_if_success</span> <span class=\"o\">{</span> <span class=\"n\">done</span> <span class=\"o\">},</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">,</span> <span class=\"n\">true_or</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">},</span> <span class=\"c1\">-- clear \"found_zero\" if present</span>\n    <span class=\"n\">done</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">id</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span> <span class=\"o\">},</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">my_section</span>\n</code></pre></div>",
        "id": 253903126,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632010120
    },
    {
        "content": "<p>But it sounds like you just haven't tried writing tactics before, it's not as hard as you think and they can be as simple or complicated as you like. You should watch Rob's metaprogramming tutorial</p>",
        "id": 253903130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632010127
    },
    {
        "content": "<p>Note that <code>iterate</code> and <code>repeat</code> are different tactics that do different things, as I mentioned. So it's not that much of a surprise that they act differently</p>",
        "id": 253903155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632010162
    },
    {
        "content": "<p>the difference is basically <code>iterate {tac} = tac, iterate {tac}</code> while <code>repeat {tac} = tac; repeat {tac}</code></p>",
        "id": 253903225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632010207
    },
    {
        "content": "<p>The <code>all_goals</code> behavior of <code>repeat</code> is important for this example. This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">iterate</span> <span class=\"o\">{</span>\n    <span class=\"n\">fail_if_success</span> <span class=\"o\">{</span> <span class=\"n\">done</span> <span class=\"o\">},</span>\n    <span class=\"n\">all_goals</span> <span class=\"o\">{</span>\n      <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">,</span> <span class=\"n\">true_or</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n      <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">},</span> <span class=\"c1\">-- clear \"found_zero\" if present</span>\n      <span class=\"n\">done</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">id</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 253903289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632010307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/repeat/near/253903130\">said</a>:</p>\n<blockquote>\n<p>But it sounds like you just haven't tried writing tactics before, it's not as hard as you think and they can be as simple or complicated as you like. You should watch Rob's metaprogramming tutorial</p>\n</blockquote>\n<p>I have watched it through twice. It seems like every time I encounter a pitfall, I have to watch it again.</p>",
        "id": 253903343,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632010336
    },
    {
        "content": "<p>If you hit any issues when writing tactics feel free to ask here</p>",
        "id": 253903354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632010364
    },
    {
        "content": "<p>Most tactics prefer to be called on one goal, and <code>repeat</code> does that, but <code>iterate</code> just calls <code>tac</code> repeatedly and doesn't care if the first invocation produced many subgoals</p>",
        "id": 253903375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632010401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/repeat/near/253903225\">said</a>:</p>\n<blockquote>\n<p>the difference is basically <code>iterate {tac} = tac, iterate {tac}</code> while <code>repeat {tac} = tac; repeat {tac}</code></p>\n</blockquote>\n<p>I have never read any formal documentation for the difference between <code>,</code> and <code>;</code>. I honestly don't understand the difference between these definitions. Shouldn't they be the same?</p>",
        "id": 253903784,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632010842
    },
    {
        "content": "<p>It seems like both of those definitions are just \"recursively apply tac on all subgoals, creating a branching tree of subgoals until you reach failure\".</p>",
        "id": 253903904,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632011003
    },
    {
        "content": "<p>That's what <code>;</code> does</p>",
        "id": 253903910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632011015
    },
    {
        "content": "<p><code>,</code> means do tac1, then do tac2</p>",
        "id": 253903915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632011027
    },
    {
        "content": "<p><code>tac1; tac2</code> means do tac1, then focus on each goal produced by tac1 and do tac2 in that state, then join all the goals that result</p>",
        "id": 253903971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632011070
    },
    {
        "content": "<p>Ok, I understand the difference between <code>,</code> and <code>;</code> I think. But that doesn't explain why iterate fails in a situation where repeat closes all goals.</p>",
        "id": 253904107,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632011245
    },
    {
        "content": "<p>Here's my logic: If repeat closes all goals, then essentially what it did to solve those goals is just to apply <code>tac</code> over and over, to whatever goal was on top of the stack at the time. If that succeeds, shouldn't iterate do the same thing?</p>",
        "id": 253904179,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632011327
    },
    {
        "content": "<p>I'm trying to get a better understanding by reading lean's definition of <code>iterate</code>. I reached this auxiliary function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`iterate_at_most' n t` repeats `t` `n` times or until `t` fails.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">iterate_at_most'</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">skip</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"n\">skip</span><span class=\"o\">,</span>\n  <span class=\"n\">iterate_at_most'</span> <span class=\"n\">n</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>What does the <code>|</code> between <code>try_core t</code> and <code>skip</code> do? This is one of those things that might have been covered in Rob Lewis course, but I can't remember all the details.</p>",
        "id": 253904697,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632011919
    },
    {
        "content": "<p>If the pattern doesn't match, it will run the thing on the other side of the <code>|</code> and skip the rest of the block</p>",
        "id": 253904789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012041
    },
    {
        "content": "<p>so here that means that if <code>try_core t</code> returns <code>none</code> (i.e. <code>t</code> fails) then the tactic terminates with success</p>",
        "id": 253904810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113489-new-members/topic/repeat/near/253904179\">said</a>:</p>\n<blockquote>\n<p>Here's my logic: If repeat closes all goals, then essentially what it did to solve those goals is just to apply <code>tac</code> over and over, to whatever goal was on top of the stack at the time. If that succeeds, shouldn't iterate do the same thing?</p>\n</blockquote>\n<p>Tactics are called on the entire tactic state, which includes the full list of goals, not just the one on top</p>",
        "id": 253904881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012144
    },
    {
        "content": "<p>Most tactics by convention only modify the top goal and leave the others alone, but not all</p>",
        "id": 253904893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012175
    },
    {
        "content": "<p>in particular, <code>done</code> acts differently if there are \"side goals\" after the main goal</p>",
        "id": 253904903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012192
    },
    {
        "content": "<p>because if the main goal is done then <code>done</code> will still fail because the side goals aren't</p>",
        "id": 253904916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012223
    },
    {
        "content": "<p>Ok, so then does a goal disappear when it is finished?</p>",
        "id": 253905003,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632012340
    },
    {
        "content": "<p>If I have two goals in my state that can both by finished by tac, and I call <code>tac, tac</code>, does that finish all goals?</p>",
        "id": 253905065,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632012390
    },
    {
        "content": "<p>Ok, I finally see why my mwe fails with iterate: the <code>try {simp only [mul_eq_zero, zero_mul, mul_zero, zero_eq_zero, or_true, true_or] at *}, </code> closes a goal, and then <code>done &lt;|&gt; id {cases ‹_ ∨ _› with found_zero found_zero; rw found_zero at *}, },</code> is applied <strong>to a different goal</strong></p>",
        "id": 253905187,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632012586
    },
    {
        "content": "<p>This is what was confusing.</p>",
        "id": 253905193,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632012599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113489-new-members/topic/repeat/near/253905065\">said</a>:</p>\n<blockquote>\n<p>If I have two goals in my state that can both by finished by tac, and I call <code>tac, tac</code>, does that finish all goals?</p>\n</blockquote>\n<p>Yes, assuming <code>tac</code> only acts on the first goal</p>",
        "id": 253905266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012665
    },
    {
        "content": "<p>Is there a way to say \"apply this list of tactics as if the top goal was the only goal in the environment\"</p>",
        "id": 253905356,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632012762
    },
    {
        "content": "<p>I thought this was accomplished with <code>{ ... }</code> or <code>id { ... }</code>, but neither of those make the iterate mwe succeed.</p>",
        "id": 253905384,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632012833
    },
    {
        "content": "<p>here's a tactic that I think represents the control flow you are going for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mysatz</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">,</span> <span class=\"n\">true_or</span><span class=\"o\">]</span>\n    <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"o\">{</span><span class=\"n\">fail_if_unchanged</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span><span class=\"o\">}],</span>\n  <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">get_goals</span> <span class=\"bp\">|</span> <span class=\"n\">skip</span><span class=\"o\">,</span>\n  <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n    <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span> <span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">],</span>\n    <span class=\"n\">mysatz</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">mysatz</span>\n</code></pre></div>",
        "id": 253905429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113489-new-members/topic/repeat/near/253905356\">said</a>:</p>\n<blockquote>\n<p>Is there a way to say \"apply this list of tactics as if the top goal was the only goal in the environment\"</p>\n</blockquote>\n<p><code>focus { tac }</code></p>",
        "id": 253905525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632012982
    },
    {
        "content": "<p>Yep, that works.</p>",
        "id": 253905545,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632013022
    },
    {
        "content": "<p>Ok, in the code you just posted, there are at least 3 things I am unfamiliar with.</p>",
        "id": 253905625,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632013106
    },
    {
        "content": "<p>I guess \"fail_if_unchaged\" is pretty self-explanatory.</p>",
        "id": 253905642,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632013127
    },
    {
        "content": "<p>It's basically equivalent to the <code>try { simp only ... }</code> you wrote, but this gives better errors</p>",
        "id": 253905659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013157
    },
    {
        "content": "<p>What is <code>_::_ &lt;- get_goals | skip</code>?</p>",
        "id": 253905671,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632013183
    },
    {
        "content": "<p>same thing as the <code>|</code> from before</p>",
        "id": 253905679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013196
    },
    {
        "content": "<p>it's <code>fail_if_success done</code></p>",
        "id": 253905732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013206
    },
    {
        "content": "<p>actually scratch that</p>",
        "id": 253905765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013221
    },
    {
        "content": "<p>if there are no goals, then it succeeds <em>and terminates <code>mysatz</code></em></p>",
        "id": 253905789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013240
    },
    {
        "content": "<p>If we let the <code>cases</code> run, then it would cause our tactic to fail</p>",
        "id": 253905796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013260
    },
    {
        "content": "<p>in other words, this covers the case where the <code>simp</code> closes the goal</p>",
        "id": 253905831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013317
    },
    {
        "content": "<p>Right, ok</p>",
        "id": 253905875,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632013328
    },
    {
        "content": "<p>Regarding goal handling, this is a \"regular\" tactic, it assumes there is one goal to start and closes the goal or fails</p>",
        "id": 253905892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013361
    },
    {
        "content": "<p>we can assume the <code>simp only</code> doesn't create goals so there is only one goal at the <code>cases</code></p>",
        "id": 253905912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013406
    },
    {
        "content": "<p>and we use <code>;</code> after <code>cases</code> to run the succeeding block twice, on the two subgoals, and ensure we have only one goal</p>",
        "id": 253905982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013477
    },
    {
        "content": "<p>crucially, after the <code>rw, clear</code> we call <code>mysatz</code> recursively</p>",
        "id": 253906008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013519
    },
    {
        "content": "<p>this causes a branching tree of invocations, like what <code>repeat</code> gives you</p>",
        "id": 253906015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013536
    },
    {
        "content": "<p>actually, we should probably use <code>;</code> instead of <code>,</code> before the recursive call, because the <code>rw</code> might also close the goal</p>",
        "id": 253906103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013645
    },
    {
        "content": "<p>Ok, I understand. One more question, for my own edification. In my version of <code>mysatz</code> (creatively named <code>integral_domain_tactic</code>, and which was bugges for other reasons), instead of using the first <code>;</code> I was doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"k\">do</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">cases_type</span> <span class=\"n\">or</span><span class=\"o\">],</span>\n        <span class=\"n\">trace</span> <span class=\"s2\">\"cases_type or succeeds\"</span>\n       <span class=\"c1\">-- If cases_type or succeeds, call tactic recursively</span>\n        <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">integral_domain_tactic</span><span class=\"o\">],</span>\n        <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">integral_domain_tactic</span><span class=\"o\">])</span>\n        <span class=\"c1\">-- If cases_type or fails, rewrite using more powerful simp</span>\n</code></pre></div>\n<p>Does this also work in principle, because <code>cases_type or</code> always returns two subgoals, or is it flawed somehow?</p>",
        "id": 253906269,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632013831
    },
    {
        "content": "<p>I expect the answer is \"it would probably work, but <code>;</code> to do recursive subcalls is more elegant\".</p>",
        "id": 253906357,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632013927
    },
    {
        "content": "<p>It's a little riskier, because if the first <code>integral_domain_tactic</code> doesn't close the goal because of bugs or otherwise, then the second <code>integral_domain_tactic</code> will get a weird state</p>",
        "id": 253906373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632013954
    },
    {
        "content": "<p>Right, I see. <br>\nI'm taking a break, thanks so much for all your help!</p>",
        "id": 253906411,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632014027
    },
    {
        "content": "<p>Unfortunately, I'm realizing the <code>mysatz</code> tactic above is not doing quite what I want it to. After the <code>_::_ ← get_goals | skip,</code> line, it might be the case that there are no <code>∨</code> present in the hypotheses. In this case, I would like the tactic to gracefully just return the state at that point as a goal, rather than fail. I'm looking at the <code>try_core</code>and <code>match</code> syntax to try to resolve this, but I'm not having much luck. Anyone able to help? This is what I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">integral_domain_tactic</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span> <span class=\"k\">with</span> <span class=\"n\">integral_domain_simp</span>\n    <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"o\">{</span><span class=\"n\">fail_if_unchanged</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span><span class=\"o\">}],</span>\n  <span class=\"n\">try</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">true</span> <span class=\"n\">false</span><span class=\"o\">],</span>\n  <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">get_goals</span> <span class=\"bp\">|</span> <span class=\"n\">skip</span><span class=\"o\">,</span> <span class=\"c1\">-- If no goals left (get goals is an empty list) then skip</span>\n  <span class=\"c1\">-- Otherwise try to recurse on an ∨.</span>\n  <span class=\"c1\">-- I still think this may be wrong. If there is no or, we ought to stop at this point</span>\n  <span class=\"n\">cases_success</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">try_core</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"o\">],</span>\n  <span class=\"k\">match</span> <span class=\"n\">cases_success</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">],</span> <span class=\"n\">integral_domain_tactic</span> <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">skip</span>\n</code></pre></div>",
        "id": 254142519,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632187112
    },
    {
        "content": "<p>It doesn't work to put <code>;</code> after the try core either. Lean complains that it doesn't know the identifier <code>cases_success</code></p>",
        "id": 254142685,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632187312
    },
    {
        "content": "<p>Actually nevermind, after playing with it a few more minutes, I found</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">integral_domain_tactic</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span> <span class=\"k\">with</span> <span class=\"n\">integral_domain_simp</span>\n    <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"o\">{</span><span class=\"n\">fail_if_unchanged</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span><span class=\"o\">}],</span>\n  <span class=\"n\">try</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">true</span> <span class=\"n\">false</span><span class=\"o\">],</span>\n  <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">get_goals</span> <span class=\"bp\">|</span> <span class=\"n\">skip</span><span class=\"o\">,</span> <span class=\"c1\">-- If no goals left (get goals is an empty list) then skip</span>\n  <span class=\"c1\">-- Otherwise try to recurse on an ∨.</span>\n  <span class=\"c1\">-- I still think this may be wrong. If there is no or, we ought to stop at this point</span>\n  <span class=\"n\">cases_success</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">try_core</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">cases</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span><span class=\"o\">],</span>\n  <span class=\"k\">match</span> <span class=\"n\">cases_success</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">all_goals'</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">rw</span> <span class=\"n\">found_zero</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">found_zero</span><span class=\"o\">,</span> <span class=\"n\">integral_domain_tactic</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">skip</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>Seems to work. I'll let you all know if anything else comes up.</p>",
        "id": 254143197,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1632187779
    }
]
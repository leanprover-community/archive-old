[
    {
        "content": "<p>Hello everyone,<br>\nI am working with my directed simple graphs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and I am trying to implement the deleting edges definiton from simple graphs, which have symmetric edges :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">delete_edges</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G.adj</span> <span class=\"bp\">\\</span> <span class=\"n\">sym2.to_rel</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">adj_comm</span><span class=\"o\">,</span> <span class=\"n\">sym2.eq_swap</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Of course, I only need adjacency not symmetry. However, I did not see a way to translate s to a relation. Therefore I tried to explicitly define what adj is supposed to do when s is deleted :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">delete_edges</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">,</span><span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">G.adj</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"k\">else</span> <span class=\"n\">false</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>That does work but I am not 100% sure whether it is doing what it is supposed to do.  Is there a more convenient way, such that one can prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_adj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.delete_edges</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>by rfl ? As in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_adj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.delete_edges</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>\n<p>Any help is appreciated.</p>",
        "id": 320907663,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673520983
    },
    {
        "content": "<p>Why not just write <code>s</code> as a relation? Then</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">delete_edges</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G.adj</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_adj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.delete_edges</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">s</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>",
        "id": 320928169,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1673527392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111433\">@Alistair Tucker</span> I would like s to be the set of the edges one wants to remove from the directed graph.. </p>\n<p>As s, for directed graphs, has no symmetry, one obviously can not use </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">sym2.to</span> <span class=\"n\">rel</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>but is there a way to obtain a relation from s?</p>",
        "id": 320945046,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673532232
    },
    {
        "content": "<p>You can write it as <code>λ v w, (v, w) ∈ s</code>. There might be some definition(s) in mathlib for going between a set of pairs and a relation, but nothing comes to mind.</p>",
        "id": 320950088,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673533424
    },
    {
        "content": "<p><code>sym2.to_rel</code> exists mainly because it's an inverse to <code>sym2.from_rel</code> and there are a few lemmas about it. It's also not too bad to write <code>λ v w, ⟦(v, w)⟧ ∈ s</code> for it instead.</p>",
        "id": 320950758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673533568
    },
    {
        "content": "<p>Internally <code>set (V × V)</code> is just <code>V × V → Prop</code> anyway. But perhaps you want to draw some subtle distinction here that I don't understand...</p>",
        "id": 320956598,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1673535031
    },
    {
        "content": "<p>Yes, the set \"API\" expects that you always respect the proper syntax of a set. Sure a set is a predicate, but you ought to always use the membership syntax for things like simp to work properly.</p>",
        "id": 320957336,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673535210
    },
    {
        "content": "<p>Also, my functions have type <code>V → V → Prop</code> (not <code>V × V → Prop</code>).</p>\n<p>If <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.uncurry\">docs#function.uncurry</a> allowed <code>Sort*</code> rather than <code>Type*</code> I might have written <code>function.uncurry (∈ s)</code></p>",
        "id": 320957635,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673535274
    },
    {
        "content": "<p>This <code>(∈ s)</code> notation is how you're expected to turn a set back into a predicate. It's the inverse of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_of\">docs#set_of</a></p>",
        "id": 320957828,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673535314
    },
    {
        "content": "<p>Sorry I should have made it clear that I was addressing <span class=\"user-mention\" data-user-id=\"573061\">@Christopher Schmidt</span></p>",
        "id": 320962516,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1673536464
    },
    {
        "content": "<p>I guess you could take what I wrote as addressing why you might want a <code>set (V × V)</code> argument rather than a raw relation.</p>",
        "id": 320963018,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673536583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"573061\">@Christopher Schmidt</span> Another design, instead of defining <code>delete_edges</code>, is to make a function to create a <code>directed_simple_graph</code> from an edge set, then define the difference of two graphs</p>",
        "id": 320963208,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673536639
    },
    {
        "content": "<p>For simple graphs we don't do that because there's the annoyance that you have to delete the diagonal from the set, since simple graphs are loopless.</p>",
        "id": 320963614,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673536730
    },
    {
        "content": "<p>Thanks for your help and ideas. What I have accomplished through that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">\\</span><span class=\"n\">times</span> <span class=\"n\">V</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set_to_rel</span><span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">G</span> <span class=\"n\">s</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"o\">,</span><span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n\n<span class=\"sd\">/-- `from_edge_set` constructs a `directed_simple_graph` from a set of edges. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">from_edge_set</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">G.set_to_rel</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Given a set of vertex pairs, remove all of the corresponding edges from the</span>\n<span class=\"sd\">graph's edge set, if present. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">delete_edges</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G.adj</span> <span class=\"bp\">\\</span> <span class=\"o\">(</span><span class=\"n\">G.set_to_rel</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The difference of two graphs `x \\ y` has the edges of `x` with the edges of `y` removed. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_sdiff</span> <span class=\"o\">(</span><span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">x.adj</span> <span class=\"bp\">\\</span> <span class=\"n\">y.adj</span><span class=\"o\">,}⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_adj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.delete_edges</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>\n<p>Does that look alright ?</p>",
        "id": 320976276,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673539873
    },
    {
        "content": "<p>You likely don't want <code>G</code> to be an argument to <code>set_to_rel</code> since it's not used.</p>",
        "id": 320979553,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673540805
    },
    {
        "content": "<p>I'd suggest this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `from_edge_set` constructs a `directed_simple_graph` from a set of edges. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">from_edge_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The difference of two graphs `x \\ y` has the edges of `x` with the edges of `y` removed. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_sdiff</span> <span class=\"o\">(</span><span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">x.adj</span> <span class=\"bp\">\\</span> <span class=\"n\">y.adj</span> <span class=\"o\">}⟩</span>\n\n<span class=\"sd\">/-- Given a set of vertex pairs, remove all of the corresponding edges from the</span>\n<span class=\"sd\">graph's edge set, if present. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">delete_edges</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">\\</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_adj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.delete_edges</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">directed_simple_graph</span>\n</code></pre></div>",
        "id": 320979590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673540814
    },
    {
        "content": "<p>and I probably wouldn't have <code>delete_edges</code> since you can write <code>G \\ from_edge_set s</code></p>",
        "id": 320979696,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673540845
    },
    {
        "content": "<p>I'd also add the <code>@[simps]</code> attribute to <code>from_edge_set</code> (which automatically makes a <code>from_edge_set_adj</code> lemma) and add</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">adj_sdiff</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">\\</span> <span class=\"n\">G'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>",
        "id": 320980280,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673541007
    },
    {
        "content": "<p>These together <em>should</em> prove the analogue of <code>delete_edges_adj</code>, but I seem to be missing an import that makes <code>simp</code> handle it automatically...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_adj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">\\</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> missing import? -/</span> <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 320980830,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673541148
    },
    {
        "content": "<p>Ah, I had <code>@[simps]</code> on the instance in my own file, which gave the \"wrong\" simp lemma for this. Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `from_edge_set` constructs a `directed_simple_graph` from a set of edges. -/</span>\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">from_edge_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The difference of two graphs `x \\ y` has the edges of `x` with the edges of `y` removed. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_sdiff</span> <span class=\"o\">(</span><span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">x.adj</span> <span class=\"bp\">\\</span> <span class=\"n\">y.adj</span> <span class=\"o\">}⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">adj_sdiff</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">\\</span> <span class=\"n\">G'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">G'.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"c1\">-- Then this particular lemma is unnecessary:</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">\\</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">directed_simple_graph</span>\n</code></pre></div>",
        "id": 320981603,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673541342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks, that looks better.</p>",
        "id": 320985218,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673542317
    },
    {
        "content": "<p>If one includes the delete_edges Def, why does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_univ_eq</span> <span class=\"o\">:</span> <span class=\"n\">G.delete_edges</span> <span class=\"n\">set.univ</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>give an error? (wanted to have it analogous to mathlib)</p>",
        "id": 320986496,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673542639
    },
    {
        "content": "<p>That depends on what you defined bot to be. I'm guessing you don't have an adjacency simp lemma for it?</p>",
        "id": 320987286,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673542832
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_bot</span> <span class=\"o\">(</span><span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">⊥</span> <span class=\"o\">}⟩</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_adj_bot</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">false.elim</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">delete_edges_univ_eq</span> <span class=\"o\">:</span>\n  <span class=\"n\">G</span> <span class=\"bp\">\\</span> <span class=\"n\">from_edge_set</span> <span class=\"n\">set.univ</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 320987917,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673543005
    },
    {
        "content": "<p>Oh, I tough that this symbol is predefined as an always false, as G.delete edges set.univ obviously is an \"always false relation\".<br>\nAnyways.. thank you <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> .</p>",
        "id": 321007614,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673548605
    }
]
[
    {
        "content": "<p>I think I am misunderstanding <code>has_coe_to_sort</code>. Why does the following not work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">formula</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_coe_to_sort</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">equation</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"c1\">--type expected at</span>\n<span class=\"c1\">--  a</span>\n<span class=\"c1\">--term has type</span>\n<span class=\"c1\">--  α</span>\n</code></pre></div>",
        "id": 232150515,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1616918133
    },
    {
        "content": "<p>I don't think <code>has_coe_to_sort</code> works as an assumption, because it is necessary for the first projection out of the <code>has_coe_to_sort</code> instance to definitionally reduce to <code>Sort u</code>, which isn't possible unless you have a concrete instance</p>",
        "id": 232151186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616918967
    },
    {
        "content": "<p>Oh, ok. It worked indeed with concrete choices of α, and that amplified my confusion. Thanks!</p>",
        "id": 232151345,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1616919171
    },
    {
        "content": "<p>Will this will be fixed by Yury's refactor?</p>",
        "id": 232153189,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616921582
    },
    {
        "content": "<p>I wouldn't call it \"Yury's\" refactor. It is backporting of <code>coe_sort</code> and <code>coe_fun</code> from Lean 4, and most of the hard work in core was done by <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>.</p>",
        "id": 232170327,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616941774
    },
    {
        "content": "<p>We're talking about <a href=\"https://github.com/leanprover-community/lean/issues/557\">lean#557</a></p>",
        "id": 232170335,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616941801
    },
    {
        "content": "<p>Another problem I encountered in the same context which might be related (though, I am not sure if it's due to <code>has_coe_to_sort</code>).<br>\nWhy is the inductive definition of <code>proof</code> wrong, why are there several <code>σ</code>'s generated?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">linear_type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">linear_type</span>\n<span class=\"bp\">|</span> <span class=\"n\">arrow</span> <span class=\"o\">:</span> <span class=\"n\">linear_type</span> <span class=\"bp\">→</span> <span class=\"n\">linear_type</span> <span class=\"bp\">→</span> <span class=\"n\">linear_type</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`↣`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">linear_type.arrow</span>\n<span class=\"kd\">notation</span> <span class=\"bp\">`𝕋`</span> <span class=\"o\">:=</span> <span class=\"n\">linear_type</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"bp\">𝕋</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">linear_type.zero</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">linear_type_to_sort</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">↣</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">linear_type_to_sort</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">linear_type_to_sort</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">linear_type</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">linear_type_to_sort</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">equation</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">universal</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span><span class=\"o\">),</span> <span class=\"n\">formula</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`∀'`</span> <span class=\"o\">:=</span> <span class=\"n\">formula.universal</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">equation_ext</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span><span class=\"o\">},</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">formula.equation</span> <span class=\"n\">t</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">↣</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">↣</span> <span class=\"n\">τ</span><span class=\"o\">),</span> <span class=\"bp\">∀'</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"n\">equation_ext</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">formula</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">EXT</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">↣</span> <span class=\"n\">τ</span><span class=\"o\">)},</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">equation_ext</span> <span class=\"n\">σ</span> <span class=\"n\">t</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">equation_ext</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch at application</span>\n<span class=\"cm\">  equation_ext t</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  t</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ↥σ_1</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ↥σ</span>\n<span class=\"cm\">types contain aliased name(s): σ</span>\n<span class=\"cm\">remark: the tactic `dedup` can be used to rename aliases</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 232194243,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1616966642
    },
    {
        "content": "<p>This looks like a bug, although I'm not sure where. As a workaround, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">formula</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">EXT</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">↣</span> <span class=\"n\">τ</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">},</span>\n    <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">equation_ext</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">equation_ext</span> <span class=\"n\">σ</span> <span class=\"n\">t</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 232198873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616971866
    },
    {
        "content": "<p>This also works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">formula</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">EXT</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"bp\">𝕋</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">↣</span> <span class=\"n\">τ</span><span class=\"o\">)},</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">equation_ext</span> <span class=\"n\">σ</span> <span class=\"n\">t</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">equation_ext</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 232199159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616972211
    }
]
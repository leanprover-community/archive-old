[
    {
        "content": "<p>Does this exist somewhere in Mathlib ? Should it be added ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multiset.prod_pow_eq_pow_sum</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">multiset.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">m.sum</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">multiset.induction_on</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"n\">pow_add</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>Two questions  by the way: </p>\n<p>1) <code>multiset.sum</code> requires that one works in a <code>comm_monoid</code> (for obvious reasons), but here all objects involved belong to the commutative submonoid generated by <code>a</code>, so something should work for any <code>monoid M</code>, but what?</p>\n<p>2) I expected to be able to use <code>multiset.prod_hom</code>. If <code>M</code> is a monoid, what is mathematically a member of <code>ℕ →* M</code> ?</p>",
        "id": 266787284,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641289322
    },
    {
        "content": "<p>Might <a href=\"https://github.com/leanprover-community/mathlib/pull/10907\">#10907</a> help? (I don't think so, because you're going from additive to multiplicative and those new lemmas each stay in the same world)</p>",
        "id": 266787367,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641289365
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/powers_hom\">docs#powers_hom</a> is the closest <code>monoid_hom</code></p>",
        "id": 266787676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641289562
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.noncomm_prod\">docs#multiset.noncomm_prod</a> the generalization you were looking for?</p>",
        "id": 266787717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641289589
    },
    {
        "content": "<p>Yes, it should be part of that, but I don't manage to make this work.<br>\n(On the other hand, I am really appalled at the idea that <code>multiplicative \\nat \\to* M</code>is not a morphism from <code>\\nat</code> as a multiplicative monoid to <code>M</code>.)</p>",
        "id": 266788912,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641290375
    },
    {
        "content": "<p>What do mean by \"ℕ as a multiplicative monoid\" if not <code>multiplicative ℕ</code>? Do you just mean ℕ?</p>",
        "id": 266789455,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641290702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> Don't you just want <code>ℕ →* M</code>?</p>",
        "id": 266789558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641290765
    },
    {
        "content": "<p><code>multiplicative ℕ</code> is the monoid of symbols <code>{x^n | n ∈ ℕ}</code>. With multiplication <code>x^m * x^n = x^(m+n)</code>.</p>",
        "id": 266789634,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641290823
    },
    {
        "content": "<p>Or maybe I'm misunderstanding what you want...</p>",
        "id": 266789687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641290855
    },
    {
        "content": "<p><code>multiplicative nat</code> means \"treat nat as a monoid with group law which is mathematically <code>+</code> but now which is written with notation <code>*</code>\"</p>",
        "id": 266790816,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641291625
    },
    {
        "content": "<p>If you talk to me of “ℕ as a multiplicative monoid”, I will understand nonnegative integers with product.</p>",
        "id": 266791316,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641291957
    },
    {
        "content": "<p>I had tried Johan's suggestion, but I got this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→*</span> <span class=\"n\">M</span><span class=\"o\">}</span>  <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">multiset.map</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">m.sum</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">multiset.prod_hom</span> <span class=\"o\">,</span>\n<span class=\"c1\">-- needs to prove ⇑f m.prod = ⇑f m.sum</span>\n<span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 266791623,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641292171
    },
    {
        "content": "<p><code>refl</code>!</p>",
        "id": 266791638,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641292184
    },
    {
        "content": "<p>\"ℕ as a multiplicative monoid' is just called ℕ in mathlib</p>",
        "id": 266791641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641292186
    },
    {
        "content": "<p>No not refl, this lemma looks false to me</p>",
        "id": 266791764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641292273
    },
    {
        "content": "<p>-&gt;* means \"preserves multiplication\"</p>",
        "id": 266791787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641292295
    },
    {
        "content": "<p><code>multiplicative X</code> means \"turn this additive monoid into a multiplicative monoid by defining multiplication to be addition\"</p>",
        "id": 266791889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641292354
    },
    {
        "content": "<p>• <code>ℕ</code> is a <code>monoid</code> and an <code>add_monoid</code>.<br>\n• <code>multiplicative ℕ</code> is the additive monoid <code>ℕ</code>, but viewed as multiplicative monoid, so with notation <code>*</code>.<br>\n• <code>additive ℕ</code> is the multiplicative monoid <code>ℕ</code>, but viewed as additive monoid, so with notation <code>+</code>.</p>",
        "id": 266791903,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641292365
    },
    {
        "content": "<p>I am not sure if this will help, but <code>multiplicative ℕ</code>is Lean's way of dealing with, for instance, the submonoid of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><msub><mi>L</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">SL_2(\\mathbb{Z})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span> generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">(</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">(</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">)</span></span></span></span></span></span>.  The submonoid is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">N</mi><mo separator=\"true\">,</mo><mo>+</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(ℕ, +)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord amsrm\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mclose\">)</span></span></span></span>, but the group operation is multiplication.</p>\n<p>I hope that this helps!</p>",
        "id": 266792292,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1641292599
    },
    {
        "content": "<p>This is irrelevant to my question, but how does one summon<code>ℕ</code> as a monoid with <em>multiplication</em> of integers ?</p>",
        "id": 266793403,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641293361
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.comm_monoid\">docs#nat.comm_monoid</a> (assuming you mean multiplication of naturals, not multiplication of integers)</p>",
        "id": 266793446,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641293400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> By doing nothing. That's the default.</p>",
        "id": 266793554,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293461
    },
    {
        "content": "<p>In informal maths, we infer <em>a lot</em> about what's going on, by choosing suggestive notation. You can quickly drive someone crazy by using <code>▸</code> and <code>↑</code> as the two binary operations in a random ring.</p>",
        "id": 266793675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293535
    },
    {
        "content": "<p>To counter this, in mathlib you can <em>only</em> use <code>*</code> and <code>+</code> for ring operations.</p>",
        "id": 266793697,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293554
    },
    {
        "content": "<p>This is unfortunate, because it means you cannot use <code>∘</code> for endomorphism rings.</p>",
        "id": 266793723,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293571
    },
    {
        "content": "<p>But in practice, this seems to be only a minor downside.</p>",
        "id": 266793731,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293581
    },
    {
        "content": "<p>The other two downsides are:</p>\n<ol>\n<li>you have to develop the theory of monoids and groups twice: once for <code>*</code> and once for <code>+</code>. But the tactic <code>to_additive</code> takes care of the duplication, so it's not a very big problem</li>\n<li>you cannot have group/monoid homomorphisms <code>G → H</code> if <code>G</code> uses <code>*</code>-notation and <code>H</code> uses <code>+</code>-notation. This is where the \"switch notation\" type wrappers <code>additive</code> and <code>multiplicative</code> come in. Because you can have a <code>*</code>-preserving monoid hom <code>G →* multiplicative H</code>.</li>\n</ol>",
        "id": 266793936,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293719
    },
    {
        "content": "<p>Altogether, I find this philosophically very unsatisfactory. But in practice it works very well.</p>",
        "id": 266793951,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293739
    },
    {
        "content": "<p>I've spent many hours dreaming about a better way to tackle the issue. But if you try to do the \"mathematically\" correct thing, I can never save the nice notation that we have now. And giving up <code>+</code> and <code>*</code> seems too big a price to pay.</p>",
        "id": 266794045,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293797
    },
    {
        "content": "<p>So, long story short. By default <code>+</code> on <code>ℕ</code> means the addition you are used to. And <code>*</code> means the multiplication that you expect.</p>",
        "id": 266794101,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293845
    },
    {
        "content": "<p>And Lean can handle both at the same time, because it has two duplicated hierarchies of semigroups/monoids/groups: one for <code>+</code> and one for <code>*</code>.</p>",
        "id": 266794137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641293873
    },
    {
        "content": "<p>And, importantly here, when you’re using <code>nat</code> in a way that uses its multiplicative structure you can just write <code>nat</code> and Lean knows what you mean — right?</p>",
        "id": 266796476,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1641295321
    },
    {
        "content": "<p>i.e. you don’t write something like <code>(nat, *, 1)</code></p>",
        "id": 266796722,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1641295483
    },
    {
        "content": "<p>OK. I understand that  if I talk about <code>multiplicative \\nat</code> (as a monoid), I get natural numbers and the law is addition written <code>*</code>, while if a talk about <code>\\nat</code> (again as a monoid), I get natural numbers with multiplication denoted <code>*</code>.</p>",
        "id": 266797213,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641295863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> What I find unsatisfactory is the use of the adjective <code>multiplicative</code> to mean the opposite of what (I believe) we (I) would say in math. Otherwise, I think I understand the issues you describe.</p>",
        "id": 266797398,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641295997
    },
    {
        "content": "<p>Maybe <code>multiplicatively</code>and <code>additively</code>would be better. But I'm nothing here to revert terminology.</p>",
        "id": 266797473,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1641296043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> That makes sense.</p>",
        "id": 266798336,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641296707
    },
    {
        "content": "<p>I guess, in a context where a type doesn't have both notations yet, it would be less confusing. Say, you have some abstract additive group <code>G</code>. Then <code>multiplicative G</code> is probably unambiguous.</p>",
        "id": 266798396,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641296759
    },
    {
        "content": "<p>What's going on here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group_power.lemmas</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prod_pow_eq_pow_sum</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">multiset.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"n\">m.sum</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- multiset.induction_on m (by simp) (λ n m h, by simp [h,pow_add])</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">multiset.prod_hom</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">m.map</span> <span class=\"n\">multiplicative.of_add</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">powers_hom</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">,</span>  <span class=\"c1\">-- exact fails</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">multiplicative.mul_one_class</span> <span class=\"n\">has_one.one</span><span class=\"o\">,</span>  <span class=\"c1\">-- fails without this</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Why do I have to unfold <code>has_one.one</code> to get lean to see the instances are equal?</p>",
        "id": 266823373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641311162
    },
    {
        "content": "<p>(mwe'd at <a href=\"#narrow/stream/113488-general/topic/Diamond.20in.20multiplicative.20nat/near/266824443\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Diamond.20in.20multiplicative.20nat/near/266824443</a>)</p>",
        "id": 266824564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641311737
    },
    {
        "content": "<p><code>ext, refl</code> works after the <code>convert</code>, so this is something to do with equality of structures. If you make the terms involved directly then it seems to work fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">mul_one_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">monoid.to_mul_one_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n      <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_monoid.to_monoid.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">multiplicative.comm_monoid.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">nat.add_comm_monoid</span><span class=\"o\">)),</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">mul_one_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">multiplicative.mul_one_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid.to_add_zero_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">nat.add_monoid</span><span class=\"o\">),</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">mul_one_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">mul_one_class.mk.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">coe_fn.</span><span class=\"o\">{</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">equiv.</span><span class=\"o\">{</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">))</span>\n     <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">equiv.</span><span class=\"o\">{</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)),</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">equiv.has_coe_to_fun.</span><span class=\"o\">{</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">))</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">multiplicative.of_add.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_zero.zero.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_zero_class.to_has_zero.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid.to_add_zero_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">nat.add_monoid</span><span class=\"o\">))))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_mul.mul.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">multiplicative.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">multiplicative.has_mul.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_zero_class.to_has_add.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid.to_add_zero_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">nat.add_monoid</span><span class=\"o\">))))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">multiplicative.mul_one_class._proof_1.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid.to_add_zero_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">nat.add_monoid</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">multiplicative.mul_one_class._proof_2.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_monoid.to_add_zero_class.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">nat.add_monoid</span><span class=\"o\">)),</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Z</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span> <span class=\"n\">Z</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">trivial</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 266831542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641314229
    },
    {
        "content": "<p>Reid's diagnosis in the other thread is that this is an elaborator bug</p>",
        "id": 266833014,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641314881
    }
]
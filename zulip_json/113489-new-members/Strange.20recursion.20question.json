[
    {
        "content": "<p>I'm fairly certain this kind of thing will never come up in any serious applications of Lean, so I first want to preface this question with an apology for how strange this might seem.</p>\n<p>I've been writing up some notes for some students I've been talking to about formal verification, and I wanted to get across  the idea that Lean is nothing more than a functional programming language, and that the tactics block is nothing more than a (very) fancy way of assembling a function. </p>\n<p>I wanted to have a silly example of this by implementing the function that finds the maximum of a list. I tried with the first definition <code>max_of_list</code>. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">max_of_list</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n<span class=\"n\">cases</span> <span class=\"n\">L</span> <span class=\"k\">with</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">max</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"n\">max_of_list</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"c1\">-- This doesn't work</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But this doesn't work because Lean complains that it doesn't know <code>max_of_list</code> when it calls itself. I then remembered a similar issue I ran into when I tried to write another silly example of a function which takes in a list of stuff and eventually outputs it to another function which prints it. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">system.io</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">get_stuff</span> <span class=\"o\">(</span><span class=\"n\">stuff</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">io</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">io.put_str</span> <span class=\"s2\">\"Give an input (no to stop)</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"o\">,</span>\n  <span class=\"n\">input</span> <span class=\"bp\">←</span> <span class=\"n\">io.get_line</span><span class=\"o\">,</span>\n  <span class=\"k\">if</span> <span class=\"n\">input</span> <span class=\"bp\">=</span> <span class=\"s2\">\"no\"</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">stuff</span>\n  <span class=\"k\">else</span> <span class=\"n\">get_stuff</span> <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">::</span> <span class=\"n\">stuff</span><span class=\"o\">)</span> <span class=\"c1\">-- This also doesn't work</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">get_stuff'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">io</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">stuff</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">io.put_str</span> <span class=\"s2\">\"Give an input (no to stop)</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"o\">,</span>\n  <span class=\"n\">input</span> <span class=\"bp\">←</span> <span class=\"n\">io.get_line</span><span class=\"o\">,</span>\n  <span class=\"k\">if</span> <span class=\"n\">input</span> <span class=\"bp\">=</span> <span class=\"s2\">\"no\"</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">stuff</span>\n  <span class=\"k\">else</span> <span class=\"n\">get_stuff</span> <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">::</span> <span class=\"n\">stuff</span><span class=\"o\">)</span> <span class=\"c1\">-- This does work though!</span>\n</code></pre></div>\n<p>So after I made the same adjustment to <code>max_of_list</code>... </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">max_of_list'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">cases</span> <span class=\"n\">L</span> <span class=\"k\">with</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">max</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"n\">max_of_list</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"c1\">-- Now it works!</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It works! I was curious about what exactly is going on here which makes the first examples <code>max_of_list</code> and <code>get_stuff</code> not like the recursive call. But as soon as I define the function matching on the input, it has no issues with it.</p>",
        "id": 273033691,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1645663940
    },
    {
        "content": "<p>Your second try does pattern matching, which allows well-founded recursion. You simply can't do that in your first try.</p>",
        "id": 273033955,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645664128
    },
    {
        "content": "<p>You might want to optimize this by actually pattern-matching on the list.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">max_of_list</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">max</span> <span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"n\">max_of_list</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 273034104,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645664239
    },
    {
        "content": "<p><a href=\"https://exlean.org/well-founded-recursion/\">https://exlean.org/well-founded-recursion/</a> is a related guide, I think (see the \"Well-founded recursion by hand\" section)</p>",
        "id": 273035056,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1645664892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Strange.20recursion.20question/near/273033955\">said</a>:</p>\n<blockquote>\n<p>Your second try does pattern matching, which allows well-founded recursion. You simply can't do that in your first try.</p>\n</blockquote>\n<p>Is there a reason why well-founded recursion can work with pattern matching, but not defined in the different way? Is this more than a choice of how things are implemented in Lean?</p>",
        "id": 273045748,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1645676299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/113489-new-members/topic/Strange.20recursion.20question/near/273035056\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://exlean.org/well-founded-recursion/\">https://exlean.org/well-founded-recursion/</a> is a related guide, I think (see the \"Well-founded recursion by hand\" section)</p>\n</blockquote>\n<p>I haven't seen this (or exlean in general) before! There are so many good resources out there, thank you!</p>",
        "id": 273045757,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1645676337
    },
    {
        "content": "<p>Instead of cases, use \"induction l using list.rec_on\"</p>",
        "id": 273046902,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1645677633
    }
]
[
    {
        "content": "<p>Hi, I am interested in implementing <a href=\"https://en.wikipedia.org/wiki/Wreath_product\">wreath products</a> in lean (currently lean 3). I have a small working definition for unrestricted wreath products reducing it to a semidirect product such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">wreath_product_1</span> <span class=\"o\">:=</span> <span class=\"n\">semidirect_product</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"n\">wreath_product.φ</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">B</span><span class=\"bp\">`</span> <span class=\"bp\">≀</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">35</span> <span class=\"n\">L</span><span class=\"o\">:</span><span class=\"mi\">35</span><span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"n\">A</span> <span class=\"o\">:</span><span class=\"mi\">35</span> <span class=\"o\">:=</span> <span class=\"n\">wreath_product_1</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">L</span>\n</code></pre></div>\n<p>where <code>ẁreath_product.φ : A →* mul_aut (L → B)</code> given by the reindexing action <code>λ (a : A) (f : L → B) (l: L), f (has_smul.smul a⁻¹ l)</code>. Most of the file is currently showing that this definition lifts to <code>A →* mul_aut (L → B)</code>.</p>\n<p>I also want to consider restricted wreath products.  But here I am not sure how to deal with the type classes: semidirect products are defined for (multiplicative) groups, but finsupp is defined for <code>has_zero B</code>.  I also want to consider groups B that are noncommutative, so I am reluctant to use additive notation for B. I saw that <span class=\"user-mention\" data-user-id=\"492774\">@Sky Wilshaw</span> was thinking of <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Finsupp.20generalisations/near/306301812\">generalizing finsupp</a>. Has there been any progress there? Any good suggestions on how to proceed? I don't really want to reinvent the wheel but I also don't know how to glue the current definitions together.</p>",
        "id": 320273166,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1673282639
    },
    {
        "content": "<p>I stopped working on that PR to give more effort to porting mathlib3 to mathlib4. I don't intend to continue with that PR, I might submit something similar for mathlib4 after the port.</p>",
        "id": 320284042,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1673285569
    },
    {
        "content": "<p><del>Could you use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_monoid\">docs#free_monoid</a> instead of finsupp?</del></p>",
        "id": 320286116,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673286154
    },
    {
        "content": "<p>I decided to side step restricted wreath products for now, one thing I want to work towards to is the description of the p-Sylow group of Sym(p^k) as an k-times iterated wreath product of the cyclic group of order p. See the <a href=\"https://github.com/leanprover-community/mathlib/commit/b5cf4961caf1d6e305bc4d6e8afe8cde067fc381\">stub</a>.</p>\n<p>At the moment I am still struggling to define iterated wreath products correctly, again because of type class issues. Is it possible to define types inductively together with their instance of a certain type class?</p>\n<p>For wreath products, I define a structure</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">bare_def</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">wreath_product</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">bare_def</span>\n</code></pre></div>\n<p>and show a group instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">group</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">wreath_product_group</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">wreath_product</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">group</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">B</span><span class=\"bp\">`</span> <span class=\"bp\">≀</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">35</span> <span class=\"n\">L</span><span class=\"o\">:</span><span class=\"mi\">35</span><span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"n\">A</span> <span class=\"o\">:</span><span class=\"mi\">35</span> <span class=\"o\">:=</span> <span class=\"n\">wreath_product</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">L</span>\n</code></pre></div>\n<p>I want to define iterated wreath products the following way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">iterated_wreath_product</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">triv_group</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iterated_wreath_product</span> <span class=\"n\">n</span> <span class=\"bp\">≀</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">G</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">iterated_wreath_product_zero</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">iterated_wreath_product</span> <span class=\"n\">G</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">triv_group</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">iterated_wreath_product_succ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">iterated_wreath_product</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">iterated_wreath_product</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"bp\">≀</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">iterated_wreath_product</span> <span class=\"n\">G</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"n\">iterated_wreath_product_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">apply_instance</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"n\">iterated_wreath_product_succ</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>here triv_group is a unit type with the trivial group structure. I would like to construct the group structure inductively. But in the inductive step,<br>\nif I try instead of the <code>sorry</code>the tactic <code>apply wreath_product_group</code>I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n  <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">iterated_wreath_product</span> <span class=\"n\">G</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">case</span> <span class=\"n\">nat.succ</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">iterated_wreath_product</span> <span class=\"n\">G</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">iterated_wreath_product</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"bp\">≀</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So it seems I cannot use the type class instance for the induction hypothesis. Is there some nice way around this?</p>",
        "id": 321854821,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1673968619
    },
    {
        "content": "<p>I think I found an OK solution, by the defining the group structure on wreath products  like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">wreath_product_group_explicit</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">wreath_product</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and then add an instance as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">wreath_product</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">wreath_product_group_explicit</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">L</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>then it is possible to use the inductively constructed group structure</p>",
        "id": 321869076,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1673972233
    },
    {
        "content": "<p>Maybe you can just do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">rw</span> <span class=\"n\">iterated_wreath_product_succ</span><span class=\"o\">,</span>\n    <span class=\"n\">resetI</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>or if you make <code>iterated_wreath_product</code> a <code>@[reducible] def</code> then maybe you don't even need the rewrite.</p>\n<p>I think something like this comes up in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.splitting_field\">docs#polynomial.splitting_field</a> (where we iteratively adjoin roots), but IIRC there situation is more complicated because we want an <code>algebra</code> instance over the base field.</p>",
        "id": 321887394,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673977135
    },
    {
        "content": "<p>I think I asked something similar a long time ago about iteratively defining tensor powers</p>",
        "id": 321960162,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674006011
    },
    {
        "content": "<p>It's perhaps worth noting that you can get the trivial group more easily with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- could use `unit` directly if you're fine with `0 : unit` existing</span>\n<span class=\"kd\">@[derive [comm_group, unique, fintype, decidable_eq]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">trivial_group</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span>\n</code></pre></div>",
        "id": 321960380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674006213
    },
    {
        "content": "<p>I didn't know about resetI, thanks! What does <code>@[reducible] def</code>do exactly?</p>",
        "id": 322975767,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1674467232
    }
]
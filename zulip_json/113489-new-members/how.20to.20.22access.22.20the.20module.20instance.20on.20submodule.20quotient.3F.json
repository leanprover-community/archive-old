[
    {
        "content": "<p>Suppose I define the notion of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-torsion submodule of an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> (I couldn't find this in mathlib but maybe I missed it):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">direct_sum</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">tors</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">},</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span>  <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n               <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"n\">rx</span> <span class=\"n\">hrx</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"n\">ry</span> <span class=\"n\">hry</span><span class=\"o\">,</span>\n               <span class=\"n\">use</span> <span class=\"n\">rx</span> <span class=\"bp\">*</span> <span class=\"n\">ry</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_add</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span><span class=\"o\">,</span> <span class=\"n\">smul_comm</span><span class=\"o\">,</span> <span class=\"n\">hrx</span><span class=\"o\">,</span> <span class=\"n\">hry</span><span class=\"o\">],</span>\n               <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n                <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_comm</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n                <span class=\"kn\">end</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">tors</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n</code></pre></div>\n\n\n<p>I can also define the property of being <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-torsion free for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules, i.e. no nonzero elements are annihilated by a non-zerodivisor:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">torsion_free</span> <span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">N</span><span class=\"o\">][</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span>  <span class=\"n\">s</span>  <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>(Probably there are less awkward ways to make the definition above, but that's not necessarily germane to my question here.)</p>\n<p>My first question is how to state \"the quotient of a module by its torsion submodule is torsion free\"?</p>\n<p>I tried <code>torsion_free (submodule.quotient tors)</code> and got an error: <code>switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</code>.</p>\n<p>If I do <code>@torsion_free _ _ (submodule.quotient tors) _ _</code>, I get  <code>don't know how to synthesize placeholder</code> errors, so my hypothesis is that I need to invoke some sort of incantation to tell Lean to use the \"obvious\" R-module structure on the quotient in question, which is defined in <code>linear_algebra/basic.lean: line 897</code>. </p>\n<p>Part of the issue here may have to do with leaning on type inference (or is the right thing to say \"elaboration\"?) unnecessarily, when I could be explicit instead?</p>\n<p>I tried to make an alternate definition of <code>tors</code> with the dependence on M (and/or R) made explicit via <code>()</code> instead of the implicit variable <code>{M : Type*}</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">tors&#39;</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">N</span><span class=\"o\">][</span><span class=\"n\">module</span> <span class=\"n\">S</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">S</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>But when I tried to construct the submodule structure, it seemed to go horribly wrong, e.g. <code>zero :=  by {simp at *}</code> no longer worked. </p>\n<p>Can anyone shed light on my confusion here? What is the \"right\" way to define <code>tors</code>? Thanks!</p>",
        "id": 198934335,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590604972
    },
    {
        "content": "<p>I don't think we have anything on torsion.</p>",
        "id": 198934380,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590604995
    },
    {
        "content": "<p>You want <code>r ≠ 0</code> in your definition.</p>",
        "id": 198934423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246647\">@Sam Lichtenstein</span> Note that with <code>rcases</code> you can merge the <code>intros</code> and <code>cases</code> lines, if you want.</p>",
        "id": 198934572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605088
    },
    {
        "content": "<p>sorry, I fixed the part that supposedly asserted r was a nonzerodivisor, so it now implies r != 0</p>",
        "id": 198934587,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590605094
    },
    {
        "content": "<p>oh whoops, you mean in the carrier<br>\nyeah that's a mistake</p>",
        "id": 198934700,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590605149
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246647\">@Sam Lichtenstein</span> Change <code>{R}</code> and <code>{M}</code> to <code>(R)</code> and <code>(M)</code> in your <code>variables</code></p>",
        "id": 198934802,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605181
    },
    {
        "content": "<p>That will hopefully fix most of your errors</p>",
        "id": 198934823,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605191
    },
    {
        "content": "<p>If you write <code>{R}</code>, you're telling Lean: \"Hey, figure out this argument by yourself\"</p>",
        "id": 198934904,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605222
    },
    {
        "content": "<p>But this does seem like a case where Lean should be able to figure stuff out for itself?</p>",
        "id": 198934945,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590605239
    },
    {
        "content": "<p>With <code>(R)</code>, you say: \"I'll supply this argument, everytime I use this def/lemma\"</p>",
        "id": 198934957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605245
    },
    {
        "content": "<p><code>tors</code> can't figure out <code>M</code></p>",
        "id": 198934985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605262
    },
    {
        "content": "<p>You certainly want <code>tors M</code>.</p>",
        "id": 198934999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605272
    },
    {
        "content": "<p>If I declare (M) in variables at the top, do I need to make the R-module instance on M explicit in the \"hypotheses\" of the <code>tors</code> definition?</p>",
        "id": 198935083,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590605292
    },
    {
        "content": "<p>But then Lean will still complain, and say: look <code>M</code> is supposed to be a module, but over which ring? It's a module over <code>Z</code>, but maybe you want another ring?</p>",
        "id": 198935108,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605304
    },
    {
        "content": "<p>No, the module instance is fine.</p>",
        "id": 198935134,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605318
    },
    {
        "content": "<p>Because [module R M] is in the variables at the top?</p>",
        "id": 198935161,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590605332
    },
    {
        "content": "<p>In usual maths, if you are pedantic, you would write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">s</mi></mrow><mi>R</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Tors}_R(M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">T</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">r</span><span class=\"mord mathrm\">s</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, with both <code>R</code> and <code>M</code> explicit</p>",
        "id": 198935205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605350
    },
    {
        "content": "<p>Lean wants you to always be pedantic.</p>",
        "id": 198935224,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605360
    },
    {
        "content": "<p>The rest of the variables are fine. <code>[comm_ring R]</code> means: Hey Lean, I'll tell you about <code>R</code>, which is a random type. I expect you to figure out a ring structure on <code>R</code>.</p>",
        "id": 198935355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605407
    },
    {
        "content": "<p>So you're suggesting the following should work (modulo the r!=0 issue in the carrier)?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">tors</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">},</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span>  <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">},</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n               <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"n\">rx</span> <span class=\"n\">hrx</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"n\">ry</span> <span class=\"n\">hry</span><span class=\"o\">,</span>\n               <span class=\"n\">use</span> <span class=\"n\">rx</span> <span class=\"bp\">*</span> <span class=\"n\">ry</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_add</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span><span class=\"o\">,</span> <span class=\"n\">smul_comm</span><span class=\"o\">,</span> <span class=\"n\">hrx</span><span class=\"o\">,</span> <span class=\"n\">hry</span><span class=\"o\">],</span>\n               <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n                <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_comm</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n                <span class=\"kn\">end</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 198935376,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590605417
    },
    {
        "content": "<p>I think that doesn't compile?</p>",
        "id": 198935407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605432
    },
    {
        "content": "<p>You can leave out the <code>(R)</code> and <code>(M)</code> from the def of <code>tors</code></p>",
        "id": 198935438,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605447
    },
    {
        "content": "<p>I meant that you should just change the parens in the <code>variables</code> line.</p>",
        "id": 198935460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590605462
    },
    {
        "content": "<p>OK thanks, I have to take care of something else, but I will try again later this afternoon</p>",
        "id": 198935663,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590605552
    },
    {
        "content": "<p>Alright, I have distilled my next question down the following:</p>\n<p>1) What on earth is going on in this proof?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"n\">finish</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hm</span> <span class=\"k\">with</span> <span class=\"n\">hm₁</span> <span class=\"n\">hm₂</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">hm₂</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">hm₂</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>2) What's wrong with the superficially similar (mk instead of mk') variant, which raises errors <code>synthesized type class instance is not definitionally equal to expression inferred by typing rules, ...</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- the lemma&#39;s statement doesn&#39;t work</span>\n</code></pre></div>\n\n\n<p>3) Shouldn't there be some version of this lemma whose proof is \"by {tauto}\", or at least \"by {simp at *}\"?</p>\n<p>4) Apparently it is a Bad Idea to try to work with quotient representatives using <code>@quotient.exists_rep _ (submodule.quotient_rel p)</code>, because this gives things of the form <code>quot.mk setoid.r m</code>, which seem surprisingly difficult to turn into things of the form <code>quotient.mk m</code>, despite the theorem <code>quotient.quot_mk_eq_mk</code>.  But what is the \"right\" way to work with lifts of elements of quotients? </p>\n<p>(I suppose a possible answer to <a href=\"https://github.com/leanprover-community/mathlib/issues/4\">#4</a> is \"don't\" -- instead try to formulate results using the universal property of the quotient in question. At least in the context of showing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi mathvariant=\"normal\">/</mi><msup><mi>M</mi><mrow><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">M/M^{tors}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.043556em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7935559999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">t</span><span class=\"mord mathdefault mtight\">o</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault mtight\">s</span></span></span></span></span></span></span></span></span></span></span></span> is torsion-free, this didn't seem like a natural approach to me, but I suppose YMMV.)</p>",
        "id": 198966869,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590622338
    },
    {
        "content": "<p>What do you even mean by Q1?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"c1\">--simp only [quotient.mk&#39;_eq_mk] at *, -- doesn&#39;t do anything</span>\n    <span class=\"n\">induction</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"n\">tauto</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">--intro h,</span>\n    <span class=\"c1\">--cases h with m hm,</span>\n    <span class=\"c1\">--cases hm with hm₁ hm₂,</span>\n    <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm₁</span><span class=\"o\">,</span> <span class=\"n\">hm₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"c1\">-- the same</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">hm₂</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hm₂</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span><span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 198967145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590622553
    },
    {
        "content": "<p>Well, I agree that I could have organized that proof better. But I found it by more or less blindly following suggestions from <code>hint</code>. I guess what I'm wondering is  where do I learn about the yoga of <code>mk</code> vs <code>mk'</code> and all that, and I suppose how I should think of quotients as inductive types. Is this explained clearly somewhere?</p>",
        "id": 198967245,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590622664
    },
    {
        "content": "<p>Q2: <code>quotient.mk</code> works when the equivalence relation on M is known to the type class inference system. It's a long story.</p>",
        "id": 198967246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590622667
    },
    {
        "content": "<p>There are three kinds of brackets for function inputs in Lean. The <code>()</code> ones are inputs which the user supplies. The <code>{}</code> ones are ones which a C++ algorithm called Lean's unification system supplies. The <code>[]</code> ones are ones which a different C++ algorithm called Lean's type class system supplies.</p>",
        "id": 198967348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590622751
    },
    {
        "content": "<p>Put differently, what is going on in the <code>finish</code>es after <code>induction xyz</code>?</p>",
        "id": 198967352,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590622760
    },
    {
        "content": "<p>Yes, I am feeling a bit better about the various types of brackets now. I've moved on to being confused about quotients.</p>",
        "id": 198967435,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590622815
    },
    {
        "content": "<p>It took me a long time to get the hang of the <code>[]</code> system. The way it works is that the user puts things into the <code>[]</code> system (e.g. you put into the system the fact that R is a commutative ring) and then the system does magic behind the scenes, e.g. if you write <code>r + s</code> with <code>r : R</code> and <code>s : R</code> then the typeclass system will magic up <code>+</code> from the fact that it knows <code>R</code> is a ring and that rings have addition</p>",
        "id": 198967479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590622871
    },
    {
        "content": "<p>But you didn't put the equivalence relation defining <code>R/M</code> into the typeclass system, so <code>quotient.mk</code>, which runs on <code>[]</code>, can't get it out.</p>",
        "id": 198967500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590622903
    },
    {
        "content": "<p>Oh I see -- you're saying that in general I'm probably always going to want <code>mk'</code> because typically when working with many inferred things floating around, the type class inference system won't be able to handle <code>mk</code>?</p>",
        "id": 198967501,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590622904
    },
    {
        "content": "<p>The type class system can \"handle\" a quotient if and only if you've told it about the quotient, and if you're dealing with quotient modules then the unification system can handle it fine.</p>",
        "id": 198967563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590622945
    },
    {
        "content": "<p>OK that's helpful.</p>",
        "id": 198967611,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590622993
    },
    {
        "content": "<p>thank you</p>",
        "id": 198967616,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590622997
    },
    {
        "content": "<p>quotients aren't inductive types, they're quotient types. There are inductive types (structures), pi types (functions), quotient types, and that's it.</p>",
        "id": 198967635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623013
    },
    {
        "content": "<p>After <code>induction x</code>, the goal which <code>finish</code> is closing is <code>⊢ ∃ (m : M), m ∈ p ∧ quotient.mk' m = quot.mk setoid.r x</code></p>",
        "id": 198967729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623060
    },
    {
        "content": "<p>So a natural question (logically prior to my previous question about the <code>finish</code>es after <code>induction x</code>) is what <code>induction x</code> means when <code>x : X</code> for a quotient (rather than inductive) type <code>X</code>. Which I suppose I will now try to look up.</p>",
        "id": 198967860,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590623198
    },
    {
        "content": "<p>The local context in full is this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"err\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">x</span>\n</code></pre></div>\n\n\n<p>so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> is a submodule of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">x\\in M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>x</mi><mo stretchy=\"true\">‾</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\overline{x} = 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.63056em;vertical-align:0em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.63056em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span></span></span><span style=\"top:-3.55056em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">M/p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">p</span></span></span></span> and the goal is to find some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>∈</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">m\\in p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>m</mi><mo stretchy=\"true\">‾</mo></mover><mo>=</mo><mover accent=\"true\"><mi>x</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{m}=\\overline{x}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.63056em;vertical-align:0em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.63056em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">m</span></span></span><span style=\"top:-3.55056em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.63056em;vertical-align:0em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.63056em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span></span></span><span style=\"top:-3.55056em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 198967865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623209
    },
    {
        "content": "<p><code>induction x</code> uses the universal property of the quotient</p>",
        "id": 198967888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623238
    },
    {
        "content": "<p>ah ok</p>",
        "id": 198967894,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590623245
    },
    {
        "content": "<p>well, it's a rather silly universal property here</p>",
        "id": 198967917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623259
    },
    {
        "content": "<p>It might have been clearer to write <code>induction x with xtilde</code></p>",
        "id": 198967937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623280
    },
    {
        "content": "<p>ok so going back to unpacking <code>finish</code>, the first step is clearly <code>use x</code></p>",
        "id": 198968007,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590623335
    },
    {
        "content": "<p>and what is happening at that point is that Lean replaces all occurences of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">x\\in M/p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">p</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mover accent=\"true\"><mi>x</mi><mo>~</mo></mover><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\tilde{x}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.86786em;vertical-align:0em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.86786em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6678599999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span></span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.22222em;\"><span class=\"mord\">~</span></span></span></span></span></span></span></span></span><span style=\"top:-3.78786em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>x</mi><mo>~</mo></mover><mo>∈</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">\\tilde{x}\\in M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7069599999999999em;vertical-align:-0.0391em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6678599999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span></span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.22222em;\"><span class=\"mord\">~</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> reduces to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span></p>",
        "id": 198968013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623339
    },
    {
        "content": "<p>which gets us to : </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"err\">⊢</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 198968019,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590623351
    },
    {
        "content": "<p>I think you're going round in circles if you use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span></p>",
        "id": 198968034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623392
    },
    {
        "content": "<p>I would rather use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>",
        "id": 198968042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623401
    },
    {
        "content": "<p>aha!</p>",
        "id": 198968094,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590623417
    },
    {
        "content": "<p>I have no idea what <code>finish</code> used -- of course <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>x</mi><mo>~</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\tilde{x}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6678599999999999em;vertical-align:0em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6678599999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span></span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.22222em;\"><span class=\"mord\">~</span></span></span></span></span></span></span></span></span></span> would also work</p>",
        "id": 198968126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623454
    },
    {
        "content": "<p>So after <code>induction x, use 0, split, simp only [zero_mem], rw h, rw quotient.mk_zero</code> I am left with a mysterious tautology:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">x_a</span> <span class=\"n\">x_b</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">x_a</span> <span class=\"n\">x_b</span>\n<span class=\"err\">⊢</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 198968231,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590623565
    },
    {
        "content": "<p>I don't find this too troubling, but it seems a bit odd?</p>",
        "id": 198968239,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590623582
    },
    {
        "content": "<p>I think the easiest way to prove this is to use <code>submodule.mk_eq_zero</code></p>",
        "id": 198968380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590623728
    },
    {
        "content": "<p>that's probably an equality of proofs (you can turn on proof printing with <code>set_option pp.proofs true</code>) and so <code>refl</code> will close it</p>",
        "id": 198968446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590623771
    },
    {
        "content": "<p>It probably appeared because you applied things in a weird order and something was a metavariable when the subgoal would have normally been discharged</p>",
        "id": 198968484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590623825
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm₁</span><span class=\"o\">,</span> <span class=\"n\">hm₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_zero</span><span class=\"o\">,</span> <span class=\"err\">←</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hm₁</span><span class=\"o\">,</span>\n    <span class=\"n\">cc</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 198968641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590623966
    },
    {
        "content": "<p>Quotients are difficult to steer in general. You need to understand the API properly before you can use them effectively. I'm not really sure I understand the API properly, in some sense.</p>",
        "id": 198968758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624038
    },
    {
        "content": "<p>LOL I am not sure whether to be comforted by that or not.</p>",
        "id": 198968831,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590624102
    },
    {
        "content": "<p>The main thing to learn is that <code>quotient.lift</code> is about descending, not lifting.</p>",
        "id": 198968855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624121
    },
    {
        "content": "<p>(in the sense that mathematicians would use the word)</p>",
        "id": 198968902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624136
    },
    {
        "content": "<p>right, I did figure out it wasn't what I initial thought</p>",
        "id": 198968910,
        "sender_full_name": "Sam Lichtenstein",
        "timestamp": 1590624144
    },
    {
        "content": "<p>The whole <code>mk_eq_mk'</code> thing is a shame, it makes things much messier</p>",
        "id": 198968945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624200
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on&#39;</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span><span class=\"o\">:</span><span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_zero</span><span class=\"o\">],</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">m&#39;</span><span class=\"o\">,</span> <span class=\"n\">hm&#39;</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_zero</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 198969060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590624289
    },
    {
        "content": "<p>Mario is using the quotient interface correctly. It always takes me forever to find that first line</p>",
        "id": 198969104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624327
    },
    {
        "content": "<p>I think there is a missing theorem for <code>induction_on</code> for <code>submodule.quotient</code>, which would allow you to skip the <code>change</code> line</p>",
        "id": 198969106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590624328
    },
    {
        "content": "<p>I'm using the <code>induction_on</code> for <code>quotient'</code>, which is okay but gives you the wrong <code>mk</code></p>",
        "id": 198969169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590624365
    },
    {
        "content": "<p>I wrote <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/Zmod37.lean\">something about how to make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>37</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}/37\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mord\">7</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> in Lean once</a>, maybe I should re-read it.</p>",
        "id": 198969234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624467
    },
    {
        "content": "<p>If you use <code>induction x</code>, I think it will use <code>quotient.induction_on</code>, which gives you yet another version of <code>mk</code> that you would have to rewrite away more painfully</p>",
        "id": 198969248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590624475
    },
    {
        "content": "<p>The line <code>local attribute [instance] Zmod37.setoid</code> is inserting it as an instance into the typeclass system, so I can use the unprimed versions of everything all the way through</p>",
        "id": 198969347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624541
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">quotient_rel</span> <span class=\"bp\">_</span><span class=\"o\">)):</span><span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span><span class=\"o\">:</span><span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_zero</span><span class=\"o\">],</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">m&#39;</span><span class=\"o\">,</span> <span class=\"n\">hm&#39;</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n      <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_zero</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">refl</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 198969392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590624584
    },
    {
        "content": "<p>My Mario expansion factor used to be something like 10, it's comforting to see him coming up with proofs which are the same size as mine occasionally</p>",
        "id": 198969505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590624654
    },
    {
        "content": "<p>the final <code>refl</code>, discharging that funny <code>_ = _</code> goal, is apparently tossed up by <code>induction x</code>. I think it is using the dependent recursor for the quotient, which is basically a combination of <code>quotient.induction_on</code> and <code>quotient.lift</code>, and so has a side goal saying that the function that you constructed in the first part doesn't depend on the representative of the equivalence class. For proofs this is always trivial, which is why <code>induction_on</code> exists in the first place</p>",
        "id": 198969609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590624741
    },
    {
        "content": "<p>If you <code>#print lem</code>, you will see that the first theorem it uses is indeed <code>quot.rec</code>, which looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">proofs</span> <span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">elab_as_eliminator</span><span class=\"o\">,</span> <span class=\"n\">elab_strategy</span><span class=\"o\">,</span> <span class=\"kn\">reducible</span><span class=\"o\">]</span>\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">quot</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">)),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">quot</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 198969696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590624837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20.22access.22.20the.20module.20instance.20on.20submodule.20quotient.3F/near/198969505\">said</a>:</p>\n<blockquote>\n<p>My Mario expansion factor used to be something like 10, it's comforting to see him coming up with proofs which are the same size as mine occasionally</p>\n</blockquote>\n<p>Challenge accepted:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk&#39;</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">zero_mem</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_zero</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 198970218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590625277
    },
    {
        "content": "<p>I think the takeaway is that we just need to flesh out the api of quotient modules/rings/groups a bit more... currently they are written with a POV that you should fall back to the underlying <code>quotient</code> API, but I think that is quite confusing.</p>",
        "id": 198984663,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590644695
    }
]
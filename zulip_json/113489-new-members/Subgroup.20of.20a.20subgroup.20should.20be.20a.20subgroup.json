[
    {
        "content": "<p>Given a group G, I defined its two-torsion subgroup. I would like to show that this operation is idempotent:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_mul_mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"n\">mul_one</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">tidy</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">mul_inv_eq_one</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"n\">inv_eq_of_mul_eq_one</span> <span class=\"n\">ha</span><span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">two_torsion_group_iterate</span> <span class=\"o\">:</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">((</span><span class=\"n\">subgroup</span><span class=\"bp\">.</span><span class=\"n\">to_group</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>The lemma doesn't typecheck:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_group</span>\n<span class=\"n\">term</span>\n  <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_group</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">group</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u_1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>What am I doing wrong?</p>",
        "id": 205571022,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186045
    },
    {
        "content": "<p>read the error</p>",
        "id": 205571049,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186079
    },
    {
        "content": "<p><code>(two_torsion_subgroup G).to_group</code> is the \"proof\" that <code>two_torsion_subgroup G</code> is a group</p>",
        "id": 205571067,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186098
    },
    {
        "content": "<p>so it should read <code>two_torsion_subgroup G = two_torsion_subgroup (two_torsion_subgroup G)</code></p>",
        "id": 205571141,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186147
    },
    {
        "content": "<p>except that this won't typecheck as well</p>",
        "id": 205571144,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186152
    },
    {
        "content": "<p>Yes, what you suggest is the first thing that I tried.</p>",
        "id": 205571160,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186172
    },
    {
        "content": "<p>because LHS is a subgroup of <code>G</code> while RHS is a subgroup of <code>two_torsion_subgroup G</code></p>",
        "id": 205571163,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186177
    },
    {
        "content": "<p>I want to \"coerce\" somehow the subgroup to a group...</p>",
        "id": 205571170,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186187
    },
    {
        "content": "<p>the lemma should be <code>two_torsion_subgroup (two_torsion_subgroup G) = \\top</code></p>",
        "id": 205571211,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186240
    },
    {
        "content": "<p>then you can coerce it however you want</p>",
        "id": 205571259,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186253
    },
    {
        "content": "<p>I don't think the coercion is defined in mathlib though</p>",
        "id": 205571273,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186277
    },
    {
        "content": "<p>the sub-object API's need some work</p>",
        "id": 205571279,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186287
    },
    {
        "content": "<p>for now I hope <code>two_torsion_subgroup (two_torsion_subgroup G) = \\top</code> is good enough</p>",
        "id": 205571311,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186318
    },
    {
        "content": "<p>What is this good for?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 205571334,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186346
    },
    {
        "content": "<p>this allows you to treat <code>two_torsion_subgroup G</code> as a type</p>",
        "id": 205571360,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186362
    },
    {
        "content": "<p>instead of just a subgroup of <code>G</code></p>",
        "id": 205571401,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186384
    },
    {
        "content": "<p>So wouldn't that help my original goal? I want to put G and two_torsion_subgroup G both as the same Type, so that I can compare their respective two_torsion_subgroups</p>",
        "id": 205571486,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186473
    },
    {
        "content": "<p>(but it doesn't work)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">two_torsion_group_iterate&#39;</span> <span class=\"o\">:</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>gives</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">G</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u_1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">u_1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">((</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">u_1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 205571575,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186557
    },
    {
        "content": "<p>you don't use <code>has_coe_to_sort</code></p>",
        "id": 205571669,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186619
    },
    {
        "content": "<p>again, the correct term is <code>two_torsion_subgroup (two_torsion_subgroup G)</code></p>",
        "id": 205571695,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186646
    },
    {
        "content": "<p>where the inner <code>two_torsion_subgroup G</code> has been coerced to a type by the instance you posted</p>",
        "id": 205571707,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186659
    },
    {
        "content": "<p>before that, <code>two_torsion_subgroup G</code> is just a subgroup of <code>G</code></p>",
        "id": 205571745,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186697
    },
    {
        "content": "<p>it is after it has been coerced to a type that you can even say that <code>two_torsion_subgroup G</code> is a group</p>",
        "id": 205571763,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186709
    },
    {
        "content": "<p>only types can be groups</p>",
        "id": 205571772,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186716
    },
    {
        "content": "<p>and to be clear, when we say <code>X</code> is a group, what we mean is that we have an instance of <code>group X</code></p>",
        "id": 205571824,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186733
    },
    {
        "content": "<p>which allows you to write things like <code>1 : X</code></p>",
        "id": 205571832,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186742
    },
    {
        "content": "<p>Yes, the I am still confused by how groups/subgroups are implemented...</p>",
        "id": 205571843,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186753
    },
    {
        "content": "<p>I'll see if the solution that you proposed is enough for what I wanted!</p>",
        "id": 205571865,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186772
    },
    {
        "content": "<p><code>subgroup G</code> is the type of subgroups of <code>G</code></p>",
        "id": 205571868,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186775
    },
    {
        "content": "<p>i.e. <code>S : subgroup G</code> means \"<code>S</code> is a subgroup of <code>G</code>\"</p>",
        "id": 205571880,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186784
    },
    {
        "content": "<p>so there's no reason to suppose that <code>S</code> is a type</p>",
        "id": 205571899,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186801
    },
    {
        "content": "<p>but then that instance coerces <code>S</code> to a type (printed as some thick up arrow followed by <code>S</code>, but to type it you just type <code>S</code>)</p>",
        "id": 205571960,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186834
    },
    {
        "content": "<p>so now <code>subgroup S</code> makes sense</p>",
        "id": 205572016,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186852
    },
    {
        "content": "<p>and <code>U : subgroup S</code> means \"<code>U</code> is a subgroup of the result of the coercion of <code>S</code> into a type\"</p>",
        "id": 205572039,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186873
    },
    {
        "content": "<p>note that (coerced) <code>S</code> and <code>G</code> are incomparable types</p>",
        "id": 205572058,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186890
    },
    {
        "content": "<p>as in, given <code>x : S</code> and <code>g : G</code>, you cannot make the statement <code>x = g</code></p>",
        "id": 205572074,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186903
    },
    {
        "content": "<p>in Lean all distinct types are incomparable</p>",
        "id": 205572087,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186918
    },
    {
        "content": "<p>And what you are saying is that there's no good way to make S and G of the same type... That's too bad.</p>",
        "id": 205572163,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596186963
    },
    {
        "content": "<p>so in practice you should treat <code>S</code> as another group isomorphic to the subgroup of <code>G</code> also called <code>S</code></p>",
        "id": 205572176,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596186981
    },
    {
        "content": "<p>here's how the type coercion works</p>",
        "id": 205572210,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187022
    },
    {
        "content": "<p>given <code>x : S</code>, you can coerce it to <code>x : G</code> (printed with a little up-arrow, but to type it you just type <code>x : G</code>)</p>",
        "id": 205572225,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187043
    },
    {
        "content": "<p>the little up-arrow is a \"hidden function\"</p>",
        "id": 205572230,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187054
    },
    {
        "content": "<p>because, again, types in Lean are incomparable</p>",
        "id": 205572240,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187063
    },
    {
        "content": "<p>given <code>x : G</code> and <code>hx : x \\in S</code> (i.e. <code>hx</code> is a proof that <code>x</code> is an element of <code>S</code>), you can form <code>\\&lt;x, hx\\&gt; : S</code></p>",
        "id": 205572293,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187086
    },
    {
        "content": "<p>Oh so in one way it's automatic, in the other I need this bracket notation... that's useful.</p>",
        "id": 205572352,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596187176
    },
    {
        "content": "<p>so they are distinct types with (partial) functions going both ways</p>",
        "id": 205572367,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187199
    },
    {
        "content": "<p>(and BTW, I have no clue how to make progress in that lemma, although it's mathematically trivial)</p>",
        "id": 205572423,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596187217
    },
    {
        "content": "<p>similarly, <code>subgroup S</code> and <code>subgroup G</code> are incomparable types</p>",
        "id": 205572433,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187227
    },
    {
        "content": "<p>you cannot ever state that their terms are equal</p>",
        "id": 205572440,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187238
    },
    {
        "content": "<p>but again, you can define (partial) functions going both ways</p>",
        "id": 205572446,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187245
    },
    {
        "content": "<p>it's just that this hasn't been done in mathlib</p>",
        "id": 205572460,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187253
    },
    {
        "content": "<p>for no other reason than itself</p>",
        "id": 205572470,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187263
    },
    {
        "content": "<p>and anyway, even if you have that function, you would still need my lemma to prove the \"mathematically correct\" version</p>",
        "id": 205572500,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254058\">Marc Masdeu</span> <a href=\"#narrow/stream/113489-new-members/topic/Subgroup.20of.20a.20subgroup.20should.20be.20a.20subgroup/near/205572423\">said</a>:</p>\n<blockquote>\n<p>(and BTW, I have no clue how to make progress in that lemma, although it's mathematically trivial)</p>\n</blockquote>\n<p>you can start with (some variant of) <code>eq_top</code> (use the Ctrl+space trick!)</p>",
        "id": 205572515,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187309
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span>\n\n<span class=\"n\">def</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"k\">calc</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n        <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_mul_mul_comm</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">mul_one</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"k\">calc</span>  <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span>\n        <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">mul_inv</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">ha</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">one_inv</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">two_torsion_subgroup_idem</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">eq_top_iff</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span>\n<span class=\"k\">show</span> <span class=\"err\">⊤</span> <span class=\"bp\">≤</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span>\n<span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 205573020,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187662
    },
    {
        "content": "<p>right, so the two functions I told you about going between <code>G</code> and <code>S</code> are not enough for you to prove this lemma</p>",
        "id": 205573085,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187690
    },
    {
        "content": "<p>there's also the theorem that the function from <code>S</code> to <code>G</code> is surjective</p>",
        "id": 205573101,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187703
    },
    {
        "content": "<p>i.e. if <code>x y : S</code> such that <code>(x : G) = y</code> then <code>x = y</code></p>",
        "id": 205573114,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187715
    },
    {
        "content": "<p>this theorem is called <code>subtype.eq</code></p>",
        "id": 205573121,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187722
    },
    {
        "content": "<p>Wow thanks! This is so helpful!</p>",
        "id": 205573289,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596187847
    },
    {
        "content": "<p>note that Lean elaborates from outside to inside, so <code>(x * x : G)</code> actually means <code>(\\u x * \\u x : G)</code> (<code>\\u</code> being the coercion from <code>S</code> to <code>G</code>)</p>",
        "id": 205573324,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187892
    },
    {
        "content": "<p>Lean first sees the <code>*</code> and figures out that both operands must be terms of <code>G</code></p>",
        "id": 205573346,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187910
    },
    {
        "content": "<p>but actually typing out the arrow sometimes causes errors</p>",
        "id": 205573407,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187940
    },
    {
        "content": "<p>so don't type out the arrow</p>",
        "id": 205573411,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187944
    },
    {
        "content": "<p>well, not typing it sometimes causes errors, in different situations (such as the coercion from <code>finset</code> to <code>set</code>)</p>",
        "id": 205573432,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596187961
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span>\n\n<span class=\"n\">def</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"k\">calc</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n        <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_mul_mul_comm</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">mul_one</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"k\">calc</span>  <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span>\n        <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">mul_inv</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">ha</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">one_inv</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">two_torsion_subgroup_idem</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">eq_top_iff</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span>\n<span class=\"k\">show</span> <span class=\"err\">⊤</span> <span class=\"bp\">≤</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span>\n<span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">missing_from_mathlib</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">subgroup</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">subgroup</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">subgroup</span><span class=\"bp\">.</span><span class=\"n\">coe_top&#39;</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span><span class=\"bp\">.</span><span class=\"n\">map_le_iff_le_comap</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">missing_from_mathlib</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">two_torsion_subgroup_idem&#39;</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">two_torsion_subgroup_idem</span><span class=\"o\">,</span> <span class=\"n\">subgroup</span><span class=\"bp\">.</span><span class=\"n\">coe_top&#39;</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 205574300,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596188686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254058\">@Marc Masdeu</span> here's the \"mathematically correct\" statement and why it uses my lemma anyways</p>",
        "id": 205574312,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596188699
    },
    {
        "content": "<p>good job kenny</p>",
        "id": 205574544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596188877
    },
    {
        "content": "<p>thanks</p>",
        "id": 205574588,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596188887
    },
    {
        "content": "<p>I don't have time to build the subobject API yet though</p>",
        "id": 205574636,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596188931
    },
    {
        "content": "<p>You guys are great</p>",
        "id": 205574669,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596188971
    },
    {
        "content": "<p>This will be the last one for today, I promise:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">prod_identity_general</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)):</span>\n <span class=\"o\">((</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"k\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">prod_all_eq_prod_two_torsion</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">htors</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">),</span>  <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">mem_two_torsion_iff_square_eq_one</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">two_torsion_subgroup_idem</span><span class=\"o\">,</span>\n        <span class=\"n\">solve_by_elim</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"n\">norm_cast</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">prod_identity</span> <span class=\"n\">htors</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>I end up with the following state:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_group</span> <span class=\"n\">G</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">G</span>\n<span class=\"n\">htors</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">G2</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"err\">⊢</span> <span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)),</span> <span class=\"err\">↑</span><span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"err\">↑∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">x</span>\n</code></pre></div>\n\n\n<p>I want to apply finset.prod_hom with something like lam x : two_torsion_subgroup G, x : G,<br>\nbut it doesn't let me. This is probably some form of a similar problem that I have faced before, but I continuously get stuck with these sorts...</p>",
        "id": 205581268,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596195284
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I rewrote a M(N)WE hoping that it's a one-liner what I'm missing...</p>",
        "id": 205591111,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596202957
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">missing_from_mathlib</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">subgroup</span><span class=\"bp\">.</span><span class=\"n\">coe_is_monoid_hom</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{</span><span class=\"bp\">..</span><span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">missing_from_mathlib</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">prod_coerce</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 205593261,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596204169
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254058\">@Marc Masdeu</span> coe and coe_sort etc are not meant to be used explicitly</p>",
        "id": 205593749,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596204412
    },
    {
        "content": "<p>we use at most an uparrow</p>",
        "id": 205593775,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596204424
    },
    {
        "content": "<p>Thanks! I really didn't need the lemma, my code works now after the <code>instance</code> line.</p>",
        "id": 205593890,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596204466
    },
    {
        "content": "<p>How would I figure this up on my own? I mean, I wanted to <code>apply finset.prod_hom</code> and saw the error, and I was trying (unsuccessfully) to create a monoid_hom... I guess I still don't understand <code>instance</code>...</p>",
        "id": 205594175,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596204569
    },
    {
        "content": "<p>the error says failed to synthesize instance</p>",
        "id": 205596693,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205774
    },
    {
        "content": "<p>the typeclass system is like Lean's notebook</p>",
        "id": 205596719,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205791
    },
    {
        "content": "<p>whenever you tell Lean about one instance, Lean marks it down in her notebook</p>",
        "id": 205596772,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205804
    },
    {
        "content": "<p>this is called the type-class system</p>",
        "id": 205596794,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205813
    },
    {
        "content": "<p>so whenever you require an instance, you ask Lean what she has learnt, and she will find the knowledge from her notebook</p>",
        "id": 205596821,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205829
    },
    {
        "content": "<p>Instance means \"example of\"?</p>",
        "id": 205596832,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596205835
    },
    {
        "content": "<p>no</p>",
        "id": 205596842,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205840
    },
    {
        "content": "<p>instance just means something to mark down in her notebook</p>",
        "id": 205596856,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205851
    },
    {
        "content": "<p>It means definition in the notebook</p>",
        "id": 205596865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596205857
    },
    {
        "content": "<p>e.g. the group structure on a type</p>",
        "id": 205596899,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205882
    },
    {
        "content": "<p>the fact that a specific function is a homomorphism</p>",
        "id": 205596911,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205891
    },
    {
        "content": "<p>etc</p>",
        "id": 205596912,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205892
    },
    {
        "content": "<p>I see. So properties of objects that I may want Lean to use in the future...?</p>",
        "id": 205597011,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596205928
    },
    {
        "content": "<p>if you do <code>#check @finset.prod_hom</code> you will see:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_hom</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">comm_monoid</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid_hom</span> <span class=\"n\">g</span><span class=\"o\">],</span>\n    <span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 205597038,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205940
    },
    {
        "content": "<p>the arguments in square brackets are what you ask Lean from her notebook</p>",
        "id": 205597075,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205960
    },
    {
        "content": "<p><code>[comm_monoid \\b]</code> means \"ask Lean to provide a commutative monoid structure on beta\"</p>",
        "id": 205597124,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596205981
    },
    {
        "content": "<p>Instances vs square-brackets is as far as my knowledge goes on this...</p>",
        "id": 205597134,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596205985
    },
    {
        "content": "<p>when you use it you don't need to provide the argument explicitly</p>",
        "id": 205597170,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206002
    },
    {
        "content": "<p>Lean will search her notebook for you</p>",
        "id": 205597181,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206006
    },
    {
        "content": "<p>the arguments in curly brackets are also implicit, but they work using a different system</p>",
        "id": 205597238,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206037
    },
    {
        "content": "<p>so e.g. Lean knows that Z is a comm_monoid</p>",
        "id": 205597322,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206058
    },
    {
        "content": "<p>so this theorem <code>finset.prod_hom</code> can be applied for beta being Z</p>",
        "id": 205597347,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206069
    },
    {
        "content": "<p>So it's an automated set of hypotheses, sort of. I could write a lemma that said something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">comm_monoid</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid_hom</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n    <span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but then it would be more annoying to use. Is that right?</p>",
        "id": 205597391,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596206093
    },
    {
        "content": "<p>exactly</p>",
        "id": 205597439,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206113
    },
    {
        "content": "<p>then you would have to explicitly provide the \"proof\" that beta is a comm monoid</p>",
        "id": 205597483,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206140
    },
    {
        "content": "<p>Oh nice! Lean didn't tell me which of the three instances couldn't make sense of. Is there a way to ask for that?</p>",
        "id": 205597499,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596206149
    },
    {
        "content": "<p>which will be something like <code>int.comm_monoid</code></p>",
        "id": 205597505,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206152
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>failed to synthesize type class instance for\nG : Type u_1,\n_inst_1 : comm_group G,\n_inst_2 : fintype G,\nH : subgroup G\n⊢ is_monoid_hom coe\n</code></pre></div>",
        "id": 205597571,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206170
    },
    {
        "content": "<p>read the error</p>",
        "id": 205597575,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206173
    },
    {
        "content": "<p>Oh! Sorry, I see. It'd be nice that there was a modification of apply (like convert) that introduced this as a new goal...</p>",
        "id": 205597652,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596206222
    },
    {
        "content": "<p>why not prove it separately?</p>",
        "id": 205597689,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206243
    },
    {
        "content": "<p>keep proofs short but many</p>",
        "id": 205597735,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206267
    },
    {
        "content": "<p>When in tactic mode, it's nice when you can keep applying results that you know will allow you to make progress (in this case, <code>prod.hom</code>), and get asked for the hypotheses later.</p>",
        "id": 205597904,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596206331
    },
    {
        "content": "<p>I guess it makes some sense</p>",
        "id": 205598089,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206417
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">prod_coerce</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n<span class=\"kn\">end</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">tactic failed, there are unsolved goals</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">G : Type u_1,</span>\n<span class=\"cm\">_inst_1 : comm_group G,</span>\n<span class=\"cm\">_inst_2 : fintype G,</span>\n<span class=\"cm\">H : subgroup G</span>\n<span class=\"cm\">⊢ is_monoid_hom coe</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 205598608,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206658
    },
    {
        "content": "<p>this is the best I can do <span class=\"user-mention\" data-user-id=\"254058\">@Marc Masdeu</span></p>",
        "id": 205598621,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596206669
    },
    {
        "content": "<p>you can get the instances as goals by using <code>@</code></p>",
        "id": 205601568,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596207966
    },
    {
        "content": "<p>if you look at the type of <code>@prod_hom</code>, you'll see that it has explicit arguments for the typeclass instances</p>",
        "id": 205601639,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596208009
    },
    {
        "content": "<p>so if you <code>apply @prod_hom</code> with appropriate underscores, the instances will appear as goals</p>",
        "id": 205601728,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596208057
    },
    {
        "content": "<p>Thanks guys! All these tricks should be documented somewhere. Like the Tactic cheatsheet, they'd very useful for noobs...</p>",
        "id": 205609583,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1596211834
    },
    {
        "content": "<p>better documentation and tutorialization is definitely a goal</p>",
        "id": 205609795,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596211949
    },
    {
        "content": "<p>from my rereading, most of this conversation was just explaining what typeclasses are</p>",
        "id": 205609890,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596212018
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> chapter 10 is all about type classes</p>",
        "id": 205609907,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596212027
    },
    {
        "content": "<p>type classes probably get a more gentle introduction in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a></p>",
        "id": 205610065,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596212101
    }
]
[
    {
        "content": "<p>Hi all. I'm just starting out with Lean and dependently typed languages.</p>\n<p>To get started, I'm making my way through the <a href=\"https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html\">book</a> and exercises when I tripped over the following in my implementation of <code>zip</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[])</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs'</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">ys'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">xs'</span> <span class=\"n\">ys'</span>\n</code></pre></div>\n<p>I get a message saying Lean failed to prove termination because arguments <a href=\"https://github.com/leanprover-community/mathlib/pull/3\">#3</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/4\">#4</a> are \"not used for structural recursion\". When I rewrite the function into a form that looks totally equivalent to me, the complaint goes away:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">ys</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">ys'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">xs'</span> <span class=\"n\">ys'</span>\n</code></pre></div>\n<p>Is there some difference between the two versions that means they aren't equivalent from the standpoint of involving structural recursion? </p>\n<p>Thanks!</p>",
        "id": 313622787,
        "sender_full_name": "Matt Pillsbury",
        "timestamp": 1670033926
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs'</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">ys'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">xs'</span> <span class=\"n\">ys'</span>\n</code></pre></div>",
        "id": 313625163,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1670036093
    },
    {
        "content": "<p>There is no need to match on tuples.</p>",
        "id": 313625168,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1670036099
    },
    {
        "content": "<p>I suspect that this has to do with the fact that if you want to define a function on lists recursively then there's a auto-generated theorem of the form \"if you've defined it for nil and for cons then you're done, and in the cons case you can assume it's already defined for the tail\" but the analogous theorem for pairs is \"if you want to define it for pairs then you have to define it for all pairs and you can't assume anything\" because the definition of a pair is not recursive in the same way. So induction on pairs isn't going to work out of the box.</p>",
        "id": 313644473,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670054351
    },
    {
        "content": "<p>Thank you both!</p>\n<p>Also the syntax Adam introduced solved my problem, so I flipped to the next page in the book, which shows exactly that syntax.</p>",
        "id": 313720935,
        "sender_full_name": "Matt Pillsbury",
        "timestamp": 1670091930
    }
]
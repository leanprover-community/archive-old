[
    {
        "content": "<p>Hi all! New to the stream here. I'm wondering how to inductively define the type of terms with a given signature.<br>\nFirst we have variables:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Var</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Var</span>\n</code></pre></div>\n<p>We then define the type class of signatures of function symbols:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[class]</span> <span class=\"kd\">structure</span> <span class=\"n\">Fsym</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">far</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, here comes the tricky part I do not know how to solve. The problem is that, since different function symbols could have different signature, it is not intuitively clear how to inductively define the type of terms with a given signature. What I did is to first define a type function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nprod</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span>     <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">nprod</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and proceed to write something as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fsym</span> <span class=\"n\">func</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">vst</span> <span class=\"o\">:</span> <span class=\"n\">Var</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n<span class=\"bp\">|</span> <span class=\"n\">tap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">func</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vecx</span> <span class=\"o\">:</span> <span class=\"n\">nprod</span> <span class=\"o\">(</span><span class=\"n\">Fsym.far</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n</code></pre></div>\n<p>However, Lean complaints with error: \"inductive type being declared can only be nested inside the parameters of other inductive types\". It seems we cannot have a dependent type in the field of inductive definition. I'm not sure whether such type of things have a standard solution or not; I'd really appreciate it if someone could help me with a reasonable definition.</p>",
        "id": 256416239,
        "sender_full_name": "Andy Ye",
        "timestamp": 1633528923
    },
    {
        "content": "<p>It's not your problem, but your <code>nprod</code> has two branches that match <code>n=1</code></p>",
        "id": 256419235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633530062
    },
    {
        "content": "<p>Your problem is that your <code>nprod</code> amounts to using a recursor in an argument of an inductive type, which is not allowed. This produces the same error, inlining <code>nprod</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fsym</span> <span class=\"n\">func</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">vst</span> <span class=\"o\">:</span> <span class=\"n\">Var</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n<span class=\"bp\">|</span> <span class=\"n\">tap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">func</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vecx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"n\">Fsym.far</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">unit</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n</code></pre></div>",
        "id": 256419897,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633530307
    },
    {
        "content": "<p>An easy way out is to use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fsym</span> <span class=\"n\">func</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">vst</span> <span class=\"o\">:</span> <span class=\"n\">Var</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n<span class=\"bp\">|</span> <span class=\"n\">tap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">func</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vecx</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">Fsym.far</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n</code></pre></div>\n<p>instead</p>",
        "id": 256419961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633530338
    }
]
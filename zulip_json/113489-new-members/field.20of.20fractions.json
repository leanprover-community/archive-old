[
    {
        "content": "<p>Before I embark in proving the lemma below, could I ask that it is what I think that it is mathematically?</p>\n<p>I want to prove that if <code>f : polynomial ℤ</code> and <code>a b : ℤ</code>, then <code>b ^ f.nat_degree * eval f (a / b)</code> is an integer.  Is this what the code below generalizes?  Is the statement that I want already in Lean?</p>\n<p>Thanks! </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d.to_map</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 220376819,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608301293
    },
    {
        "content": "<p>(Also, feel free to suggest any improvements to the statement: I have never used localizations in Lean before.)</p>",
        "id": 220377906,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608301838
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> yup, that statement looks right. And I'm sorry that it turns into such a mess.</p>",
        "id": 220378937,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608302370
    },
    {
        "content": "<p>I think we should be able to make this look better... but it will require changes to mathlib</p>",
        "id": 220379045,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608302410
    },
    {
        "content": "<p>Thanks for the confirmation!  Since I had not experience of fields of fractions, I wanted to make sure that I was not complicating my life too much by doing it like this!</p>",
        "id": 220379062,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608302424
    },
    {
        "content": "<p>Should <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fraction_map\">docs#fraction_map</a> have a coe_to_fun equal to to_map?</p>",
        "id": 220379205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608302501
    },
    {
        "content": "<p>So that I understand Eric's comment: this means I would not need to type <code>d.to_map b</code>, but simply <code>d b</code> would suffice?</p>",
        "id": 220379355,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608302575
    },
    {
        "content": "<p>I think <code>fraction_map</code> (and <code>localization_map</code>) should be predicates on <code>ring_hom</code>.</p>",
        "id": 220379408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608302609
    },
    {
        "content": "<p>But that requires a bunch of refactoring, for which I currently don't have the time</p>",
        "id": 220379431,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608302625
    },
    {
        "content": "<p>I think the instance may already be there</p>",
        "id": 220379513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608302652
    },
    {
        "content": "<p>Does it work without to_map?</p>",
        "id": 220379550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608302674
    },
    {
        "content": "<p>I am waiting for Lean to process the file: it takes a really long time.</p>\n<p>Earlier, though, I had to put in the <code>.to_map</code> since at some stage it was not working without.  However, it was also a stage where I did not have a correctly formed term, so I am not sure that the missing <code>.to_map</code> was the issue.</p>",
        "id": 220380354,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608303078
    },
    {
        "content": "<p>It might be that you only need one of the <code>to_map</code>s</p>",
        "id": 220381099,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608303434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/220379408\">said</a>:</p>\n<blockquote>\n<p>I think <code>fraction_map</code> (and <code>localization_map</code>) should be predicates on <code>ring_hom</code>.</p>\n</blockquote>\n<p>Perhaps <code>fraction_map R K</code> should even be a class extending <code>algebra R K</code>?</p>",
        "id": 220381272,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1608303520
    },
    {
        "content": "<p>Finally I could use Lean!  It seems to require the <code>.to_map</code>.  For instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"c1\">--function expected at</span>\n<span class=\"c1\">--  d</span>\n<span class=\"c1\">--term has type</span>\n<span class=\"c1\">--  localization_map (non_zero_divisors R) K</span>\n</code></pre></div>\n<p>whereas </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d.to_map</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>works.</p>",
        "id": 220381643,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608303688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/220376819\">said</a>:</p>\n<blockquote>\n<p>Before I embark in proving the lemma below, could I ask that it is what I think that it is mathematically?</p>\n<p>I want to prove that if <code>f : polynomial ℤ</code> and <code>a b : ℤ</code>, then <code>b ^ f.nat_degree * eval f (a / b)</code> is an integer.  Is this what the code below generalizes?  Is the statement that I want already in Lean?</p>\n<p>Thanks! </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d.to_map</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Equivalent, but nicer, should be to have the conclusion <code>d.is_integer ((((d.to_map b) ^ f.nat_degree * eval₂ d.to_map (d.to_map a / d.to_map b) f))</code> (see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/localization_map.is_integer\">docs#localization_map.is_integer</a>).</p>",
        "id": 220381822,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1608303758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/220379355\">said</a>:</p>\n<blockquote>\n<p>So that I understand Eric's comment: this means I would not need to type <code>d.to_map b</code>, but simply <code>d b</code> would suffice?</p>\n</blockquote>\n<p>It would be nice, but isn't possible at the moment. So you'll have to write <code>d.to_map b</code> always, unfortunately.</p>",
        "id": 220382032,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1608303855
    },
    {
        "content": "<p>Anne, thanks for the suggestion!  I will use <code>.is_integer</code>!  Also, no worries about the <code>.to_map</code>: it had not even occurred to me that it might be possible to not have to type it!</p>",
        "id": 220382215,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608303951
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">fraction_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">localization_map.to_ring_hom</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">d.is_integer</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"bp\">↑</span><span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>If it doesn't cause too much pain, that <code>has_coe </code> instance could be added back to mathlib later.</p>",
        "id": 220383119,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608304353
    },
    {
        "content": "<p>Ah, thanks a lot, Eric!  I am not at all familiar with <code>coe</code>stuff, but I am happy to use what you proposed!</p>\n<p>In any case, I will start proving this result in a bit: I first need to set up an inductive argument.</p>",
        "id": 220383254,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608304441
    },
    {
        "content": "<p>I'd probably try to prove the <code>to_map</code> version first, and then see what breaks if you use the <code>has_coe</code> instead one you already have the proof</p>",
        "id": 220383387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608304501
    },
    {
        "content": "<p>If we later decide to add the <code>has_coe</code>, we should not forget to also add a <code>has_coe_to_fun</code>, as explained in <a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#function%20coercion\">the function coercion library note</a>.</p>",
        "id": 220383872,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1608304745
    },
    {
        "content": "<p>In case anyone is interested, want to golf the proofs or has comments of any form, below is a proof of the initial lemma!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.erase_lead</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">erase_lead_card_support_eq</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f0</span> <span class=\"o\">:</span> <span class=\"n\">f.support.card</span> <span class=\"bp\">=</span> <span class=\"n\">c.succ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.erase_lead.support.card</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">erase_lead_support</span><span class=\"o\">,</span> <span class=\"n\">card_erase_of_mem</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">nat.pred_eq_of_eq_succ</span> <span class=\"n\">f0</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">nat_degree_eq_support_max'</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">f.support.max'_mem</span> <span class=\"o\">(</span><span class=\"n\">nonempty_support_iff.mpr</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">support_zero</span><span class=\"o\">,</span> <span class=\"n\">card_empty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">f0</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">not_le.mpr</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_pos</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">eq.ge</span> <span class=\"n\">f0</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Pind</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P_0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P_C_mul_pow</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">P_C_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">g.nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">df</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize'</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">f.support</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">c</span> <span class=\"k\">with</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">df</span> <span class=\"n\">f0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">(</span><span class=\"n\">finsupp.support_eq_empty.mp</span> <span class=\"o\">(</span><span class=\"n\">card_eq_zero.mp</span> <span class=\"n\">f0</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">df</span> <span class=\"n\">f0</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">erase_lead_add_C_mul_X_pow</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">P_C_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">erase_lead_nat_degree_le</span> <span class=\"n\">df</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">nat_degree_C_mul_X_pow_le</span> <span class=\"o\">(</span><span class=\"n\">leading_coeff</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat_degree</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"n\">df</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hc</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">erase_lead_nat_degree_le</span> <span class=\"n\">df</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">erase_lead_card_support_eq</span> <span class=\"n\">f0</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">P_C_mul_pow</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">df</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">leading_coeff_eq_zero</span><span class=\"o\">],</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">not_le.mpr</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_pos</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">eq.ge</span> <span class=\"n\">f0</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">P_0</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">d.is_integer</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eval₂_zero</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">d.to_map.map_zero</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">P_C_mul_pow</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span>\n    <span class=\"n\">d.is_integer</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">r</span> <span class=\"n\">r0</span> <span class=\"n\">nN</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nat_degree</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">C_mul_X_pow_eq_monomial</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat_degree_monomial</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">r0</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eval₂_X_pow</span><span class=\"o\">,</span> <span class=\"n\">div_pow</span><span class=\"o\">,</span> <span class=\"n\">eval₂_C</span><span class=\"o\">,</span> <span class=\"n\">eval₂_mul</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.map_pow</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.map_mul</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_mul_left_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">left</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mul_div_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_div_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_div_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_eq_mul_left_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">left</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_eq_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"n\">nat.sub_add_cancel</span> <span class=\"n\">nN</span><span class=\"o\">],</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l0</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">b0</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">pow_eq_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">localization_map.injective</span> <span class=\"n\">d</span> <span class=\"n\">le_rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ring_hom.map_pow</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.map_zero</span><span class=\"o\">,</span> <span class=\"n\">localization_map.injective</span> <span class=\"n\">d</span> <span class=\"n\">le_rfl</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">P_C_add</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">g.nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span>\n    <span class=\"n\">d.is_integer</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"n\">d.is_integer</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"n\">d.is_integer</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">fN</span> <span class=\"n\">gN</span> <span class=\"o\">⟨</span><span class=\"n\">f1</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">g1</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f1</span> <span class=\"bp\">+</span> <span class=\"n\">g1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"n\">eval₂_add</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.map_add</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_integer_N</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span>\n<span class=\"n\">d.is_integer</span> <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">Pind</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">P_0</span> <span class=\"n\">N</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P_C_mul_pow</span> <span class=\"n\">N</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P_C_add</span> <span class=\"n\">N</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">d.is_integer</span> <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_integer_N</span> <span class=\"o\">(</span><span class=\"n\">nat_degree</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b0</span> <span class=\"n\">f</span> <span class=\"n\">le_rfl</span>\n</code></pre></div>",
        "id": 220407420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608314434
    },
    {
        "content": "<p>A follow up question: is the definition below already in mathlib?  Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zq</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_units'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">surj'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_iff_exists'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 220453588,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608352946
    },
    {
        "content": "<p>Found it!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The cast from `int` to `rat` as a `fraction_map`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">int.fraction_map</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">map_units'</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">submonoid.mem_carrier</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_unit_iff_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">int.cast_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">surj'</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩⟩,</span> <span class=\"n\">rat.mul_denom_eq_num</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">submonoid.mem_carrier</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">int.coe_nat_ne_zero_iff_pos</span><span class=\"o\">]</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_iff_exists'</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">int.cast_inj</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"mi\">1</span> <span class=\"o\">},</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">int.eq_of_mul_eq_mul_right</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">submonoid.mem_carrier</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">int.cast_ring_hom</span> <span class=\"n\">ℚ</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 220453815,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608353470
    },
    {
        "content": "<p>You can search <code>fraction_map ℤ ℚ</code> in VSCode</p>",
        "id": 220454191,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1608354206
    },
    {
        "content": "<p>Ah, thanks for the pointer!  I still had not realized that there was a search tool across all the repository!  I had created my own using <code>grep</code> on the command line!</p>",
        "id": 220454618,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608354975
    },
    {
        "content": "<p>Once more, how can I prove this fact?  I cannot get the coercion to more from the submonoid to the element.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.non_zero_divisors</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors</span> <span class=\"n\">Z</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">↑</span><span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">non_zero_divisors</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 220455654,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608357014
    },
    {
        "content": "<p><code>exact c.2</code></p>",
        "id": 220455726,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1608357193
    },
    {
        "content": "<p>Seriously!  It works, thanks a lot!!</p>",
        "id": 220455730,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608357233
    },
    {
        "content": "<p>Is there a way of finding out such proofs automatically?  Library_search does not seem to try the components of assumptions.</p>",
        "id": 220459587,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608365102
    },
    {
        "content": "<p>Which is weird, because this is just shorthand for <code>subtype.property c</code></p>",
        "id": 220459832,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608365574
    },
    {
        "content": "<p>Is there a tactic that tries out <code>exact h.i</code> where <code>h</code> is a hypothesis and <code>i</code> an index?</p>",
        "id": 220459958,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608365833
    },
    {
        "content": "<p>Something like <code>assumption</code>, except... <code>subassumption</code>?</p>",
        "id": 220460008,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608365891
    },
    {
        "content": "<p>A tactic like library_search is to find proofs when you don't know where they are. Here it's clear where the proof is, all you need to learn is the simple technique for getting it out.</p>",
        "id": 220460064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608366004
    },
    {
        "content": "<p>Re subassumption -- if you've spent some time playing with pp.all true you will discover how absolutely gigantic some terms are!</p>",
        "id": 220460203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608366319
    },
    {
        "content": "<p>That, together with the fact that figuring out if two terms have the same type is noncomputable, indicates that it might be better off just learning the trick</p>",
        "id": 220460254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608366400
    },
    {
        "content": "<p>Ok, in this case, I had no idea that <code>c.2</code> was my assumption, but I take your points!</p>",
        "id": 220460409,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608366690
    },
    {
        "content": "<p>If you don't understand what c is or how to work with it, you should right click on <code>non_zero_divisors</code> and jump to definition, where you will see how it's defined and examples of how to use it plus the basic API (the lemmas proved just after the definition).</p>",
        "id": 220460645,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608367163
    },
    {
        "content": "<p>Inside a tactic proof you can also do <code>cases c</code> if you want to see what it's hiding</p>",
        "id": 220460691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608367231
    },
    {
        "content": "<p>But in this case clicking on <code>non_zero_divisors</code> wouldn't help. It's the <code>coe_to_sort</code> that was hiding something</p>",
        "id": 220460808,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608367532
    },
    {
        "content": "<p>Thank you both!  I had looked at non_zero_divisors and I tried to exact it a lot, but did not think of it having fields.  A rookie mistake!</p>",
        "id": 220463166,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608372274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> <code>non_zero_divisors</code> is a set. But sets can be coerced into types (using <code>coe_to_sort</code>). This coercion sends a set <code>s</code> to <code>subtype s = {x // x \\in s}</code>.</p>",
        "id": 220463298,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608372501
    },
    {
        "content": "<p>If <code>s : set X</code>, then <code>subtype s</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">\\</span><span class=\"k\">in</span> <span class=\"n\">s</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 220463305,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608372533
    },
    {
        "content": "<p>So if you have a term <code>c : non_zero_divisors</code>, then <code>c.val</code> is the raw element, and <code>c.property</code> is the proof witness that <code>c.val</code> is in fact a nonzero divisor.</p>",
        "id": 220463325,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608372601
    },
    {
        "content": "<p><code>c.2</code> is just shorthand for <code>c.property</code>.</p>",
        "id": 220463365,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608372613
    },
    {
        "content": "<p>But my main point is that <code>.val</code> and <code>.property</code> have nothing to do with <code>non_zero_divisor</code>. They come from <code>subtype</code>.</p>",
        "id": 220463372,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608372640
    },
    {
        "content": "<p>And the <code>subtype</code> showed up by some hidden Lean trick, because <code>non_zero_divisor</code> was being treated as a <em>Type</em> instead of as a <em>set</em>.</p>",
        "id": 220463385,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608372672
    },
    {
        "content": "<p>Thank you very much for the explanation!  I am now just competent enough to understand what you are saying!</p>",
        "id": 220463519,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608372862
    },
    {
        "content": "<p>And it clarifies a lot!</p>",
        "id": 220463522,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608372871
    },
    {
        "content": "<p>I bet <code>suggest</code> would give you the proof right away</p>",
        "id": 220494422,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1608423339
    },
    {
        "content": "<p><code>hint</code> suggests <code>cases c</code> and then <code>hint</code> again suggests <code>tauto</code> which works :-)</p>",
        "id": 220495084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608424580
    },
    {
        "content": "<p>Ah. That's too bad! Is there any way to add <code>subtype.property</code> to the <code>suggest</code> list?</p>",
        "id": 220495339,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1608425099
    },
    {
        "content": "<p>Thanks for the suggestion of using <code>cases</code>!  I do not use cases enough, I think.  Once that step made its way in its final form, it is included in the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exact</span> <span class=\"n\">false.rec</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">not_not.mpr</span> <span class=\"n\">ze</span> <span class=\"o\">(</span><span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mp</span> <span class=\"n\">c.property</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 220503813,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608441402
    },
    {
        "content": "<p>Below is a proof that you can obtain a <code>fraction_map</code> out of an <code>injective</code> ring homomorphism such that every element of the target is the ratio of two elements of the source.  This is not much longer than the proof of <code>int.fraction_map</code> and you can recover <code>int.fraction_map</code> from this in 4 lines.</p>\n<ol>\n<li>Is the lemma below already in mathlib?  I could not find it.</li>\n<li>Does it seem like a valuable addition?</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">fraction_map_of_inj_frac</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">Q</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→+*</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">inj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">gen</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fraction_map</span> <span class=\"n\">Z</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"n\">z</span><span class=\"o\">),</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_one</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_mul</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_zero</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_add</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">map_units'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">submonoid.mem_carrier</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨{</span><span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">val_inv</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">inv_val</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">},</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n    <span class=\"o\">{</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">mul_inv_cancel</span> <span class=\"o\">},</span>\n      <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">inv_mul_cancel</span> <span class=\"o\">},</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">ring_hom.map_zero</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">function.injective.ne</span> <span class=\"n\">inj</span> <span class=\"n\">z</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">surj'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">gen</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class=\"n\">b0</span><span class=\"o\">⟩⟩,</span> <span class=\"n\">H</span><span class=\"o\">⟩,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_iff_exists'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">function.injective.eq_iff</span> <span class=\"n\">inj</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_mul_right_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">ze</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">false.rec</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">not_not.mpr</span> <span class=\"n\">ze</span> <span class=\"o\">(</span><span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mp</span> <span class=\"n\">c.property</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 220504357,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608442428
    },
    {
        "content": "<p>And below is the proof of <code>int.fraction_map</code>, given the lemma above.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ZQ_alg</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"n\">fraction_map_of_inj_frac</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">int.cast_inj</span> <span class=\"n\">ℚ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">ring_hom.eq_int_cast</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">q.1</span><span class=\"o\">,</span> <span class=\"n\">q.2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">norm_cast</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">rat.denom_ne_zero</span> <span class=\"n\">q</span> <span class=\"o\">},</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ring_hom.eq_int_cast</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.eq_int_cast</span><span class=\"o\">,</span> <span class=\"n\">int.cast_coe_nat</span><span class=\"o\">,</span> <span class=\"n\">rat.mul_denom_eq_num</span><span class=\"o\">]</span> <span class=\"o\">)⟩)</span>\n</code></pre></div>\n<p>together with a proof that it coincides with the earlier definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"n\">ZQ_alg</span> <span class=\"bp\">=</span> <span class=\"n\">fraction_map.int.fraction_map</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext1</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ring_hom.eq_int_cast</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 220504477,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608442566
    },
    {
        "content": "<p>Dear All,</p>\n<p>in the process of cleaning up, I now have two almost identical proofs of essentially the same statement.  One assumes that you start with a <code>semiring/comm_ring</code> pair, the other with an <code>integral_domain/field</code> pair.  I would like to obtain the <code>integral_domain/field</code> result as an application of the <code>semiring/comm_ring</code> one.  However, I seem to be steering Lean to proving something that is not true.  Can anyone help me with the second <code>sorry</code> below, please?  Thank you very much!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">semiring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">bi</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">bu</span> <span class=\"o\">:</span> <span class=\"n\">bi</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span>  <span class=\"c1\">-- this is the lemma that I can prove</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bi</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bu</span> <span class=\"o\">:</span> <span class=\"n\">bi</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"n\">D</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">bi</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial.map</span> <span class=\"n\">i</span> <span class=\"n\">f</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>  <span class=\"c1\">-- I have a full proof of this fact</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">semiring</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">fractions_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- this is the \"special case\" of the previous one that I can only prove by reproving it along</span>\n<span class=\"c1\">-- the same lines as the lemma above</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens_2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">d.is_integer</span> <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">nums_dens</span> <span class=\"n\">d.to_map</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">eval</span><span class=\"o\">,</span> <span class=\"c1\">-- here you can see that Lean is following different paths that seem to diverge</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- I can see that Lean went to try to prove something that is not necessarily true</span>\n  <span class=\"c1\">-- but how can I get it to prove what actually is true?</span>\n  <span class=\"n\">apply</span> <span class=\"n\">one_div_mul_cancel</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">localization_map.to_map</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">function.injective.ne</span> <span class=\"o\">(</span><span class=\"n\">fraction_map.injective</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">b0</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">fractions_map</span>\n</code></pre></div>",
        "id": 221219330,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609341319
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.field_simp</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">semiring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">bi</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">bu</span> <span class=\"o\">:</span> <span class=\"n\">bi</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span>  <span class=\"c1\">-- this is the lemma that I can prove</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bi</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bu</span> <span class=\"o\">:</span> <span class=\"n\">bi</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"n\">D</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">bi</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>  <span class=\"c1\">-- I have a full proof of this fact</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">semiring</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">fractions_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">fraction_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- this is the \"special case\" of the previous one that I can only prove by reproving it along</span>\n<span class=\"c1\">-- the same lines as the lemma above</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens_2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">d.is_integer</span> <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">nums_dens</span> <span class=\"n\">d.to_map</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">field_simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">one_div_mul_cancel</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">localization_map.to_map</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">function.injective.ne</span> <span class=\"o\">(</span><span class=\"n\">fraction_map.injective</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">b0</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">fractions_map</span>\n</code></pre></div>\n<p>Note that I changed <code>eval</code> to <code>eval\\_2</code> in the first lemma.</p>",
        "id": 221220019,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609341886
    },
    {
        "content": "<p>I don't know how important it is for you to have <code>eval</code> as opposed to <code>eval_2</code>.</p>",
        "id": 221220152,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609341991
    },
    {
        "content": "<p>Ah, thank you!  I will try to see how it plays out: to be honest, I do not know what the difference between<code>eval</code> and <code>eval2</code> is.</p>",
        "id": 221221142,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609342927
    },
    {
        "content": "<p>As I understand it, <code>eval_2</code> takes a polynomial over <code>R</code> and a morphism <code>R -&gt; S</code> and evaluates the polynomial in <code>S</code>.</p>",
        "id": 221221251,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343060
    },
    {
        "content": "<p>So it looks like that's exactly what you're trying to do in <code>nums_dens</code>.</p>",
        "id": 221221261,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343077
    },
    {
        "content": "<p>If you insist on using <code>eval</code>, I suggest using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.eval₂_eq_eval_map\">docs#polynomial.eval₂_eq_eval_map</a></p>",
        "id": 221221311,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343141
    },
    {
        "content": "<p>Thanks for the conversion between eval and eval2: it seems that everything might be a simple <code>rw</code> away!</p>",
        "id": 221221456,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609343252
    },
    {
        "content": "<p>Indeed: below is a proof of the literal statements that I wrote before!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nums_dens_2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">d.is_integer</span> <span class=\"o\">(((</span><span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">d.to_map</span> <span class=\"o\">(</span><span class=\"n\">d.to_map</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">wfs.nums_dens</span> <span class=\"n\">d.to_map</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">d.to_map</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eval₂_eq_eval_map</span><span class=\"o\">,</span> <span class=\"n\">mul_one_div</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">one_div_mul_cancel</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">localization_map.to_map</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">function.injective.ne</span> <span class=\"o\">(</span><span class=\"n\">fraction_map.injective</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">b0</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Thank you very much!</p>",
        "id": 221221711,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609343415
    },
    {
        "content": "<p>Right, there are 3 ways of evaluating polynomials. If you have <code>f : polynomial R</code>, then you can use</p>\n<ul>\n<li><code>eval</code> to evaluate <code>f</code> on elements of <code>R</code>,</li>\n<li><code>eval2</code> to evaluate <code>f</code> on elements of <code>S</code>, but you have to provide a ring hom <code>R -&gt; S</code></li>\n<li><code>aeval</code> to evaluate <code>f</code> on elements of <code>A</code>, if there is an instance <code>[algebra R A]</code> available.</li>\n</ul>",
        "id": 221221720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609343429
    },
    {
        "content": "<p>(and some of this will assume various rings are commutative)</p>",
        "id": 221221818,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609343515
    },
    {
        "content": "<p>Thank you both!</p>\n<p>I personally prefer the initial version <code>nums_dens</code>.  However, it does not use the <code>localization</code> theory.  I would like to PR either one/both of these to mathlib: is there any preference?</p>",
        "id": 221221820,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609343517
    },
    {
        "content": "<p>probably both, because the proof of <code>nums_dens_2</code> is not a 1-liner.</p>",
        "id": 221222007,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609343664
    },
    {
        "content": "<p>You can also formulate <code>nums_dens</code> with <code>is_unit (i b)</code>.</p>",
        "id": 221222019,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343675
    },
    {
        "content": "<p>Which I suppose is closer to the localization api.</p>",
        "id": 221222046,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343700
    },
    {
        "content": "<p>(I meant, PR these with a full proof!  My preference would be to prove <code>nums_dens</code> and maybe or maybe not include also the proof above of <code>nums_dens_2</code>.  Since I do not have much experience with <code>localizations</code> in mathlib, I had worked with the initial version.  I do use the freedom of having a target field that is <em>larger</em> than the field of fractions.  In my intended application, the rings in question are ℤ and ℝ, rather than ℚ.)</p>",
        "id": 221222062,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609343712
    },
    {
        "content": "<p>That's another argument for <code>nums_dens</code>. It is a lot more flexible.</p>",
        "id": 221222159,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609343763
    },
    {
        "content": "<p>Ok, so I will PR the statement without <code>localizations</code> and merge it in some file.  Then, once this one is in, I will add the proof of <code>nums_dens_2</code> in the localization file.  Of course, the names will have to be better!</p>",
        "id": 221222174,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609343786
    },
    {
        "content": "<p>Don't we have something in mathlib which says \"This morphism of rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f : A \\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> factors through <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A \\to S^{-1}A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">A</span></span></span></span>.\"?</p>",
        "id": 221222201,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343819
    },
    {
        "content": "<p>I.e. <code>\\forall s, is_unit (f s)</code></p>",
        "id": 221222233,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343849
    },
    {
        "content": "<p>Hmm, maybe just PR only <code>nums_dens</code>. We'll see if <code>nums_dens_2</code> is useful in the end. Maybe if we refactor <code>localization</code> to make <code>localization_map</code> a predicate, then the proof of <code>nums_dens_2</code> will be a 1-liner.</p>",
        "id": 221222240,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609343854
    },
    {
        "content": "<p>If nobody gets to it before me, I hope to do this refactor 2nd half of Feb</p>",
        "id": 221222252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609343868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/221222201\">said</a>:</p>\n<blockquote>\n<p>Don't we have something in mathlib which says \"This morphism of rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f : A \\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> factors through <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A \\to S^{-1}A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">A</span></span></span></span>.\"?</p>\n</blockquote>\n<p>Probably <code>localization_map.lift</code> or something like that. I'm sure it's there.</p>",
        "id": 221222317,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609343907
    },
    {
        "content": "<p>Ok, I will do so!  As an idea, I like the <code>localization</code> idea, however, the possibility of working with a \"possibly larger than the localization\" target ring can be useful.</p>",
        "id": 221222326,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609343921
    },
    {
        "content": "<p>Yeah, I agree. That's why I suggested the <code>is_unit</code> thing, because I assumed the api for localization used it... I'm looking in mathlib now...</p>",
        "id": 221222364,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343965
    },
    {
        "content": "<p>(I still do not have a good application in mind for the <code>semiring</code> stuff, so, although it is true with these very limited hypotheses, it is not this that sells it to me!)</p>",
        "id": 221222373,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609343980
    },
    {
        "content": "<p>Right <a href=\"https://leanprover-community.github.io/mathlib_docs/find/localization_map.lift\">docs#localization_map.lift</a></p>",
        "id": 221222386,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609343994
    },
    {
        "content": "<p>So, I think if you can phrase your <code>nums_dens</code> using <code>is_unit</code>, it should be easy to relate it to localization via the universal property using <code>localization_map.lift</code>.</p>",
        "id": 221222479,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609344046
    },
    {
        "content": "<p>Just to emphasize what you have all been saying: I had no use for this in this context, however, I would also find it useful to have the freedom in <code>localization</code> to work with the localization of a quotient.  If I understand correctly, this is where the <code>localization_map.lift</code> comes in.</p>",
        "id": 221222959,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609344394
    },
    {
        "content": "<p>Well, what I'm saying is that the condition <code>is_unit (i b)</code> is equivalent to the assertion that the moprhism <code>i</code> factors through the localization at the element <code>b</code>. And the part of the localization api which lets you obtain the map from the localization at <code>b</code> is coming from <code>localization_map.lift</code>, where the assumption is <code>\\forall s, is_unit (i s)</code> (or something similar...).</p>",
        "id": 221223649,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609344761
    },
    {
        "content": "<p>So essentially, yes :)</p>",
        "id": 221223655,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609344768
    },
    {
        "content": "<p>Here's a skeleton :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.units</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.field_simp</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">semiring</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nums_dens</span>  <span class=\"c1\">-- this is the lemma that I can prove</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"n\">D</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">f.nat_degree</span> <span class=\"bp\">*</span> <span class=\"n\">eval₂</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">hb.unit.inv</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>  <span class=\"c1\">-- I have a full proof of this fact</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">semiring</span>\n</code></pre></div>",
        "id": 221223974,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609345071
    },
    {
        "content": "<p>Thanks!  I was trying to see how to extract the inverse from <code>is_unit</code>!</p>",
        "id": 221224096,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609345197
    },
    {
        "content": "<p>I am failing to make progress: how do I access the fact that <code>is_unit</code> implies that there is an inverse?  Below is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> that I am not able to solve.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.units</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">iub</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">iub.unit.inv</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">admit</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221226541,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609347377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/221221720\">said</a>:</p>\n<blockquote>\n<p>Right, there are 3 ways of evaluating polynomials. If you have <code>f : polynomial R</code>, then you can use</p>\n<ul>\n<li><code>eval</code> to evaluate <code>f</code> on elements of <code>R</code>,</li>\n<li><code>eval2</code> to evaluate <code>f</code> on elements of <code>S</code>, but you have to provide a ring hom <code>R -&gt; S</code></li>\n<li><code>aeval</code> to evaluate <code>f</code> on elements of <code>A</code>, if there is an instance <code>[algebra R A]</code> available.</li>\n</ul>\n</blockquote>\n<p>Is this in a module docstring somewhere? If not then it should be added.</p>",
        "id": 221226838,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1609347616
    },
    {
        "content": "<p>Are the three ways to do arbitrary unions, each with their own specific notation, documented somewhere?</p>",
        "id": 221229197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609348788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/221226541\">said</a>:</p>\n<blockquote>\n<p>I am failing to make progress: how do I access the fact that <code>is_unit</code> implies that there is an inverse?  Below is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> that I am not able to solve.</p>\n</blockquote>\n<p>Here's a proof (that can probably be golfed a bit):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.units</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n\n<span class=\"c1\">-- This should really be a simp lemma for `is_unit` itself...</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">iub</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">iub.unit.inv</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">iub.unit.inv_val</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">iub.unit</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">iub.unit_spec</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221239189,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609356312
    },
    {
        "content": "<p>Thank you very much!</p>",
        "id": 221239579,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609356586
    },
    {
        "content": "<p>It really looks like mathlib is missing some simp lemmas here...</p>",
        "id": 221239661,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609356611
    },
    {
        "content": "<p>This proof should have been <code>by simp</code>.</p>",
        "id": 221239672,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609356623
    },
    {
        "content": "<p>Yes, even with your solution, I am finding it very difficult to navigate with the <code>is_unit</code> command...</p>",
        "id": 221239921,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609356815
    },
    {
        "content": "<p>In fact, maybe this example should be a <code>simp</code> lemma</p>",
        "id": 221240010,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609356857
    },
    {
        "content": "<p>This is a bit better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.units</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n\n<span class=\"c1\">-- rename this...</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">unit_val_eq_coe</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">u.val</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- rename this too...</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_unit_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hx.unit.inv</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hx.unit.inv_val</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx.unit_spec</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">iub</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">iub.unit.inv</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 221240180,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609357008
    },
    {
        "content": "<p>I am off for the day, but will take a look at this soon!  I have PR <a href=\"https://github.com/leanprover-community/mathlib/issues/5529\">#5529</a> with a single lemma waiting to be approved, before I will make a PR with the stuff about denominators!</p>",
        "id": 221240667,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609357420
    },
    {
        "content": "<p>I left a review (-;</p>",
        "id": 221241060,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609357715
    },
    {
        "content": "<p>A golf of <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s second lemma,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_unit.inv_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hx.unit.inv</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">units.inv_mul_of_eq</span> <span class=\"n\">hx.unit_spec</span>\n</code></pre></div>\n<p>or possible more simp-normal,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_unit.inv_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">hx.unit</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">units.inv_mul_of_eq</span> <span class=\"n\">hx.unit_spec</span>\n</code></pre></div>\n<p>which parallels the theorem statement of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unit.inv_mul\">docs#unit.inv_mul</a></p>",
        "id": 221286776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609417497
    },
    {
        "content": "<p>I created PR <a href=\"https://github.com/leanprover-community/mathlib/issues/5587\">#5587</a> including the stuff about clearing denominators.  I still did not include the <code>is_unit</code> stuff, though.</p>",
        "id": 221443746,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1609668231
    }
]
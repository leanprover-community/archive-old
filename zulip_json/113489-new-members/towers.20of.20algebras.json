[
    {
        "content": "<p>I think I could need some guidance of how Lean automatically finds -- or doesn't -- some implicit arguments.<br>\nWith the following variables</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_closure</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>it is true that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra by combining the intermediate algebra maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant=\"normal\">Frac</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">A \\to \\operatorname{Frac}(A) \\to L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Frac</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> and I can certainly state this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_comp_of_algebras</span><span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">ring_hom.to_algebra</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But if I state other results, it doesn't automatically find the instance <code>algebra A L</code> (is 'instance' the correct terminology?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(says <code>failed to synthesize type class instance for algebra A L</code>)</p>\n<ul>\n<li>attempt 1: I thought the thing labelled as <code>def</code> could be labelled as <code>instance</code> to fix this, but I seem to be misunderstanding instances as this leads to timeout errors.</li>\n<li>attempt 2: Then I thought I would have to add <code>{algebra A L}</code> or <code>[algebra A L]</code> to the preamble. From the former I hoped it would create it automatically, which it didn't, the latter works, but I have the feeling it just adds another <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> instead of using the combined structure above, i.e. I can't show then that <code>algebra A L = my_comp_of_algebras</code>. <br>\n<code>example [algebra A L]: algebra (integral_closure A (fraction_ring A)) (integral_closure A L) := sorry</code></li>\n</ul>\n<p><em>Could somebody please give me a hint on what I didn't understand yet and how to do this? Thank you for the help!</em></p>\n<p>PS: Ultimately I am trying to get algebra maps (or just a linear map) <code>A → (integral_closure A (fraction_field A)) → (integral_closure A L)</code> and then split them (there's also more conditions, like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> being normal and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> being finite extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Frac</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Frac}(K)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Frac</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span>, but I thought they are irrelevant here).</p>",
        "id": 238449402,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620813779
    },
    {
        "content": "<p>Good questions! I have had similar struggles before, so let me take a look...</p>",
        "id": 238449696,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620813937
    },
    {
        "content": "<p>My guess would be that mathlib can infer <code>algebra (fraction_ring A) L</code> from <code>algebra A L</code>but not vice versa (assuming that's something that mathematically is possible)</p>",
        "id": 238449811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620813992
    },
    {
        "content": "<p>Typeclass inference is used to build structures on complex objects out of structures on simpler ones</p>",
        "id": 238449847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620814019
    },
    {
        "content": "<p>It's not allowed to go in both directions, as it can't handle loops</p>",
        "id": 238449877,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620814038
    },
    {
        "content": "<blockquote>\n<p>But if I state other results, it doesn't automatically find the instance algebra A L (is 'instance' the correct terminology?):</p>\n</blockquote>\n<p>(<code>instance</code> is indeed the correct word here!) You're getting a missing instance error here because the typeclass system is only aware of declarations marked as instance, as you correctly tried to fix by replacing <code>def</code> with <code>instance</code>.</p>",
        "id": 238450032,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620814119
    },
    {
        "content": "<p>However, an instance of the form <code>my_comp_of_algebras [algebra (fraction_ring A) L] : algebra A L</code> cannot work automatically. This is because type class inference performs its search as follows:</p>\n<ul>\n<li>need to find instance <code>algebra A L</code></li>\n<li>try to apply <code>my_comp_of_algebras</code><ul>\n<li>need to find instance <code>algebra (fraction_ring A) L</code></li>\n<li>try to apply <code>my_comp_of_algebras</code><ul>\n<li>need to find instance <code>algebra (fraction_ring (fraction_ring A)) L</code></li>\n<li>try to apply <code>my_comp_of_algebras</code><ul>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>",
        "id": 238450361,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620814306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238449811\">said</a>:</p>\n<blockquote>\n<p>My guess would be that mathlib can infer <code>algebra (fraction_ring A) L</code> from <code>algebra A L</code>but not vice versa (assuming that's something that mathematically is possible)</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238450361\">said</a>:</p>\n<blockquote>\n<p>However, an instance of the form <code>my_comp_of_algebras [algebra (fraction_ring A) L] : algebra A L</code> cannot work automatically. This is because type class inference performs its search as follows:</p>\n<ul>\n<li>need to find instance <code>algebra A L</code></li>\n<li>try to apply <code>my_comp_of_algebras</code><ul>\n<li>need to find instance <code>algebra (fraction_ring A) L</code></li>\n<li>try to apply <code>my_comp_of_algebras</code><ul>\n<li>need to find instance <code>algebra (fraction_ring (fraction_ring A)) L</code></li>\n<li>try to apply <code>my_comp_of_algebras</code><ul>\n<li>...<br>\nOh I see the looping problem involved here.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 238450783,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620814566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238449811\">said</a>:</p>\n<blockquote>\n<p>My guess would be that mathlib can infer <code>algebra (fraction_ring A) L</code> from <code>algebra A L</code>but not vice versa (assuming that's something that mathematically is possible)</p>\n</blockquote>\n<p>why is that?</p>",
        "id": 238450808,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620814584
    },
    {
        "content": "<p>Your solution is also on the right track: we can introduce a new <code>algebra</code> instance parameter, then try to show that this is indeed the correct one. I'm not completely sure whether this is always the case (would it follow from the universal property of <code>fraction_ring</code>?), but we can simply postulate that this holds:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_closure</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_comp_of_algebras</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">refine</span> <span class=\"n\">ring_hom.to_algebra</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_scalar_tower.algebra_map_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 238450821,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620814591
    },
    {
        "content": "<p>Eric, there's an algebra map from <code>A</code> to <code>fraction_ring A</code>, not the other way. So mathematically going from <code>algebra (fraction_ring A) L</code> to <code>algebra A L</code> is the correct direction</p>",
        "id": 238450951,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620814683
    },
    {
        "content": "<p>(Fixed the example, sorry. I should run my code before posting it! :P)</p>",
        "id": 238451074,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620814780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238450821\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I did use <code>is_scalar_tower</code> at some point before, but hesitated on using too many conditions that seem to follow automatic from a maths perspective. In that case I just throw in a couple of them, thank you!</p>",
        "id": 238451475,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620815020
    },
    {
        "content": "<p>Can I also ask you about integral closure <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> ? I found this <code>[integrally_closed: integral_closure A (fraction_ring A) = ⊥]</code> but I can't really use it. I don't have a MWE ready but essentially I want to say that I get a map <code>integral_closure A (fraction_ring A) →+* A</code> which is a bijection...</p>",
        "id": 238451696,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620815143
    },
    {
        "content": "<p>I agree with Anne's snippet, the way to set this up is indeed <code> [algebra A L] [algebra (fraction_ring A) L] [is_scalar_tower A (fraction_ring A) L]</code>, as lean already provides <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fraction_ring.algebra\">docs#fraction_ring.algebra</a></p>",
        "id": 238451859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815227
    },
    {
        "content": "<p>thanks!</p>",
        "id": 238451903,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620815262
    },
    {
        "content": "<p>I think you want something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.bot_equiv_of_injective\">docs#algebra.bot_equiv_of_injective</a></p>",
        "id": 238451915,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620815271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238451915\">said</a>:</p>\n<blockquote>\n<p>I think you want something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.bot_equiv_of_injective\">docs#algebra.bot_equiv_of_injective</a></p>\n</blockquote>\n<p>Looks like it, didn't see that before. Thanks for the help</p>",
        "id": 238452044,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620815339
    },
    {
        "content": "<p>I can't find anything that says that there's an equivalence between two equal subalgebras, which would give you your exact statement.</p>",
        "id": 238452076,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620815361
    },
    {
        "content": "<p>Let me see if I can build it easily...</p>",
        "id": 238452090,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620815373
    },
    {
        "content": "<p>If the subalgebras are equal then that's presumably just something like <code>h \\t alg_equiv.id</code>?</p>",
        "id": 238452132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815403
    },
    {
        "content": "<p><del>Do</del> we have that definition for other structures<del>?</del>: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.of_eq\">docs#linear_equiv.of_eq</a> <del>maybe</del> exists<del>?</del></p>",
        "id": 238452219,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815440
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Two subalgebras that are equal are also equivalent as algebras. -/</span>\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">linear_equiv.of_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">to_submodule</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 238452635,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620815678
    },
    {
        "content": "<p><code>h \\t alg_equiv.refl S</code> doesn't work (looks like because it's not smart enough to see that only one <code>S</code> should become a <code>T</code>)</p>",
        "id": 238452708,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620815712
    },
    {
        "content": "<p>What you have is better definitionally anyway</p>",
        "id": 238452758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815734
    },
    {
        "content": "<p>I'd recommend <code>simps apply</code> and a manual lemma though, to match <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.of_eq_symm\">docs#linear_equiv.of_eq_symm</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_eq_symm</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of_eq</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">=</span> <span class=\"n\">of_eq</span> <span class=\"n\">q</span> <span class=\"n\">p</span> <span class=\"n\">h.symm</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 238452854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815780
    },
    {
        "content": "<p>Hmm, should it be called <code>subalgebra.equiv_of_eq</code> or <code>alg_equiv.of_eq</code>?</p>",
        "id": 238452880,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620815804
    },
    {
        "content": "<p>(The latter might not work so well with <code>intermediate_field</code>)</p>",
        "id": 238452902,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620815820
    },
    {
        "content": "<p>The latter is consistent with linear_equiv.of_eq</p>",
        "id": 238453050,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815929
    },
    {
        "content": "<p>We already have duplicate names in this space; <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.set_congr\">docs#equiv.set_congr</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.set.of_eq\">docs#equiv.set.of_eq</a> are the same definition</p>",
        "id": 238453058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815942
    },
    {
        "content": "<p>I'll go with the former since there's not a lot of consensus, and maybe we want to make the same definition <code>intermediate_field</code> (where the appropriate equiv is still <code>alg_equiv</code>, which would cause name collisions).</p>",
        "id": 238453351,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620816141
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7590\">#7590</a></p>",
        "id": 238453510,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620816246
    },
    {
        "content": "<p>So that means I can just update mathlib in my project once that has been accepted and it'll be in there? That is amazing :D</p>",
        "id": 238453930,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620816513
    },
    {
        "content": "<p>If everything goes well and the PR gets accepted, yes :) If you are impatient, you should be able to copy-paste the definitions into your own project:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Two subalgebras that are equal are also equivalent as algebras.</span>\n<span class=\"sd\">This is the `subalgebra` version of `linear_equiv.of_eq` and `equiv.set.of_eq`. -/</span>\n<span class=\"kd\">@[simps apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">linear_equiv.of_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">to_submodule</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">equiv_of_eq_symm</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">equiv_of_eq</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">=</span> <span class=\"n\">equiv_of_eq</span> <span class=\"n\">T</span> <span class=\"n\">S</span> <span class=\"n\">h.symm</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 238454183,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620816701
    },
    {
        "content": "<p>Just to note that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra then even if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is a field it might not be an algebra for the field of fractions for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>37</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/37\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/37</span><span class=\"mord mathbb\">Z</span></span></span></span> is an algebra for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> but cannot be given the structure of an algebra for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>.</p>",
        "id": 238461897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620820935
    },
    {
        "content": "<p>is there any conditions that allow it to be such?</p>",
        "id": 238462257,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1620821127
    },
    {
        "content": "<p>Not 100% sure, but I suppose it's exactly when the algebra map from <code>A</code> to <code>L</code> maps every nonzero element of <code>A</code> to a unit in <code>L</code>, by the universal property of the localization.</p>",
        "id": 238462760,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620821383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238461897\">said</a>:</p>\n<blockquote>\n<p>Just to note that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra then even if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is a field it might not be an algebra for the field of fractions for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>37</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/37\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/37</span><span class=\"mord mathbb\">Z</span></span></span></span> is an algebra for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> but cannot be given the structure of an algebra for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>.</p>\n</blockquote>\n<p>Good point. I realised I don't actually need this map to be an algebra map/linear map, I only need to look at the composite of multiple maps.</p>",
        "id": 238463764,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620821947
    },
    {
        "content": "<p>Also, everything in my project is in equal characteristics (0,0), i.e. when you have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q} \\subset A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></p>",
        "id": 238464448,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620822310
    },
    {
        "content": "<p>that doesn't fix the maths problem, there are char 0 counterexamples, but this is not the point -- the answer to your question is this <code>is_scalar_tower</code> class. It's a bit of an adjustment coming from maths on paper to maths in Lean's type theory, you need to pick up a few basic tricks and this is one.</p>",
        "id": 238464665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620822406
    },
    {
        "content": "<p>But it helps realising that certain things are wrong (and you don't even need them), so thanks for the comment! It's so easy to get lost in the code and try to proof things that don't hold</p>",
        "id": 238464964,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620822562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238454183\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"bp\">...</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>After putting that in I am left with two small conversion problems, which I unfortunately don't think I can solve with my own understanding.</p>\n<p>I want to take an integral element in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo>:</mo><mo>=</mo><mi mathvariant=\"normal\">Frac</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K:=\\operatorname{Frac}(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Frac</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> and say that it is actually in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>. (we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> integrally closed.)</p>\n<p><em>(For context that would help me to manually define then a function <code>(integral_closure A L) →ₗ[A] A</code> and manually check the <code>map_add'</code> and <code>map_smul'</code> conditions.)</em></p>\n<p>Here are the steps I tried, the two I am stuck on are</p>\n<p>1) going from <code>is_integral A x</code> to <code>x:integral_closure A K</code> (where <code>x:K</code>) and <br>\n2) going from <code>z:↑⊥</code> to <code>z:A</code> (I think <code>↑⊥</code> is a <code>subalgebra A K</code>).</p>\n<p>Moreover, is there better syntax for working on this? I am just treating it as if it was a <code>Prop</code> statement, which works but I think some tactics like <code>library_search</code> or <code>hint</code> don't like constructions like this...</p>\n<p>Thank you once more for the help!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_closure</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">restrict_to_A</span>  <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">][</span><span class=\"n\">integrally_closed</span><span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">]:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- that should be a straight forward conversion I haven't found yet.</span>\n  <span class=\"n\">replace</span> <span class=\"n\">integrally_closed</span> <span class=\"o\">:=</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">⊥</span> <span class=\"n\">integrally_closed</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">integrally_closed.to_fun</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">y'</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- I expect a conversion from elements in `↑⊥: subalgebra A (fraction_field A)` to elements of `A`.</span>\n  <span class=\"n\">use</span> <span class=\"n\">y'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 238474997,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620826748
    },
    {
        "content": "<p>Does the following help?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">integral_closure.mk</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 238478485,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620828121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> I get an error on <code>equiv_of_eq</code> if I paste your code into VS Code.</p>",
        "id": 238479350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620828432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238479350\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"385895\">Jon Eugster</span> I get an error on <code>equiv_of_eq</code> if I paste your code into VS Code.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">linear_equiv.of_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">subalgebra.to_submodule</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>There's a <code>subalgebra.to_submodule</code> in the proof that needs to be adjusted from what Anne wrote</p>",
        "id": 238479639,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620828552
    },
    {
        "content": "<p>Can you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? Edit your original post</p>",
        "id": 238479754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620828603
    },
    {
        "content": "<p>This is what I have in my file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_closure</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simps apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">linear_equiv.of_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">subalgebra.to_submodule</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">equiv_of_eq_symm</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">equiv_of_eq</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">=</span> <span class=\"n\">equiv_of_eq</span> <span class=\"n\">T</span> <span class=\"n\">S</span> <span class=\"n\">h.symm</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">restrict_to_A</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">][</span><span class=\"n\">integrally_closed</span><span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">]:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- that should be a straight forward conversion I haven't found yet.</span>\n  <span class=\"n\">replace</span> <span class=\"n\">integrally_closed</span> <span class=\"o\">:=</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">⊥</span> <span class=\"n\">integrally_closed</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">integrally_closed.to_fun</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">y'</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- I expect a conversion from elements in `↑⊥: subalgebra A (fraction_field A)` to elements of `A`.</span>\n  <span class=\"n\">use</span> <span class=\"n\">y'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 238479895,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620828643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238478485\">said</a>:</p>\n<blockquote>\n<p>Does the following help?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">integral_closure.mk</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes, that seems to be the first <code>sorry</code>,  thank you! The <code>⟨  ⟩</code> is still very mysterious to me</p>",
        "id": 238480621,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620828934
    },
    {
        "content": "<p>If you want to understand <code>⟨  ⟩</code>, replace it with <code>{! !}</code>, click the lightbulb in vscode and \"generate structure under consideration\" or similar</p>",
        "id": 238480847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620829031
    },
    {
        "content": "<p>In your case it will expand to <code>{ val := _, property := _ }</code>.  So on this line, <code>⟨x, hx⟩</code> is just short for <code>{ val := x, property := hx }</code></p>",
        "id": 238480967,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620829081
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238480847\">said</a>:</p>\n<blockquote>\n<p>If you want to understand <code>⟨  ⟩</code>, replace it with <code>{! !}</code>, click the lightbulb in vscode and \"generate structure under consideration\" or similar</p>\n</blockquote>\n<p>oh that's neat!</p>",
        "id": 238481100,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620829118
    },
    {
        "content": "<p>Another way to think of <code>⟨  ⟩</code> is as it being like a term-mode version of the <code>split</code> or <code>constructor</code> tactic</p>",
        "id": 238481208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620829166
    },
    {
        "content": "<p>Updated MWE on what's still left from my original question.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_closure</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- I expect a conversion from elements in `↑⊥: subalgebra A (fraction_field A)` to elements of `A`.</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_mk</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"o\">:</span><span class=\"n\">subalgebra</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))]:</span>\n  <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 238485217,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620830521
    },
    {
        "content": "<p>A comment: <code>[my hypothesis]</code> should be really used only for things that the typeclass search can use, like <code>[group G]</code> <code>[field K]</code> <code>[algebra A L]</code></p>",
        "id": 238485628,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620830645
    },
    {
        "content": "<p>so <code>(...)</code> for everything else?</p>",
        "id": 238485765,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620830690
    },
    {
        "content": "<p>And a <code>≃ₐ[A]</code> is not actually a lemma, it is a <code>def</code>, it is a bundled combination of a function and its reverse and all of the proofs saying that it is an equivalence of algebras</p>",
        "id": 238485796,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620830700
    },
    {
        "content": "<p>I think somehow <code>subalgebra.bot_equiv</code> should help here</p>",
        "id": 238486677,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620830968
    },
    {
        "content": "<p>Using <code>alg_equiv.trans</code>. Basically, you compose several \"canonical isomorphisms\"</p>",
        "id": 238486740,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620830997
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> I think I managed to use the two statements you mentioned to get the desired result!</p>",
        "id": 238488707,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620831710
    },
    {
        "content": "<p>Can you share?</p>",
        "id": 238488732,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620831723
    },
    {
        "content": "<p>yep, give me a second to clean it up</p>",
        "id": 238490292,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620832239
    },
    {
        "content": "<p>Still a big mess, but here's roughly how all the help can be combined to get that an integral element in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Frac</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Frac}(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Frac</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> actually<br>\nlies in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_closure</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.subalgebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">integrally_closed</span><span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Anne PRed this into mathlib, can be removed later.</span>\n<span class=\"kd\">@[simps apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_of_eq</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">x.2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">linear_equiv.of_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">subalgebra.to_submodule</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n\n<span class=\"c1\">-- Thx Yakov Perchersky</span>\n<span class=\"kd\">def</span> <span class=\"n\">integral_closure.mk</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"c1\">--- {!   !} is useful!</span>\n\n\n<span class=\"c1\">-- assuming `A` is integrally closed in it's fraction field, this</span>\n<span class=\"c1\">-- is the corresponding equivalence of algebras</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">canoncial_equiv</span>\n<span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))):</span>\n<span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">alg_equiv.trans</span> <span class=\"o\">(</span><span class=\"n\">equiv_of_eq</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">⊥</span> <span class=\"n\">integrally_closed</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">algebra.bot_equiv_of_injective</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- This is how we can get an element in `A` from an integral element in `fraction_ring A`.</span>\n<span class=\"c1\">-- Injectivity should be deducable from something, `A: integral_domain`?</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">restriction_to_A</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">integrally_closed</span><span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">integral_closure.mk</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">canoncial_equiv</span> <span class=\"n\">integrally_closed</span> <span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 238492410,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620833030
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Thx Yakov Pechersky -- (only 1 `r`)</span>\n<span class=\"kd\">def</span> <span class=\"n\">integral_closure.mk</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"c1\">--- {!   !} is useful!</span>\n\n\n<span class=\"c1\">-- assuming `A` is integrally closed in it's fraction field, this</span>\n<span class=\"c1\">-- is the corresponding equivalence of algebras</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">canonical_equiv</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))):</span>\n  <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">equiv_of_eq</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">⊥</span> <span class=\"n\">integrally_closed</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n  <span class=\"o\">(</span><span class=\"n\">algebra.bot_equiv_of_injective</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- This is how we can get an element in `A` from an integral element in `fraction_ring A`.</span>\n<span class=\"c1\">-- Injectivity should be deducable from something, `A : integral_domain`?</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">restriction_to_A</span> <span class=\"o\">(</span><span class=\"n\">integrally_closed</span> <span class=\"o\">:</span> <span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">canonical_equiv</span> <span class=\"n\">integrally_closed</span> <span class=\"n\">h'</span> <span class=\"o\">(</span><span class=\"n\">integral_closure.mk</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 238494043,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620833576
    },
    {
        "content": "<p>Try not to define <code>def</code> using tactic <code>begin ... end</code> mode</p>",
        "id": 238494155,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620833606
    },
    {
        "content": "<p>(to first pass)</p>",
        "id": 238494164,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620833611
    },
    {
        "content": "<p>We can use <code>canonical_equiv</code> or any <code>≃ₐ[A]</code> (or any <code>≃</code>) as a function, no need to use <code>to_fun</code></p>",
        "id": 238494229,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620833639
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  What's wrong about this example?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span>\n<span class=\"kd\">end</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch at application</span>\n<span class=\"cm\">  (algebra_map ?m_6 ?m_7).injective</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  algebra_map ?m_1 ?m_2</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  @ring_hom ?m_1 ?m_2 (@comm_semiring.to_semiring ?m_1 ?m_3) ?m_4 : Type (max ? ?)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  @ring_hom ?m_1 ?m_2 (@ring.to_semiring ?m_1 (@division_ring.to_ring ?m_1 ?m_3)) ?m_4 : Type (max ? ?)</span>\n<span class=\"cm\">Additional information:</span>\n<span class=\"cm\">/home/yakov/code/mathlib/src/test.lean: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</span>\n<span class=\"cm\">  type mismatch at application</span>\n<span class=\"cm\">    (algebra_map ?m_6 ?m_7).injective</span>\n<span class=\"cm\">  term</span>\n<span class=\"cm\">    algebra_map ?m_1 ?m_2</span>\n<span class=\"cm\">  has type</span>\n<span class=\"cm\">    @ring_hom ?m_1 ?m_2 (@comm_semiring.to_semiring ?m_1 ?m_3) ?m_4 : Type (max ? ?)</span>\n<span class=\"cm\">  but is expected to have type</span>\n<span class=\"cm\">    @ring_hom ?m_1 ?m_2 (@ring.to_semiring ?m_1 (@division_ring.to_ring ?m_1 ?m_3)) ?m_4 : Type (max ? ?)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 238495029,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620833880
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_hom.injective\">docs#ring_hom.injective</a> needs the algebra to be over a <del>field</del> <code>division_ring</code>, not just an <code>integral_domain</code></p>",
        "id": 238495146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620833912
    },
    {
        "content": "<p>There should be some lemma that for an integral domain the map into the field of fractions is injective</p>",
        "id": 238496760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620834407
    },
    {
        "content": "<p>Perhaps, but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fraction_ring.algebra\">docs#fraction_ring.algebra</a> is the very last line in the file, so either mathlib doesn't have it, it's in a downstream file somewhere, or it's true more generally and we're looking for the wrong thing</p>",
        "id": 238497457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620834590
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fraction_map.injective\">docs#fraction_map.injective</a></p>",
        "id": 238497480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620834597
    },
    {
        "content": "<p>Look's to me like we're missing the rfl-lemma that <code>algebra_map A (fraction_ring A) = (fraction_map.of A).to_map</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">algebra_map_eq</span> <span class=\"o\">:</span> <span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.of</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_map</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>as then we would have found the <code>injective</code> lemma with library_search</p>",
        "id": 238497723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620834675
    },
    {
        "content": "<p>But indeed that lemma closes the goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">fraction_map.injective</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 238497956,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620834760
    },
    {
        "content": "<p>Great!<br>\nThen you have just this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">canonical_equiv</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">equiv_of_eq</span> <span class=\"o\">(</span><span class=\"n\">integral_closure</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">⊥</span> <span class=\"n\">integrally_closed</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n  <span class=\"o\">(</span><span class=\"n\">algebra.bot_equiv_of_injective</span> <span class=\"o\">(</span><span class=\"n\">fraction_map.injective</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 238498302,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620834879
    },
    {
        "content": "<p>But <span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span>, why do you need to construct an <code>A</code> from something that you know only separately is of type <code>fraction_map A</code> and  holds <code>is_integral A</code>?</p>",
        "id": 238498615,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620834989
    },
    {
        "content": "<p>Instead of working on such elements, perhaps you just need the right composition of functions/isos</p>",
        "id": 238498679,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1620835015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238498679\">said</a>:</p>\n<blockquote>\n<p>Instead of working on such elements, perhaps you just need the right composition of functions/isos</p>\n</blockquote>\n<p>Thanks for work above, I'll go through it tomorrow. Maybe I should explain more of the context. I thought I give it a shot and see how far I'd get formalising the direct summand conjecture; in equal characteristics (0,0) to start with. The proof reads like this<br>\n<a href=\"/user_uploads/3121/nDvIH1gKfHiEnck9WXzeK_we/dsc.png\">dsc.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/nDvIH1gKfHiEnck9WXzeK_we/dsc.png\" title=\"dsc.png\"><img src=\"/user_uploads/3121/nDvIH1gKfHiEnck9WXzeK_we/dsc.png\"></a></div><p>I did manage to construct the trace as map <code>L →ₗ[K] K</code> and show that it splits <code>algebra_map K L</code>, so know I would like to adapt this to a map <code>(integral_closure A L) →ₗ[A] A</code>. I guess there should be a way to combine this from different maps but the problem I encountered is that although you have a combination of maps <code>(integral_closure A L) → L → K</code> and <code>(integral_closure A K) → A</code> you don't have a map <code>K→(integral_closure A K)</code>, but the composition of everything exists and is a linear map. So I thought as last resource I would give it a go and define this composition explicitly by constructing an element in <code>A</code>.</p>\n<p>Another challenge is then the \"we can enlarge $B$ to be the integral closure ...\" but I haven't started on that yet.</p>\n<p>So if you have any tips/tricks or opinions I am very happy to listen and learn :)</p>",
        "id": 238548956,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620855662
    },
    {
        "content": "<p>This is a great way of learning Lean! There are plenty of people here who know enough to be able to help you out.</p>\n<p>The best way to ask a question here is to post fully working lean code including all imports etc and a sorry, and ask how to fill it in. You'll get stuck many times initially, but it will all begin to make sense later on as you learn the tricks.</p>",
        "id": 238551227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620856931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238494155\">said</a>:</p>\n<blockquote>\n<p>Try not to define <code>def</code> using tactic <code>begin ... end</code> mode</p>\n</blockquote>\n<p>So far I used <code>begin ... end</code> because it seems more iterative, i.e. you can create stuff step-by-step with <code>have</code>, and then once your done, you can rewrite it as a direct term without tactic mode, is there a better approach to do such constructions?</p>",
        "id": 238612593,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1620907631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> You can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">some_type</span> <span class=\"o\">:=</span>\n<span class=\"n\">partial</span> <span class=\"n\">_</span> <span class=\"n\">construction</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">my</span> <span class=\"n\">_</span> <span class=\"kd\">definition</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and if you put your cursor on one of the <code>_</code>, then the goal window will show you the remaining goal.</p>",
        "id": 238613091,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620907925
    },
    {
        "content": "<p>Often it's still easier to use tactic mode first as Jon describes though, especially since sometimes it saves you from elaborator quirks</p>",
        "id": 238672753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620936179
    }
]
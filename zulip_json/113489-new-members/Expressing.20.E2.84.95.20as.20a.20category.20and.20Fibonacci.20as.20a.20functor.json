[
    {
        "content": "<p>A <a href=\"https://www.math3ma.com/blog/fibonacci-sequence\">blog post by Tai-Danae Bradley</a> shows that ‚Ñï is a complete category where</p>\n<ul>\n<li>The objects are non-negative integers</li>\n<li>The morphism is divisibility</li>\n</ul>\n<p>and the Fibonacci sequence <code>F(n)</code> where is exactly <code>nat.fib</code> and roughly (but this doesn't quite work):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">F</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is a functor given <code>nat.gcd(F n) ( F m) = F (nat.gcd n m)</code>.</p>\n<p>Using the <code>category</code> structure of <code>mathlib</code>, how do I prove <code>‚Ñï</code> is a category under <code>nat.gcd</code>?</p>\n<p>I don't quite understand all I need to prove because the definition of <code>category</code> uses some complicated language <code>extends category_struct.{v} obj </code>.  With the inclusion of the tactic <code>. obviously</code>, the <code>category</code> fields should prove themselves for the most part:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">extends</span> <span class=\"n\">category_struct.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">id_comp'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"mi\">ùüô</span> <span class=\"n\">X</span> <span class=\"bp\">‚â´</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comp_id'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"mi\">ùüô</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">assoc'</span>   <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">W</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">‚â´</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Having proven <code>‚Ñï</code> is a category under divisibility, how do I show that <code>nat.fib</code> is a functor?</p>\n<p>This is as far as I could get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.category.default</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.fib</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">instance</span>  <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n<span class=\"c1\">-- something with nat.gcd</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">functor</span>\n<span class=\"c1\">-- something with nat.fib</span>\n</code></pre></div>\n<p>Also, what in <code>mathlib</code> marks that a category is a complete category?  <code>complete_space</code>?  <code>is_complete</code>?</p>",
        "id": 220198334,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608169558
    },
    {
        "content": "<p>Here's a start to setting this up</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.fib</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.functor</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">def</span> <span class=\"n\">mynat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_nat</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_dvd</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">dvd</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">to_nat</span> <span class=\"n\">a</span> <span class=\"bp\">‚à£</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">‚à£</span><span class=\"o\">),</span>\n<span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">dvd_refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">dvd_trans</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_dvd_fib</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m.fib</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n.fib</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚•§</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">nat.fib</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hom_of_le</span> <span class=\"o\">(</span><span class=\"n\">fib_dvd_fib</span> <span class=\"o\">(</span><span class=\"n\">le_of_hom</span> <span class=\"n\">h</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 220200511,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608171878
    },
    {
        "content": "<p>We make mynat a type alias for nat so that we can put the divisibility order on it</p>",
        "id": 220200640,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608172004
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/preorder.small_category\">docs#preorder.small_category</a> automatically makes this a category then, so that the functor notation <code>‚•§</code> works</p>",
        "id": 220200657,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608172038
    },
    {
        "content": "<p>I don't think we have the key lemma about divisibility of fibonaccis yet?</p>",
        "id": 220200678,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608172081
    },
    {
        "content": "<p>Thanks for the sketch <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> .</p>\n<p>Tai-Danae Bradley  expressed the \"functorial-ness\" of <code>nat.fib</code> in terms of <code>nat.gcd(nat.fib n) ( nat.fib  m) = nat.fib  (nat.gcd n m)</code>.   How is this represented in the sketch, and how is <code>nat.gcd</code> as the greatest lower bound operator of the ‚Ñï lattice represented in your sketch?</p>\n<p>Another question, the definition of <code>nat.fib</code> says \"We use a stream iterator for better performance when compared to the naive recursive implementation.\"  The documentation for <code>stream</code> is terse.  Is there a writeup somewhere for the use of stream iterators?</p>",
        "id": 220237807,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608208799
    },
    {
        "content": "<p>It's not, this was just the first step, setting up N with divisibility as a category and showing that fib defines a functor.</p>",
        "id": 220238033,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608208940
    },
    {
        "content": "<p>If you want to formalise the rest you would be showing that this category has (co)products (this would be lcm / gcd) and that the fib functor preserves limits</p>",
        "id": 220238217,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608209071
    },
    {
        "content": "<p>As for streams, I believe they're the same as the stream concept in haskell <a href=\"https://hackage.haskell.org/package/Stream-0.4.7.2/docs/Data-Stream.html\">https://hackage.haskell.org/package/Stream-0.4.7.2/docs/Data-Stream.html</a></p>",
        "id": 220238483,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608209260
    },
    {
        "content": "<p>How do you say that <code>mynat</code> is an instance of <code>category</code> and that it is a complete category?</p>",
        "id": 220248676,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608214971
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>\n<p>for the first, lean is doing this behind the scenes when you use the functor notation, that won't work unless lean \"knows\" that mynat is a category</p>",
        "id": 220249077,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608215166
    },
    {
        "content": "<p>So adding that line to the file is only needed for you to check as a user that lean knows how to find the category instance.</p>",
        "id": 220249135,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608215197
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_limits\">docs#category_theory.limits.has_limits</a> is what mathlib calls a complete category I believe</p>",
        "id": 220249511,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608215405
    },
    {
        "content": "<p>To actually make an instance of this class probably requires some work</p>",
        "id": 220249655,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608215484
    },
    {
        "content": "<p>You can see several examples by searching for <code>instance has_limits</code> in mathlib</p>",
        "id": 220250035,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608215649
    },
    {
        "content": "<p>Actually maybe I'm wrong and this is already there, if you import <code>category_theory.limits.lattice</code>  then proving an instance of <code>complete_lattice mynat</code>  will give you the <code>has_limits mynat</code>  instance for free</p>",
        "id": 220250660,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608215979
    },
    {
        "content": "<p>ok but maybe mynat isn't a complete lattice? so the best you can do is make an instance of <code>semilattice_inf_top mynat</code>  and get <code>has_finite_limits mynat</code> from that, or maybe the dual lol</p>",
        "id": 220251036,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608216159
    },
    {
        "content": "<p>Ok I guess it is a complete lattice after all but I'm not sure the best way to prove that, you need to define <code>has_Inf mynat</code> which should be the gcd of a (possibly infinite) set, the way I would do this by hand is just to say a set of naturals is a set of integers which generates some ideal, which is principal so take the positive generator to be the Inf of your set, no idea what the easiest way to do this in lean is.</p>",
        "id": 220254316,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608217736
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.fib</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.limits</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.lattice</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">def</span> <span class=\"n\">mynat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_nat</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_dvd</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">dvd</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">to_nat</span> <span class=\"n\">a</span> <span class=\"bp\">‚à£</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_inf_top</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">‚à£</span><span class=\"o\">),</span>\n<span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">dvd_refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">dvd_trans</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"n\">top</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span>\n<span class=\"n\">inf</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">,</span> <span class=\"n\">nat.gcd</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">nat.dvd_antisymm</span><span class=\"o\">,</span>\n<span class=\"n\">inf_le_left</span> <span class=\"o\">:=</span> <span class=\"n\">nat.gcd_dvd_left</span><span class=\"o\">,</span>\n<span class=\"n\">inf_le_right</span> <span class=\"o\">:=</span> <span class=\"n\">nat.gcd_dvd_right</span><span class=\"o\">,</span>\n<span class=\"n\">le_top</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©,</span>\n<span class=\"n\">le_inf</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">nat.dvd_gcd</span><span class=\"o\">,</span>\n <span class=\"o\">}</span>\n\n<span class=\"c1\">-- instance : complete_lattice mynat :=  complete_lattice_of_Inf mynat</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_dvd_fib</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m.fib</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n.fib</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚•§</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">nat.fib</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hom_of_le</span> <span class=\"o\">(</span><span class=\"n\">fib_dvd_fib</span> <span class=\"o\">(</span><span class=\"n\">le_of_hom</span> <span class=\"n\">h</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">limits.has_finite_limits</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>\n<p>uses the category machinery to show finite limits at least</p>",
        "id": 220254380,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608217777
    },
    {
        "content": "<p>Is there a <code>complete_lattice_of_Sup</code>?</p>",
        "id": 220254841,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608217982
    },
    {
        "content": "<p>Yes, Sup seemed harder to define to me than Inf though?</p>",
        "id": 220254910,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608218019
    },
    {
        "content": "<p>Isn't it <code>finset.lcm</code> for finite input and <code>0</code> otherwise?</p>",
        "id": 220255006,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608218046
    },
    {
        "content": "<p>Ah yes it is</p>",
        "id": 220255092,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608218090
    },
    {
        "content": "<p>Ok well I think these are the right definitions at least then, just a sorry to fill <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.fib</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.limits</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.gcd</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">def</span> <span class=\"n\">mynat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_nat</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_dvd</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">dvd</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">to_nat</span> <span class=\"n\">a</span> <span class=\"bp\">‚à£</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n<span class=\"c1\">-- instance : semilattice_inf_top mynat :=</span>\n<span class=\"c1\">-- { le := (‚à£),</span>\n<span class=\"c1\">-- le_refl := Œª a, dvd_refl a,</span>\n<span class=\"c1\">-- le_trans := Œª a b c h g, dvd_trans h g,</span>\n<span class=\"c1\">-- top := (0 : ‚Ñï),</span>\n<span class=\"c1\">-- inf := Œª a b , nat.gcd a b,</span>\n<span class=\"c1\">-- le_antisymm := Œª a b, nat.dvd_antisymm,</span>\n<span class=\"c1\">-- inf_le_left := nat.gcd_dvd_left,</span>\n<span class=\"c1\">-- inf_le_right := nat.gcd_dvd_right,</span>\n<span class=\"c1\">-- le_top := Œª a, ‚ü®0, rfl‚ü©,</span>\n<span class=\"c1\">-- le_inf := Œª a b c, nat.dvd_gcd,</span>\n<span class=\"c1\">--  }</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">‚à£</span><span class=\"o\">),</span>\n<span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">dvd_refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">dvd_trans</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span>\n<span class=\"n\">sup</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">,</span> <span class=\"n\">nat.lcm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">nat.dvd_antisymm</span><span class=\"o\">,</span>\n<span class=\"n\">le_sup_left</span> <span class=\"o\">:=</span> <span class=\"n\">nat.dvd_lcm_left</span><span class=\"o\">,</span>\n<span class=\"n\">le_sup_right</span> <span class=\"o\">:=</span> <span class=\"n\">nat.dvd_lcm_right</span><span class=\"o\">,</span>\n<span class=\"n\">bot_le</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">‚ü©,</span>\n<span class=\"n\">sup_le</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">nat.lcm_dvd</span><span class=\"o\">,</span>\n <span class=\"o\">}</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span> <span class=\"k\">then</span> <span class=\"n\">finset.sup</span> <span class=\"o\">(</span><span class=\"n\">set.finite.to_finset</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">id</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)‚ü©</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"n\">complete_lattice_of_Sup</span> <span class=\"n\">mynat</span>  <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_dvd_fib</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m.fib</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n.fib</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚•§</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">nat.fib</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hom_of_le</span> <span class=\"o\">(</span><span class=\"n\">fib_dvd_fib</span> <span class=\"o\">(</span><span class=\"n\">le_of_hom</span> <span class=\"n\">h</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">limits.has_finite_limits</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 220257016,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608218876
    },
    {
        "content": "<p>Am I right in thinking that<code>instance : semilattice_inf_top mynat</code> could be PR'd as <code>def dvd.semilattice_inf_top</code>?</p>",
        "id": 220259558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608219863
    },
    {
        "content": "<p>Seems like a nice way to group together all the structure, even if it's not desirable to register it as an instance</p>",
        "id": 220259589,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608219882
    },
    {
        "content": "<p>Yes I think so? Or the complete lattice version if someone fills in the proof <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>.<br>\nMaybe <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> has some ideas on whats a good way to set this all up though? Taking the naturals as a partial order w.r.t. divisibility is quite close to some of the moebius function machinery Aaron has developed.</p>",
        "id": 220265616,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608222302
    },
    {
        "content": "<p>If only the order were total -- then it would be an answer to <a href=\"#narrow/stream/116395-maths/topic/There.20are.20no.20.60canonically_linear_ordered_monoid.60s/near/220239296\">this</a></p>",
        "id": 220265969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608222440
    },
    {
        "content": "<p>There is already a partial order representing divisibility of naturals in mathlib - it‚Äôs <code>associates nat</code></p>",
        "id": 220270037,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1608224262
    },
    {
        "content": "<p>I haven‚Äôt explicitly defined an equivalence between N and that, but the ingredients are there (the assumption you want is <code>[unique (units N)]</code>)</p>",
        "id": 220270272,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1608224347
    },
    {
        "content": "<p>For any <code>comm_monoid</code>, there should be a <code>&lt;=</code> on <code>associates</code> which is defeq to <code>|</code>, and with possibly a few assumptions, it's a <code>partial_order</code>.</p>",
        "id": 220270865,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1608224605
    },
    {
        "content": "<p>Unfortunately, the lattice instances on it are defined only for <code>unique_factorization_monoid</code>, and not for <code>gcd_monoid</code>, and I've found that hard to generalize without screwing up the flow of the <code>unique_factorization_monoid</code> file, but that's ok for this, because we have <code>unique_factorization_monoid N</code>.</p>",
        "id": 220271120,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1608224725
    },
    {
        "content": "<p>We do not however have a <code>complete_lattice</code> instance.</p>",
        "id": 220271385,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1608224854
    },
    {
        "content": "<p>Some definitions I've been vaguely thinking about defining for a while is a <code>locally_finite_partial_order_with_top</code>, which would apply to the partial order of the <code>associates</code> of a <code>unique_factorization_monoid</code>,  and allow us to use your <code>complete_lattice</code> definition.</p>",
        "id": 220271985,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1608225126
    },
    {
        "content": "<p>Aah -- on a DVR the <code>&lt;=</code> on <code>associates will be totally ordered: does </code>associates<code> have </code>mul`?</p>",
        "id": 220272444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608225332
    },
    {
        "content": "<p>Oh it does! There's my example!</p>",
        "id": 220272573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608225389
    },
    {
        "content": "<p>Nice benchmark problem!  Thanks for thinking about it.</p>",
        "id": 220295786,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608236025
    },
    {
        "content": "<p>It's a nice cold Saturday morning.  I'm looking at this again.  The above sketch from <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> creates an alias of ‚Ñï, <code>mynat</code>.  However I noticed that a lot of pieces are there already in ‚Ñï in particular</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">nat.has_dvd</span>\n<span class=\"k\">#check</span> <span class=\"n\">nat.semilattice_sup_bot</span>\n</code></pre></div>\n<p>What's missing is <code>|</code> as a relation with the same status as <code>‚â§</code>, with corresponding <code>hom_of_dvd</code> and <code>dvd_of_hom</code> in <code>category</code>.  I tried to redo the sketch purely in ‚Ñï, but it fails at definitions of <code>hom_of_dvd</code> and <code>dvd_of_hom</code> and hence thereafter in this revised sketch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.limits</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.fib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span> <span class=\"k\">then</span> <span class=\"n\">finset.sup</span> <span class=\"o\">(</span><span class=\"n\">set.finite.to_finset</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">id</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)‚ü©</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span> <span class=\"n\">complete_lattice_of_Sup</span> <span class=\"n\">‚Ñï</span>  <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">category_theory.hom_of_dvd</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"bp\">|</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚ü∂</span>  <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">ulift.up</span> <span class=\"o\">(</span><span class=\"n\">plift.up</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"c1\">-- ERROR</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">category_theory.dvd_of_hom</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"bp\">|</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h.down.down</span> <span class=\"c1\">-- ERROR</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nat.fib_as_functor</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚•§</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">nat.fib</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hom_of_dvd</span> <span class=\"o\">(</span><span class=\"n\">nat.fib_dvd_fib</span> <span class=\"o\">(</span><span class=\"n\">dvd_of_hom</span> <span class=\"n\">h</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.fib_dvd_fib</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">}</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m.fib_as_functor</span> <span class=\"bp\">|</span> <span class=\"n\">n.fib_as_functor</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">limits.has_finite_limits</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>\n<p>If it's possible to make this work (with <code>sorry</code> in proofs is OK, just the types and ability to extend ‚Ñï directly without making a <code>mynat</code>), that would be interesting.</p>",
        "id": 220476883,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608395404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> it looks like you are trying to put two different order structures on the same type. Lean will not like that.</p>",
        "id": 220477074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608395651
    },
    {
        "content": "<p>OK I'll stick with the <code>mynat</code> version, thanks.</p>",
        "id": 220477192,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608395850
    },
    {
        "content": "<p>Lean and typeclass inference should be able to deduce the category structure on the naturals obtained by divisibility using <code>associates nat</code> as Aaron hinted to above.</p>",
        "id": 220478277,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608397338
    },
    {
        "content": "<p>There are a number of assertions made in  <a href=\"https://www.math3ma.com/blog/fibonacci-sequence\">Fibonacci Sequence as a Functor</a>. I'm using <code>x_y</code> for things defined in <code>mathlib</code> and <strong>x y</strong> for things that I don't know are defined in <code>mathlib</code>:</p>\n<ul>\n<li><code>‚Ñï</code> has a <code>partial_order</code> under divisibility<ul>\n<li>Hence <code>‚Ñï</code> is a <code>category</code></li>\n<li><code>‚Ñï</code> is also a <strong>complete category</strong></li>\n</ul>\n</li>\n<li><code>‚Ñï</code> has a <strong>meet</strong> defined as <code>n ‚äì m = nat.gcd n m</code> <ul>\n<li>Hence <code>‚Ñï</code> has a <strong>categorical limit</strong></li>\n</ul>\n</li>\n<li><code>nat.fib</code> <strong>preserves meets</strong>, where we define  \"preserve meets\" by  <code>(nat.fib n)‚äì (nat.fib m) = nat.fib (n ‚äì m)</code><ul>\n<li>Hence <code>‚Ñï</code> is a <strong>meet semilattice</strong></li>\n<li>Hence <code>nat.fib</code> is a <strong>meet semilattice homomorphism</strong></li>\n<li>Hence <code>nat.fib</code> is a <strong>functor</strong> because <code>nat.gcd(nat.fib n, nat.fib m) = nat.fib(nat.gcd n m)</code></li>\n<li>Hence <code>nat.fib</code> is a <strong> continuous functor</strong>, because it preserves limits</li>\n</ul>\n</li>\n<li><code>nat.gcd n m</code> is <br>\n    * The <strong>categorical product</strong>  of  <code>n</code> and <code>m</code><br>\n    * The <strong>pullback</strong> of <code>n</code> and <code>m</code><br>\n    * The <strong>inverse limit</strong> of <code>n</code> and <code>m</code><br>\n    * The <strong>equalizer</strong> of <code>n</code> and <code>m</code></li>\n</ul>\n<p>I would like to annotate the <code>mynat</code> proof sketch above with all of these assertions and be able to point out in Lean how each of the concepts is expressed.  My placement of assertions next to related proofs is very approximate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.limits</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.fib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"c1\">-- nat.gcd n m is the categorical product of n and m</span>\n<span class=\"c1\">-- nat.gcd n m is the pullback of n and m</span>\n<span class=\"c1\">-- nat.gcd n m is the inverse limit of n and m</span>\n<span class=\"c1\">-- nat.gcd n m is the equalizer of n and m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mynat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_nat</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_dvd</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">dvd</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">to_nat</span> <span class=\"n\">a</span> <span class=\"bp\">‚à£</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_sup_bot</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">‚à£</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">dvd_refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">dvd_trans</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span>\n  <span class=\"n\">sup</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">,</span> <span class=\"n\">nat.lcm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">nat.dvd_antisymm</span><span class=\"o\">,</span>\n  <span class=\"n\">le_sup_left</span> <span class=\"o\">:=</span> <span class=\"n\">nat.dvd_lcm_left</span><span class=\"o\">,</span>\n  <span class=\"n\">le_sup_right</span> <span class=\"o\">:=</span> <span class=\"n\">nat.dvd_lcm_right</span><span class=\"o\">,</span>\n  <span class=\"n\">bot_le</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">sup_le</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">nat.lcm_dvd</span><span class=\"o\">,</span>\n <span class=\"o\">}</span>\n\n<span class=\"c1\">-- ‚Ñï has a partial_order under divisibility</span>\n<span class=\"c1\">-- ‚Ñï has a meet defined as n ‚äì m = nat.gcd n m</span>\n<span class=\"c1\">-- ‚Ñï is a meet semilattice</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span> <span class=\"k\">then</span> <span class=\"n\">finset.sup</span> <span class=\"o\">(</span><span class=\"n\">set.finite.to_finset</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">id</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)‚ü©</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"n\">complete_lattice_of_Sup</span> <span class=\"n\">mynat</span>  <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- nat.fib preserves meets, where we define  \"preserve meets\" by  (nat.fib n)‚äì (nat.fib m) = nat.fib (n ‚äì m)</span>\n<span class=\"c1\">-- nat.fib is a meet semilattice homomorphism</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_dvd_fib</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m.fib</span> <span class=\"bp\">‚à£</span> <span class=\"n\">n.fib</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- nat.fib is a functor because nat.gcd(nat.fib n, nat.fib m) = nat.fib(nat.gcd n m)</span>\n<span class=\"c1\">-- nat.fib is a continuous functor, because it preserves limits</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">‚•§</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">nat.fib</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hom_of_le</span> <span class=\"o\">(</span><span class=\"n\">fib_dvd_fib</span> <span class=\"o\">(</span><span class=\"n\">le_of_hom</span> <span class=\"n\">h</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- ‚Ñï is a category</span>\n<span class=\"c1\">-- ‚Ñï is also a complete category</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"c1\">-- ‚Ñï has a categorical limit</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">limits.has_finite_limits</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 220478546,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1608397757
    },
    {
        "content": "<p>The sketch provided doesn't show that fib preserves meets, the unproven lemma <code> lemma fib_dvd_fib {m n : ‚Ñï} (h : m ‚à£ n) : m.fib ‚à£ n.fib :=</code> just says that fib is order preserving with the order on mynat given by division.</p>",
        "id": 220522837,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608475294
    },
    {
        "content": "<p>The reason for introducing mynat as a type alias for nat is to make use of notation and lemmas proved for types equipped with an order relation. Lean (naturally) gets confused if you put a two different order relations on the same type and want to use the same symbols to represent them both, so when you have two different relations on some type that both make it a preorder one way to circumvent this is to make a new type which is definitionally equal to the old one but with a different name. Lean will not automatically introduce the typeclasses from the old type for the new one, so we can set up an order relation on mynat that doesn't conflict with the usual ordering on natural numbers. As the types are equal by definition we can still use things proved about nat to prove things about mynat and lean will accept the proofs, hence why lines like <code>   le_sup_left := nat.dvd_lcm_left,</code> work to prove things about mynat.</p>",
        "id": 220522966,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608475553
    },
    {
        "content": "<p>I'm not sure if you are intending your annotations to be before or after the corresponding declaration?</p>",
        "id": 220523036,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608475651
    },
    {
        "content": "<p>The statement that fib is a functor isn't the same as <code>nat.gcd(nat.fib n, nat.fib m) = nat.fib(nat.gcd n m)</code> that is the statement that fib preserves limits.</p>",
        "id": 220523084,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608475721
    },
    {
        "content": "<p>Being a complete category in lean is the statement <code>limits.has_limits</code> I believe, <code>has_finite_limits</code> would just be called finitely complete.</p>",
        "id": 220523152,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608475840
    },
    {
        "content": "<p>But given that we've added an incomplete proof that mynat is a complete lattice, the last line can be changed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">limits.has_finite_limits</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 220523206,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1608475949
    }
]
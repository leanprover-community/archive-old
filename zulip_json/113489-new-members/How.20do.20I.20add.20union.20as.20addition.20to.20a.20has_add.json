[
    {
        "content": "<p>I'm trying to make a <code>has_add</code> instance on a <code>finset</code> where addition is defined as set union.  I know the set union operation exists because I checked it.  Lean is kicking it back:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">X</span> <span class=\"c1\">-- X : set ℕ</span>\n<span class=\"k\">#check</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"n\">X</span> <span class=\"c1\">-- X ∪ X : set ℕ</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X_has_add1</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>with error message</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">X</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_union</span> <span class=\"bp\">↥</span><span class=\"n\">X</span>\n</code></pre></div>\n<p>How do I do this right?  I'm trying to show that <code>{1,2,3}</code> is an <code>add_semigroup</code> and this is step 1.</p>",
        "id": 219682020,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607736855
    },
    {
        "content": "<p>You want to define the instance on finsets, not on elements of a particular finset <code>X</code>. So you want to show</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 219682140,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1607737028
    },
    {
        "content": "<p>This is easy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>But what I want to do is:</p>\n<ul>\n<li>Define a finite set <code>X={1,2,3}</code> as a type so that if I say <code>a : X</code> then <code>a</code> can only take on values 1, 2 or 3.</li>\n<li>Define the power set <code>𝒫 X</code> as a type, with a union operation</li>\n<li>Use the union operation as addition in <code>has_add (𝒫 X)</code>.</li>\n</ul>\n<p>... or the equivalent, but the idea is sets of subsets of <code>{1,2,3}</code>.  This is my first crack at it but it doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">X</span> <span class=\"c1\">-- X : set ℕ</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">X</span> <span class=\"c1\">-- λ (x : ℕ), x = 1 ∨ x = 2 ∨ x = 3 ∨ false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">𝒫</span> <span class=\"n\">X</span>\n<span class=\"k\">#check</span> <span class=\"n\">A</span> <span class=\"c1\">-- A : set (set ℕ)</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">A</span> <span class=\"c1\">-- λ (t : ℕ → Prop), ∀ ⦃a : ℕ⦄, t a → a = 1 ∨ a = 2 ∨ a = 3 ∨ false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"c1\">-- FAIL</span>\n<span class=\"c\">/-</span><span class=\"cm\"> function expected at</span>\n<span class=\"cm\">  x</span>\n<span class=\"cm\">term has type</span>\n<span class=\"cm\">  {x // x ∈ A} -/</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 219688894,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607746886
    },
    {
        "content": "<p>The standard explicit finite set type is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin\">docs#fin</a> with <code>fin n</code> being the subtype of natural numbers below <code>n</code>.</p>",
        "id": 219691035,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607750191
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">A</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>might be what you're looking for</p>",
        "id": 219691124,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607750340
    },
    {
        "content": "<p>In this situation it might be best not to define types with names to be explicit things, I had to add the <code>reducible</code> attribute here so that lean still knows how to define a union of terms of type A.</p>",
        "id": 219691206,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607750421
    },
    {
        "content": "<p>I.e. rather than writing <code>def plus (x y : A) := x ∪ y</code> write <code>def plus (x y : set (fin 3)) := x ∪ y</code> if you're playing around with things.</p>",
        "id": 219691217,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607750457
    },
    {
        "content": "<p>In that case you want <code>instance : has_add (set X) := ...</code> (which is equally easy to define, and uses nothing special about <code>X</code>).<br>\nI also agree with everything Alex said, though if you just want some example code, your <code>X</code> would work fine as well.</p>",
        "id": 219693261,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1607754217
    },
    {
        "content": "<p>Here is a code snippet that works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">X</span> <span class=\"c1\">-- X : set ℕ</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">X</span> <span class=\"c1\">-- λ (x : ℕ), x = 1 ∨ x = 2 ∨ x = 3 ∨ false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">set</span> <span class=\"n\">X</span>\n<span class=\"k\">#check</span> <span class=\"n\">A</span> <span class=\"c1\">-- A : set (set ℕ)</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">A</span> <span class=\"c1\">-- λ (t : ℕ → Prop), ∀ ⦃a : ℕ⦄, t a → a = 1 ∨ a = 2 ∨ a = 3 ∨ false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">set.union</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"c1\">-- alternative</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>However, I <em>strongly</em> encourage you to not define <code>A</code> (or define it as local notation or something), and just use <code>set X</code> instead.</p>",
        "id": 219693310,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1607754273
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  and <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>.  For self-training I am trying fill out a bunch of these intermediary concepts with countable and concrete finite examples.  This really helps me get started on the concrete finite ones.  I got this far and then I got stuck on the case above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X_is_nontrivial</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">fin.nontrivial</span>\n<span class=\"k\">#check</span> <span class=\"n\">X_is_nontrivial</span> <span class=\"c1\">--X_is_nontrivial : nontrivial X</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">):=</span> <span class=\"n\">fin.has_add</span>\n<span class=\"k\">#check</span> <span class=\"n\">X_has_add</span> <span class=\"c1\">-- X_has_add : has_add X</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X_has_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.add_semigroup</span>\n<span class=\"k\">#check</span> <span class=\"n\">X_has_add_semigroup</span> <span class=\"c1\">-- X_has_add_semigroup : add_semigroup X</span>\n</code></pre></div>\n<p>where the whole homework is:<br>\n<a href=\"/user_uploads/3121/F-zhI-5llQhznVYG7R6Ivq7L/Screenshot-from-2020-12-12-09-15-45.png\">Screenshot-from-2020-12-12-09-15-45.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/F-zhI-5llQhznVYG7R6Ivq7L/Screenshot-from-2020-12-12-09-15-45.png\" title=\"Screenshot-from-2020-12-12-09-15-45.png\"><img src=\"/user_uploads/3121/F-zhI-5llQhznVYG7R6Ivq7L/Screenshot-from-2020-12-12-09-15-45.png\"></a></div>",
        "id": 219711099,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607783259
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">):=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>\n<p>The point of the type class inference framework is that the end user shouldn't have to worry about what these instances are called or where they are. Lean will fill in the \"square bracket inputs\" to functions automatically. Your <code>#check</code> outputs aren't the same as mine, I don't know what X is, but this is the reason why <code>def X := fin 3</code> might be a bad idea -- because then <code>apply_instance</code> won't work any more when applied to X and you have to unfold the definition to get it working again.</p>",
        "id": 219712417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607785393
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kd\">@[derive nontrivial]</span> <span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">X</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- apply_instance by itself won't work</span>\n</code></pre></div>",
        "id": 219712487,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607785452
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>.  I will replace my uses of <code>instance</code> with <code>lemma</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">X_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.add_semigroup</span>\n<span class=\"k\">#check</span> <span class=\"n\">X_add_semigroup</span> <span class=\"c1\">-- X_has_add_semigroup : add_semigroup ℕ</span>\n</code></pre></div>\n<p>I like being able to <code>#check </code> the result because it gives me a little extra positive feedback.  </p>\n<p>For <code>fin 3</code>, even though it <code>has_add</code>, it doesn't appear to be an <code>add_semigroup</code>. This fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fin3_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- OK</span>\n<span class=\"kd\">instance</span> <span class=\"n\">fin3_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- FAIL</span>\n</code></pre></div>\n<p>with error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic.mk_instance</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">generate</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n  <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Tactic <code>library_search!</code> also fails.</p>\n<p>I tried a slightly different route:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">X_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span>\n<span class=\"k\">#check</span> <span class=\"n\">X_has_add</span> <span class=\"o\">:</span> <span class=\"n\">X_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">X_add_semigroup</span><span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>this also fails, with error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"n\">add_semigroup.mk</span> <span class=\"n\">plus</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So now I'm confused again.  <code>∪</code> on sets should give me <code>add_semigroup</code>.  Should I be working with power sets?  That's where I started at the beginning of this thread.  But this also fails with a similar error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">set</span> <span class=\"n\">X</span>\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">set.union</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"c1\">-- alternative</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span> <span class=\"c1\">-- OK</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span> <span class=\"c1\">-- ERROR</span>\n</code></pre></div>\n<p>namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"n\">add_semigroup.mk</span> <span class=\"n\">plus</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">A</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">add_semigroup</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>If I take the <code>def A</code> out, I still get an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">set.union</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"c1\">-- alternative</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">A_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">A_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span> <span class=\"c1\">-- ERROR</span>\n</code></pre></div>\n<p>of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"n\">add_semigroup.mk</span> <span class=\"n\">plus</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm stuck.</p>",
        "id": 219714135,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607787949
    },
    {
        "content": "<p>You shouldn't call them lemmas, the instances contain data and if you call them lemmas then the data will be forgotten and things will break</p>",
        "id": 219714687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607788860
    },
    {
        "content": "<p>I can scope it out a little bit like this (which makes this a pretty good exercise):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">set123_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">set123_add_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">sup_assoc</span><span class=\"o\">,</span> <span class=\"c1\">-- FAIL</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">A_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">set123_add_assoc</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>the <code>exact sup_assoc</code> came from <code>library_search!</code>.  It fails, but gives a clue maybe as to a sub-lemma to prove (modelled after <code>sup_assoc</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">⊔</span> <span class=\"bp\">?</span><span class=\"n\">m_4</span> <span class=\"bp\">⊔</span> <span class=\"bp\">?</span><span class=\"n\">m_5</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">⊔</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m_4</span> <span class=\"bp\">⊔</span> <span class=\"bp\">?</span><span class=\"n\">m_5</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 219714808,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607789010
    },
    {
        "content": "<p>Do you understand the error message? It gives you enough information about how to try and fix it.</p>",
        "id": 219714861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607789088
    },
    {
        "content": "<p>It seems like I will have to copy all the <code>sup_assoc</code> machinery and textually replace the <code>⊔</code> with a <code>∪</code>, is that correct?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">sup_assoc</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"bp\">⊔</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⊔</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_antisymm</span>\n  <span class=\"o\">(</span><span class=\"n\">sup_le</span>\n    <span class=\"o\">(</span><span class=\"n\">sup_le</span> <span class=\"n\">le_sup_left</span> <span class=\"o\">(</span><span class=\"n\">le_sup_right_of_le</span> <span class=\"n\">le_sup_left</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">le_sup_right_of_le</span> <span class=\"n\">le_sup_right</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">sup_le</span>\n    <span class=\"o\">(</span><span class=\"n\">le_sup_left_of_le</span> <span class=\"n\">le_sup_left</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">sup_le</span> <span class=\"o\">(</span><span class=\"n\">le_sup_left_of_le</span> <span class=\"n\">le_sup_right</span><span class=\"o\">)</span> <span class=\"n\">le_sup_right</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 219714865,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607789099
    },
    {
        "content": "<p>I.e. prove all the <code>sup_assoc</code> theorems and supporting lemmas in a union context.</p>",
        "id": 219714880,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607789137
    },
    {
        "content": "<p>All these questions you're asking -- all the errors you're posting are of the form \"Lean expected a term of type X and you gave it a term of a completely different type\". The errors are telling you what you did wrong.</p>",
        "id": 219714884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607789154
    },
    {
        "content": "<p>I have to prove set union is associative, is the clue.</p>",
        "id": 219714934,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607789200
    },
    {
        "content": "<p>you have to read the error messages</p>",
        "id": 219714944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607789237
    },
    {
        "content": "<p>That is, <code>library_search!</code> seems to be looking for something that fits the bill, but I don't know in Lean how to instantiate ⊔ with ∪.  I am not willfully ignoring the error messages, I am trying to figure out why <code>library_search!</code> took me here and what I need to do next.  Naively, it's a copy and replace of all of <code>sup_assoc</code>.</p>",
        "id": 219714999,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607789306
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">⊔</span> <span class=\"bp\">?</span><span class=\"n\">m_4</span> <span class=\"bp\">⊔</span> <span class=\"bp\">?</span><span class=\"n\">m_5</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">⊔</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m_4</span> <span class=\"bp\">⊔</span> <span class=\"bp\">?</span><span class=\"n\">m_5</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>says \"the term you gave me does not start with \"for all\" but the term I want starts with \"for all\".</p>",
        "id": 219715019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607789357
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"n\">add_semigroup.mk</span> <span class=\"n\">plus</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>says \"the term you gave me is of the form X -&gt; Y but I was expecting a term of type Y\"</p>",
        "id": 219715078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607789429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20add.20union.20as.20addition.20to.20a.20has_add/near/219714944\">said</a>:</p>\n<blockquote>\n<p>you have to read the error messages</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> I get this sort of error messages <em>all the time</em>. And they help me figure out my next step.<br>\nLearning how to read these error messages is <em>not hard</em> and crucial for a happy Lean experience.</p>",
        "id": 219715089,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607789450
    },
    {
        "content": "<p>Basically, these particular error messages are telling you: hey, your answer is almost right, but not quite. If you change it a little bit, I'll be happy.</p>",
        "id": 219715110,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607789510
    },
    {
        "content": "<p>And it gives you very good clues about how you need to change your code.</p>",
        "id": 219715151,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607789526
    },
    {
        "content": "<p>Thank you.  I didn't know how to fix the → message which is why I broke down the problem more.  When I looked at the  ⊔ message I saw the  ⊔ versus + and didn't focus on the  ∀.  I will focus on the  ∀.</p>",
        "id": 219715153,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607789536
    },
    {
        "content": "<p>Those messages are of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">you</span> <span class=\"n\">gave</span> <span class=\"n\">me</span>\n  <span class=\"n\">X</span>\n<span class=\"n\">I</span> <span class=\"n\">am</span> <span class=\"n\">expecting</span>\n  <span class=\"n\">Y</span>\n</code></pre></div>",
        "id": 219715162,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607789573
    },
    {
        "content": "<p>It is very important that you compare <code>X</code> and <code>Y</code>.</p>",
        "id": 219715170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607789583
    },
    {
        "content": "<p><code>⊔</code> and <code>+</code> are probably definitionally the same in your situation.</p>",
        "id": 219715175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607789590
    },
    {
        "content": "<p>If you give it a term of type X and it was expecting a term of type Y, and X and Y are definitionally equal, this will be fine.</p>",
        "id": 219715360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607789880
    },
    {
        "content": "<p><code>#print notation</code> tells me that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">_</span> <span class=\"bp\">`⊔`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">_</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">has_sup.sup</span>\n<span class=\"n\">_</span> <span class=\"bp\">`+`</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">_</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">:=</span> <span class=\"n\">has_add.add</span>\n</code></pre></div>\n<p>Knowing a little now about <code>mathlib</code> naming conventions, this tells me that I should instead be using <a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/group/defs.html#add_assoc\"><code>add_assoc</code></a>.  If the proofs of <code>add_assoc</code> and <code>sup_assoc</code> are identical up to notation, maybe there is some code factoring that could be done to make one theorem apply to both notations. There is a proof for <code>sup_assoc</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">sup_assoc</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"bp\">⊔</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⊔</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_antisymm</span>\n  <span class=\"o\">(</span><span class=\"n\">sup_le</span>\n    <span class=\"o\">(</span><span class=\"n\">sup_le</span> <span class=\"n\">le_sup_left</span> <span class=\"o\">(</span><span class=\"n\">le_sup_right_of_le</span> <span class=\"n\">le_sup_left</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">le_sup_right_of_le</span> <span class=\"n\">le_sup_right</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">sup_le</span>\n    <span class=\"o\">(</span><span class=\"n\">le_sup_left_of_le</span> <span class=\"n\">le_sup_left</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">sup_le</span> <span class=\"o\">(</span><span class=\"n\">le_sup_left_of_le</span> <span class=\"n\">le_sup_right</span><span class=\"o\">)</span> <span class=\"n\">le_sup_right</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The definition of <code>add_assoc</code> is a little more mysterious. It shows as a theorem in the docs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">add_assoc</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but the source is hard to interpret.  This is the only thing I see in <a href=\"https://github.com/leanprover-community/mathlib/blob/3afdf41fbbe6eb77bce52ea733d1386184552aed/src/algebra/group/defs.lean#L76\">the file</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">no_rsimp</span><span class=\"o\">]</span> <span class=\"n\">add_assoc</span> <span class=\"c1\">-- TODO(Mario): find out why this isn't copying</span>\n</code></pre></div>\n<p>Game theory has it's <a href=\"https://github.com/leanprover-community/mathlib/blob/3afdf41fbbe6eb77bce52ea733d1386184552aed/src/set_theory/game.lean#L81\">own definition</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">add_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">game</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">quot.sound</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_assoc_equiv</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This is fairly compact (unlike the sup definition which relies on a lot of lemmas), so maybe I can just copy this one over and give it a try, if <code>add_assoc</code> on it's own doesn't work.</p>\n<p>And actually this comes a lot closer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>  <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">A_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">add_assoc</span> <span class=\"c1\">-- ERROR</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>The error message is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">field</span> <span class=\"bp\">'</span><span class=\"n\">add_assoc'</span>\n  <span class=\"n\">add_assoc</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now once again I am stumped.  I am looking at the error message.  It says I am really close.  It just doesn't know how to match a type metavariable <code>?m_1</code> with a concrete type <code>set ↥X</code>.</p>\n<p>What do I do in this case?  I'm guess I need to use <code>@add_assoc</code> instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">add_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and fill out each implicit argument explicitly.</p>",
        "id": 219716710,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607791881
    },
    {
        "content": "<p>DONE (with a hybrid approach of copying the technique in the game theory version to fix the ∀ and then finally applying <code>sup_assoc</code> even though <code>⊔</code> and <code>+</code> map to different types):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">X_add_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">sup_assoc</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">plus</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">X_add_assoc</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 219716985,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607792336
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">X_add_assoc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sup_assoc</span>\n</code></pre></div>\n<p>Why not move x,y,z before the colon and then just go full term mode?</p>",
        "id": 219717124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607792518
    },
    {
        "content": "<p>Thank you.  Shortest version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">X_has_add</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span> <span class=\"o\">⟩</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">X_add_assoc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sup_assoc</span>\n<span class=\"kd\">instance</span> <span class=\"n\">X_add_semigroup</span> <span class=\"o\">:</span> <span class=\"n\">add_semigroup</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">plus</span><span class=\"o\">,</span> <span class=\"n\">X_add_assoc</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 219717180,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607792560
    },
    {
        "content": "<p>I usually stick with the <code>{ ... }</code> notation for making structure instances such as <code>X_add_semigroup</code>, because it's more readable. Note that you don't have to name the instances either -- Lean will find them automatically. The very fact that <code>(x + y) + z</code> typechecks demonstrates this.</p>",
        "id": 219718425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607794352
    }
]
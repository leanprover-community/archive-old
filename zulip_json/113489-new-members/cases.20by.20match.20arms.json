[
    {
        "content": "<p>I have a match that branches over two inductive types. However, there are way fewer arms than cases due to <code>_</code>. Is there a nice way to do cases on the arms rather than the match-inputs?</p>\n<p>Here is an (artificial) example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Category</span>\n<span class=\"bp\">|</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">bar</span>\n<span class=\"bp\">|</span> <span class=\"n\">baz</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cat</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">):</span> <span class=\"n\">Category</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span> <span class=\"k\">then</span> <span class=\"n\">Category.foo</span> <span class=\"k\">else</span> <span class=\"n\">Category.bar</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">cat</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">cat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">Category.foo</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">Category.bar</span><span class=\"o\">,</span> <span class=\"n\">Category.bar</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">Category.bar</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span>\n<span class=\"bp\">|</span> <span class=\"n\">Category.baz</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">):</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"c1\">-- goal: foo._match_1 n (cat n) (cat (n + 1)) &gt; n</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>There are 16 cases with <code>cases cat n; cases cat (n+1);</code>. However, I would like to only consider the four cases of the match. Each match arm case should provide hypotheses which describe all cases when that match arm is selected. (I think it would be reasonable to do this kind of casing automatically when unfolding a definition that uses pattern matching)</p>",
        "id": 220577225,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1608552564
    },
    {
        "content": "<p>Maybe a tactic <code>unfold_match</code> is what I'm looking for. It would be nice if it would consider nested matches too.<br>\nIn my actual scenario, I have this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Gdt.mark_inactive_leaves</span> <span class=\"o\">:</span> <span class=\"n\">Gdt</span> <span class=\"bp\">→</span> <span class=\"n\">Env</span> <span class=\"bp\">→</span> <span class=\"n\">Ant</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Gdt.grd</span> <span class=\"o\">(</span><span class=\"n\">Grd.xgrd</span> <span class=\"n\">grd</span><span class=\"o\">)</span> <span class=\"n\">tr</span><span class=\"o\">)</span> <span class=\"n\">env</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">xgrd_eval</span> <span class=\"n\">grd</span> <span class=\"n\">env</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">tr.mark_all_leaves_inactive</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">env'</span> <span class=\"o\">:=</span> <span class=\"n\">tr.mark_inactive_leaves</span> <span class=\"n\">env'</span>\n    <span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>My goal G is like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">G</span><span class=\"o\">[</span>  <span class=\"o\">(</span><span class=\"n\">Gdt.grd</span> <span class=\"o\">(</span><span class=\"n\">Grd.xgrd</span> <span class=\"n\">gdt_grd</span><span class=\"o\">)</span> <span class=\"n\">gdt_tr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mark_inactive_leaves</span> <span class=\"n\">env</span>   <span class=\"o\">]</span>\n</code></pre></div>\n<p>It would be nice if I could do <code>unfold_match Gdt.mark_inactive_leaves</code> which would solve the goal and create two new ones:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span><span class=\"o\">:</span>  <span class=\"n\">xgrd_eval</span> <span class=\"n\">grd</span> <span class=\"n\">env</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n<span class=\"n\">G</span><span class=\"o\">[</span> <span class=\"n\">tr.mark_all_leaves_inactive</span>  <span class=\"o\">]</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span><span class=\"o\">:</span>  <span class=\"n\">xgrd_eval</span> <span class=\"n\">grd</span> <span class=\"n\">env</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">env'</span>\n<span class=\"n\">G</span><span class=\"o\">[</span> <span class=\"n\">tr.mark_inactive_leaves</span> <span class=\"n\">env'</span>  <span class=\"o\">]</span>\n</code></pre></div>\n<p>Does such a tactic exist?</p>",
        "id": 220577784,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1608553089
    },
    {
        "content": "<p>I recall someone working on this back in june, but I don't know if we got a PR out of it</p>",
        "id": 220616305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608576555
    },
    {
        "content": "<p>Sort of a beefed-up <code>split_ifs</code>, I guess?</p>",
        "id": 220616537,
        "sender_full_name": "Reid Barton",
        "timestamp": 1608576686
    },
    {
        "content": "<p>I guess <code>match</code> is rarely used for math anyway?</p>",
        "id": 220616678,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1608576751
    },
    {
        "content": "<p>exact<br>\n<span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/cases.20by.20match.20arms/near/220616537\">said</a>:</p>\n<blockquote>\n<p>Sort of a beefed-up <code>split_ifs</code>, I guess?</p>\n</blockquote>\n<p>, <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 220616776,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1608576830
    }
]
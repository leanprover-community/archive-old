[
    {
        "content": "<p>I have an abstract question which arises from a concrete problem which is complicated to transform into an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, so I will try to ask it in words (I can link a branch though).  If I have a dependent type, say <code>Π a : α,  A</code>, and <code>x : A a</code>, <code>y : A b</code>, where <code>a</code> and <code>b</code> are equal but not definitionally equal (I need to use an easy simp lemma to show that <code>a = b</code>), the proposition <code>x = y</code> will not be accepted by Lean. If I need to impose this proposition as a condition in a structure, what can I do? I kind of managed to produce an accepted proposition in tactic mode (by rewriting the simp lemma and then using <code>exact</code>), but it is extremely slow to compile, so I wonder if there is a better way or what is in general a good solution to this kind of problem. Also, although it typechecks, I did not manage to test it yet to see if it is what I want because the goal when trying to prove things is just <code>prop</code> so I cannot say it works yet (it could be that I should use <code>exact</code> with something of Type the prop I want but I don't really know how to do this)</p>",
        "id": 206364837,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1596922239
    },
    {
        "content": "<p>you can write <code>x == y</code> and end up in heq hell</p>",
        "id": 206379907,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596950712
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/heq.20hell.20again\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/heq.20hell.20again</a></p>",
        "id": 206379956,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596950767
    },
    {
        "content": "<p>Do you have any resource about <code>==</code>? I mean to understand better what it is and what it does</p>",
        "id": 206381364,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1596953615
    },
    {
        "content": "<p>I cannot find a way to search for \"==\" in Zulip, it tells me no results when at least this chat should clearly appear in the results</p>",
        "id": 206383891,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1596958777
    },
    {
        "content": "<p>== is the notation for heterogeneous equality, its in <a href=\"https://leanprover.github.io/tutorial/tutorial.pdf\">https://leanprover.github.io/tutorial/tutorial.pdf</a> at least</p>",
        "id": 206384400,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1596959869
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/heq\">docs#heq</a></p>",
        "id": 206386205,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596963566
    },
    {
        "content": "<p>You can define a function from A a to A b and show it maps x to y</p>",
        "id": 206414257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597011945
    },
    {
        "content": "<p>maybe we should prove that <code>eq.rec</code> is a ring hom etc</p>",
        "id": 206428793,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597036449
    },
    {
        "content": "<p>Would you suggest trying to avoid using heq at all costs? It actually seems to be designed exactly for my problem</p>",
        "id": 206522520,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597099900
    },
    {
        "content": "<p>But I already encountered the first problem: how do I apply extensionality results to heq?</p>",
        "id": 206522590,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597099934
    },
    {
        "content": "<p>don't use heq</p>",
        "id": 206522629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597099975
    },
    {
        "content": "<p>that's really the best advice I can give; if you are using heq you are either doing something really specialized or something has gone wrong earlier</p>",
        "id": 206522661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100011
    },
    {
        "content": "<p>Do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 206522744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100067
    },
    {
        "content": "<p>No things departed from mathlib too much time ago, I have a big branch</p>",
        "id": 206522764,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100096
    },
    {
        "content": "<p>you should link a branch then</p>",
        "id": 206522780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100110
    },
    {
        "content": "<p>I am using it to define left invariant vector fields. I kind of need to use it naturally as two different tangent vectors at two different tangent spaces have different types</p>",
        "id": 206522804,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100132
    },
    {
        "content": "<p>You can still sorry things out for the purpose of an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> you know</p>",
        "id": 206522805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100133
    },
    {
        "content": "<p>Yeah but there is many PRs in between, I feel my problem can be discussed philosophically first</p>",
        "id": 206522897,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100194
    },
    {
        "content": "<p>well I want to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> your problem and I can't do that without more context</p>",
        "id": 206522911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100213
    },
    {
        "content": "<p>I want to know what problem got you to this stage</p>",
        "id": 206522922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100230
    },
    {
        "content": "<p>Ok I'll link a branch tomorrow as there are many things I need to write to explain what is going on: there's really a lot of code in between. In any case I implemented everything as in standard maths. Tangent spaces are spaces of derivations at that point, so it feels natural that to impose the condition of left invatiant vector field I need to use heq. Lean cannot know in advance the tangent space of the vector field evaluated at g and the tangent space of the vector field evaluated at the identity and then transported to g are the same space</p>",
        "id": 206523255,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100459
    },
    {
        "content": "<p>There is a lemma that proves it but lean cannot know it</p>",
        "id": 206523302,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100506
    },
    {
        "content": "<p>But just to sleep well tonight and finish off what I started: there is no standard way to apply extensionality to heq right?</p>",
        "id": 206523438,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100564
    },
    {
        "content": "<p>You really don't need all the code here</p>",
        "id": 206523473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100607
    },
    {
        "content": "<p>just snip out the part that contains the heq, the stuff needed to understand the types of those objects, and then just axiomatize all the things needed to make those things typecheck</p>",
        "id": 206523551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100655
    },
    {
        "content": "<p>I have never seen an issue that needs an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of more than 50 lines unless it is actually a code review question</p>",
        "id": 206523595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100706
    },
    {
        "content": "<p>even if it doesn't compile, could you post the code that says</p>\n<blockquote>\n<p>so it feels natural that to impose the condition of left invatiant vector field I need to use heq</p>\n</blockquote>",
        "id": 206523654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100762
    },
    {
        "content": "<blockquote>\n<p>Lean cannot know in advance the tangent space of the vector field evaluated at g and the tangent space of the vector field evaluated at the identity and then transported to g are the same space</p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> has dealt with a problem similar to this for defining tangent spaces in manifolds</p>",
        "id": 206523723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100827
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267205\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20type.20runtime/near/206523438\">said</a>:</p>\n<blockquote>\n<p>But just to sleep well tonight and finish off what I started: there is no standard way to apply extensionality to heq right?</p>\n</blockquote>\n<p>The theorem <code>f == g -&gt; x == y -&gt; f x == g y</code> is not a theorem in lean (it is consistent but not provable from lean's axioms), but <code>f = g -&gt; x1 == y1 -&gt; ... -&gt; xn == yn -&gt; f x1 ... xn == g y1 ... yn</code> is provable (and I believe <code>congr</code> will prove it). Maybe this answers your question?</p>",
        "id": 206523884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597100968
    },
    {
        "content": "<p>Well this is gonna take me at least two hours haha I promise there's like 1500 lines of code between the current state of mathlib and my branch! When I'll link the branch if someone will be able to write a 50 lines <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> I'll be extremely surprised. The structure is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">Lb</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">lie_group</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"err\">∞</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">;</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">g</span><span class=\"o\">),</span> <span class=\"n\">smooth_mul_left</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fdifferential</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"err\">∞</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">;</span> <span class=\"n\">I&#39;</span><span class=\"o\">,</span> <span class=\"n\">M&#39;</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">point_derivation</span> <span class=\"n\">I&#39;</span> <span class=\"n\">M&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">vector_field_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">left_invariant_vector_field</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">lie_group</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">vector_field_derivation</span> <span class=\"n\">I</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left_invariant</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">to_vector_field_derivation</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">g</span> <span class=\"bp\">==</span> <span class=\"o\">(</span><span class=\"n\">fd</span> <span class=\"o\">(</span><span class=\"n\">Lb</span> <span class=\"n\">I</span> <span class=\"n\">G</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_vector_field_derivation</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 206523885,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100969
    },
    {
        "content": "<p>Now I try to define something</p>",
        "id": 206523905,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597100988
    },
    {
        "content": "<p>Names are temporary not at all what I plan to push</p>",
        "id": 206523978,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597101021
    },
    {
        "content": "<p>So you can just delete the typeclasses, they look irrelevant to the example. But the types of <code>fd</code> and <code>Lb</code> look important, put them in the mwe</p>",
        "id": 206524022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101060
    },
    {
        "content": "<p><code>fd</code> is the differential in this context, <code>Lb</code> left multiplication for bundled smooth maps</p>",
        "id": 206524042,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597101071
    },
    {
        "content": "<p>also <code>to_vector_field_derivation.eval</code></p>",
        "id": 206524045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101073
    },
    {
        "content": "<p><code>eval</code> is a function that evaluates a vector field at a point</p>",
        "id": 206524137,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597101150
    },
    {
        "content": "<p>sure, I mean the types of all those functions should be in the mwe</p>",
        "id": 206524152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101166
    },
    {
        "content": "<p>My guess is, you need a function that maps the type of <code>to_vector_field_derivation.eval g</code> (see here I need to see the type of <code>to_vector_field_derivation.eval</code> to say the right words) to the type of <code>(fd (Lb I G g)) </code></p>",
        "id": 206524272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101277
    },
    {
        "content": "<p>this type is a map from <code>P x</code> to <code>P y </code> where <code>x = y</code>, although usually you can say something weaker than just <code>x = y</code></p>",
        "id": 206524323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101343
    },
    {
        "content": "<p>So <code>point_derivation I M x</code> for different values of <code>x</code> are different vector spaces?</p>",
        "id": 206524418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101424
    },
    {
        "content": "<p>Yes</p>",
        "id": 206524427,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597101436
    },
    {
        "content": "<p>I guess <code>P</code> here is <code>point_derivation I M</code></p>",
        "id": 206524428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101436
    },
    {
        "content": "<p>Yeah the easy thing is to just make a function <code>point_derivation_eq : x = y -&gt; point_derivation I M x -&gt; point_derivation I M y</code></p>",
        "id": 206524518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101500
    },
    {
        "content": "<p>and apply it here to perform the type juggling</p>",
        "id": 206524529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101516
    },
    {
        "content": "<p>with a bit of soul searching you might find a more appropriate assumption than <code>x = y</code>, like <code>x &lt;= y</code> for some sense of <code>&lt;=</code></p>",
        "id": 206524571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101561
    },
    {
        "content": "<p>Ok but so just for general culture heq should not exist right? I cannot really immagine a more natural situation for it to be used than this one, so I guess you think it should never be used</p>",
        "id": 206524678,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597101650
    },
    {
        "content": "<p>I mean you could use it here, it's equivalent, but it will not be as nice to work with</p>",
        "id": 206524726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101706
    },
    {
        "content": "<p>if you choose to put it in the structure you will want lemmas saying how to get from it to various other versions using explicit coercion between types</p>",
        "id": 206524803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597101764
    },
    {
        "content": "<p>Ok then I'll link a branch tomorrow so to get help to remove it cause I am not sure I am able to do it now</p>",
        "id": 206524918,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597101855
    },
    {
        "content": "<p>Just to write the code to show my purpose though do you know how to use extensionality rules with it? I promise I'll remove it I just want to test the machinery I wrote before people can help me removing it</p>",
        "id": 206524961,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597101944
    },
    {
        "content": "<p>You will have to be more specific. Many basic tactics don't work on <code>heq</code></p>",
        "id": 206526176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597103042
    },
    {
        "content": "<p><code>ext</code> doesn't work on any <code>heq</code> goal that I can think of</p>",
        "id": 206526252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597103093
    },
    {
        "content": "<p>what kind of extensionality theorem are you talking about? again, <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> even if the W comes later</p>",
        "id": 206526295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597103138
    },
    {
        "content": "<p>If the question is only to define left invariant vector fields then you should be able to define the action of G on vector fields and then take the vector fields fixed by this action</p>",
        "id": 206526930,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597103687
    },
    {
        "content": "<p>Alternatively can you just change the left hand side to evaluation at <code>g * 1</code> or something?</p>",
        "id": 206526980,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597103754
    },
    {
        "content": "<p>or evaluation at <code>_</code> to dodge the problem</p>",
        "id": 206527051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597103802
    },
    {
        "content": "<p>or another way (which is basically expanding out the action on vector fields approach to something similar to what you have) is to require an equation with <code>g * x</code> on the left, for all <code>g x : G</code></p>",
        "id": 206527139,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597103885
    },
    {
        "content": "<p>Have you constructed examples of left invariant vector fields yet?</p>",
        "id": 206527823,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597104480
    },
    {
        "content": "<p>The mathlib tangent space is designed so that the type of the tangent space at all points is the same, to avoid precisely this issue. Are you trying to define another tangent space? (I don't think we want to have several instantiations of the tangent space in mathlib, the one we have should be general enough)</p>",
        "id": 206548166,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1597131817
    },
    {
        "content": "<p>Yes, I was very confused by <span class=\"user-mention\" data-user-id=\"267205\">@Nicolò Cavalleri</span> 's messages. Sébastien went out of his way to avoid exactly this issue, at the cost of an extremely unnatural construction of the tangent bundle. I think you are currently proving he was right. What you can probably do is building a function turning a derivation into a tangent vector, but you shouldn't make a new tangent bundle.</p>",
        "id": 206550392,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597133782
    },
    {
        "content": "<p>The point is that I tried for about a week to define it with the current tangent bundle but I am really not able to understand how am I supposed to use it and I hence I cannot really work with it. My initial strategy was to define vector bundles and then define vector fields as sections of a vector bundle. I was not able to do it and I tried to ask for help to do this, in the topic \"Vector bundles\" in new members and in the topic \"Lie algebras and Lie groups\" in maths, but I did not receive any answer to any of the two, and that was just the initial problem, then I had many others. So I looked for a workaround on which I could be more independent, without the need to ask for too much help, which is harder to get for more specific sections of the library, and I came up with an idea that is in the end purely algebraic: using derivations both for vector fields and to define Lie brackets. I am not redefining the tangent bundle, I am just doing everything in terms of derivations: I do not plan to work on any smooth structures on them, just dealing with the algebra. When I talked about tangent spaces before I meant point derivations, not a proper substitution to the current tangent space. I believe this solution looks extremely natural and proofs with these definition are short and easy. It is just that it does present this problem of heq, for which it looks though that there are solutions (I am thinking in particular to that of Mario) that would allow me to keep using just algebra. In any case I do not necessarily plan to upload all of this to mathlib, I just need to prove some results on my own, so if people have suggestions about how to use heq with extensionality rules I'm happy to hear them all the same</p>",
        "id": 206565062,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597146362
    },
    {
        "content": "<p>What's your definition of <code>point_derivation</code>?</p>",
        "id": 206567165,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597148054
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">manifold</span>\n\n<span class=\"n\">def</span> <span class=\"n\">module_point_derivation</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">C</span><span class=\"err\">∞</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">;</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"err\">𝕜</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span> <span class=\"bp\">_</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">compatible_semimodule_tangent_space</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">compatible_semimodule</span> <span class=\"err\">𝕜</span> <span class=\"n\">C</span><span class=\"err\">∞</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">;</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"err\">𝕜</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">module_point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">compatible_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">point_derivation</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">derivation</span> <span class=\"err\">𝕜</span> <span class=\"n\">C</span><span class=\"err\">∞</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">;</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"err\">𝕜</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">module_point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">_</span>\n  <span class=\"o\">(</span><span class=\"n\">compatible_semimodule_tangent_space</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>the derivation part is in the derivation PR but I can include it here if you want</p>",
        "id": 206567282,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597148163
    },
    {
        "content": "<p>Yet another way to avoid <code>heq</code> is to work with the type <code>\\Sigma x, point_derivation I M x</code> -- this is the total space of the tangent bundle in these terms</p>",
        "id": 206567322,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597148188
    },
    {
        "content": "<p>Ok cool this would be nice as well I'll give it a try</p>",
        "id": 206567366,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597148240
    },
    {
        "content": "<p>Do you have in mind any particular point in mathlib where a similar solution was used and which I could look for inspiration?</p>",
        "id": 206567455,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597148286
    },
    {
        "content": "<p>just experiment</p>",
        "id": 206567485,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597148310
    },
    {
        "content": "<p>the drawback is now you cannot easily e.g. add two tangent vectors that you know are based at the same point</p>",
        "id": 206567504,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597148331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20type.20runtime/near/206524518\">said</a>:</p>\n<blockquote>\n<p>Yeah the easy thing is to just make a function <code>point_derivation_eq : x = y -&gt; point_derivation I M x -&gt; point_derivation I M y</code></p>\n</blockquote>\n<p>At some point, you will probably be forced to do this <span aria-label=\"this\" class=\"emoji emoji-1f446\" role=\"img\" title=\"this\">:this:</span> in any case</p>",
        "id": 206567580,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597148400
    },
    {
        "content": "<p>Ok thanks</p>",
        "id": 206567627,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597148424
    },
    {
        "content": "<p>So ultimately, a <code>v : point_derivation I M x</code> is a function from <code>C∞(I, M; 𝕜)</code> that satisfies a long list of properties. The key point is that <code>C∞(I, M; 𝕜)</code> doesn't depend on <code>x</code> any more. You want to prove that if <code>x = y</code>, then the properties for <code>point_derivation I M x</code> are the same (equivalent) to the ones for <code>point_derivation I M y</code>, and therefore you can convert <code>point_derivation I M x</code> to <code>point_derivation I M y</code> by using the same function.</p>",
        "id": 206567978,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597148742
    },
    {
        "content": "<p>Ok you meant something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">point_derivation_eq</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span><span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">v</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Lb_apply_one</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">lie_group</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Lb</span> <span class=\"n\">I</span> <span class=\"n\">G</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Lb_apply</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">left_invariant_vector_field</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">lie_group</span> <span class=\"n\">I</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">vector_field_derivation</span> <span class=\"n\">I</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left_invariant</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">to_vector_field_derivation</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">point_derivation_eq</span>\n  <span class=\"o\">(</span><span class=\"n\">Lb_apply_one</span> <span class=\"n\">I</span> <span class=\"n\">G</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">fd</span> <span class=\"o\">(</span><span class=\"n\">Lb</span> <span class=\"n\">I</span> <span class=\"n\">G</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_vector_field_derivation</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)))</span> <span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>right? This kind of works</p>",
        "id": 206571522,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597151036
    },
    {
        "content": "<p>All the same I wonder if it were possible to write a tactic <code>hext</code> that transforms extensionality rules for <code>=</code> into extensionality rules for <code>==</code>. This would make woking with <code>heq</code> totally possible in my situation</p>",
        "id": 206571919,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597151253
    },
    {
        "content": "<p>I mean just for the sake of elegance, and not to write lemmas that have to make things work with <code>point_derivation_eq</code></p>",
        "id": 206572200,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597151379
    },
    {
        "content": "<p>A simple way to define the Lie algebra using the current tangent space in mathlib is just to define <code>Ad</code> by deriving conjugacy, and then <code>ad</code> by deriving <code>Ad</code> (see <a href=\"https://en.wikipedia.org/wiki/Adjoint_representation\">https://en.wikipedia.org/wiki/Adjoint_representation</a> if you're not familiar with this).</p>",
        "id": 206573173,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1597151944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20type.20runtime/near/206573173\">said</a>:</p>\n<blockquote>\n<p>A simple way to define the Lie algebra using the current tangent space in mathlib is just to define <code>Ad</code> by deriving conjugacy, and then <code>ad</code> by deriving <code>Ad</code> (see <a href=\"https://en.wikipedia.org/wiki/Adjoint_representation\">https://en.wikipedia.org/wiki/Adjoint_representation</a> if you're not familiar with this).</p>\n</blockquote>\n<p>Well sure I do know what the adjoint representation is. The problem with this approach is that I am not really able to prove even basic stuff about the current tangent bundle, such as functoriality of the differential (if it has been proved I can't find it, the words <code>functor</code> <code>composition</code> and <code>inverse</code> are not in the documentation). Unless I have a stable help to use this tangent bundle I am not really able to use it...</p>",
        "id": 206591786,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597160828
    },
    {
        "content": "<p>Hopefully everything you need on the derivative should be in the file <code>mfderiv.lean</code>, see <a href=\"https://leanprover-community.github.io/mathlib_docs/geometry/manifold/mfderiv.html\">https://leanprover-community.github.io/mathlib_docs/geometry/manifold/mfderiv.html</a>. The fact that the derivative of the composition is the composition of derivatives should be there, probably under the name <code>mfderiv_comp</code> that you can guess once you know that the name for the derivative is <code>mfderiv</code>, as explained in the file-level docstring. If you want to use the full tangent map, then the file level docstring tells you that it is called <code>tangent_map</code>, and then the statement on the composition on the tangent maps is probably called <code>tangent_map_comp</code> (I haven't checked, but I hope this is it). If you have ideas on how we could improve the documentation to make this easier to find, your thoughts are most welcome!</p>",
        "id": 206597557,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1597163647
    },
    {
        "content": "<p>All this should also be covered at length in the tutorial for manifolds I gave at lftcm2020.</p>",
        "id": 206597669,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1597163721
    },
    {
        "content": "<p>Ops right I do not know why I did not find it before, probably I looked for <code>composition</code> instead of <code>comp</code> thinking there would have been a documentation string above. I cannot find <code>mfderiv_inv</code> but that I should be able to prove it probably, I'll give it a try. Well I guess it is because that would require diffeomorphisms</p>",
        "id": 206598986,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597164411
    },
    {
        "content": "<p>I'd need to implement a version of <code>mfderiv</code> for diffeomorphism as I need the fact that the <code>mfderiv</code> of a diffeo is an isomorphism. Is it a good idea, how should it be called? I mean was this problem faced for fderiv already?</p>",
        "id": 206606247,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597167696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267205\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20type.20runtime/near/206571919\">said</a>:</p>\n<blockquote>\n<p>All the same I wonder if it were possible to write a tactic <code>hext</code> that transforms extensionality rules for <code>=</code> into extensionality rules for <code>==</code>. This would make woking with <code>heq</code> totally possible in my situation</p>\n</blockquote>\n<p>I'm still confused by what exactly you mean by this. Could you write down the statement of the extensionality theorem you expect?</p>",
        "id": 206614799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597171639
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hext</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">hext</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">point_derivation</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">w</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">==</span> <span class=\"n\">w</span>\n</code></pre></div>",
        "id": 206636266,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597183191
    },
    {
        "content": "<p>I think this might not be provable, but it should be fine if you change <code>h1</code> to <code>h1 : x = y</code></p>",
        "id": 206636922,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597183583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20type.20runtime/near/206636922\">said</a>:</p>\n<blockquote>\n<p>I think this might not be provable, but it should be fine if you change <code>h1</code> to <code>h1 : x = y</code></p>\n</blockquote>\n<p>That's totally fine! Just out of curiosity what is the strategy to prove it?</p>",
        "id": 206637109,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597183704
    },
    {
        "content": "<p><code>cases h1</code>, then rewrite <code>heq</code> to <code>eq</code></p>",
        "id": 206637146,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597183743
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/heq_iff_eq\">docs#heq_iff_eq</a></p>",
        "id": 206637185,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597183768
    },
    {
        "content": "<p>(also, I'm assuming the type of <code>w</code> is wrong--should have <code>y</code>)</p>",
        "id": 206637520,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597184036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20type.20runtime/near/206637520\">said</a>:</p>\n<blockquote>\n<p>(also, I'm assuming the type of <code>w</code> is wrong--should have <code>y</code>)</p>\n</blockquote>\n<p>Yep sure sorry</p>",
        "id": 206637577,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597184061
    },
    {
        "content": "<p>Yeah it works even if <code>h2</code> needs to be changed to only one equal, which is better and <code>cases h1</code> seems a bit magic to me</p>",
        "id": 206637834,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597184261
    },
    {
        "content": "<p>In any case I wonder whether this kind of theorem can be generated automatically from ext theorems or they are specific to each case</p>",
        "id": 206638523,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597184807
    },
    {
        "content": "<p>I think the closest we have to this is <code>local_homeomorph.mfderiv</code> (see the section <code>/-! ### Differentiable local homeomorphisms -/</code> starting at line 1151 in <code>mfderiv.lean</code>). There are two possible paths:</p>\n<ul>\n<li>define <code>homeomorph.differentiable</code>, and <code>homeomorph.mfderiv</code> and so on, following the <code>local_homeomorph</code> API. So, the main objects would be homeomorphisms, and there would be predicates on them</li>\n<li>introduce bundled diffeomorphisms.</li>\n</ul>\n<p>Both paths make sense. If you want to go the bundled route (which I think I like a little bit more), it would be important to have it in intermediate smoothness (i.e., be able to talk of a <code>C^k</code>-diffeomorphism between smooth manifolds, for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">0 \\leq k \\leq \\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span>, where for <code>k=0</code> this would just be homeomorphisms).</p>\n<p>For local homeomorphisms, the bundled way isn't good because we want to be able to talk about the smoothness of the charts, and the charts are given as local homeos already. But this constraint does not apply to the global objects, so I think I would go for bundled.</p>",
        "id": 206678452,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1597227904
    },
    {
        "content": "<p>Well I actually have a ready PR in cue with bundled diffeos which I was waiting to push after bundled maps, but I did the C^\\infty case only. What do you wanna call C^k diffeomoerphisms?</p>",
        "id": 206698044,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1597241159
    },
    {
        "content": "<p>Something like (to be copy-pasted as the end of <code>times_cont_mdiff.lean</code>, but it would probably deserve its own file)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">I&#39;</span> <span class=\"n\">M</span> <span class=\"n\">M&#39;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"kn\">structure</span> <span class=\"n\">diffeomorph</span> <span class=\"kn\">extends</span> <span class=\"n\">M</span> <span class=\"err\">≃</span> <span class=\"n\">M&#39;</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">times_cont_mdiff_symm</span> <span class=\"o\">:</span> <span class=\"n\">times_cont_mdiff</span> <span class=\"n\">I&#39;</span> <span class=\"n\">I</span> <span class=\"n\">n</span> <span class=\"n\">inv_fun</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">times_cont_mdiff</span> <span class=\"o\">:</span> <span class=\"n\">times_cont_mdiff</span> <span class=\"n\">I</span> <span class=\"n\">I&#39;</span> <span class=\"n\">n</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">diffeomorph</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">I</span> <span class=\"n\">M</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">times_cont_mdiff</span> <span class=\"o\">:=</span> <span class=\"n\">times_cont_mdiff_id</span><span class=\"o\">,</span>\n  <span class=\"n\">times_cont_mdiff_symm</span> <span class=\"o\">:=</span> <span class=\"n\">times_cont_mdiff_id</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">M</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>and so on, with a whole API to be written, with <code>symm</code>, <code>trans</code>, <code>mono</code> (to say that a <code>C^n</code> diffeo induces a <code>C^m</code> diffeo when <code>m \\leq n</code>), coercions to functions, to homeos and to bundled continuous functions...</p>",
        "id": 206707795,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1597245415
    }
]
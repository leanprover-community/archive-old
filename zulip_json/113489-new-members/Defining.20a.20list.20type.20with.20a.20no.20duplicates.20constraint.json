[
    {
        "content": "<p>I'm a programmer without a strong mathematical background having fun playing around in Lean, but I'm a complete beginner at this. I've completed up to proposition world in the natural numbers game and read through most of the documentation but it's not all intuitive for me yet.</p>\n<p>I'm interested in proving some simple theorems on a type I'll call <code>unique_array</code>. This is a fixed length ordered list in which duplicates are not allowed. I'm particularly interested in using lemmas surrounding rotation of elements, as well as swaps.</p>\n<p>The <code>list</code> type exists and has <a href=\"https://leanprover-community.github.io/mathlib_docs/data/list/rotate.html\">rotation defined</a>, but does not have the fixed length or uniqueness constraints. The <code>array</code> type has the fixed length constraint but not uniqueness, and does not have rotation defined. The <code>set</code> type has uniqueness but nothing else that I need.</p>\n<p>Is there a way to create a <code>unique_array</code> type that combines the features of the above? For example, create an alias of the <code>list</code> type with the additional no duplicates and fixed length constraints? I'd like to make use of the many lemmas already defined for <code>list</code>. I should then be able to define additional lemmas like \"for all <code>unique_array</code> a with length &gt; 1, (a.rotate 1) != a\" which relies on uniqueness.</p>\n<p>I don't know how to go about defining an alias or derivation with additional constraints, nor how to go about constraining uniqueness. Perhaps there's something that I can do with <a href=\"https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#inheritance\">structure inheritance</a>, but I've not got my head around it well enough to work this out yet.</p>\n<p>Some pointers would be welcome please! Thanks.</p>",
        "id": 249002084,
        "sender_full_name": "Sam",
        "timestamp": 1628612922
    },
    {
        "content": "<p>You should look at the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset/src\">src#finset</a>, which does basically this, but with <code>multiset</code> as the base instead of <code>list</code> or <code>array</code></p>",
        "id": 249002533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628613147
    },
    {
        "content": "<p>That's interesting. I'll take a look, thanks!</p>",
        "id": 249002666,
        "sender_full_name": "Sam",
        "timestamp": 1628613232
    },
    {
        "content": "<p>That is, I think you are describing a type like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">unique_array</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">len</span> <span class=\"o\">:</span> <span class=\"n\">val.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 249002759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628613263
    },
    {
        "content": "<p>Note that you will still have to reprove all the theorems, because they don't all carry over, although most of them are just redirecting to the corresponding lemma on the representing type. See the rest of that finset file for examples</p>",
        "id": 249002863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628613329
    },
    {
        "content": "<p>Can one subtype on <code>vector</code>?</p>",
        "id": 249003010,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628613400
    },
    {
        "content": "<p>that's also an option, although <code>vector</code> doesn't have <code>nodup</code> so you would have to write <code>val.1.nodup</code> for the other field</p>",
        "id": 249003110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628613448
    },
    {
        "content": "<p>But if you're thinking about swaps and rotation of elements over a type with a fixed number of elements, just work on functions over <code>fin n</code>. That way you can use <code>equiv.perm (fin n)</code>, <code>function.injective</code>, etc</p>",
        "id": 249003138,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628613461
    },
    {
        "content": "<p>If the base type has size n, you can just use permutations instead of defining a new type</p>",
        "id": 249003295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628613533
    },
    {
        "content": "<p>Ah. I had considered a composition approach like this but had dismissed it because it doesn't inherit all of the theorems already proved on <code>list</code>. There's a lot of stuff already defined on <code>list</code> that looks useful to me. Intuitively, a fixed length list with a constraint on the elements is a subtype of <code>list</code> and I hoped to exploit that without the busywork of re-implementing the theorems.</p>",
        "id": 249003539,
        "sender_full_name": "Sam",
        "timestamp": 1628613630
    },
    {
        "content": "<p>it depends on what you want. <code>perm</code> and <code>equiv</code> also have a lot of theorems</p>",
        "id": 249003591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628613659
    },
    {
        "content": "<p>but indexing is a little annoying on lists</p>",
        "id": 249003668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628613691
    },
    {
        "content": "<p>I'm looking at those now. I am actually dealing with permutations quite a bit so that sounds useful. I'd only come across <a href=\"https://leanprover-community.github.io/mathlib_docs/data/list/perm.html\">list.perm</a> and hadn't realised that <a href=\"https://leanprover-community.github.io/mathlib_docs/group_theory/perm/basic.html\">perm</a> is defined as its own type in the group theory namespace.</p>",
        "id": 249004028,
        "sender_full_name": "Sam",
        "timestamp": 1628613848
    },
    {
        "content": "<p>The catch is that when I said that I don't have a strong mathematical background I meant it. I'm not actually familiar with group theory yet, so I'll have to see if that's an obstacle or just an opportunity to learn.</p>",
        "id": 249004267,
        "sender_full_name": "Sam",
        "timestamp": 1628613954
    },
    {
        "content": "<p>Is there a way to accomplish something like this using <code>subtype</code>?  The <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions\">Inductive Types documentation</a> mentions it briefly but I've not fully got my head around it yet. Does this represent the type of a list of naturals with no duplicates?</p>\n<p><code>#check { x : list nat // list.nodup x}</code></p>",
        "id": 249008054,
        "sender_full_name": "Sam",
        "timestamp": 1628615629
    },
    {
        "content": "<p>yes, that's right</p>",
        "id": 249008327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628615761
    },
    {
        "content": "<p>Another way to write the type from above is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">unique_array</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">nodup</span> <span class=\"n\">val</span> <span class=\"bp\">∧</span> <span class=\"n\">val.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 249008468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628615826
    },
    {
        "content": "<p>Ah, that looks very promising, thanks!</p>\n<p>I'm a little surprised that that still seems to be creating a new type with a constrained list as a field. <code>unique_array</code> itself is not a list here, right? I'm a little confused by why this is called <code>subtype</code>, because I would think of this result as being a composed type rather than a subtype.</p>",
        "id": 249009972,
        "sender_full_name": "Sam",
        "timestamp": 1628616643
    },
    {
        "content": "<p>It's a subtype because it's the elements of <code>list α</code> which satisfy <code>nodup val ∧ val.length = n</code> - that makes it a \"smaller\" type with fewer elements (unless the condition is just <code>true</code>!)</p>",
        "id": 249012297,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628617750
    },
    {
        "content": "<p>But from a syntactic point of view, it's true that an element of <code>unique_array</code> is not a list, it is a tuple of a list and two proofs. The proofs are erased, so in the VM it is represented as just a list</p>",
        "id": 249012605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628617887
    },
    {
        "content": "<p>My confusion stems from the fact that it looks like a structure with a field called <code>val</code> of that subtype, rather than the subtype itself.</p>",
        "id": 249012639,
        "sender_full_name": "Sam",
        "timestamp": 1628617919
    },
    {
        "content": "<p>what is \"it\"?</p>",
        "id": 249012711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628617948
    },
    {
        "content": "<p>the <code>def</code> or the <code>structure</code> example?</p>",
        "id": 249012737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628617969
    },
    {
        "content": "<p>The <code>unique_array</code> type def. You're right, I shouldn't have called it a \"structure\" I think.</p>",
        "id": 249012772,
        "sender_full_name": "Sam",
        "timestamp": 1628617990
    },
    {
        "content": "<p>That is a typedef for a certain instantiation of the <code>subtype</code> type, which is defined as a <code>structure</code> with two fields (the first of which is actually called <code>val</code>, unrelated to the fact that I also called it <code>val</code> in the binder syntax)</p>",
        "id": 249012950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628618073
    },
    {
        "content": "<p>so your \"confusion\" is actually the correct interpretation of the situation, this is a structure with two things</p>",
        "id": 249013026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628618110
    },
    {
        "content": "<p>the reason it is \"smaller\" is because the second thing is sometimes only a singleton and sometimes impossible</p>",
        "id": 249013097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628618142
    },
    {
        "content": "<p>Oh! I thought that <code>val</code> was the field name you defined in the def.</p>",
        "id": 249013113,
        "sender_full_name": "Sam",
        "timestamp": 1628618148
    },
    {
        "content": "<p>If I wrote</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">unique_array</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">nodup</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">a.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>it would still define the same type and the field projection to get the list would still be called <code>subtype.val</code></p>",
        "id": 249013268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628618198
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype/src\">src#subtype</a> might clear things up. There's nothing magic going on other than perhaps the notation</p>",
        "id": 249013326,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628618221
    },
    {
        "content": "<p>I've got the following very simple test that I'm playing with to understand this. I've just found that same thing about using a different name.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">unique_array</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">list.nodup</span> <span class=\"n\">bar</span> <span class=\"bp\">∧</span> <span class=\"n\">bar.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">unique_array</span> <span class=\"n\">nat</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a.val.length</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 249013355,
        "sender_full_name": "Sam",
        "timestamp": 1628618232
    },
    {
        "content": "<p>The shorter proof is <code>a.prop.2</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.prop\">docs#subtype.prop</a>)</p>",
        "id": 249013422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628618268
    },
    {
        "content": "<p>or <code>a.2.2</code> since you can refer to structure fields either by name or index</p>",
        "id": 249013514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628618303
    },
    {
        "content": "<p>Oh very cool!</p>",
        "id": 249013515,
        "sender_full_name": "Sam",
        "timestamp": 1628618303
    },
    {
        "content": "<p>with the <a href=\"#narrow/stream/113489-new-members/topic/Defining.20a.20list.20type.20with.20a.20no.20duplicates.20constraint/near/249002759\">structure def</a> it would be either <code>a.3</code> or <code>a.len</code></p>",
        "id": 249013619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628618372
    },
    {
        "content": "<p>To clarify, what <code>subtype</code> and the <code>def</code> actually create is a tuple, containing a value and a constraint upon that value?</p>\n<p>What I intuitively expected was for the result of <code>subtype</code> to itself actually <em>be</em> a constrained<code>list</code>, rather than a grouping of a plain list and a constraint upon it. This is fine, it's just not what I expected from the name of the feature.</p>",
        "id": 249014563,
        "sender_full_name": "Sam",
        "timestamp": 1628618806
    },
    {
        "content": "<p>In lean, a value can only have one type up to definitional equality. So if <code>val : list A</code> is a list with no duplicates, it still has type <code>list A</code>, it is not possible to prove that it has a different, more constrained type. This is important for type inference, among other things. If you want to show that it has a more constrained type, what you actually do is construct a <em>new</em> value that bundles <code>val</code> with its proof, and that's what <code>subtype</code> does. There are coercions to make this process fairly transparent in most cases</p>",
        "id": 249014978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628619032
    },
    {
        "content": "<p>I see, thanks! I think I'm getting the hang of this now.</p>",
        "id": 249015131,
        "sender_full_name": "Sam",
        "timestamp": 1628619115
    },
    {
        "content": "<p>One thing that seems a little inconvenient about this is the lack of dot calls. Is there a way to make <code>a.length</code> etc automatically forward to <code>a.val.length</code>?</p>",
        "id": 249015799,
        "sender_full_name": "Sam",
        "timestamp": 1628619434
    },
    {
        "content": "<p>On the subtype? Not automatically. Dot notation <code>l.length</code> is just shorthand for <code>list.length l</code>. Since the subtype isn't of the type <code>list</code> but of <code>subtype ...</code>, there isn't a way to infer that a function <code>subtype.length {x : list _ / ...}</code> ...</p>",
        "id": 249017420,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628620100
    },
    {
        "content": "<p>I see. I obviously don't know what I'm talking about yet, but I wonder whether that would make sense to add in the future. It seems like it might be convenient if it could forward to <code>val</code> when unambiguous, but maybe there's a good reason for not doing that.</p>",
        "id": 249018016,
        "sender_full_name": "Sam",
        "timestamp": 1628620425
    },
    {
        "content": "<p>Note that you can still write <code>list.length a</code> and the coercion will kick in</p>",
        "id": 249020587,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628621829
    },
    {
        "content": "<p>Also, this forwarding does happen for structure <code>extends</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">foo</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">stuff</span> <span class=\"o\">:</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">x.val</span> <span class=\"c1\">-- x.to_foo.val</span>\n</code></pre></div>\n<p>You can't make a structure extend a non-structure though, so it doesn't work for <code>list</code></p>",
        "id": 249022563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628622710
    },
    {
        "content": "<p>Ah yes I see. I think that difference between structure <code>extends</code> and <code>subtype</code> was part of where my original confusion came from.</p>",
        "id": 249023565,
        "sender_full_name": "Sam",
        "timestamp": 1628623210
    },
    {
        "content": "<p>Extended structures feel like my intuitive notion of subtyping more than <code>subtype</code> actually does, but that's only a matter of naming and probably stems from me thinking in more typical programming terms rather than type theory terms.</p>",
        "id": 249023936,
        "sender_full_name": "Sam",
        "timestamp": 1628623360
    },
    {
        "content": "<p>Extended structures feel like my intuitive notion of subtyping more than <code>subtype</code> actually does, but that's only a matter of naming and probably stems from me thinking in more typical programming terms rather than type theory terms.</p>",
        "id": 249023937,
        "sender_full_name": "Sam",
        "timestamp": 1628623360
    },
    {
        "content": "<p>Keep in mind that <code>extends</code> is also just sugar for an extra field like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_foo</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">stuff</span> <span class=\"o\">:</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 249025070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628623872
    },
    {
        "content": "<p>combined with a bit of added magic like the dot forwarding</p>",
        "id": 249025222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628623925
    },
    {
        "content": "<p>Thanks for all of the help yesterday guys! I said in my post that</p>\n<blockquote>\n<p>I should then be able to define additional lemmas like \"for all unique_array a with length &gt; 1, (a.rotate 1) != a\"</p>\n</blockquote>\n<p>Formally (and slightly more generally for all rotation distances) that's</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nodup_rotate</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl₁</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl₂</span> <span class=\"o\">:</span> <span class=\"n\">l.nodup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I've now proved that theorem, which is my first Lean proof at a difficulty level higher than the Natural Numbers Game. It was quite a slog and it took longer than it should have with lots of things to learn along the way, but I got there. In the end I proved this on plain list not the <code>unique_array</code> type - I can use this proof to trivially prove it for <code>unique_array</code> later if I want that.</p>\n<p>The proof ended up being quite long and complicated, and I expect that I've done lots of things very inefficiently. Any feedback on how I could improve it would be very welcome! I've tried to name things well but in some places readability is quite poor. I have a fear that somebody may come along and do it in one line...</p>\n<p>One thing that I've found is that it's actually quite annoyingly slow to evaluate in VSCode - like 10 seconds. Are there some tricks to make compilation faster?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.rotate</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.nodup</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.linarith</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nodup_rotate</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl₁</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl₂</span> <span class=\"o\">:</span> <span class=\"n\">l.nodup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n\n  <span class=\"c1\">-- Break up the iff into parts</span>\n  <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n\n  <span class=\"c1\">-- Show that n % l.length = 0 → l = l.rotate n</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">l.rotate</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">list.rotate_mod</span> <span class=\"n\">l</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">list.rotate_zero</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n\n  <span class=\"c1\">-- Show that l = l.rotate n → n % l.length = 0</span>\n  <span class=\"c1\">-- Prove by contradiction, showing that n % l.length ≠ 0 → l ≠ l.rotate n</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">by_contradiction</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- We have two different indices</span>\n    <span class=\"k\">let</span> <span class=\"n\">k₁</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">k₂</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">k₁</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">l.length</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h_k₁_ne_k₂</span> <span class=\"o\">:</span> <span class=\"n\">k₁</span> <span class=\"bp\">≠</span> <span class=\"n\">k₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finish</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- Utility hypothesese required for list indexing - indices must be in range</span>\n    <span class=\"k\">have</span> <span class=\"n\">h_k₁_le_len</span> <span class=\"o\">:</span> <span class=\"n\">k₁</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span> <span class=\"o\">:=</span> <span class=\"n\">pos_of_gt</span> <span class=\"n\">hl₁</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h_k₂_le_len</span> <span class=\"o\">:</span> <span class=\"n\">k₂</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">k₁</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mod_lt</span> <span class=\"n\">h_k₁_le_len</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h_k₁_le_rlen</span> <span class=\"o\">:</span> <span class=\"n\">k₁</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finish</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- Show that the two different indices have the same value</span>\n    <span class=\"k\">have</span> <span class=\"n\">h_vk₁_eq_vk₂</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.nth_le</span> <span class=\"n\">k₁</span> <span class=\"n\">h_k₁_le_len</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.nth_le</span> <span class=\"n\">k₂</span> <span class=\"n\">h_k₂_le_len</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">k₁</span> <span class=\"n\">h_k₁_le_rlen</span> <span class=\"bp\">=</span> <span class=\"n\">l.nth_le</span> <span class=\"n\">k₂</span> <span class=\"n\">h_k₂_le_len</span> <span class=\"o\">:=</span> <span class=\"n\">list.nth_le_rotate</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"n\">k₁</span> <span class=\"n\">h_k₁_le_rlen</span><span class=\"o\">,</span>\n      <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- Different indices having the same value implies that the list is not nodup</span>\n    <span class=\"c1\">-- Our list is nodup by definition</span>\n    <span class=\"c1\">-- This is our contradiction</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">l.nodup</span> <span class=\"o\">:=</span> <span class=\"n\">list.nth_le_eq_of_ne_imp_not_nodup</span> <span class=\"n\">l</span> <span class=\"n\">k₁</span> <span class=\"n\">k₂</span> <span class=\"n\">h_k₁_le_len</span> <span class=\"n\">h_k₂_le_len</span> <span class=\"n\">h_vk₁_eq_vk₂</span> <span class=\"n\">h_k₁_ne_k₂</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Thanks again for all of the help!</p>",
        "id": 249174977,
        "sender_full_name": "Sam",
        "timestamp": 1628719221
    },
    {
        "content": "<p>Regarding the speed, <code>finish</code> is often a slow tactic</p>",
        "id": 249176136,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628719853
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.rotate_eq_iff/src\">src#list.rotate_eq_iff</a></p>",
        "id": 249176163,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628719877
    },
    {
        "content": "<p>That's how that lemma is proven in more generality in mathlib (by yours truly)</p>",
        "id": 249176226,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628719919
    },
    {
        "content": "<p>That doesn't look like a comparable statement to me</p>",
        "id": 249176380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628719993
    },
    {
        "content": "<p>Your <code>norm_cast</code> isn't doing much. Instead of <code>fconstructor</code>, which is a very low-level tactic, it is more customary to use <code>split</code>.</p>",
        "id": 249176402,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628720010
    },
    {
        "content": "<p>Ah I must have misread it. I see.</p>",
        "id": 249176509,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628720070
    },
    {
        "content": "<p>I don't think the <code>l.length &gt; 1</code> hypothesis is needed for it to be true?</p>",
        "id": 249176587,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628720112
    },
    {
        "content": "<p>Oh I think that you're right about <code>l.length &gt; 1</code> not being needed! That's a holdover from a previous version of a slightly different lemma. I do use it in the proof to verify that the indices are in range, but I suppose I should just special case length 0 and length 1.</p>",
        "id": 249178984,
        "sender_full_name": "Sam",
        "timestamp": 1628721687
    },
    {
        "content": "<p><code>finish</code> being slow is interesting. Those mostly appeared out of me lazily doing <code>hint</code> so I'll try to replace those with something faster.</p>",
        "id": 249179089,
        "sender_full_name": "Sam",
        "timestamp": 1628721750
    },
    {
        "content": "<p>I'm quite surprised that nobody said that anything more drastic was wrong! Would this be considered a reasonably proof? If hypothetically this theorem were being put into mathlib, what would need to change to bring it up to standard?</p>",
        "id": 249179315,
        "sender_full_name": "Sam",
        "timestamp": 1628721924
    },
    {
        "content": "<p>I don't know much about the policy for what gets added to mathlib. I just did this for fun and learning, but is it something that it might be worth turning into a PR or would mathlib not want it?</p>",
        "id": 249179411,
        "sender_full_name": "Sam",
        "timestamp": 1628721992
    },
    {
        "content": "<p>I'll look at that <code>fconstructor</code> / <code>split</code> thing now! Thanks! I got <code>fconstructor</code> from <code>hint</code>, which didn't offer me <code>split</code>. Is there a reason for that?</p>",
        "id": 249179573,
        "sender_full_name": "Sam",
        "timestamp": 1628722106
    },
    {
        "content": "<p>I've been able to turn the final <code>finish</code> into a nice <code>exact h₂ (false.rec (n % list.length l = 0) (this hl₂)),</code> by first using <code>solve_by_elim</code> instead, then using <code>show_term</code> and inlining it.</p>\n<p>The other three <code>finish</code>s are giving me a bit more trouble, and <code>show_term</code> on them gives me some 20 line monstrosity. I'm leaving them as <code>finish</code> for now, but if anyone has any tips on how to tidy them up into something that runs faster without being verbose or ugly I'd appreciate it!</p>",
        "id": 249183218,
        "sender_full_name": "Sam",
        "timestamp": 1628724894
    },
    {
        "content": "<p>Here's how I would phrase this lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.rotate</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nodup.rotate_eq_self_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">l.nodup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.rotate</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">l.length.zero_le.eq_or_lt</span> <span class=\"k\">with</span> <span class=\"n\">hl'</span> <span class=\"n\">hl'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">length_eq_zero</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hl'</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nodup_iff_nth_le_inj</span> <span class=\"n\">at</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hl</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"n\">hl'</span><span class=\"o\">)</span> <span class=\"n\">hl'</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">nth_le_rotate'</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"n\">hl'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">,</span> <span class=\"n\">nat.mod_self</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">|</span><span class=\"n\">h</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">rotate_mod</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">rotate_zero</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n</code></pre></div>",
        "id": 249195849,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628741276
    },
    {
        "content": "<p>Wow thank you <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>! That is so much cleaner than mine! I won't be able to properly study what you've done until later, but this is an incredibly valuable learning resource.</p>",
        "id": 249202890,
        "sender_full_name": "Sam",
        "timestamp": 1628751297
    },
    {
        "content": "<p>In runs in a fraction of a second compared to 10 seconds for mine, too. I guess those tactics really were doing me in!</p>",
        "id": 249203004,
        "sender_full_name": "Sam",
        "timestamp": 1628751415
    }
]
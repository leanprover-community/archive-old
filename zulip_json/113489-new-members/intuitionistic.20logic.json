[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notnotLEM</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">¬¬</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">):=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n       <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"c\">/-</span><span class=\"cm\">  now what? -/</span>\n\n\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>push_neg  takes a  non-intuitionistic step.   How can I  push the negation into h  but don't erase the resulting double negation.<br>\nI wrote a couple of such rules myself.      The tactic 'finish'  can't do this one,  which I really expected it to do.    It is about as<br>\nhard to predict as Alexa--sometimes it works very well and other times it is lame.</p>",
        "id": 223857812,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611553686
    },
    {
        "content": "<p>it's a tricky proof, and mathlib doesn't have any tactics that do intuitionistic proof search so you'll have to prove it yourself. The hint is to prove <code>\\neg x \\in t</code></p>",
        "id": 223858232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611554332
    },
    {
        "content": "<p>Michael, <code>push_neg</code> is the opposite of what you are doing. This tactic was written explicitly for teaching mathematics without any focus on exotic logic. For your specific need you can either create specific tools or go back to basics (here that would probably be <code>rw not_or_distrib</code>).</p>",
        "id": 223864900,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611561802
    },
    {
        "content": "<p>Doesn't it need a bit more setup prior to attempting the proof?  For example <code>M</code> is not declared and you have <code>t m : M</code> followed by <code>x ∈ t</code> which is a little bit problematic unless <code>M</code> is some kind of lattice.  In any event <code>M</code> needs to have <code>∈ </code> defined, which it doesn't so far.  In this slight elaboration of the above sketch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>lemma notnotLEM (M: Type*): ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>\nbegin<br>\n  sorry,<br>\nend</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">we</span> <span class=\"n\">get</span> <span class=\"n\">the</span> <span class=\"n\">error</span>\n</code></pre></div>\n<p>failed to synthesize type class instance for<br>\nM : Type ?,<br>\nx t : M<br>\n⊢ has_mem M M</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Suppose</span> <span class=\"n\">we</span> <span class=\"n\">were</span> <span class=\"n\">to</span> <span class=\"n\">alter</span> <span class=\"n\">it</span> <span class=\"n\">slightly</span> <span class=\"n\">so</span> <span class=\"n\">that</span> <span class=\"bp\">`</span><span class=\"n\">M</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">set</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>import tactic</p>\n<p>universe u</p>\n<p>lemma notnotLEM1 (α: Type u) (M: set α): <br>\n  ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>\nbegin<br>\n    sorry,<br>\nend</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">it's</span> <span class=\"n\">still</span> <span class=\"n\">complaining</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">underlying</span> <span class=\"n\">type</span> <span class=\"n\">doesn't</span> <span class=\"k\">have</span> <span class=\"n\">membership</span> <span class=\"n\">constructed.</span>\n\n<span class=\"n\">So</span> <span class=\"k\">let</span><span class=\"bp\">'</span><span class=\"n\">s</span> <span class=\"k\">let</span> <span class=\"bp\">`</span><span class=\"n\">M</span><span class=\"bp\">`</span> <span class=\"n\">be</span> <span class=\"n\">sets</span> <span class=\"n\">of</span> <span class=\"n\">natural</span> <span class=\"n\">numbers</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>import tactic</p>\n<p>lemma notnotLEM2  (M: set ℤ): <br>\n  ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>\nbegin<br>\n    sorry,<br>\nend</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">it's</span> <span class=\"n\">still</span> <span class=\"n\">complaining</span> <span class=\"n\">because</span> <span class=\"n\">you</span> <span class=\"k\">have</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">`</span> <span class=\"n\">i.e.</span> <span class=\"n\">trying</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">one</span> <span class=\"n\">member</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">M</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"n\">element</span> <span class=\"n\">of</span> <span class=\"n\">another</span> <span class=\"n\">member</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">M</span><span class=\"bp\">`.</span>\n\n<span class=\"n\">We</span> <span class=\"n\">could</span> <span class=\"n\">try</span> <span class=\"n\">using</span> <span class=\"bp\">`</span><span class=\"n\">lattice</span><span class=\"bp\">`</span> <span class=\"n\">instead</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">set</span><span class=\"bp\">`</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>import tactic<br>\nimport order.lattice</p>\n<p>lemma notnotLEM3  (M: lattice ℤ): <br>\n  ∀ (x t:M), ¬¬ (x ∈ t ∨ ¬ x ∈ t):=<br>\nbegin<br>\n    sorry,<br>\nend</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">This</span> <span class=\"k\">then</span> <span class=\"n\">resolves</span> <span class=\"n\">the</span> <span class=\"n\">problem</span> <span class=\"k\">with</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">`</span> <span class=\"n\">but</span> <span class=\"n\">leads</span> <span class=\"n\">to</span> <span class=\"n\">a</span> <span class=\"n\">new</span> <span class=\"n\">and</span> <span class=\"n\">confusing</span> <span class=\"n\">to</span> <span class=\"n\">me</span> <span class=\"n\">error</span> <span class=\"n\">that</span> <span class=\"n\">for</span> <span class=\"n\">type</span> <span class=\"bp\">`</span><span class=\"n\">M</span><span class=\"bp\">`</span> <span class=\"n\">we</span> <span class=\"n\">can</span> <span class=\"n\">no</span> <span class=\"n\">longer</span> <span class=\"n\">use</span> <span class=\"n\">the</span> <span class=\"n\">type</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">`.</span>  <span class=\"n\">We</span> <span class=\"n\">get</span> <span class=\"n\">this</span> <span class=\"n\">error</span> <span class=\"n\">at</span> <span class=\"n\">the</span> <span class=\"n\">colen</span> <span class=\"k\">in</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"bp\">`</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>type expected at<br>\n  M<br>\nterm has type<br>\n  lattice ℤ</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">At</span> <span class=\"n\">this</span> <span class=\"n\">point</span> <span class=\"n\">you'd</span> <span class=\"k\">have</span> <span class=\"n\">to</span> <span class=\"n\">call</span> <span class=\"n\">an</span> <span class=\"n\">expert.</span>\n\n<span class=\"n\">My</span> <span class=\"n\">point</span> <span class=\"n\">being</span> <span class=\"n\">just</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">types</span> <span class=\"k\">have</span> <span class=\"n\">to</span> <span class=\"n\">be</span> <span class=\"n\">set</span> <span class=\"n\">up</span> <span class=\"n\">to</span> <span class=\"n\">support</span> <span class=\"n\">the</span> <span class=\"n\">language</span> <span class=\"n\">of</span> <span class=\"n\">membership</span> <span class=\"n\">that</span> <span class=\"n\">you</span> <span class=\"n\">are</span> <span class=\"n\">using</span> <span class=\"n\">before</span> <span class=\"n\">you</span> <span class=\"n\">can</span> <span class=\"n\">prove</span> <span class=\"n\">anything</span> <span class=\"n\">about</span> <span class=\"n\">that</span> <span class=\"n\">language.</span>\n\n<span class=\"n\">I</span> <span class=\"n\">am</span> <span class=\"n\">a</span> <span class=\"n\">beginner</span><span class=\"o\">,</span> <span class=\"n\">just</span> <span class=\"n\">guessing</span> <span class=\"n\">on</span> <span class=\"n\">above.</span>  <span class=\"n\">The</span> <span class=\"n\">drill</span> <span class=\"n\">for</span> <span class=\"n\">newcomers</span> <span class=\"n\">is</span> <span class=\"n\">to</span> <span class=\"n\">read</span> <span class=\"n\">and</span> <span class=\"k\">do</span> <span class=\"n\">the</span> <span class=\"n\">exercises</span> <span class=\"n\">closely</span> <span class=\"k\">in</span> <span class=\"n\">these</span> <span class=\"n\">two</span> <span class=\"n\">sites</span> <span class=\"n\">before</span> <span class=\"n\">trying</span> <span class=\"n\">to</span> <span class=\"k\">do</span> <span class=\"n\">anything</span> <span class=\"n\">complicated</span><span class=\"o\">:</span>\n\n<span class=\"bp\">*</span> <span class=\"bp\">#</span><span class=\"n\">nng</span>\n<span class=\"bp\">*</span> <span class=\"bp\">#</span><span class=\"n\">tpil</span>\n</code></pre></div>",
        "id": 223904858,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611585342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span>, I think the correction you were trying to make is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notnotLEM</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">¬¬</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">):=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>that is, changing <code>t</code> to be a <code>set</code> but leaving <code>x</code> alone.</p>",
        "id": 223906015,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611585868
    },
    {
        "content": "<p>You don't need a lattice for this to typecheck, but you do need <code>has_mem M M</code>. The original statement is not self contained though so it's possible something equivalent to this is above the lemma in Michael Beeson's version (which is why <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>'s are important)</p>",
        "id": 223908040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611586714
    },
    {
        "content": "<p>For example based on <a href=\"#narrow/stream/113489-new-members/topic/introducing.20a.20weird.20less-than.20symbol/near/221327819\">this</a> I expect that he has <code>(M : Type*) [Model M]</code> in the variables and <code>instance [Model M] : has_mem M M</code></p>",
        "id": 223908321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611586843
    },
    {
        "content": "<p>In any case, <code>x \\in t</code> is just window dressing in this theorem. It may as well be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notnotLEM</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬¬</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">):=</span>\n  <span class=\"kd\">begin</span>\n       <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"c\">/-</span><span class=\"cm\">  now what? -/</span>\n\n\n  <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 223908602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611586941
    },
    {
        "content": "<p>Mario, not to be a pain, but can you make your sketch into an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?  How do you <code>assume x t</code> when they are not declared?</p>",
        "id": 223909378,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611587254
    },
    {
        "content": "<p>fixed</p>",
        "id": 223909408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587267
    },
    {
        "content": "<p>So we already have intuitionistic logic by default.  Just don't <code>open classical</code>?</p>",
        "id": 223909525,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611587307
    },
    {
        "content": "<p>actually that doesn't do very much besides make it easier to refer to some theorems that you shouldn't use here</p>",
        "id": 223909599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587344
    },
    {
        "content": "<p>It's not as simple as that. Some tactics are classical. Try to find a proof and then at the end <code>#print axioms notnotLEM</code> and check that the output is empty.</p>",
        "id": 223909671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587370
    },
    {
        "content": "<p>or at least that it doesn't use <code>classical.choice</code></p>",
        "id": 223909724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587395
    },
    {
        "content": "<p>whether quotient types and/or propext are considered intuitionistic depend on your denomination of intuitionism</p>",
        "id": 223909892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587459
    },
    {
        "content": "<p>I've just done this one. It's the same trick as the <code>not (p and not p)</code> question which comes up on a semi-regular basis. Are there any harder ones? My favourite so far was proving that various things were equivalent to LEM -- there's a list in the Software Foundations book and the question was marked super-hard.</p>",
        "id": 223910099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587547
    },
    {
        "content": "<p>I think you mean <code>not (p iff not p)</code></p>",
        "id": 223910142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587567
    },
    {
        "content": "<p>yeah, my one is much easier isn't it. Shows how little feeling I have for this stuff.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">notnotLEM</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>\n<p>is what you're after Lars.</p>",
        "id": 223910219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587609
    },
    {
        "content": "<p>Given that intuitionistic logic actually has an infinite lattice of truth values (even with only one indeterminate), I would think that there are actually long and interesting intuitionistic theorems, but these two examples are the hardest I know and they are pretty easy, objectively speaking</p>",
        "id": 223910430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587702
    },
    {
        "content": "<p>Bottom of <a href=\"https://softwarefoundations.cis.upenn.edu/lf-current/Logic.html\">https://softwarefoundations.cis.upenn.edu/lf-current/Logic.html</a> is the challenge I remember enjoying as a beginner. My strategy was to knock off four very easy proofs that LEM implied all of them, and then prove LEM from each of them.</p>",
        "id": 223910539,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587756
    },
    {
        "content": "<p>It's fun to come up with proofs and counterexamples for all the basic logic theorems</p>",
        "id": 223910541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587757
    },
    {
        "content": "<p>lol there are no counterexamples</p>",
        "id": 223910598,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587771
    },
    {
        "content": "<p>the counterexamples are actually more mindbending than the proofs</p>",
        "id": 223910604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587774
    },
    {
        "content": "<p>You need kripke frames</p>",
        "id": 223910641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587788
    },
    {
        "content": "<p>all the theorems are true, you just can't prove them because you're missing some axioms</p>",
        "id": 223910647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587792
    },
    {
        "content": "<p>If you believe Brouwer, they are real counterexamples.</p>",
        "id": 223910676,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1611587809
    },
    {
        "content": "<p>It's a godel completeness kind of situation</p>",
        "id": 223910679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587810
    },
    {
        "content": "<p>Never trust a mathematician who doesn't believe their own theorems</p>",
        "id": 223910732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587845
    },
    {
        "content": "<p>you just need more advanced models to capture the intuitionistic theorems instead of the classical ones</p>",
        "id": 223910737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587849
    },
    {
        "content": "<p>oh wait, I started on this whole Lean thing because I was worried about my own theorems...</p>",
        "id": 223910773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587864
    },
    {
        "content": "<p>Learning about the models also gives you a better sense for how to predict that a theorem won't be intuitionistically provable</p>",
        "id": 223910846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587887
    },
    {
        "content": "<p>for example topological models, where truth values are open sets and negation is the interior of the complement</p>",
        "id": 223910910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587922
    },
    {
        "content": "<p>it makes it easy to see why <code>p \\/ ~p</code> should not hold</p>",
        "id": 223910940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611587942
    },
    {
        "content": "<p>how come nobody from paraconsistent logic ever shows up here? Don't they believe p and not p, or something?</p>",
        "id": 223911031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611587987
    },
    {
        "content": "<p>or is it p iff not p</p>",
        "id": 223911097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611588003
    },
    {
        "content": "<p>Relevance logic is fun, that's a paraconsistent logic that you see sometimes on the FOM mailing list</p>",
        "id": 223911156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588024
    },
    {
        "content": "<p>it rejects <code>A -&gt; ~A -&gt; B</code> because <code>B</code> comes \"out of nowhere\"</p>",
        "id": 223911227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588054
    },
    {
        "content": "<p>I think I'll go back to condensed sets</p>",
        "id": 223911250,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611588064
    },
    {
        "content": "<p>But lean really <em>isn't</em> a playground for arbitrary logics, intuitionistic logic just has a special place here because MLTT is a direct descendent of intuitionism a la brouwer</p>",
        "id": 223911661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588237
    },
    {
        "content": "<p>Can we please prove that <a href=\"https://www.jstor.org/stable/20013984?seq=1\">if God possibly exists, then God necessarily exists</a>?</p>",
        "id": 223911663,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611588237
    },
    {
        "content": "<p>in particular lean is also hostile to modal logic</p>",
        "id": 223911748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588264
    },
    {
        "content": "<p>(also in that paraphrasing of the argument you forgot the six or so questionable axioms about goodness used in the proof)</p>",
        "id": 223911936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588349
    },
    {
        "content": "<p>Don't leave <a href=\"https://mitpress.mit.edu/books/model-checking-second-edition\">temporal logic</a> out.  Any kind of logic should be expressible in Lean as a new mathematical structure, it just won't proof automation tuned to that logic.  A new logic should be like any other structured like <code>ring</code> or <code>lattice</code>.  You just add the axioms for that logic in the structure definition.  Am I right?</p>",
        "id": 223912036,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611588377
    },
    {
        "content": "<p>I think there is an isabelle formalization of that argument (or was it a different one?)</p>",
        "id": 223912066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588393
    },
    {
        "content": "<p>Sure, lean can do natural numbers so it can represent any logic as a deep embedding. I'm talking about the shallow embedding, where the actual axioms of lean matter</p>",
        "id": 223912196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588442
    },
    {
        "content": "<p>In a deep embedding, it doesn't really matter what axioms the meta logic has. PA can model ZFC, ZFC can model HOTT, HOTT can model modal logic, and you can freely mix and match</p>",
        "id": 223912477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588553
    },
    {
        "content": "<p>If I've translated the software foundations exercises correctly, then these four theorems should all be provable constructively:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lem</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_peirce</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n  <span class=\"o\">((</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_double_negation_elimination</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"bp\">¬¬</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_de_morgan_not_and_not</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_implies_to_or</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 223912480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611588554
    },
    {
        "content": "<p>that's correct (those are all iffs, although the reverse implication is just the classical proof)</p>",
        "id": 223912676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611588629
    },
    {
        "content": "<p>Given that it's trivial to show all the things applying LEM are true classically (just check the truth tables), these things are all hence constructively equivalent to LEM.</p>",
        "id": 223912683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611588632
    },
    {
        "content": "<p>These are easy.  They all have about the same proof.  Am I doing something wrong?  I didn't <code>open classical</code>.  Is this intuitionist?  Or are we missing a lattice and a typeclass of <code>intuitionistic_logic</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lem</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_peirce</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n  <span class=\"o\">((</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">Q</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hQ</span><span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"n\">hQ</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"n\">hQ</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_double_negation_elimination</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"bp\">¬¬</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">P1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">lem</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hP</span><span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_de_morgan_not_and_not</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">P1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">lem</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hP</span><span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lem_of_implies_to_or</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">lem</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hP</span><span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 223916578,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611590182
    },
    {
        "content": "<p>That is, does the above respond to the original problem, or is it something fancier?</p>",
        "id": 223916700,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611590232
    },
    {
        "content": "<p><code>by_cases</code> assumes LEM</p>",
        "id": 223917031,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611590381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/223916700\">said</a>:</p>\n<blockquote>\n<p>That is, does the above respond to the original problem, or is it something fancier?</p>\n</blockquote>\n<p>You can ask Lean this question by writing <code>#print axioms lem_of_peirce</code>. Since it outputs <code>classical.choice</code>, you did use choice in your proof.</p>",
        "id": 223919195,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1611590974
    },
    {
        "content": "<p>Yes,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">lem_of_peirce</span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">classical.choice</span>\n<span class=\"n\">quot.sound</span>\n<span class=\"n\">propext</span>\n</code></pre></div>\n<p>So is it fair to say that if <span class=\"user-mention\" data-user-id=\"284844\">@Michael Beeson</span>  rewrites the above proofs without <code>by_cases</code>, then his original problem is addressed?  I.e., no need to define <code>intuitionistic_logic</code> as a structure with lattice-valued propositions or something like that?</p>",
        "id": 223919592,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611591124
    },
    {
        "content": "<p>You just need to prove this theorem using <code>intro</code>, <code>apply</code>, and things like <code>or.inl</code> and <code>or.inr</code> (or <code>left</code> and <code>right</code>), and <code>have</code> if you want. Such a proof will be intuitionistic.</p>",
        "id": 223919969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611591272
    },
    {
        "content": "<p>also <code>cases</code> and/or <code>and.left</code> and <code>and.right</code> on the one with conjunction</p>",
        "id": 223920059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611591314
    },
    {
        "content": "<p>I assure you that lattices are not involved</p>",
        "id": 223920130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611591347
    },
    {
        "content": "<p>Also, you should notice that in your proof you never use any of the assumptions, you are just proving <code>lem</code> outright, which should give you a hint that something is wrong</p>",
        "id": 223920490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611591465
    },
    {
        "content": "<p>Here's an answer to my own question:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notnotLEM</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"bp\">¬¬</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">):=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬¬</span> <span class=\"n\">P</span><span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">ifinish</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">ifinish</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>In short,  ifinish can do this in two steps.</p>",
        "id": 223923853,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611592613
    },
    {
        "content": "<p>Nope, check the axioms</p>",
        "id": 223923965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611592671
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">notnotLEM</span>\n<span class=\"c1\">-- propext</span>\n<span class=\"c1\">-- classical.choice</span>\n<span class=\"c1\">-- quot.sound</span>\n</code></pre></div>\n<p>yes, <code>ifinish</code> is broken (<a href=\"https://github.com/leanprover-community/mathlib/issues/1922\">#1922</a>)</p>",
        "id": 223924135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611592725
    },
    {
        "content": "<p>OK.   I have 30,000 lines of Lean code with hundreds of applications of  the 'ifinish'  tactic to finish off small goals.    I knew already <br>\nthat 'ifinish' will sometimes prove something that is not intuitionistically valid.   But what I have now learned is that it also will <br>\nprove an intuitionistically valid theorem  by a classical proof.    That means that my proofs are not intuitionistically valid after all.<br>\nSince I am not skilled in meta programming I don't think I'll be able to fix the broken tactic myself.   It looks like I will have to <br>\nsupply a list of basic intuitionistic logic theorems and use them myself by hand to fix all those proofs.</p>",
        "id": 223927741,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611594178
    },
    {
        "content": "<p>The manual proof of this theorem is not difficult, and most theorems are even easier than this one - generally intuitionistically valid theorems will have an \"obvious\" proof that is intuitionistic</p>",
        "id": 223929207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611594696
    },
    {
        "content": "<p>in general you should just be using the theorems in <code>logic.basic</code>, which are all intuitionistic where possible and use decidable hypotheses otherwise</p>",
        "id": 223929348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611594752
    },
    {
        "content": "<p>If you want to know that your theorems are intuitionistic, always use <code>#print axioms</code> because you never know if a tactic snuck one past you (especially if you are using high powered tactics like <code>finish</code>)</p>",
        "id": 223929601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611594849
    },
    {
        "content": "<p>This may sound like a joke, but...are there any software applications whose verification requires intuitionistic logic for physical safety?</p>\n<p>If there were, then the matter of strictly being able to control what axioms are available in the namespace would take on more importance.  For example, in addition to <code>open classical</code>, you might want to introduce a directive <code>prohibit classical</code> which forces tactics to throw an error if they use LEM or try to open that namespace.</p>",
        "id": 223930074,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611595053
    },
    {
        "content": "<p>Probably a <code>@[restrict_axioms [axioms, here]]</code> attribute is the best way to achieve that goal, if it's a goal anyone really has - it can then just do the equivalent of <code>#print axioms</code> and verify that it contains only the provided axioms.</p>",
        "id": 223930383,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611595179
    },
    {
        "content": "<blockquote>\n<p>are there any software applications whose verification requires intuitionistic logic for physical safety?</p>\n</blockquote>\n<p>It depends on how the logic is interpreted. If it is used to express things that are true and false about the behavior of a program or physical system, then I would say no - classical logic is admissible for such applications. If however there is some other aspect of the logic being invoked, for example the \"computability\" of the proofs or the inability to make certain kinds of statements a la HoTT, enabling more unusual models that don't literally read the theorems as stated, then these alternate logics can in fact capture something beyond classical logic</p>",
        "id": 223930638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595272
    },
    {
        "content": "<p>One way to do it would be a command like <code>#lint</code> that checks all theorems in the current file for intuitionism unless they have <code>@[classical]</code> or some such</p>",
        "id": 223930944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595399
    },
    {
        "content": "<p>Not strictly analogous but a few examples of connections of logical modelling to real-world:</p>\n<ul>\n<li>Chee Yap's <a href=\"https://cs.nyu.edu/exact/\">zero project</a>, using real algebraic number arithmetic to never confuse left and right.</li>\n<li>Ed Clarke's <a href=\"https://link.springer.com/chapter/10.1007/978-3-540-69850-0_1\">temporal logic applied to VLSI design</a></li>\n</ul>\n<p>So what I'm asking, loosely, is if there is a real-world application and rationale for excluding LEM.  Or in general why is it an interesting project to exclude LEM.  Not being facetious.  I just don't honestly know why it's a thing.</p>",
        "id": 223931103,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611595460
    },
    {
        "content": "<p>When I did this a few months ago with the core library, I just grepped for all theorem names in the file and edited a big list of <code>#print axioms</code> at the end</p>",
        "id": 223931110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595461
    },
    {
        "content": "<p>Constructivism is a thing</p>",
        "id": 223931184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595494
    },
    {
        "content": "<p>you can literally run proofs that don't use choice</p>",
        "id": 223931234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595515
    },
    {
        "content": "<p><code>#reduce</code> will do this in lean</p>",
        "id": 223931248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595521
    },
    {
        "content": "<p>That said I'm not going to defend it too hard, it's mostly a puzzle game for me</p>",
        "id": 223931413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595601
    },
    {
        "content": "<p>it's interesting to use less axioms when you can</p>",
        "id": 223931445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595622
    },
    {
        "content": "<p>However the list of axioms strongly influences the kinds of subsystems you will try to study. In metamath, I did a lot of stuff with avoiding the axiom of choice (obvious) but also the axiom of foundation (turns out it's never needed for anything) and the axiom of replacement (this one is pretty important but you can still do a fair bit). In lean all of that is off the table because we have ZF+U right out the door even with <code>no axioms</code></p>",
        "id": 223931733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611595754
    },
    {
        "content": "<p>On the other hand, in metamath (or at least <a href=\"http://us.metamath.org/mpeuni/mmset.html\">set.mm</a>), the very first axioms are the 3 axioms of classical logic, so intuitionism / no-LEM is not even considered, while in lean that's actually a thing you can try to pursue. (There is however an alternate axiomatization, <a href=\"http://us.metamath.org/ileuni/mmil.html\">iset.mm</a>, that I created specifically to investigate intuitionistic and minimal logic, as well as IZF and CZF. Lean doesn't support those kinds of axiomatic investigations.)</p>",
        "id": 223932514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596070
    },
    {
        "content": "<p>On the topic of <code>classical</code>, is it the case that in general, <code>nonempty α</code> is not decidable? Under what constraints is it? I'm trying to see if I can make some variant of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.subtype_of_fintype/src\">src#fintype.subtype_of_fintype</a> lose the noncomputability.</p>",
        "id": 223932670,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611596147
    },
    {
        "content": "<p>It's as decidable as any arbitrary proposition</p>",
        "id": 223932745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596173
    },
    {
        "content": "<p>which is to say, not in general</p>",
        "id": 223932764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596180
    },
    {
        "content": "<p>specifically, <code>nonempty (plift p) &lt;-&gt; p</code></p>",
        "id": 223932804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596199
    },
    {
        "content": "<p>I think the most appropriate variant on <code>fintype.subtype_of_fintype</code> would be to add a <code>decidable_pred p</code> assumption</p>",
        "id": 223933012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596287
    },
    {
        "content": "<p>How would you modify this then? Or avoid it entirely in the <code>decidable_pred</code> version of <code>fintype.subtype_of_fintype</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">of_injective</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">classical.dec</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n<span class=\"k\">if</span> <span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"k\">then</span> <span class=\"kd\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">classical.inhabited_of_nonempty</span> <span class=\"n\">hα</span><span class=\"bp\">;</span>\n  <span class=\"n\">exact</span> <span class=\"n\">of_surjective</span> <span class=\"o\">(</span><span class=\"n\">inv_fun</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inv_fun_surjective</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"k\">else</span> <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hα</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 223933534,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611596534
    },
    {
        "content": "<p>Like, adding a <code>[decidable_eq α]</code> and using the inverse from <a href=\"https://github.com/leanprover-community/mathlib/issues/5872\">#5872</a>?</p>",
        "id": 223933590,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611596565
    },
    {
        "content": "<p>Probably avoid it entirely. The direct proof is simpler, because you can use <code>univ.filter p</code> as the witness</p>",
        "id": 223934050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596775
    },
    {
        "content": "<p>There is an analogue of this for <code>of_injective</code> but the decidability assumption is more complicated</p>",
        "id": 223934137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596814
    },
    {
        "content": "<p>If you're looking for decision procedures for sublanguages of set theory that you could tuck into Lean, there's a whole cottage industry for that, I linked a few papers <a href=\"#narrow/stream/113489-new-members/topic/What.20is.20a.20deterministic.20timeout/near/219470104\">here</a>.</p>\n<p>The point of my question was not really to question utility of excluding LEM but rather to point out that, if there is a material requirement for that in a program verification system (canonical example: 737MAX autopilot), then the fact that  <span class=\"user-mention\" data-user-id=\"284844\">@Michael Beeson</span>  has 30,000 lines of proof that he thought were LEM-free but are not would be a significant fail in a real world application.  This raises the utility of <code>restrict axioms</code> or similar.</p>",
        "id": 223934198,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611596844
    },
    {
        "content": "<p>Decision procedures? Not really. Most of the interesting subsystems are undecidable. But a collection of theorems proved under minimal assumptions is useful</p>",
        "id": 223934322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611596905
    },
    {
        "content": "<p>Lean + mathlib is currently not geared toward intuitionistic logic. The base axiom system, dependent type theory, draws on intuitionism, but if you actually care about intuitionistic or constructive mathematics you should use coq instead</p>",
        "id": 223934581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611597014
    },
    {
        "content": "<p>The user base doesn't care about constructive logic, and as you've already pointed out it's not really needed for applications. There is the notion of <code>noncomputable</code> which is drawn at the (IMO much more useful) distinction of whether lean can generate executable code for the definition</p>",
        "id": 223934790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611597117
    },
    {
        "content": "<p>Mario and I are talking about this notnotLEM as if everyone knows how to solve it constructively, but in case anyone this thread is actually hoping someone will post a solution, here's what I came up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notnotLEM</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"bp\">¬¬</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">):=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">left</span><span class=\"o\">,</span>\n      <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">right</span><span class=\"o\">,</span>\n    <span class=\"n\">assumption</span>\n  <span class=\"kd\">end</span>\n\n  <span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">notnotLEM</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>\n<p>The trick is to prove not P first. This is the same trick as the not (P iff not P) puzzle in TPIL. The four problems I posted earlier should also be solvable nonconstructively.</p>\n<p>Regarding <code>ifinish</code>, everyone always says \"well nobody really uses it and so what's the point fixing it\" but could it be the case that there's just a one liner which makes it far more likely to be constructive? <code>ifinish</code> seems to call<code> finish</code> with <code>{classical := ff}</code>. Do people actually understand what the issue is or it is just <code>WONTFIX</code>? Edit: Oh, I see Jeremy looked at this seriously in <a href=\"https://github.com/leanprover-community/mathlib/issues/1922\">#1922</a> . Hmm.</p>",
        "id": 223938618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611598822
    },
    {
        "content": "<p>there is some discussion about this on the issue</p>",
        "id": 223938751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611598886
    },
    {
        "content": "<p>some of it was oversight in the implementation but there is also a part that requires C++ changes</p>",
        "id": 223938797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611598911
    },
    {
        "content": "<p>\"Fixing this leak could be a decent medium-sized project for anyone interested in learning tactic programming.\"</p>",
        "id": 223938887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611598938
    },
    {
        "content": "<p>Perhaps for someone in Michael's situation it might be easier to just write a new tactic, which blunders through some known techniques e.g. uses some simp set consisting of all the constructive lemmas in logic.basic?</p>",
        "id": 223939143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611599053
    },
    {
        "content": "<p>and the obligatory golfed version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notnotLEM</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬¬</span><span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">or.inr</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"bp\">∘</span> <span class=\"n\">or.inl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 223939242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611599109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/223934322\">said</a>:</p>\n<blockquote>\n<p>Decision procedures? Not really. Most of the interesting subsystems are undecidable. But a collection of theorems proved under minimal assumptions is useful</p>\n</blockquote>\n<p>It depends on the meaning of \"interesting\", for example \"The class of unquantified formulae of set theory involving Boolean operators, the powerset and singleton operators, and the equality and membership predicates is shown to have a solvable satisfiability problem.  It is shown that whenever a formula φ in the above class is satisfiable there exists a hereditarily finite model of φ, whose rank is bounded by a doubly exponential expression in the number of variables<br>\noccurring in φ. \"</p>\n<p>So if you are writing procedures like <code>finish</code> and <code>ring</code> and are permitted to embed magic widgets in them that solve certain subsets of expressions, for example the subset described above, then it is at least useful to know</p>\n<ul>\n<li>That there is a fully constructive/programmable decision procedure for that class of expression</li>\n<li>If the expression has more than a few variables in it, it's intractable</li>\n<li>Any other solution you might think of for that class of expressions is equally intractable</li>\n</ul>",
        "id": 223939274,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611599123
    },
    {
        "content": "<blockquote>\n<p>It depends on the meaning of \"interesting\"</p>\n</blockquote>\n<p>Put another way, if a theory is decidable then it is uninteresting, because a computer can solve all the problems so there is nothing left for me to do</p>",
        "id": 223939432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611599190
    },
    {
        "content": "<p>Do you not want to use <code>linarith</code> and <code>ring</code> and <code>finish</code> when you can?  There's enough heavy lifting to do out there without making trivial things hard when they don't have to be.</p>",
        "id": 223939595,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611599263
    },
    {
        "content": "<p>I don't care for doubly-exponential proofs of anything</p>",
        "id": 223939673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611599288
    },
    {
        "content": "<p>I know 3 people that got tenure just by cranking out papers like that.  It's a living.</p>",
        "id": 223939761,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611599325
    },
    {
        "content": "<p>it's nice to know these subsets are decidable in theory but it has very little practical application besides knowing that certain search strategies will terminate</p>",
        "id": 223939800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611599343
    },
    {
        "content": "<p>I may be mistaken, but \"decidability\" in lean usually refers to the presence of a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/decidable\">docs#decidable</a> instance right? So <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> isn't talking about tactics like <code>ring</code>, <code>linarith</code>, and <code>finish</code>?</p>",
        "id": 223939801,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611599343
    },
    {
        "content": "<p>No I mean decidable in the same sense as Lars, i.e. you can prove or disprove all problems in a class. <code>ring</code> is a decision procedure, as is <code>linarith</code>, but <code>finish</code> is a heuristic solving an undecidable problem</p>",
        "id": 223939926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611599400
    },
    {
        "content": "<p>In case anyone cares,  what I'm going to do about this is simply to go through my 16 files and manually replace all use of <br>\nifinish  with a few lines of code.  This is taking about,  I would guess,  one minute per occurrence,  and there were about forty in <br>\nthe file I'm working on now,  so it's a couple of days and then I'm done with it.    Also for the record I did not \"think these proofs were<br>\nLEM-free\",  I only thought \"these proofs ought to be LEM-free\".   I always knew I needed to \"check axioms\"  when I was done.   What <br>\nI didn't anticipate is that simple,  intuitionistically correct,  inferences would get classical proofs via ifinish.   Oh well,  it's just another speed bump.</p>",
        "id": 223961507,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611609428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284844\">@Michael Beeson</span> some time back <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> wrote some meta code for you to make this checking quite fast, I'm sure that will be useful here<br>\n<span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/not.20equals/near/209186002\">said</a>:</p>\n<blockquote>\n<p>Here is a super hacky way to print all the axioms used by everything in the current file. Import it and invoke it with <code>#axioms_all</code>. You could grep the output for <code>choice</code>.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.core</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">lean</span> <span class=\"n\">lean.parser</span>\n\n<span class=\"kd\">@[user_command]</span> <span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">axioms_all</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">interactive.parse</span> <span class=\"bp\">$</span> <span class=\"n\">tk</span> <span class=\"s2\">\"#axioms_all\"</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n   <span class=\"n\">e.fold</span> <span class=\"o\">(</span><span class=\"n\">return</span> <span class=\"o\">())</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">rest</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n     <span class=\"n\">when</span> <span class=\"o\">(</span><span class=\"n\">e.in_current_file</span> <span class=\"n\">d.to_name</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">emit_command_here</span> <span class=\"o\">(</span><span class=\"s2\">\"#check \"</span> <span class=\"bp\">++</span> <span class=\"n\">d.to_name.to_string</span><span class=\"o\">),</span>\n           <span class=\"n\">emit_command_here</span> <span class=\"o\">(</span><span class=\"s2\">\"#print axioms \"</span> <span class=\"bp\">++</span> <span class=\"n\">d.to_name.to_string</span><span class=\"o\">),</span>\n           <span class=\"n\">return</span> <span class=\"o\">()),</span>\n     <span class=\"n\">rest</span><span class=\"o\">),</span>\n   <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 223962254,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1611609779
    },
    {
        "content": "<p>I'm using that code.   Sometimes it works,  sometimes it generates \"not enough memory\"  messages.   But I'm just going to <br>\neliminate all uses of 'ifinish' and be done with it.</p>",
        "id": 223989399,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611626772
    },
    {
        "content": "<p>simp  also produces intuitionistically incorrect results.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span><span class=\"o\">:</span> <span class=\"bp\">¬¬</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">false</span><span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>Of course foo is not a correct result--that's irrelevant-- the point is that simp transforms h   incorrectly.    Since foo is not a theorem<br>\nI can't see what #check axioms foo would report.</p>\n<p>But one of my actual theorems makes use of simp,  and in that proof simp makes an incorrect step.</p>",
        "id": 223996088,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611635197
    },
    {
        "content": "<p>That's also to be expected, since <code>simp</code> uses all lemmas marked with the attribute <code>@[simp]</code> and we tag useful lemmas with that attribute regardless of whether they are intuitionistically valid.</p>\n<p>As a workaround, you could create a custom <code>simp</code> set using <a href=\"https://leanprover-community.github.io/mathlib_docs/commands.html#mk_simp_attribute\">command#mk_simp_attribute</a> that only contains intuitionistic lemmas. You can find some examples of its use in <code>mathlib</code> <a href=\"https://github.com/leanprover-community/mathlib/search?q=mk_simp_attribute\">here</a>.</p>",
        "id": 223997117,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1611636490
    },
    {
        "content": "<p>Was there a way that I could have discovered that (I mean that simp is possibly not intuitionistic)  by reading some piece of documentation?   I naively believed that as long as I did not explicitly \"turn on\" classical logic,  I would get only intuitionistic logic.   Thanks for pointing me to mk_simp_attribute.   That might be useful.   I didn't make all that much use of simp so I think I'll just go through and eliminate them.</p>",
        "id": 223997167,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611636581
    },
    {
        "content": "<p>Unfortunately, the population of Lean users interested in intuitionistic logic is low (or silent) enough that most of the documentation completely ignores these (valid) concerns. So I would suggest proceeding with the opposite prior: tactics and theorems assume classical logic unless explicitly mentioned otherwise. (That the documentation of <code>ifinish</code> doesn't mention that it's broken is an oversight which we'll hopefully fix soon.)</p>",
        "id": 224001318,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1611641953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284844\">Michael Beeson</span> <a href=\"#narrow/stream/113489-new-members/topic/intuitionistic.20logic/near/223997167\">said</a>:</p>\n<blockquote>\n<p>Was there a way that I could have discovered that (I mean that simp is possibly not intuitionistic)  by reading some piece of documentation? </p>\n</blockquote>\n<p>The technical answer is yes: the <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#simp\">documentation of simp</a> says \"<code>simp</code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>.\" So, if you are interested in knowing which lemmas are used by <code>simp</code> you need to have a look at lemmas tagged with simp, such as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/not_not\">docs#not_not</a>.</p>\n<p>But the honest answer is no: I think there is nothing we could write that you would accept to understand and make you come out of your alternate reality. We tried to tell you so many times. mathlib is 470.000  lines of normal mathematics. Each time you load a file from mathlib you're summoning some of those 470.000 lines that will try to prevent you from staying intuitionist. Why are you doing that? Why not creating your own tactics or, much easier, use a tool like the Coq standard library or mathcomp that is designed for the kind of exotic math you're doing? There is nothing wrong with intuitionism, this is simply not what mathlib is doing. Do you complain about the documentation of your car that doesn't mention on every page that you shouldn't use it as a boat?</p>\n<p>All that being repeated, I still think we should entirely remove <code>ifinish</code> from mathlib. There is no point at all in keeping a tactic that is known to be so broken. I'll try to convince the other maintainers and I really apologize for the inconvenience.</p>",
        "id": 224013270,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611652555
    },
    {
        "content": "<p>Presumably it would be an entry-level <code>tactic</code> project to write a new <code>isimp</code> that only used simp lemmas that don't rely on <code>choice</code>? Obviously mathlib wouldn't use it much, but it would at least make it more viable for those looking for intuitionistic logic.</p>",
        "id": 224023698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611659097
    },
    {
        "content": "<p>I think there's no easy way to check the axioms used by a declaration in <code>meta</code> land.</p>",
        "id": 224024331,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1611659490
    },
    {
        "content": "<p>Oh, I didn't look at the code above for collecting axioms - indeed, it just uses <code>emit_command_here \"#print axioms\"</code>. Can meta-land code capture the output of <code>emit_command_here</code>?</p>",
        "id": 224024645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611659670
    },
    {
        "content": "<p>Since mathlib is by design classical, I wouldn't see the point. A library building something seriously intuitionistic in Lean should probably be something different from mathlib.</p>",
        "id": 224024744,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611659744
    },
    {
        "content": "<p>It seems a shame to throw out all of mathlib when intuitionistic users object to only parts of it. I wonder what fraction of our  ~50k theorems use choice. Even if it's 90%, getting a 5k theorem head-start still seems like an argument to build an intuitionistic library on top of mathlib rather than from scratch.</p>",
        "id": 224025042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611659940
    },
    {
        "content": "<p>A clear-cut choice seems much better from my point of view, as otherwise some people will get some expectations, and then they will be disappointed when they realize these expectations can not be met with mathlib. (This is a situation we can already see!)</p>",
        "id": 224025607,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611660306
    },
    {
        "content": "<p>Indeed there is no need for a thought experiment here: we <em>know</em> what happens when people try to use mathlib for intuitionistic maths.</p>",
        "id": 224025972,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611660521
    },
    {
        "content": "<p>See also <a href=\"https://github.com/leanprover-community/mathlib/issues/5897\">#5897</a>.</p>",
        "id": 224026451,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611660828
    },
    {
        "content": "<p>Regarding the other point Michael made, about <code>simp</code> -- are there any non-intuitionistic <code>simp</code> lemmas in core Lean 3? I ask because a proposal crystallising here is \"if you want to be 100% sure you are intuitionistic in lean then do not import any mathlib modules\", which sounds fair enough to me as we have made no attempt whatsoever to correctly document which tactics are intuitionistic (cf broken claims about ifinish which nobody has even bothered to fix). However if there is a single non-intuitionistic simp lemma in core then one interpretation of this is that actually lean 3 is not safe to use <em>at all</em> if you want to be sure you are intuitionistic. This would be a shame for Michael and others who want to use Lean in this way. Of course the converse argument is that one reason for the terrifying growth of mathlib is precisely because we are not held back by issues involving constructivism -- the deep-rooted classical foundations of mathlib have attracted more number theorists, geometers, analysts etc than the other systems.</p>\n<p>Of course there is also the other attitude, which given Michael's situation is probably the more pragmatic one, that he simply continues to use lean as he is doing and constantly runs <code>#print axioms</code> to make sure he is not selling his soul to Hilbert.</p>",
        "id": 224032277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611664651
    },
    {
        "content": "<blockquote>\n<p>\"if you want to be 100% sure you are intuitionistic in lean then do not import any mathlib modules\"</p>\n</blockquote>\n<p>If you want to be 100% sure you are intuitionistic in lean, a necessary and sufficient condition is to run <code>#print axioms</code></p>",
        "id": 224033510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665397
    },
    {
        "content": "<p>it's completely possible to do this while still using mathlib, and it's also possible to screw up when using core lean</p>",
        "id": 224033592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665441
    },
    {
        "content": "<p>There is a decent amount of intuitionistic maths in mathlib, it just isn't marked in any way, you need <code>#print axioms</code> to see it</p>",
        "id": 224033674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665511
    },
    {
        "content": "<p>It probably wouldn't be too hard to indicate it in docgen, if somehow can show me how to get the result of <code>#print axioms</code> in meta code</p>",
        "id": 224033769,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611665552
    },
    {
        "content": "<p>I'm not saying this is something we need to change</p>",
        "id": 224033794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665574
    },
    {
        "content": "<p>It means that we can still have a decent intuitionistic coverage without getting in the way of the 99% of users who don't want to be bothered about it</p>",
        "id": 224033878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665638
    },
    {
        "content": "<p>That said, pre-running <code>#print axioms</code> and displaying it in docgen is generally a good idea, that's been a selling point of the metamath web pages since the beginning</p>",
        "id": 224033978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665691
    },
    {
        "content": "<p>In principle this is useful to anyone who uses the <code>axiom</code> keyword (and uses doc-gen), not just intuitionist users</p>",
        "id": 224034025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611665722
    },
    {
        "content": "<p>well, <code>axiom</code> is more or less banned in mathlib, and docgen only works on mathlib AFAIK</p>",
        "id": 224034066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665751
    },
    {
        "content": "<p>I made docgen work on my own project with only a few lines of hacks in a shell script: <a href=\"https://github.com/pygae/lean-ga/blob/3027ba22a5698d0d2a9e4f497399a55027704aa9/.github/workflows/lean_doc.yml#L71-L73\">https://github.com/pygae/lean-ga/blob/3027ba22a5698d0d2a9e4f497399a55027704aa9/.github/workflows/lean_doc.yml#L71-L73</a></p>",
        "id": 224034143,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611665778
    },
    {
        "content": "<p>In third party projects I can definitely see the use, it means that people can see whether you've used extra axioms in your big theorem without having to boot up lean</p>",
        "id": 224034220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611665840
    },
    {
        "content": "<p>How hard would it be to put a # directive in Lean which causes any proof to fail which uses a specific axiom, so</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">prohibit</span> <span class=\"n\">classical.choice</span>\n</code></pre></div>\n<p>This seems like an easy hack. Then it wouldn't matter if a use was buried, the proof would just fail when it got to that use, and then you could rework the proof.  You wouldn't have to introspect so much on what is buried in the tactics and pre-existing proofs.</p>\n<p>An alternate approach would be to axiomatize multiple logics and try to factor out more the underlying axiomatic system.  For example, you could have system <code>I</code> (intuitionist), system <code>C</code> (classical) and system <code>Q</code> (whatever <a href=\"https://en.wikipedia.org/wiki/Q0_(mathematical_logic)\">that</a> is) and modal logics and temporal logics and so on.  I would have thought that could just be done inside the <code>class</code> mechanism.   However I guess there is some meta glue surrounding the process of proof checking such that the system of logic used is somewhat hard-wired.  Is Lean 4 more flexible in this regard?</p>",
        "id": 224040672,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611669007
    },
    {
        "content": "<p>Like I said, lean isn't cut out for this. It's not a logical foundation; the baseline axioms are already way stronger than most systems logicians care to study</p>",
        "id": 224040988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669146
    },
    {
        "content": "<p>Lean 4 is actually less flexible in this regard</p>",
        "id": 224041038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669178
    },
    {
        "content": "<p>Shouldn't we have a new documentation page and a new Zulip magic url so that you can stop repeating all this over and over? I'm pretty sure you could enjoy doing something else.</p>",
        "id": 224041260,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611669286
    },
    {
        "content": "<p>Lean 2 seriously entertained the possibility of alternate \"settings\" for the foundations, such as HoTT; lean 3 has a few vestigial remnants of this but is basically just one specific DTT foundation; and lean 4 is doubling down on this approach because mathlib has made the interest in this approach even less attractive</p>",
        "id": 224041319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669309
    },
    {
        "content": "<p>Will this scare off the computer scientists? Or are they expected to just #print axioms?</p>",
        "id": 224041539,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611669402
    },
    {
        "content": "<p>Maybe they actually run code or something? So I guess they notice then</p>",
        "id": 224041615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611669438
    },
    {
        "content": "<p>I'm not sure most computer scientists care about intuitionism</p>",
        "id": 224041618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669441
    },
    {
        "content": "<p>Certainly the kind of mathematics you see in algorithms classes is completely classical</p>",
        "id": 224041682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669472
    },
    {
        "content": "<p>it's just this one type theory offshoot community that cares about MLTT and its extensions that latch on to this particular notion of intuitionism</p>",
        "id": 224041853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669541
    },
    {
        "content": "<p>Am I right in thinking that one motivation behind \"running proofs\" is that you can extract a witness of existentials computably?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">foo</span>  <span class=\"c1\">-- prints a term which involves `2`</span>\n</code></pre></div>\n<p>Is there a way of doing this without either <code>classical</code> or <code>#reduce</code>, to get the result in a <code>def</code>?</p>",
        "id": 224041882,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611669555
    },
    {
        "content": "<p>Yeah, just use <code>{x // x*x = 4}</code> instead</p>",
        "id": 224041920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669581
    },
    {
        "content": "<p>basically in lean you decide upfront whether you care about the witness or not</p>",
        "id": 224042012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669612
    },
    {
        "content": "<p>Yeah, I understand that's a bad way to write it, I'm just asking out of curiousity.<br>\nI assume then there's no builtin computable <code>get_witness h</code> that requires <code>h</code> to be constructively proven?</p>",
        "id": 224042237,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611669714
    },
    {
        "content": "<p>I guess that would violate proof irrelevance</p>",
        "id": 224042307,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611669731
    },
    {
        "content": "<p>No, I'm answering your question</p>",
        "id": 224042499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669831
    },
    {
        "content": "<p>If you want to get the value without <code>classical</code> or <code>#reduce</code>, you make the lemma data-carrying by using <code>subtype</code> in place of <code>Exists</code></p>",
        "id": 224042591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669865
    },
    {
        "content": "<p>Yeah, that was the model I already had in my head</p>",
        "id": 224042646,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611669887
    },
    {
        "content": "<p><code>get_witness</code> would be inconsistent</p>",
        "id": 224042660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669895
    },
    {
        "content": "<p>that's basically <code>classical.choice</code> but it doesn't have the properties of a function</p>",
        "id": 224042709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611669917
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">get_witness</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">get_witness_ex</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">get_witness</span> <span class=\"n\">p</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">get_witness_ex</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">tt</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">get_witness_ex</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">ff</span> <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">bool.ff_ne_tt</span> <span class=\"o\">(</span><span class=\"n\">h2.symm.trans</span> <span class=\"n\">h1</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224043128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611670090
    },
    {
        "content": "<p>I was thinking something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.unquot\">docs#quotient.unquot</a> could exist, which works only in the vm</p>",
        "id": 224043387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611670209
    },
    {
        "content": "<p>Yeah, what I wrote could be implemented computably in the same way as <code>quotient.unquot</code>, although it would require propositions to carry data in the VM</p>",
        "id": 224043456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611670248
    },
    {
        "content": "<p>however it's inconsistent</p>",
        "id": 224043469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611670255
    },
    {
        "content": "<p>just like <code>quotient.unquot</code></p>",
        "id": 224043489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611670265
    },
    {
        "content": "<p>The way compilation works, a proof of <code>exists x, p x</code> is represented as <code>()</code>, i.e. nothing at all, meaning that a <code>get_witness</code> function in the VM would have nowhere to get the data</p>",
        "id": 224043685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611670342
    },
    {
        "content": "<p>So in a sense, the way to do constructive logic safely in lean is to use <code>trunc (subtype p)</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/trunc\">docs#trunc</a>) instead of <code>Exists p</code>, and something similar for disjunctions? Then you know your proofs are intuitionist because if they weren't you'd need <code>noncomputable</code>?</p>",
        "id": 224044251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611670575
    },
    {
        "content": "<p>I think it's seriously difficult to build a good formalized math library which supports both classical and constructive logic well; more difficult than just writing two independent libraries.</p>",
        "id": 224045141,
        "sender_full_name": "Reid Barton",
        "timestamp": 1611670967
    },
    {
        "content": "<p>If it's a single offending axiom (LEM), I don't get from this discussion why you can't just add a flag to throw an error when that axiom is invoked.  This is a simple solution, why wouldn't it be adequate?  The main complaint here is that <code>classical.choice</code> was invoked inadvertently.   It seems easy to flag, and doesn't require a large rethink of the design.</p>",
        "id": 224050312,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611673062
    },
    {
        "content": "<p>Well the obvious way to get an error on all uses of an axiom is to delete the axiom</p>",
        "id": 224054078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611674560
    },
    {
        "content": "<p>if you completely don't want it then it shouldn't be in the environment</p>",
        "id": 224054158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611674590
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> How do you know if you've touched that \"one axiom\"? It's not always clear that it's invoked. For reference, there was this cool thread <a href=\"#narrow/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound</a><br>\nwhere there are many ways to prove <code>em</code>.</p>",
        "id": 224054258,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611674630
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> , the advice so far has been to <code>#print axioms notnotLEM </code> and if it doesn't print <code>classical.choice</code>, then you're blessed as intuitionist.  So either that advice is wrong, or there is a fairly simple mechanism (whatever function/store accumulates results for <code>#print axioms</code> to inspect) which you can stick an exception/breakpoint into whenever it tries to add <code>classical.choice</code> to it's store.</p>\n<p>Or the advice is wrong.  But the claim above is that you know you've touched that one axiom <code>classical.choice</code> based on the <code>#print</code>.</p>\n<p>I'm assuming here also that for the proof checking mechanism, there is a list of axioms which is explicitly declared in the same sense that we declare properties in type classes.   If it's not so explicit, i.e. if it's a bunch of C++ code under the hood that encodes the axioms by hand, then that's a different story.</p>",
        "id": 224056299,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611675447
    },
    {
        "content": "<blockquote>\n<p>whatever function/store accumulates results for #print axioms to inspect</p>\n</blockquote>\n<p>There is no such store. When you use <code>#print axioms</code> it traverses the entire proof, and the entire proof of all referenced theorems and so on recursively, until it finds uses of <code>axiom</code> constants.</p>",
        "id": 224057773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611676016
    },
    {
        "content": "<blockquote>\n<p>I'm assuming here also that for the proof checking mechanism, there is a list of axioms which is explicitly declared in the same sense that we declare properties in type classes. If it's not so explicit, i.e. if it's a bunch of C++ code under the hood that encodes the axioms by hand, then that's a different story.</p>\n</blockquote>\n<p>Lean actually has both kinds of axiom. The kind that <code>#print axioms</code> picks up are those that were introduced with actual <code>axiom</code> invocations in the source. But there are other constants like <code>nat.rec</code> and <code>quot.mk</code> and definitional equality axioms like proof irrelevance and a countable hierarchy of universes that are built in to the C++, cannot be turned off, and do not show up in <code>#print axioms</code>. These are the \"no axioms\" axioms, and it's impossible to meaningfully do proofs with a subset of these axioms.</p>",
        "id": 224058500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611676239
    },
    {
        "content": "<p>Be that all as it may, if the project were to implement system <a href=\"https://en.wikipedia.org/wiki/Q0_(mathematical_logic)\">Q</a> as a <code>class</code> and prove theorems either in or about <code>Q</code>, without straying from the bounds of <code>Q</code>, is that doable in Lean?</p>\n<p>In other words, just as much as a <code>topology</code> or a <code>lattice</code> is a mathematical structure, something like <code>Q</code> is a mathematical structure, so what are the limits to reasoning about or in <code>Q</code> versus say the limits of reasoning about a topology or lattice?</p>\n<p>I hope the question isn't too fuzzy, it's a bit fuzzy in my mind, but you get the idea.</p>",
        "id": 224094059,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611691187
    },
    {
        "content": "<p>A model I've had in mind, but I'm not sure how accurate it is, is that if you want to be as constructive as possible then you should avoid <code>Prop</code> entirely.   Is this more or less a reasonable model?</p>\n<p>Something I've never been quite sure about with intuitionism is what the scope is of what needs to be constructible.  At a basic level, you can give a computation for an object and in that sense the object exists, but is it generally accepted that every aspect of the proof that this is the right object needs to be constructible as well? or is that a more of an extreme position?</p>\n<p>I like Lean's pragmatic approach where so long as a definition isn't <code>noncomputable</code> then that implies there's a construction.  It just might use not-incorrect inferences along the way.  I guess it seems meaningful to me having computable definitions (even if I'm never going to evaluate them), but avoiding choice in proofs seems more like a curiosity unless reverse mathematics is your specialty.</p>",
        "id": 224115557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1611700922
    },
    {
        "content": "<p>Just for the record,   my files do not import mathlib  and I knew that I could not expect mathlib to be intuitionistic. <br>\nI only have  import tactic.basic.      I had a mistaken idea about the behavior of those tactics.   I did not intend to be <br>\n\"complaining\"   (especially not that \"my car is not a boat\");  I'm grateful that Lean exists and I'm appreciative of the <br>\nwork that has been done on it.   When I asked if there was something I could/should have read to avoid my mistaken idea,<br>\nI did not mean to complain,  I just wanted to know if these things are written down somewhere.   The last thing I intended<br>\nwas to annoy anyone.  Thanks to all of you who have considered this issue.</p>",
        "id": 224139749,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611722538
    },
    {
        "content": "<p>We should keep an open mind.<br>\n<a href=\"/user_uploads/3121/roMe2wxp6QLsrveIqW72xiaU/BN-KK363_0922my_M_20150921164148.jpg\">BN-KK363_0922my_M_20150921164148.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/roMe2wxp6QLsrveIqW72xiaU/BN-KK363_0922my_M_20150921164148.jpg\" title=\"BN-KK363_0922my_M_20150921164148.jpg\"><img src=\"/user_uploads/3121/roMe2wxp6QLsrveIqW72xiaU/BN-KK363_0922my_M_20150921164148.jpg\"></a></div>",
        "id": 224142869,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1611726366
    },
    {
        "content": "<p>OK,  I still want to make sure my proofs are intuitionistic.   I seem to have two options.</p>\n<ol>\n<li>\n<p>continue to import tactic.basic,   but avoid simp, simp_rw,  and ifinish,   and check which axioms are used to make sure classical choice isn't.</p>\n</li>\n<li>\n<p>remove import tactic.basic from all my files.</p>\n</li>\n</ol>\n<p>Questions:   <br>\nQ1:   with option 2  is it correct that my proofs will all pass through an intuitionistic kernel  and it won't be necessary to \"check axioms\"? <br>\nAnd,  if that is the case,  </p>\n<p>Q2:   I will still need to eliminate the need for tactic  'use'  to  call exists.intro from tactic mode and leave a goal still to solve, since<br>\n'use'  is defined in tactic.basic.  </p>\n<p>Is that easy or hard?   </p>\n<p>and <br>\nQ3:  with option 1, i.e.  check axioms,   how airtight is the guarantee that the proof is intuitionistically correct?   I guess it does not quite<br>\nhave the certainty of passing through the kernel?   I am intending to publish  a proof,  and naturally I wish to be CERTAIN that it is <br>\ncorrect--that is why I am using Lean in the first place.</p>",
        "id": 224228848,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611773246
    },
    {
        "content": "<p>I think that the conclusion of the discussion above is that 2. is not going to solve your problems. LEM is defined as an axiom in core Lean, and this axiom cannot be overridden or removed. Having thought about this over the last few days, I personally think that the easiest path is simple: import tactic.basic, import what the heck you like. You can't make LEM go away, and nobody is able to <em>guarantee</em> that it won't randomly appear when you use a tactic like <code>simp</code> or even, unfortunately, <code>ifinish</code>. However I believe we _can_ guarantee that <code>#print axioms</code> will report on usage of nonintuitionistic things if it finds them. Apparently it's difficult to even get Lean to automatically check that no axioms are used automatically. But this kind of question can be solved. So in fact my instinct would be to continue to use both mathlib and the dubious tactics, and just keep checking that your proofs are intuitionistic. If they're not, then rewrite until they are.</p>",
        "id": 224229761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611773562
    },
    {
        "content": "<p>And be aware that the fact your proofs are intuitionistic today will not guarantee that they still are after updating lean / mathlib, as the simp set may have changed</p>",
        "id": 224230226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611773753
    },
    {
        "content": "<p>I know that Patrick was keen on just nuking <code>ifinish</code>, because it is dishonest to have a tactic which claims to do something that it does not do, and the user has to explicitly check that it did its job every time. Is there an example known where <code>finish</code> produces a non-intuitionistic proof and <code>ifinish</code>produces an axiom-free one?</p>",
        "id": 224230927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611773999
    },
    {
        "content": "<p>Is it possible to create <code>itheorem</code> which will error if the proof uses axioms?</p>",
        "id": 224233828,
        "sender_full_name": "Reid Barton",
        "timestamp": 1611775175
    },
    {
        "content": "<p><code>itheorem</code> is hard because it is a <code>def</code>-variant command, which means that you have to replicate all the parsing stuff that <code>def</code> does</p>",
        "id": 224240177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611778121
    },
    {
        "content": "<p>Maybe an attribute can do something similar though</p>",
        "id": 224240220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611778139
    },
    {
        "content": "<p>Here is a small MWE  on which checking axioms produces output  I cannot interpret.  What is going on here?   Is there an <br>\nerror in my Lean code?   The example<br>\nbegins with \"import barton\".   The contents of barton.lean will be pasted in below.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">barton</span>\n<span class=\"kd\">reserve</span> <span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">∈</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">49</span>\n\n<span class=\"kd\">class</span>  <span class=\"n\">Model</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">infix</span>  <span class=\"bp\">∈</span> <span class=\"o\">:=</span>  <span class=\"n\">mem</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">union_axiom</span><span class=\"o\">:</span>   <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">union</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">z</span><span class=\"o\">)))</span>\n <span class=\"c\">/-</span><span class=\"cm\"> end of class definition because next line doesn't declare a member -/</span>\n\n <span class=\"bp\">#</span><span class=\"n\">axioms_all</span>\n</code></pre></div>\n<p>Here is barton.lean </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.core</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">lean</span> <span class=\"n\">lean.parser</span>\n\n<span class=\"kd\">@[user_command]</span> <span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">axioms_all</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">interactive.parse</span> <span class=\"bp\">$</span> <span class=\"n\">tk</span> <span class=\"s2\">\"#axioms_all\"</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n   <span class=\"n\">e.fold</span> <span class=\"o\">(</span><span class=\"n\">return</span> <span class=\"o\">())</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">rest</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n     <span class=\"n\">when</span> <span class=\"o\">(</span><span class=\"n\">e.in_current_file</span> <span class=\"n\">d.to_name</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">emit_command_here</span> <span class=\"o\">(</span><span class=\"s2\">\"#check \"</span> <span class=\"bp\">++</span> <span class=\"n\">d.to_name.to_string</span><span class=\"o\">),</span>\n           <span class=\"n\">emit_command_here</span> <span class=\"o\">(</span><span class=\"s2\">\"#print axioms \"</span> <span class=\"bp\">++</span> <span class=\"n\">d.to_name.to_string</span><span class=\"o\">),</span>\n           <span class=\"n\">return</span> <span class=\"o\">()),</span>\n     <span class=\"n\">rest</span><span class=\"o\">),</span>\n   <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224362808,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611855229
    },
    {
        "content": "<p>Does putting a full stop after the definition of the class help?</p>",
        "id": 224362950,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611855278
    },
    {
        "content": "<p>No,  output does not change with a full stop.</p>",
        "id": 224363091,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611855334
    },
    {
        "content": "<p>What is the output?</p>",
        "id": 224363811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611855600
    },
    {
        "content": "<p>I get four infos and an error on the <code>#axioms_all</code> line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">info</span><span class=\"o\">:</span>\n<span class=\"n\">Model.cases_on</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Model</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span> <span class=\"bp\">→</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span> <span class=\"bp\">→</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"n\">union_axiom</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span> <span class=\"n\">mem</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">union</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span> <span class=\"n\">mem</span> <span class=\"n\">z</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">mem</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">),</span>\n       <span class=\"bp\">?</span><span class=\"n\">M_2</span> <span class=\"o\">{</span><span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"n\">mem</span><span class=\"o\">,</span> <span class=\"n\">union</span> <span class=\"o\">:=</span> <span class=\"n\">union</span><span class=\"o\">,</span> <span class=\"n\">union_axiom</span> <span class=\"o\">:=</span> <span class=\"n\">union_axiom</span><span class=\"o\">})</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">?</span><span class=\"n\">M_2</span> <span class=\"n\">n</span>\n\n<span class=\"n\">info</span><span class=\"o\">:</span>\n<span class=\"n\">no</span> <span class=\"kd\">axioms</span>\n\n<span class=\"n\">info</span><span class=\"o\">:</span>\n<span class=\"n\">Model.union_axiom</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span> <span class=\"n\">Model.mem</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">Model.union</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span> <span class=\"n\">Model.mem</span> <span class=\"n\">z</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">Model.mem</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n\n<span class=\"n\">info</span><span class=\"o\">:</span>\n<span class=\"n\">no</span> <span class=\"kd\">axioms</span>\n\n<span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">invalid</span> <span class=\"bp\">'</span><span class=\"n\">Model.no_confusion'</span> <span class=\"n\">application</span><span class=\"o\">,</span> <span class=\"n\">elaborator</span> <span class=\"n\">has</span> <span class=\"n\">special</span> <span class=\"n\">support</span> <span class=\"n\">for</span> <span class=\"n\">no_confusion</span>\n<span class=\"n\">but</span> <span class=\"n\">the</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"n\">known</span>\n</code></pre></div>",
        "id": 224364047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611855676
    },
    {
        "content": "<p>I guess it emits <code>#check Model.no_confusion</code>, which isn't a valid application</p>",
        "id": 224364841,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611855918
    },
    {
        "content": "<p>right, you need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>           <span class=\"n\">emit_command_here</span> <span class=\"o\">(</span><span class=\"s2\">\"#check @\"</span> <span class=\"bp\">++</span> <span class=\"n\">d.to_name.to_string</span><span class=\"o\">),</span>\n</code></pre></div>",
        "id": 224364869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611855930
    },
    {
        "content": "<p>While we're on this topic, does <code>#check @@f</code> ever give a different result to <code>#check @f</code>?</p>",
        "id": 224364944,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611855960
    },
    {
        "content": "<p>Answer: yes, <code>@@mul_assoc</code> is an example</p>",
        "id": 224365077,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611855997
    },
    {
        "content": "<p>also <code>@@list.rec</code></p>",
        "id": 224365095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856007
    },
    {
        "content": "<p>Perhaps <code>@@</code> is actually a good idea here to avoid noise while avoiding the error caused by no <code>@</code>?</p>",
        "id": 224365180,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611856043
    },
    {
        "content": "<p>No, I think it's best to avoid metavariable insertion since that could cause unexpected elaboration errors</p>",
        "id": 224365268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856082
    },
    {
        "content": "<p>You could use <code>#print decl</code> instead but that shows the whole function definition too</p>",
        "id": 224365367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856110
    },
    {
        "content": "<p>probably just <code>trace decl</code> is sufficient</p>",
        "id": 224365430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856133
    },
    {
        "content": "<p>or rather <code>emit_command_here (\"#eval tactic.trace `\" ++ d.to_name.to_string)</code> since otherwise it isn't sequenced properly with the <code>#print axioms</code></p>",
        "id": 224365749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856271
    },
    {
        "content": "<p>Thank you Mario,  once again you have made my day.   One little @ sign seems to get rid of the red ink.</p>",
        "id": 224366490,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611856610
    },
    {
        "content": "<p>Here's another version of that command with these adjustments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[user_command]</span> <span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">axioms_all</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">interactive.parse</span> <span class=\"bp\">$</span> <span class=\"n\">tk</span> <span class=\"s2\">\"#axioms_all\"</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">parser</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">info</span> <span class=\"bp\">←</span> <span class=\"n\">option.is_some</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">optional</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"?\"</span><span class=\"o\">),</span>\n  <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n  <span class=\"n\">e.fold</span> <span class=\"o\">(</span><span class=\"n\">return</span> <span class=\"o\">())</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">rest</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n    <span class=\"n\">when</span> <span class=\"o\">(</span><span class=\"n\">e.in_current_file</span> <span class=\"n\">d.to_name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n      <span class=\"n\">when</span> <span class=\"n\">info</span> <span class=\"bp\">$</span> <span class=\"n\">emit_command_here</span> <span class=\"o\">(</span><span class=\"s2\">\"#eval tactic.trace `\"</span> <span class=\"bp\">++</span> <span class=\"n\">d.to_name.to_string</span><span class=\"o\">)</span> <span class=\"bp\">$&gt;</span> <span class=\"o\">(),</span>\n      <span class=\"n\">emit_command_here</span> <span class=\"o\">(</span><span class=\"s2\">\"#print axioms \"</span> <span class=\"bp\">++</span> <span class=\"n\">d.to_name.to_string</span><span class=\"o\">)</span> <span class=\"bp\">$&gt;</span> <span class=\"o\">()),</span>\n    <span class=\"n\">rest</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 224366494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856613
    },
    {
        "content": "<p>You can use <code>#axioms_all</code> and it will not print the names of things, but it should be easy to scan for the odd one out in a sea of <code>no axioms</code>. If you use <code>#axioms_all?</code> it will print the names of declarations so you can go find the offender</p>",
        "id": 224366639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856678
    },
    {
        "content": "<p>Unfortunately <code>#print axioms</code> does not provide its information via tactics so it still requires some eyeball work</p>",
        "id": 224366902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856799
    },
    {
        "content": "<p>Is there no way to run a command and capture the trace messages?</p>",
        "id": 224366990,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611856818
    },
    {
        "content": "<p>not that I know of</p>",
        "id": 224367006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856828
    },
    {
        "content": "<p>It shouldn't be hard to make a hook for this in lean C++</p>",
        "id": 224367126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856884
    },
    {
        "content": "<p>Can you do something dumb like vm_override trace?</p>",
        "id": 224367147,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611856897
    },
    {
        "content": "<p><code>#print axioms</code> is a bit of an unusual case because it predates a lot of the tactic framework. It just writes straight to the editor, lean never sees anything</p>",
        "id": 224367281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856946
    },
    {
        "content": "<p>trace isn't called, this is 100% C++ code</p>",
        "id": 224367303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611856965
    },
    {
        "content": "<p>the hook I'm referring to is something like <code>constant tactic.get_axioms_used : name -&gt; tactic (list name)</code></p>",
        "id": 224367488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611857029
    },
    {
        "content": "<p>#axioms_all?   (with question mark)  produces great output,  I'm happy with that.   <br>\nWithout the question mark it just prints  \"no axioms\"  or \"propext\"  or occasionally \"quot.sound\";  so I guess<br>\nif I do not say any occurrence of \"choice\"  I'm good to go without a question mark.   The plan is to do leanproject build and <br>\ngrep the output for \"choice\".</p>",
        "id": 224368113,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611857318
    },
    {
        "content": "<p>yeah, that's the idea</p>",
        "id": 224368156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611857337
    },
    {
        "content": "<p>That was working fine before you improved the code, except on the file containing the class definition.   Now that works too, thanks.</p>",
        "id": 224368207,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611857360
    },
    {
        "content": "<p>I suppose with the other version you might get in trouble if you happen to have a declaration called <code>choice</code> something</p>",
        "id": 224368272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611857397
    },
    {
        "content": "<p>I don't have any such declaration so that's not a problem.</p>",
        "id": 224368355,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611857419
    },
    {
        "content": "<p>I wonder why quot.sound pops up now and then.  I don't have any explicit quotient types.</p>",
        "id": 224368391,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611857444
    },
    {
        "content": "<p>If you use <code>funext</code> then quot.sound will get involved</p>",
        "id": 224368423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611857459
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">environment.is_builtin</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">env.is_inductive</span> <span class=\"n\">n</span> <span class=\"bp\">||</span> <span class=\"n\">env.is_recursor</span> <span class=\"n\">n</span> <span class=\"bp\">||</span> <span class=\"n\">env.is_constructor</span> <span class=\"n\">n</span> <span class=\"bp\">||</span>\n<span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">quot</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">quot.lift</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">quot.ind</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">quot.mk</span><span class=\"o\">])</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.get_axioms_used_aux</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">environment</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span>\n  <span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">ns.contains</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"k\">do</span>\n  <span class=\"n\">d</span> <span class=\"bp\">←</span> <span class=\"n\">env.get</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">ns.insert</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">process</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">name_set</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n    <span class=\"n\">v.fold</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">))</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"k\">if</span> <span class=\"n\">e.is_constant</span> <span class=\"k\">then</span> <span class=\"n\">tactic.get_axioms_used_aux</span> <span class=\"n\">e.const_name</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.defn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">declaration.thm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">)</span>      <span class=\"o\">:=</span> <span class=\"n\">process</span> <span class=\"n\">v.get</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"k\">if</span> <span class=\"n\">env.is_builtin</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.get_axioms_used</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_env</span><span class=\"o\">,</span>\n  <span class=\"n\">prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">tactic.get_axioms_used_aux</span> <span class=\"n\">env</span> <span class=\"n\">n</span> <span class=\"o\">([],</span> <span class=\"n\">mk_name_set</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">tactic.get_axioms_used</span> <span class=\"bp\">`</span><span class=\"n\">classical.em</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic.trace</span>\n<span class=\"c1\">-- [propext, quot.sound, classical.choice]</span>\n</code></pre></div>",
        "id": 224372208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611859038
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[user_attribute]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">intuit_attr</span> <span class=\"o\">:</span> <span class=\"n\">user_attribute</span> <span class=\"n\">unit</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">name</span>   <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">intuit</span><span class=\"o\">,</span>\n  <span class=\"n\">descr</span>  <span class=\"o\">:=</span> <span class=\"s2\">\"intuit\"</span><span class=\"o\">,</span>\n  <span class=\"n\">after_set</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n    <span class=\"n\">l</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.get_axioms_used</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"n\">classical.choice</span> <span class=\"bp\">∉</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span>\n    <span class=\"n\">tactic.fail</span> <span class=\"s2\">\"ERROR: classical axioms used\"</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[intuit]</span> <span class=\"kd\">theorem</span> <span class=\"n\">bad</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"c1\">-- fail</span>\n<span class=\"kd\">by</span> <span class=\"n\">by_cases</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">@[intuit]</span> <span class=\"kd\">theorem</span> <span class=\"n\">good</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"c1\">-- ok</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h.1</span> <span class=\"n\">i</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">h.2</span> <span class=\"n\">this</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 224372999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611859392
    },
    {
        "content": "<p>I'm not sure about the attribute, but those meta defs look worth PRing to me</p>",
        "id": 224377901,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611861345
    },
    {
        "content": "<p>If I understand this correctly,  here is how I should use it:  import the code and then tag all my theorems with @[intuit].<br>\nIs that right?</p>",
        "id": 224378161,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611861437
    },
    {
        "content": "<p>Here's a MWE.   In this case it is really a working example,  instead of a non-working example.  My question is this:  I first wrote it with <br>\n[M:Type]  instead of {M:Type}.   It didn't work.  But this version, with {M},  does work.    Is anybody willing to explain why?  I suppose if I studied the documentation hard enough it would explain the difference between curly brackets and braces,  so I'm hesitant to post, but maybe somebody can tell me easily.  Also:  would there be a way to write it so the final 'simp'  to cause beta-reduction would be already applied?  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notnot_forall</span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">¬¬</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">¬¬</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">:=</span>\n  <span class=\"c1\">-- credit: Troestra 344, p. 8</span>\n  <span class=\"k\">assume</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h3</span><span class=\"o\">:</span>  <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">:=</span>\n      <span class=\"kd\">begin</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n        <span class=\"n\">specialize</span> <span class=\"n\">h4</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n        <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span><span class=\"o\">,</span>\n   <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n <span class=\"kd\">end</span>\n\n<span class=\"kd\">reserve</span> <span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">∈</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">49</span>\n\n<span class=\"kd\">class</span>  <span class=\"n\">Model</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">infix</span>  <span class=\"bp\">∈</span> <span class=\"o\">:=</span>  <span class=\"n\">mem</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">union_axiom</span><span class=\"o\">:</span>   <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">union</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">z</span><span class=\"o\">)))</span><span class=\"bp\">.</span>\n <span class=\"c\">/-</span><span class=\"cm\"> end of class definition because next line doesn't declare a member -/</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Model</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">X</span> <span class=\"n\">R</span> <span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span> <span class=\"n\">Model</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">¬¬</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span><span class=\"o\">:=</span> <span class=\"n\">notnot_forall</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 224527060,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611951269
    },
    {
        "content": "<p>square brackets are only for typeclass arguments</p>",
        "id": 224527370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951463
    },
    {
        "content": "<p>Usually type arguments will be in curly braces like <code>{M : Type}</code>, because they are not going to be supplied explicitly in lemmas</p>",
        "id": 224527493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951525
    },
    {
        "content": "<p>Since all the variables in your variables line are explicit except for <code>[Model M]</code>, that means that if you use <code>test</code> you will have to write <code>test M h x</code> to apply it (where <code>h</code> is a proof of <code>¬¬ ∀ (x:M), x = x</code>, even though lean can infer <code>M</code> from <code>h</code></p>",
        "id": 224527596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951589
    },
    {
        "content": "<p>Yes,  I always supply M explicitly.  If I don't type the variables in my lemmas  then Lean often complains that it cannot synthesize their types so I just got in the habit of typing everything.</p>",
        "id": 224527813,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611951698
    },
    {
        "content": "<p>For the variables like <code>a b x y</code> this is reasonable, but for type variables it's pretty rare that they can't be inferred</p>",
        "id": 224527932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951741
    },
    {
        "content": "<p>If you use <code>(M)</code> instead of <code>{M}</code> in <code>notnot_forall</code>, in <code>test</code> you can write <code>have h := notnot_forall _ (λ (x:M), x = x),</code> but <code>have h := notnot_forall (λ (x:M), x = x),</code> won't work. If you use <code>[M:Type]</code>, then it will attempt to use typeclass inference to infer <code>M</code>, which will fail because <code>Type</code> is not a typeclass</p>",
        "id": 224527959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951762
    },
    {
        "content": "<p>The standard rule we use in mathlib is that if a variable appears in the types of arguments that come later, then it should be implicit, otherwise it should be explicit</p>",
        "id": 224528124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951848
    },
    {
        "content": "<p>so if you have <code>lemma foo (M : Type) (a : M) (h : a = a)</code> then you could make <code>M</code> and <code>a</code> implicit because <code>h</code> contains <code>a</code> in its type and <code>a</code> contains <code>M</code> in its type</p>",
        "id": 224528237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951909
    },
    {
        "content": "<p>because the elaborator will be able to pick up the type from the later occurrences?   having temporarily substituted a metavariable that it will then fill in when it encounters the correct type?</p>",
        "id": 224528278,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611951937
    },
    {
        "content": "<p>right, when you apply it with say <code>a</code> being <code>3 : nat</code> it can figure out that <code>M := nat</code></p>",
        "id": 224528365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611951975
    },
    {
        "content": "<p>Except your example would hit the infamous \"a\" bug,  as it uses \"a\" for that metavariable, if I understand things.</p>",
        "id": 224528439,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611952062
    },
    {
        "content": "<p>if you just wrote <code>foo rfl</code> it would have trouble though because <code>rfl</code> doesn't follow this rule of implicitness, it has all arguments implicit. With <code>foo (eq.refl (3:nat))</code> or <code>foo (rfl : 3 = 3)</code> it would work</p>",
        "id": 224528457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611952076
    },
    {
        "content": "<p>Nah, the a bug is dead and gone</p>",
        "id": 224528509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611952092
    },
    {
        "content": "<p>long live the alpha-vrachy <code>ᾰ</code> bug</p>",
        "id": 224528523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611952102
    },
    {
        "content": "<p>OK!</p>",
        "id": 224528608,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611952151
    },
    {
        "content": "<p>How come if I write (M)  I can get away with an underscore?   I don't know how that works.</p>",
        "id": 224528665,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611952200
    },
    {
        "content": "<p>Also:   simp often uses classical choice.  How can I cause beta-reduction  and ONLY beta-reduction?   Similar to #reduce,  but in a tactic.    'simp only'  works at least sometimes,  maybe that is the answer.</p>",
        "id": 224530656,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611953214
    },
    {
        "content": "<p><code>dsimp only</code></p>",
        "id": 224531788,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1611953639
    },
    {
        "content": "<p>Looking at the manual for dsimp,  it looks like the \"only\"  after dsimp  would be superfluous.   Or maybe not.  Anyway thanks,  I did not know about dsimp,  even though it is right there in the manual.</p>",
        "id": 224532364,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1611953884
    },
    {
        "content": "<p><code>dsimp</code> without <code>only</code> means <code>dsimp</code> with all definitional simp lemmas</p>",
        "id": 224532679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611954023
    },
    {
        "content": "<p>those lemmas can't use axioms so it's safe in your case, but it's more than just beta reduction</p>",
        "id": 224532712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611954043
    },
    {
        "content": "<blockquote>\n<p>How come if I write (M) I can get away with an underscore? I don't know how that works.</p>\n</blockquote>\n<p>For the same reason that <code>{M}</code> works. Lean can infer it if you ask it to; you can either signal this on the definition of the function itself using <code>{M}</code>, in which case lean will insert the underscore unless you ask it not to, or you can do it at point of use if the function uses <code>(M)</code> but you have an actual <code>_</code> at the application</p>",
        "id": 224532949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611954151
    },
    {
        "content": "<p>I did leanproject update.    Now I wish I had not,  as it seems that the \"broken\" tactic  'finish'  has been removed.   But I was still using it.<br>\nMany times it DOES produce an intuitionistically correct proof.    I guess now I will really have to eliminate ALL use of it.   Unless there is an <br>\neasy way to revert to the previous version?</p>",
        "id": 226262179,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1613244007
    },
    {
        "content": "<p>You can take the one-line definitions of <code>ifinish</code> etc from old <code>mathlib</code> and copy to your project.</p>",
        "id": 226262207,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1613244085
    },
    {
        "content": "<p>I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">auto</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">ifinish</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">simp_lemmas</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cfg</span> <span class=\"o\">:</span> <span class=\"n\">auto_config</span> <span class=\"o\">:=</span> <span class=\"o\">{})</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">finish</span> <span class=\"n\">s</span> <span class=\"n\">ps</span> <span class=\"o\">{</span><span class=\"n\">classical</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"n\">cfg</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span> <span class=\"n\">auto</span>\n</code></pre></div>\n<p>But it produced</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"kd\">structure</span> <span class=\"n\">value</span> <span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">},</span> <span class=\"bp\">'</span><span class=\"n\">classical'</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"n\">field</span> <span class=\"n\">of</span> <span class=\"kd\">structure</span> <span class=\"bp\">'</span><span class=\"n\">auto.auto_conf</span>\n</code></pre></div>",
        "id": 226262719,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1613244843
    },
    {
        "content": "<p>There were some other changes made to <code>finish</code> in that commit, so the easiest thing to do might just be to copy the entire file from the commit before and rename some of the declarations in it <a href=\"https://github.com/leanprover-community/mathlib/blob/c64aa1327ea3ce07673e98f9a1a33097ad377019/src/tactic/finish.lean\">https://github.com/leanprover-community/mathlib/blob/c64aa1327ea3ce07673e98f9a1a33097ad377019/src/tactic/finish.lean</a></p>\n<p>It looks like there's also one fix to <code>normalize_hyp</code> you'll have to port from the Lean 3.26.0 upgrade: <a href=\"https://github.com/leanprover-community/mathlib/commit/c64aa1327ea3ce07673e98f9a1a33097ad377019#diff-a0d8d6b754a5f49a85e923e6ca891150d76bd8d1e7f66f395db8a81af79f1b09\">https://github.com/leanprover-community/mathlib/commit/c64aa1327ea3ce07673e98f9a1a33097ad377019#diff-a0d8d6b754a5f49a85e923e6ca891150d76bd8d1e7f66f395db8a81af79f1b09</a></p>",
        "id": 226263578,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1613246110
    },
    {
        "content": "<p>Maybe it'd be easier to rename the <code>auto</code> namespace rather than all of the individual declarations in it.</p>",
        "id": 226263644,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1613246183
    },
    {
        "content": "<p>I've just gone through all my files and replaced all calls to ifinish with explicit proofs.    It was kinda sorta fun and now it's done,  so I can keep using the current version.</p>",
        "id": 226460263,
        "sender_full_name": "Michael Beeson",
        "timestamp": 1613436948
    }
]
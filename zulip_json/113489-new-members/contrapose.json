[
    {
        "content": "<p>Dear All,</p>\n<p>I want to go from an <code>A ↔ B</code> to <code>¬A ↔ ¬B</code>.  I know that I can prove the equivalence of these two by <code>tauto</code>, but it seems a little silly.  Is there a \"contrapositive iff\" automatically generated by Lean?  Is there a better way?  Below is the actual statement that I was trying to prove.  Note that this is part of a larger proof: I would rather not include this step in my argument!</p>\n<p>Thanks!</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">zero_coeff_iff</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">coeff</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"err\">∉</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">contrapose</span><span class=\"o\">,</span>\n      <span class=\"n\">push_neg</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">contrapose</span><span class=\"o\">,</span>\n      <span class=\"n\">push_neg</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 209268348,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599466477
    },
    {
        "content": "<p><code>not_mem_support_iff</code></p>",
        "id": 209268410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599466534
    },
    {
        "content": "<p>And <code>unfold coeff</code></p>",
        "id": 209268422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599466541
    },
    {
        "content": "<p>Thank!  I will try it!</p>",
        "id": 209268430,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599466551
    },
    {
        "content": "<p>I agree that this lemma should be added to mathlib, because you shouldn't need to unfold <code>coeff</code></p>",
        "id": 209268435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599466559
    },
    {
        "content": "<p>Concerning your actual question, I think there is something like <code>not_iff_not</code> and <code>not_iff_not_of_iff</code></p>",
        "id": 209268534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599466610
    },
    {
        "content": "<p><del>But, as a general rule, proving an iff does not automatically also prove the iff between the <code>\\not</code>s. right?</del></p>",
        "id": 209268554,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599466624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/contrapose/near/209268534\">said</a>:</p>\n<blockquote>\n<p>Concerning your actual question, I think there is something like <code>not_iff_not</code> and <code>not_iff_not_of_iff</code></p>\n</blockquote>\n<p>Ah, ok!!</p>",
        "id": 209268584,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599466640
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/not_congr\">docs#not_congr</a> I think</p>",
        "id": 209268592,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1599466648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/contrapose/near/209268435\">said</a>:</p>\n<blockquote>\n<p>I agree that this lemma should be added to mathlib, because you shouldn't need to unfold <code>coeff</code></p>\n</blockquote>\n<p>I think so too: when Lean \"interprets\" <code>f.coeff n</code>, it often writes it as <code>⇑f n</code> and <code>unfold coeff</code> does not work...</p>",
        "id": 209269039,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1599466995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/contrapose/near/209268435\">said</a>:</p>\n<blockquote>\n<p>I agree that this lemma should be added to mathlib, because you shouldn't need to unfold <code>coeff</code></p>\n</blockquote>\n<p>Every logic lemma under the sun is already there, but no one wants to refer to them by name</p>",
        "id": 209273239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599469911
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">zero_coeff_iff</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">coeff</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"err\">∉</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"n\">iff_not_comm</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 209273543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599470071
    },
    {
        "content": "<p>But <code>(f.not_mem_support_iff _).symm</code> should hopefully also work, and be a slightly more readable proof...</p>",
        "id": 209274154,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599470467
    },
    {
        "content": "<p>:-( I did a bunch of work earlier trying to stamp out the coercion to a function for polynomials, but the problem is everytime you forget that it is a polynomial and treat it as a <code>finsupp</code> the coercion starts to sneak in again.</p>",
        "id": 209278510,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599473305
    },
    {
        "content": "<p>My attitude if that if you ever see <code>⇑f</code>, and <code>f : polynomial R</code>, then you have encountered a bug, for which the correct fix is make the definition of <code>polynomial</code> irreducible as early as possible (if not earlier).</p>",
        "id": 209278584,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599473357
    },
    {
        "content": "<p>I very much agree</p>",
        "id": 209278630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599473393
    },
    {
        "content": "<p>(Although I admit to having written a lot of <em>evil</em> code)</p>",
        "id": 209278688,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599473411
    },
    {
        "content": "<p>we did a bunch of cleanup of the polynomials files a few months ago, but I guess there's still a ways to go</p>",
        "id": 209278708,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599473427
    },
    {
        "content": "<p>Thinking out loud: would it be possible/useful to write a linter that checks for <code>coe_fn</code> being applied to a term of type <code>polynomial _</code>? It won't catch any occurrence in the goal, but it should catch some evil usages.</p>",
        "id": 209278814,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1599473519
    },
    {
        "content": "<p>One thing that is interesting here is that <code>f.3</code> itself is abstraction-breaking</p>",
        "id": 209279857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599474231
    },
    {
        "content": "<p>even if you write that after it is made irreducible, lean will make it work</p>",
        "id": 209279925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599474261
    },
    {
        "content": "<p>Oh wait, lean is doing the right thing here. If you write <code>f.3</code>, it resolves to <code>finsupp.mem_support_to_fun f</code>, which will fail to typecheck if <code>polynomial</code> is irreducible.</p>",
        "id": 209280134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599474454
    },
    {
        "content": "<p>So the question is, why isn't <code>attribute [irreducible] polynomial</code> at the bottom of <code>data.polynomial</code>?</p>",
        "id": 209280192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599474483
    },
    {
        "content": "<p>Of course the statement of this theorem itself doesn't typecheck, since <code>f.support</code> is referring to <code>finsupp.support f</code>. If we need this then it should be redeclared as <code>polynomial.support</code></p>",
        "id": 209280369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599474606
    },
    {
        "content": "<p>I made has_zero irreducible, added very little API, and if people really want it reducible so they can abuse defeq for some reason then they can just locally tag it as reducible</p>",
        "id": 209285403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478330
    },
    {
        "content": "<p>I did this when I was making has_zero irreducible: some proofs broke, but surprisingly few. The proofs which broke were of two kinds: those which broke because of missing API, and those that broke because they abuse the API; in those cases I fixed the proofs by removing the <code>option</code> lemma and replacing it with the corresponding <code>has_zero</code> lemma</p>",
        "id": 209285543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478451
    },
    {
        "content": "<p>Actually there was also a funny third kind</p>",
        "id": 209285568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478469
    },
    {
        "content": "<p>There were two theorems about <code>option</code> for which some stupid trivial lemma was missing from the option API and so the proof used the corresponding result from has_zero :-)</p>",
        "id": 209285634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478527
    },
    {
        "content": "<p>I added the result to the option API</p>",
        "id": 209285704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599478563
    },
    {
        "content": "<p>You made <code>has_zero</code> irreducible? That would break quite a lot. I assume you mean <code>with_zero</code></p>",
        "id": 209286203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599478931
    },
    {
        "content": "<p>Rather than making <code>polynomial</code> irreducible, why not just make it a structure?</p>",
        "id": 209287495,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599479910
    },
    {
        "content": "<p>One argument against that (making it a structure) is that it commits you a single big refactor. You can make gradual progress by making <code>polynomial</code> irreducible, fixing the API a bit in response to a subset of the errors, then removing the <code>irreducible</code> again. But yeah.</p>",
        "id": 209288771,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599480850
    },
    {
        "content": "<p>I was going to propose that, but then I looked up the definition and it's equal to <code>add_monoid_algebra</code> and I'm not sure where to assert the structure</p>",
        "id": 209289340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599481220
    },
    {
        "content": "<p>should <code>add_monoid_algebra</code> be a structure with a <code>G</code>-indexed <code>coeff</code> field?</p>",
        "id": 209289378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599481254
    },
    {
        "content": "<p>oh yeah, that does make things a bit more complicated. I think at least <code>add_monoid_algebra</code> should be a structure, because <code>finsupp</code> is not the only sensible representation (constructively it's perhaps not even the correct representation). Not sure whether <code>polynomial</code> should also be a structure.</p>",
        "id": 209293324,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599483879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/contrapose/near/209288771\">said</a>:</p>\n<blockquote>\n<p>One argument against that (making it a structure) is that it commits you a single big refactor.</p>\n</blockquote>\n<p>Right--so the broader lesson is that we should be more eager to use <code>structure</code> in the first place</p>",
        "id": 209293793,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599484199
    },
    {
        "content": "<p>Do you think it would have been a good idea to define <code>with_zero</code> as an inductive type instead of making it an alias for <code>option</code>?</p>",
        "id": 209317952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599501869
    },
    {
        "content": "<p>This would enforce good behaviour but now you'd have to prove some things twice</p>",
        "id": 209317967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599501899
    },
    {
        "content": "<p>Although can this be automated because of the non-refl equiv between option and with_zero?</p>",
        "id": 209317998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599501948
    }
]
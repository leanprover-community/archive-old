[
    {
        "content": "<p>I'd like to define a group via its presentation, prove that it's finite, and then compute its character table. I read some of the files in mathlib/algebra/group but still don't really know where to start. Could anyone point me to an example that might be instructive?</p>",
        "id": 183718581,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576642111
    },
    {
        "content": "<p>what's the group?</p>",
        "id": 183718815,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1576642506
    },
    {
        "content": "<p>I don't really think it's best to define a group via its presentation</p>",
        "id": 183718817,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1576642518
    },
    {
        "content": "<p>rather than going from large to small, we go from small to large</p>",
        "id": 183718820,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1576642535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> But we'll need to be able to deal with this, right? Presentations are pervasive in maths</p>",
        "id": 183721066,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576645730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> In mathlib, you can find free groups. And subgroups. And quotients. That should allow you to build your group. And didn't a student of Scott even do finitely presented groups?</p>",
        "id": 183721087,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576645793
    },
    {
        "content": "<p>I guess groupprops would be a good source for proofs using presentations</p>",
        "id": 183721088,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1576645795
    },
    {
        "content": "<p>It might be in mathlib already</p>",
        "id": 183721089,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576645799
    },
    {
        "content": "<p>do we have normal closure?</p>",
        "id": 183721134,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1576645809
    },
    {
        "content": "<p>Yep</p>",
        "id": 183721138,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576645814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> You probably want to look at <a href=\"https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean\">https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean</a></p>",
        "id": 183721148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576645854
    },
    {
        "content": "<p>However, be warned that proving that this thing is finite is probably going to be quite awkard</p>",
        "id": 183721161,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576645898
    },
    {
        "content": "<p><a href=\"https://groupprops.subwiki.org/wiki/Equivalence_of_presentations_of_dicyclic_group\" target=\"_blank\" title=\"https://groupprops.subwiki.org/wiki/Equivalence_of_presentations_of_dicyclic_group\">https://groupprops.subwiki.org/wiki/Equivalence_of_presentations_of_dicyclic_group</a></p>",
        "id": 183721204,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1576645932
    },
    {
        "content": "<p>maybe we would want to be able to do something like this</p>",
        "id": 183721206,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1576645941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Certainly. It would be great to have all sorts of stuff like that.</p>",
        "id": 183721374,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576646278
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> You probably want to look at <a href=\"https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean\">https://github.com/leanprover-community/mathlib/blob/0eea0d9fc53bd037da13abdf5d95a711cbd0c288/src/group_theory/presented_group.lean</a></p>\n</blockquote>\n<p>I'll work on understanding this file (on my first pass, I have a mathematical understanding but I don't yet have a good guess of how to translate a group presentation like &lt; a , b | a^2 = 1, abab\\inv = 1&gt; into code)</p>",
        "id": 183727207,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576655523
    },
    {
        "content": "<blockquote>\n<p>what's the group?</p>\n</blockquote>\n<p>The groups I'm interested are described here <a href=\"https://en.wikipedia.org/wiki/Extra_special_group\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Extra_special_group\">https://en.wikipedia.org/wiki/Extra_special_group</a><br>\nquantum information people call them the pauli group on n qudits</p>",
        "id": 183727283,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576655634
    },
    {
        "content": "<blockquote>\n<p>However, be warned that proving that this thing is finite is probably going to be quite awkard</p>\n</blockquote>\n<p>The proof I have in mind is to define a canonical form, that is a list of words in the group together with a proof that any word in the group is equal to one of the canonical ones<br>\nDo you mean awkward like, I will have to understand details about how lean represents finite lists?</p>",
        "id": 183727434,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576655807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> Cool, I think it's really good if people work on examples. But usually it's not something that Lean excels at. Let's break down a bit what you have to do. We've got the following definition:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- Given a set of relations, rels, over a type α, presented_group constructs the group with</span>\n<span class=\"cm\">generators α and relations rels as a quotient of free_group α.-/</span>\n<span class=\"n\">def</span> <span class=\"n\">presented_group</span> <span class=\"o\">(</span><span class=\"n\">rels</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"err\">$</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">normal_closure</span> <span class=\"n\">rels</span>\n</pre></div>",
        "id": 183728055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576656522
    },
    {
        "content": "<p>You gave as example, a group generated by two elements <code>a</code> and <code>b</code>. So you need a type with two elements. You could choose <code>bool</code> or <code>fin 2</code>, or roll your own type:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">pauli_two_gens</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span>\n</pre></div>",
        "id": 183728144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576656627
    },
    {
        "content": "<p>After that, you need the relations. So you do something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">pauli_two_gens</span>\n\n<span class=\"n\">def</span> <span class=\"n\">pauli_two_rels</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"n\">pauli_two_gens</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"err\">\\</span><span class=\"n\">or</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"err\">\\</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 183728245,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576656728
    },
    {
        "content": "<p>Once you have those, you should be able to write</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">pauli_two</span> <span class=\"o\">:=</span> <span class=\"n\">presented_group</span> <span class=\"n\">pauli_two_rels</span>\n</pre></div>",
        "id": 183728255,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576656761
    },
    {
        "content": "<p>Wow, thanks! I will play with your definitions when I get home from work.</p>",
        "id": 183728295,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576656825
    },
    {
        "content": "<p>Note that I didn't test any of these in Lean. So they might be full of hidden mistakes</p>",
        "id": 183728369,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576656900
    },
    {
        "content": "<p>I did a little testing earlier and the following works</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">presented_group</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"n\">def</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">--check everything makes sense so far</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- if you use pauli_two_gens like Johan you need to tell lean that this is decidable</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- either one of the following ways works, but lean does not automatically work out what 0 or 1 are inside the free group so we use r and s</span>\n<span class=\"n\">def</span> <span class=\"n\">my_rels</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"bp\">⁻¹</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">my_rels2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">r</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"bp\">*</span><span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">r</span><span class=\"bp\">*</span><span class=\"n\">s</span><span class=\"bp\">⁻¹</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">pauli_two</span> <span class=\"o\">:=</span> <span class=\"n\">presented_group</span> <span class=\"n\">my_rels2</span> <span class=\"c1\">-- or my_rels</span>\n</pre></div>",
        "id": 183728950,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1576657475
    },
    {
        "content": "<p>I would try defining your \"canonical forms\" as a type in its own right, then construct the group operation and prove that it is generated the way you expect</p>",
        "id": 183728958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1576657491
    },
    {
        "content": "<p>You will have to do essentially all this work anyway in order to prove that the free group modulo relations is in fact finite</p>",
        "id": 183728995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1576657545
    },
    {
        "content": "<p>Whut? How does this work:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">my_rels2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">r</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"bp\">*</span><span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">r</span><span class=\"bp\">*</span><span class=\"n\">s</span><span class=\"bp\">⁻¹</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Has this syntax always been available in lean?</p>",
        "id": 183729217,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576657766
    },
    {
        "content": "<p>I guess it is, but I just never really realized...</p>",
        "id": 183729305,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576657823
    },
    {
        "content": "<p>Always used the <code>{x | x = _ \\or _ \\or _}</code> stuff</p>",
        "id": 183729327,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1576657843
    },
    {
        "content": "<p>I believe it unfolds to something worse than your option ;-)</p>",
        "id": 183729543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576658077
    },
    {
        "content": "<p><code>example  (x : ℕ) : x ∈ ({4,6} : set ℕ) ↔ x = 6 ∨ x = 4 ∨ false := iff.rfl</code></p>",
        "id": 183729769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576658287
    },
    {
        "content": "<blockquote>\n<p>I would try defining your \"canonical forms\" as a type in its own right, then construct the group operation and prove that it is generated the way you expect</p>\n</blockquote>\n<p>Proving associativity will be a nightmare like this.</p>",
        "id": 183729799,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576658354
    },
    {
        "content": "<p>I don't see why, provided you set up the operation right</p>",
        "id": 183729887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1576658458
    },
    {
        "content": "<p>Using the definitions that Alex J Best gave, it seems like the type system has less of an understanding of the claim \"pauli_two is a group\" than the claim \"free_group (fin 2)\" is a group. </p>\n<p>Lean knows how to deal with <br>\ntheorem order_not_two : ∀ x : (free_group (fin 3)), x≠ 1 → x * x ≠ 1</p>\n<p>but not<br>\ntheorem order_two : ∀ x : pauli_two, x * x = 1<br>\nin which case it says it can't find has_mul or has_one for pauli_two</p>",
        "id": 184010176,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576933589
    },
    {
        "content": "<p>the presented_group file has this line<br>\ninstance (rels : set (free_group α)) : group (presented_group (rels)) :=<br>\nquotient_group.group _</p>\n<p>and I guess I expected it to have something like<br>\ninstance group : (presented_group rels)</p>",
        "id": 184010370,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576933926
    },
    {
        "content": "<p>Can you post the current working version of your code? The errors just mean that there is no term of tyoe <code>group G</code> for your group <code>G</code></p>",
        "id": 184010375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576933966
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">presented_group</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span>\n\n<span class=\"c1\">-- open presented_group</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"n\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">1</span>\n<span class=\"n\">def</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">2</span>\n\n<span class=\"c1\">--check everything makes sense so far</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- if you use pauli_two_gens like Johan you need to tell lean that this is decidable</span>\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">J</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">my_rels2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">J</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">J</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">z</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">⁻¹*</span><span class=\"n\">z</span><span class=\"bp\">⁻¹</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">pauli_two</span> <span class=\"o\">:=</span> <span class=\"n\">presented_group</span> <span class=\"n\">my_rels2</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">my_rels2</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">pauli_two</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">group</span> <span class=\"n\">pauli_two</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">has_pow</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">has_pow</span> <span class=\"o\">(</span><span class=\"n\">pauli_two</span><span class=\"o\">)</span> <span class=\"bp\">ℕ</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">free_group</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">order_not_two</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)),</span> <span class=\"n\">x</span><span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">rintros</span>  <span class=\"bp\">⟨</span> <span class=\"n\">L</span><span class=\"bp\">⟩</span> <span class=\"o\">,</span>\n<span class=\"n\">induction</span> <span class=\"n\">L</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">order_two</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">pauli_two</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 184010383,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576934013
    },
    {
        "content": "<p>Can you put it all in quotes so it displays properly?</p>",
        "id": 184010432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934092
    },
    {
        "content": "<p><code> ```lean </code> at the top</p>",
        "id": 184010441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934113
    },
    {
        "content": "<p>And <code> ``` </code> at the end</p>",
        "id": 184010444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934125
    },
    {
        "content": "<blockquote>\n<p>there is no term of type group G for your group G</p>\n</blockquote>\n<p>If I construct such a term manually, how do I get the compiler to notice it when I'm writing statements about G?</p>",
        "id": 184010604,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576934423
    },
    {
        "content": "<p>which version of lean/mathlib are you using? Your proof of <code>order_not_two</code> doesn't compile for me</p>",
        "id": 184010615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934488
    },
    {
        "content": "<p>oh, sorry, it doesn't compile for me either</p>",
        "id": 184010660,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576934540
    },
    {
        "content": "<p>it had been a sorry and I  had been trying to prove it and forgot to revert it before posting</p>",
        "id": 184010663,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576934560
    },
    {
        "content": "<p><code>instance : group pauli_two := by unfold pauli_two; apply_instance</code></p>",
        "id": 184010666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934570
    },
    {
        "content": "<p>is what you're missing.</p>",
        "id": 184010667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934579
    },
    {
        "content": "<p>or alternatively</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">group</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">pauli_two</span> <span class=\"o\">:=</span> <span class=\"n\">presented_group</span> <span class=\"n\">my_rels2</span>\n</pre></div>",
        "id": 184010674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934601
    },
    {
        "content": "<p>The type class inference system handles the job of coming up with e.g. what notation means for a given type. Your definition of <code>pauli_two</code> is just a definition of a new type -- if you hover over <code>presented_group</code> then you'll see that it just returns something of type <code>Type</code>.</p>",
        "id": 184010721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934701
    },
    {
        "content": "<p>that @derive clause makes a lot of sense to me coming from programming in ocaml</p>",
        "id": 184010731,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576934722
    },
    {
        "content": "<p>OK great, it's brand spanking new in Lean.</p>",
        "id": 184010735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934739
    },
    {
        "content": "<p>would it make sense for presented_group to return a type decorated with a group instance?</p>",
        "id": 184010778,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576934769
    },
    {
        "content": "<p>I am not a computer scientist, all I can say is that because groups are \"partially bundled\" this is what we have to do.</p>",
        "id": 184010785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934802
    },
    {
        "content": "<p>Another alternative is that <code>presented_group</code> returns a term of type <code>Group</code> where <code>Group</code> is the category of groups.</p>",
        "id": 184010797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934835
    },
    {
        "content": "<p>ok, I think I can accept this as a fact of life.</p>",
        "id": 184010800,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576934862
    },
    {
        "content": "<p>If you do it that way then all your maps between groups will be morphisms in the category and you'll lose some of the cool advantages of functional programming because they won't be functions any more. Or something.</p>",
        "id": 184010802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934879
    },
    {
        "content": "<p>In short, this is a design decision</p>",
        "id": 184010842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934888
    },
    {
        "content": "<p>and the less I say about it the better ;-) because I know nothing about the pros and cons. There is a section about this in the mathlib paper.</p>",
        "id": 184010847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934938
    },
    {
        "content": "<p>Note that <code>theorem order_two : ∀ x : presented_group my_rels2, x * x = 1 := by sorry</code> works fine, because the typeclass system knows that <code>presented_group R</code> is a group.</p>",
        "id": 184010861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576934991
    },
    {
        "content": "<p>section 4.1.1 of <a href=\"https://leanprover-community.github.io/papers/mathlib-paper.pdf\" target=\"_blank\" title=\"https://leanprover-community.github.io/papers/mathlib-paper.pdf\">the mathlib paper</a> talks about the design decisions.</p>",
        "id": 184010922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1576935084
    },
    {
        "content": "<p>i guess the term <code>lean ∀ x : presented_group my_rels2, x * x = 1</code> can be turned into the term<code>lean ∀ x:pauli_two, x * x = 1</code> by one application of definitional equality, but you can't make that substitution before the compiler has made up its mind about whether the second term makes sense</p>",
        "id": 184011026,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576935248
    },
    {
        "content": "<p>I don't know how to access a statment like \"if w \\in rels, then w = 1 in presented_group rels\". I also don't know how to access the quotient map from my free group to my presented group. There is a lemma in the presented_groups file that looks awfully relevant but I can't figure out how to make any interesting terms with it. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">to_group_eq_one_of_mem_closure</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">normal_closure</span> <span class=\"n\">rels</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_group_hom</span><span class=\"bp\">.</span><span class=\"n\">mem_ker</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>  <span class=\"o\">((</span><span class=\"n\">closure_rels_subset_ker</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>(I would love if the answer to my question was \"read X tutorial or Y book chapter more closely to understand Z fundamental concept that you clearly lack understanding of\")</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- goal: define the two qubit pauli group</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">presented_group</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">presented_group</span>\n\n<span class=\"n\">def</span> <span class=\"n\">gen_J</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">0</span>\n<span class=\"n\">def</span> <span class=\"n\">gen_x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">1</span>\n<span class=\"n\">def</span> <span class=\"n\">gen_z</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">2</span>\n\n<span class=\"n\">def</span> <span class=\"n\">my_rels</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">gen_J</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">gen_x</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">gen_z</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">gen_J</span><span class=\"bp\">*</span><span class=\"n\">gen_x</span><span class=\"bp\">*</span><span class=\"n\">gen_z</span><span class=\"bp\">*</span><span class=\"n\">gen_x</span><span class=\"bp\">⁻¹*</span><span class=\"n\">gen_z</span><span class=\"bp\">⁻¹</span><span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">group</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">pauli_two</span> <span class=\"o\">:=</span> <span class=\"n\">presented_group</span> <span class=\"n\">my_rels</span>\n\n<span class=\"n\">def</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">presented_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pauli_two</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">presented_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pauli_two</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">presented_group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pauli_two</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel1</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 184012753,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576938722
    },
    {
        "content": "<p>Its possible a lot of the lemmas you are interested in are actually just lemmas about group quotients, and so in <code>group_theory/quotient_group.lean</code> rather than this file. In particular the one you mentioned <code>to_group_eq_one_of_mem_closure</code> is a bit more complex, it has the additional assumptions defined above in that file</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">rels</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"n\">F</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">free_group</span><span class=\"bp\">.</span><span class=\"n\">to_group</span> <span class=\"n\">f</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">rels</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>so its to do with when you have a map from your generating letters into some other group such that rels end up in the kernel then the universal property of a presented group gives you a map to the other group etcetc..</p>",
        "id": 184013732,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1576940570
    },
    {
        "content": "<p>Thanks, Alex! I'm currently convinced that if I read the quotient_group file closely enough, I will learn how to access the quotient map</p>",
        "id": 184014211,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1576941383
    },
    {
        "content": "<p>Yeah I think this area (presented_group) needs many more helper lemmas and things, I did it one way, there may be an easier one but I couldn't find it yet:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">rel1</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">J</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">presented_group</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">gen_J</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">((</span><span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">gen_J</span> <span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">normal_closure</span> <span class=\"n\">my_rels</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">is_group_hom</span><span class=\"bp\">.</span><span class=\"n\">mem_ker</span> <span class=\"o\">(</span><span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">ker_mk</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_of_subset_of_mem</span> <span class=\"o\">(</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">subset_normal_closure</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">my_rels</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 184015083,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1576943048
    },
    {
        "content": "<p>Probably a nicer refactor is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">rels</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">presented_group</span> <span class=\"n\">rels</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mk_eq_one_of_mem_rels</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">rels</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">free_group</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">free_group</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">rels</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">presented_group</span> <span class=\"n\">rels</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">is_group_hom</span><span class=\"bp\">.</span><span class=\"n\">mem_ker</span> <span class=\"o\">(</span><span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">quotient_group</span><span class=\"bp\">.</span><span class=\"n\">ker_mk</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_of_subset_of_mem</span> <span class=\"o\">(</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">subset_normal_closure</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel1</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"err\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">change</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">gen_J</span> <span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mk_eq_one_of_mem_rels</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">my_rels</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 184018270,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1576948899
    }
]
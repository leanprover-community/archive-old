[
    {
        "content": "<p>Dear All,</p>\n<p>I am trying to prove that a ring is an integral domain.  I can prove that  a ring isomorphic to the one that I want is an integral domain (all apparently confirmed by Lean), but I cannot deduce that my initial ring is an integral domain!  I realize that I must be missing a very silly command, but I have been unable to find it...</p>\n<p>Extra question: after this is done, how can I get Lean to confirm that the ideal by which I divide is prime, since the quotient is an integral domain?</p>\n<p>Thank you very much!</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n<span class=\"kn\">open</span> <span class=\"n\">ideal</span>\n\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">quoprime</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">is_prime</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">integral_domain</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">C</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">let</span> <span class=\"n\">quo</span> <span class=\"o\">:=</span> <span class=\"n\">polynomial</span> <span class=\"o\">(</span><span class=\"n\">quotient</span> <span class=\"n\">P</span><span class=\"o\">),</span>\n    <span class=\"k\">let</span> <span class=\"n\">quot</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">C</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)),</span>\n    <span class=\"k\">have</span> <span class=\"n\">idq</span> <span class=\"o\">:</span> <span class=\"n\">integral_domain</span> <span class=\"n\">quo</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">integral_domain</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"n\">quo</span> <span class=\"err\">≃</span><span class=\"bp\">+*</span> <span class=\"n\">quot</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">polynomial_quotient_equiv_quotient_polynomial</span><span class=\"o\">,</span>\n        <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 208106297,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455214
    },
    {
        "content": "<p>Can you prove that if R and S are isomorphic rings, and R is an integral domain, then so is S? I think there is a tactic-in-progress to do this, but it is not \"true by definition\", there's some argument here which is completely mechanical.</p>",
        "id": 208106450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455286
    },
    {
        "content": "<p>As for the other question I guess you need to find a lemma saying R/P is an ID iff P is prime. It will probably be there somewhere...</p>",
        "id": 208106610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455354
    },
    {
        "content": "<p>I think that I convinced Lean that one of the rings is an integral domain and that the two rings are isomorphic.  This is where I am stuck...</p>",
        "id": 208106709,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455391
    },
    {
        "content": "<p>(The code above should also contain a proof of this)</p>",
        "id": 208106731,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455403
    },
    {
        "content": "<p>Right. And what I'm saying is that now we need a tactic which rewrites mathematically sane statements along isomorphisms of structures</p>",
        "id": 208106779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455427
    },
    {
        "content": "<p>I will keep looking for how to transport under isomorphisms</p>",
        "id": 208106781,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455429
    },
    {
        "content": "<p>Ah, I understand what you are saying now...</p>",
        "id": 208106807,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455441
    },
    {
        "content": "<p>You could either prove it yourself, or take a look at the current state of the tactic, which I think is called something like <code>equiv_rw</code></p>",
        "id": 208106910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455468
    },
    {
        "content": "<p>ok, I will take a look: thanks for the pointer!</p>",
        "id": 208106948,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455485
    },
    {
        "content": "<p>Do you know where quotient rings are defined? I've found integral domains but the file makes no mention of quotients.</p>",
        "id": 208106993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455508
    },
    {
        "content": "<p>I am not sure where quotient rings are defined...</p>",
        "id": 208107078,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455537
    },
    {
        "content": "<p>you have them in your file so you can just right click. It's OK, I did it now</p>",
        "id": 208107171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455570
    },
    {
        "content": "<p>I am still lacking in these basic skills, sorry...</p>",
        "id": 208107285,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455621
    },
    {
        "content": "<p>It's in ring_theory.ideal.basic; line 304 is the direction you don't want.</p>",
        "id": 208107314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455631
    },
    {
        "content": "<p>(sorry, I need to go: I will dig into this later, and will report on what I find!)</p>",
        "id": 208107780,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455813
    },
    {
        "content": "<p>thank you!</p>",
        "id": 208107790,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455817
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">all</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">integral_domain</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">quotient</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">is_prime</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">library_search</span> <span class=\"c1\">-- fails</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>I don't think it's there!</p>",
        "id": 208107864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598455854
    },
    {
        "content": "<p>More stuff to write!</p>",
        "id": 208108066,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598455941
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv.integral_domain\">docs#ring_equiv.integral_domain</a> is what you want right?</p>",
        "id": 208109541,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1598456675
    },
    {
        "content": "<p>Wow, can I do <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv.discrete_valuation_ring\">docs#ring_equiv.discrete_valuation_ring</a> and it just works?</p>",
        "id": 208109617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598456735
    },
    {
        "content": "<p>apparently not. So what's the deal here? People just write them if they need them?</p>",
        "id": 208109717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598456778
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv.principal_ideal_domain\">docs#ring_equiv.principal_ideal_domain</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv.euclidean_domain\">docs#ring_equiv.euclidean_domain</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv.unique_factorization_domain\">docs#ring_equiv.unique_factorization_domain</a> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv.local_ring\">docs#ring_equiv.local_ring</a></p>",
        "id": 208109785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598456818
    },
    {
        "content": "<p>oh man, you just got lucky</p>",
        "id": 208109817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598456835
    },
    {
        "content": "<p>Hahaha well I grepped to find its name first then posted the doc link, but we are all lucky it exists in mathlib already I guess <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 208110033,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1598456943
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3951\">#3951</a></p>",
        "id": 208113825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598458745
    },
    {
        "content": "<p>That is awesome!  Thank you very much <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span></p>",
        "id": 208114819,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598459250
    },
    {
        "content": "<p>Note that <code>integral_domain</code> is a Type, and <code>is_integral_domain</code> is a Prop, but the stuff I quote in the PR is the API for converting between them.</p>",
        "id": 208114942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598459317
    },
    {
        "content": "<p>Thanks for the explanation: I am no longer in front of my computer, but will try to use this as soon as I get back!</p>",
        "id": 208115993,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598459855
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv.is_integral_domain\">docs#ring_equiv.is_integral_domain</a> is more relevant if you already have a ring isomorphism.</p>",
        "id": 208117892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598460794
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Looks like just what I want!  Perfect!</p>",
        "id": 208118354,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598461008
    },
    {
        "content": "<p>Johan: should we have <code>is_field</code>? Is there an issue here with <code>inv</code>?</p>",
        "id": 208120588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598462044
    },
    {
        "content": "<p>Yup, that will quickly lead to defeq issues with <code>inv</code></p>",
        "id": 208121177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598462338
    },
    {
        "content": "<p>Only if people move from is_field to field.</p>",
        "id": 208121432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598462456
    },
    {
        "content": "<p>Which is bound to happen</p>",
        "id": 208124389,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598464012
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A predicate to express that a ring is a field.</span>\n\n<span class=\"cm\"> This is mainly useful because such a predicate does not contain data,</span>\n<span class=\"cm\"> and can therefore be easily transported along ring isomorphisms. -/</span>\n <span class=\"kn\">structure</span> <span class=\"n\">is_field</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_pair_ne</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_inv_cancel&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n <span class=\"c\">/-</span><span class=\"cm\">- Every field satisfies the predicate for integral domains. -/</span>\n <span class=\"kn\">lemma</span> <span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">to_is_field</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n   <span class=\"n\">is_field</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n <span class=\"o\">{</span> <span class=\"n\">mul_inv_cancel&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">mul_inv_cancel</span> <span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n   <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"err\">‹</span><span class=\"bp\">_</span><span class=\"err\">›</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n <span class=\"c\">/-</span><span class=\"cm\">- If a ring satisfies the predicate for integral domains,</span>\n<span class=\"cm\"> then it can be endowed with an `integral_domain` instance</span>\n<span class=\"cm\"> whose data is definitionally equal to the existing data. -/</span>\n <span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">is_field</span><span class=\"bp\">.</span><span class=\"n\">to_field</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_field</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"n\">field</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n <span class=\"o\">{</span> <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">is_field</span><span class=\"bp\">.</span><span class=\"n\">mul_inv_cancel&#39;</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">),</span>\n   <span class=\"n\">inv_zero</span> <span class=\"o\">:=</span> <span class=\"n\">dif_pos</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n   <span class=\"n\">mul_inv_cancel</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">convert</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">is_field</span><span class=\"bp\">.</span><span class=\"n\">mul_inv_cancel&#39;</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">dif_neg</span> <span class=\"n\">ha</span>\n   <span class=\"kn\">end</span><span class=\"o\">,</span>\n   <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"err\">‹</span><span class=\"bp\">_</span><span class=\"err\">›</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"err\">‹</span><span class=\"bp\">_</span><span class=\"err\">›</span> <span class=\"o\">:</span> <span class=\"n\">is_field</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>Interested?</p>",
        "id": 208136781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598470136
    },
    {
        "content": "<p>Thank you all again so much!  I have laboriously worked through the thread, managed to prove both <code>integral_domain</code> and <code>is_integral_domain</code>, as well as showing that the ideal that I wanted was prime!  The subtleties among the presence or absence of <code>is_</code> are not entirely clear to me, but I can prove both, so that is ok!</p>\n<p>Also, I am very happy to now there is a lemma <code>R/P integral domain iff P prime</code>: even though I did not have anything to do with this, I still feel that I am starting to contribute to mathlib!  Ahahaha</p>",
        "id": 208187610,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598515140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Do you want an explanation of the subtleties? (It doesn't have real mathematical content, as you probably guessed.)</p>",
        "id": 208188542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598515793
    },
    {
        "content": "<p>Maybe yes, if you have the time, or if you can point me to somewhere where it is already explained...</p>",
        "id": 208190900,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598517615
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Do you know the difference between \"definitional equality\" and \"propositional equality\"?</p>",
        "id": 208194178,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520109
    },
    {
        "content": "<p>\"defeq\" means two things are equal by simply unfolding the definitions <em>and nothing else</em>.<br>\nPropositional equality means that two things are equal because you can prove it (and maybe even use an axiom, like choice).</p>",
        "id": 208194319,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520202
    },
    {
        "content": "<p>So, in the natural numbers, you can prove <code>n + 0 = n</code> with <code>rfl</code>. Because that is the definition of <code>n + 0</code>.</p>",
        "id": 208194363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520237
    },
    {
        "content": "<p>On the other hand, <code>0 + n</code> is defined by induction on <code>n</code>. So to prove <code>0 + n = n</code>, you need to really do something (namely, repeat the induction on <code>n</code>, and at some point <code>rw</code> along the induction hypothesis.</p>",
        "id": 208194455,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520298
    },
    {
        "content": "<p>So <code>0 + n = n</code> is only a propositional equality.</p>",
        "id": 208194468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520308
    },
    {
        "content": "<p>Ok, I have a (probably intuitive) understanding of this: in my mind, it is coded as \"defeq : could be an axiom\" or \"propeq : could be deduced from the axioms\"</p>",
        "id": 208194474,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520319
    },
    {
        "content": "<p>Yup, that sounds about right.</p>",
        "id": 208194486,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520333
    },
    {
        "content": "<p>Now why does this matter...</p>",
        "id": 208194492,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520340
    },
    {
        "content": "<p>indeed!</p>",
        "id": 208194497,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520350
    },
    {
        "content": "<p>Lean is trying to help us by automatically finding the semiring structure on <code>nat</code></p>",
        "id": 208194507,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520360
    },
    {
        "content": "<p>Or the integral domain structure on one of your two rings, etc...</p>",
        "id": 208194552,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520375
    },
    {
        "content": "<p>This is type class inference.</p>",
        "id": 208194553,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520380
    },
    {
        "content": "<p>Now suppose that I am using the addition on <code>nat</code> from mathlib, but you had an addition on <code>nat</code> where you define <code>m + n</code> by induction on <code>m</code> (instead of <code>n</code>, like mathlib does).</p>",
        "id": 208194586,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520421
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 208194589,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520424
    },
    {
        "content": "<p><del>Oops, you are right. Let me edit it.</del></p>",
        "id": 208194599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520438
    },
    {
        "content": "<p>ok, I will erase my comment, then!</p>",
        "id": 208194607,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520447
    },
    {
        "content": "<p>Now you might want to apply the lemma <code>add_comm : m + n = n + m</code>.</p>",
        "id": 208194677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520488
    },
    {
        "content": "<p>What does this lemma actually say under the hood?</p>",
        "id": 208194702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/integral.20domain/near/208194553\">said</a>:</p>\n<blockquote>\n<p>This is type class inference.</p>\n</blockquote>\n<p>I had read/heard these words, but not really internalized their meaning</p>",
        "id": 208194720,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520532
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">add_comm</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_semigroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_semigroup</span> <span class=\"n\">G</span><span class=\"o\">],</span> <span class=\"n\">add_comm_semigroup</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span>\n</code></pre></div>",
        "id": 208194741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520551
    },
    {
        "content": "<p>So lean says, ok, I'll need to find some <code>add_comm_semigroup</code> structure on the natural numbers, and it happily goes away and finds, mine. Out of that, it pulls the definition of addition.</p>",
        "id": 208194816,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520610
    },
    {
        "content": "<p>Let me explain a bit more.</p>",
        "id": 208194828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520629
    },
    {
        "content": "<p>In <code>a + b</code>, the <code>+</code> is notation for <code>has_add.add</code></p>",
        "id": 208194839,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520642
    },
    {
        "content": "<p>And lean knows that it can pull <code>has_add.add</code> out of an <code>add_comm_semigroup</code>.</p>",
        "id": 208194852,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520664
    },
    {
        "content": "<p>So, in the end, it will reduce the <code>m + n</code> to <code>nat.add m n</code>.</p>",
        "id": 208194872,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520691
    },
    {
        "content": "<p>However, in your <code>m + n</code>, it had figured out a different <code>nat.add' m n</code> where addition is defined by inducting on <code>m</code>.</p>",
        "id": 208194892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520718
    },
    {
        "content": "<p>And now it is stuck... because it doesn't know why the two are the same.</p>",
        "id": 208194941,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520734
    },
    {
        "content": "<p>Of course <em>we</em> can prove that they are the same. But Lean can't do so automatically.</p>",
        "id": 208194954,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520751
    },
    {
        "content": "<p>I see: this makes sense also in math!  You gave two different definitions of the same additions, but did not prove that they are indeed the same.  Is this what is happening?</p>",
        "id": 208194971,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520771
    },
    {
        "content": "<p>So you proofs no longer go smooth, because you will have to remind Lean all the time that two definitions are doing the same thing.</p>",
        "id": 208194981,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/integral.20domain/near/208194971\">said</a>:</p>\n<blockquote>\n<p>I see: this makes sense also in math!  You gave two different definitions of the same additions, but did not prove that they are indeed the same.  Is this what is happening?</p>\n</blockquote>\n<p>Almost. The trouble is. Even if we prove a lemma</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">add_eq_add&#39;</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add&#39;</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n</code></pre></div>\n\n\n<p>we would still need to mention this lemma <em>all the time</em>.</p>",
        "id": 208195020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520833
    },
    {
        "content": "<p>Whereas in maths, once you prove it, you can forget about it.</p>",
        "id": 208195066,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520845
    },
    {
        "content": "<p>This is starting to become clearer.  And it is also clear that I need to understand more about how things are defined in Lean in order to avoid such traps...</p>",
        "id": 208195077,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520853
    },
    {
        "content": "<p>The two defintions will merge into one thing.</p>",
        "id": 208195081,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520856
    },
    {
        "content": "<p>There is actually one really painful occurence of this issue in mathlib/Lean.</p>",
        "id": 208195107,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520875
    },
    {
        "content": "<p>The definition of <code>nat.pow</code> is not defeq to powers in arbitrary monoids.</p>",
        "id": 208195124,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520892
    },
    {
        "content": "<p>(But you don't see this in the notation.)</p>",
        "id": 208195132,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520901
    },
    {
        "content": "<p>Ah, the slogan that I heard from Kevin <em><code>=</code> is not an equivalence relation in Lean</em> surfaces in my mind</p>",
        "id": 208195157,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598520913
    },
    {
        "content": "<p>So we have to rewrite with <code>nat.pow_eq_pow</code>. (And you have to guess in which direction <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span>)</p>",
        "id": 208195165,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520924
    },
    {
        "content": "<p>This is something that we have to fix. But nobody has gone through the trouble so far.</p>",
        "id": 208195196,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520952
    },
    {
        "content": "<p>There are actually other instances as well. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> is a module over itself in two different ways.</p>",
        "id": 208195265,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598520986
    },
    {
        "content": "<ol>\n<li>every abelian group is a module over <code>int</code>.</li>\n<li>every ring is a module over itself.</li>\n</ol>",
        "id": 208195280,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521006
    },
    {
        "content": "<p>Ok, it helps a lot to understand the separation between mathematical issues and computer issues.  I feel that I am quite comfortable with the mathematical ones, that the computer ones have \"mirrors\" in maths, but I am not yet able to see through the mirror</p>",
        "id": 208195288,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521017
    },
    {
        "content": "<p>Currently these two are not defeq. Which causes pain.</p>",
        "id": 208195297,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521024
    },
    {
        "content": "<p>It would help a lot if we could teach lean: \"hey, all module instances of anything over <code>int</code> are always propositionally equal. Just use this fact an move on.\"</p>",
        "id": 208195341,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521077
    },
    {
        "content": "<p>Ok, so is this where the trouble with <code>is_integral_domain</code> and <code>integral_domain</code> begins?  That they are not defeq?</p>",
        "id": 208195389,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521088
    },
    {
        "content": "<p>But currently we don't have a way to teach Lean such a fact.</p>",
        "id": 208195392,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/integral.20domain/near/208195389\">said</a>:</p>\n<blockquote>\n<p>Ok, so is this where the trouble with <code>is_integral_domain</code> and <code>integral_domain</code> begins?  That they are not defeq?</p>\n</blockquote>\n<p>Not really.</p>",
        "id": 208195405,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521106
    },
    {
        "content": "<p>So let me try to explain that.</p>",
        "id": 208195423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521117
    },
    {
        "content": "<p>ok, thanks!</p>",
        "id": 208195429,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521122
    },
    {
        "content": "<p>Here is one very important fact: in Lean (but not in all other systems) we have <em>proof irrelevance</em>.</p>",
        "id": 208195451,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521144
    },
    {
        "content": "<p>Yes, I read about this and I am not sure where my (mathematical) stance is on this one!</p>",
        "id": 208195495,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521177
    },
    {
        "content": "<p>But I accept it!  Ahahaa</p>",
        "id": 208195516,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521187
    },
    {
        "content": "<p>That means that if <code>P : Prop</code>, and <code>h1</code> and <code>h2</code> are proofs of <code>P</code>. In other words <code>h1 : P</code> and <code>h2 : P</code>. Then <code>h1</code> and <code>h2</code> are defeq.</p>",
        "id": 208195517,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521187
    },
    {
        "content": "<p>This is baked into Lean core.</p>",
        "id": 208195534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521199
    },
    {
        "content": "<p>Ok, now I can also follow with the defeq definition from before!  This is great!  :)</p>",
        "id": 208195604,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521229
    },
    {
        "content": "<p>Yes, and it means that if we have a definition that depends on a proof of <code>P</code>. (Say <code>fin n</code>, which consists of <code>i : nat</code> and <code>h : i &lt; n</code>)</p>",
        "id": 208195652,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521276
    },
    {
        "content": "<p>Then <code>(i, h1)</code> is defeq to <code>(i, h2)</code>.</p>",
        "id": 208195681,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521295
    },
    {
        "content": "<p>So we don't care how to prove <code>i &lt; n</code>.</p>",
        "id": 208195695,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521302
    },
    {
        "content": "<p>Now, <code>is_integral_domain R : Prop</code>, because it assumes <code>[comm_ring R]</code> under the hood as an argument.</p>",
        "id": 208195763,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521332
    },
    {
        "content": "<p>So it doesn't matter how you prove <code>is_integral_domain R</code>, all of them are the same to Lean.</p>",
        "id": 208195780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521349
    },
    {
        "content": "<p>But <code>integral_domain R</code> records all the data, because it <em>extends</em> <code>has_add</code> and <code>has_mul</code>, etc...</p>",
        "id": 208195806,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521380
    },
    {
        "content": "<p>So, in your setup, you has <code>A</code> and <code>B</code>, and both of them already had a <code>comm_ring</code> instance.</p>",
        "id": 208195840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521406
    },
    {
        "content": "<p>So Lean already knew about <code>has_add A</code> and <code>has_add B</code>.</p>",
        "id": 208195847,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521421
    },
    {
        "content": "<p>So now, what you really don't want to do, is transfer <code>has_add B</code> along an equivalence to obtain a new version of <code>has_add A</code>.</p>",
        "id": 208196065,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521582
    },
    {
        "content": "<p>Because then, all of a sudden, there are two. And they are only propositionally equal.</p>",
        "id": 208196082,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521609
    },
    {
        "content": "<p>This would be a (dire) consequence of using <code>is_integral_domain</code> as opposed to <code>integral_domain</code>, right?</p>",
        "id": 208196116,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521645
    },
    {
        "content": "<p>So, when you extend <code>comm_ring A</code> to <code>integral_domain A</code>, you need to make sure that all the data fields are defeq to what you had. But for the fields that are props, it doesn't matter what you do.</p>",
        "id": 208196120,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521651
    },
    {
        "content": "<p>So transferring <code>is_integral_domain</code> is harmless.</p>",
        "id": 208196137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521665
    },
    {
        "content": "<p>But transferring <code>integral_domain</code> can be dangerous.</p>",
        "id": 208196143,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598521675
    },
    {
        "content": "<p>Ah, I got it mixed up...</p>",
        "id": 208196228,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521717
    },
    {
        "content": "<p>I need to think this through more carefully, then</p>",
        "id": 208196265,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521755
    },
    {
        "content": "<p>this is all theoretical</p>",
        "id": 208196383,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598521835
    },
    {
        "content": "<p>you'll internalize it once you run into errors</p>",
        "id": 208196387,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598521841
    },
    {
        "content": "<p>I am a little puzzled about this <code>has_add</code> not remembering the proof.  I could put two ring structures on a set with 4 elements: Z/4 and (Z/2)^2.  If Lean forgets how I proved that there was an addition, how will it know which addition to use?</p>",
        "id": 208196419,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598521874
    },
    {
        "content": "<p><code>has_add</code> is data</p>",
        "id": 208196516,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598521948
    },
    {
        "content": "<p>I don't understand what you mean by not remembering the proof</p>",
        "id": 208196523,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598521957
    },
    {
        "content": "<p>proof irrelevance only concerns propositions not data</p>",
        "id": 208196535,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598521965
    },
    {
        "content": "<p>I was trying to contrast this with </p>\n<p><a href=\"#narrow/stream/113489-new-members/topic/integral.20domain/near/208196065\">said</a>:</p>\n<blockquote>\n<p>So now, what you really don't want to do, is transfer <code>has_add B</code> along an equivalence to obtain a new version of <code>has_add A</code>.</p>\n</blockquote>",
        "id": 208196704,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598522089
    },
    {
        "content": "<p>For the moment, I have been able to prove both results <code>integral_domain R</code> and <code>is_integral_domain R</code>, so I am happy.  The discussion here has helped clarify a lot of hazy stuff, but I still need time to process these concepts.  Thank you all for your time and help!</p>",
        "id": 208197094,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598522338
    },
    {
        "content": "<p><code>has_add</code> is data, not a proof, so proof irrelevance doesn't apply to it. We don't say things like \"I proved that there was an addition\" (it's imprecise at best even in ordinary mathematics).</p>",
        "id": 208197364,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598522527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/integral.20domain/near/208195495\">said</a>:</p>\n<blockquote>\n<p>Yes, I read about this and I am not sure where my (mathematical) stance is on this one!</p>\n</blockquote>\n<p>This might be because you are identifying some things as proofs that Lean doesn't consider to be proofs.</p>",
        "id": 208197446,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598522607
    },
    {
        "content": "<p>Ah, so this is precisely the reason why the addition is carried along an equivalence and might cause problems <em>on the other side</em>?</p>",
        "id": 208197464,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598522626
    },
    {
        "content": "<p>It is carried along, because it contains actual instructions on how to perform the addition that have nothing to do with proving stuff about it.  Maybe I am understanding what is going on</p>",
        "id": 208197566,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598522677
    },
    {
        "content": "<p>I think that I see my mistake: when I read that <code>has_add</code> was passed along an equivalence, I thought that Lean simply remembered that there was an addition on one of the two sides.  However, if I understand correctly, Lean remembers exactly how to perform the addition and now has two well-defined additions on the same type and can be stuck.  Hopefully this is correct!</p>",
        "id": 208197793,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598522848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/integral.20domain/near/208197464\">said</a>:</p>\n<blockquote>\n<p>Ah, so this is precisely the reason why the addition is carried along an equivalence and might cause problems <em>on the other side</em>?</p>\n</blockquote>\n<p>Right!</p>",
        "id": 208197809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598522861
    },
    {
        "content": "<p>You want to transfer the proof that addition is commutative. But not the defintion of addition itself.</p>",
        "id": 208197831,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598522881
    },
    {
        "content": "<p>I don't really know what the context was, but:</p>\n<ul>\n<li>Even in ordinary math, you could certainly define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span></span></span></span> on something in two different ways. Generally we try to pick just one way because otherwise things would get confusing quickly.</li>\n<li>In Lean, if we have two definitions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span></span></span></span> on something, it's not sufficient that they be merely equal by a theorem, because Lean doesn't just know this theorem. You really want them to be the same by definiiton.</li>\n</ul>",
        "id": 208197893,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598522902
    },
    {
        "content": "<p>Ok, I am getting the hang of this: thank you so much!</p>",
        "id": 208198054,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1598523014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/integral.20domain/near/208195341\">said</a>:</p>\n<blockquote>\n<p>It would help a lot if we could teach lean: \"hey, all module instances of anything over <code>int</code> are always propositionally equal. Just use this fact an move on.\"</p>\n</blockquote>\n<p>import tactic<br>\nimport algebra.module.basic</p>\n<p>example (M : Type) [add_comm_group M] : subsingleton (module ℤ M) := by apply_instance</p>\n<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>",
        "id": 208262076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598555244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Sure, but that's not enough</p>",
        "id": 208262219,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598555299
    },
    {
        "content": "<p>Because Lean doesn't use that fact when it hits a wall</p>",
        "id": 208262246,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598555316
    },
    {
        "content": "<p>And of course there is the other problem that <code>has_scalar Z M</code> is not a subsingleton... so if it hits two different <code>has_scalar</code> instances then there's a nastier issue</p>",
        "id": 208262346,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598555377
    }
]
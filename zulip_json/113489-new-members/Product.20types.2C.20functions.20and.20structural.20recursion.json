[
    {
        "content": "<p>Hello all; I was writing some test code in Lean, and encountered the following situation:</p>\n<p>Let <code>idBool : List Bool -&gt; List Bool</code> be the identity function on the type. Define the following two functions in Lean 4, together with the identity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">idBool</span> <span class=\"o\">(</span><span class=\"n\">inp</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">inp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">TermBool</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermBool</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">idBool</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lean happily accepts the first function, but has trouble proving that the second one terminates: removing the <code>partial</code> marker gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fail</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">termination</span> <span class=\"n\">for</span>\n  <span class=\"n\">TermBool</span><span class=\"bp\">?</span>\n<span class=\"k\">with</span> <span class=\"n\">errors</span>\n<span class=\"n\">structural</span> <span class=\"n\">recursion</span> <span class=\"n\">cannot</span> <span class=\"n\">be</span> <span class=\"n\">used</span>\n\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n</code></pre></div>\n<p>My question is: what is the reason for the rejection in the second situation, and how can one provide evidence of termination?  More generally, if we have an arbitrary (properly defined) function <code>F : List Bool -&gt; List Bool</code>, where is Lean stuck proving termination of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">TermF</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">\\</span><span class=\"n\">x</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and how can we overcome this?</p>\n<p>Thanks a lot for your time!</p>",
        "id": 321453746,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1673770310
    },
    {
        "content": "<p>There's a couple of solutions to your problem.</p>\n<ol>\n<li>Make <code>idBool</code> an <code>abbrev</code>:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">idBool</span> <span class=\"o\">(</span><span class=\"n\">inp</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">inp</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Provide <code>TermBool?</code> in curried form:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">idBool</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n<ol start=\"3\">\n<li>Explicitly tell Lean which part is decreasing when recursing:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">idBool</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">TermBool</span><span class=\"bp\">?</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span>\n</code></pre></div>\n<p>Options 2 and 3 also work for your general <code>TermF?</code>.</p>",
        "id": 321455090,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1673771429
    },
    {
        "content": "<p>As to what's causing the problem in the first place, I think it's the following (please correct me if this is wrong).<br>\nIf we consider the recursive case in <code>TermF?</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermF</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>... for the recursion to be allowed, Lean tries to show that <code>(k, F L)</code> is smaller than <code>(Nat.succ k, L)</code> wrt. to some well-founded relation.<br>\nThe way Lean handles this by default is by assigning a <code>Nat</code> to both terms: <code>sizeOf (k, F L) = n</code> and <code>sizeOf (Nat.succ k, L) = m</code>. Then Lean tries to prove <code>n &lt; m</code>, which thus ensures that the recursion is decreasing.<br>\nThe <code>sizeOf</code> function comes from the <code>SizeOf</code> type class:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">SizeOf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">sizeOf</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>Lean creates instances of this for any type you define automatically.<br>\nIf we now check what the sizes are for some concrete values of type <code>Nat × List Bool</code>, we can see why Lean can't prove that the recursive call in <code>TermF?</code> is decreasing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#reduce</span> <span class=\"n\">sizeOf</span> <span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">])</span> <span class=\"c1\">-- 14</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">sizeOf</span> <span class=\"o\">(</span><span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">])</span> <span class=\"c1\">-- 15</span>\n</code></pre></div>\n<p>Here, even though the first member of the tuple decreased, the increased size of the second member caused the total size of the tuple to increase. Thus, Lean couldn't prove termination.</p>",
        "id": 321456919,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1673772993
    },
    {
        "content": "<p>Thank you so much for the detailed explanation of what is going on behind the scenes!  I see now that your solution 3 is the most satisfactory for me if I want to <em>insist</em> that the function's signature is some <code>Prod -&gt; Prod</code>.</p>",
        "id": 321464450,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1673778498
    },
    {
        "content": "<p>Or you can use 2, and then provide an uncurried wrapper. That would reduce better.</p>",
        "id": 321492259,
        "sender_full_name": "Reid Barton",
        "timestamp": 1673792369
    }
]
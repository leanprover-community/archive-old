[
    {
        "content": "<p>I am having trouble with this simple lemma.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">zero_eq_zero</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>In fact, I have been able to prove this, which I thought would already be in mathlib:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">zero_iff_n_divides</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span>  <span class=\"err\">∣</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n        <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">finish</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">@@</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">val_lt</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">hw</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n        <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mul_lt_iff_lt_one_right</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>and I can't seem to prove the analogous one for integers:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">zero_iff_n_divides&#39;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">):=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n        <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span>\n            <span class=\"k\">have</span> <span class=\"n\">hw0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">nlinarith</span><span class=\"o\">,</span>\n            <span class=\"n\">exact</span> <span class=\"n\">zero_eq_zero</span> <span class=\"n\">hw0</span><span class=\"o\">,</span>\n        <span class=\"o\">},</span>\n        <span class=\"n\">sorry</span>\n    <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Incidentally, I don't see with the typeclass inference system doesn't work in this case (hence the two occurrences of _inst_1 in the proof). Is there something that I am overlooking?</p>\n<p>Thank you!</p>",
        "id": 208093798,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598450130
    },
    {
        "content": "<p>Can you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? You're missing one or more of imports, variables, opens, universes</p>",
        "id": 208094032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450233
    },
    {
        "content": "<p><code>&lt;</code> is not a class, so <code>[0 &lt; n]</code> won't work. Inputs to functions in <code>[square brackets]</code> are supposed to be filled in by the type class inference system, and the type class inference system only deals with classes, so it won't deal with <code>&lt;</code>.</p>",
        "id": 208094259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450320
    },
    {
        "content": "<p>I feel like some people might think I'm just nagging when I ask for MWE's, but I genuinely don't know what to import to get zmod and I'm too lazy to find out.</p>",
        "id": 208094498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450406
    },
    {
        "content": "<p>That compiles in my system.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">zero_eq_zero</span>  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 208094576,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598450446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208094498\">said</a>:</p>\n<blockquote>\n<p>I feel like some people might think I'm just nagging when I ask for MWE's, but I genuinely don't know what to import to get zmod and I'm too lazy to find out.</p>\n</blockquote>\n<p>I am not one of those people.</p>",
        "id": 208094670,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598450487
    },
    {
        "content": "<p>You're using a coercion from zmod n to Z? Eew. I am surprised there is even a coercion :-)</p>",
        "id": 208094703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450496
    },
    {
        "content": "<p>Well somewhere in Zulip I saw that it's best to work with int than with nat whenever possible.</p>",
        "id": 208094936,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598450581
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"err\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>I don't know what the definition of that arrow is yet</p>",
        "id": 208094949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254058\">Marc Masdeu</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208094936\">said</a>:</p>\n<blockquote>\n<p>Well somewhere in Zulip I saw that it's best to work with int than with nat whenever possible.</p>\n</blockquote>\n<p>that surely highly depends on context</p>",
        "id": 208095117,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598450644
    },
    {
        "content": "<p>I say that if you're in zmod you shouldn't coerce to int</p>",
        "id": 208095144,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598450657
    },
    {
        "content": "<p>or to nat</p>",
        "id": 208095164,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598450662
    },
    {
        "content": "<p>If you plan to do subtractions you shouldn't be using nat because it doesn't have a subtraction (it's a semiring, not a ring)</p>",
        "id": 208095212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208094949\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"err\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>I don't know what the definition of that arrow is yet</p>\n</blockquote>\n<p>Kevin, we longer have this issue since Ed offered us magic widgets.</p>",
        "id": 208095261,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598450710
    },
    {
        "content": "<p>Just click on the arrow.</p>",
        "id": 208095285,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598450722
    },
    {
        "content": "<p>What I want is an easy way to go from x=y (in zmod n) to n dividing x'-y', where x' and y' are lifts to integers. So here is where subtraction appears.</p>",
        "id": 208095296,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598450728
    },
    {
        "content": "<p>when we say \"lift\", we choose x' first</p>",
        "id": 208095329,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598450749
    },
    {
        "content": "<p>what are x' and y'? Are they arbitrary? Is this a theorem about x and y, or about x' and y'?</p>",
        "id": 208095380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450762
    },
    {
        "content": "<p>i.e. rather than using the standard lift that isn't canonical, instead let the integer be the variable</p>",
        "id": 208095401,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598450772
    },
    {
        "content": "<p>so the \"correct\" theorem should say that for x y : Z, (x : zmod n) = y &lt;-&gt; n | (x - y)</p>",
        "id": 208095437,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598450793
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/mUaX_-qQkVNr0zek6n8vdPVp/uparrow2.png\">uparrow2.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/mUaX_-qQkVNr0zek6n8vdPVp/uparrow2.png\" title=\"uparrow2.png\"><img src=\"/user_uploads/3121/mUaX_-qQkVNr0zek6n8vdPVp/uparrow2.png\"></a></div>",
        "id": 208095443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450796
    },
    {
        "content": "<p>coercing from int to zmod is good; from zmod to int is bad</p>",
        "id": 208095452,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598450801
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I said I didn't know the definition precisely because this trick told me nothing</p>",
        "id": 208095463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450810
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">has_lift</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">tactic.mk_instance failed to generate instance for</span>\n<span class=\"cm\">  has_lift (zmod n) ℤ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 208095528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450843
    },
    {
        "content": "<p>I've never understood the zoo of lifts and coercions properly</p>",
        "id": 208095545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450856
    },
    {
        "content": "<p>The trick tells you this is coercion from <code>zmod n</code> to <code>int</code>, that's infinitely more information than what you would have had before widgets.</p>",
        "id": 208095582,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598450874
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">tactic.mk_instance failed to generate instance for</span>\n<span class=\"cm\">  has_coe (zmod n) ℤ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 208095642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208095582\">said</a>:</p>\n<blockquote>\n<p>The trick tells you this is coercion from <code>zmod n</code> to <code>int</code>, that's infinitely more information than what you would have had before widgets.</p>\n</blockquote>\n<p>I already knew that from the lemma statement <code>lemma zero_eq_zero  {x : zmod n} (h : (x : ℤ) = 0) : x = 0 :=</code></p>",
        "id": 208095697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450920
    },
    {
        "content": "<p>I genuinely don't know how to work out what the map is</p>",
        "id": 208095728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598450932
    },
    {
        "content": "<p>oh -- I keep going with the widgets!</p>",
        "id": 208095894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451005
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/VAMedzE_4iIR6nCMr1zp9Zbf/tada.png\">tada.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/VAMedzE_4iIR6nCMr1zp9Zbf/tada.png\" title=\"tada.png\"><img src=\"/user_uploads/3121/VAMedzE_4iIR6nCMr1zp9Zbf/tada.png\"></a></div>",
        "id": 208095971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451050
    },
    {
        "content": "<p>what is that cursed instance</p>",
        "id": 208096021,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451077
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- Cast an integer modulo `n` to another semiring.</span>\n<span class=\"cm\">This function is a morphism if the characteristic of `R` divides `n`.</span>\n<span class=\"cm\">See `zmod.cast_hom` for a bundled version. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">cast</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"c1\">-- see Note [coercion into rings]</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">priority</span> <span class=\"mi\">900</span><span class=\"o\">]</span> <span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_t</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">cast</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">cast_zero</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 208096114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  <a href=\"https://github.com/leanprover-community/mathlib/pull/3882#discussion_r475005206\">https://github.com/leanprover-community/mathlib/pull/3882#discussion_r475005206</a></p>",
        "id": 208096194,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1598451137
    },
    {
        "content": "<p>This coercion has no good ring-theoretic properties. <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> the Teichmuller lift is at least a homomorphism of monoids with zero :-)</p>",
        "id": 208096491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451267
    },
    {
        "content": "<p>OK I'll try to explain myself a bit better. I was trying to prove</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">basic_lemma</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n   <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>This is a statement about elements all in zmod (either p or p^r). It seems that it should be very easy, but I got this so far:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">basic_lemma</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span>  <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">r</span> <span class=\"err\">∣</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">have</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span>  <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">sub_eq_zero</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"c1\">--rw_mod_cast zmod.int_coe_zmod_eq_zero_iff_dvd at h&#39;,</span>\n        <span class=\"n\">sorry</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h1</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">h1w</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">h1w</span><span class=\"o\">,</span>\n        <span class=\"n\">ring</span><span class=\"o\">,</span>\n        <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">induction</span> <span class=\"n\">r</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n            <span class=\"o\">{</span>\n                <span class=\"n\">linarith</span><span class=\"o\">,</span>\n            <span class=\"o\">},</span>\n            <span class=\"o\">{</span>\n                <span class=\"n\">ring</span><span class=\"o\">,</span>\n                <span class=\"n\">ring</span><span class=\"o\">,</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">},</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">hp</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">have</span> <span class=\"n\">hfac</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n                    <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">:</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">hfac</span> <span class=\"n\">at</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"bp\">.</span><span class=\"n\">dvd_mul&#39;</span> <span class=\"n\">hp</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h3</span> <span class=\"k\">with</span> <span class=\"n\">h3l</span> <span class=\"n\">h3r</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">left</span><span class=\"o\">,</span>\n        <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">sub_eq_zero</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span><span class=\"err\">←</span> <span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">int_coe_zmod_eq_zero_iff_dvd</span> <span class=\"o\">(((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">):</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">at</span> <span class=\"n\">h3l</span><span class=\"o\">,</span>\n        <span class=\"n\">push_cast</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"bp\">@@</span><span class=\"n\">x_val_trans</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"n\">at</span> <span class=\"n\">h3l</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">h3l</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">right</span><span class=\"o\">,</span>\n        <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">eq_neg_of_add_eq_zero</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span><span class=\"err\">←</span> <span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">int_coe_zmod_eq_zero_iff_dvd</span> <span class=\"o\">(((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">):</span><span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">at</span> <span class=\"n\">h3r</span><span class=\"o\">,</span>\n        <span class=\"n\">push_cast</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"bp\">@@</span><span class=\"n\">x_val_trans</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"n\">at</span> <span class=\"n\">h3r</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">h3r</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>So I find myself trying to prove</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"err\">↑</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">r</span> <span class=\"err\">∣</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n</code></pre></div>\n\n\n<p>in the realm of int...</p>",
        "id": 208096526,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598451285
    },
    {
        "content": "<p>To prove the basic lemma, let xbar be x mod p and deduce that xbar^2=1 and then you're done because zmod p is a field, right?</p>",
        "id": 208096728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451372
    },
    {
        "content": "<p>This was my math proof, but I had a bit more trouble writing it in Lean!</p>",
        "id": 208096875,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598451444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> right, so the problem is how to coerce from zmod (p^r) to zmod p</p>",
        "id": 208096894,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451454
    },
    {
        "content": "<p>now that cursed instance seems like a good candidate</p>",
        "id": 208096931,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451477
    },
    {
        "content": "<p>because zmod p does have characteristic dividing p^r</p>",
        "id": 208096981,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451486
    },
    {
        "content": "<p>But <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> this coercion should be simple, right?</p>",
        "id": 208097009,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598451494
    },
    {
        "content": "<p>so maybe <code>zmod.cast_hom</code> would help</p>",
        "id": 208097035,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451505
    },
    {
        "content": "<p>In the situation where the coercion is ring-theoretically reasonable one should use the ring-theoretic coercion I guess</p>",
        "id": 208097246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451601
    },
    {
        "content": "<p>I feel like this is still <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a></p>",
        "id": 208097374,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451655
    },
    {
        "content": "<p>the \"basic lemma\" has a coercion from zmod (p^r) to zmod p</p>",
        "id": 208097412,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451671
    },
    {
        "content": "<p>what demanded this coercion to start with?</p>",
        "id": 208097420,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1598451677
    },
    {
        "content": "<p>There is no API for it and it's a horrible function, so it's horrible to use.</p>",
        "id": 208097462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451703
    },
    {
        "content": "<p>OK the feeling I had throughout is that zmod's API is not quite working yet. It is very hard to work with it, since it has references to %, to MOD, ...</p>",
        "id": 208097617,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598451765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20that.200.20.3D.200.20in.20zmod/near/208097374\">said</a>:</p>\n<blockquote>\n<p>I feel like this is still <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a></p>\n</blockquote>\n<p>You got me. I want to prove that in Z/p^r  (p odd) the only solutions to x^2-1=0 are 1 and -1. The way I can prove this is to lift x to x'=+-1 + e, with e being a multiple of p (hence the basic lemma). Then I prove that p^r divides e, here is where I use that p is odd.</p>",
        "id": 208097984,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598451925
    },
    {
        "content": "<p>right, that looks like the standard proof.</p>",
        "id": 208098113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598451974
    },
    {
        "content": "<p>I might start from scratch...</p>",
        "id": 208098764,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598452241
    },
    {
        "content": "<p>rofl <code>cast</code> uses <code>nat.cast_coe</code> because it's coercing to a general ring, as opposed to the standard coercion from nat to int.</p>",
        "id": 208100005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598452778
    },
    {
        "content": "<p>so the issue is to prove that <code>nat.cast_coe</code> is injective when going from nat to int.</p>",
        "id": 208100141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598452823
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">zero_eq_zero</span>  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">-- this workaround is because you&#39;re using `fact`</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">unfreeze_local_instances</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- deal with n = 0 case</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now n = d + 1</span>\n  <span class=\"c1\">-- now take x apart</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now a is a natural</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- and it suffices to prove a = 0,</span>\n  <span class=\"n\">unfold_coes</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- zmod.cast has no API because nobody uses it</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"bp\">.</span><span class=\"n\">equations</span><span class=\"bp\">._</span><span class=\"n\">eqn_2</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- We know the usual map ℕ → ℤ is injective</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_eq_zero</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- so we would be done by h</span>\n  <span class=\"n\">convert</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- except we now have to prove that the two coercions ℕ → ℤ are equal.</span>\n  <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span> <span class=\"n\">has_coe_t</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- we prove it by induction</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">hd</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>You're really fighting the system here because the casts don't have too much API</p>",
        "id": 208101618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453398
    },
    {
        "content": "<p>My apologies for the awful coercion. I don't know how to improve it.</p>",
        "id": 208102192,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598453605
    },
    {
        "content": "<p>Wow! That is incredibly hard!! Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, this is the kind of thing that throw some people off...</p>",
        "id": 208102248,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598453632
    },
    {
        "content": "<p>Because it's so general it's hard to find lemmas about it.</p>",
        "id": 208102255,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453636
    },
    {
        "content": "<p>What's going on here Marc is that there is a map from Z/nZ to <em>any ring</em> given by literally sending 0,1,2,...,n-1 to 0,1,2,...,n-1. There aren't really any lemmas you can prove about it.</p>",
        "id": 208102392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453673
    },
    {
        "content": "<p>However, for a given ring like the integers, there are lemmas you can prove (for example injectivity)</p>",
        "id": 208102450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453699
    },
    {
        "content": "<p>but these lemmas are not proved, as far as I can see.</p>",
        "id": 208102497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453715
    },
    {
        "content": "<p>because probably there are a million such lemmas. We know that \"if x is in Z/nZ then lift x to Z\" is a reasonable thing to do</p>",
        "id": 208102573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453754
    },
    {
        "content": "<p>but \"if x is in Z/nZ then randomly map it to Z/mZ\" is perhaps not so common</p>",
        "id": 208102639,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453770
    },
    {
        "content": "<p>I see. Yes, the general map is a bit dumb, but it's very common <strong>as you know</strong> in arithmetic to lift elements in Z/n to Z and then prove things about those lifts, so it'd be useful to have some lemmas about this.</p>",
        "id": 208102676,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598453791
    },
    {
        "content": "<p>It might be interesting <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> to see how many times in the library this map is used when the target ring is not nat or int. If people are only using it to lift from Z/n to Z (this is Marc's use case and also yours in the PR) then perhaps it's worth restricting to that case and then writing the API which Marc needed here.</p>",
        "id": 208102819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453854
    },
    {
        "content": "<p>Maybe it'd be best to do as in mathlib, start with integers and prove things about their images in various zmods</p>",
        "id": 208102869,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598453879
    },
    {
        "content": "<p>right, that's another way of thinking about it.</p>",
        "id": 208102954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453899
    },
    {
        "content": "<p>There is congruence mod n in mathlib, and it's an equivalence relation on integers</p>",
        "id": 208102984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453919
    },
    {
        "content": "<p>and that has a whole file of API, a very solid one.</p>",
        "id": 208103019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453934
    },
    {
        "content": "<p>Yes, I will want to work with the ring (and its units) zmod n, so I'd rather not think in terms of equivalence relations...</p>",
        "id": 208103082,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598453963
    },
    {
        "content": "<p>I feel like lifting from Z/p^n to Z/p^(n+1) is still a useful thing though</p>",
        "id": 208103095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598453966
    },
    {
        "content": "<p>Ideally, it would be easy to go back and forth between all these objects.</p>",
        "id": 208103139,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598453986
    },
    {
        "content": "<p>but I would be strongly tempted here not to use the cast. It <em>is</em> easy to go back and forth between these objects, because you can do it directly without using the coercion.</p>",
        "id": 208103255,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598454015
    },
    {
        "content": "<p>I'll try...</p>",
        "id": 208103378,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598454059
    },
    {
        "content": "<p>If n&gt;0 then a term of type <code>zmod n</code> is just a pair (a,h) with a a natural and h a proof that it's less than n. So you can just use (a,h') to move from Z/n to Z/(pn) where h' is a proof that a&lt;pn manufactured from the proof that it's less than n</p>",
        "id": 208103457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598454099
    },
    {
        "content": "<p>It would be very easy to prove things about that map because it's defined concretely on the level of integers without using nat.cast or zmod.cast</p>",
        "id": 208103579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598454139
    },
    {
        "content": "<p>I can't find x^2=1 -&gt; x=+-1 in a field</p>",
        "id": 208104739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598454632
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_self_eq_one_iff\">docs#mul_self_eq_one_iff</a></p>",
        "id": 208105088,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1598454797
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">cast_hom</span>\n\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">div_pow</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">-- do a case split on r=0 or r=s+1</span>\n  <span class=\"n\">cases</span> <span class=\"n\">r</span> <span class=\"k\">with</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- r=0 can&#39;t happen</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hr</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- r = s + 1 so we can use nat.pow_succ</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- library_search found the next line</span>\n    <span class=\"n\">apply</span> <span class=\"n\">dvd_mul_left</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">include</span> <span class=\"n\">hp</span> <span class=\"n\">hn</span> <span class=\"n\">hm</span> <span class=\"n\">hr</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">basic_lemma</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">cast_hom</span> <span class=\"o\">(</span><span class=\"n\">div_pow</span> <span class=\"n\">p</span> <span class=\"n\">hr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"c1\">-- the ring hom</span>\n  <span class=\"n\">set</span> <span class=\"n\">xp</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"n\">hxp</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hxpsquared</span> <span class=\"o\">:</span> <span class=\"n\">xp</span> <span class=\"bp\">*</span> <span class=\"n\">xp</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hxp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"o\">:=</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">mul_self_eq_one_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hxpsquared</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 208105719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598454977
    },
    {
        "content": "<p>Note that mathlib knows that <code>coe : int → zmod n</code> is surjective. In fact it knows that arbitrary ring homs to <code>zmod n</code> are surjective.</p>",
        "id": 208110429,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598457140
    },
    {
        "content": "<p>I guess that might be helpful...</p>",
        "id": 208110441,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598457147
    },
    {
        "content": "<p>But I haven't thought about the details of what's going on here.</p>",
        "id": 208110462,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1598457163
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">cast_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">},</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">int</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">val_injective</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_inj</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">zero_eq_zero</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">cast_inj</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 208122490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598463027
    },
    {
        "content": "<p>Right! And now if we want to prove it for rationals, you have to prove a whole new cast_inj :-(</p>",
        "id": 208122552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598463060
    },
    {
        "content": "<p>I tried to generalize it but <code>char_p</code> wasn't built to handle this</p>",
        "id": 208122719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598463146
    },
    {
        "content": "<p>I don't know how to say \"R is a ring with the first n elements distinct\"</p>",
        "id": 208122740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598463165
    },
    {
        "content": "<p>Anyway this proof doesn't really generalize because the zero case uses <code>int.cast_id</code></p>",
        "id": 208122852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598463242
    },
    {
        "content": "<p>so a different ring would actually be substantively different</p>",
        "id": 208122944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598463271
    },
    {
        "content": "<p>Thanks for the discussion. I am slowly understanding how this is working...</p>",
        "id": 208128926,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1598466334
    }
]
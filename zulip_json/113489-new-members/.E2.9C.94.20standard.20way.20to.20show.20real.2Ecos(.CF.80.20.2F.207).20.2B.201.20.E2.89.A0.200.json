[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"494394\">wendy shang</span> has marked this topic as resolved.</p>",
        "id": 280053722,
        "sender_full_name": "Notification Bot",
        "timestamp": 1650885343
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"456794\">@Patrick Johnson</span> , Thank you so much for the concise solution but unfortunately I have a lot of trouble fully understanding its construction <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>This is my very-much-naive-tedious-suboptimal way of interpreting your solution in a manner that I fully understand the logic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.trigonometric.basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">real</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">real</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span><span class=\"n\">eq_neg_iff_add_eq_zero</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span><span class=\"n\">cos_pi</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">π</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n  <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">pi_pos</span><span class=\"o\">],</span>\n  <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span> <span class=\"bp\">≤</span> <span class=\"n\">real.pi</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"n\">real.cos</span> <span class=\"n\">π</span> <span class=\"bp\">&lt;</span> <span class=\"n\">real.cos</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">),</span> <span class=\"o\">{</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">cos_lt_cos_of_nonneg_of_le_pi</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"n\">π</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">],</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">pi_pos</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">],</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">p</span> <span class=\"n\">at</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>If you may elaborate on the train of logic behind the concise tactics in your solution that would be great! and how they correspond to my writeup. <br>\nBut here are some of my more specific questions:<br>\n(1) is the first tactic being applied <code>linarith [pi_pos]</code>?  however in your solution there is no need to use <code>have</code> or additional hypothesis. Is it because of the use of  <code>by</code>? and what is the consequence after executing <code>linarith [pi_pos]</code>?<br>\n(2) what are some good rule-of-thumb advice in using <code>by</code>?<br>\n(3) is <code>apply @cos_lt_cos_of_nonneg_of_le_pi (π / 7) π</code> used after <code>cos_pi</code>? but there is a <code>by</code> in front of <code>apply</code> and i am confused over their (<code>cos_pi</code>, <code>apply</code>) relationsip.<br>\n(4) what is the functionality of <code>@</code> in front of  <code>os_lt_cos_of_nonneg_of_le_pi </code>?</p>\n<p>I apologize for having so much difficulty following your solution...and thank you for your patience in advance!</p>",
        "id": 280140496,
        "sender_full_name": "wendy shang",
        "timestamp": 1650927505
    },
    {
        "content": "<p><code>linarith [x, y]</code> is equivalent to <code>have h₁ := x, have h₂ := y, linarith</code>, so the lemma can be written as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">cos_pi</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">cos_lt_cos_of_nonneg_of_le_pi</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"n\">π</span><span class=\"bp\">;</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">pi_pos</span><span class=\"o\">],</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>That can be expanded further to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">cos_pi</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">cos</span> <span class=\"n\">π</span> <span class=\"bp\">&lt;</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">pi_pos</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"n\">π</span> <span class=\"bp\">≤</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₅</span> <span class=\"o\">:</span> <span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span> <span class=\"bp\">&lt;</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">pi_pos</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">cos_lt_cos_of_nonneg_of_le_pi</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span> <span class=\"n\">h₅</span> <span class=\"o\">},</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280145719,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650931191
    },
    {
        "content": "<p>Regarding your questions:</p>\n<blockquote>\n<p>(1) is the first tactic being applied <code>linarith [pi_pos]</code>?</p>\n</blockquote>\n<p>Lean is a <a href=\"https://en.wikipedia.org/wiki/Lazy_evaluation\">lazy</a> programming language, so it does not make much sense to talk about the order of execution of tactics. Strictly speaking, the first thing that is evaluated in the tactic monad is <code>linarith [cos_pi, ...]</code>, which then evaluates the inner expressions.</p>\n<blockquote>\n<p>However in your solution there is no need to use <code>have</code> or additional hypothesis. Is it because of the use of by? and what is the consequence after executing <code>linarith [pi_pos]</code>?</p>\n</blockquote>\n<p>Since <code>linarith</code> can take a list of hypotheses as an argument, there is no need for <code>have</code>. We can simply provide the proofs of the hypotheses as an argument to <code>linarith</code>.</p>\n<blockquote>\n<p>(2) what are some good rule-of-thumb advice in using by</p>\n</blockquote>\n<p><code>by x</code> is equivalent to <code>begin x end</code>. It is used when we have only one tactic, so there is no need to open a <code>begin ... end</code> block. Also, <code>by {x, y, z}</code> is equivalent to <code>begin x, y, z end</code>.</p>\n<blockquote>\n<p>(3) is <code>apply @cos_lt_cos_of_nonneg_of_le_pi (π / 7) π</code> used after <code>cos_pi</code>? but there is a <code>by</code> in front of apply and i am confused over their (<code>cos_pi</code>, <code>apply</code>) relationsip.<br>\n(4) what is the functionality of <code>@</code> in front of <code>cos_lt_cos_of_nonneg_of_le_pi</code>?</p>\n</blockquote>\n<p>We provide two hypotheses to <code>linarith</code>. The first hypothesis is <code>cos π = -1</code> and its proof is <code>cos_pi</code>. The second hypothesis is <code>cos π &lt; cos (π / 7)</code> and we prove it using <code>cos_lt_cos_of_nonneg_of_le_pi</code>. If you look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/real.cos_lt_cos_of_nonneg_of_le_pi\">docs#real.cos_lt_cos_of_nonneg_of_le_pi</a>, you can see that it has the following form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">cos_lt_cos_of_nonneg_of_le_pi</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">π</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">cos</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">cos</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Arguments <code>x</code> and <code>y</code> are implicit. To make them explicit, we put <code>@</code> before the theorem name. We then provide <code>(π / 7)</code> for <code>x</code> and <code>π</code> for <code>y</code>. Now, we need proofs for <code>0 ≤ π / 7</code>, <code>π ≤ π</code> and <code>π / 7 &lt; π</code>. All of them can be proved by <code>linarith [pi_pos]</code>, so we put semicolon and then <code>linarith [pi_pos]</code>. Semicolon means: apply the thing on the right to all unsolved goals produced by the thing on the left. So, <code>linarith [pi_pos]</code> proves the three remaining statements.</p>",
        "id": 280145834,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1650931222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20standard.20way.20to.20show.20real.2Ecos.28.CF.80.20.2F.207.29.20.2B.201.20.E2.89.A0.200/near/280145834\">said</a>:</p>\n<blockquote>\n<p>Lean is a <a href=\"https://en.wikipedia.org/wiki/Lazy_evaluation\">lazy</a> programming language</p>\n</blockquote>\n<p>The tactic monad might be misleading -- Lean generally has strict evaluation. The evaluator has some special cases, like recursors can get compiled into conditional jumps, so those are, in a sense, lazy, but everything else is strict.</p>\n<p>With <code>linarith</code>, the interactive tactic gets a list of \"<code>pexpr</code>s\", which it then <a href=\"https://github.com/leanprover-community/mathlib/blob/8f604aa32be6acbbc0f28e24a47dfacf1da834f6/src/tactic/linarith/frontend.lean#L246\">elaborates</a> into \"<code>expr</code>s\" using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.i_to_expr\">docs#tactic.i_to_expr</a>. The elaborator is responsible for executing tactic blocks in <code>pexpr</code>s. It also has a mechanism where while it's elaborating an expression, it defers elaborating until after it elaborates the rest of an expression.</p>\n<p>Here's my understanding of the exact order of elaboration for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">cos</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">cos_pi</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">cos_lt_cos_of_nonneg_of_le_pi</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"bp\">/</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"n\">π</span><span class=\"bp\">;</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">pi_pos</span><span class=\"o\">]]</span>\n</code></pre></div>\n<ol>\n<li>the type <code>cos (π / 7) + 1 ≠ 0</code> is elaborated</li>\n<li>the <code>by linarith [cos_pi, by apply @cos_lt_cos_of_nonneg_of_le_pi (π / 7) π; linarith [pi_pos]]</code> block is deferred</li>\n<li>there is nothing more to elaborate, so that tactic block is evaluated</li>\n<li>the outer <code>linarith</code> asks the elaborator to elaborate its arguments in left-to-right order</li>\n<li><code>cos_pi</code> is elaborated</li>\n<li><code>by apply @cos_lt_cos_of_nonneg_of_le_pi (π / 7) π; linarith [pi_pos]</code> is elaborated by first deferring it but, since there's nothing else to do for this expression, the tactic block is evaluated</li>\n<li>the <code>;</code> combinator means the <code>apply @cos_lt_cos_of_nonneg_of_le_pi (π / 7) π</code> tactic is evaluated first</li>\n<li>(I'll assume this creates just a single goal for sake of simpler explanation, even though it produces three). the <code>linarith [pi_pos]</code> tactic is evaluated</li>\n<li>it asks the elaborator to elaborate <code>pi_pos</code>. Once that's done, the <code>linarith</code> tactic does the rest of what it does, closing the goal</li>\n<li><code>by apply @cos_lt_cos_of_nonneg_of_le_pi (π / 7) π; linarith [pi_pos]</code> is now done evaluating, and after a check that the term it constructed has no metavariables, it is done elaborating</li>\n<li>we go back to evaluating the rest of <code>linarith [cos_pi, by apply @cos_lt_cos_of_nonneg_of_le_pi (π / 7) π; linarith [pi_pos]]</code>, doing whatever <code>linarith</code> does, and then finally its tactic block is done</li>\n<li>now the right-hand side of the definition is fully elaborated.</li>\n</ol>",
        "id": 280149688,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650935025
    },
    {
        "content": "<p>The reason tactic blocks are deferred like this is that they do a lot better if the expected type is known.</p>",
        "id": 280149759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650935074
    },
    {
        "content": "<p>Although the description of tactic deferral is correct there, I don't think there is any nontrivial deferral going on in this example. You would normally only notice deferral in an expression like <code>(by foo) + bar</code> where if you set things up right you will be able to tell that <code>bar</code> is already elaborated when <code>foo</code> is called</p>",
        "id": 280154470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1650940065
    },
    {
        "content": "<p>Hmm, I'm actually wrong about how tactic deferral waits until the end of the expression. There are many places during elaboration where tactic evaluation can be triggered earlier than that...</p>\n<p>First, here's an example that is sort of what Mario was saying:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- both tactics deferred, and `by exact 37` happens after the first tactic block so it doesn't have an expected type</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"o\">})</span> <span class=\"bp\">+</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"mi\">37</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">solve1 tactic failed, focused goal has not been solved</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">⊢ ?m_1</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- tactic deferred, numerals processed before tactics, so tactic gets ℕ as expected type</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"o\">})</span> <span class=\"bp\">+</span> <span class=\"mi\">37</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">solve1 tactic failed, focused goal has not been solved</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">⊢ ℕ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>There's only one tactic queue, though, and many constructs call the <code>synthesize()</code> function, which ends up evaluating all deferred tactics.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- let blocks call synthesize right after elaborating the type and value for the let-bound variable,</span>\n<span class=\"c1\">-- so the `+` does not see the type of `x` before the tactic is evaluated</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"o\">})</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span> <span class=\"k\">in</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">solve1 tactic failed, focused goal has not been solved</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">⊢ ?m_1</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 280155705,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650941416
    },
    {
        "content": "<p>None of this affects Patrick's example, though, since every tactic block the elaborator sees is essentially evaluated immediately. I mainly brought up deferral since it's arguably a kind of laziness that exists during tactic evaluation.</p>",
        "id": 280155761,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650941521
    },
    {
        "content": "<p>wow thanks everyone for the in-depth discussion! <br>\nThank you Patrick for such detailed explanations!  (I didn't even know how to phrase the questions well but you pinned down the exact points of my ambiguous questions!)</p>\n<p>I have really learned a lot from this one example :) Thanks again!!</p>",
        "id": 280230096,
        "sender_full_name": "wendy shang",
        "timestamp": 1650988400
    }
]
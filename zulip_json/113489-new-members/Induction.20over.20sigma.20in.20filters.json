[
    {
        "content": "<p>Hello, could anyone please point me in a good direction wrt. a proof using dependent types - I am not quite used to working with them. It seems to me my approach from non--dependent scenario is completely inapplicable within the realm of dependent types.</p>\n<p>The basic version of the theorem is as follows. (I shall just use Lean for brevity.)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span>\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n\n<span class=\"kn\">variables</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">Q</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">filter_partition</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">P</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">Q</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">R</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">filter_nil</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]},</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span>\n          <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">hd</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">*</span><span class=\"o\">,</span>\n        <span class=\"o\">},</span>\n        <span class=\"o\">{</span>\n          <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"n\">not_iff_comm</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">hd</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">*</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I included the proof to show what idea doesn't seem to translate (as far as I can tell) into the following version.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">filter_partition_dependent</span>\n  <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">l</span><span class=\"o\">}),</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">filter</span> <span class=\"n\">Q</span> <span class=\"n\">l</span><span class=\"o\">}),</span> <span class=\"n\">P</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mem_of_mem_filter</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">Q</span> <span class=\"n\">l</span><span class=\"o\">)))</span> <span class=\"bp\">+</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">filter</span> <span class=\"n\">R</span> <span class=\"n\">l</span><span class=\"o\">}),</span> <span class=\"n\">P</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mem_of_mem_filter</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">R</span> <span class=\"n\">l</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">attach</span><span class=\"o\">]},</span>\n    <span class=\"o\">{</span>\n      <span class=\"c1\">-- ih : ∀ {P : {x // x ∈ tl} → Prop}</span>\n    <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>This version is not much different. I promoted the original <code>P : α → Prop</code> to <code>P : {x // x ∈ l} → Prop</code>,<br>\nwhich means I had to use <code>attach</code>ed versions of lists. The filtered lists also need a proof that <code>a ∈ filter p l → a ∈ l</code>.</p>\n<p>The problem is that the original proof by induction on <code>l</code> (with <code>hd :: tl</code> in the inductive case) appears to no longer work, because the inductive hypothesis wants <code>P : {x // x ∈ tl} → Prop</code> and I  only have <code>P : {x // x ∈ hd :: tl} → Prop</code>. <br>\nI tried synthesizing one from <code>P</code> but the conclusion still has the original <code>P</code> that also considers the head.<br>\nI can't think of a way to actually successfully use induction here - do I need some filter congruence lemmas?<br>\nThese seem to only work in \"homogeneous\" settings with filtering predicates of equivalent types.</p>\n<p>Could someone please suggest an alternative way to prove this? Or am I missing something here, have I managed to make the theorem false?<br>\nHere's also a link to the web editor which conveniently contains a minimal compilable example - I am not sure how Zulip handles long URLs so I made a pastebin of the link. <a href=\"https://pastebin.com/raw/grX324K2\" target=\"_blank\" title=\"https://pastebin.com/raw/grX324K2\">https://pastebin.com/raw/grX324K2</a></p>",
        "id": 185049677,
        "sender_full_name": "Aria Miuk",
        "timestamp": 1578427839
    },
    {
        "content": "<p>I am not a computer scientist but I think I'd be tempted to look for a result in the library of the following form: if <code>L : list X</code> and there's a map <code>f: X -&gt; Y</code> and a predicate <code>Q</code> on <code>Y</code> then <code>map f (filter (Q o f) L) = filter Q (map f L)</code>, and then use the fact that list.map doesn't change length, let Q be \"if x is in l then P(x) else false\" and muddle on from there.</p>",
        "id": 185066018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1578439660
    },
    {
        "content": "<p>Thank you Kevin, I will give it a try! I've been very much \"stuck\" in the inductive mindset as conceptually it seems like the most obvious thing to do.  <em>Surely</em> tagging along \"that\" obvious properly shouldn't change the way the proof can be done but the more I struggle with it, the more impossible the inductive proof seems to be. Actually understanding why this happens could come in handy.</p>",
        "id": 185066611,
        "sender_full_name": "Aria Miuk",
        "timestamp": 1578440173
    },
    {
        "content": "<p>You can't prove things about <code>attach</code> by induction. You have to generalize it, in the same way that <code>attach</code> itself is generalized, to <code>pmap</code></p>",
        "id": 185067858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578441339
    },
    {
        "content": "<p>Is this a common \"theme\" within the realm of dependent types? I can't even formulate this question more specifically - it just appears to be clear that this is not specific to <code>attach</code> only.</p>",
        "id": 185068208,
        "sender_full_name": "Aria Miuk",
        "timestamp": 1578441658
    },
    {
        "content": "<p>I think something like this will work:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">filter_partition_dependent&#39;</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">β₁</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i₁</span> <span class=\"o\">:</span> <span class=\"n\">β₁</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p₁</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β₁</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">β₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">β₂</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p₂</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">filter</span> <span class=\"n\">Q</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">p₁</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">filter</span> <span class=\"n\">R</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">p₂</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">pmap</span> <span class=\"n\">f</span> <span class=\"n\">l</span> <span class=\"n\">H</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">i₁</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">pmap</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">Q</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">H₁</span><span class=\"o\">))</span> <span class=\"bp\">+</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">i₂</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">pmap</span> <span class=\"n\">f₂</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">R</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">H₂</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 185068995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578442413
    },
    {
        "content": "<p>there may be more hypotheses needed</p>",
        "id": 185069047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578442455
    },
    {
        "content": "<p>But this is assuming you actually want a direct inductive proof. It is quite likely that Kevin's suggestion of stringing together other lemmas will work here</p>",
        "id": 185069073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578442508
    },
    {
        "content": "<p>Interesting. Thanks everyone kindly for the suggestions, very appreciated.</p>",
        "id": 185069155,
        "sender_full_name": "Aria Miuk",
        "timestamp": 1578442598
    },
    {
        "content": "<p>Note that this is a direct generalization of the target statement, like so:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">filter_partition_dependent</span>\n  <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">filter</span> <span class=\"n\">Q</span> <span class=\"n\">l</span><span class=\"o\">}),</span> <span class=\"n\">P</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mem_of_mem_filter</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">Q</span> <span class=\"n\">l</span><span class=\"o\">)))</span> <span class=\"bp\">+</span>\n  <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">filter</span> <span class=\"n\">R</span> <span class=\"n\">l</span><span class=\"o\">}),</span> <span class=\"n\">P</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mem_of_mem_filter</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">R</span> <span class=\"n\">l</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"n\">filter_partition_dependent&#39;</span> <span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n</pre></div>",
        "id": 185069244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578442700
    },
    {
        "content": "<p>I am not sure how I feel about dependent type right now, there's a lot to process. I read a quote on Coq along the lines of \"Coq has a very powerful type system. But don't use it.\" and perhaps I am starting to see as to why that would be the case.</p>",
        "id": 185069373,
        "sender_full_name": "Aria Miuk",
        "timestamp": 1578442823
    },
    {
        "content": "<p>I can get behind that quote</p>",
        "id": 185070440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1578444013
    }
]
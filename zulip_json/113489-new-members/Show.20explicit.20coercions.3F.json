[
    {
        "content": "<p>Is there a way to make the pretty printer indicate what specific coercion hides under a <code>↑</code>? <code>set_option pp.coercions true</code> does not do that (and <code>false</code> apparently suppresses them completely), and using <code>set_option pp.all true</code> is way too much.<br>\nI'm trying to prove a result on p-adic numbers and can't seem to figure out what the <code>↑</code> in <code>u - ↑(1 : zmod p)</code> means (where <code>u : ℤ_[p]</code>). <code>norm_cast</code> seemingly cannot do anything with this expression, so I'm looking for a library lemma that gives me that  <code>↑(1 : zmod p) = 1</code>, and knowing what the coercion map is called would probably help.</p>",
        "id": 276113337,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647896568
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> If you use VSCode, do you know about the ability to get this information by clicking on the arrow in the infoview?</p>",
        "id": 276113547,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647896666
    },
    {
        "content": "<p>Now I know...</p>",
        "id": 276113650,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647896730
    },
    {
        "content": "<p>It says <code>coe</code>  <code>zmod p</code> <code>ℤ_[p]</code> <code>coe_to_lift</code> <code>(1 : zmod p))</code>. How do I interpret this?</p>",
        "id": 276113772,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647896796
    },
    {
        "content": "<p>Hmm ... what do you get by clicking on the <code>coe_to_lift</code>?</p>",
        "id": 276114148,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647897010
    },
    {
        "content": "<p>(You can keep clicking and clicking to dive deeper)</p>",
        "id": 276114166,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647897021
    },
    {
        "content": "<p><code>coe_to_lift</code> <code>zmod p</code> <code>ℤ_[p]</code> <code>zmod.has_coe_t p</code></p>",
        "id": 276114264,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897081
    },
    {
        "content": "<p>And then from <code>zmod.has_coe_t p</code>:<br>\n<code>zmod.has_coe_t</code> <code>ℤ_[p]</code> <code>padic_int.has_zero</code> <code>padic_int.has_one</code> <code>padic_int.has_add</code> <code>padic_int.has_neg</code> <code>p</code></p>",
        "id": 276114399,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897138
    },
    {
        "content": "<p>Right, so it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.has_coe_t\">docs#zmod.has_coe_t</a></p>",
        "id": 276114445,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647897163
    },
    {
        "content": "<p>which converts an element of <code>zmod p</code> to an element of any ring (or even any <code>R</code> satisfying <code>[has_zero R] [has_one R] [has_add R] [has_neg R]</code>)</p>",
        "id": 276114676,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647897226
    },
    {
        "content": "<p>If I remember correctly, the existence of this coercion is rather controversial, since it's so clearly badly behaved on a non-char-<code>p</code> ring.</p>",
        "id": 276114866,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647897262
    },
    {
        "content": "<p>But somehow I fail to see the statement that <code>1 : zmod p</code> is mapped to <code>1 : ℤ_[p]</code>...</p>",
        "id": 276114880,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897270
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/padic_int.coe_one\">docs#padic_int.coe_one</a> ?</p>",
        "id": 276114935,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647897304
    },
    {
        "content": "<p>or is that the wrong way around?</p>",
        "id": 276114961,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647897318
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.cast_one\">docs#zmod.cast_one</a> ?</p>",
        "id": 276114995,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647897345
    },
    {
        "content": "<p>The first is <code>↑(1 : ℤ_[p]) = (1 : ℚ_[p])</code><br>\nThe second has an assumption <code>m | n</code></p>",
        "id": 276115173,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897436
    },
    {
        "content": "<p>So the challenge is to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 276115290,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897505
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276115370,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897566
    },
    {
        "content": "<p>Replacing <code>1</code> by <code>0</code> (on both sides <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>) is <code>zmod.cast_zero</code> (although both <code>suggest</code> and <code>library_search</code> give me a timeout).</p>",
        "id": 276115702,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897733
    },
    {
        "content": "<p>There is <code>zmod.cast_one'</code>, but it wants a target of characteristic <code>p</code>...</p>",
        "id": 276115874,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647897829
    },
    {
        "content": "<p>Yeah the library lemmas seem a bit inefficient, this works, but we need the cardinality at least two (which lean knows is implied by prime)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">cast_one</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">casesI</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">fact.out</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_inst_1</span><span class=\"o\">)),</span>\n  <span class=\"n\">casesI</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">fact.out</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_inst_1</span><span class=\"o\">)),</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276116891,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1647898326
    },
    {
        "content": "<p>After that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"n\">p.prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>works</p>",
        "id": 276116928,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1647898366
    },
    {
        "content": "<p>Thanks! This looks like a useful addition to the library.</p>",
        "id": 276117430,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647898671
    },
    {
        "content": "<p>What is the intended mathematical content of this lemma?</p>",
        "id": 276117599,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647898781
    },
    {
        "content": "<p>Why would you expect a coercion from <code>zmod p</code> to any ring?</p>",
        "id": 276117680,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647898812
    },
    {
        "content": "<p>Here is now what all of this was about.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">number_theory.padics</span>\n<span class=\"kn\">import</span> <span class=\"n\">number_theory.padics.ring_homs</span> <span class=\"c1\">-- should not be necessary?</span>\n<span class=\"kn\">import</span> <span class=\"n\">number_theory.padics.hensel</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.derivative</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">test</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"c1\">-- From Alex J. Best:</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">cast_one</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">casesI</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">fact.out</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_inst_1</span><span class=\"o\">)),</span>\n  <span class=\"n\">casesI</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">fact.out</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_inst_1</span><span class=\"o\">)),</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">square_of_principal_unit</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"n\">p.prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u.to_zmod</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">],</span> <span class=\"n\">s</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- We want to use Hensel's lemma, so set up a suitable polynomial</span>\n  <span class=\"k\">let</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">X</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- and show the relevant condition.</span>\n  <span class=\"k\">have</span> <span class=\"n\">hnorm</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">eval</span> <span class=\"mi\">1</span> <span class=\"n\">F</span><span class=\"bp\">∥</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∥</span><span class=\"n\">eval</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">derivative</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">∥^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n       <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n       <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">norm_cast</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])),</span> <span class=\"n\">padic_norm_e.eq_padic_norm</span><span class=\"o\">],</span>\n            <span class=\"n\">norm_cast</span><span class=\"o\">,</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">norm_cast</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)),</span> <span class=\"n\">padic_norm.padic_norm_of_prime_of_ne</span> <span class=\"n\">hp</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n       <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h₂</span><span class=\"o\">],</span>\n       <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:=</span> <span class=\"n\">padic_int.to_zmod_spec</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n       <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hu</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₃</span><span class=\"o\">,</span>\n       <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">norm_sub_rev</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₃</span><span class=\"o\">,</span>\n       <span class=\"n\">exact</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hensels_lemma</span> <span class=\"n\">hnorm</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hensel</span> <span class=\"o\">:=</span> <span class=\"n\">h.left</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hensel</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sub_eq_zero</span> <span class=\"n\">at</span> <span class=\"n\">hensel</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hensel</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>",
        "id": 276117702,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647898826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Show.20explicit.20coercions.3F/near/276117680\">said</a>:</p>\n<blockquote>\n<p>Why would you expect a coercion from <code>zmod p</code> to any ring?</p>\n</blockquote>\n<p>Patrick, sadly, we have this coercion and it's used in several places :). <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.has_coe_t\">docs#zmod.has_coe_t</a></p>",
        "id": 276117740,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647898843
    },
    {
        "content": "<p>I'd be interested in seeing how one can do this (i.e., mostly the proof of <code>hnorm</code>) more elegantly.</p>",
        "id": 276117758,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647898857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  The point is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/padic_int.to_zmod_spec\">docs#padic_int.to_zmod_spec</a>, which uses exactly this map.</p>",
        "id": 276117896,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647898927
    },
    {
        "content": "<p>There is even an issue to remove it: <a href=\"https://github.com/leanprover-community/mathlib/pull/3975\">#3975</a></p>",
        "id": 276117951,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647898961
    },
    {
        "content": "<p>This map really sounds like a very bad idea.</p>",
        "id": 276118161,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647899087
    },
    {
        "content": "<p>In the context of p-adic numbers, one wants to have a map that sends a p-adic integer to an approximation in the integers (or naturals), so something like that will be necessary.</p>",
        "id": 276118267,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647899157
    },
    {
        "content": "<p>Probably if we had the teichmuller lift as a map from <code>zmod p</code> to <code>Z_p</code> in mathlib that could replace the coe in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/padic_int.to_zmod_spec\">docs#padic_int.to_zmod_spec</a> and everyone would be happy, but as far as I know we don't have it in this context yet (though it is there for Witt vectors)</p>",
        "id": 276118481,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1647899262
    },
    {
        "content": "<p>I think one definitely wants a map to ℕ or ℤ here. The Teichmüller lift would also be useful, but would not be an adequate replacement.</p>",
        "id": 276118818,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647899467
    },
    {
        "content": "<p>Also, it is not just about ℤ/pℤ, but also ℤ/p^nℤ...</p>",
        "id": 276119132,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647899650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> I agree the map should be there. But I think it shouldn't be a coercion.<br>\nWe have <a href=\"https://github.com/leanprover-community/mathlib/pull/3975\">#3975</a> to remind us that this coercion should be down-graded to an ordinary map. I haven't actually done the work yet.</p>",
        "id": 276148499,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647931086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I think what is missing is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">padic_int.to_zmod_spec</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">z.to_zmod.val</span> <span class=\"bp\">=</span> <span class=\"n\">z.zmod_repr</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">padic_int.to_zmod_pow_spec</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">padic_int.to_zmod_pow</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">z.appr</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Then one can do reasonable computations.</p>",
        "id": 276159807,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940323
    },
    {
        "content": "<p>As a side note, I would suggest to switch the arguments of <code>padic_int.to_zmopd_pow</code> so that one can write <code>z.to_zmod_pow n</code> instead of <code>padic_int.to_zmod_pow n z</code>.</p>",
        "id": 276159880,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940377
    },
    {
        "content": "<p>I think you should still be able to do that. Does it fail?</p>",
        "id": 276159903,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647940409
    },
    {
        "content": "<p>I haven't tried yet. I assume the proofs should be easy, since this should be basically the definition of <code>to_zmod</code>/<code>to_zmod_pow</code>.</p>",
        "id": 276160004,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940462
    },
    {
        "content": "<p><code>X.foobar Y</code> looks at the type of <code>X</code>, say <code>quux</code>, and then looks up the declaration <code>quux.foobar</code>. It then plugs <code>X</code> into the first explicit argument with type <code>quux</code>. But <code>X</code> doesn't need to be the first explicit argument. Just the first one with type <code>quux</code>.</p>",
        "id": 276160014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647940473
    },
    {
        "content": "<p>IIRC, when I tried to write <code>z.to_zmod_pow n</code>, it complained...</p>",
        "id": 276160059,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940512
    },
    {
        "content": "<p>Perhaps because nat has a coercion to p-adic integers?</p>",
        "id": 276160097,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940546
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">])</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">z.to_zmod_pow</span> <span class=\"mi\">3</span>\n</code></pre></div>\n<p>gives <code>invalid field notation, function 'padic_int.to_zmod_pow' does not have explicit argument with type (padic_int ...)\n</code></p>",
        "id": 276160267,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940651
    },
    {
        "content": "<p><code>#check padic_int.to_zmod_pow</code> --&gt; <code>Π (n : ℕ), ℤ_[?M_1] →+* zmod (?M_1 ^ n)</code></p>",
        "id": 276160375,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940716
    },
    {
        "content": "<p>Hmm, that's a surprising error message. Because it clearly does have such an explicit argument.</p>",
        "id": 276160390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647940729
    },
    {
        "content": "<p>There is an implicit ⇑ involved, but I have no idea whether this is relevant.</p>",
        "id": 276160445,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647940781
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Do you understand what's going on?</p>",
        "id": 276160763,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647940965
    },
    {
        "content": "<p>While trying to prove the first of the two <code>theorems</code> I stated above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">padic_int.to_zmod_spec</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]):</span>\n  <span class=\"n\">z.to_zmod.val</span> <span class=\"bp\">=</span> <span class=\"n\">z.zmod_repr</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">padic_int.to_zmod</span><span class=\"o\">,</span> <span class=\"n\">padic_int.to_zmod_hom</span><span class=\"o\">,</span> <span class=\"n\">padic_int.zmod_repr</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- turns the goal into ↑(classical.some _).val = classical.some _</span>\n  <span class=\"c1\">-- what to do with that?</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276160976,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647941074
    },
    {
        "content": "<p>That doesn't look pleasant.</p>",
        "id": 276161130,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647941158
    },
    {
        "content": "<p>Let me take a look</p>",
        "id": 276161192,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647941180
    },
    {
        "content": "<p>Shouldn't there be a constructive way of defining <code>to_zmod</code>? By definition of a Cauchy sequence, there must be an index <code>n</code> such that the corresponding and all following terms have nonnegative valuation and the lowest p-adic bit stays fixed; then take the image of that term.</p>",
        "id": 276161268,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647941230
    },
    {
        "content": "<p>That would require the homomorphism from <code>{x : ℚ // ¬ p ∣ x.denom}</code> (i.e., the localization of  ℤ at the prime ideal generated by <code>p</code>) to <code>zmod p</code>. Is this available?</p>",
        "id": 276161428,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647941338
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">padic_int.to_zmod_spec'</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"o\">:</span>\n  <span class=\"n\">z.to_zmod.val</span> <span class=\"bp\">=</span> <span class=\"n\">z.zmod_repr</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">padic_int.to_zmod</span><span class=\"o\">,</span> <span class=\"n\">padic_int.to_zmod_hom</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zmod.val_cast_of_lt</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">padic_int.zmod_repr_lt_p</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276161785,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647941559
    },
    {
        "content": "<p>Note that I added a <code>'</code> to the name, to avoid a conflict.</p>",
        "id": 276161807,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647941572
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">padic_int.to_zmod_spec'</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]):</span>\n  <span class=\"n\">z.to_zmod.val</span> <span class=\"bp\">=</span> <span class=\"n\">z.zmod_repr</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ring_hom.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">padic_int.to_zmod</span><span class=\"o\">,</span> <span class=\"n\">padic_int.to_zmod_hom</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zmod.val_cast_of_lt</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">padic_int.zmod_repr_lt_p</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>... pretty close :)</p>",
        "id": 276161887,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647941631
    },
    {
        "content": "<p>OK, then also:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">padic_int.to_zmod_pow_spec'</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">padic_int.to_zmod_pow</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">z.appr</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">padic_int.to_zmod_pow</span><span class=\"o\">,</span> <span class=\"n\">padic_int.to_zmod_hom</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zmod.val_cast_of_lt</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">padic_int.appr_lt</span> <span class=\"n\">z</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276162134,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647941788
    },
    {
        "content": "<p>As a general remark, if your goal looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- turns the goal into ↑(classical.some _).val = classical.some _</span>\n</code></pre></div>\n<p>then you have most likely unfolded one definition too many.</p>",
        "id": 276162327,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647941952
    },
    {
        "content": "<p>But if you can redefine it without <code>classical.some</code>, it may be worth doing so</p>",
        "id": 276162347,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647941973
    },
    {
        "content": "<p>In this case the definition of <code>zmod.repr</code></p>",
        "id": 276162349,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647941975
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.repr\">docs#zmod.repr</a> doesn't seem to exist</p>",
        "id": 276162505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647942062
    },
    {
        "content": "<p>Ah, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/padic_int.zmod_repr\">docs#padic_int.zmod_repr</a></p>",
        "id": 276162538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647942095
    },
    {
        "content": "<p>Sorry, my bad</p>",
        "id": 276162677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647942182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/113489-new-members/topic/Show.20explicit.20coercions.3F/near/276161268\">said</a>:</p>\n<blockquote>\n<p>Shouldn't there be a constructive way of defining <code>to_zmod</code>? By definition of a Cauchy sequence, there must be an index <code>n</code> such that the corresponding and all following terms have nonnegative valuation and the lowest p-adic bit stays fixed; then take the image of that term.</p>\n</blockquote>\n<p>I don't think this is enough to compute with, as \"the corresponding and all following terms have nonnegative valuation\" doesn't look like a decidable predicate to me.</p>",
        "id": 276167240,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647944774
    },
    {
        "content": "<p>Right, you would need to work with modulated Cauchy sequences: don't just take a quotient of (sequences such that for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span>, there exists <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, ...) but rather a quotient of (sequences together with a modulus of convergence function sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>)</p>",
        "id": 276173485,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647948259
    },
    {
        "content": "<p>OK, I guess I'll leave this for the time being.</p>",
        "id": 276174520,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647948879
    },
    {
        "content": "<p>If one does not take the route to define ℚ_p as a completion of ℚ and then ℤ_p as a subring of ℚ_p, but instead defines ℤ_p as the projective limit of the finite rings ℤ/p^nℤ and then ℚ_p as its field of fractions (or by inverting p), the maps from ℤ_p to ℤ/pℤ etc. would be constructive and immediate.</p>",
        "id": 276238350,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647975368
    },
    {
        "content": "<p>I was discussing with a post-doc the idea of refactoring Q_p so it's defined the \"Bourbaki way\" as the uniform space completion of Q with respect to the uniform structure coming from the p-adic metric. But I'm not sure it's worth it.</p>",
        "id": 276239350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647975772
    },
    {
        "content": "<p>My point is that I want to <em>use</em> p-adics, in particular to do computations with them. For this, the more concrete the construction is, the better.</p>",
        "id": 276240673,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647976422
    },
    {
        "content": "<p>Does it really make a difference what the construction is? Can't you write tactics to do computations? I don't know anything about these matters but with Lean 4 around the corner (where computations will become feasible) I'm interested to hear what you mean. What kind of computations?</p>",
        "id": 276241126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647976635
    },
    {
        "content": "<p>My fairly immediate concern is to be able to prove statements like \"if z = 1 mod 8 in ℤ_2, then z is a square\" without having to go through contortions. For this, it would be advantageous (or so I think) to have the maps to the finite ring quotients in a fairly explicit way, so that it is easy to use them (instead of having to go via the p-adic norm, for example).</p>",
        "id": 276243059,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647977589
    },
    {
        "content": "<p>I had similar concerns when I started using Lean.  However, my impression now is that the definition is actually irrelevant, as long as it is equivalent to the definition that you want.</p>\n<p>What is certainly important is that one of the lemmas is going to say that elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> are coherent sequences elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi>n</mi></msup><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}/p^n\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathbb\">Z</span></span></span></span>.</p>\n<p>Of course, there should be a proof of Hensel's lemma as well.</p>\n<p>Michael, I think that the contortions that you are worrying about will involve the first few lemmas after the actual definition.  Once those are done, I imagine that what the definition actually was will be irrelevant.</p>",
        "id": 276251270,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647981729
    },
    {
        "content": "<p>My impression, during the Witt vector project, was that the API for <code>ℤ_[p]</code> would be easier to setup if the definition is the algebraic one.</p>",
        "id": 276251896,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647982065
    },
    {
        "content": "<p>But I never tested that claim</p>",
        "id": 276251911,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647982076
    },
    {
        "content": "<p>One hybrid approach would be to take the analytic definition of <code>ℚ_[p]</code> and the algebraic definition of <code>ℤ_[p]</code>. And then show <code>is_fraction_ring</code> to glue the two together.</p>",
        "id": 276252012,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647982119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> A version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hensels_lemma\">docs#hensels_lemma</a> is actually there. However, I've written a variant (the simpler version using that the reduction mod p is zero for the polynomial and nonzero for the derivative) that I hope will be easier to apply.</p>",
        "id": 276252271,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647982240
    },
    {
        "content": "<p>Could there be a coercion from <code>ℤ_[p]</code> to <code>ℚ_[p]</code> with the hybrid approach?  Maybe the answer is trivially yes, I'm not sure...</p>",
        "id": 276252282,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647982251
    },
    {
        "content": "<p>Yes, but maybe not trivially yes (-;</p>",
        "id": 276252482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647982364
    },
    {
        "content": "<p>Where I had to go through contortions was here (not directly related to p-adics):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">two_nonzero_mod_odd_prime</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"n\">p.prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_cast</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)),</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">zmod.int_coe_zmod_eq_zero_iff_dvd</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat.prime_dvd_prime_iff_eq</span> <span class=\"n\">_inst_1.1</span> <span class=\"n\">nat.prime_two</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm wondering how to deal with this in a better way. Any suggestions?</p>",
        "id": 276252528,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647982386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> Note that there is also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/henselian_ring\">docs#henselian_ring</a>. And mathlib knows that <code>ℤ_[p]</code> is an example.</p>",
        "id": 276252530,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647982388
    },
    {
        "content": "<p>Michael, I think that what you are doing is precisely developping the API to make \"some\" definition workable.  This is exactly what needs to be done and what ultimately makes the initial definition irrelevant, since all the ways in which you might want to use it have already been implemented.</p>",
        "id": 276252538,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647982394
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/henselian_local_ring.tfae\">docs#henselian_local_ring.tfae</a> gives some versions of Hensel's lemma. But other versions are missing, because the proof is actually non-trivial that they are equivalent. You need a bunch about etale maps, iirc</p>",
        "id": 276252693,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647982466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Henselian rings feel way more abstract than what I need...</p>",
        "id": 276252806,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647982530
    },
    {
        "content": "<p>Michael I'm not at a computer right now, but I would try to prove that 2 &lt; p, being p prime and not two and then use that to conclude the incongruence.  I'm not sure whether it would be faster or not, though...</p>",
        "id": 276252936,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647982593
    },
    {
        "content": "<p>OK, here is a one-liner: <code>exact_mod_cast zmod.prime_ne_zero p 2 hp</code><br>\nEDIT: ...which is not found by <code>library_search</code> or <code>suggest using hp</code>.</p>",
        "id": 276253310,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647982793
    },
    {
        "content": "<p>It seems to me that we need to figure out how to fill in the following blank:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">number_theory.number_field</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">number_field</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_completion</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">number_field.ring_of_integers</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"n\">P.is_prime</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 276253692,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1647982929
    },
    {
        "content": "<p>I think a student of <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has done something related.</p>",
        "id": 276253817,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647982992
    },
    {
        "content": "<p>The dumb thing you can do is just ask for a K-algebra isomorphism to the completion (which Maria has, as Michael says).</p>",
        "id": 276256762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647984280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/113489-new-members/topic/Show.20explicit.20coercions.3F/near/276253310\">said</a>:</p>\n<blockquote>\n<p>OK, here is a one-liner: <code>exact_mod_cast zmod.prime_ne_zero p 2 hp</code><br>\nEDIT: ...which is not found by <code>library_search</code> or <code>suggest using hp</code>.</p>\n</blockquote>\n<p>Library search and suggest will only ever really find one refine or exact statement that matches the goal. So specialized tactics like exact_mod_cast can definitely do more in the situations they are designed for.</p>",
        "id": 276268494,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1647991755
    }
]
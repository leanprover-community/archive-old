[
    {
        "content": "<p>Hello, I am playing with LEAN and quite new to dependent types so I have some basic questions. A function that takes a value and returns a type makes sense to me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"n\">Nat</span> <span class=\"k\">else</span> <span class=\"n\">Bool</span>\n</code></pre></div>\n<p>but what is a value of type <code>f x</code> and how does one construct one? My simple attempt to construct a typed pair is not accepted by LEAN</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:=</span> <span class=\"n\">Sigma.mk</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Adding explicit type assertion <code>(1 : f 2)</code> doesn't seem to help. Doesn't LEAN evaluate <code>f 2</code> at type-checking time turn it into <code>Nat</code> and pass the checker?</p>",
        "id": 276764756,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1648355875
    },
    {
        "content": "<p>What you're running into with <code>(1 : f 2)</code> is that there's a somewhat complicated system in Lean to turn numerals into values -- it's able to tell that <code>f 2</code> is <code>Nat</code>, but that takes a stronger sort of evaluation than it's willing to do. The error I'm seeing is <code>failed to synthesize instance OfNat (f 2) 1</code>. That means it's trying to take the natural number <code>1</code> and interpret it as a <code>f 2</code>, which it doesn't immediately know how to do. You can help it out though with <code>((1 : Nat) : f 2)</code>.</p>",
        "id": 276768670,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648361080
    },
    {
        "content": "<p>With <code>Sigma</code>, Lean usually needs help to figure out <em>which</em> <code>Sigma</code> you mean (especially here -- how is it supposed to guess to use <code>f</code>?) Even so, you need to give it the <code>(1 : Nat)</code> hint to help it interpret the natural number literal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">Sigma</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">Sigma.mk</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 276768842,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648361317
    },
    {
        "content": "<p>That <code>Sigma f</code> can also be written using the <code>Σ x, f x</code> notation</p>",
        "id": 276768866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648361379
    },
    {
        "content": "<p>This <code>OfNat</code> business doesn't apply to things that aren't literals. For example this passes the type checker:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mk2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 276769128,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648361756
    },
    {
        "content": "<p>Ah, makes sense. Extra confusion around literals. A quick follow up then. How would I tell LEAN that the following function has type <code>(x: Nat) -&gt; f x</code> (where <code>f x</code> is above).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fn</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>This doesn't seem to work.</p>",
        "id": 277569289,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1648959083
    },
    {
        "content": "<p>It won't fix it, but make sure to use <code>:=</code> instead of <code>=</code> for a definition.</p>\n<p>The reason things worked with, for example, <code>(true : f 0)</code> is that Lean is able to compute what <code>f 0</code> is. In an <code>if</code> expression, however, at best you have an additional assumption <code>x &gt; 1</code>, but that's not enough for Lean to compute what <code>f x</code> might be (<code>x</code> is still a variable, it's not a literal number). You can help it out using tactics though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fn</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"k\">then</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>I'm using the \"dependent if\" notation; here <code>h</code> is a proof of either <code>x &gt; 1</code> or its negation.</p>",
        "id": 277571351,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648960436
    },
    {
        "content": "<p>You can also define some constructors</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"n\">Nat</span> <span class=\"k\">else</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f.mk_nat</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- I wasn't sure whether to write this as `¬ x &gt; 1` just to make the `if` more convenient.</span>\n<span class=\"kd\">def</span> <span class=\"n\">f.mk_bool</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.not_lt_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fn</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"n\">f.mk_nat</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"n\">f.mk_bool</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 277572377,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648960969
    },
    {
        "content": "<p>I didn't know about the 'dependent if' notation, this makes a lot of sense. Thanks!</p>",
        "id": 277776213,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1649097623
    }
]
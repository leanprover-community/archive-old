[
    {
        "content": "<p>Well, I really need partial functions. I really, really need partial functions. There is a specific class of competitive programming problems called 'interactive problems' which requires contestants to interact with a secret library, and functions from that library often have some preconditions. If the contestant violates a precondition then their submission is judged as Wrong Answer—a generic verdict given by the automatic judge system when the submitted code doesn't work as expected.</p>\n<p>So with that out of the way, I am experimenting with the \"useless\" hypothesis parameter. May I ask a few questions:</p>\n<ul>\n<li>Why are some hypotheses replaced with <code>_</code> in the infoview?</li>\n<li>Why does the rw tactic dislike the extra hypothesis parameter so much? It even says \"rewrite tactic failed, motive is not type correct\" when I directly prove the retrieve_replace lemma without the helper lemma.</li>\n</ul>",
        "id": 228129232,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1614517086
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.linarith</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">retrieve</span> <span class=\"o\">{</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">array</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">index</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"n\">array.length</span><span class=\"o\">,</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"c1\">-- I can't provide a sane value. I'm relying on the principle of explosion to produce an instance of the desired type.</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_eq_zero.mpr</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">head</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">rest.length</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">list.length_cons</span> <span class=\"n\">head</span> <span class=\"n\">rest</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">rest.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">retrieve</span> <span class=\"n\">rest</span> <span class=\"n\">n</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">replace</span> <span class=\"o\">{</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">array</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">index</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"n\">array.length</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">target</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"c1\">-- I can't provide a sane value. I'm relying on the principle of explosion to produce an instance of the desired type.</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_eq_zero.mpr</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"n\">target</span><span class=\"o\">::</span><span class=\"n\">rest</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">rest.length</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">list.length_cons</span> <span class=\"n\">head</span> <span class=\"n\">rest</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">rest.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">replace</span> <span class=\"n\">rest</span> <span class=\"n\">n</span> <span class=\"n\">this</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">length_equal</span> <span class=\"o\">{</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">array</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">index</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"n\">array.length</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">array.length</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">array</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">value</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_eq_zero.mpr</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">replace</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_cons</span> <span class=\"n\">head</span> <span class=\"n\">rest</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_cons</span> <span class=\"n\">target</span> <span class=\"n\">rest</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">replace</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_cons</span> <span class=\"n\">head</span> <span class=\"n\">rest</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_cons</span> <span class=\"n\">head</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">length_equal</span> <span class=\"n\">rest</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">target</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">transform_hypothesis</span> <span class=\"o\">{</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">array</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">index</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"n\">array.length</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">array</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">value</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">array</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">index</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">value</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">length_equal</span> <span class=\"n\">array</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">value</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- This auxiliary lemma is there because the rw tactic doesn't like the transformed hypothesis for some reason.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">retrieve_replace_aux</span> <span class=\"o\">{</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">array</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">index</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"n\">array.length</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">array</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">value</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span> <span class=\"n\">retrieve</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">array</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">index</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">value</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.length_eq_zero.mpr</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">replace</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">retrieve</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">replace</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">retrieve</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">retrieve_replace_aux</span> <span class=\"n\">rest</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">target</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">retrieve_replace</span> <span class=\"o\">{</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">array</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">index</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">index</span> <span class=\"bp\">&lt;</span> <span class=\"n\">array.length</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">retrieve</span> <span class=\"o\">(</span><span class=\"n\">replace</span> <span class=\"n\">array</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">index</span> <span class=\"o\">(</span><span class=\"n\">transform_hypothesis</span> <span class=\"n\">array</span> <span class=\"n\">index</span> <span class=\"n\">h</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">array</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">index</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">value</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">retrieve_replace_aux</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 228129238,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1614517090
    },
    {
        "content": "<p>Isn't your retrieve just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nth_le\">docs#list.nth_le</a>?</p>",
        "id": 228130269,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614518347
    },
    {
        "content": "<p>Oh. And my <code>replace</code> is just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.update_nth\">docs#list.update_nth</a> with the extra hypothesis paramater. Interesting.</p>",
        "id": 228130621,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1614518766
    },
    {
        "content": "<p>You <em>can</em> have partial functions -- the issue is that they are a bit messier to prove things about. If you're just doing competitive programming stuff, especially if you're just running functions and don't mind supplying the proofs that you're within the right bounds, then that's fine. I think I already told you my experience with partial functions when doing mathematical proofs -- when I was proving sqrt(2)+sqrt(3)&lt;sqrt(10) by squaring things out, it was painful. But if you're not in this use case, or if you're in a use case where those proofs really do feel necessary for you, then go ahead and use partial functions -- they work fine :-)</p>",
        "id": 228131479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614519815
    },
    {
        "content": "<p>Why are proofs of hypotheses represented as <code>_</code> in the infoview? Is it because proofs are irrelevant?</p>",
        "id": 228140708,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1614529961
    },
    {
        "content": "<p>Yes</p>",
        "id": 228141825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614531241
    },
    {
        "content": "<p>You can tell Lean to show proofs with the option <code>set_option pp.proofs true</code>.</p>",
        "id": 228143747,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1614533092
    }
]
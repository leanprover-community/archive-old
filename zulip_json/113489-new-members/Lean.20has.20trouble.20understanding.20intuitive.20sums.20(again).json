[
    {
        "content": "<p>I'm once again stuck on a terrible sum that should be obvious, but turns out to be frustratingly hard for Lean to understand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.rename</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.comm_ring</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_polynomial</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">τ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">esymm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∑</span> <span class=\"n\">t</span> <span class=\"k\">in</span> <span class=\"n\">powerset_len</span> <span class=\"n\">n</span> <span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">i</span>\n\n<span class=\"sd\">/-- A second definition of `esymm σ R n` with range over a subtype instead of `powerset_len`.</span>\n<span class=\"sd\">  Sometimes it's easier to reason with subtypes. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">esymm₂</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">esymm</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">σ</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">σ</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">mv_polynomial</span>\n</code></pre></div>\n<p>I'm trying to convert the sum over <code>powerset_len n univ</code> to a sum over <code>{s : finset σ // s.card = n}</code>. Both literally count the subsets of <code>σ</code> that have cardinality <code>n</code>. But the first is a finset of <code>finset σ</code> and the second is a subtype <code>σ</code>. I've tried using <code>congr</code>, <code>attach</code>, etc, but it's just a mess. Is there a good way to do this?</p>",
        "id": 223014643,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1610842201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  Do you think it's a good idea to use <code>powerset_len</code>? I've been using it because I'm stubborn and my original Vieta code uses it, but now I'm thinking it might not be worth it. Is there any preference for reasoning with subtypes in mathlib?</p>",
        "id": 223014905,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1610842602
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bij\">docs#finset.sum_bij</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bij'\">docs#finset.sum_bij'</a> would help?</p>",
        "id": 223014926,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610842676
    },
    {
        "content": "<p>Somehow I've missed these. D: Thanks!</p>",
        "id": 223015094,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1610842968
    },
    {
        "content": "<p>I'vee made some progress, but I've gotten stuck again ):<br>\nI need help reasoning with the big <code>i</code> function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.rename</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.comm_ring</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_polynomial</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">τ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">esymm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∑</span> <span class=\"n\">t</span> <span class=\"k\">in</span> <span class=\"n\">powerset_len</span> <span class=\"n\">n</span> <span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">i</span>\n\n<span class=\"sd\">/-- A second definition of `esymm σ R n` with range over a subtype instead of `powerset_len`.</span>\n<span class=\"sd\">  Sometimes it's easier to reason with subtypes. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">esymm₂</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">esymm</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">σ</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">σ</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">esymm</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">σ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">powerset_len</span> <span class=\"n\">n</span> <span class=\"n\">univ</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">σ</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mem_powerset_len.mp</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">sum_bij</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">prod_congr</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span>\n\n    <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">mv_polynomial</span>\n</code></pre></div>\n<p>Maybe it's because I've been staring at it for too long, but how can I unwrap <code>a_1 ∈ ↑(i a ha)</code> at the first <code>sorry</code>? I want to change the membership statement into a logical one.</p>",
        "id": 223018219,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1610848367
    },
    {
        "content": "<p>I'm not quite sure whats you are proving here but  <code>i</code> is some function which constructs data right, so possibly the problem is that you want to remember the definition of <code>i</code> by using <code>let i</code> rather than <code>have i</code>? When you do that the first sorry is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"c1\">--actually you don't even need this line</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 223018394,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1610848782
    },
    {
        "content": "<p>A small example of the difference is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and you are left with an unprovable goal. But if you use let instead of have you get  a proof.</p>",
        "id": 223018511,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1610848948
    },
    {
        "content": "<p><span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span>  Oh... I didn't even know there was a difference.</p>",
        "id": 223018534,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1610848997
    },
    {
        "content": "<p>Have forgets the term used whereas let doesn't, so for propositions have is more natural, in lean all proofs of the same proposition are equal so it doesn't matter what the original one was. But for things which are \"data\" like natural numbers, finsets, functions, you want to remember what their definition was mostly, so <code>let</code> is what you need.</p>",
        "id": 223018612,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1610849158
    },
    {
        "content": "<p>Thanks! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 223019919,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1610851454
    }
]
[
    {
        "content": "<p>I don't have a good feeling for how to manipulate subtypes. How do I do this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">I</span> <span class=\"err\">⊆</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"c1\">-- wrong type: finset (finset α)</span>\n</pre></div>\n\n\n<p>I messed around with <code>map</code> and <code>subtype.mk</code> to no avail.</p>",
        "id": 134577961,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537857619
    },
    {
        "content": "<p>I would suggest using <code>filter_map</code>, but I guess there is no <code>filter_map</code> on multiset</p>",
        "id": 134578112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537857946
    },
    {
        "content": "<p>I get the sense you are asking the wrong question. Why do you need this?</p>",
        "id": 134578175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537858044
    },
    {
        "content": "<p>I'm trying to redefine a restriction function on matroids; <a href=\"https://github.com/bryangingechen/lean-matroids/blob/master/src/matroid.lean#L787\" target=\"_blank\" title=\"https://github.com/bryangingechen/lean-matroids/blob/master/src/matroid.lean#L787\">my original implementation</a> used a bunch of subset hypotheses and I got the impression from what you said earlier that working with fintypes might be easier. So far everything else has indeed gotten simpler.</p>",
        "id": 134578319,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537858227
    },
    {
        "content": "<p>I think instead of a subset relation, you want an injective function in that definition (or possibly its partial inverse function)</p>",
        "id": 134578412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537858407
    },
    {
        "content": "<p>also, this definition doesn't typecheck, not even loosely:</p>\n<div class=\"codehilite\"><pre><span></span>def foo (m X : finset α) : finset (finset {x : α // x ∈ X}) :=\nm.filter (λ I, I ⊆ X) -- wrong type: finset (finset α)\n</pre></div>\n\n\n<p><code>m</code> here is a <code>finset α</code> so if you filter over it you get elements of <code>α</code>, which can't be subsets of <code>X</code></p>",
        "id": 134578502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537858521
    },
    {
        "content": "<p>Oh damn, I meant to have <code>m: finset (finset α)</code>. Sorry about that.</p>",
        "id": 134578566,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537858617
    },
    {
        "content": "<p>This works, but it won't be so easy to work with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">filter_map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">filter_map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span>\n\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">filter_map</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"bp\">_</span> <span class=\"k\">then</span> <span class=\"n\">some</span>\n  <span class=\"bp\">⟨</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h&#39;</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n   <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">nodup_pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_mk</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n</pre></div>",
        "id": 134578668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537858792
    },
    {
        "content": "<p>I'm not sure what you had in mind for using an injective function instead but the theorems and definitions are naturally phrased in terms of subsets. The whole theory is basically about relations between collections of subsets of some \"ground set\".</p>\n<p>Thanks for the code! I'll see how far I can get with this.</p>",
        "id": 134578983,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537859200
    },
    {
        "content": "<p>I guess the point of using <code>fintype</code> is to get away from the \"ground set\"</p>",
        "id": 134578997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859227
    },
    {
        "content": "<p>because type theory supplies you with a \"ground set\" already, that is, the whole type</p>",
        "id": 134579008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859246
    },
    {
        "content": "<p>Right. It looks like it could be awkward whenever we want to change the ground set though.</p>",
        "id": 134579063,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537859292
    },
    {
        "content": "<p>That's what the injective function is for</p>",
        "id": 134579068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859305
    },
    {
        "content": "<p>In type theory you want to think about subsets as monos in the category theory sense</p>",
        "id": 134579080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537859338
    },
    {
        "content": "<p>I tried working more with finsets of subtypes and found myself needing a whole bunch of stuff like the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">finset_embed</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"err\">$</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">embedding</span><span class=\"bp\">.</span><span class=\"n\">subtype</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">finset_embed_inj</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}),</span> <span class=\"n\">finset_embed</span> <span class=\"n\">S</span><span class=\"o\">):=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"err\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset_embed</span><span class=\"o\">,</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">embedding</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"n\">ha</span> <span class=\"n\">H</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ha_</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"n\">ha</span> <span class=\"n\">H</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ha_</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">))</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">finset_embed_coe</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">finset_embed</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">finset_finset_embed_coe</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}))</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})),</span> <span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"err\">$</span> <span class=\"bp\">⟨</span><span class=\"n\">finset_embed</span><span class=\"o\">,</span> <span class=\"n\">finset_embed_inj</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">finset_embed_mem</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}}</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">finset_embed_subset</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}}</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"err\">⊆</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"err\">⊆</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">finset_embed_univ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"err\">⊆</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">finset_embed_card</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- def by Mario Carneiro -/</span>\n<span class=\"n\">def</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">filter_map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">filter_map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- def by Mario Carneiro -/</span>\n<span class=\"n\">def</span> <span class=\"n\">restriction</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">filter_map</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">_</span> <span class=\"k\">then</span> <span class=\"n\">some</span>\n  <span class=\"bp\">⟨</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h&#39;</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">nodup_pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_mk</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mem_restriction</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}}</span> <span class=\"o\">:</span>\n<span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">restriction</span> <span class=\"n\">m</span> <span class=\"n\">X</span> <span class=\"bp\">↔</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"err\">⊆</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">aux</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">e</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">e</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>I feel like I might be going about this all wrong. Recall that what I'm ultimately trying to do is reprove <a href=\"https://github.com/bryangingechen/lean-matroids/blob/master/src/matroid.lean#L782\" target=\"_blank\" title=\"https://github.com/bryangingechen/lean-matroids/blob/master/src/matroid.lean#L782\">this stuff</a> using fintypes rather than carrying around a bunch of (<code>hX : X ⊆ E</code>) everywhere.</p>\n<p>Is there a file in mathlib that takes this approach via monomorphisms to subobjects that I could study, or could someone give me a motivational explanation? In e.g. subgroup.lean it looks like there's a new class <code>is_subgroup</code> but I don't see how that fits.</p>",
        "id": 134704613,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1537997487
    },
    {
        "content": "<p>Update: I was able to prove almost all of the above. Just stuck on <code>mem_restriction</code>, which I realized should just be:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">mem_restriction</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}}</span> <span class=\"o\">:</span>\n<span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">restriction</span> <span class=\"n\">m</span> <span class=\"n\">X</span> <span class=\"bp\">↔</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>",
        "id": 134720517,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538021309
    },
    {
        "content": "<p>I still think you should not be dealing with subtypes so much. I assume your definition looks like this now?</p>\n<div class=\"codehilite\"><pre><span></span>structure indep (α : Type*) [decidable_eq α] :=\n(indep : finset (finset α))\n-- (I1)\n(empty_mem_indep : ∅ ∈ indep)\n-- (I2)\n(indep_of_subset_indep {x y} (hx : x ∈ indep) (hyx : y ⊆ x) : y ∈ indep)\n-- (I3)\n(indep_exch {x y} (hx : x ∈ indep) (hy : y ∈ indep) (hcard : card x &lt; card y)\n    : ∃ e ∈ y \\ x, insert e x ∈ indep)\n</pre></div>",
        "id": 134720961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538022037
    },
    {
        "content": "<p>Also, I notice that this notion of restriction just throws away sets that are not in the subset, rather than taking an intersection like in topology. Is this the same?</p>",
        "id": 134721194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538022479
    },
    {
        "content": "<p>Ah, yes it is because of the subset axiom. If <code>A ∈ I</code> is an independent set and <code>E</code> is the subset, then <code>A ∩ E ∈ I</code> as well by the subset axiom, so the set of independent sets that are subsets of <code>E</code> is also the set of intersections of <code>E</code> with independent sets in <code>I</code></p>",
        "id": 134721323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538022705
    },
    {
        "content": "<p>That's right. What do you suggest instead of subtypes?</p>",
        "id": 134721703,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538023447
    },
    {
        "content": "<p>filter_map, like before. Here's what I've got so far:</p>\n<div class=\"codehilite\"><pre><span></span>@[simp] theorem finset.mem_filter_map {α β} [decidable_eq β] {f : α → option β} {s : finset α}\n  {b : β} : b ∈ s.filter_map f ↔ ∃ a ∈ s, b ∈ f a :=\nby simp [finset.filter_map]; refl\n\ndef {u v} indep.filter_map {α : Type u} {β : Type v} [decidable_eq α] [decidable_eq β] (f : α → option β)\n  (m : indep α) : indep β :=\n{ indep := m.indep.image (finset.filter_map f),\n  empty_mem_indep := finset.mem_image.2 ⟨∅, m.empty_mem_indep, rfl⟩,\n  indep_of_subset_indep := λ x y, begin\n    rw [mem_image, mem_image],\n    rintro ⟨x, hx, rfl⟩ xy,\n    refine ⟨x.filter (λ a, ∃ b ∈ f a, b ∈ y),\n      m.indep_of_subset_indep hx (filter_subset _), _⟩,\n    ext b, simp; split,\n    { rintro ⟨a, ⟨ha, b&#39;, hb&#39;, hy⟩, hb⟩,\n      rcases option.some_inj.1 (hb.symm.trans hb&#39;),\n      exact hy },\n    { intro hb,\n      rcases finset.mem_filter_map.1 (xy hb) with ⟨a, ha, ab⟩,\n      exact ⟨a, ⟨ha, b, ab, hb⟩, ab⟩ }\n  end,\n  indep_exch := λ x y, begin\n\n  end }\n</pre></div>",
        "id": 134721936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538023877
    },
    {
        "content": "<p>How important is it that this theory be constructive? Are you trying to construct an algorithm, or are you trying to avoid LEM, or does it not matter?</p>",
        "id": 134722144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538024162
    },
    {
        "content": "<p>Here's my version of that, using the lemmas I listed above:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">restriction</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">indep</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">indep</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">indep_of_restriction</span> <span class=\"n\">m</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n<span class=\"n\">mem_restriction</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">empty_mem_indep</span><span class=\"o\">,</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hyx</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hx&#39;</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">indep</span> <span class=\"o\">:=</span> <span class=\"n\">mem_restriction</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hyx&#39;</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"n\">y</span> <span class=\"err\">⊆</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">finset_embed_subset</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hyx</span><span class=\"o\">,</span>\n  <span class=\"n\">mem_restriction</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">indep_of_subset_indep</span> <span class=\"n\">hx&#39;</span> <span class=\"n\">hyx&#39;</span><span class=\"o\">),</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"n\">hcard</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">mem_restriction</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hy&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">mem_restriction</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hcard&#39;</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">card</span> <span class=\"err\">↑</span><span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"k\">calc</span>\n    <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">finset_embed_card</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">&lt;</span> <span class=\"n\">card</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">hcard</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"err\">↑</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">finset_embed_card</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">indep_exch</span> <span class=\"n\">hx&#39;</span> <span class=\"n\">hy&#39;</span> <span class=\"n\">hcard&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">He</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">mem_of_subset</span> <span class=\"o\">(</span><span class=\"n\">finset_embed_subset_univ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">e</span> <span class=\"n\">He</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">heyx</span> <span class=\"o\">:</span> <span class=\"n\">e&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">y</span> <span class=\"err\">\\</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mem_sdiff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"bp\">⟨</span><span class=\"n\">finset_embed_mem</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">finset_embed_mem</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">heinsert</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">e&#39;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">indep</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">e&#39;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">insert</span> <span class=\"n\">e</span> <span class=\"err\">↑</span><span class=\"n\">x</span> <span class=\"o\">:=</span>\n        <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">finset_embed_coe_def</span><span class=\"o\">,</span> <span class=\"n\">finset_embed</span><span class=\"o\">,</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">embedding</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">e&#39;</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">indep_of_restriction</span> <span class=\"n\">m</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n      <span class=\"n\">mem_restriction</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">heinsert</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"n\">e&#39;</span> <span class=\"bp\">⟨</span><span class=\"n\">heyx</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span>\n  <span class=\"o\">})}</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>I'd like to preserve computability if possible. I think it's really neat that I'm able to compute different descriptions of matroids with #eval right now. Constructive everything might be beyond my capabilities. I'm already using <code>finset.ssubset_iff</code> which uses <code>classical</code>.</p>",
        "id": 134722343,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538024522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> I managed to finish the proof of this theorem. <a href=\"https://gist.github.com/digama0/edc2a9fe4d468c3921c87650eea5b77a\" target=\"_blank\" title=\"https://gist.github.com/digama0/edc2a9fe4d468c3921c87650eea5b77a\">https://gist.github.com/digama0/edc2a9fe4d468c3921c87650eea5b77a</a></p>\n<p>It is a lot more complicated than your proof, but it also deals with the case when the filter map is not injective. You can also get subtypes and map out of the filter map construction.</p>",
        "id": 134729214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538035464
    },
    {
        "content": "<p>(the stuff about <code>finset.filter_map</code> should go into mathlib)</p>",
        "id": 134729325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538035626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Wow, thanks for all the effort! So, the first thing that matroid restrictions will be used for is to define a notion of rank on subsets (as the cardinality of a maximal independent subset of the subset). Would the best way to apply the filter_map construction be to imitate what you did with <code>foo</code> and subtypes a few days ago in this thread?</p>\n<p>Regarding mathlib, should I try to put together a PR, or would it be faster for you just to directly commit the <code>finset.filter_map</code> stuff yourself?</p>",
        "id": 134747360,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538057869
    },
    {
        "content": "<p>Let me get this straight: given an <code>indep</code> structure <code>m</code>, the rank of a subset <code>S</code> is the largest cardinality of subsets of <code>S</code> in <code>m</code>?</p>",
        "id": 134750167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538060139
    },
    {
        "content": "<p>or is it the largest cardinality of an <code>indep</code> that is a restriction of <code>m</code> to <code>S</code>?</p>",
        "id": 134752685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538062260
    },
    {
        "content": "<p>Given <code>m : indep α</code>, a set <code>B : finset α</code>is a _basis_ for <code>m</code> if it is contained in <code>m.indep</code> and is maximal with regard to inclusion. The definition of the rank of a subset (of the ground set) that I'm trying to formalize is the following. The rank of <code>S : finset α</code>(with respect to <code>m</code>) is defined to be the cardinality of any basis of the restriction of <code>m</code> to <code>S</code> (which should be of type <code>indep {x // x ∈ S}</code>); I've formalized bases in an earlier section and proven e.g. that the cardinality of any two bases is equal.</p>",
        "id": 134753717,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538063076
    },
    {
        "content": "<p>My suggestion:</p>\n<div class=\"codehilite\"><pre><span></span>def indep.supported {α} [decidable_eq α] (m : indep α) (s : finset α) : Prop :=\n∀ t ∈ m.indep, t ⊆ s\n\ndef indep.restriction {α} [decidable_eq α] (m : indep α) (s : finset α) : indep α :=\nm.filter_map (option.guard (∈ s))\n\ntheorem indep.restriction_supported {α} [decidable_eq α]\n  (m : indep α) (s : finset α) : (m.restriction s).supported s := sorry\n\ndef indep.rank {α} [decidable_eq α] (m : indep α) : ℕ := m.indep.sup card\n\ndef rank_of {α} [decidable_eq α] (m : indep α) (s : finset α) : ℕ :=\n(m.restriction s).rank\n</pre></div>",
        "id": 134754363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538063613
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def indep.basis {α} [decidable_eq α] (m : indep α) : finset (finset α) :=\nm.indep.filter (λ s, ∀ t ∈ m.indep, ¬ s ⊂ t)\n</pre></div>",
        "id": 134754503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538063751
    },
    {
        "content": "<p>although maybe this last one should be a predicate instead of a finset</p>",
        "id": 134754571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538063790
    },
    {
        "content": "<p>That's an interesting way to avoid using subtypes. I'm not convinced that we shouldn't change the underlying type of the restriction though. For instance, one prototypical way of getting a matroid is to take a matrix over a field and let the ground set consist of the set of rows and the independent sets be the linearly independent sets of rows. The restriction of such a matroid to a certain subset of its elements should be equal (or maybe \"equivalent\" is a safer word) to the matroid constructed from the matrix consisting of the corresponding subset of rows; similar remarks hold for most other constructions of matroids that are coming to mind. I think following your approach I would end up with extra elements in the underlying fintype / ground set of the restriction which would violate this principle.</p>\n<p>I think <a href=\"https://github.com/bryangingechen/lean-matroids/blob/fintype/src/matroid.lean#L572\" target=\"_blank\" title=\"https://github.com/bryangingechen/lean-matroids/blob/fintype/src/matroid.lean#L572\">the function <code>bases_bases_of_indep</code></a> is the equivalent of <code>indep.basis</code>. (The name was supposed to suggest getting <code>bases.bases</code> from <code>indep</code>).  Though I see it's more efficient to filter on <code>m.indep</code> than on <code>powerset univ</code>.</p>",
        "id": 134757675,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538066427
    },
    {
        "content": "<p>I'm not saying you should never use subtypes, but they shouldn't be your bread and butter because it entails additional complications that can be avoided by just using the flexibility that you already have inside the type.</p>\n<p>As for <code>bases</code>, I see that you have a separate axiomatization of bases rather than just using the collection of independent sets that also satisfy <code>is_basis</code>. Another advantage of not using <code>powerset univ</code> is that I have yet to invoke the assumption that <code>A</code> is finite; all of the above results have only needed <code>decidable_eq A</code>. I imagine you can add that assumption when you need it, but so far it hasn't come up.</p>",
        "id": 134774700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538083501
    },
    {
        "content": "<p>OK, point well-taken. I haven't had a chance to work more on this yet, but doubtless I'll have more questions when I try to push on with my way of doing things. Thanks once again for being so helpful!</p>\n<blockquote>\n<p>I see that you have a separate axiomatization of bases</p>\n</blockquote>\n<p>Yes, part of the fun of matroids is the existence of so many distinct but equivalent axiomatizations, a phenomenon often referred to as <a href=\"https://en.wikipedia.org/wiki/Cryptomorphism\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Cryptomorphism\">cryptomorphism</a>. I've been idly wondering whether something based on the \"TFAE\" PR might be able to treat this sort of thing, but in practice it's probably not hard just to compose the relevant maps by hand.</p>",
        "id": 134775211,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538084157
    }
]
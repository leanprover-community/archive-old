[
    {
        "content": "<p>Hello all! I learned Lean from the Natural Number Game, and decided to try to define Catalan objects in Lean, and prove they satisfy the usual Catalan self similarity.  I think I am almost done with the proof; here is the current goal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"n\">binary_tree</span><span class=\"o\">,</span>\n<span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">order</span> <span class=\"n\">t1</span> <span class=\"bp\">=</span> <span class=\"o\">⟨(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">⟩</span><span class=\"bp\">.</span><span class=\"n\">val.fst</span><span class=\"o\">,</span>\n<span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">order</span> <span class=\"n\">t2</span> <span class=\"bp\">=</span> <span class=\"o\">⟨(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">⟩</span><span class=\"bp\">.</span><span class=\"n\">val.snd</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(⟨</span><span class=\"n\">t1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">t2</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩)</span> <span class=\"bp\">==</span> <span class=\"o\">(⟨</span><span class=\"n\">t1</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">t2</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩)</span>\n</code></pre></div>\n<p>I've never encountered proving something with a double equals sign. First of all, what does this mean? Second, how does one prove it? If it is not possible to prove, what kind of hypothesis would I need to add to prove it?</p>\n<p>I am pretty sure that both sides of the <code>==</code> are ordered pairs, and the coordinates of each order pair are instances of subtype, meaning the first coordinate is the val, and the second coordinate is a <code>Prop</code> which proves that the val satisfies the subtype condition. On the left, the props are represented as underscores, and on the right they are explicitly written as <code>h1</code> and <code>h2</code>.  It would be easy for me to prove this goal if <code>==</code> was replaced with <code>=</code>, because there is a theorem in mathlib that two instances of a subtype are equal as long as their values are equal. I feel like I need to prove some sort of extensionality principle for the <code>binary_tree</code> type I defined, but I am not sure.</p>\n<p>I hope this is enough context to answer my question. For more background, I defined <code>binary_tree</code> to be the inductive class with two constructors, <code>pt</code> with arity 0 and <code>join</code> with arity 2. Then, I inductively defined the <code>order</code> of a binary tree to be <code>0</code> in the case of <code>pt</code>, and one plus the sum of the orders of the two subtrees in the case of join. Finally, <code>catalan n</code> is defined to be the subtype of binary trees whose order is <code>n</code>, <code>catalan (n : \\N) : Type  := {t : binary_tree // order t = n}</code>. The theorem I am trying to prove is that the type <code>catalan n</code> is equivalent to the type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">sum</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">unit</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>  <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">pair.fst</span> <span class=\"bp\">+</span> <span class=\"n\">pair.snd</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.fst</span> <span class=\"bp\">×</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.snd</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Basically, <code>catalan 0</code> is the unit type, while <code>n &gt; 0</code> implies <code>catalan n</code> is the disjoint union over pairs <code>(h, k)</code> for which <code>h + k + 1 = n</code> of <code>cat k \\times cat h</code>. I have already defined the functions to and prove these types, and am now trying to prove they are inverses to each other.</p>",
        "id": 290296648,
        "sender_full_name": "Michael Earnest",
        "timestamp": 1658350187
    },
    {
        "content": "<p>The term you're looking for is \"heterogeneous equality\", and that's about how much I know about it :)</p>",
        "id": 290297050,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1658350350
    },
    {
        "content": "<p><code>==</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/heq\">docs#heq</a>, which is a fairly weak notion, where <code>a == b</code> means the types of <code>a</code> and <code>b</code> are equal, and if you carry <code>a</code> across that equality you get something equal to <code>b</code>. Usually what you need to do is to substitute some relevant things until the types aren't just equal, but definitionally equal, or better, figure out how you got into this mess <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>A <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would help</p>",
        "id": 290297207,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658350426
    },
    {
        "content": "<p>(<code>heq</code> is one of the levels of dependent type hell. It's not so bad, but it does take some getting used to.)</p>",
        "id": 290297558,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658350567
    },
    {
        "content": "<p>Yeah generally the rule when faced with <code>==</code> is \"go back to the tactic which caused it and try another one\"</p>",
        "id": 290297774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658350667
    },
    {
        "content": "<p>But it's really hard to help without a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 290297805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658350678
    },
    {
        "content": "<p>Haha, the docs for <code>heq</code> say that if you encounter trying to prove something wtih <code>==</code>, then to ask yourself, or on zulip, if something went wrong, so I guess I did the right thing. Thank you all, I'll close this issue since it seems I need to back up and try a different route.</p>",
        "id": 290298806,
        "sender_full_name": "Michael Earnest",
        "timestamp": 1658351096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515599\">Michael Earnest</span> has marked this topic as resolved.</p>",
        "id": 290298825,
        "sender_full_name": "Notification Bot",
        "timestamp": 1658351105
    },
    {
        "content": "<p>Feel free to still give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, since we could still try to plow forward, since it looks like the goal might still be doable. (You should still also back up and try a different route.)</p>",
        "id": 290299014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658351212
    },
    {
        "content": "<p>My mental model for <code>a == b</code> is \"<code>a</code> and <code>b</code> are equal, but the equality doesn't typecheck\".</p>",
        "id": 290299686,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658351578
    },
    {
        "content": "<p>The general way you prove a <code>==</code> goal is by rewriting carefully so that the statement still typechecks, until you get an equality of two things with definitionally equal types, at which point you can use <code>heq_of_eq</code> and get a normal equality.</p>",
        "id": 290300591,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658352025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515599\">Michael Earnest</span> has marked this topic as unresolved.</p>",
        "id": 290300618,
        "sender_full_name": "Notification Bot",
        "timestamp": 1658352044
    },
    {
        "content": "<p>Well, here's a link to a <a href=\"https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.linarith%0A%0Ainductive%20binary_tree%0A%7C%20%20%20%20pt%20%3A%20binary_tree%0A%7C%20%20join%20%3A%20binary_tree%20%E2%86%92%20binary_tree%20%E2%86%92%20binary_tree%0A%0Adef%20order%20%28t%20%3A%20binary_tree%29%20%3A%20%E2%84%95%20%3A%3D%20binary_tree.rec_on%20t%200%20%28%CE%BB%20left%20right%20x%20y%2C%20x%20%2B%20y%20%2B%201%29%0A%0Alemma%20order_sum%20%28L%20R%20%3A%20binary_tree%29%20%3A%20order%20%28binary_tree.join%20L%20R%29%20%3D%20order%20L%20%2B%20order%20R%20%2B%201%20%3A%3D%20begin%20refl%2C%20end%0A%0Adef%20catalan%20%28n%20%3A%20%E2%84%95%29%20%3A%20Type%20%3A%3D%20%7Bt%20%3A%20binary_tree%20%2F%2F%20order%20t%20%3D%20n%7D%0A%0Adef%20cat_split%20%7Bn%20%3A%20%E2%84%95%7D%20%28t%20%3A%20catalan%20n%29%20%3A%20--%20A%20catalan%20n%20object%0Asum%20--is%20either%20a%20unit%2C%20in%20the%20case%20n%20%3D%200%2C%20or%20a%20pair%20%28h%2Ck%29%20with%20h%2Bk%2B1%3Dn%2C%20and%20an%20ordered%20pair%20%28cat%20h%2C%20cat%20k%29%0A%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%20%3A%3D%0Abegin%0A%20%20cases%20t%20with%20t%20pf%2C%0A%20%20cases%20t%20with%20t_left%20t_right%2C%0A%20%20left%2C%20use%28unit.star%29%2C%20rw%20%E2%86%90%20pf%2C%20refl%2C%0A%20%20right%2C%0A%20%20use%20%28order%20t_left%2C%20order%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pf%2C%20order_sum%20t_left%20t_right%5D%2C%0A%20%20split%2C%0A%20%20use%20t_left%2C%0A%20%20use%20t_right%2C%0Aend%0A%0Adef%20cat_join%20%7Bn%20%3A%20%E2%84%95%7D%20%28input%20%3A%20sum%20%20%7Bk%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%29%0A%3A%20catalan%20n%20%3A%3D%20%0Abegin%0A%20%20cases%20input%2C%0A%20%20use%20binary_tree.pt%2C%0A%20%20rw%20input.prop%2C%20refl%2C%0A%20%20cases%20input%20with%20pair%20pair_of_trees%2C%20%20%20%20%20%20--%20There's%20a%20lot%20to%20unpack%20here...%0A%20%20cases%20pair_of_trees%20with%20t_left%20t_right%2C%20%20--%20%0A%20%20cases%20t_left%20with%20t_left%20pf_left%2C%20%20%20%20%20%20%20%20%20--%0A%20%20cases%20t_right%20with%20t_right%20pf_right%2C%20%20%20%20%20%20--%0A%20%20use%20%28binary_tree.join%20t_left%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pair.prop%2C%20order_sum%20t_left%20t_right%2C%20pf_left%2C%20pf_right%5D%2C%0Aend%0A%0Adef%20cat_self_recurse%20%7Bn%20%3A%20%E2%84%95%7D%20%3A%0Aequiv%0A%20%20%28catalan%20n%29%0A%20%20%28sum%0A%20%20%20%20%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%20%20%20%20%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%0A%20%20%29%0A%3A%3D%0Abegin%0A%20%20use%20cat_split%2C%20use%20cat_join%2C%0A%20%20intro%20t%2C%0A%20%20cases%20n%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20refl%2C%0A%20%20%20%20rw%20order_sum%20at%20pf%2C%20contradiction%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20contradiction%2C%0A%20%20%20%20unfold%20cat_split%2C%20simp%20%5Bcat_join%5D%2C%0A%20%20%20%20intro%20triv_or_pairtrees%2C%0A%20%20%20%20cases%20triv_or_pairtrees%2C%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%0A%20%20%20%20cases%20triv_or_pairtrees%20with%20pair%20pair_of_trees%2C%0A%20%20%20%20cases%20pair_of_trees%20with%20t1%20t2%2C%0A%20%20%20%20cases%20t1%20with%20t1%20h1%2C%0A%20%20%20%20cases%20t2%20with%20t2%20h2%2C%0A%20%20%20%20cases%20pair%20with%20pair%20h%2C%0A%20%20%20%20cases%20pair%20with%20i%20j%2C%0A%20%20%20%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%20--%20Here%20is%20where%20the%20%3D%3D%20goal%20gets%20introduced.%20%0A%20%20%20%20split%2C%0A%20%20%20%20simp%20%5Bh1%2C%20h2%5D%2C%0A%20%20%20%20sorry%2C%0Aend\">working example</a>. I would not call it minimal, since I do not understand the problem well enough to pare it down to just that issue. I am trying to prove <code>cat_self_recurse</code>, and I included a comment the exact step which introduced the <code>==</code> goal. Basically, I had a complicated expression involving <code>cat_split</code> and <code>cat_join</code>, which are the inductively defined functions which are supposed to be inverses. I need to \"unpack\" these definitions in exactly right way, so I used <code>simp [cat_split, cat_join]</code>, but I guess lean couldn't prove both sides had the right types.</p>",
        "id": 290300677,
        "sender_full_name": "Michael Earnest",
        "timestamp": 1658352079
    },
    {
        "content": "<p>Destructuring via <code>cases</code> or brute-force rewriting an equality using <code>subst</code> are usually most helpful. <code>congr</code> can usually make progress too.</p>",
        "id": 290300731,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658352110
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.linarith%0A%0Ainductive%20binary_tree%0A%7C%20%20%20%20pt%20%3A%20binary_tree%0A%7C%20%20join%20%3A%20binary_tree%20%E2%86%92%20binary_tree%20%E2%86%92%20binary_tree%0A%0Adef%20order%20%28t%20%3A%20binary_tree%29%20%3A%20%E2%84%95%20%3A%3D%20binary_tree.rec_on%20t%200%20%28%CE%BB%20left%20right%20x%20y%2C%20x%20%2B%20y%20%2B%201%29%0A%0Alemma%20order_sum%20%28L%20R%20%3A%20binary_tree%29%20%3A%20order%20%28binary_tree.join%20L%20R%29%20%3D%20order%20L%20%2B%20order%20R%20%2B%201%20%3A%3D%20begin%20refl%2C%20end%0A%0Adef%20catalan%20%28n%20%3A%20%E2%84%95%29%20%3A%20Type%20%3A%3D%20%7Bt%20%3A%20binary_tree%20%2F%2F%20order%20t%20%3D%20n%7D%0A%0Adef%20cat_split%20%7Bn%20%3A%20%E2%84%95%7D%20%28t%20%3A%20catalan%20n%29%20%3A%20--%20A%20catalan%20n%20object%0Asum%20--is%20either%20a%20unit%2C%20in%20the%20case%20n%20%3D%200%2C%20or%20a%20pair%20%28h%2Ck%29%20with%20h%2Bk%2B1%3Dn%2C%20and%20an%20ordered%20pair%20%28cat%20h%2C%20cat%20k%29%0A%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%20%3A%3D%0Abegin%0A%20%20cases%20t%20with%20t%20pf%2C%0A%20%20cases%20t%20with%20t_left%20t_right%2C%0A%20%20left%2C%20use%28unit.star%29%2C%20rw%20%E2%86%90%20pf%2C%20refl%2C%0A%20%20right%2C%0A%20%20use%20%28order%20t_left%2C%20order%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pf%2C%20order_sum%20t_left%20t_right%5D%2C%0A%20%20split%2C%0A%20%20use%20t_left%2C%0A%20%20use%20t_right%2C%0Aend%0A%0Adef%20cat_join%20%7Bn%20%3A%20%E2%84%95%7D%20%28input%20%3A%20sum%20%20%7Bk%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%29%0A%3A%20catalan%20n%20%3A%3D%20%0Abegin%0A%20%20cases%20input%2C%0A%20%20use%20binary_tree.pt%2C%0A%20%20rw%20input.prop%2C%20refl%2C%0A%20%20cases%20input%20with%20pair%20pair_of_trees%2C%20%20%20%20%20%20--%20There's%20a%20lot%20to%20unpack%20here...%0A%20%20cases%20pair_of_trees%20with%20t_left%20t_right%2C%20%20--%20%0A%20%20cases%20t_left%20with%20t_left%20pf_left%2C%20%20%20%20%20%20%20%20%20--%0A%20%20cases%20t_right%20with%20t_right%20pf_right%2C%20%20%20%20%20%20--%0A%20%20use%20%28binary_tree.join%20t_left%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pair.prop%2C%20order_sum%20t_left%20t_right%2C%20pf_left%2C%20pf_right%5D%2C%0Aend%0A%0Adef%20cat_self_recurse%20%7Bn%20%3A%20%E2%84%95%7D%20%3A%0Aequiv%0A%20%20%28catalan%20n%29%0A%20%20%28sum%0A%20%20%20%20%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%20%20%20%20%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%0A%20%20%29%0A%3A%3D%0Abegin%0A%20%20use%20cat_split%2C%20use%20cat_join%2C%0A%20%20intro%20t%2C%0A%20%20cases%20n%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20refl%2C%0A%20%20%20%20rw%20order_sum%20at%20pf%2C%20contradiction%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20contradiction%2C%0A%20%20%20%20unfold%20cat_split%2C%20simp%20%5Bcat_join%5D%2C%0A%20%20%20%20intro%20triv_or_pairtrees%2C%0A%20%20%20%20cases%20triv_or_pairtrees%2C%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%0A%20%20%20%20cases%20triv_or_pairtrees%20with%20pair%20pair_of_trees%2C%0A%20%20%20%20cases%20pair_of_trees%20with%20t1%20t2%2C%0A%20%20%20%20cases%20t1%20with%20t1%20h1%2C%0A%20%20%20%20cases%20t2%20with%20t2%20h2%2C%0A%20%20%20%20cases%20pair%20with%20pair%20h%2C%0A%20%20%20%20cases%20pair%20with%20i%20j%2C%0A%20%20%20%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%20--%20Here%20is%20where%20the%20%3D%3D%20goal%20gets%20introduced.%20%0A%20%20%20%20split%2C%0A%20%20%20%20simp%20%5Bh1%2C%20h2%5D%2C%0A%20%20%20%20congr'%201%2C%0A%20%20%20%20simp%20%5Bh1%5D%2C%0A%20%20%20%20simp%20%5Bh2%5D%2C%0A%20%20%20%20congr'%201%2C%0A%20%20%20%20simp%20%5Bh1%5D%2C%0A%20%20%20%20congr'%201%2C%0A%20%20%20%20simp%20%5Bh2%5D%2C%0Aend\">Here is my solution</a>.</p>",
        "id": 290302217,
        "sender_full_name": "FR",
        "timestamp": 1658352832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515599\">Michael Earnest</span> has marked this topic as resolved.</p>",
        "id": 290303776,
        "sender_full_name": "Notification Bot",
        "timestamp": 1658353591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455791\">@FR</span> , you are a beast, thank you!</p>",
        "id": 290303797,
        "sender_full_name": "Michael Earnest",
        "timestamp": 1658353602
    },
    {
        "content": "<p>Also <a href=\"https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.linarith%0A%0Ainductive%20binary_tree%0A%7C%20%20%20%20pt%20%3A%20binary_tree%0A%7C%20%20join%20%3A%20binary_tree%20%E2%86%92%20binary_tree%20%E2%86%92%20binary_tree%0A%0Adef%20order%20%28t%20%3A%20binary_tree%29%20%3A%20%E2%84%95%20%3A%3D%20binary_tree.rec_on%20t%200%20%28%CE%BB%20left%20right%20x%20y%2C%20x%20%2B%20y%20%2B%201%29%0A%0Alemma%20order_sum%20%28L%20R%20%3A%20binary_tree%29%20%3A%20order%20%28binary_tree.join%20L%20R%29%20%3D%20order%20L%20%2B%20order%20R%20%2B%201%20%3A%3D%20begin%20refl%2C%20end%0A%0Adef%20catalan%20%28n%20%3A%20%E2%84%95%29%20%3A%20Type%20%3A%3D%20%7Bt%20%3A%20binary_tree%20%2F%2F%20order%20t%20%3D%20n%7D%0A%0Adef%20cat_split%20%7Bn%20%3A%20%E2%84%95%7D%20%28t%20%3A%20catalan%20n%29%20%3A%20--%20A%20catalan%20n%20object%0Asum%20--is%20either%20a%20unit%2C%20in%20the%20case%20n%20%3D%200%2C%20or%20a%20pair%20%28h%2Ck%29%20with%20h%2Bk%2B1%3Dn%2C%20and%20an%20ordered%20pair%20%28cat%20h%2C%20cat%20k%29%0A%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%20%3A%3D%0Abegin%0A%20%20cases%20t%20with%20t%20pf%2C%0A%20%20cases%20t%20with%20t_left%20t_right%2C%0A%20%20left%2C%20use%28unit.star%29%2C%20rw%20%E2%86%90%20pf%2C%20refl%2C%0A%20%20right%2C%0A%20%20use%20%28order%20t_left%2C%20order%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pf%2C%20order_sum%20t_left%20t_right%5D%2C%0A%20%20split%2C%0A%20%20use%20t_left%2C%0A%20%20use%20t_right%2C%0Aend%0A%0Adef%20cat_join%20%7Bn%20%3A%20%E2%84%95%7D%20%28input%20%3A%20sum%20%20%7Bk%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%29%0A%3A%20catalan%20n%20%3A%3D%20%0Abegin%0A%20%20cases%20input%2C%0A%20%20use%20binary_tree.pt%2C%0A%20%20rw%20input.prop%2C%20refl%2C%0A%20%20cases%20input%20with%20pair%20pair_of_trees%2C%20%20%20%20%20%20--%20There's%20a%20lot%20to%20unpack%20here...%0A%20%20cases%20pair_of_trees%20with%20t_left%20t_right%2C%20%20--%20%0A%20%20cases%20t_left%20with%20t_left%20pf_left%2C%20%20%20%20%20%20%20%20%20--%0A%20%20cases%20t_right%20with%20t_right%20pf_right%2C%20%20%20%20%20%20--%0A%20%20use%20%28binary_tree.join%20t_left%20t_right%29%2C%0A%20%20simp%20%5B%E2%86%90%20pair.prop%2C%20order_sum%20t_left%20t_right%2C%20pf_left%2C%20pf_right%5D%2C%0Aend%0A%0Adef%20cat_self_recurse%20%7Bn%20%3A%20%E2%84%95%7D%20%3A%0Aequiv%0A%20%20%28catalan%20n%29%0A%20%20%28sum%0A%20%20%20%20%7Bu%20%3A%20unit%20%2F%2F%20n%20%3D%200%7D%20%0A%20%20%20%20%28sigma%20%28%CE%BB%20pair%20%3A%20%7Bpair%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%2F%2F%20pair.fst%20%2B%20pair.snd%20%2B%201%20%3D%20n%7D%2C%20catalan%20pair.val.fst%20%C3%97%20catalan%20pair.val.snd%29%29%0A%20%20%29%0A%3A%3D%0Abegin%0A%20%20use%20cat_split%2C%20use%20cat_join%2C%0A%20%20intro%20t%2C%0A%20%20cases%20n%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20refl%2C%0A%20%20%20%20rw%20order_sum%20at%20pf%2C%20contradiction%2C%0A%20%20%20%20cases%20t%20with%20t%20pf%2C%0A%20%20%20%20cases%20t%20with%20t_l%20t_r%2C%20contradiction%2C%0A%20%20%20%20unfold%20cat_split%2C%20simp%20%5Bcat_join%5D%2C%0A%20%20%20%20intro%20triv_or_pairtrees%2C%0A%20%20%20%20cases%20triv_or_pairtrees%2C%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%0A%20%20%20%20cases%20triv_or_pairtrees%20with%20pair%20pair_of_trees%2C%0A%20%20%20%20cases%20pair_of_trees%20with%20t1%20t2%2C%0A%20%20%20%20cases%20t1%20with%20t1%20h1%2C%0A%20%20%20%20cases%20t2%20with%20t2%20h2%2C%0A%20%20%20%20cases%20pair%20with%20pair%20h%2C%0A%20%20%20%20cases%20pair%20with%20i%20j%2C%0A%20%20%20%20simp%20%5Bcat_join%2C%20cat_split%5D%2C%20--%20Here%20is%20where%20the%20%3D%3D%20goal%20gets%20introduced.%20%0A%20%20%20%20split%2C%0A%20%20%20%20simp%20%5Bh1%2C%20h2%5D%2C%0A%20%20%20%20congr'%2C%0A%20%20%20%20simp%20%5Bh1%5D%2C%0A%20%20%20%20simp%20%5Bh2%5D%2C%0Aend\">this</a> is shorter. Just merge <code>congr'</code>s into one.</p>",
        "id": 290304524,
        "sender_full_name": "FR",
        "timestamp": 1658353991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"515599\">@Michael Earnest</span> If you go back to just before the <code>simp</code> and instead simplify <code>h</code>, <code>h1</code>, and <code>h2</code> and then do <code>cases</code> on each of these (or, equivalent, doing <code>subst</code> on <code>n</code>, <code>i</code>, and <code>j</code>) then the <code>simp</code> completely handles the goal without introducing a <code>==</code>.</p>\n<p>I also went ahead and switched your definitions to using the equation compiler, which lets you do pattern matching rather than lots of <code>cases</code> in a tactic block.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.linarith</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">binary_tree</span>\n<span class=\"bp\">|</span>    <span class=\"n\">pt</span> <span class=\"o\">:</span> <span class=\"n\">binary_tree</span>\n<span class=\"bp\">|</span>  <span class=\"n\">join</span> <span class=\"o\">:</span> <span class=\"n\">binary_tree</span> <span class=\"bp\">→</span> <span class=\"n\">binary_tree</span> <span class=\"bp\">→</span> <span class=\"n\">binary_tree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">order</span> <span class=\"o\">:</span> <span class=\"n\">binary_tree</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">binary_tree.pt</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">binary_tree.join</span> <span class=\"n\">left</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">order</span> <span class=\"n\">left</span> <span class=\"bp\">+</span> <span class=\"n\">order</span> <span class=\"n\">right</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- not needed, since this is one of the equations for `order`</span>\n<span class=\"c1\">--lemma order_sum (L R : binary_tree) : order (binary_tree.join L R) = order L + order R + 1 := begin refl, end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">catalan</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">binary_tree</span> <span class=\"bp\">//</span> <span class=\"n\">order</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">A catalan n object is either a unit, in the case n = 0, or a pair (h,k) with h+k+1=n, and an ordered pair (cat h, cat k)</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">cat_split</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">catalan</span> <span class=\"n\">n</span> <span class=\"bp\">→</span>\n  <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">unit</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">⊕</span>\n  <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">pair.fst</span> <span class=\"bp\">+</span> <span class=\"n\">pair.snd</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}),</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.fst</span> <span class=\"bp\">×</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.snd</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">binary_tree.pt</span><span class=\"o\">,</span> <span class=\"n\">pf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">sum.inl</span> <span class=\"o\">⟨</span><span class=\"n\">unit.star</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">pf</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"kd\">end</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">binary_tree.join</span> <span class=\"n\">left</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">pf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">sum.inr</span> <span class=\"o\">⟨⟨(</span><span class=\"n\">order</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">order</span> <span class=\"n\">right</span><span class=\"o\">),</span> <span class=\"kd\">begin</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">pf</span><span class=\"o\">,</span> <span class=\"n\">order</span><span class=\"o\">],</span> <span class=\"kd\">end</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cat_join</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">unit</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">⊕</span>\n  <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">pair.fst</span> <span class=\"bp\">+</span> <span class=\"n\">pair.snd</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}),</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.fst</span> <span class=\"bp\">×</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.snd</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">catalan</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">sum.inl</span> <span class=\"n\">input</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">binary_tree.pt</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">rwa</span> <span class=\"n\">input.prop</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"kd\">end</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">sum.inr</span> <span class=\"o\">⟨</span><span class=\"n\">pair</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">t_left</span><span class=\"o\">,</span> <span class=\"n\">pf_left</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">t_right</span><span class=\"o\">,</span> <span class=\"n\">pf_right</span><span class=\"o\">⟩⟩)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">binary_tree.join</span> <span class=\"n\">t_left</span> <span class=\"n\">t_right</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">pair.prop</span><span class=\"o\">,</span> <span class=\"n\">order</span><span class=\"o\">,</span> <span class=\"n\">pf_left</span><span class=\"o\">,</span> <span class=\"n\">pf_right</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cat_self_recurse</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">catalan</span> <span class=\"n\">n</span> <span class=\"bp\">≃</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">unit</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">⊕</span>\n  <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">pair.fst</span> <span class=\"bp\">+</span> <span class=\"n\">pair.snd</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}),</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.fst</span> <span class=\"bp\">×</span> <span class=\"n\">catalan</span> <span class=\"n\">pair.val.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">cat_split</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">cat_join</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">t</span> <span class=\"n\">pf</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">t_l</span> <span class=\"n\">t_r</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">order</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">pf</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cat_split</span><span class=\"o\">,</span> <span class=\"n\">cat_join</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">triv_or_pairtrees</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">triv_or_pairtrees</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cat_join</span><span class=\"o\">,</span> <span class=\"n\">cat_split</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">triv_or_pairtrees</span> <span class=\"k\">with</span> <span class=\"n\">pair</span> <span class=\"n\">pair_of_trees</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">pair_of_trees</span> <span class=\"k\">with</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">t1</span> <span class=\"k\">with</span> <span class=\"n\">t1</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">t2</span> <span class=\"k\">with</span> <span class=\"n\">t2</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">pair</span> <span class=\"k\">with</span> <span class=\"n\">pair</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">pair</span> <span class=\"k\">with</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cat_join</span><span class=\"o\">,</span> <span class=\"n\">cat_split</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>",
        "id": 290306761,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658355294
    },
    {
        "content": "<p>You can also simplify your sequences of <code>cases</code> using <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases\">tactic#rcases</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#obtain\">tactic#obtain</a>, or <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#rintro\">tactic#rintro</a>, which are all very convenient (though I didn't do this).</p>",
        "id": 290306899,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658355368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Hey Kyle, you went above and beyond with your reply. It teaches a lot about how to do things cleanly in lean.</p>",
        "id": 290324591,
        "sender_full_name": "Michael Earnest",
        "timestamp": 1658369917
    }
]
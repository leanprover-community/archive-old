[
    {
        "content": "<p>I might have a crack at showing that sets form a category that is a model of ETCS <a href=\"https://ncatlab.org/nlab/show/ETCS\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/ETCS\">https://ncatlab.org/nlab/show/ETCS</a></p>",
        "id": 135520140,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539149566
    },
    {
        "content": "<p>Or at least build a model of ETCS in Lean. Not sure quite what the sets of Lean <em>are</em> yet.</p>",
        "id": 135520152,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539149622
    },
    {
        "content": "<p>I mean, I notice that in <code>set_theory.zfc</code> presets are used, but I can't tell if these are the same as Bishop-style presets (<a href=\"https://ncatlab.org/nlab/show/preset\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/preset\">https://ncatlab.org/nlab/show/preset</a>) and then sets are what are sometimes called setoids (<a href=\"https://ncatlab.org/nlab/show/equivalence+relation#setoids\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/equivalence+relation#setoids\">https://ncatlab.org/nlab/show/equivalence+relation#setoids</a>)</p>",
        "id": 135520216,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539149746
    },
    {
        "content": "<p>There are multiple formalizations of sets in Lean, depending on your needs. <code>set_theory.zfc</code> is if you're interested in (untyped) ZFC set theory, <code>data.set</code> formalize sets whose elements have a certain type as predicates on that type and <code>data.finset</code> formalizes finite sets whose elements also have a given type.</p>",
        "id": 135520260,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1539149799
    },
    {
        "content": "<p>In <code>set_theory.zfc</code> there is <code>pSet</code> but there's also <code>Set</code> which might be more useful</p>",
        "id": 135520277,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1539149879
    },
    {
        "content": "<p>I think that <code>pSet</code> is indeed a preset in the nLab sense</p>",
        "id": 135520450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150138
    },
    {
        "content": "<p>Yes, I could show that ZFC-sets give a model of ETCS, but it would be more interesting to show that one could build the category of \"sets\" directly, without knowing a well-founded \\in-tree structure on them.</p>",
        "id": 135520457,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150154
    },
    {
        "content": "<p>although of course there is an equality relation on <code>pSet</code>, since it is a type; this equality is too fine for ZFC and <code>Set</code> is a quotient of this by set extensionality</p>",
        "id": 135520466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150187
    },
    {
        "content": "<p>So I guess: is there a way to talk about sets native to Lean, as there is in HoTT, for instance? (where there is the type of hSets)</p>",
        "id": 135520467,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150189
    },
    {
        "content": "<p>hSet = Type in lean</p>",
        "id": 135520468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150203
    },
    {
        "content": "<p>Oh, cool!</p>",
        "id": 135520469,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150209
    },
    {
        "content": "<p>all types are \"sets\" in the HoTT sense, because of proof irrelevance</p>",
        "id": 135520472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150218
    },
    {
        "content": "<p>So, in principle, one could try to show that Type is (the objects of) a category—perhaps this is done already—and then show it is a term of type <code>ETCS</code>, once that is defined.</p>",
        "id": 135520526,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150298
    },
    {
        "content": "<p>yes, that should not be difficult</p>",
        "id": 135520544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150350
    },
    {
        "content": "<p>There is a category of types in <code>category_theory.types</code></p>",
        "id": 135520546,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1539150351
    },
    {
        "content": "<p>The category structure on <code>Type</code> is at <a href=\"https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean\">https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean</a></p>",
        "id": 135520547,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539150353
    },
    {
        "content": "<p>also ^ that</p>",
        "id": 135520549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> not fast enough!</p>",
        "id": 135520589,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1539150372
    },
    {
        "content": "<p>:-)</p>",
        "id": 135520591,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539150393
    },
    {
        "content": "<p>I was running a longer race. :-)</p>",
        "id": 135520593,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539150400
    },
    {
        "content": "<p>Now you understand why some of my code snippets have small type errors in them :P</p>",
        "id": 135520607,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1539150456
    },
    {
        "content": "<p>OK, cool, thanks :-)</p>",
        "id": 135520725,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150623
    },
    {
        "content": "<p>What's more, I think there is a model of ETCS in <code>Type</code></p>",
        "id": 135520730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150650
    },
    {
        "content": "<p>i.e. a suitably large inductive type can give you all the types you need to interpret the operations of ETCS</p>",
        "id": 135520738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150674
    },
    {
        "content": "<p>As an aside: is there a handy chart that details the various unicode autocompletion shortcuts? and/or LaTeX : autocompl shortcut table?</p>",
        "id": 135520740,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150680
    },
    {
        "content": "<p>If you want the full list you should look at the vscode extension file</p>",
        "id": 135520744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150708
    },
    {
        "content": "<p>but it is quite large and likely auto-populated with a bunch of things from LaTeX</p>",
        "id": 135520791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150736
    },
    {
        "content": "<p>You can also paste in symbols from <a href=\"https://github.com/EdAyers/mathlib/blob/doc/docs/unicode.md\" target=\"_blank\" title=\"https://github.com/EdAyers/mathlib/blob/doc/docs/unicode.md\">this page</a> and hover over them to see what the completion is.</p>",
        "id": 135520794,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1539150739
    },
    {
        "content": "<p>Which lives...? (thanks, btw)</p>",
        "id": 135520796,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150740
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>  cool, thanks</p>",
        "id": 135520801,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150766
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/vscode-lean/blob/master/translations.json\" target=\"_blank\" title=\"https://github.com/leanprover/vscode-lean/blob/master/translations.json\">https://github.com/leanprover/vscode-lean/blob/master/translations.json</a></p>",
        "id": 135520810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150776
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/vscode-lean/blob/master/translations.json\" target=\"_blank\" title=\"https://github.com/leanprover/vscode-lean/blob/master/translations.json\">Here's</a> the vscode file</p>",
        "id": 135520811,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1539150776
    },
    {
        "content": "<p><span class=\"emoji emoji-1f44d\" title=\"+1\">:+1:</span></p>",
        "id": 135520872,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539150879
    },
    {
        "content": "<p>The maintainer of the extension (Gabriel Ebner) is quite receptive to adding new symbols if you spot one in high unicode that you like</p>",
        "id": 135520877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539150903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130272\">@David Michael Roberts</span> Nice seeing you here!</p>\n<p><code>Type</code> is indeed a model of ETCS; function extensionality should correspond to well-pointedness,  working in <code>classical</code>, we have choice, <code>Prop</code> is the subobject classifier, and  the NNO is <code>nat</code>.</p>",
        "id": 135716573,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1539404059
    },
    {
        "content": "<p>Sure, but is it _proved_ to be a model of ETCS? And, if I use the constructive fragment, do I get a model of the constructive version (a la I guess Mike Shulman's \"material and structural set theories\" paper)</p>",
        "id": 135716828,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539404552
    },
    {
        "content": "<p>Oh, and thanks, <span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span>  :-)</p>",
        "id": 135716833,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539404567
    },
    {
        "content": "<p>Also, one could go the whole hog and show without using even <code>Prop</code> that Type is some kind of predicative topos...</p>",
        "id": 135716853,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539404621
    },
    {
        "content": "<p>That said, this is just to get me wet behind the ears and play around with stuff that I care about.</p>",
        "id": 135716897,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539404659
    },
    {
        "content": "<p>Do you know what that should mean?</p>",
        "id": 135716898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539404661
    },
    {
        "content": "<p>There is a constructive version of well-pointedness, that doesn't force Booleanness. just that \"a global element of the subobject classifier is false if and only if it is not true.\" (from <a href=\"https://ncatlab.org/nlab/show/well-pointed+topos\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/well-pointed+topos\">https://ncatlab.org/nlab/show/well-pointed+topos</a>)</p>",
        "id": 135716988,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539404791
    },
    {
        "content": "<p>And as far as predicative stuff, one could show directly that Type is a Pi-W-pretopos satisfying some version of WISC (??? not sure about that one), following eg Benno van den Berg</p>",
        "id": 135717000,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539404843
    },
    {
        "content": "<p>For instance \"the category of Bishop sets in Martin-Löf type theory is a predicative topos\" (<a href=\"https://ncatlab.org/nlab/show/predicative+topos\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/predicative+topos\">https://ncatlab.org/nlab/show/predicative+topos</a>)</p>",
        "id": 135717053,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539404996
    },
    {
        "content": "<p>I'm not sure about WISC, seems like any version of the axiom of choice is likely to be false without <code>choice</code>, but I checked the proof that epis are surjective in lean:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">epi</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">true</span><span class=\"bp\">⟩</span> <span class=\"k\">in</span>\n<span class=\"k\">have</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">H</span> <span class=\"bp\">_</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">congr_arg</span> <span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">up</span> <span class=\"err\">$</span> <span class=\"n\">eq_true_intro</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">),</span>\n<span class=\"k\">by</span> <span class=\"n\">injection</span> <span class=\"n\">congr_fun</span> <span class=\"n\">this</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">cast</span> <span class=\"n\">eq_true</span> <span class=\"n\">h_1</span>\n</pre></div>\n\n\n<p>and it looks like you need <code>Prop</code> and <code>propext</code> essentially (you can't prove it using <code>trunc</code>, and you certainly can't prove it \"constructively\" i.e. with a sigma)</p>",
        "id": 135718340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539407579
    },
    {
        "content": "<p>Actually I find this to be an interesting example of a \"nonconstructive\" constructive exists, in the sense that you can't upgrade the exists to a data type even though the proof does not use choice.</p>",
        "id": 135718618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539408240
    },
    {
        "content": "<p>I am almost certain that WISC is not provable, although I don't think there is an easy proof of this. I don't think Asaf Karagila's proof <a href=\"https://arxiv.org/pdf/1212.4396.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1212.4396.pdf\">https://arxiv.org/pdf/1212.4396.pdf</a> is much affected by the presence of inaccessible cardinals, so it should be independent of lean as well by simulation in ZFC + omega inaccessibles (below the first inaccessible because we are working in <code>Type</code>).</p>",
        "id": 135719664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539410543
    },
    {
        "content": "<p>Well, I did prove (on paper) that WISC isn't provable from the axioms of an elementary topos, by constructing a topos where it fails :-)</p>",
        "id": 135721449,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539414712
    },
    {
        "content": "<p>I suppose that's also an option... I guess lean has a bit more structure though, so maybe you have to do that with pi-W-toposes? Is that a thing?</p>",
        "id": 135721505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539414791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130272\">@David Michael Roberts</span> I'm not sure if</p>\n<blockquote>\n<p>a global element of the subobject classifier is false if and only if it is not true</p>\n</blockquote>\n<p>holds without invoking <code>classical</code>. Without being able to take a filterquotient of <code>Prop</code>, it's just a massive Heyting algebra, and even with excluded middle, if Lean knows that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⊢</mo><mi>p</mi><mo>∨</mo><mi mathvariant=\"normal\">¬</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\"> \\vdash p \\vee \\neg p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mrel\">⊢</span><span class=\"mord mathit\">p</span><span class=\"mbin\">∨</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">p</span></span></span></span>, it does not necessarily decide if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">p</span></span></span></span> is true or false.</p>\n<p>Lean is also not quite a topos over <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"bold\">S</mi><mi mathvariant=\"bold\">e</mi><mi mathvariant=\"bold\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68611em;\"></span><span class=\"strut bottom\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbf\">S</span><span class=\"mord mathbf\">e</span><span class=\"mord mathbf\">t</span></span></span></span></span>, for it lacks externally indexed colimits (while <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathrm\">Σ</span></span></span></span>-types and quotient types give all internally indexed colimits).</p>",
        "id": 135743749,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1539458355
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> Could you unpack what that statement about the subobject classifier should mean? I assume <code>Prop</code> is a subobject classifier for <code>Type</code> even without <code>choice</code> (but assuming <code>propext</code>), because every monomorphism in <code>Type</code> is an injection, and so it factors through the subtype on the range.</p>\n<p>Actually, I see another problem: If f : A -&gt; X is a monomorphism and g : X -&gt; Prop is the function <code>g x = \\ex a, f x = a</code>, then we want a pullback square with the <code>true : unit -&gt; Prop</code> function. But the subtype is a pullback, and A is not constructively isomorphic to the subtype, so I don't think it holds. That is, <code>Prop</code> isn't even a subobject classifier.</p>",
        "id": 135752172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539474019
    },
    {
        "content": "<p>That's interesting. (I assume you mean <code>g x = \\ex a, f a = x</code>.) Why is the image of an injection not constructively isomorphic to its domain?</p>",
        "id": 135754838,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1539478582
    },
    {
        "content": "<p>There are a few ways to look at it. My favorite is to think in terms of what is \"data\" vs \"erased\" stuff, which corresponds to stuff that the computer could actually execute or manipulate. If you have a function f : A -&gt; X where A and X are both data types, then f is a real <em>function</em>, something that transforms one kind of representation into another. There is no guarantee that this transformation is invertible, and in particular assuming that f is injective does not supply you with such an inverse. (This is why <code>equiv</code> contains an explicit inverse function, and <code>bijection</code> is a weaker notion.) So defining a function from A to {x // x \\in range f} is easy by restricting the codomain of f, but you don't have enough data for the converse function.</p>\n<p>In set theory you would use the exists assumption to give the value, but since this is a Prop, it is \"not data\" and can't be turned into data. If you use a Type-valued equivalent, like <code>trunc {a // f a = x}</code>, then it would be constructively bijective, but in this case I'm not sure it's a pullback.</p>",
        "id": 135755636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539479766
    },
    {
        "content": "<p>If that's the case, when maybe one does need 'classical' to show that <code>Prop</code> (which is then <code>bool</code>) is a subobject classifier after all.</p>\n<p>Could you explain why couldn't we do something like, take the collection of pairs <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a, f(a))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> and flip the pairs to get an inverse?</p>",
        "id": 135755884,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1539480329
    },
    {
        "content": "<p>Ah, here's another way to show choiceless <code>Type</code> is not a topos:</p>\n<blockquote>\n<p>Corollary 4.2. <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"bold\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbf{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68611em;\"></span><span class=\"strut bottom\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbf\">C</span></span></span></span></span> is balanced, i.e., a morphism in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"bold\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbf{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68611em;\"></span><span class=\"strut bottom\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbf\">C</span></span></span></span></span> is an isomorphism iff it is both monic and epic. (<a href=\"https://ncatlab.org/nlab/show/subobject+classifier\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/subobject+classifier\">https://ncatlab.org/nlab/show/subobject+classifier</a>)</p>\n</blockquote>\n<p>This is not true in <code>Type</code>, since as I said monic means <code>injective</code> and epic means <code>surjective</code>, and the conjunction of these is <code>bijective</code> which is not the same as <code>equiv</code> which is isomorphism.</p>",
        "id": 135755947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480416
    },
    {
        "content": "<p>Actually unique choice is enough to prove that a bijection is an equiv</p>",
        "id": 135755957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480456
    },
    {
        "content": "<p>so you can still get this property without collapsing Prop = bool</p>",
        "id": 135755959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480474
    },
    {
        "content": "<blockquote>\n<p>Could you explain why couldn't we do something like, take the collection of pairs <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(a, f(a))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> and flip the pairs to get an inverse?</p>\n</blockquote>\n<p>because that's not how functions are defined in type theory. In type theory every function is given by a term that has a free variable for the argument</p>",
        "id": 135756014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480572
    },
    {
        "content": "<p>That is, \"functions\" and \"functional relations\" are not the same</p>",
        "id": 135756017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480596
    },
    {
        "content": "<p>a definition like that one would give a functional relation, but proving that a functional relation induces a function requires unique choice</p>",
        "id": 135756071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480629
    },
    {
        "content": "<p>By the way, this kind of thing comes up even in \"real math\". For example, the derivative of a function is a functional relation, not a function</p>",
        "id": 135756084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480699
    },
    {
        "content": "<p>You can of course use choice to upgrade it to a function but it's not quite natural and lean will make it feel a little awkward</p>",
        "id": 135756136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539480764
    },
    {
        "content": "<p>Right, I see.</p>\n<blockquote>\n<p>Ah, here's another way to show choiceless <code>Type</code> is not a topos:</p>\n<blockquote>\n<p>Corollary 4.2. <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"bold\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbf{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68611em;\"></span><span class=\"strut bottom\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbf\">C</span></span></span></span></span> is balanced, i.e., a morphism in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"bold\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbf{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68611em;\"></span><span class=\"strut bottom\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbf\">C</span></span></span></span></span> is an isomorphism iff it is both monic and epic. (<a href=\"https://ncatlab.org/nlab/show/subobject+classifier\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/subobject+classifier\">https://ncatlab.org/nlab/show/subobject+classifier</a>)</p>\n</blockquote>\n<p>This is not true in <code>Type</code>, since as I said monic means <code>injective</code> and epic means <code>surjective</code>, and the conjunction of these is <code>bijective</code> which is not the same as <code>equiv</code> which is isomorphism.</p>\n</blockquote>\n<p>This is what one usually uses to show that the image of a mono is isomorphic to its domain, so that makes sense.</p>",
        "id": 135756215,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1539480861
    },
    {
        "content": "<p>Well, that was the informal explanation. The real definition is Def 4.1 in Shulman's <a href=\"https://arxiv.org/pdf/1808.05204.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1808.05204.pdf\">https://arxiv.org/pdf/1808.05204.pdf</a> and is stated in the context of a Heyting category, so no subobject classifier necessary.</p>",
        "id": 135756739,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539481891
    },
    {
        "content": "<p>Also, I wouldn't naively take Prop to be the subobject classifier. What about <code>1 -&gt;  Prop</code>?</p>",
        "id": 135756798,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539481954
    },
    {
        "content": "<p><code>Prop</code> and <code>1 -&gt; Prop</code> are isomorphic</p>",
        "id": 135756815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482041
    },
    {
        "content": "<p>Ah, well... :-/</p>",
        "id": 135756863,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482120
    },
    {
        "content": "<p>Looking at </p>\n<blockquote>\n<p>Def 4.1 in Shulman's <a href=\"https://arxiv.org/pdf/1808.05204.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1808.05204.pdf\">https://arxiv.org/pdf/1808.05204.pdf</a> </p>\n</blockquote>\n<p>part a) gives me pause. The other parts b)-d) seem ok (Epis are surjective, \"every function 1-&gt; U \\cup V factors through U or V\" and <code>1-&gt;0</code> is empty).</p>",
        "id": 135756915,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482269
    },
    {
        "content": "<p>I guess (b) isn't obvious to me, mostly because I'm learning the terminology as I go</p>",
        "id": 135756990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482384
    },
    {
        "content": "<p>But (a) does indeed look to be false. If <code>m : A -&gt; X</code> is <code>bijective</code>, then for every <code>x : X</code> (add <code>1 -&gt; </code> if you like) there exists <code>y : A</code> such that <code>f x = y</code>, but it is not necessarily an isomorphism</p>",
        "id": 135757108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482572
    },
    {
        "content": "<p>By Remark 4.2 b) is equiv to epis are surjective, which you proved above.</p>",
        "id": 135757116,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482613
    },
    {
        "content": "<p>But, I think we have to be more careful about what the actual category under discussion is. Is all the metatheory being internalized to Lean?</p>",
        "id": 135757119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482627
    },
    {
        "content": "<p>That is, if you prove there exists a morphism that may not mean that there is a closed term morphism</p>",
        "id": 135757171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482659
    },
    {
        "content": "<p>Hmm, not sure. I was vaguely planning on formalising Mike's definitions and seeing what happened.</p>",
        "id": 135757172,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482667
    },
    {
        "content": "<p>I can almost imagine that knowing that every <code>x : 1 -&gt; X </code> splits over <code>m</code> in some strong external sense implying that there is an inverse function</p>",
        "id": 135757206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482731
    },
    {
        "content": "<p>but that has its own issues</p>",
        "id": 135757207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482747
    },
    {
        "content": "<p>If you assume choice, then of course you get all these properties</p>",
        "id": 135757249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482776
    },
    {
        "content": "<p>I just tuned in and I'm not really sure what is going on here, but in the opposite direction it seems that (c) could fail if you interpreted \"either A or B must be ...\" in a strong external sense, as well</p>",
        "id": 135757252,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539482801
    },
    {
        "content": "<blockquote>\n<p>I can almost imagine that knowing that every <code>x : 1 -&gt; X </code> splits over <code>m</code> in some strong external sense implying that there is an inverse function</p>\n</blockquote>\n<p>ah, that would be quantifying over <code>1-&gt;X</code> I suppose, leading to a section (?). This is the old problem that with the strong constructive quantifier the axiom of choice is simply true.</p>",
        "id": 135757257,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482878
    },
    {
        "content": "<p>Same with (b) if you interpret the statement as a Pi/Sigma rather than a forall/exists</p>",
        "id": 135757296,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539482889
    },
    {
        "content": "<blockquote>\n<p>I just tuned in and I'm not really sure what is going on here, but in the opposite direction it seems that (c) could fail if you interpreted \"either A or B must be ...\" in a strong external sense, as well</p>\n</blockquote>\n<p>I would imagine it's not meant to be exclusive or.</p>",
        "id": 135757299,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482901
    },
    {
        "content": "<p>I mean that you could interpret it as a sum type</p>",
        "id": 135757302,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539482913
    },
    {
        "content": "<p>it's certainly exclusive or, but that's not the hard part</p>",
        "id": 135757305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539482922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  yes, I imagine so.</p>",
        "id": 135757306,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482929
    },
    {
        "content": "<p>rather than the propositional truncation thereof</p>",
        "id": 135757310,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539482938
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  but what if A=B as subobjects of X? (here I'm using Remark 4.2 again)</p>",
        "id": 135757320,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539482955
    },
    {
        "content": "<p>I haven't read the preceding part of the paper so I'm not sure whether the metatheory is intended to be classical or what.</p>",
        "id": 135757324,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539482972
    },
    {
        "content": "<p>If A = B then <code>1 = A \\cup A</code>, and then by pushing the unique element of 1 around you find A = 1 and hence 1 has two distinct elements, which is false</p>",
        "id": 135757404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539483047
    },
    {
        "content": "<p>Actually I'm not even sure why that is an axiom, seems like it should be true in the base theory</p>",
        "id": 135757433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539483103
    },
    {
        "content": "<p>If <code>1 = A \\cup B</code> then you get a distinguished element of <code>A \\cup B</code>, and by following it you find which one is isomorphic to 1</p>",
        "id": 135757503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539483194
    },
    {
        "content": "<p>then again that relies on elementwise reasoning so it probably isn't true in the base theory</p>",
        "id": 135757512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539483221
    },
    {
        "content": "<p>Fair enough. Gotta run now, though</p>",
        "id": 135757578,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539483288
    },
    {
        "content": "<p>BTW, are you allowing <code>funext</code>?</p>",
        "id": 135757675,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539483410
    },
    {
        "content": "<p>I was assuming the other two axioms</p>",
        "id": 135757688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539483439
    },
    {
        "content": "<p>It is true that without quot.sound you have to worry about funext</p>",
        "id": 135757704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539483471
    },
    {
        "content": "<p>Okay good, otherwise I was confused about some earlier stuff.</p>",
        "id": 135757705,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539483474
    },
    {
        "content": "<p>and in that case I'm not sure there is a good theory at all, since the category is all about equalities of morphisms which are functions</p>",
        "id": 135757754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539483509
    },
    {
        "content": "<p>I love that #new users has all these questions about how <code>@</code> works etc  and then a huge thread about topos theory :-)</p>",
        "id": 135771585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539512105
    },
    {
        "content": "<p>Tbh I barely know how <code>@</code> works, too, but I am coming at this top-down, which is probably the wrong way to do it.</p>",
        "id": 135772669,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539513909
    },
    {
        "content": "<p>I don't think there are right and wrong ways to do it. I think we're still figuring out the best ways to learn and to direct growth of Lean. I think the best way to do it is to try all the ways we can think of.</p>",
        "id": 135777652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539523418
    },
    {
        "content": "<p>Re: the preceding discussion, I think one again needs unique choice to show (besides ruling out things like uninvertible bijections) that any epimorphism satisfies the universal property with respect to its kernel relation on its domain (i.e. is regular).</p>",
        "id": 135787077,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1539539745
    }
]
[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">rule1</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"mi\">1</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">this_is_a_test</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}:</span>\n    <span class=\"n\">K</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n_k</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>I have reduced my problem to this simple case. I want to prove that n can only be 1 due to the inductive structure of K that has no other value. In my real-world example, there are plenty of rules with multiple arguments, but the gist of it is this case, which I cannot prove. Any tips?</p>",
        "id": 200286168,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1591734788
    },
    {
        "content": "<p>Continue <code>induction n_k, refl</code>.</p>",
        "id": 200286658,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591735003
    },
    {
        "content": "<p><code>induction</code> is what you should use to prove things about inductive predicates.</p>",
        "id": 200286702,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591735029
    },
    {
        "content": "<p>Thank you! This works on this small problem, but not on the original problem. Let me see if I can figure out the difference.</p>",
        "id": 200286961,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1591735142
    },
    {
        "content": "<p>A more realist example, in which that solution does not work:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">syntax</span>\n\n\n<span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">CheckKind</span>\n<span class=\"k\">with</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">rule1</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"n\">y</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">with</span> <span class=\"n\">CheckKind</span> <span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"bp\">→</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"n\">Kind</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">K_Int</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"c1\">-----------------------------------</span>\n    <span class=\"n\">CheckKind</span> <span class=\"err\">Γ</span> <span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Integer</span> <span class=\"err\">⋆</span>\n\n<span class=\"bp\">|</span> <span class=\"n\">K_Bool</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"c1\">-----------------------------------</span>\n    <span class=\"n\">CheckKind</span> <span class=\"err\">Γ</span> <span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Boolean</span> <span class=\"err\">⋆</span>\n\n\n<span class=\"kn\">theorem</span> <span class=\"n\">this_is_a_test</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"n\">k</span><span class=\"o\">}:</span>\n    <span class=\"n\">CheckKind</span> <span class=\"err\">Γ</span> <span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Integer</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"err\">⋆</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n_k</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n_k</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>The error is:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">test</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">22</span><span class=\"o\">:</span><span class=\"mi\">4</span><span class=\"o\">:</span> <span class=\"n\">error</span>\n<span class=\"n\">induction</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">argument</span> <span class=\"bp\">#</span><span class=\"mi\">2</span> <span class=\"n\">of</span> <span class=\"n\">major</span> <span class=\"n\">premise</span> <span class=\"n\">type</span>\n  <span class=\"n\">CheckKind</span> <span class=\"err\">Γ</span> <span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Integer</span> <span class=\"n\">k</span>\n<span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"kn\">variable</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">Context</span><span class=\"o\">,</span>\n<span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Kind</span><span class=\"o\">,</span>\n<span class=\"n\">n_k</span> <span class=\"o\">:</span> <span class=\"n\">CheckKind</span> <span class=\"err\">Γ</span> <span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Integer</span> <span class=\"n\">k</span>\n<span class=\"err\">⊢</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"err\">⋆</span>\n</code></pre></div>\n\n\n<p>I can provide the full file if required.</p>",
        "id": 200287943,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1591735579
    },
    {
        "content": "<p>Mutual inductives are somehow compiled down to regular inductives in an arcane way. You could try <code>cases n_k</code> and if that doesn't work either then you might want to start looking at the output of <code>#print prefix CheckKind</code> to find out what's actually going on</p>",
        "id": 200290305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591736697
    },
    {
        "content": "<p>The problem was indeed related with mutual induction. A more simple example would be:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">K2</span>\n<span class=\"k\">with</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">rule1</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">with</span> <span class=\"n\">K2</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">rule2</span> <span class=\"o\">:</span> <span class=\"n\">K2</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">this_is_another_test</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"n\">n</span><span class=\"o\">}:</span>\n    <span class=\"n\">K</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n_k</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n_k</span><span class=\"o\">,</span> <span class=\"bp\">&lt;--</span> <span class=\"n\">error</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Using cases indeed worked. Thank you very much to both!</p>",
        "id": 200290779,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1591736920
    },
    {
        "content": "<p>The compilation of mutual inductives to regular inductives is not that arcane, at least on paper, and in fact because of the limitations of Lean's implementation I often just do this compilation process manually by writing the underlying inductive type myself (and depending on the application I might just use the new composite inductive type directly rather than defining the two mutual inductive types and all the translation machinery).</p>\n<p>The idea is simple: Take all the indices of all elements of the mutual inductive and compress them into one \"index inductive\" with one constructor for each mutual inductive. (You can use either a new <code>inductive</code> or just use sums and products if you are too lazy to give this inductive a name.) For example, in your mutual inductive the first inductive is <code>K : ℕ → ℕ → Prop</code> and the second is <code>CheckKind : Context → Ty → Kind → Prop</code>, so the index inductive is essentially <code>ℕ × ℕ ⊕ Context × Ty × Kind</code>, or as an inductive:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">Ty</span> <span class=\"bp\">|</span> <span class=\"n\">Integer</span> <span class=\"bp\">|</span> <span class=\"n\">Boolean</span>\n<span class=\"n\">def</span> <span class=\"n\">Context</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">Kind</span> <span class=\"bp\">|</span> <span class=\"n\">star</span>\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">⋆</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">Kind</span><span class=\"bp\">.</span><span class=\"n\">star</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">K_Kind</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">K_Kind</span>\n<span class=\"bp\">|</span> <span class=\"n\">CheckKind</span> <span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"bp\">→</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"n\">Kind</span> <span class=\"bp\">→</span> <span class=\"n\">K_Kind</span>\n</code></pre></div>\n\n\n<p>The actual inductive we are writing will have type <code>T : K_Kind -&gt; Prop</code>, with the old <code>K m n</code> being expressed as <code>T (K_Kind.K m n)</code> and the old <code>CheckKind Γ A k</code> being <code>T (K_Kind.CheckKind Γ A k)</code>. Then we just write down the constructors:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">K_Kind</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">K_Kind</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">rule1</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">y</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">K_Int</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">CheckKind</span> <span class=\"err\">Γ</span> <span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Integer</span> <span class=\"err\">⋆</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">K_Bool</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">CheckKind</span> <span class=\"err\">Γ</span> <span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Boolean</span> <span class=\"err\">⋆</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Since this example has been significantly golfed already, the mutual inductive is not very interesting because there are no cross-recursions, and this could just be two separate inductive types. But we can easily use either type in any constructor.</p>\n<p>The big advantage of writing things like this instead of using lean's <code>mutual inductive</code> is that you can do proper structural mutual recursion. Currently lean fakes it with well founded recursion and it's not too hard to find the limitations; the recursion principle that is generated is also wrong so it doesn't allow you to manually write structural recursions. This composite inductive's recursor yields the correct mutual recursion principle.</p>",
        "id": 200314611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591756851
    },
    {
        "content": "<p>There is also a wiki page on the MS lean repo <a href=\"https://github.com/leanprover/lean/wiki/Compiling-mutually-inductive-declarations\">Compiling mutually inductive declarations</a> that describes this process.</p>",
        "id": 200314716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591756995
    },
    {
        "content": "<blockquote>\n<p><code>inductive th := t0, t1, t2</code></p>\n</blockquote>\n<p>Oh wow that page is old</p>",
        "id": 200314781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591757064
    },
    {
        "content": "<p>This explanation might well also belong on the community wiki. Mutual inductives are a sore point in Lean.</p>",
        "id": 200317827,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1591762039
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Thank you for the explanation. Because I am having other errors (related to missing well-founded recursion) I might have to move to the \"manually compiled\" version.  And yes, I have a few cross-recursions, thus the need for mutual inductive types. So this was actually very helpful!</p>",
        "id": 200387982,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1591776363
    },
    {
        "content": "<p>(I assumed you did, else why use a mutual inductive? But your example was a bit too abstract to demonstrate all the interesting aspects of mutual inductives.)</p>",
        "id": 200388062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591776435
    }
]
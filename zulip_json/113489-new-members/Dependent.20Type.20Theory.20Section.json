[
    {
        "content": "<p>Hi I'm reading said section from the book \"Theorem Proving in Lean\", and I'm having a few questions hopefully I can get some help:</p>\n<p><a href=\"/user_uploads/3121/eHeLuxCKvVr_1JOPPEpT3P_E/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/eHeLuxCKvVr_1JOPPEpT3P_E/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/eHeLuxCKvVr_1JOPPEpT3P_E/image.png\"></a></div><p>Here' I'm experimenting with universe variables but I don't get why it says <code>u_1</code> instead of just <code>u</code> also <code>u</code> is representing some natural number right?</p>",
        "id": 267315377,
        "sender_full_name": "ccn",
        "timestamp": 1641675822
    },
    {
        "content": "<p>yes <code>u</code> is representing a natural number...the reason it's saying <code>u_1</code> is that what you see on the right hand side does not directly correspond to what you see on the left, the right hand side (aka the infoview) is autogenerated from your file + your current position using another information provided by the compiler and it appears there is a minor cosmetic bug here in this case</p>",
        "id": 267315859,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1641676119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267315859\">said</a>:</p>\n<blockquote>\n<p>yes <code>u</code> is representing a natural number...the reason it's saying <code>u_1</code> is that what you see on the right hand side does not directly correspond to what you see on the left, the right hand side (aka the infoview) is autogenerated from your file + your current position using another information provided by the compiler and it appears there is a minor cosmetic bug here in this case</p>\n</blockquote>\n<p>Ok, so in reality the info view should be saying <code>alpha: Type u</code> right?</p>",
        "id": 267316157,
        "sender_full_name": "ccn",
        "timestamp": 1641676216
    },
    {
        "content": "<p>Yes, I think its just a cosmetic bug, I also would expect the infoview to at least be self consistent so it will most likely use the u_1 identifier in every spot where <code>u</code> should appear</p>",
        "id": 267316207,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1641676309
    },
    {
        "content": "<p>If I wrote <code>#check λ (α β : Type*) (b : β) (x : α), x</code> Then alpha and beta are two arbitrary types right? Now if I type <code>#check λ (α β : Type) (b : β) (x : α), x</code> (notice the asterisk is gone), then it makes alpha and beta both have type <code>Type</code> ?</p>",
        "id": 267316585,
        "sender_full_name": "ccn",
        "timestamp": 1641676807
    },
    {
        "content": "<p>Yeap, and you can do things like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">χ</span> <span class=\"c1\">-- χ : Type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">χ</span> <span class=\"bp\">→</span> <span class=\"n\">χ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">foo</span> <span class=\"c1\">-- foo : Π (χ : Type), χ → χ</span>\n</code></pre></div>",
        "id": 267316690,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641676979
    },
    {
        "content": "<p>Yes, also note that <code>Type*</code> actually works in a way such that in the first case alpha and beta are in fact so arbitrary that they are not necessarily in the same type universe as evident by:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">α</span>\n<span class=\"k\">#check</span> <span class=\"n\">β</span>\n</code></pre></div>",
        "id": 267316691,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1641676979
    },
    {
        "content": "<p>Just to give some more context here for why Lean doesn't return the exact universe variables you wrote back at you, in the following example both <code>a</code> and <code>b</code> are in type <code>Type u</code>, but <code>u</code> is a variable here, so when they interact the type may depend on two universe variables <code>u_1 u_2</code>, despite the fact that they both live in <code>Type u</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">constant</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kd\">constant</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"c1\">-- Type (max u_1 u_2)</span>\n</code></pre></div>",
        "id": 267316722,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641677043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267316722\">said</a>:</p>\n<blockquote>\n<p>Just to give some more context here for why Lean doesn't return the exact universe variables you wrote back at you, in the following example both <code>a</code> and <code>b</code> are in type <code>Type u</code>, but <code>u</code> is a variable here, so when they interact the type may depend on two universe variables <code>u_1 u_2</code>, despite the fact that they both live in <code>Type u</code></p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">constant</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kd\">constant</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"c1\">-- Type (max u_1 u_2)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is <code>a → b</code> the same thing as <code>f: a → b</code> ?</p>",
        "id": 267316870,
        "sender_full_name": "ccn",
        "timestamp": 1641677239
    },
    {
        "content": "<p>It is the type of all possible functions from alpha to beta</p>",
        "id": 267316949,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641677382
    },
    {
        "content": "<p>And <code>f: a -&gt; b</code> would just be one of the possible elements of that set?</p>",
        "id": 267316998,
        "sender_full_name": "ccn",
        "timestamp": 1641677412
    },
    {
        "content": "<p>Yeah exactly</p>",
        "id": 267317003,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641677424
    },
    {
        "content": "<p>I know it's not sets now though right? How could I rephrase my question I just asked in terms of type theory</p>",
        "id": 267317004,
        "sender_full_name": "ccn",
        "timestamp": 1641677434
    },
    {
        "content": "<p>Maybe \"one possible term of that type\"</p>",
        "id": 267317027,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641677502
    },
    {
        "content": "<p>Right, but its not a bad mental model to start with.<br>\nYou can still use the terminology elements of a type, some people say terms of a type, but elements is totally fine</p>",
        "id": 267317030,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641677504
    },
    {
        "content": "<p>Ok thanks for explaining that</p>",
        "id": 267317080,
        "sender_full_name": "ccn",
        "timestamp": 1641677534
    },
    {
        "content": "<p>I just tried out <code>#check λ (α β γ : Type*) (g : β → γ) (f : α → β) (x : α), g (f x)</code> in a  lean file, the infoview says this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n</code></pre></div>\n<p>What does the part after the Π mean?</p>",
        "id": 267317086,
        "sender_full_name": "ccn",
        "timestamp": 1641677556
    },
    {
        "content": "<p>I think that <code>λ (α : Type u_1) (β : Type u_2) (γ : Type u_3) (g : β → γ) (f : α → β) (x : α), g (f x)</code> describes a function which takes in <code>alpha</code> of type <code>u_</code>,  <code>beta</code> of type <code>u_2</code>, <code>gamma</code> of type <code>u_3</code> two functions and x, and outputs the composition</p>",
        "id": 267317113,
        "sender_full_name": "ccn",
        "timestamp": 1641677628
    },
    {
        "content": "<p>Have you learned what the capital pi means in general yet? If not you can keep going until you do and try to ignore it for now, it's on of the fundamental concepts of dependent type theory.</p>",
        "id": 267317184,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1641677735
    },
    {
        "content": "<p>Maybe this book can help you with these questions: <a href=\"https://homotopytypetheory.org/book/\">https://homotopytypetheory.org/book/</a><br>\nIt certainly helped me (and still does)</p>\n<p>And you don't need to go super super deep into it. The chapter 1 is highly insightful already</p>",
        "id": 267317185,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641677742
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> is also a good reference here <a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types\">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types</a></p>",
        "id": 267317257,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641677794
    },
    {
        "content": "<p>These videos are very good too:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=TeY5niDR8yE\">https://www.youtube.com/watch?v=TeY5niDR8yE</a><div class=\"youtube-video message_inline_image\"><a data-id=\"TeY5niDR8yE\" href=\"https://www.youtube.com/watch?v=TeY5niDR8yE\"><img src=\"https://uploads.zulipusercontent.net/100b1ba69a7c5cb668e0dd4708270dc32f852b2f/68747470733a2f2f692e7974696d672e636f6d2f76692f546559356e6944523879452f64656661756c742e6a7067\"></a></div></li>\n<li><a href=\"https://www.youtube.com/watch?v=9cR2Day-4Bk\">https://www.youtube.com/watch?v=9cR2Day-4Bk</a><div class=\"youtube-video message_inline_image\"><a data-id=\"9cR2Day-4Bk\" href=\"https://www.youtube.com/watch?v=9cR2Day-4Bk\"><img src=\"https://uploads.zulipusercontent.net/7716d13534969edec01f9a92b9a7d413c36ce769/68747470733a2f2f692e7974696d672e636f6d2f76692f396352324461792d34426b2f64656661756c742e6a7067\"></a></div></li>\n</ul>",
        "id": 267317426,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641678029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267317257\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> is also a good reference here <a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types\">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types</a></p>\n</blockquote>\n<p>I'm in section 2.3 rn, I guess I'll get there soon</p>",
        "id": 267317438,
        "sender_full_name": "ccn",
        "timestamp": 1641678065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267317426\">said</a>:</p>\n<blockquote>\n<p>These videos are very good too:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=TeY5niDR8yE\">https://www.youtube.com/watch?v=TeY5niDR8yE</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=9cR2Day-4Bk\">https://www.youtube.com/watch?v=9cR2Day-4Bk</a></li>\n</ul>\n</blockquote>\n<p>checking it out</p>",
        "id": 267317446,
        "sender_full_name": "ccn",
        "timestamp": 1641678088
    },
    {
        "content": "<p>Ok, so I'm trying to figure out why bar doesn't work whereas foo does work: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span>  <span class=\"k\">in</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">nat</span>\n</code></pre></div>",
        "id": 267327847,
        "sender_full_name": "ccn",
        "timestamp": 1641692165
    },
    {
        "content": "<p>I think it has to do with the order of how things are evaluated.</p>\n<p>Would it be correct to say that bar doesn't work because first lean looks at <code>(λ a, λ x : a, x + 2)</code> but that doesn't make sense because we don't know what <code>x</code> is? in the case for foo, I think they must \"sub\" the <code>nat</code> in before it does the type check?</p>",
        "id": 267327896,
        "sender_full_name": "ccn",
        "timestamp": 1641692252
    },
    {
        "content": "<p>You'd have to be able to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar'</span> <span class=\"n\">nat</span>\n</code></pre></div>\n<p>Notice that <code>bar'</code> breaks for the same reason. Maybe this way you can understand it better</p>",
        "id": 267328420,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641692858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267328420\">said</a>:</p>\n<blockquote>\n<p>You'd have to be able to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar'</span> <span class=\"n\">nat</span>\n</code></pre></div>\n<p>Notice that <code>bar'</code> breaks for the same reason. Maybe this way you can understand it better</p>\n</blockquote>\n<p>So that one is breaking because it doesn't know what type x has right?</p>",
        "id": 267328556,
        "sender_full_name": "ccn",
        "timestamp": 1641692968
    },
    {
        "content": "<p>Wait nvm it doesn't know what a is</p>",
        "id": 267328751,
        "sender_full_name": "ccn",
        "timestamp": 1641693139
    },
    {
        "content": "<p>Ok, so I think it's a problem because it can't infer what type a should be</p>",
        "id": 267329981,
        "sender_full_name": "ccn",
        "timestamp": 1641694751
    },
    {
        "content": "<p>The problem is that Lean can't just assume that addition is available for <code>x</code>. That is, Lean can't assure that addition is defined for type <code>a</code></p>",
        "id": 267331122,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641696284
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar'</span> <span class=\"c1\">-- bar' : ?M_1 → ?M_1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar'</span> <span class=\"mi\">3</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar</span> <span class=\"c1\">-- bar : ℕ (Lean inferred ℕ because I applied bar' to 3)</span>\n</code></pre></div>",
        "id": 267331713,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641697125
    },
    {
        "content": "<p>And this is a bit exotic, but is more aligned with what you tried to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">a</span><span class=\"o\">],</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">tactic.unfreeze_local_instances</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar'</span> <span class=\"n\">nat</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar</span> <span class=\"c1\">-- bar : ℕ → ℕ</span>\n</code></pre></div>",
        "id": 267332207,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641697781
    },
    {
        "content": "<p>If someone knows how to tell lean to use <code>_inst_1: has_add a</code> and <code>_inst_2: has_one a</code> directly (without relying on <code>tactic.unfreeze_local_instances</code>), please let us know <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 267332279,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641697872
    },
    {
        "content": "<p>It's still tactic mode, but the usual way is <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#exactI\">tactic#exactI</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">a</span><span class=\"o\">],</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar'</span> <span class=\"n\">nat</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar</span> <span class=\"c1\">-- bar : ℕ → ℕ</span>\n</code></pre></div>",
        "id": 267332398,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641698095
    },
    {
        "content": "<p>Much better!</p>",
        "id": 267332440,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641698162
    },
    {
        "content": "<p>(I'd never looked at the definition of <code>exactI</code> until now. It just does <code>tactic.unfreeze_local_instances</code> then <code>tactic.freeze_local_instances</code> for you before doing <code>exact</code>, so it's essentially equivalent to what you'd written, but fewer keystrokes.)</p>",
        "id": 267332550,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641698291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"367659\">@ccn</span> One thing about the original question that no one seems to have pointed out is that when you write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">constant</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>you are really defining a parametric family of constants, denoted <code>a.{u}</code>. It's not like <code>a</code> exists in some particular universe <code>u</code>, rather there is a different <code>a</code> at each universe: <code>a.{0} : Type 0</code>, <code>a.{1} : Type 1</code> and so on. This is the same way that the <code>variables</code> command works: every definition is implicitly universally quantified over <code>variable</code> declarations in scope, and when you use the definition later you can supply different values for the variables.</p>\n<p>Universe parameters are usually implicit, so when you write <code>#check a</code> what it really means is <code>#check a.{_}</code>. Lean has to pick some universe variable to fill the <code>_</code>, and it makes up <code>u_1</code> as a universe variable name. So the output is saying <code>a.{u_1} : Type u_1</code>, although the <code>.{u_1}</code> part is hidden unless you set <code>set_option pp.universes true</code>.</p>",
        "id": 267338921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641708545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267317257\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> is also a good reference here <a href=\"https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types\">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#dependent-types</a></p>\n</blockquote>\n<p>I guess this is the relevant part?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">This</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"k\">Pi</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">or</span> <span class=\"n\">dependent</span> <span class=\"n\">function</span> <span class=\"n\">type.</span> <span class=\"n\">Given</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">and</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">think</span> <span class=\"n\">of</span> <span class=\"n\">β</span> <span class=\"n\">as</span> <span class=\"n\">a</span> <span class=\"n\">family</span> <span class=\"n\">of</span> <span class=\"n\">types</span> <span class=\"n\">over</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">that</span> <span class=\"n\">is</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">type</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"n\">for</span> <span class=\"n\">each</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α.</span> <span class=\"n\">In</span> <span class=\"n\">that</span> <span class=\"n\">case</span><span class=\"o\">,</span> <span class=\"n\">the</span> <span class=\"n\">type</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"n\">denotes</span> <span class=\"n\">the</span> <span class=\"n\">type</span> <span class=\"n\">of</span> <span class=\"n\">functions</span> <span class=\"n\">f</span> <span class=\"k\">with</span> <span class=\"n\">the</span> <span class=\"n\">property</span> <span class=\"n\">that</span><span class=\"o\">,</span> <span class=\"n\">for</span> <span class=\"n\">each</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"n\">element</span> <span class=\"n\">of</span> <span class=\"n\">β</span> <span class=\"n\">a.</span> <span class=\"n\">In</span> <span class=\"n\">other</span> <span class=\"n\">words</span><span class=\"o\">,</span> <span class=\"n\">the</span> <span class=\"n\">type</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">value</span> <span class=\"n\">returned</span> <span class=\"kd\">by</span> <span class=\"n\">f</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"n\">its</span> <span class=\"n\">input.</span>\n</code></pre></div>",
        "id": 267368306,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1641749611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267331713\">said</a>:</p>\n<blockquote>\n<p>This works:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar'</span> <span class=\"c1\">-- bar' : ?M_1 → ?M_1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">bar'</span> <span class=\"mi\">3</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar</span> <span class=\"c1\">-- bar : ℕ (Lean inferred ℕ because I applied bar' to 3)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>what does <code>has_one</code> mean here? Is it connected to the one in the type of it? <code>bar' : ?M_1 → ?M_1</code>, what do those question marks mean?</p>",
        "id": 267370587,
        "sender_full_name": "ccn",
        "timestamp": 1641752705
    },
    {
        "content": "<p><code>has_one</code> is a typeclass, its what lets us type <code>1 : a</code> and have lean know what that means, nat already has a <code>has_one</code> typeclass built in so you don't notice it. Given <code>has_one</code> and <code>has_add</code> lean knows what 2 and 3, etc. mean for a given type</p>",
        "id": 267370729,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641752891
    },
    {
        "content": "<p>The questionmarked variables are metavariables</p>",
        "id": 267370739,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1641752916
    },
    {
        "content": "<p>Yeah, you can read <code>bar' : ?M_1 → ?M_1</code> as \"<code>bar'</code> is a function that, given a term of a type, returns a term of that same type, whatever that type is\"</p>\n<p>And Lean differentiates \"whatever types\" by saying <code>?M_1</code>, <code>?M_2</code>...</p>",
        "id": 267371026,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641753348
    },
    {
        "content": "<p>Ok, so I'm trying to get this into my head, so if I have <code>Π x : α, β</code> this represents  <code>α → β</code> which is the type of functions from alpha to beta. </p>\n<p>When we have something like this: <code>Π x : α, β x</code> then what it saying is that this is the type of functions so where for any such function f and element a in α, then f a is an element of β a.</p>\n<p>So if α consists of the points a_0, a_1, a_2, ... then <code>Π x : α, β x</code> is the type of functions  <code>α→ Union over a_i β a_i</code> ?</p>",
        "id": 267372156,
        "sender_full_name": "ccn",
        "timestamp": 1641754869
    },
    {
        "content": "<p>You could think of them as functions of that type such that for each input <code>i</code>, the output value belongs to <code>β i</code></p>",
        "id": 267372260,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641755032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267372260\">said</a>:</p>\n<blockquote>\n<p>You could think of them as functions of that type such that for each input <code>i</code>, the output value belongs to <code>β i</code></p>\n</blockquote>\n<p>So it means that the co-domain of any one of those functions  has to at least contain { β i :  i in α}, but could be a super set of that?</p>",
        "id": 267372343,
        "sender_full_name": "ccn",
        "timestamp": 1641755139
    },
    {
        "content": "<p>Well, now you're mixing type theory and set theory terminology in a way that's probably making things more confusing</p>",
        "id": 267372407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641755209
    },
    {
        "content": "<p>A dependent function in type theory doesn't really have <strong>a</strong> codomain because the result type depends on the input value</p>",
        "id": 267372448,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641755279
    },
    {
        "content": "<p>so maybe it is best to just avoid this language</p>",
        "id": 267372489,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641755290
    },
    {
        "content": "<p>Ok I will. I watched this video: <a href=\"https://youtu.be/TeY5niDR8yE?t=757\">https://youtu.be/TeY5niDR8yE?t=757</a> so is it ok to think about types as space and then the terms of a type as the points of the space?</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"TeY5niDR8yE\" href=\"https://youtu.be/TeY5niDR8yE?t=757\"><img src=\"https://uploads.zulipusercontent.net/100b1ba69a7c5cb668e0dd4708270dc32f852b2f/68747470733a2f2f692e7974696d672e636f6d2f76692f546559356e6944523879452f64656661756c742e6a7067\"></a></div>",
        "id": 267372523,
        "sender_full_name": "ccn",
        "timestamp": 1641755372
    },
    {
        "content": "<p>This is from TPIL</p>\n<blockquote>\n<p>Suppose we wish to write a function cons which inserts a new element at the head of a list. What type should cons have? Such a function is polymorphic: we expect the cons function for ℕ, bool, or an arbitrary type α to behave the same way. So it makes sense to take the type to be the first argument to cons, so that for any type, α, cons α is the insertion function for lists of type α. In other words, for every α, cons α is the function that takes an element a : α and a list l : list α, and returns a new list, so we have cons α a l : list α.</p>\n<p>It is clear that cons α should have type α → list α → list α. But what type should cons have? A first guess might be Type → α → list α → list α, but, on reflection, this does not make sense: the α in this expression does not refer to anything, whereas it should refer to the argument of type Type. In other words, assuming α : Type is the first argument to the function, the type of the next two elements are α and list α. These types vary depending on the first argument, α.</p>\n</blockquote>\n<p>Couldn't cons be of the the type <code>Type -&gt; type Type -&gt; list Type -&gt; list Type</code> ?</p>",
        "id": 267372726,
        "sender_full_name": "ccn",
        "timestamp": 1641755661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">ccn</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267372523\">said</a>:</p>\n<blockquote>\n<p>is it ok to think about types as space and then the terms of a type as the points of the space?</p>\n</blockquote>\n<p>You can, although in Lean the \"spaces\" are more specifically discrete spaces, i.e., just sets.</p>",
        "id": 267372907,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641755890
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"367659\">@ccn</span>  Reid's right that there's not really a codomain, but you can transform dependent functions into non-dependent ones by creating \"the\" codomain using a sigma type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_total</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Using the space analogy, this sigma type is the total space of a fiber bundle, where above each <code>y</code> lies the fiber <code>β y</code>. Then the original <code>f</code> here \"is\" a section of this fiber bundle.</p>",
        "id": 267372912,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641755898
    },
    {
        "content": "<p>(The sigma type is basically a disjoint union.)</p>",
        "id": 267372945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641755994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">ccn</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267372523\">said</a>:</p>\n<blockquote>\n<p>Ok I will. I watched this video. so is it ok to think about types as space and then the terms of a type as the points of the space?</p>\n</blockquote>\n<p>Watching video about some foundations they are related to the foundations used by Lean but different will very likely bring you a <em>lot</em> of confusion.</p>",
        "id": 267373774,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1641757181
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">variable</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>            <span class=\"c1\">-- (a, b) : α × β a</span>\n<span class=\"k\">#check</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>      <span class=\"c1\">-- Σ (a : α), β a</span>\n</code></pre></div>\n<p>I'm having some trouble differentiating these two objects, can anyone enlighten me?</p>",
        "id": 267374451,
        "sender_full_name": "ccn",
        "timestamp": 1641758149
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"367659\">@ccn</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span>\n<span class=\"kd\">variable</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a'</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>            <span class=\"c1\">-- (a, b) : α × β a</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>           <span class=\"c1\">-- (a', b) : α × β a</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span>      <span class=\"c1\">-- Σ (a : α), β a</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">sigma.mk</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span>    <span class=\"c1\">-- Σ (a : α), β a</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span>     <span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>The first are non-dependent pairs, so the second element does not depend on the value of the first. The last example shows that sigmas need the second element to have a type determined by the first element.</p>",
        "id": 267374835,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641758524
    },
    {
        "content": "<p><code>(a, b)</code> is another way of calling the constructor of <code>prod</code>, which is <code>prod.mk</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">variable</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">prod.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>       <span class=\"c1\">-- (a, b) : α × β a</span>\n<span class=\"k\">#check</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>      <span class=\"c1\">-- Σ (a : α), β a</span>\n</code></pre></div>\n<p>They (<code>prod</code> and <code>sigma</code>) are different structures, you can ctrl+click on them to see their definitions</p>",
        "id": 267374870,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641758573
    },
    {
        "content": "<p>In principle, the non-dependent pair (the cartesian product) is a sigma type where the second argument does not depend on the first argument, in exactly the same way that the function arrow is a pi type.  However, in Lean <code>prod</code> and <code>sigma</code> are actually different so this is only an analogy.</p>",
        "id": 267374896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641758606
    },
    {
        "content": "<p>Products could have been defined this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myprod</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span>\n</code></pre></div>",
        "id": 267374955,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641758648
    },
    {
        "content": "<p>Ok, so is <code>prod.mk</code>a dependent type too, since you can pass in a second argument which depends on the first?</p>",
        "id": 267375168,
        "sender_full_name": "ccn",
        "timestamp": 1641758879
    },
    {
        "content": "<p><code>prod.mk</code> is a term, not a type</p>",
        "id": 267375213,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641758897
    },
    {
        "content": "<p>Should I have said the type of the term produced by <code>prod.mk a b</code>?</p>",
        "id": 267375234,
        "sender_full_name": "ccn",
        "timestamp": 1641758931
    },
    {
        "content": "<p><code>prod.mk</code> <strong>is</strong> a dependent function</p>",
        "id": 267375327,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641759036
    },
    {
        "content": "<p>Tada:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">prod.mk</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">prod.mk : Π {α : Type u_4} {β : Type u_5}, α → β → α × β</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>It's dependent in a very weak way (it's the kind of dependent function that Haskell 98 has, which is type polymorphism).</p>",
        "id": 267375471,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641759212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">ccn</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267375234\">said</a>:</p>\n<blockquote>\n<p>Should I have said the type of the term produced by <code>prod.mk a b</code>?</p>\n</blockquote>\n<p>Probably not, since the type of the term produced by <code>prod.mk a b</code> doesn't depend on anything. (Assuming that <code>a</code> and <code>b</code> are some fixed terms.) Also, the second argument does not depend on the first -- notice that the type of <code>prod.mk</code> has independent types <code>α</code> and <code>β</code> for its two explicit arguments.</p>",
        "id": 267375561,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641759333
    },
    {
        "content": "<p>(What I was trying to point out with <code>#check (a', b)</code> earlier is how <code>#check (a, b)</code> is misleading.)</p>",
        "id": 267375743,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641759558
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ident</span>      <span class=\"c1\">-- ?M_1 → ?M_1</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"n\">a</span>    <span class=\"c1\">-- α</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"n\">b</span>    <span class=\"c1\">-- β</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ident_v2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ident_v2</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident_v2</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>Why does <code>ident_v2 a</code> cause this problem: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">ident_v2</span> <span class=\"n\">a</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">a</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Shouldn't it be ok since <code>a</code> is of the type <code>α</code>?</p>",
        "id": 267376149,
        "sender_full_name": "ccn",
        "timestamp": 1641760099
    },
    {
        "content": "<p>What was the output of <code>#check ident_v2</code>?</p>",
        "id": 267376484,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641760564
    },
    {
        "content": "<p>The first parameter that <code>ident_v2</code> expects is the type of the second parameter</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">ident_v2</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"c1\">-- ident_v2 α a : α</span>\n</code></pre></div>\n<p>You can see it here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">ident_v2</span> <span class=\"c1\">-- def ident_v2 : Π (α : Type u), α → α := λ (α : Type u) (x : α), x</span>\n</code></pre></div>",
        "id": 267376490,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1641760575
    },
    {
        "content": "<p>This should fix it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>That way alpha will be an implicit argument.</p>",
        "id": 267376518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641760644
    },
    {
        "content": "<p><code>variables</code> aren't fixed, they turn into extra arguments of definitions. In this case, the argument is explicit because of the way <code>α</code> was declared. So you need to pass it explicitly to use <code>ident_v2</code>.</p>",
        "id": 267376586,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641760698
    },
    {
        "content": "<p>Can anyone provide a concrete example of when a Pi type is used? I'm still having some trouble grasping it. Thanks!</p>",
        "id": 267818203,
        "sender_full_name": "ccn",
        "timestamp": 1642043259
    },
    {
        "content": "<p>Ok, here's an example of one: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">modus_ponens</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"n\">Proof</span> <span class=\"o\">(</span><span class=\"n\">implies</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"n\">Proof</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Proof</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>So would this be the type of functions f where giving the arguments p and q, then then <code>f p q</code> has the type <code> Proof (implies p q) →  Proof p → Proof q</code></p>\n<p>Does it mean pretty much that this is a \"template\" where if you give two propositions, you get a proof of modeus_ponens for those specific <code>Props</code> p and q ?</p>",
        "id": 267818569,
        "sender_full_name": "ccn",
        "timestamp": 1642043570
    },
    {
        "content": "<p>The statement of Fermat's Last Theorem is a pi type.</p>",
        "id": 267835123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1642061120
    },
    {
        "content": "<p>Because the equation depends on the input variables</p>",
        "id": 267835145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1642061145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">ccn</span> <a href=\"#narrow/stream/113489-new-members/topic/Dependent.20Type.20Theory.20Section/near/267818569\">said</a>:</p>\n<blockquote>\n<p>Does it mean pretty much that this is a \"template\" where if you give two propositions, you get a proof of modeus_ponens for those specific <code>Props</code> p and q ?</p>\n</blockquote>\n<p>I'm not sure if thinking about them as \"templates\" is really helpful. <br>\nThe parameters <code>p</code> and <code>q</code> are just \"normal\" parameters, too. The only difference is that all the other parameters (after the comma) are allowed to reference <code>p</code> and <code>q</code>.<br>\nPerhaps this example motivates this better:</p>\n<p><code>array</code> is a type of fixed length arrays (like a list, but with an additional parameter in the type that constrains the size of the array):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">array</span> <span class=\"c1\">--  ℕ → Type u → Type u</span>\n<span class=\"k\">#check</span> <span class=\"n\">array</span> <span class=\"mi\">10</span> <span class=\"n\">nat</span> <span class=\"c1\">-- Type u</span>\n\n<span class=\"c1\">-- for comparison:</span>\n<span class=\"k\">#check</span> <span class=\"n\">list</span> <span class=\"c1\">--  Type u → Type u</span>\n<span class=\"k\">#check</span> <span class=\"n\">list</span> <span class=\"n\">nat</span> <span class=\"c1\">-- Type u</span>\n</code></pre></div>\n<p>Let's say you want to define a function that returns the last item in a given array of integers of length 10:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">array.last</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">array</span> <span class=\"mi\">10</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.read</span> <span class=\"mi\">9</span>\n</code></pre></div>\n<p>Obviously it would would be nice to write this function more generically for all lengths. So we add a parameter <code>n</code> for the length:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">array.last</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">array</span> <span class=\"n\">n</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.read</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"c1\">-- this wouldn't actually work exactly like this, but for the example it's ok</span>\n</code></pre></div>\n<p>This is now a dependent function, as the type of <code>a</code> depends on the value <code>n</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">array.last</span> <span class=\"c1\">-- Π (n : ℕ), array n int → int</span>\n</code></pre></div>\n<p>But as you can see <code>n</code> is still just a regular parameter. In fact, we use it in the body of the function.</p>",
        "id": 267835824,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1642061654
    },
    {
        "content": "<p>(it's irrelevant for the example, but you want <code>a.read (n-1)</code> instead of <code>a.read n-1</code>)</p>",
        "id": 267841814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642065374
    }
]
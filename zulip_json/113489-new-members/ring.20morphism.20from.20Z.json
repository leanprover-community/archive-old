[
    {
        "content": "<p>Hello, </p>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a commutatif ring, there exists an unique morphisme <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">Z</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\"> f : \\mathbb{Z} \\to R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, how   show this fact in lean ?</p>",
        "id": 191415188,
        "sender_full_name": "orlando",
        "timestamp": 1584909859
    },
    {
        "content": "<p>perhaps this is already done !</p>",
        "id": 191415194,
        "sender_full_name": "orlando",
        "timestamp": 1584909882
    },
    {
        "content": "<p>It's called <code>int.cast</code>.</p>",
        "id": 191415694,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584910630
    },
    {
        "content": "<p>oh nice, there is a theorem  \" eq_cast \" i thinck it's ok ! Thx !</p>",
        "id": 191415868,
        "sender_full_name": "orlando",
        "timestamp": 1584910825
    },
    {
        "content": "<p>Yeaaaaaaaaaaaah !!!    <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">CommRing</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">types</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kn\">open</span> <span class=\"n\">CommRing</span>\n<span class=\"kn\">open</span> <span class=\"n\">is_ring_hom</span>\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n<span class=\"kn\">open</span> <span class=\"n\">int</span>\n<span class=\"kn\">variables</span><span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">](</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n<span class=\"kn\">structure</span> <span class=\"n\">V</span>  <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>      <span class=\"c1\">-- set of solution of P(x) = 0  with x in R</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>                                     <span class=\"c1\">-- if φ : R → R&#39; is a ring morphism then we have application</span>\n<span class=\"o\">(</span><span class=\"n\">certif</span> <span class=\"o\">:</span> <span class=\"n\">eval₂</span><span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">)</span>     <span class=\"c1\">--  φ : V(P)(R) → V(P(R&#39;)</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">ζ1</span> <span class=\"n\">ζ2</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"n\">R</span><span class=\"o\">},</span> <span class=\"n\">ζ1</span><span class=\"bp\">.</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ζ2</span><span class=\"bp\">.</span><span class=\"n\">x</span> <span class=\"bp\">→</span>  <span class=\"n\">ζ1</span> <span class=\"bp\">=</span> <span class=\"n\">ζ2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ζ1</span> <span class=\"n\">ζ2</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ζ1</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ζ2</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">congr</span> <span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n<span class=\"kn\">definition</span> <span class=\"n\">map_V</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R&#39;</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R&#39;</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">P</span> <span class=\"n\">R&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ζ</span><span class=\"o\">,</span><span class=\"k\">begin</span>\n<span class=\"n\">exact</span>  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">ζ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">certif</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">eval₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ζ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">eval₂</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">ζ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">P</span><span class=\"o\">),</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span>  <span class=\"n\">hom_eval₂</span>  <span class=\"n\">P</span>  <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">f</span> <span class=\"n\">ζ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"bp\">=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">eq_cast&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">G</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">cer</span> <span class=\"o\">:</span> <span class=\"n\">eval₂</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">ζ</span><span class=\"bp\">.</span><span class=\"n\">x</span> <span class=\"n\">P</span> <span class=\"bp\">=</span><span class=\"mi\">0</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">ζ</span><span class=\"bp\">.</span><span class=\"n\">certif</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">cer</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">map_zero</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span><span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 191419171,
        "sender_full_name": "orlando",
        "timestamp": 1584915452
    },
    {
        "content": "<p>When I had just started Lean, <code>polynomial</code> wasn't there! I had to get an undergraduate to make it ;-)</p>",
        "id": 191419423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584915832
    },
    {
        "content": "<p>Kevin, it's very hard to use :  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><msub><mi>l</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant=\"normal\">.</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> eval_2 (int.cast) (x) (P) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">a</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mord\">.</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">t</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> , for us it's just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\"> P(x) = 0 </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">x \\in R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span> !!!</p>",
        "id": 191419649,
        "sender_full_name": "orlando",
        "timestamp": 1584916151
    },
    {
        "content": "<p>This is called \"learning the interface\". The most important thing to understand is: \"if it is a standard fact, it will be there\".</p>",
        "id": 191420109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584916829
    },
    {
        "content": "<p>I wanted to learn the interface for polynomials in more than one variable recently, because I was formalising <a href=\"https://github.com/ImperialCollegeLondon/M4P33\" target=\"_blank\" title=\"https://github.com/ImperialCollegeLondon/M4P33\">basic algebraic geometry</a> (I just finished teaching an undergraduate alg geom course at my university). So I read <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/mv_polynomial.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/mv_polynomial.lean\">data.mv_polynomial</a> and then I wrote the docstring which you can see in the first 90 lines. I didn't do that for <code>polynomial.lean</code> yet so it was probably harder work for you to find the theorems.</p>",
        "id": 191420185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584916971
    },
    {
        "content": "<p>I agree that formalising is much harder work than mathematics on paper. The idea is that if we make a really good interface then it will not be so painful. I would imagine that there is already a coercion from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span> but I don't think that there is a rule that says that if there is a coercion from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> then there is also a coercion from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">B[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span>. If this was added then it might make the code look nicer, but then a computer scientist might come along and say that this is a bad coercion because of some computer science reason involving type class search.</p>",
        "id": 191420352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917196
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n</pre></div>\n\n\n<p>This works, so integers can be regarded as elements of a commutative ring. If you look at what happened, it actually defined the term to be <code>↑n</code></p>",
        "id": 191420391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917262
    },
    {
        "content": "<p><code>example (R : Type*) [comm_ring R] (p : polynomial ℤ) : polynomial R := p</code> -- this fails, and so does <code>:= ↑p</code></p>",
        "id": 191420447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917321
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 191420535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917467
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"err\">↑</span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_lift_t</span> <span class=\"bp\">ℤ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"kn\">eval</span> <span class=\"n\">r</span> <span class=\"n\">p</span>\n</pre></div>\n\n\n<p>There -- now it is just <code>eval</code> and you could set up notation for <code>eval</code> so that it becomes some kind of <code>p(r)</code>, although probably you would have to use some funky brackets</p>",
        "id": 191420702,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917696
    },
    {
        "content": "<p>Yes i use 'map' </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"o\">)</span> <span class=\"n\">p</span>\n</pre></div>\n\n\n<p>But non computable (i don't know if it's a problem ?)</p>",
        "id": 191420705,
        "sender_full_name": "orlando",
        "timestamp": 1584917698
    },
    {
        "content": "<p>It's not a problem</p>",
        "id": 191420709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917710
    },
    {
        "content": "<p>It's a problem for some people, but not for mathematicians</p>",
        "id": 191420715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917726
    },
    {
        "content": "<p>It's probably something to do with the fact that you can't tell if a coefficient is zero or not if there is no algorithm for deciding equality between two elements of R or something.</p>",
        "id": 191420777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917800
    },
    {
        "content": "<p>For example there is no algorithm which tells you if two real numbers are equal: you cannot just tell a computer to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></msub><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><msup><mi>π</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">\\sum_{n\\geq1}1/n^2=\\pi^2/6</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.208997em;vertical-align:-0.39488900000000005em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139799999999992em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.39488900000000005em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\">6</span></span></span></span>. All it can do is to check it to 10000 decimal places</p>",
        "id": 191420795,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917852
    },
    {
        "content": "<p>And because you don't care about this, you don't care that your example is noncomputable</p>",
        "id": 191420840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917885
    },
    {
        "content": "<p>okay !</p>",
        "id": 191420843,
        "sender_full_name": "orlando",
        "timestamp": 1584917909
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">notation</span> <span class=\"n\">p</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">`</span> <span class=\"n\">r</span> <span class=\"bp\">`</span><span class=\"o\">)</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"kn\">eval</span> <span class=\"n\">r</span> <span class=\"n\">p</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 191420854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584917937
    },
    {
        "content": "<p>I suspect that this is really bad notation for all sorts of reasons :-)</p>",
        "id": 191420991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918015
    },
    {
        "content": "<p>but what I am showing you is that if you don't like the interface then there are always possibilities to make it better, either by adding more theorems or adding more notation.</p>",
        "id": 191421024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270476\">orlando</span> <a href=\"#narrow/stream/113489-new-members/topic/ring.20morphism.20from.20Z/near/191420705\" title=\"#narrow/stream/113489-new-members/topic/ring.20morphism.20from.20Z/near/191420705\">said</a>:</p>\n<blockquote>\n<p>Yes i use 'map' </p>\n</blockquote>\n<p>I used <code>map</code> too, but I buried it in <code>instance (R : Type*) [comm_ring R] : has_coe (polynomial ℤ) (polynomial R) :=\n⟨polynomial.map (coe : ℤ → R)⟩</code></p>",
        "id": 191421102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918129
    },
    {
        "content": "<p>and also</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>\n\n\n<p>I used a map which was the same as yours by definition (not just a theorem that they are the same, they are the same by definition). So our definitions of evaluation are the same.</p>",
        "id": 191421174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918258
    },
    {
        "content": "<p><code>example : (λ n, ↑n : ℤ → R) = (int.cast : ℤ → R) := rfl</code></p>",
        "id": 191421192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918314
    },
    {
        "content": "<p>When you are in this situation, when there are several ways of saying the exact same thing, you have to decide on a \"canonical\" way! I believe that the canonical way is <code>↑n</code> here (which is just notation for <code>coe</code>). What do I mean by this? I mean that when you prove 100 lemmas about this map, you have to decide exactly how to phrase them (for example you want to prove that this map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}\\to R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span></span></span></span> sends products to products, and you have to decide how to say this). The rule is that you state everything using the canonical notation, and then you teach the simplifier all the theorems expressed using the canonical notation, and then the simplifier hopefully works well.</p>",
        "id": 191421280,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918482
    },
    {
        "content": "<p>You can see in <code>data.int.basic</code> straight after the definition of <code>int.cast</code> they define the coercion:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- Canonical homomorphism from the integers to any ring(-like) structure `α` -/</span>\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">cast</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">priority</span> <span class=\"mi\">10</span><span class=\"o\">]</span> <span class=\"kn\">instance</span> <span class=\"n\">cast_coe</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"bp\">ℤ</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>and if you import data.int.basic and do stuff like <code>#check int.cast_one</code> or <code>#check int.cast_add</code>, all these results are stated using <code>↑</code> notation.</p>",
        "id": 191421410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918667
    },
    {
        "content": "<p>and if you do things like <code>#print int.cast_add</code> you can see they are all tagged with <code>simp</code>. This is how the simplifier learns to use this stuff. But it means that it's important to stick with the canonical choice if you want to maximise your use of the simplifier.</p>",
        "id": 191421459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584918725
    }
]
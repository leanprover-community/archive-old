[
    {
        "content": "<p>I am trying to prove a lemma of the following form.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.cover</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.simple_module</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">covby_iff_simple_order_Icc</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⋖</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">Icc.bounded_order</span> <span class=\"n\">hxy</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">is_simple_order</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">covby_iff_lt_and_eq_or_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hxy</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"o\">{</span>\n    <span class=\"n\">use</span> <span class=\"n\">hxy.le</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">le_refl</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxy.le</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"k\">let</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hxy.le</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span> <span class=\"n\">y</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">Icc.bounded_order</span> <span class=\"n\">hxy.le</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span> <span class=\"n\">x'</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hy'</span> <span class=\"o\">:</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span> <span class=\"n\">y'</span><span class=\"o\">,</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"bp\">⊥</span><span class=\"o\">,</span> <span class=\"bp\">⊤</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hxy.ne</span> <span class=\"o\">(</span><span class=\"n\">subtype.mk_eq_mk.mp</span> <span class=\"n\">i</span><span class=\"o\">)⟩⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">hz</span><span class=\"o\">⟩,</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"n\">hz.1</span> <span class=\"n\">hz.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"kd\">begin</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx'</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"kd\">begin</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hy'</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span> <span class=\"o\">⟩,</span>\n  <span class=\"o\">},</span> <span class=\"o\">{</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">Icc.bounded_order</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">le_refl</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxy</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"k\">let</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hxy</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span> <span class=\"n\">y</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span> <span class=\"n\">x'</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hy'</span> <span class=\"o\">:</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span> <span class=\"n\">y'</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n      <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_ne</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">x'</span> <span class=\"bp\">≠</span> <span class=\"n\">y'</span> <span class=\"o\">:=</span> <span class=\"n\">bot_ne_top</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">hxy</span><span class=\"o\">],</span>\n    <span class=\"o\">},</span> <span class=\"o\">{</span>\n      <span class=\"n\">intros</span> <span class=\"n\">z</span> <span class=\"n\">hxz</span> <span class=\"n\">hzy</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">eq_bot_or_eq_top</span> <span class=\"o\">(⟨</span><span class=\"n\">z</span><span class=\"o\">,⟨</span><span class=\"n\">hxz</span><span class=\"o\">,</span><span class=\"n\">hzy</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n        <span class=\"n\">left</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">subtype.mk.inj</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span> <span class=\"o\">{</span>\n        <span class=\"n\">right</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">subtype.mk.inj</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Besides the usual question of whether this is already in mathlib (<code>#print instances is_simple_order</code> gives no results), I wonder how to properly deal with the typeclasses in the theorem statement. It feels incorrect to go into tactics mode like this. Similarly, in the proof I need to construct the same typeclass instance. It forces me to duplicate the <code>x'</code> and <code>hx'</code> statements. Could you give me some style hints.</p>",
        "id": 307341623,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667317509
    },
    {
        "content": "<p><code>#print instances</code> will only check the current environment, so unless you have <code>import all</code> (using <code>leanproject mk-all</code>) you won't find all of them.<br>\nFortunately there is an easier way to find all instances: on the website: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_simple_order\">docs#is_simple_order</a> you can click the arrow to show \"instances of this typeclass\"</p>",
        "id": 307348616,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667319511
    },
    {
        "content": "<p>It seems I was lucky, and my <code>#print instances</code> returned the same list as the docs. The question remains what the <del>pythonic</del> leanic way is to state this lemma.</p>",
        "id": 307351210,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667320158
    },
    {
        "content": "<p>One way to improve the statement would be if we refactor <code>is_simple_order α</code> to mean <code>nat.card α = 2</code>.</p>",
        "id": 307361343,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667322833
    },
    {
        "content": "<p>My short answer is: \"don't\". The reason it's a bit weird is that <code>bounded_order</code> is a data-carrying class (the data are <code>⊤ ⊥ : Icc x y</code>), whereas <code>x ⋖ y</code> is a <code>Prop</code>. This is the reason you must have an existential.</p>\n<p>But if you must you can make the statement without tactic mode by providing the terms directly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">covby_iff_simple_order_Icc'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⋖</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_simple_order</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Icc.bounded_order</span> <span class=\"n\">hxy</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>However, I would instead suggest creating the following instance and lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">Icc.is_simple_order</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⋖</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_simple_order</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Icc.bounded_order</span> <span class=\"n\">h.le</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">covby_of_Icc_is_simple_order</span> <span class=\"o\">[</span><span class=\"n\">bounded_order</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">is_simple_order</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⋖</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 307361446,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1667322852
    },
    {
        "content": "<p>Lemmas about simple orders can still assume that <code>bounded_order</code> is present, but the defn wouldn't need it.</p>",
        "id": 307361478,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667322863
    },
    {
        "content": "<p>I know the context for this and my answer is: don't</p>",
        "id": 307379335,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667327899
    },
    {
        "content": "<p>The blueprint I gave you carefully dodges trap statements like this one</p>",
        "id": 307379481,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667327949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Nevertheless, what do you think of making <code>is_simple_order</code> a synonym for <code>nat.card X = 2</code>?</p>",
        "id": 307380621,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667328304
    },
    {
        "content": "<p>It seems a bit weird to use <code>is_simple_order</code> as the name if we define it without reference to orders</p>",
        "id": 307383994,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667329417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, that's wrong. For example, <code>bool</code> with the discrete order (<code>tt</code> and <code>ff</code> are incomparable) is <em>not</em> a simple order.</p>",
        "id": 307385903,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667330130
    },
    {
        "content": "<p>To be fair, the docstring of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_simple_order\">docs#is_simple_order</a> is misleading.</p>",
        "id": 307386103,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667330187
    },
    {
        "content": "<p>I don't know much about order theory...</p>",
        "id": 307386195,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667330232
    },
    {
        "content": "<p>Using the word \"simple\" seems strange to me in this case.</p>",
        "id": 307386280,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1667330269
    },
    {
        "content": "<p>Technically, the current definition is wrong too...</p>",
        "id": 307386394,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667330298
    },
    {
        "content": "<p>According to its definition, we could have a preorder where both <code>⊥</code> and <code>⊤</code> are less than each other (indistinguishable).</p>",
        "id": 307386567,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667330353
    },
    {
        "content": "<p>Does this notion agree with <a href=\"https://ncatlab.org/nlab/show/simple+object\">nlab#simple+object</a> ?</p>",
        "id": 307386729,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1667330404
    },
    {
        "content": "<p>I would need to think it through. I think the correct interpretation for it would be in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Lattice\">docs#Lattice</a></p>",
        "id": 307386979,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667330498
    },
    {
        "content": "<p>I guess if you have a simple object <code>X</code> then its lattice of quotients will be \"simple\" with this definition. But I don't know if that means the lattice itself is simple!</p>",
        "id": 307387200,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1667330573
    },
    {
        "content": "<p>I'm confused.</p>",
        "id": 307387205,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1667330576
    },
    {
        "content": "<p>Hello confused, I'm confused too!</p>",
        "id": 307387594,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667330707
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_simple_module\">docs#is_simple_module</a> unfolds to <code>is_simple_order</code>. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_simple_group\">docs#is_simple_group</a> is definitionally the same as <code>is_simple_order (subgroup G)</code> except for the <code>is_normal</code> condition. I guess it could be defined to be <code>is_simple_order {H : subgroup G // H.is_normal}</code>.</p>",
        "id": 307390862,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1667331860
    },
    {
        "content": "<p>yeah exactly.</p>",
        "id": 307391285,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1667332034
    },
    {
        "content": "<blockquote>\n<p>According to its definition, we could have a preorder where both ⊥ and ⊤ are less than each other (indistinguishable).</p>\n</blockquote>\n<p>Your comment amounts to </p>\n<blockquote>\n<p><code>[preorder T] [bounded_order T] [is_simple_order T]</code> is meaningless, only <code>[partial_order T] [bounded_order T] [is_simple_order T]</code> has mathematical content</p>\n</blockquote>\n<p>right? I don't think redefining <code>is_simple_order</code> in terms of <code>nat.card</code> changes that</p>",
        "id": 307391824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667332211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307386729\">said</a>:</p>\n<blockquote>\n<p>Does this notion agree with <a href=\"https://ncatlab.org/nlab/show/simple+object\">nlab#simple+object</a> ?</p>\n</blockquote>\n<p>I have not checked what the appropriate morphisms are. But in general (aka \"universal\") algebra, we treat categories that usually do not have a zero object, and still we call <em>simple</em> those objects with exactly two \"congruences\" (which is essentially, two quotients).</p>",
        "id": 307400473,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1667335510
    },
    {
        "content": "<p>Yeah that's essentially what I was saying above. The congruences form a lattice (w.r.t. implication, say), and the lattice of congruences of a simple object is the a simple lattice w.r.t. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_simple_order\">docs#is_simple_order</a></p>",
        "id": 307400788,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1667335640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307379481\">said</a>:</p>\n<blockquote>\n<p>The blueprint I gave you carefully dodges trap statements like this one</p>\n</blockquote>\n<p>You are right about what context I am using it, but it is actually for something else. I prove for modules that <code>x ⋖ y</code> iff the quotient is a simple module. However, I think that statement should go (1) <code>x ⋖ y</code> iff <code>Icc x y</code> is simple for lattices and then (2) <code>Icc x y</code> is order isomorphic to the quotient in the case of modules.</p>",
        "id": 307401376,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667335910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307385903\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>, that's wrong. For example, <code>bool</code> with the discrete order (<code>tt</code> and <code>ff</code> are incomparable) is <em>not</em> a simple order.</p>\n</blockquote>\n<p><del><a href=\"https://leanprover-community.github.io/mathlib_docs/order/atoms.html#bool.is_simple_order\">Isn't it?</a></del> My bad I missed the discrete part.</p>",
        "id": 307402052,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667336172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307390862\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_simple_module\">docs#is_simple_module</a> unfolds to <code>is_simple_order</code>. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_simple_group\">docs#is_simple_group</a> is definitionally the same as <code>is_simple_order (subgroup G)</code> except for the <code>is_normal</code> condition. I guess it could be defined to be <code>is_simple_order {H : subgroup G // H.is_normal}</code>.</p>\n</blockquote>\n<p>Working with the 'lattice of normal subgroups' feels unnatural, mostly because  <code>Icc x y</code> is not order isomorphic with <code>y / x</code>.</p>",
        "id": 307403240,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667336674
    },
    {
        "content": "<p>At the risk of throwing oil at the fire: Is this better? I am also trying to improve my Lean. I have managed to eliminate code duplication.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">covby_iff_simple_order_Icc'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⋖</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_simple_order</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Icc.bounded_order</span> <span class=\"n\">hxy</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">covby_iff_lt_and_eq_or_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">1</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hxy'</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"k\">have</span> <span class=\"n\">hxy</span> <span class=\"o\">:=</span> <span class=\"n\">hxy'.le</span> <span class=\"o\">},</span>\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hxy</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">all_goals</span>\n  <span class=\"o\">{</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">Icc.bounded_order</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">le_refl</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxy</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hxy</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span> <span class=\"n\">y</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"bp\">⊥</span><span class=\"o\">,</span> <span class=\"bp\">⊤</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hxy'.ne</span> <span class=\"o\">(</span><span class=\"n\">subtype.mk_eq_mk.mp</span> <span class=\"n\">i</span><span class=\"o\">)⟩⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">hz</span><span class=\"o\">⟩,</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"n\">hz.1</span> <span class=\"n\">hz.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]),</span>\n      <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]),</span>\n      <span class=\"kd\">end</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_ne</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">bot_ne_top</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">hxy</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">z</span> <span class=\"n\">hxz</span> <span class=\"n\">hzy</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">eq_bot_or_eq_top</span> <span class=\"o\">(⟨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hxz</span><span class=\"o\">,</span> <span class=\"n\">hzy</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"n\">subtype.mk.inj</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n      <span class=\"n\">exact</span> <span class=\"n\">or.inr</span> <span class=\"o\">(</span><span class=\"n\">subtype.mk.inj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 307408356,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667339005
    },
    {
        "content": "<p>Yael's comment above still applies; that lemma permits a more pleasant statement if you state the two directions separately (as this eliminates the <code>exists</code>). You can of course still prove the <code>iff</code>, but you can do so in terms of the separate directions.</p>",
        "id": 307410736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667340036
    },
    {
        "content": "<p><del>Wrong thread <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>?</del> (fixed)</p>",
        "id": 307410848,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667340070
    },
    {
        "content": "<p>Uh yes <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 307410895,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667340084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307410736\">said</a>:</p>\n<blockquote>\n<p>Yael's comment above still applies; that lemma permits a more pleasant statement if you state the two directions separately (as this eliminates the <code>exists</code>). You can of course still prove the <code>iff</code>, but you can do so in terms of the separate directions.</p>\n</blockquote>\n<p>Fair point, I will do that.</p>",
        "id": 307414902,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667341915
    },
    {
        "content": "<p>Should a lemma like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Icc_equiv_quot</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">⧸</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>be added to mathlib? Does it exist? Or does anyone have a better idea for proving that  <code>A ⋖ B</code> iff <code>B/A</code> is a simple module?</p>",
        "id": 307415328,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667342101
    },
    {
        "content": "<p>At least this one wasn't hard</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.jordan_holder</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.cover</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.simple_module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_map_subtype</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">comap_map_eq_of_injective</span> <span class=\"n\">subtype.coe_injective</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_comap_subtype'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_comap_subtype</span><span class=\"o\">,</span> <span class=\"n\">inf_eq_right</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">hab</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Iic_equiv_submodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Iic</span> <span class=\"n\">C</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">to_fun</span>       <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">⟩,</span> <span class=\"n\">comap</span> <span class=\"n\">C.subtype</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span>      <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">map</span> <span class=\"n\">C.subtype</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">map_subtype_le</span> <span class=\"n\">C</span> <span class=\"n\">A</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">⟩,</span> <span class=\"n\">subtype.mk_eq_mk.mpr</span> <span class=\"o\">(</span><span class=\"n\">map_comap_subtype'</span> <span class=\"n\">hA</span><span class=\"o\">),</span>\n  <span class=\"n\">right_inv</span>    <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">comap_map_subtype</span> <span class=\"n\">C</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">hB</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">change</span> <span class=\"n\">comap</span> <span class=\"n\">C.subtype</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">comap</span> <span class=\"n\">C.subtype</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">map_comap_subtype'</span> <span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">map_comap_subtype'</span> <span class=\"n\">hB</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">map_mono</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">comap_mono</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 307422517,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667345797
    },
    {
        "content": "<p>It would be better to avoid the <code>⟨⟩</code> when defining <code>to_fun</code></p>",
        "id": 307467189,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667374904
    },
    {
        "content": "<p>Because when defining data this trick can lead to some pretty nasty defeqs under the hood</p>",
        "id": 307467302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667374972
    },
    {
        "content": "<p>I guess the statement above is also true as <code>(C : set X) : Iic C ≃o set C</code></p>",
        "id": 307467445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667375069
    },
    {
        "content": "<p>So I am trying to prove the <code>Icc</code> version, and I run into some very verbose goals in <code>left_inv</code>, <code>right_inv</code> and <code>map_rel_iff'</code>. Trying to <code>change</code> or <code>dsimp</code> them is very slow, to the point that it gives a deterministic timeout. Any suggestions?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.jordan_holder</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.cover</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.simple_module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n<span class=\"kn\">open</span> <span class=\"n\">subtype</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_map_subtype</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">comap_map_eq_of_injective</span> <span class=\"n\">subtype.coe_injective</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_comap_subtype'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_comap_subtype</span><span class=\"o\">,</span> <span class=\"n\">inf_eq_right</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">hab</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_map_mkq'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comap</span> <span class=\"n\">A.mkq</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">A.mkq</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">comap_map_mkq</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_right</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">hab</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_comap_mkq</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">A.mkq</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">A.mkq</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"n\">map_comap_eq_of_surjective</span> <span class=\"n\">A.mkq_surjective</span> <span class=\"n\">B</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Icc_equiv_quot</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">⧸</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">C.val</span><span class=\"o\">),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"o\">⟨</span>\n    <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">map_comap_subtype'</span> <span class=\"n\">hAB</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.le</span> <span class=\"o\">(</span><span class=\"n\">map_mono</span> <span class=\"o\">(</span><span class=\"n\">le_comap_mkq</span> <span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">)),</span>\n    <span class=\"n\">map_subtype_le</span> <span class=\"n\">B</span> <span class=\"n\">_</span> <span class=\"o\">⟩⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">comap_map_mkq'</span> <span class=\"o\">(</span><span class=\"n\">comap_mono</span> <span class=\"n\">h.1</span><span class=\"o\">),</span> <span class=\"n\">map_comap_subtype'</span> <span class=\"n\">h.2</span><span class=\"o\">],</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">change</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"n\">C</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">comap_map_subtype</span><span class=\"o\">,</span> <span class=\"n\">map_comap_mkq</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n      <span class=\"n\">change</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">C.val</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">D.val</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>",
        "id": 307498483,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667387201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/cumbersome.20typeclass.20in.20theorem.20statement/near/307467445\">said</a>:</p>\n<blockquote>\n<p>I guess the statement above is also true as <code>(C : set X) : Iic C ≃o set C</code></p>\n</blockquote>\n<p>My statement does not follow from that one right? Certainly a submodule <code>C</code> is a <code>set X</code>, but  <code>set C</code> is not equal to <code>submodule R C</code>. Or am I missing your point?</p>",
        "id": 307507932,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667390827
    },
    {
        "content": "<p><del><code>dsimp at h,</code> does the <code>change</code> and it seems to do it much more quickly.</del> Wait -- why are you changing C to C.val?</p>",
        "id": 307610947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667420265
    },
    {
        "content": "<p>If you do <code>dsimp at h</code> first then the <code>change</code> might work more quickly?</p>",
        "id": 307611262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667420362
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">comap_map_mkq'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comap</span> <span class=\"n\">A.mkq</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">A.mkq</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">comap_map_mkq</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_right</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><code>rwa</code> is <code>rw</code>, then <code>assumption</code></p>",
        "id": 307625370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667426361
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hAC</span><span class=\"o\">,</span> <span class=\"n\">hCB</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">hAD</span><span class=\"o\">,</span> <span class=\"n\">hDB</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">,</span> <span class=\"n\">comap_map_mkq</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sup_eq_right.2</span> <span class=\"o\">(</span><span class=\"n\">comap_mono</span> <span class=\"n\">hAD</span> <span class=\"o\">:</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">D</span><span class=\"o\">),</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">hxC</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">comap_mono</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">B.subtype</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hCB</span> <span class=\"n\">hxC</span><span class=\"o\">⟩</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">),</span>\n    <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">hxC</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 307630717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667429155
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hAC</span><span class=\"o\">,</span> <span class=\"n\">hCB</span><span class=\"o\">⟩,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 307632233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667430075
    },
    {
        "content": "<p>Probably yours is faster though. Note that your <code>h</code> is defeq to <code>A &lt;= C \\and C \\le B</code>.</p>",
        "id": 307632446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667430180
    },
    {
        "content": "<p>Oh -- I changed your <code>to_fun</code> to <code>to_fun := λ C, map (comap B.subtype A).mkq (comap B.subtype (C : submodule R M)),</code> -- my guess is that the coercion is the <code>simp</code> normal form rather than <code>C.val</code>.</p>",
        "id": 307632617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667430255
    },
    {
        "content": "<p>To avoid confusion let me just post my version of the full code. It's still slow though and I don't really know why.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Icc_equiv_quot</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">⧸</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">map</span> <span class=\"n\">B.subtype</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mkq</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"o\">⟨</span>\n    <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">map_comap_subtype'</span> <span class=\"n\">hAB</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.le</span> <span class=\"o\">(</span><span class=\"n\">map_mono</span> <span class=\"o\">(</span><span class=\"n\">le_comap_mkq</span> <span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">)),</span>\n    <span class=\"n\">map_subtype_le</span> <span class=\"n\">B</span> <span class=\"n\">_</span> <span class=\"o\">⟩⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hAC</span><span class=\"o\">,</span> <span class=\"n\">hCB</span><span class=\"o\">⟩,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hAC</span><span class=\"o\">,</span> <span class=\"n\">hCB</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">hAD</span><span class=\"o\">,</span> <span class=\"n\">hDB</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">,</span> <span class=\"n\">comap_map_mkq</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sup_eq_right.2</span> <span class=\"o\">(</span><span class=\"n\">comap_mono</span> <span class=\"n\">hAD</span> <span class=\"o\">:</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">comap</span> <span class=\"n\">B.subtype</span> <span class=\"n\">D</span><span class=\"o\">),</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">hxC</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">comap_mono</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">B.subtype</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hCB</span> <span class=\"n\">hxC</span><span class=\"o\">⟩</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">),</span>\n    <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">hxC</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 307634316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667431429
    },
    {
        "content": "<p>Thanks for your effort! I was really struggling with val/coe/etc. Do you mind if I pull request this to mathlib?</p>",
        "id": 307688611,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667468804
    },
    {
        "content": "<p>I did some experimenting by moving to_fun and inv_fun to separate definitions, and it becomes way faster. It seems like inv_fun is somewhat slow, and if we leave it inline as in your code it seems like it has to 'parse' (for lack of a better word) that multiple times.</p>",
        "id": 307688978,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667468961
    },
    {
        "content": "<p>I am now at the final stages of my proofs. I only require the following instance. However, I seem unable to tell Lean that beta is a bounded_order. Any hints?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.cover</span> <span class=\"n\">order.atoms</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">is_simple_order_of_equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">bounded_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">bounded_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_simple_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_simple_order</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">exists_pair_ne</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h.exists_pair_ne</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">((</span><span class=\"n\">order_iso.apply_eq_iff_eq</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">i</span><span class=\"o\">)⟩,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_bot_or_eq_top</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h.eq_bot_or_eq_top</span> <span class=\"o\">(</span><span class=\"n\">f.symm</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"o\">{</span>\n      <span class=\"n\">left</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">h_1</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">f.apply_symm_apply</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"c1\">--letI : order_bot β := bounded_order.to_order_bot β,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">order_iso.map_bot</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 307712892,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667477289
    },
    {
        "content": "<p>Nevermind, I figured it out. <code>has_le</code> and <code>partial_order</code> conflict, so it should be <code>{α : Type*} [partial_order α] [bounded_order α]</code>.</p>",
        "id": 307715001,
        "sender_full_name": "Daan van Gent",
        "timestamp": 1667477937
    },
    {
        "content": "<p><code>is_simple_order_of_equiv</code>  can't be an instance as lean can't find <code>f</code>, but it should be a <code>@[reducible] def</code>.</p>",
        "id": 307718136,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667478890
    },
    {
        "content": "<p>You should be able to golf that by using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.injective.nontrivial\">docs#function.injective.nontrivial</a></p>",
        "id": 307718268,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667478942
    }
]
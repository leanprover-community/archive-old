[
    {
        "content": "<p>Trying to show a result about finite bases of matrices. I'm running into converting between set, finset, and fintype. The proof I have comes from reading various lemmas in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_algebra/src\">src#linear_algebra</a>/finite_dimensional. I tried employing various set and finset lemmas, but I think I'm missing something:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">matrix</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- An n × n matrix has some finite basis of cardinality n ^ 2</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)),</span>\n            <span class=\"o\">(</span><span class=\"n\">is_basis</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n            <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_is_basis_finite</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span> <span class=\"n\">s_finite</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_two</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span>\n    <span class=\"n\">funext</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span><span class=\"o\">,</span>\n    <span class=\"n\">funext</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span> <span class=\"o\">},</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">dim_eq_card_basis</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span><span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim_eq_dim</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"c1\">-- goal is s_finite.to_finset.card = fintype.card {x // x ∈ s}</span>\n  <span class=\"n\">rw</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">subtype_card</span> <span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"c1\">-- seems like set.finite.mem_to_finset should work</span>\n  <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">intros</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- why doesn&#39;t the exact statement here work?</span>\n        <span class=\"c1\">-- exact set.finite.mem_to_finset.mp h,</span>\n        <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">mem_to_finset</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n        <span class=\"n\">funext</span><span class=\"o\">}</span> <span class=\"o\">),</span>\n  <span class=\"c1\">-- but rw fails with</span>\n  <span class=\"c1\">-- rewrite tactic failed, did not find instance of the pattern in the target expression</span>\n  <span class=\"c1\">--    fintype.card {x // (λ (x : matrix (fin n) (fin n) ℝ), x ∈ s) x}</span>\n  <span class=\"c1\">-- how does one funext inside the subtype expression?</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 200516224,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591863383
    },
    {
        "content": "<p>I think that the concept of finiteness in type theory is genuinely messy. Either that or there's a trick I don't know about.</p>",
        "id": 200517428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591864333
    },
    {
        "content": "<p>an irrelevant hint: if you're gonna provide an explicit witness, don't obscure it inside an existential, but rather construct it and prove its properties</p>",
        "id": 200518186,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591864858
    },
    {
        "content": "<p>aha you didn't provide an expllicit basis, alright</p>",
        "id": 200518229,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591864889
    },
    {
        "content": "<p>I'm not at lean right now but looking at your code I think that <code>fintype</code> is data so you should use <code>letI</code></p>",
        "id": 200519206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591865548
    },
    {
        "content": "<p>Did you read <a href=\"https://leanprover-community.github.io/theories/sets.html\">https://leanprover-community.github.io/theories/sets.html</a>?</p>",
        "id": 200519560,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1591865864
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">matrix</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">attach_eq_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">attach</span> <span class=\"bp\">=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">card_to_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_attach</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">attach_eq_univ</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">],</span> <span class=\"n\">congr&#39;</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">mem_to_finset</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- An n × n matrix has some finite basis of cardinality n ^ 2</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)),</span>\n            <span class=\"o\">(</span><span class=\"n\">is_basis</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n            <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_is_basis_finite</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span> <span class=\"n\">s_finite</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">s_basis</span> <span class=\"o\">},</span>\n  <span class=\"n\">cases</span> <span class=\"n\">id</span> <span class=\"n\">s_finite</span><span class=\"o\">,</span> <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">card_to_finset</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim_eq_card_basis</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span>\n      <span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"n\">findim_matrix</span><span class=\"o\">,</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_two</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 200526505,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591871038
    },
    {
        "content": "<p>These theory pages are great</p>",
        "id": 200543052,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1591881848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/working.20with.20finset.20and.20fintype/near/200519560\">said</a>:</p>\n<blockquote>\n<p>Did you read <a href=\"https://leanprover-community.github.io/theories/sets.html\">https://leanprover-community.github.io/theories/sets.html</a>?</p>\n</blockquote>\n<p>This seems like a good place to ask about the following definition (as it appears in mathlib, rather than how it appears on the given page):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">elems</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">complete</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">elems</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>What is the <code>[]</code> after <code>elems</code>?  In the Lean documentation, I could only find something about <code>{}</code>.</p>\n<p>(Also, for <code>finset</code>, is there a short way to extract a representative <code>list</code> along with a proof of <code>nodup</code> for that list? I don't need this right now, but I had spent an hour or two trying to figure it out before I settled on a construction through induction using <code>finset.induction</code>. )</p>",
        "id": 200592081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1591903004
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> That recently changed... (that's why you only find mention of <code>{}</code> in the docs, and the def is different from that documentation page.</p>",
        "id": 200592230,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591903079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Will know the details better than I do.</p>",
        "id": 200592388,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591903139
    },
    {
        "content": "<p>These brackets refer to the binder of <code>fintype.elems</code></p>",
        "id": 200592424,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1591903156
    },
    {
        "content": "<p>See</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">elems</span>\n\n<span class=\"n\">class</span> <span class=\"n\">fintype&#39;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">elems</span>  <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">complete</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">elems</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">fintype&#39;</span><span class=\"bp\">.</span><span class=\"n\">elems</span>\n</code></pre></div>",
        "id": 200592638,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1591903272
    },
    {
        "content": "<p>You'll see that <code>α</code> is explicit in <code>fintype.elems</code> and implicit in <code>fintype'.elems</code>.</p>",
        "id": 200592760,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1591903329
    },
    {
        "content": "<p>The default value changed recently.</p>",
        "id": 200592778,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1591903346
    },
    {
        "content": "<p>I see, thanks for the example.  Somehow it didn't strike me as odd that every use of <code>fintype.elems</code> in <code>data.fintype.basic</code> had an explicit type.</p>",
        "id": 200593179,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1591903552
    },
    {
        "content": "<p>It's not meant to be odd.</p>",
        "id": 200594978,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1591904384
    },
    {
        "content": "<p>Worth it to add Kenny's theorems to mathlib?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">attach_eq_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">attach</span> <span class=\"bp\">=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">card_to_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_attach</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">attach_eq_univ</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">],</span> <span class=\"n\">congr&#39;</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">mem_to_finset</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 200603515,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591908241
    },
    {
        "content": "<p>In the proof here, the first <code>rw</code> does not change my tactic state in a visible way. <code>s_basis : is_basis ℝ subtype.val</code> matches the tactic goal of <code>is_basis ℝ subtype.val</code>, but it only works when the <code>rw set.finite.coe_to_finset</code> is included. What's going on?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">-- An n × n matrix has some finite basis of cardinality n ^ 2</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)),</span>\n            <span class=\"o\">(</span><span class=\"n\">is_basis</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n            <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_is_basis_finite</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span> <span class=\"n\">s_finite</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">s_basis</span> <span class=\"o\">},</span> <span class=\"c1\">-- here; exact s_basis is not enough</span>\n  <span class=\"n\">cases</span> <span class=\"n\">id</span> <span class=\"n\">s_finite</span><span class=\"o\">,</span> <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">card_to_finset</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim_eq_card_basis</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span>\n      <span class=\"n\">matrix</span><span class=\"bp\">.</span><span class=\"n\">findim_matrix</span><span class=\"o\">,</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_two</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span><span class=\"bp\">```</span>\n</code></pre></div>",
        "id": 200605405,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591909211
    },
    {
        "content": "<p>Isn't this a special case of a more general theorem about a by b matrices?</p>",
        "id": 200611779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591912427
    },
    {
        "content": "<p>Isn't this a special case of a more general theorem about findim vector spaces?</p>",
        "id": 200612129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591912602
    },
    {
        "content": "<p>the only thing that is specific to matrices is the claim that the dimension is a * b or n ^ 2</p>",
        "id": 200612210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591912637
    },
    {
        "content": "<p>Yeah it is a specialized case. But proving the general case would look the same, other than getting rid of the last three rewrite terms, <code>matrix.findim_matrix, fintype.card_fin, nat.pow_two</code>, correct?</p>",
        "id": 200613708,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591913455
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n        <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n        <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n          <span class=\"o\">(</span><span class=\"n\">is_basis</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n          <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_is_basis_finite</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span> <span class=\"n\">s_finite</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">s_basis</span> <span class=\"o\">},</span>\n  <span class=\"n\">cases</span> <span class=\"n\">id</span> <span class=\"n\">s_finite</span><span class=\"o\">,</span> <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"n\">erewrite</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">card_to_finset</span><span class=\"o\">,</span> <span class=\"err\">←</span><span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim_eq_card_basis</span> <span class=\"n\">s_basis</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 200614303,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591913816
    },
    {
        "content": "<p>Sounds reasonable to me. This example would presumably be a lemma called <code>finite_dimensional.exists_finset_is_basis</code>.</p>",
        "id": 200621812,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591919961
    },
    {
        "content": "<p>Some minor stylistic points:</p>\n<ol>\n<li>you can use <code>obtain ...</code> in the first line, which is perhaps slightly more readable</li>\n<li>put braces around the proofs steps of the second case coming from <code>refine</code>.</li>\n<li><code>erw</code> instead of <code>erewrite</code></li>\n</ol>",
        "id": 200621920,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591920051
    },
    {
        "content": "<p>Did you work out why the <code>erw</code> is necessary? It means some definitional unfolding needs to happen, preventing <code>rw</code> from matching purely syntactically. Often an additional <code>rw</code> or <code>dsimp</code> can be used instead, and it's usually easier to understand if you do this.</p>",
        "id": 200621981,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591920121
    },
    {
        "content": "<p>But sometimes, sadly, <code>erw</code> seems unavoidable.</p>",
        "id": 200622028,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591920129
    },
    {
        "content": "<p>Yeah, that makes sense about the <code>erw</code>. The conversion between the four types (for lack of a better word) of values and types of sets is clunky. That's why the <code>erw</code> is needed, to convert the <code>↥s</code> to <code>{x // x ∈ s}</code>. And the <code>cases id s_finite, resetI</code> is needed to populate the <code>fintype ↥s</code> instance into the tactic state. I think the difference I've understood to be between <code>finsets </code>and <code>finite</code> is that finsets are our regular old enumerable finite sets. While <code>finite</code> describes something that can be grouped into a finite set in a meaningful and non-trivial way, but also in a axiom-of-choice way.</p>",
        "id": 200626937,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591925548
    },
    {
        "content": "<p>Is there a lemma that says <code>↥s = {x // x ∈ s}</code>? (Presumably yes.) If so, you can rewrite along that first.</p>",
        "id": 200627353,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591926068
    },
    {
        "content": "<p>Seems like <code>refl</code> proves that. Which I guess is why <code>erw</code> works.</p>",
        "id": 200629490,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591929094
    },
    {
        "content": "<p>Is it possible to trace which relations <code>refl</code> uses?</p>",
        "id": 200629552,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591929128
    },
    {
        "content": "<p>anything with a <code>@[refl]</code> tag</p>",
        "id": 200630656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591930865
    },
    {
        "content": "<p>or are you asking something else?</p>",
        "id": 200630662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591930894
    },
    {
        "content": "<p>If you mean proofs by defeq, i.e. <code>exact rfl</code>, then anything is fair game, it will unfold whatever it has to</p>",
        "id": 200630705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591930958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>, could you post the actual statement you're proving with <code>refl</code> here? I'd like to test a new variant of <code>library_search</code> on it.</p>",
        "id": 200632103,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591933040
    },
    {
        "content": "<p>Oh, got it.</p>",
        "id": 200632430,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591933596
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 200632974,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591934425
    },
    {
        "content": "<p>Similar to how one can <code>set_option trace.simplify true</code> for <code>simp</code>, what would it be for <code>refl</code>?</p>",
        "id": 200633035,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591934524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Tests.20fail/near/200632671\">said</a>:</p>\n<blockquote>\n<p>Happily <a href=\"https://github.com/leanprover-community/mathlib/issues/3038\">#3038</a> makes this test fast again, so I've restored it there.</p>\n</blockquote>\n<p>I see you got it.</p>",
        "id": 200633148,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591934745
    },
    {
        "content": "<p>I learned this from some of <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s messages:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n<span class=\"c\">/-</span><span class=\"cm\"> when your cursor is on `refl`:</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] [1]: ?m_2 = ?m_2 =?= ↥s = {x // x ∈ s}</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] [2]: eq =?= eq</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] process_assignment ?m_1 := has_coe_to_sort.S (set α)</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] assign: ?m_1 := has_coe_to_sort.S (set α)</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] process_assignment ?m_1 := ↥s</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] assign: ?m_1 := ↥s</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] [2]: ↥s =?= {x // x ∈ s}</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] unfold left: coe_sort</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] [3]: has_coe_to_sort.coe s =?= {x // x ∈ s}</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] [4]: (λ (s : set α), {x // x ∈ s}) s =?= {x // x ∈ s}</span>\n<span class=\"cm\">[type_context.is_def_eq_detail] after whnf_core: {x // x ∈ s} =?= {x // x ∈ s}</span>\n<span class=\"cm\">[type_context.is_def_eq] ?m_2 = ?m_2 =?= ↥s = {x // x ∈ s} ... success  (approximate mode)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n\n\n<p>Don't ask me exactly what all the steps mean though...</p>",
        "id": 200633216,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1591934848
    },
    {
        "content": "<p>It does suggest looking at <code>#print set.has_coe_to_sort</code>.</p>",
        "id": 200633273,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1591934921
    },
    {
        "content": "<p>It would seem inserting <code>rw set.set_coe_eq_subtype s</code> should work, but it gives a motive error:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_finset_is_basis</span>\n      <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n      <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n        <span class=\"o\">(</span><span class=\"n\">is_basis</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n        <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">obtain</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span> <span class=\"n\">s_finite</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_is_basis_finite</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">s_basis</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">id</span> <span class=\"n\">s_finite</span><span class=\"o\">,</span> <span class=\"n\">resetI</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">card_to_finset</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">set_coe_eq_subtype</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n<span class=\"c1\">-- error here: rewrite tactic failed, motive is not type correct</span>\n<span class=\"c1\">--  λ (_a : has_coe_to_sort.S (set V)),</span>\n<span class=\"c1\">--    fintype.card ↥s = finite_dimensional.findim K V = (fintype.card _a = finite_dimensional.findim K V)</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim_eq_card_basis</span> <span class=\"n\">s_basis</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 200633512,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591935310
    },
    {
        "content": "<p>The problem is that the goal involves a <code>fintype</code> instance, which Lean isn't clever enough to move across the equality.</p>",
        "id": 200634231,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591936422
    },
    {
        "content": "<p>Perhaps <code>simp</code> instead of <code>rw</code> at that step?</p>",
        "id": 200634238,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591936433
    },
    {
        "content": "<p>Yes, <code>simp only</code> works:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_finset_is_basis</span>\n      <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n      <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n        <span class=\"o\">(</span><span class=\"n\">is_basis</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n        <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">obtain</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_basis</span><span class=\"o\">,</span> <span class=\"n\">s_finite</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">exists_is_basis_finite</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">s_finite</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">s_basis</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">id</span> <span class=\"n\">s_finite</span><span class=\"o\">,</span> <span class=\"n\">resetI</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">card_to_finset</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">set_coe_eq_subtype</span> <span class=\"n\">s</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim_eq_card_basis</span> <span class=\"n\">s_basis</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 200634474,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591936752
    },
    {
        "content": "<p>Good exercise for learning, but I think at the end of the day both options are unfortunate (<code>rw, simp, rw</code>, or <code>erw</code>), and neither obviously superior. :-)</p>",
        "id": 200634545,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591936830
    },
    {
        "content": "<p>Welcome to dependent type theory...</p>",
        "id": 200634555,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591936846
    },
    {
        "content": "<p>I haven't yet grokked what the Sort coercion of <code>↥s</code> is doing yet. Regular coercion can turn a <code>finset</code> into a <code>set</code>, so that's from one Type to another Type. While <code>↥s</code> is turning something from value-level to type-level. Is that correct? So it is similar to what <code>fin n</code> does. Then why can't one do <code>↥n</code> to get <code>fin n</code>?</p>",
        "id": 200634637,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1591937009
    },
    {
        "content": "<p><code>↥s</code> is the subtype of elements of <code>s</code></p>",
        "id": 200634759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591937174
    },
    {
        "content": "<p>that is, <code>↥s = {x // x ∈ s}</code></p>",
        "id": 200634762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591937194
    },
    {
        "content": "<p>but you know this already?</p>",
        "id": 200634764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591937200
    },
    {
        "content": "<p><code>↥n</code> doesn't work because there is no defined <code>has_coe_to_sort nat</code> instance</p>",
        "id": 200634781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591937235
    },
    {
        "content": "<p>and if you did define one, isn't <code>1 : 4</code> exactly the sort of nonsense question from ZFC that type theory was built to avoid?</p>",
        "id": 200634831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591937351
    },
    {
        "content": "<p>(In case it's helpful, <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#coercions-using-type-classes\">here's</a> the section in TPiL about coercions.)</p>",
        "id": 200634837,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1591937383
    }
]
[
    {
        "content": "<p>Thanks all for your answers.</p>\n<p>How do you perform induction on a term which is not part of the context? I am trying to prove this lemma, which says \"finite sums of vectors can be done coordinate-by-coodinate\" . I'm trying to employ induction on the size of  the fintype α. This is my best try so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">data.real.sqrt</span> <span class=\"n\">data.nat.basic</span> <span class=\"n\">data.fin.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span>\n\n<span class=\"c1\">-- I've show (add_comm_monoid (R n))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_by_coordinate</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sizeof</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I used <code>let n := sizeof α</code> when <code>induction (sizeof  α)</code> failed to work on its own. But now I don't know how to work with the resulting target term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sizeof</span> <span class=\"n\">α</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>What's the standard way forward here? Btw, I am trying to prove this first without <code>finset.sum_induction</code>,  just as an exercise.</p>",
        "id": 313877679,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1670207250
    },
    {
        "content": "<p>You should use <code>finset.sum_induction</code> and then specialise to <code>finset.univ</code> to get your result.</p>",
        "id": 313903541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670225747
    },
    {
        "content": "<p>I'm pretty sure you want <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.card\">docs#fintype.card</a> not <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sizeof\">docs#sizeof</a></p>",
        "id": 313911885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670229351
    },
    {
        "content": "<p><code>induction h : fintype.card α</code> might be what you're asking for</p>",
        "id": 313912275,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670229445
    },
    {
        "content": "<p>I'm not sure that encouraging the use of induction on the type is a good idea here. It's much easier to prove the more general statement about a finset because then you don't need to move the underlying type.</p>",
        "id": 313923829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670233658
    },
    {
        "content": "<p>Just to give a mathlib example of how to do induction on the cardinality of a type (which is like what Eric brought up), there's this part of the proof of Hall's marriage theorem: <a href=\"https://github.com/leanprover-community/mathlib/blob/f1a2caaf51ef593799107fe9a8d5e411599f3996/src/combinatorics/hall/finite.lean#L229\">https://github.com/leanprover-community/mathlib/blob/f1a2caaf51ef593799107fe9a8d5e411599f3996/src/combinatorics/hall/finite.lean#L229</a></p>\n<p>There's a Lean technicality where you have to use <code>unfreezingI</code> since the <code>fintype</code> instance is \"frozen\".</p>",
        "id": 313930603,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1670235928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra/near/313923829\">said</a>:</p>\n<blockquote>\n<p>I'm not sure that encouraging the use of induction on the type is a good idea here.</p>\n</blockquote>\n<p>Indeed; but it does directly answer the \"How do you perform induction on a term which is not part of the context?\". It just happens that in this particular case that's not actually a helpful thing to do!</p>",
        "id": 313937607,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670238128
    },
    {
        "content": "<p>Hello all,</p>\n<p>Thank you again for your helpful answers.</p>\n<p>I am still stuck on proving the below lemma. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> thank you for your suggestion to use <code>finset.sum_induction</code>. Upon further study of that theorem, I am struggling to apply it to my case (though I do not doubt it may apply). Specifically, I am struggling to formulate a predicate <code>p: R n -&gt; Prop</code> to use in my case. I believe I want to show a property of summing in <code>R n</code>.</p>\n<p>Having temporarily hit a wall with the recommended approach, I have decided to continue playing with the ill-advised induction on <code>fintype.card α</code>, in hopes to learn why it breaks down. It did break down, but in an unexpected way. Here is my current state (using the induction pointed out by <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">data.fin.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- In my file, I have shown</span>\n<span class=\"kd\">instance</span> <span class=\"n\">vec_add_comm_monoid</span><span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- the lemma in question</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_pointwise</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"k\">with</span> <span class=\"n\">n'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- constructing this instance as I don't know how to help Lean find/infer it</span>\n    <span class=\"k\">have</span> <span class=\"n\">α_is_empty</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.card_eq_zero_iff.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- error on this line</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">@</span><span class=\"n\">fintype.sum_empty</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">vec_add_comm_monoid</span> <span class=\"n\">α_is_empty</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Giving the following state/error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"n\">α_is_empty</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>I am quite stumped, as I expect Lean to find the pattern in the target as <code>∑ (a : α), f a</code>. I believe this pattern is <code>finset.univ.sum f</code>. Does it perhaps have to do with Type universes?</p>\n<p>Any help on either of these fronts would be greatly appreciated.</p>",
        "id": 314382089,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1670392408
    },
    {
        "content": "<p>I <em>think</em> what's being suggested here is to begin with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_pointwise</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">A</span> <span class=\"n\">using</span> <span class=\"n\">finset.cons_induction</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">A</span> <span class=\"n\">hb</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>and only then proceed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_pointwise'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">vec_sum_pointwise</span> <span class=\"n\">finset.univ</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 314422552,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1670408809
    },
    {
        "content": "<p>FWIW, this more general lemma exists already as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_apply\">docs#finset.sum_apply</a></p>",
        "id": 314443573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670416089
    },
    {
        "content": "<p>Thanks to those who have helped me thus far.</p>\n<p>This time I'm not stuck, I just want to know the most idiomatic way of doing something. I have the following lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_smul_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Later on, I want to show that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⟪</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span>\n</code></pre></div>\n<p>However, I find that I cannot <code>rw</code> or <code>apply</code> dot_prod_right_distrib directly. The problem is that the lemma does not know that <code>α</code> and <code>β</code> can be taken to be 1.  Thus, my proof of the latter statements starts like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n      <span class=\"c1\">-- insert \"1 •\" on every vector</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">vec_smul_one</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">vec_smul_one</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- apply the lemma with α = β = 1</span>\n      <span class=\"n\">rw</span> <span class=\"n\">dot_prod_distrib</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n      <span class=\"c1\">-- remove the \"1 •\"</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">vec_smul_one</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>My question is, is there a better way to do this? I suspect many theorems/lemmas will appear in these generalized forms. Can I tell LEAN how to guess <code>α = β = 1</code> automatically? Alternatively, I could just write multiple versions of the same lemma, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib''</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib'''</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but this seems rather tedious.</p>\n<p>Thanks for the help!</p>",
        "id": 318027898,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672108941
    },
    {
        "content": "<p><code>1 bub x</code> is neither syntactically nor definitely equal to <code>x</code>. The problem is not that lean isn't guessing alpha = 1, it's that even if you set alpha = 1 the lemma doesn't match. It might be what you see in the textbooks but the lemma isn't a good one for rewriting because it's doing too many jobs at once, and <code>rw</code> works up to syntactic equality. Why not prove additivity and linearity as two separate lemmas? <code>(x+y,z) and </code>(c \\bub x,z), and also have lemmas for (x,y+z) etc.</p>",
        "id": 318039481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672120707
    },
    {
        "content": "<p>You don't want the more complex lemmas, you should tell the simplifier about the basic lemmas and then it will prove the more complex ones by itself.</p>",
        "id": 318039671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672120888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for the insight. I see what you mean about this lemma being overloaded. I'll prove the two lemmas separately and show the textbook's lemma as an example.</p>",
        "id": 318040060,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672121249
    },
    {
        "content": "<p>The proof of the textbook lemma should be <code>simp</code></p>",
        "id": 318060279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672133880
    },
    {
        "content": "<p>Isn't your <code>vec_smul_one</code> just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/one_smul\">docs#one_smul</a>?</p>",
        "id": 318121303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672157061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>. Thanks for the pointer. I had not seen this theorem. I have since removed my <code>vec_smul_one</code> lemma as I don't need it.</p>\n<p>What I'm trying to do is formalize a basic linalg book, replicating any definitions/theorems from the book, while using mathlib as much as possible to help with any definitions/theorems that the book assumes or uses without proof.</p>",
        "id": 318517174,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672366488
    },
    {
        "content": "<p>I had a followup question about the simplifier.</p>\n<p>I am working on a theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_norm_sum</span> <span class=\"o\">:</span>  <span class=\"bp\">∥</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">∥</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">x</span><span class=\"bp\">∥</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"bp\">∥</span><span class=\"n\">y</span><span class=\"bp\">∥</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">dot_prod_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">dot_prod_comm</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">ring</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>After the first <code>simp</code>,  the tactic state becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">xy</span><span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>However, I have a theorem <code>dot_prod_comm</code> marked with <code>@[simp]</code> with the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- #check dot_prod_comm</span>\n<span class=\"n\">dot_prod_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>My question is, why doesn't the simplifier use this lemma to further simplify the state? As shown above, I can manually apply <code>dot_prod_comm</code> twice with another <code>simp</code> and <code>ring</code> to complete the proof.</p>",
        "id": 318517595,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672366799
    },
    {
        "content": "<p><code>simp</code> detects commutativity (such as your <code>dot_prod_comm</code> and only uses them if the rewrite results in smaller variable indices when taken lexicographically, or something along those lines. The details don't matter, but the point is that you don't want to rewrite <code>a + b</code> into <code>b + a</code> into <code>a + b</code> into... so <code>simp</code> has some secret preferred ordering of the variables, and in your case it just happens that the variables are in its preferred order.</p>",
        "id": 318532329,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672383230
    },
    {
        "content": "<p>Here I would suggest adding <code>dot_prod_comm x</code> (or <code>dot_prod_comm x, dot_prod_comm y</code>) to your <code>simp</code> call because it suddenly isn't a commutativity lemma either (it won't rewrite back).</p>",
        "id": 318532433,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672383307
    },
    {
        "content": "<p>In this case I think a better approach would be: you seem to have a simp lemma that says that <code>inner</code> is linear in the first argument, but not one for the second argument; you should add it.</p>",
        "id": 318539509,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672388423
    },
    {
        "content": "<p>That's more sensible than relying on <code>dot_prod_comm</code> in this proof (which isn't \"simplification\" at all, it just happens to <em>allow</em> further simplification).</p>",
        "id": 318539679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672388542
    },
    {
        "content": "<p>Are you aware of the lemmas <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_add_right\">docs#inner_add_right</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_add_left\">docs#inner_add_left</a>?</p>",
        "id": 318541169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672389425
    }
]
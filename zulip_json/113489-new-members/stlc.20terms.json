[
    {
        "content": "<p>If I understand correctly, in the untyped lambda calculus, we have the inductive definition for terms as something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">abs</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n</code></pre></div>\n<p>In this [1] and other formulations of the simply typed lambda calculus I am confused to see this definition unaltered. I had guessed that it would have been amended to incorporate the typing rules somehow. It seems to say that we can have a term of something like <code>app (10) (20)</code>? But then what would its type be? It wouldn't have one by the typing rules right? Doesn't every term have to have a type?<br>\n[1] <a href=\"https://softwarefoundations.cis.upenn.edu/current/plf-current/Stlc.html\">https://softwarefoundations.cis.upenn.edu/current/plf-current/Stlc.html</a></p>",
        "id": 240795106,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622441034
    },
    {
        "content": "<p>I guess further down in the same document it says that some terms are untypable. I guess programs like Coq and Lean have additional rules to prohibit untypable terms?</p>",
        "id": 240795693,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622441722
    },
    {
        "content": "<p>Right, in this formulation typing only comes later as some sort of deduction system on these terms, like in the \"Typing\" section of the book you linked. And then you can start to ask and to prove things like whether a term is well typed, to infer the type of a term (or give an error if it's ill typed), that some operations preserve well typing and so on. And you can indeed have ill typed terms like you point out, but you are generally interested in those well typed</p>",
        "id": 240795804,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622441841
    },
    {
        "content": "<p>This, if I remember correctly the terminology is sometimes called Curry-style typing.</p>",
        "id": 240795860,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622441885
    },
    {
        "content": "<p>But you can also implement the types as intrinsic part of the definition of terms, which is Church-style typing</p>",
        "id": 240795873,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622441927
    },
    {
        "content": "<p>Interesting. So Coq and Lean and similar programs use Church style typing?</p>",
        "id": 240795974,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622442062
    },
    {
        "content": "<p>Where you would have something <code>term : ty -&gt; Type</code> and then <code>app (a b) : term (a --&gt; b) -&gt; term a -&gt; term b</code> so to speak. And this way it will not make sense, by definition to speak of ill typed terms, they don't exist</p>",
        "id": 240795989,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622442086
    },
    {
        "content": "<p>That I don't know, but I think not, though I'm out of my knowledge zone here</p>",
        "id": 240796058,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622442154
    },
    {
        "content": "<p>Thank you. Is <code>ty</code> a misprint for <code>Type</code>?</p>",
        "id": 240796164,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622442270
    },
    {
        "content": "<p>No, that would be the simple types of the lambda calculus you are implementing, as opposed to Type, the Lean types, or the types of the system you are implementing it in</p>",
        "id": 240796291,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622442423
    },
    {
        "content": "<p>So you would have probably an inductive definition of <code>ty</code> saying stuff like \"if a and b are types in ty, you can construct a function type in ty\"</p>",
        "id": 240796376,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622442501
    },
    {
        "content": "<p>A function type <code>a --&gt; b</code> I mean, in my notation above, I think I didn't explain that very good</p>",
        "id": 240796703,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622442847
    },
    {
        "content": "<p>I think I see. term is a constructor that takes a ty and returns a Type. And app takes two Types and returns a Type.</p>",
        "id": 240796763,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622442927
    },
    {
        "content": "<p>Is that right?</p>",
        "id": 240796955,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622443130
    },
    {
        "content": "<p><code>term</code> would be an inductive type indexed by <code>ty</code>, and <code>ty</code> would be an inductive type. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ty</span>\n<span class=\"bp\">|</span> <span class=\"n\">some_constant_type</span> <span class=\"o\">:</span> <span class=\"n\">ty</span>\n<span class=\"bp\">|</span> <span class=\"n\">function_type</span> <span class=\"o\">:</span> <span class=\"n\">ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ty</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`==&gt;`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">ty.function_type</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ty</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">term</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">term</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 240797093,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622443240
    },
    {
        "content": "<p>Something like this</p>",
        "id": 240797110,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622443265
    },
    {
        "content": "<p><code>app</code> takes two terms (<em>of appropriate types, by definition</em>) and returns a term (<em>of appropriate type, by definition</em>)</p>",
        "id": 240797163,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622443320
    },
    {
        "content": "<p>I see. Cool. Thank you!</p>",
        "id": 240797285,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622443426
    },
    {
        "content": "<p>It would be interesting and maybe educational to see what the full formalization of just the simply typed lambda portion of Coq or Lean is, in Coq or Lean. Especially if a user could interact with it in such a way as to manually apply each typing rule, reduction, etc. Basically to see and interact with what is going on behind the scenes. And then see what is changed by adding polymorphism, etc.</p>",
        "id": 240800379,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622445952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/stlc.20terms/near/240795974\">said</a>:</p>\n<blockquote>\n<p>Interesting. So Coq and Lean and similar programs use Church style typing?</p>\n</blockquote>\n<p>Yes. The key difference with church style typing is that a type appears in the term constructor for lambda, <code>\\lam x: T, e</code> rather than an unspecified <code>\\lam x, e</code> like in your original inductive type</p>",
        "id": 240803763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622448170
    },
    {
        "content": "<p>How does adding a type in the term constructor for lambda prevent the construction of a term that is not typable, like <code>app (10) (20)</code>?</p>",
        "id": 240851757,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622478585
    },
    {
        "content": "<p>If I understand Mario correctly I was mistaken in calling my construction there Church typing (or rather, it is Church typing, but you don't need all that for it to count as Church typing), and I should've probably spoken about implicitly vs explicitly typed syntaxes.</p>",
        "id": 240852746,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622479282
    },
    {
        "content": "<p>So, yes, you can speak of <code>app (10) (20)</code> which is a term even though it is ill-typed</p>",
        "id": 240853026,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622479512
    },
    {
        "content": "<p>I see.</p>",
        "id": 240853081,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622479562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/stlc.20terms/near/240800379\">said</a>:</p>\n<blockquote>\n<p>It would be interesting and maybe educational to see what the full formalization of just the simply typed lambda portion of Coq or Lean is, in Coq or Lean. Especially if a user could interact with it in such a way as to manually apply each typing rule, reduction, etc. Basically to see and interact with what is going on behind the scenes. And then see what is changed by adding polymorphism, etc.</p>\n</blockquote>\n<p>Is this possible, or maybe does it already exist?</p>",
        "id": 240856928,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622482540
    },
    {
        "content": "<p>Maybe Lean metaprogramming would interest you? I don't know much about it, but if I understand correctly it exposes the Lean implementation of these constructions to you, within Lean, so that you can play around with them and see what happens internally. I don't know about simply typed fragments and so on.</p>",
        "id": 240858209,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622483599
    },
    {
        "content": "<p>Or do you mean a full formalization in the sense of defining these systems in Lean and proving stuff about them?</p>",
        "id": 240858371,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1622483727
    },
    {
        "content": "<p>Yes, a full formalization in Lean or Coq. I'm not as interested in proving stuff about them as in being able to do stuff like see how a term is typed or reduced step by step. Doing something like this more formally:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">1</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">|-</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">;</span> <span class=\"n\">Var</span>\n<span class=\"mi\">2</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">;</span> <span class=\"n\">Var</span>\n<span class=\"mi\">3</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">|-</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">;</span> <span class=\"n\">Var</span>\n<span class=\"mi\">4</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">;</span> <span class=\"n\">App</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span>\n<span class=\"mi\">5</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">|-</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">;</span> <span class=\"n\">App</span> <span class=\"mi\">1</span> <span class=\"mi\">4</span>\n<span class=\"mi\">6</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">|-</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">;</span> <span class=\"n\">Lam</span> <span class=\"mi\">5</span>\n<span class=\"mi\">7</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">|-</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">;</span> <span class=\"n\">Lam</span> <span class=\"mi\">6</span>\n<span class=\"mi\">8</span><span class=\"bp\">.</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">|-</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">))</span> <span class=\"bp\">;</span> <span class=\"n\">Lam</span> <span class=\"mi\">7</span>\n</code></pre></div>",
        "id": 240859119,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622484363
    },
    {
        "content": "<p>It sounds like playing around with <code>expr</code> is close to what you want.</p>",
        "id": 240859200,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622484429
    },
    {
        "content": "<p>(I.e., the metaprogramming suggestion by Horatiu above.)</p>",
        "id": 240859211,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622484442
    },
    {
        "content": "<p>Hmm. Where could I find more info?</p>",
        "id": 240859349,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622484551
    },
    {
        "content": "<p>The tactic writing tutorial, the youtube tutorial on metaprogramming by Rob Lewis, and here on zulip</p>",
        "id": 240859599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622484804
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 240859797,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622484967
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"139442\">@Patrick Thomas</span> ooh, you could also work with Lean 4. It's mostly implemented in Lean 4 itself.</p>",
        "id": 240859848,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622485050
    },
    {
        "content": "<p>Nice.</p>",
        "id": 240859935,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622485129
    },
    {
        "content": "<p>I'll take a look.</p>",
        "id": 240859953,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622485145
    },
    {
        "content": "<p>Hmm. It looks like the kernel is in C++.</p>",
        "id": 240860531,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622485616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/stlc.20terms/near/240803763\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/stlc.20terms/near/240795974\">said</a>:</p>\n<blockquote>\n<p>Interesting. So Coq and Lean and similar programs use Church style typing?</p>\n</blockquote>\n<p>Yes. The key difference with church style typing is that a type appears in the term constructor for lambda, <code>\\lam x: T, e</code> rather than an unspecified <code>\\lam x, e</code> like in your original inductive type</p>\n</blockquote>\n<p>Do you also mean that Coq and Lean use a formalization like the one given by Horatiu?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ty</span>\n<span class=\"bp\">|</span> <span class=\"n\">some_constant_type</span> <span class=\"o\">:</span> <span class=\"n\">ty</span>\n<span class=\"bp\">|</span> <span class=\"n\">function_type</span> <span class=\"o\">:</span> <span class=\"n\">ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ty</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`==&gt;`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">ty.function_type</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ty</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">term</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">term</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 240878556,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1622502724
    },
    {
        "content": "<p>No, application does not have type arguments. See <code>expr.app</code>. But lambda does.</p>",
        "id": 240898738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622528193
    },
    {
        "content": "<p>Is this correct (in Haskell)? Are the types for the var term and the bound variable in the abs term the same or should they differ?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span> <span class=\"kt\">Nat</span> <span class=\"ow\">=</span> <span class=\"kt\">O</span> <span class=\"o\">|</span> <span class=\"kt\">S</span> <span class=\"kt\">Nat</span>\n  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Type</span> <span class=\"ow\">=</span> <span class=\"kt\">Atomic</span> <span class=\"o\">|</span> <span class=\"kt\">Arrow</span> <span class=\"kt\">Type</span> <span class=\"kt\">Type</span>\n  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"kt\">Nat</span> <span class=\"o\">|</span> <span class=\"kt\">App</span> <span class=\"kt\">Term</span> <span class=\"kt\">Term</span> <span class=\"o\">|</span> <span class=\"kt\">Abs</span> <span class=\"kt\">Nat</span> <span class=\"kt\">Type</span> <span class=\"kt\">Term</span>\n  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n\n\n<span class=\"kr\">type</span> <span class=\"kt\">Expr</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"kt\">Term</span><span class=\"p\">,</span> <span class=\"kt\">Type</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Context</span> <span class=\"ow\">=</span> <span class=\"p\">[</span><span class=\"kt\">Expr</span><span class=\"p\">]</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Proof</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"kt\">Context</span><span class=\"p\">,</span> <span class=\"kt\">Expr</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\">-- Typing rules</span>\n\n<span class=\"nf\">applyVar</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Expr</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Proof</span>\n<span class=\"nf\">applyVar</span> <span class=\"n\">c</span> <span class=\"n\">e</span> <span class=\"ow\">=</span> <span class=\"kr\">if</span> <span class=\"n\">elem</span> <span class=\"n\">e</span> <span class=\"n\">c</span> <span class=\"kr\">then</span> <span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">)</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"bad input\"</span>\n\n<span class=\"nf\">applyApp</span> <span class=\"ow\">::</span> <span class=\"kt\">Proof</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Proof</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Proof</span>\n<span class=\"nf\">applyApp</span> <span class=\"p\">(</span><span class=\"n\">c1</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"kt\">Arrow</span> <span class=\"n\">s11</span> <span class=\"n\">s12</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"n\">c2</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">s2</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"kr\">if</span> <span class=\"n\">c1</span> <span class=\"o\">==</span> <span class=\"n\">c2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">s11</span> <span class=\"o\">==</span> <span class=\"n\">s2</span> <span class=\"kr\">then</span> <span class=\"p\">(</span><span class=\"n\">c1</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">App</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">s12</span><span class=\"p\">))</span> <span class=\"kr\">else</span> <span class=\"ne\">error</span> <span class=\"s\">\"bad input\"</span>\n<span class=\"nf\">applyApp</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"bad input\"</span>\n\n<span class=\"nf\">applyAbs</span> <span class=\"ow\">::</span> <span class=\"kt\">Proof</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Proof</span>\n<span class=\"nf\">applyAbs</span> <span class=\"p\">(((</span><span class=\"kt\">Var</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">s1</span><span class=\"p\">)</span> <span class=\"kt\">:</span> <span class=\"n\">es</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">s2</span><span class=\"p\">))</span> <span class=\"ow\">=</span> <span class=\"p\">(</span><span class=\"n\">es</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Abs</span> <span class=\"n\">v</span> <span class=\"n\">s1</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"kt\">Arrow</span> <span class=\"n\">s1</span> <span class=\"n\">s2</span><span class=\"p\">))</span>\n<span class=\"nf\">applyAbs</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"ne\">error</span> <span class=\"s\">\"bad input\"</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Example:</span>\n\n<span class=\"cm\">*Main&gt; applyApp (applyVar [(Var O, Arrow Atomic Atomic), (Var (S O), Atomic)] (Var O, (Arrow Atomic Atomic))) (applyVar [(Var O, Arrow Atomic Atomic), (Var (S O), Atomic)] (Var (S O), Atomic))</span>\n<span class=\"cm\">([(Var O,Arrow Atomic Atomic),(Var (S O),Atomic)],(App (Var O) (Var (S O)),Atomic))</span>\n<span class=\"cm\">-}</span>\n</code></pre></div>",
        "id": 241988211,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623187283
    },
    {
        "content": "<p>I think you want <code>applyVar</code> and similar definitions to return the type of the expression, rather than returning a context</p>",
        "id": 241988503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623187446
    },
    {
        "content": "<p>the context should be an additional argument to all the functions like a reader monad</p>",
        "id": 241988524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623187465
    },
    {
        "content": "<p>Your typing rules allow a single variable to have multiple types, which is not correct, or at least will significantly complicate substitution</p>",
        "id": 241988899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623187669
    },
    {
        "content": "<p>Are you thinking in terms of how to make it get the type of a given expression in a given context?</p>",
        "id": 241989148,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623187796
    },
    {
        "content": "<p>yes, typecheckers usually have two functions, mutually defined: give me the type of a term, or check that this term has this type. The signatures are something like <code>Context -&gt; Term -&gt; option Type</code> and <code>Context -&gt; Term -&gt; Type -&gt; bool</code></p>",
        "id": 241989693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623188049
    },
    {
        "content": "<p>the second one is easily defined in terms of the first:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">infer</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Maybe</span> <span class=\"kt\">Type</span>\n<span class=\"o\">...</span>\n\n<span class=\"nf\">check</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Bool</span>\n<span class=\"nf\">check</span> <span class=\"n\">c</span> <span class=\"n\">e</span> <span class=\"n\">ty</span> <span class=\"ow\">=</span> <span class=\"kr\">case</span> <span class=\"n\">infer</span> <span class=\"n\">c</span> <span class=\"n\">e</span> <span class=\"kr\">of</span>\n  <span class=\"kt\">Just</span> <span class=\"n\">t</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">t</span> <span class=\"ow\">=</span> <span class=\"n\">ty</span>\n  <span class=\"kt\">Nothing</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">False</span>\n</code></pre></div>",
        "id": 241989967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623188173
    },
    {
        "content": "<p>If you use <code>error</code> for error handling, then these can have type <code>Type</code> and <code>Unit</code> respectively, although that might cause haskell to delete calls to the unit function</p>",
        "id": 241990150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623188272
    },
    {
        "content": "<p>I see. I wasn't going for a type checker, but that was going to be the next attempt. Thank you. Do I have the data definitions right, especially in regard to the types for the var term and the bound variable in the abs term? Are the var terms just identifiers that can be added to the context and used as bound variables in abstraction?</p>",
        "id": 241990505,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623188437
    },
    {
        "content": "<p>There are two general approaches here, known as \"named variables\" vs \"de bruijn variables\". You are using the \"named variables\" approach, even though the names are numbers here (they could be strings as well). The named variables approach has the advantage that you don't need to define or think about \"lifting\" terms when they go under a binder, but you do have to check for bound variable capture. de Bruijn variables refer to a binder by the number of nested binders, which makes alpha renaming and substitution a bit easier but adds lifting, and also makes it harder to read the resulting terms because the names of variables are implicit</p>",
        "id": 241992261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623188957
    },
    {
        "content": "<p>If you were to use the de bruijn variables approach, <code>Abs</code> would look like <code>Abs Type Term</code>, with no <code>Nat</code> argument since it always introduces the variable now named 0 and everything else shifts up</p>",
        "id": 241992380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623189015
    },
    {
        "content": "<p>I see. So the Term and Type data definitions are right for the named variables approach? I think Coq and Lean use de bruijn variables?</p>",
        "id": 241992880,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623189334
    },
    {
        "content": "<p>Yes. Lean uses a combination of named and de bruijn variables called \"locally nameless\": variables inside a term are de bruijn, but binders are \"opened\" when they enter the local context, at which point they are replaced with \"local constants\" that are basically named variables</p>",
        "id": 241994045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623190038
    },
    {
        "content": "<p>HOL Light implements STLC using the named variables approach</p>",
        "id": 241994165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623190109
    },
    {
        "content": "<p>Interesting. Thank you!</p>",
        "id": 241994469,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623190259
    },
    {
        "content": "<p>Is there a base type built into the STLC for Coq and Lean, or do inductive types take the place of that?</p>",
        "id": 241997092,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623192097
    },
    {
        "content": "<p>Base types are only needed when there are no type constructors other than things like arrow. Practical systems will usually have some specific types there. Lean has a bunch of \"base types\": <code>Type u</code> and <code>Prop</code>, inductive types, and axiomatic constants</p>",
        "id": 241997480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623192437
    },
    {
        "content": "<p>HOL Light has <code>bool</code> (aka <code>Prop</code>) and <code>ind</code> (an infinite type used to build <code>nat</code>) as base types</p>",
        "id": 241997620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623192539
    },
    {
        "content": "<p>And types also become included as terms as an extension to the STLC?</p>",
        "id": 241997963,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623192824
    },
    {
        "content": "<p>In dependently typed languages, types are also terms, so lambda and variables also appear as types</p>",
        "id": 241999031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623193614
    },
    {
        "content": "<p>well, even plain STLC often has type variables, but they are a separate class from regular variables. That's probably closer to HOL though</p>",
        "id": 241999121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623193683
    },
    {
        "content": "<p>It's not like adding another constructor like <code>data Term = Var Nat | App Term Term | Abs Nat Type Term | TypeC Type</code>?</p>",
        "id": 241999827,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623194289
    },
    {
        "content": "<p>No, in DTT you have one inductive type containing all of the constructors of <code>Type</code> and <code>Term</code></p>",
        "id": 242001800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623196033
    },
    {
        "content": "<p>that has the side effect of making <code>Abs</code> a type constructor and <code>Arrow</code> a term constructor, because the two syntactic classes are unified</p>",
        "id": 242001822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623196064
    },
    {
        "content": "<p>If you have an embedding like <code>TypeC</code> that only means that every type is a term, but doesn't permit using <code>App</code> and <code>Abs</code> in types</p>",
        "id": 242001916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623196142
    },
    {
        "content": "<p>for example <code>list A</code> is a type in lean which can be rendered <code>App (Const \"List\") (Var 0)</code>, where <code>App</code> is the same <code>App</code> as used on terms</p>",
        "id": 242001963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623196196
    },
    {
        "content": "<p>You couldn't use <code>App (TypeC (Const \"List\")) ((TypeC (Var 0))</code>?<br>\nWould unifying them like that imply that every term is a type? That isn't true right?</p>",
        "id": 242002354,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623196503
    },
    {
        "content": "<p>That would be a <code>Term</code>, but not a <code>Type</code></p>",
        "id": 242002710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623196843
    },
    {
        "content": "<p>we want <code>List A</code> to be a type</p>",
        "id": 242002726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623196858
    },
    {
        "content": "<p>I see. But does unifying them in one inductive type remove the distinction between terms and types altogether? Aren't there base terms that are not types?</p>",
        "id": 242003018,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623197120
    },
    {
        "content": "<p>I thought all types were terms, but not all terms were types.</p>",
        "id": 242003045,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623197157
    },
    {
        "content": "<p>Is this right? Do I need to worry about the fact that inserting a value into the context that already has the value does not give an error, but overwrites the existing type for it?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"c1\">-- Modified from https://softwarefoundations.cis.upenn.edu/plf-current/Typechecking.html</span>\n\n<span class=\"kr\">import</span> <span class=\"nn\">Data.Map</span>\n\n\n<span class=\"kr\">data</span> <span class=\"kt\">Type</span> <span class=\"ow\">=</span> <span class=\"kt\">Atomic</span> <span class=\"o\">|</span> <span class=\"kt\">Arrow</span> <span class=\"kt\">Type</span> <span class=\"kt\">Type</span>\n  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n\n<span class=\"kr\">data</span> <span class=\"kt\">Term</span> <span class=\"ow\">=</span> <span class=\"kt\">Var</span> <span class=\"kt\">String</span> <span class=\"o\">|</span> <span class=\"kt\">App</span> <span class=\"kt\">Term</span> <span class=\"kt\">Term</span> <span class=\"o\">|</span> <span class=\"kt\">Abs</span> <span class=\"kt\">String</span> <span class=\"kt\">Type</span> <span class=\"kt\">Term</span>\n  <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n\n\n<span class=\"kr\">type</span> <span class=\"kt\">Context</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"kt\">Map</span> <span class=\"kt\">String</span> <span class=\"kt\">Type</span>\n\n\n<span class=\"nf\">getType</span> <span class=\"ow\">::</span> <span class=\"kt\">Context</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Term</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Maybe</span> <span class=\"kt\">Type</span>\n<span class=\"nf\">getType</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"kt\">Var</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">lookup</span> <span class=\"n\">v</span> <span class=\"n\">gamma</span>\n<span class=\"nf\">getType</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"kt\">App</span> <span class=\"n\">tm1</span> <span class=\"n\">tm2</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"kr\">case</span> <span class=\"p\">(</span><span class=\"n\">getType</span> <span class=\"n\">gamma</span> <span class=\"n\">tm1</span><span class=\"p\">,</span> <span class=\"n\">getType</span> <span class=\"n\">gamma</span> <span class=\"n\">tm2</span><span class=\"p\">)</span> <span class=\"kr\">of</span>\n    <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"p\">(</span><span class=\"kt\">Arrow</span> <span class=\"n\">ty11</span> <span class=\"n\">ty12</span><span class=\"p\">),</span> <span class=\"kt\">Just</span> <span class=\"n\">ty2</span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span>\n      <span class=\"kr\">if</span> <span class=\"n\">ty11</span> <span class=\"o\">==</span> <span class=\"n\">ty2</span> <span class=\"kr\">then</span> <span class=\"kt\">Just</span> <span class=\"n\">ty12</span> <span class=\"kr\">else</span> <span class=\"kt\">Nothing</span>\n    <span class=\"kr\">_</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Nothing</span>\n<span class=\"nf\">getType</span> <span class=\"n\">gamma</span> <span class=\"p\">(</span><span class=\"kt\">Abs</span> <span class=\"n\">v</span> <span class=\"n\">ty1</span> <span class=\"n\">tm1</span><span class=\"p\">)</span> <span class=\"ow\">=</span>\n  <span class=\"kr\">let</span> <span class=\"n\">gamma'</span> <span class=\"ow\">=</span> <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Map</span><span class=\"o\">.</span><span class=\"n\">insert</span> <span class=\"n\">v</span> <span class=\"n\">ty1</span> <span class=\"n\">gamma</span> <span class=\"kr\">in</span>\n  <span class=\"kr\">case</span> <span class=\"n\">getType</span> <span class=\"n\">gamma'</span> <span class=\"n\">tm1</span> <span class=\"kr\">of</span>\n    <span class=\"kt\">Just</span> <span class=\"n\">ty2</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Just</span> <span class=\"p\">(</span><span class=\"kt\">Arrow</span> <span class=\"n\">ty1</span> <span class=\"n\">ty2</span><span class=\"p\">)</span>\n    <span class=\"kr\">_</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Nothing</span>\n\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Examples:</span>\n\n<span class=\"cm\">*Main&gt; getType (Data.Map.fromList [(\"a\", Atomic)]) (Var \"a\")</span>\n<span class=\"cm\">Just Atomic</span>\n\n<span class=\"cm\">*Main&gt; getType (Data.Map.fromList [(\"a\", Atomic), (\"b\", (Arrow Atomic Atomic))]) (App (Var \"b\") (Var \"a\"))</span>\n<span class=\"cm\">Just Atomic</span>\n\n<span class=\"cm\">*Main&gt; getType (Data.Map.fromList [(\"b\", Atomic)]) (Abs \"a\" Atomic (Var \"b\"))</span>\n<span class=\"cm\">Just (Arrow Atomic Atomic)</span>\n<span class=\"cm\">-}</span>\n</code></pre></div>",
        "id": 242012825,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623207487
    },
    {
        "content": "<p>I can't prove anything with this in its current form, correct? Not even limited propositional logic? What is the next minimal extension required to do that?</p>",
        "id": 242147274,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623284745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/stlc.20terms/near/242003018\">said</a>:</p>\n<blockquote>\n<p>I see. But does unifying them in one inductive type remove the distinction between terms and types altogether? Aren't there base terms that are not types?</p>\n</blockquote>\n<p>In DTT, the distinction between types and terms is a matter of typechecking, not syntax. A type is something whose type is <code>*</code> (in a haskell like language) or <code>Sort u</code> for lean</p>",
        "id": 242147447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623284932
    },
    {
        "content": "<p>I see.</p>",
        "id": 242147488,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623285000
    },
    {
        "content": "<blockquote>\n<p>Is this right? Do I need to worry about the fact that inserting a value into the context that already has the value does not give an error, but overwrites the existing type for it?</p>\n</blockquote>\n<p>That's okay as long as the updates to the context are functional / temporary within a scope. Once you are out of the scope with the shadowed variable the variable needs to go back to its old type</p>",
        "id": 242147551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285041
    },
    {
        "content": "<p>you can also accomplish this by keeping the context as an ordered list and doing linear search when looking variables up in the context</p>",
        "id": 242147575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285099
    },
    {
        "content": "<p>In haskell the former approach is easier since <code>Data.Map</code> is already a persistent map, and that's what you did</p>",
        "id": 242147669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285180
    },
    {
        "content": "<p>your typechecker looks correct</p>",
        "id": 242147753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Patrick Thomas</span> <a href=\"#narrow/stream/113489-new-members/topic/stlc.20terms/near/242147274\">said</a>:</p>\n<blockquote>\n<p>I can't prove anything with this in its current form, correct? Not even limited propositional logic? What is the next minimal extension required to do that?</p>\n</blockquote>\n<p>Well it's haskell, so no</p>",
        "id": 242147766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285265
    },
    {
        "content": "<p>You can just transpose all of this to lean though</p>",
        "id": 242147777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285279
    },
    {
        "content": "<p>You mean no type checker I write in Haskell can prove propositional logic? Because Haskell itself can't prove propositional logic?</p>",
        "id": 242147820,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623285325
    },
    {
        "content": "<p>I mean if you want to prove the correctness of the typechecker</p>",
        "id": 242147832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285344
    },
    {
        "content": "<p>If you want to write a prover in haskell that works fine</p>",
        "id": 242147852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285358
    },
    {
        "content": "<p>Oh. No, I'm not worried about formally checking it. This is more a learning exercise for now.</p>",
        "id": 242147915,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623285403
    },
    {
        "content": "<p>If you want to extend STLC to intuitionistic logic you need some more constructors like and / or</p>",
        "id": 242147919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623285415
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> to <a class=\"stream-topic\" data-stream-id=\"236446\" href=\"/#narrow/stream/236446-Type-theory/topic/stlc.20terms\">#Type theory &gt; stlc terms</a></p>",
        "id": 242150783,
        "sender_full_name": "Notification Bot",
        "timestamp": 1623288748
    },
    {
        "content": "<p>I'm not sure what happened. If I click on the topic in Type theory there is no history.</p>",
        "id": 242150877,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623288857
    },
    {
        "content": "<p>and <code>getType _ trivial = Just True</code>?</p>",
        "id": 242150973,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623288986
    },
    {
        "content": "<p>you sure about that?</p>",
        "id": 242150975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623288996
    },
    {
        "content": "<p>I see the history, try reloading</p>",
        "id": 242150979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1623289005
    },
    {
        "content": "<p>Ok. Yes, needed to reload.</p>",
        "id": 242151001,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1623289048
    }
]
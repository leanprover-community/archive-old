[
    {
        "content": "<p>Hi, all.</p>\n<p>I am interested in the problem of how does theorem provers based on DTT, such as Lean,  make change to type judgment according to assumptions, such as in the example below, or if it is possible at all.</p>\n<p>If the goal looks like<br>\na: A-&gt;B<br>\np: A = B</p>\n<hr>\n<p>phi</p>\n<p>I want the goal to become:</p>\n<p>a:B-&gt;B<br>\n(p:B= B here, or whatever, I only care about a:A-&gt;B is substituted into a:B-&gt;B according to the assumption B=B,)</p>\n<hr>\n<p>phi</p>\n<p>My main quest is that I want the a : B-&gt;B, to be literally the same as the ones in the original goal, that is, I do not want an argument such like: the path p:A=B induces a function (A -&gt;B) -&gt; (B -&gt;B), so we can feed a as an argument to this function, and get a term a':B-&gt;B, and we can rename a' into a. </p>\n<p>Instead, I want just to substitute all the occurrences of A in the assumptions directly into B, and if the goal looks like:</p>\n<p>a:A-&gt;B<br>\na': \\sum_{x:A} P(x)<br>\na'':\\prod_{x:A} P(x)<br>\nA = B</p>\n<hr>\n<p>phi</p>\n<p>I want the goal to become</p>\n<p>a:B-&gt;B<br>\na': \\sum_{x:B} P(x)<br>\na'':\\prod_{x:B} P(x)<br>\nB = B</p>\n<hr>\n<p>phi</p>\n<p>according to the assumption B = B, where a, a', a'' are all literally the same as the original goal, we just make changes to the type annotation of them.</p>\n<p>According to my experience in a non-dependent typed theorem prover, a \"direct substitution\" will appeal to equalities such as \"a:A-&gt;B = a:B-&gt;B\", and I am confused because such equality is in principle not well-formed at all because the LHS and RHS are not obviously of the same type. </p>\n<p>Is making such direct substitution on type-judgment possible in Lean (or in some other DTT theorem provers) whose type information can depend on assumption? If it does, which rule enables us to do this?</p>",
        "id": 244516879,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625113242
    },
    {
        "content": "<p>I'll try to give my understanding here, but I am far from being an expert, so take it with a grain of salt. I'll use the simpler example of <code>a : A</code> instead of <code>a : A -&gt; B</code> because I think the idea is the same if I understand your question correctly.</p>\n<p>If <code>a : A</code> then that's it, it can't be of any other type, even with <code>A = B</code>, unless the <code>A</code> and <code>B</code> are definitionally equal, in which case they are really the same thing, as far as Lean is concerned. So in Lean any term has precisely one type (up to definitional equality). So no, I don't think you can <em>just</em> do such substitutions. </p>\n<p>Such substitutions are performed through \"functions generated paths arguments\" as you called them and that you wanted to avoid. Particularly, in Lean it's all based on <code>eq.rec</code>, the recursor on equalities, which allows you do this kind of things, and whose type also kind of looks like a substitution rule for equality. But still, such substituted terms will ultimately still be <code>eq.rec</code> of something, or other type cast variations based on it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">eq.rec</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n</code></pre></div>\n<blockquote>\n<p>According to my experience in a non-dependent typed theorem prover, a \"direct substitution\" will appeal to equalities such as \"a:A-&gt;B = a:B-&gt;B\", and I am confused because such equality is in principle not well-formed at all because the LHS and RHS are not obviously of the same type. </p>\n</blockquote>\n<p>I don't think I understand what you mean here by a direct substitition appealing to equalites. But indeed, that equality won't typecheck. And even before that you can't have (a : A -&gt; B) <em>and</em> (a : B -&gt; B), one of them will have to be a cast.</p>\n<p>On the other hand, when writing in tactic mode, some tactics do appear to transform the proof state as you describe. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f1</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A B : Type,</span>\n<span class=\"cm\">  a : A,</span>\n<span class=\"cm\">  h : A = B</span>\n<span class=\"cm\">  ⊢ B</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A : Type,</span>\n<span class=\"cm\">  a : A</span>\n<span class=\"cm\">  ⊢ A</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">A B : Type,</span>\n<span class=\"cm\">a : A,</span>\n<span class=\"cm\">h : A = B</span>\n<span class=\"cm\">⊢ B</span>\n<span class=\"cm\">-/</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A B : Type,</span>\n<span class=\"cm\">  h : A = B,</span>\n<span class=\"cm\">  a : B</span>\n<span class=\"cm\">  ⊢ B</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't really know how these tactis work internally, but the term they generate in the end will still involve some kind of type casting through <code>eq</code>, and things you saw happening to the goal are not really what happens internally, but rather some goal-view tricks meant to hide all this from you.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">f1</span>\n<span class=\"kd\">def</span> <span class=\"n\">f1</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">eq.rec</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">f2</span>\n<span class=\"kd\">def</span> <span class=\"n\">f2</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">eq.mp</span> <span class=\"n\">_</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 244523417,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1625120449
    },
    {
        "content": "<p>That's all Lean specific of course, but I believe most of it applies to other DTT proof assistants based on CIC (like Coq) or to HoTT. <br>\nMaybe in extensional type theory you can have such direct substitutions, but I know virtually nothing about that</p>",
        "id": 244523656,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1625120674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209370\">Yiming Xu</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244516879\">said</a>:</p>\n<blockquote>\n<p>I only care about a:A-&gt;B is substituted into a:B-&gt;B according to the assumption B=B,)</p>\n</blockquote>\n<p>If you're saying the assumption has changed from <code>A=B</code> to <code>B=B</code>, it sounds like you might be talking about bound variable substitution for a polymorphic definition?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myDef</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">phi</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">myDef</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">phi</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">myDef</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"n\">goal</span> <span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span>\n<span class=\"n\">phi</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">phi</span>\n</code></pre></div>",
        "id": 244527012,
        "sender_full_name": "Chris B",
        "timestamp": 1625123611
    },
    {
        "content": "<blockquote>\n<p>My main quest is that I want the a : B-&gt;B, to be literally the same as the ones in the original goal</p>\n</blockquote>\n<p>But <code>p : A = B</code> does not mean \"A is literally the same as B\", it means nothing more than \"<code>p</code> is a term of the inductive type <code>eq A B</code>\". Would you say that <code>x + y</code> is <em>literally the same as</em> <code>y + x</code>, if <code>x</code> and <code>y</code> are natural numbers?</p>",
        "id": 244528367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625124628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244528367\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>My main quest is that I want the a : B-&gt;B, to be literally the same as the ones in the original goal</p>\n</blockquote>\n<p>But <code>p : A = B</code> does not mean \"A is literally the same as B\", it means nothing more than \"<code>p</code> is a term of the inductive type <code>eq A B</code>\". Would you say that <code>x + y</code> is <em>literally the same as</em> <code>y + x</code>, if <code>x</code> and <code>y</code> are natural numbers?</p>\n</blockquote>\n<p>Yes, <code>p : A = B</code> means <code>p</code> is a term of the inductive type <code>eq A B</code>, this is specific for DTT. I had trouble in a somehow weird workspace, and I am trying to grab idea from DTT for solving this, in my setting, I just have equality, so I do not have things like p: A = B, but just A = B, so I am trying to ignore the (which I agree that is helpful...) viewpoint that \"p is a term of eq A B\".</p>\n<p>To be specific, I am mainly interested in the cases which causes the A and B are literally the same. The two cases I can think of which I care about is:</p>\n<p>1.Abbrevation: That is, A is a type with complicated construction, say, it is a huge combination of Pi and Sum, and we want to give it an abbreviation, so we do not need to write it out everywhere. In HOL4, it is a tactic called abbrev_tac, such that you can write abbrev_tac <code>A = B</code>, and it substitute the A into B everywhere in the goal. In this case, A and B are literally the same. </p>\n<p>2.inputs equal results in that the output of function is equal: say, I have two arrows f,g:A-&gt;B. after proving f = g, I want all occurrences of the \"equalizer of f and g\" to become \"equalizer of f and f\", they should be literally the same as well.</p>",
        "id": 244530061,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625125811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244523417\">said</a>:</p>\n<blockquote>\n<p>I'll try to give my understanding here, but I am far from being an expert, so take it with a grain of salt. I'll use the simpler example of <code>a : A</code> instead of <code>a : A -&gt; B</code> because I think the idea is the same if I understand your question correctly.</p>\n<p>If <code>a : A</code> then that's it, it can't be of any other type, even with <code>A = B</code>, unless the <code>A</code> and <code>B</code> are definitionally equal, in which case they are really the same thing, as far as Lean is concerned. So in Lean any term has precisely one type (up to definitional equality). So no, I don't think you can <em>just</em> do such substitutions. </p>\n<p>Such substitutions are performed through \"functions generated paths arguments\" as you called them and that you wanted to avoid. Particularly, in Lean it's all based on <code>eq.rec</code>, the recursor on equalities, which allows you do this kind of things, and whose type also kind of looks like a substitution rule for equality. But still, such substituted terms will ultimately still be <code>eq.rec</code> of something, or other type cast variations based on it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">eq.rec</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n</code></pre></div>\n<blockquote>\n<p>According to my experience in a non-dependent typed theorem prover, a \"direct substitution\" will appeal to equalities such as \"a:A-&gt;B = a:B-&gt;B\", and I am confused because such equality is in principle not well-formed at all because the LHS and RHS are not obviously of the same type. </p>\n</blockquote>\n<p>I don't think I understand what you mean here by a direct substitition appealing to equalites. But indeed, that equality won't typecheck. And even before that you can't have (a : A -&gt; B) <em>and</em> (a : B -&gt; B), one of them will have to be a cast.</p>\n<p>On the other hand, when writing in tactic mode, some tactics do appear to transform the proof state as you describe. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f1</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A B : Type,</span>\n<span class=\"cm\">  a : A,</span>\n<span class=\"cm\">  h : A = B</span>\n<span class=\"cm\">  ⊢ B</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A : Type,</span>\n<span class=\"cm\">  a : A</span>\n<span class=\"cm\">  ⊢ A</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">A B : Type,</span>\n<span class=\"cm\">a : A,</span>\n<span class=\"cm\">h : A = B</span>\n<span class=\"cm\">⊢ B</span>\n<span class=\"cm\">-/</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A B : Type,</span>\n<span class=\"cm\">  h : A = B,</span>\n<span class=\"cm\">  a : B</span>\n<span class=\"cm\">  ⊢ B</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't really know how these tactis work internally, but the term they generate in the end will still involve some kind of type casting through <code>eq</code>, and things you saw happening to the goal are not really what happens internally, but rather some goal-view tricks meant to hide all this from you.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">f1</span>\n<span class=\"kd\">def</span> <span class=\"n\">f1</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">eq.rec</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">f2</span>\n<span class=\"kd\">def</span> <span class=\"n\">f2</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">eq.mp</span> <span class=\"n\">_</span> <span class=\"n\">a</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you!  In your example where you used <code>exact a</code> where Lean asks for a term <code>B</code>, to me it really looks like Lean allows you to use <code>a</code> as of type <code>B</code>,  the eq.rec stuff looks relevant! I would search for how rw uses it.</p>",
        "id": 244531606,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625126725
    },
    {
        "content": "<p>The first case you can do in Lean by declaring a definition. The corresponding rule in the theory is called delta reduction. In that case, the long version and the short version are definitionally equal, which is like a \"literally the same as\" relation which is respected by the kernel.</p>\n<p>In the second case, if <code>f</code> and <code>g</code> aren't definitionally equal, then you can't substitute them without the stuff you said you wanted to avoid (the eq.rec stuff).</p>",
        "id": 244531615,
        "sender_full_name": "Chris B",
        "timestamp": 1625126730
    },
    {
        "content": "<p>There are also <code>let short := long</code> expressions, which also get unfolded. The rule for those is called zeta reduction.</p>",
        "id": 244531906,
        "sender_full_name": "Chris B",
        "timestamp": 1625126887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244531615\">said</a>:</p>\n<blockquote>\n<p>The first case you can do in Lean by declaring a definition. The corresponding rule in the theory is called delta reduction. In that case, the long version and the short version are definitionally equal, which is like a \"literally the same as\" relation which is respected by the kernel.</p>\n<p>In the second case, if <code>f</code> and <code>g</code> aren't definitionally equal, then you can't substitute them without the stuff you said you wanted to avoid (the eq.rec stuff).</p>\n</blockquote>\n<p>Thanks for the quick reply! I will check for the rules and think about them. It is a bit sad that the second case must involve eq.rec stuff though. I have not done enough reading on stuff on <code>delta reduction/zeta reduction</code> yet (I will have a look at them), but at first glance it sounds to me that they are the thing that happens in the meta-level, and is not a part of Lean core logic, but the thing which is done by the language which Lean is written in.</p>",
        "id": 244532695,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625127428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244523417\">said</a>:</p>\n<blockquote>\n<p>I'll try to give my understanding here, but I am far from being an expert, so take it with a grain of salt. I'll use the simpler example of <code>a : A</code> instead of <code>a : A -&gt; B</code> because I think the idea is the same if I understand your question correctly.</p>\n<p>If <code>a : A</code> then that's it, it can't be of any other type, even with <code>A = B</code>, unless the <code>A</code> and <code>B</code> are definitionally equal, in which case they are really the same thing, as far as Lean is concerned. So in Lean any term has precisely one type (up to definitional equality). So no, I don't think you can <em>just</em> do such substitutions. </p>\n<p>Such substitutions are performed through \"functions generated paths arguments\" as you called them and that you wanted to avoid. Particularly, in Lean it's all based on <code>eq.rec</code>, the recursor on equalities, which allows you do this kind of things, and whose type also kind of looks like a substitution rule for equality. But still, such substituted terms will ultimately still be <code>eq.rec</code> of something, or other type cast variations based on it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">eq.rec</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n</code></pre></div>\n<blockquote>\n<p>According to my experience in a non-dependent typed theorem prover, a \"direct substitution\" will appeal to equalities such as \"a:A-&gt;B = a:B-&gt;B\", and I am confused because such equality is in principle not well-formed at all because the LHS and RHS are not obviously of the same type. </p>\n</blockquote>\n<p>I don't think I understand what you mean here by a direct substitition appealing to equalites. But indeed, that equality won't typecheck. And even before that you can't have (a : A -&gt; B) <em>and</em> (a : B -&gt; B), one of them will have to be a cast.</p>\n<p>On the other hand, when writing in tactic mode, some tactics do appear to transform the proof state as you describe. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f1</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A B : Type,</span>\n<span class=\"cm\">  a : A,</span>\n<span class=\"cm\">  h : A = B</span>\n<span class=\"cm\">  ⊢ B</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A : Type,</span>\n<span class=\"cm\">  a : A</span>\n<span class=\"cm\">  ⊢ A</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">A B : Type,</span>\n<span class=\"cm\">a : A,</span>\n<span class=\"cm\">h : A = B</span>\n<span class=\"cm\">⊢ B</span>\n<span class=\"cm\">-/</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  A B : Type,</span>\n<span class=\"cm\">  h : A = B,</span>\n<span class=\"cm\">  a : B</span>\n<span class=\"cm\">  ⊢ B</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't really know how these tactis work internally, but the term they generate in the end will still involve some kind of type casting through <code>eq</code>, and things you saw happening to the goal are not really what happens internally, but rather some goal-view tricks meant to hide all this from you.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">f1</span>\n<span class=\"kd\">def</span> <span class=\"n\">f1</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">eq.rec</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">f2</span>\n<span class=\"kd\">def</span> <span class=\"n\">f2</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">eq.mp</span> <span class=\"n\">_</span> <span class=\"n\">a</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Maybe my parse of \"direct substitution\" is confusing, and maybe it is a wrong phrase. I was thinking of how a usual rewrite tactic work: It is provided an equality, and it looks for the LHS of equality in a goal, and substitute it into the RHS of such equality.</p>",
        "id": 244533369,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625127947
    },
    {
        "content": "<p>I mean you <em>can</em> do these with the <code>rw</code> tactic, but they do make use of the recursor for eq.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 244534986,
        "sender_full_name": "Chris B",
        "timestamp": 1625129020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244534986\">said</a>:</p>\n<blockquote>\n<p>I mean you <em>can</em> do these with the <code>rw</code> tactic, but they do make use of the recursor for eq.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes, I understand that rw can do this. It is reasonable that Leans's rw has access to eq recursor. I should say is that the thing in my mind is a non-DTT rw, I would try have a look how Lean's rw use the eq.</p>",
        "id": 244538944,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625131215
    },
    {
        "content": "<p>Just out of curiosity, in what non-DTT setting are you more specifically working?</p>",
        "id": 244540049,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1625131821
    },
    {
        "content": "<p>Perhaps it'll be helpful to talk a bit about why intensional dependent type theory (ITT) doesn't let you do something like this. Basically, many design choices of ITT are made to ensure that type checking is decidable (and fast). If you go from <code>x : A</code> to <code>eq.rec eq x</code>, where <code>eq : A = B</code>, this is easy to typecheck. If you go from <code>x : A</code> to <code>x : B</code> by appealing to some ambient equation, without recording this equation in the term, that is much harder to check: the compiler must go through any equations currently in scope and try to construct some proof <code>eq : A = B</code>. This is undecidable in general since <code>eq</code> may involve an arbitrary number of transitivity steps.</p>\n<p>Nevertheless, there are also extensional type theories, where \"extensional\" means that exactly the thing you're asking for is possible. An example would be F*. I don't know how they get around the undecidability in practice, but whatever they do seems to be working, so it's certainly not impossible. And of course there are systems which do not have proof terms anyway (Isabelle etc?), so they don't have to concern themselves with this.</p>",
        "id": 244541050,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1625132474
    },
    {
        "content": "<p>Just to comment that if you name declarations then you can inspect them with <code>#print</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo</span> <span class=\"c1\">-- see explicit proof term involving eq.rec</span>\n</code></pre></div>",
        "id": 244541134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625132529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244540049\">said</a>:</p>\n<blockquote>\n<p>Just out of curiosity, in what non-DTT setting are you more specifically working?</p>\n</blockquote>\n<p>The object-arrow two-sorted first-order logic(but no more than first-order logic except for the fact that it is two-sorted, it is just like Makkai's FOLDS <a href=\"https://www.math.mcgill.ca/makkai/folds/foldsinpdf/FOLDS.pdf\">https://www.math.mcgill.ca/makkai/folds/foldsinpdf/FOLDS.pdf</a>, the case for category theory, but without the complicated setting of kinds/sorts, just look at his working examples (that is basically the part in the link which you can directly understand without reading through his paper, for example, page 3 to page 4)). So a variable with name \"a\" and of sort A-&gt;B depends on two terms,namely A and B, which are objects. I have a function symbol called \"coeqo\", which takes a pair of arrow term with the same sort, I have a variable (simplified version) like:</p>\n<p>a:coeqo(f,g) -&gt;X</p>\n<p>(Note that FOLDS does not get into this situation, because it does not allow equality on objects at all, and it only has predicates, no functions.)<br>\nand then I proved that f = g, and want to substitute the g to be f, so I get a post inverse of a. And I am messed up by this for several days, because I do not have rules to make changes on the sort of variable, and the sort is same a type-judgment, which is unique for each term.</p>",
        "id": 244541921,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625133080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244541050\">said</a>:</p>\n<blockquote>\n<p>Perhaps it'll be helpful to talk a bit about why intensional dependent type theory (ITT) doesn't let you do something like this. Basically, many design choices of ITT are made to ensure that type checking is decidable (and fast). If you go from <code>x : A</code> to <code>eq.rec eq x</code>, where <code>eq : A = B</code>, this is easy to typecheck. If you go from <code>x : A</code> to <code>x : B</code> by appealing to some ambient equation, without recording this equation in the term, that is much harder to check: the compiler must go through any equations currently in scope and try to construct some proof <code>eq : A = B</code>. This is undecidable in general since <code>eq</code> may involve an arbitrary number of transitivity steps.</p>\n<p>Nevertheless, there are also extensional type theories, where \"extensional\" means that exactly the thing you're asking for is possible. An example would be F*. I don't know how they get around the undecidability in practice, but whatever they do seems to be working, so it's certainly not impossible. And of course there are systems which do not have proof terms anyway (Isabelle etc?), so they don't have to concern themselves with this.</p>\n</blockquote>\n<p>That makes sense and is eye-opening. And yes, Isabelle is one example of no proof term, I am a rather long-term HOL4 user, which does not have proof term either, so have not encountered such problems at all before.</p>",
        "id": 244543325,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625133915
    },
    {
        "content": "<p>Thanks to all who have replied. I think I see hope of getting my problem to be solved using a similar idea of eq.rec. But there raises a new problem.</p>",
        "id": 244646938,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625189288
    },
    {
        "content": "<p>How can we show that the predicates which previously hold for a term also holds for the term produced by eq.rec on that term?</p>",
        "id": 244646945,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625189323
    },
    {
        "content": "<p>Is there any usage of other primitive rules here?</p>",
        "id": 244646959,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625189356
    },
    {
        "content": "<p>Yes, although this gets into \"coercion hell\". The primitive rule is the same one: <code>eq.rec</code> can be used to prove that <code>P a</code> implies <code>P (eq.rec h a)</code> assuming <code>P</code> is suitably parametric in the types to make that typecheck</p>",
        "id": 244647043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625189447
    },
    {
        "content": "<p>There is a much simpler approach, which will be familiar to you if you have used HOL: Instead of using a dependent type to express the property of an element, have a simpler type and assert a proposition about the element. For example, instead of having <code>a : term nat</code>, use <code>a : term</code> and <code>h : typed a nat</code></p>",
        "id": 244647168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625189596
    },
    {
        "content": "<p>If you never have any nontrivial equalities of types, this issue doesn't come up</p>",
        "id": 244647179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625189632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244647168\">said</a>:</p>\n<blockquote>\n<p>There is a much simpler approach, which will be familiar to you if you have used HOL: Instead of using a dependent type to express the property of an element, have a simpler type and assert a proposition about the element. For example, instead of having <code>a : term nat</code>, use <code>a : term</code> and <code>h : typed a nat</code></p>\n</blockquote>\n<p>I tried that, in HOL, exactly. It is horrible. If sort information is not an intrinsic property of a term, then even composition rules like (a o b) o c = a o b o c is not a simple equality anymore, but need to be conditional rw. if we have long-long arrow term, then it is time consuming to get out of nested composition.</p>",
        "id": 244647721,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625190282
    },
    {
        "content": "<p>Another way to get rid of non-trivial equality on types is to never have functions which produce the things which type-information can rely on, which basically demands us to have <strong>no functions at all</strong>. But that mean predicates everywhere. As in common sense I know, rw's likes equalities ,not predicates. Also, using predicates means that if def1 replies on def2, then we require all the inputs of the def2 to also be inputs in def1. Say, definition of exponential relies on the definition of product, the definition of exponential would be messy, since it involves the predicate of being a product.</p>",
        "id": 244649528,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625191183
    },
    {
        "content": "<p>People which do not like the idea of <code>equality of objects</code> in category theory claims that we can use predicates everywhere! But then give simple examples, and do not really go through all basic category theory using predicates and get rid of all functions. Yes, I <strong>am</strong> complaining about this :-( .</p>",
        "id": 244650178,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625191331
    },
    {
        "content": "<blockquote>\n<p>Another way to get rid of non-trivial equality on types is to never have functions which produce the things which type-information can rely on, which basically demands us to have no functions at all.</p>\n</blockquote>\n<p>I'm not sure how you got here. You can certainly have functions in simple type theory, they just don't have dependent types (i.e. the type of the result doesn't depend on the non-type arguments). But really, both positions are extremist, and the reality is somewhere in the middle. Use simple types when convenient, but reach for dependent types when you have a categorical style problem and you think you can maintain the discipline to keep your defeq problems sane.</p>",
        "id": 244653168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625192348
    },
    {
        "content": "<p>Working in a DTT theorem prover means you can bend the rules when simple types everywhere is too onerous</p>",
        "id": 244653236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625192412
    },
    {
        "content": "<blockquote>\n<p>If sort information is not an intrinsic property of a term, then even composition rules like (a o b) o c = a o b o c is not a simple equality anymore, but need to be conditional rw.</p>\n</blockquote>\n<p>By the way, you can also use typeclasses for this sort of thing, although I don't think we've ever tried it for composition. Mathlib uses dependent types for category theory.</p>",
        "id": 244653277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625192508
    },
    {
        "content": "<blockquote>\n<p>Also, using predicates means that if def1 replies on def2, then we require all the inputs of the def2 to also be inputs in def1. Say, definition of exponential relies on the definition of product, the definition of exponential would be messy, since it involves the predicate of being a product.</p>\n</blockquote>\n<p>I think I'm missing the context for this assertion. This isn't the case in lean, you can have the definition of a product packed up in a typeclass and the exponential function can have a simple type</p>",
        "id": 244653369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625192630
    },
    {
        "content": "<p>Here is the context: we tried formalising some basic category theory in HOL4, and we use \"type judgments as formulas\", so we can prove things like <code>h</code> is an arrow from an object <code>A</code> to an object <code>B</code>, but then, it turns out that even simple facts such like:</p>\n<p>∀A B X Y Z f1 f2 f3 f4.<br>\n  f1∶ X → Y ∧ f2∶ Y → Z ∧ f3∶ Z → A ∧ f4∶ A → B ⇒<br>\n  f4 o (f3 o f2) o f1 = f4 o f3 o f2 o f1</p>\n<p>takes long(if you use metis, with minimal intermediate steps, than it takes ages)/or some human work (if you want the proof to run fast, figure out step-by-step how the LHS becomes RHS, and then tell HOL to do the detailed proof) to prove. But won't everyone agree that this is such a simple thing which should completely be automatic and should not take so long?!</p>\n<p>and we are trying to design a new thing, which we want to be on a sweet spot when dealing with problems like in the situation in basic category theory, where sorts information of term is an intrinsic property, so it works nicely for such a simple proof. So I am not claiming \"we cannot have functions in simple type theory\". So I want to borrow things from Lean and HOL, if possible.</p>",
        "id": 244654615,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625194275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244653369\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Also, using predicates means that if def1 replies on def2, then we require all the inputs of the def2 to also be inputs in def1. Say, definition of exponential relies on the definition of product, the definition of exponential would be messy, since it involves the predicate of being a product.</p>\n</blockquote>\n<p>I think I'm missing the context for this assertion. This isn't the case in lean, you can have the definition of a product packed up in a typeclass and the exponential function can have a simple type</p>\n</blockquote>\n<p>If we have function symbols whose output is an object, say, we can produce the coequalizer object of f,g:A-&gt;B, using a function called <code>coeqo</code>, <strong>and</strong> we make the sort information of a term an intrinsic property, then we can have a goal asking us to prove:</p>\n<p>P(a:coeqo(f,g) -&gt;X)</p>\n<p>where P is a predicate on a. Then if we have <code>f = g</code> by hand, and want the goal to become P(a:coeqo(f,f) -&gt;X), it gets <code>changing the type of a</code> involves.</p>\n<p>My claim is that if we do not have function symbols, at least the ones whose output is an object, then we do not get into a situation like this, because then we can avoid substitution on dom/cod of arrows. Because  instead of having coeqo(f,g) as an object, we have a predicate <code>iscoeqo(f,g,E)</code>, so if we want something we can prove from the fact that <code>the domain of a is a coequalizer of f and f</code>, then we just prove <code>forall f g E. iscoeqo (f,g,E)  ==&gt; forall a:E -&gt;X,P(a)</code>, then instead of substitution, we use the strategy of proving \"the property holds for all the thing satisfies certain predicates\" holds.</p>",
        "id": 244655385,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625195395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Making.20change.20to.20type.20judgement.20according.20to.20assumptions/near/244647043\">said</a>:</p>\n<blockquote>\n<p>Yes, although this gets into \"coercion hell\". The primitive rule is the same one: <code>eq.rec</code> can be used to prove that <code>P a</code> implies <code>P (eq.rec h a)</code> assuming <code>P</code> is suitably parametric in the types to make that typecheck</p>\n</blockquote>\n<p>If it is not so hard to state, could you give a bit explaination, maybe an example, on what is \"coercion hell\"? I am interested in which trouble will it bring us in practice.</p>",
        "id": 244657153,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1625197982
    }
]
[
    {
        "content": "<p>Hi, I've come up with a new logic called \"Practical Types\". I would say it is basically first-order logic with types as axiomatic basis. Free variables can depend on parameters, though, I need that so that there is a powerful definition mechanism. I've written up details about it at <a href=\"https://doi.org/10.47757/practical.types.1\">https://doi.org/10.47757/practical.types.1</a> and would love to chat about it, and related approaches!</p>",
        "id": 247813288,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627749314
    },
    {
        "content": "<p>(FYI: This was forked from a discussion at FMM.) My position is that it is both possible and advantageous to have a proof assistant use a type theory that is implemented on an untyped foundational system such as FOL / ZFC, and use the underlying logical rules as inspiration for the things that the type theory is allowed to do. For example, extensional types are a natural addition, as well as dependent types. I'm not really sold on universes, I think that this is an artificial consequence of type theoretic foundations.</p>",
        "id": 247814533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627751136
    },
    {
        "content": "<p>Regarding the practal axioms, it would be useful to have a model of those axioms implemented in a formal system, because there are rather a lot of them and some of them are quite strange on first look; besides putting any worries about consistency to rest, it also provides readers with a clear mental model for the meaning of the assertions</p>",
        "id": 247814612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627751230
    },
    {
        "content": "<p>I mentioned <a href=\"https://github.com/digama0/mm0\">MM0</a> briefly before. I imagine it developing a type system such as I've described eventually, but right now it's mostly only at the \"untyped foundation\" level; you have to manually manipulate (what you would think of as) typing predicates.</p>",
        "id": 247814841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627751549
    },
    {
        "content": "<p>I've looked at MM0 last year. Do you have a strategy for building up theory developments without introducing new axioms all the time, i.e. does MM0 follow the LCF approach?</p>",
        "id": 247814922,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627751675
    },
    {
        "content": "<p>That depends on what you mean by LCF approach. The usual interpretation of this in HOL based systems seems to involve an abstract data type and ambient programming language, and to that end it does not follow LCF; if you mean does it have a small kernel then yes; and if you mean can you get a lot done once you have stopped adding axioms then yes</p>",
        "id": 247815066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627751881
    },
    {
        "content": "<p>the principle mechanisms for the latter are the ability to make new definitions and prove theorems / inference rules as lemmas</p>",
        "id": 247815117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627751915
    },
    {
        "content": "<p>As to practal axioms, yes, it would be great to have a model, for example in ZFC. I suspect you will need additional axioms like  <a href=\"https://mathoverflow.net/questions/366014/data-abstraction-in-set-theory-via-urelements/366845#366845\">discussed last year</a>.</p>\n<p>I haven't combed the axioms yet for minimality (yet), I've just added everything that I thought makes sense and might still be consistent :-) Further cleanup should be possible. I think the axioms are all pretty straightforward, is there any axiom you are worried about in particular? I think there is no way around universes, as you will want every object to have a type.</p>",
        "id": 247815297,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752235
    },
    {
        "content": "<p>In fact, most of the axioms bear a striking resemblance to metamath's \"type system\" in the <a href=\"http://us.metamath.org/mpeuni/mmset.html\">set.mm</a> math library based on ZFC</p>",
        "id": 247815357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752296
    },
    {
        "content": "<p>What I mean by LCF approach is the following: There is a build up phase where you introduce the axioms. Then EVERYTHING else is introduced by definition and cannot cause inconsistency (assuming the build up phase didn't already).</p>",
        "id": 247815384,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752354
    },
    {
        "content": "<p>for example stuff like <code>nil x = nil</code> holds (written <code>( (/) ` x ) = (/)</code> where the empty set plays the role of nil)</p>",
        "id": 247815388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752361
    },
    {
        "content": "<p>I would expect them to, because types in practal are basically sets, but with data abstraction.</p>",
        "id": 247815431,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752380
    },
    {
        "content": "<p>sure, doesn't every system do that?</p>",
        "id": 247815434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752387
    },
    {
        "content": "<p>I wasn't sure about MM0 in that respect!</p>",
        "id": 247815458,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752442
    },
    {
        "content": "<p>well okay that's not true for metamath</p>",
        "id": 247815460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752445
    },
    {
        "content": "<p>it is true for MM0 though</p>",
        "id": 247815462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752455
    },
    {
        "content": "<p>that's one of the major departures - it has a built in definition checking mechanism</p>",
        "id": 247815470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752478
    },
    {
        "content": "<p>in metamath there is an external definition checker which is good but not great since it is still important for soundness if you don't want to trust thousands of axioms</p>",
        "id": 247815519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247815431\">said</a>:</p>\n<blockquote>\n<p>I would expect them to, because types in practal are basically sets, but with data abstraction.</p>\n</blockquote>\n<p>Could you explain what you mean by data abstraction?</p>",
        "id": 247815599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752630
    },
    {
        "content": "<p>In Practal you have <code>∅  x = nil</code> though. The empty set and nil are kind of dual in practal.</p>",
        "id": 247815600,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752639
    },
    {
        "content": "<p>I mean that the space of functions in Practal really is just a space of functions, for example. A function is not a set, also, or has any other structure beyond being a function.</p>",
        "id": 247815617,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752677
    },
    {
        "content": "<p>that would still be fine as long as you choose not to talk about the set structure</p>",
        "id": 247815625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752705
    },
    {
        "content": "<p>metamath does sometimes talk about the set structure of functions though, for example intersection of functions is a thing</p>",
        "id": 247815680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752759
    },
    {
        "content": "<p>Well, it violates data abstraction for them to be sets. It's not a good thing.</p>",
        "id": 247815744,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752848
    },
    {
        "content": "<p>sure, but I'm talking about the underlying foundation, not the \"front end\"</p>",
        "id": 247815761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752880
    },
    {
        "content": "<p>yes, me too</p>",
        "id": 247815768,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752890
    },
    {
        "content": "<p>Let's say you define addition. Once you have defined addition for sets, that's it. You cannot change it for functions.</p>",
        "id": 247815789,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752919
    },
    {
        "content": "<p>By types being independent from each other, each can have their own addition operation, and still everything can stay consistent.</p>",
        "id": 247815835,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752971
    },
    {
        "content": "<p>In lean, those would be two different addition functions, and you are using \"typeclass inference\" to distinguish them based on their ambient types</p>",
        "id": 247815842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627752983
    },
    {
        "content": "<p>Basically type extensionality gives you all the good properities of sets, and none of the bad</p>",
        "id": 247815843,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627752988
    },
    {
        "content": "<p>I would find it somewhat sketchy to have those be the \"same\" addition</p>",
        "id": 247815848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753003
    },
    {
        "content": "<p>in metamath they are literally different functions, you will write <code>A +s B</code> and <code>f +f g</code> or something</p>",
        "id": 247815873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753050
    },
    {
        "content": "<p>Well, what I am saying is if your underlying foundation is set theory, you have no other choice than being sketchy</p>",
        "id": 247815875,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753054
    },
    {
        "content": "<p>you can just have additional arguments to the function, or different functions</p>",
        "id": 247815888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753079
    },
    {
        "content": "<p>Well, as Lean proves, and Isabelle, and Coq, you can do all sorts of things</p>",
        "id": 247815935,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753107
    },
    {
        "content": "<p>lean does it by having an additional argument, inferring it, and suppressing it in printing</p>",
        "id": 247815936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753107
    },
    {
        "content": "<p>But how simple is it? I don't want additional arguments, because they make things more complicated.</p>",
        "id": 247815944,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753125
    },
    {
        "content": "<p>In practal, a function is a function. It doesn't need additional type arguments etc.</p>",
        "id": 247815954,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753153
    },
    {
        "content": "<p>metamath doesn't like the complication and magic of implicit args so it uses different functions</p>",
        "id": 247815960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753160
    },
    {
        "content": "<p>But using the same function says something significant about the domain that you don't always want and is sometimes impossible to satisfy</p>",
        "id": 247815969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753192
    },
    {
        "content": "<p>But each of these different functions is still defined on everything, because everything is sets</p>",
        "id": 247815973,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753195
    },
    {
        "content": "<p>Not necessarily, <code>+f</code> might be defined on pairs of functions with the same/compatible domains</p>",
        "id": 247816027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753226
    },
    {
        "content": "<p>and if you use it on a non-function you just get <code>(/)</code> aka <code>nil</code></p>",
        "id": 247816031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753243
    },
    {
        "content": "<p>let me put it the other way around: what is your argument AGAINST types like in Practal</p>",
        "id": 247816050,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753286
    },
    {
        "content": "<p>Are you against data abstraction?</p>",
        "id": 247816062,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753317
    },
    {
        "content": "<p>At the low level, yes</p>",
        "id": 247816107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753336
    },
    {
        "content": "<p>why?</p>",
        "id": 247816109,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753341
    },
    {
        "content": "<p>more ontological entities means a more complex theory to reason about and prove the soundness of</p>",
        "id": 247816116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753363
    },
    {
        "content": "<p>The low level theory should be the bare minimum needed to build mathematics</p>",
        "id": 247816132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753399
    },
    {
        "content": "<p>and it should ideally be a system that logicians know a lot about</p>",
        "id": 247816138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753408
    },
    {
        "content": "<p>or reducible to such</p>",
        "id": 247816140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753414
    },
    {
        "content": "<p>Well, in Practal there are propositions, functions, natural numbers, and types.</p>",
        "id": 247816148,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753441
    },
    {
        "content": "<p>That's it. I think that is as simple as it should be.</p>",
        "id": 247816192,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753458
    },
    {
        "content": "<p>It makes no sense to mix up any of these with each other.</p>",
        "id": 247816195,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753469
    },
    {
        "content": "<p>But I assume you agree that you could do the same things even with fewer categories</p>",
        "id": 247816217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753507
    },
    {
        "content": "<p>no, I don't , and I would not want to.</p>",
        "id": 247816226,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753522
    },
    {
        "content": "<p>the thing data abstraction (or typing in general) gives you is the ability to say no to things</p>",
        "id": 247816228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753534
    },
    {
        "content": "<p>but you don't need the foundational theory to do that</p>",
        "id": 247816236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753551
    },
    {
        "content": "<p>the front end can do that just fine</p>",
        "id": 247816237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753559
    },
    {
        "content": "<p>Yes, if you want your foundational theory, and your practical theory to be the same, you need to</p>",
        "id": 247816280,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753582
    },
    {
        "content": "<p>A front end just makes everything more complicated</p>",
        "id": 247816283,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753598
    },
    {
        "content": "<p>I thought you want simple?</p>",
        "id": 247816287,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753605
    },
    {
        "content": "<p>I don't think that should be a goal at all</p>",
        "id": 247816288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753606
    },
    {
        "content": "<p>It doesn't have to be like that</p>",
        "id": 247816298,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753627
    },
    {
        "content": "<p>The front end needs to support the practice of <em>writing</em> mathematics, which is entirely separate from the goal of <em>verifying</em> mathematics</p>",
        "id": 247816301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753643
    },
    {
        "content": "<p>If you can get significant advantage by separating the two, by all means do it</p>",
        "id": 247816303,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753644
    },
    {
        "content": "<p>For example, lean has tactics in order to support the front end experience</p>",
        "id": 247816306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753664
    },
    {
        "content": "<p>No, you write mathematics so that it can be verified by other people</p>",
        "id": 247816307,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753673
    },
    {
        "content": "<p>A good front end is great.</p>",
        "id": 247816347,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753693
    },
    {
        "content": "<p>If you try to make the foundation the same as the front end, you will just feel a constant push to make the foundation more complicated</p>",
        "id": 247816348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753693
    },
    {
        "content": "<p>that's how DTT got the way it is</p>",
        "id": 247816349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753700
    },
    {
        "content": "<p>and it will never be good enough</p>",
        "id": 247816355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753716
    },
    {
        "content": "<p>I understand your concerns, and I agree, that is true for static type systems.</p>",
        "id": 247816366,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753746
    },
    {
        "content": "<p>because users' desires for convenient mathematical data entry are infinite</p>",
        "id": 247816369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753754
    },
    {
        "content": "<p>I certainly don't want to have a neural network in the kernel</p>",
        "id": 247816373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753780
    },
    {
        "content": "<p>Haha, me neither.</p>",
        "id": 247816378,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753791
    },
    {
        "content": "<p>but I also don't want to have to tell users that they need to be spartan to use the system</p>",
        "id": 247816428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753815
    },
    {
        "content": "<p>I want the foundation to be as simple as possible, while allowing me to do everything important without tricks.</p>",
        "id": 247816429,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753816
    },
    {
        "content": "<p>As I said, there is no need to be simpler than functions, propositions, types and natural numbers.</p>",
        "id": 247816444,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753843
    },
    {
        "content": "<p>It would be great to build a model in something simpler.</p>",
        "id": 247816455,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753857
    },
    {
        "content": "<p>But that's it.</p>",
        "id": 247816465,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753868
    },
    {
        "content": "<p>Lean and Coq and Isabelle have all done a good job of providing a generous arena for doing mathematics. Isabelle is the only one of those that has mostly managed to keep that complexity out of the kernel</p>",
        "id": 247816480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753902
    },
    {
        "content": "<p>But they are all not good enough in what you can do in them.</p>",
        "id": 247816528,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753929
    },
    {
        "content": "<p>Practal will have a simpler kernel, and a more powerful one.</p>",
        "id": 247816538,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753940
    },
    {
        "content": "<p>When you say frontend, I think of the parsing mechanism I implemented so far.</p>",
        "id": 247816562,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627753975
    },
    {
        "content": "<p>There aren't too many places where I would say that lean is (foundationally) too weak for what I want to do; the main area is around the straightjacket of intensional type theory</p>",
        "id": 247816567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627753998
    },
    {
        "content": "<p>Sure, that's complexity that  has no business being in the kernel.</p>",
        "id": 247816568,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754003
    },
    {
        "content": "<p>For example lean has no subtyping, and no undefinedness. That's pretty bad.</p>",
        "id": 247816574,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754028
    },
    {
        "content": "<p>It has both, through types</p>",
        "id": 247816595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754043
    },
    {
        "content": "<p>It has none, because of types.</p>",
        "id": 247816624,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754055
    },
    {
        "content": "<p>Subtyping is done via implicit \"coercion\" injections, and undefinedness is done through the option type</p>",
        "id": 247816635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754075
    },
    {
        "content": "<p>All it has are workarounds.</p>",
        "id": 247816636,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754079
    },
    {
        "content": "<p>Perhaps, but you have to show evidence that the workaround is inadequate for solving real problems</p>",
        "id": 247816649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754101
    },
    {
        "content": "<p>And these things cause a lot of pain. Like you have to change your whole formalisation in order to accomodate for that.</p>",
        "id": 247816652,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754103
    },
    {
        "content": "<p>No, I don't have to. You can do everything with workarounds. It is just not as good as it could be.</p>",
        "id": 247816675,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754135
    },
    {
        "content": "<p>Honestly that is true in any system. You always have to formalize taking into account the constraints of the system, and no system is unconstrained</p>",
        "id": 247816685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754154
    },
    {
        "content": "<p>Practal is about as unconstrained as you can possibly get it.</p>",
        "id": 247816729,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754177
    },
    {
        "content": "<p>Maybe you have subtyping, but do you have the right subtyping? Maybe it doesn't actually match mathematical practice</p>",
        "id": 247816735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754200
    },
    {
        "content": "<p>what do you do then?</p>",
        "id": 247816741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754207
    },
    {
        "content": "<p>If you have type extensionality, then subtying follows automatically from that. There is only one kind of subtyping then.</p>",
        "id": 247816756,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754246
    },
    {
        "content": "<p>You give an example of this on that practal page: you would like <code>A -&gt; B &lt;= C -&gt; D</code> iff <code>C &lt;= A</code> and <code>B &lt;= D</code> but it doesn't work for technical reasons</p>",
        "id": 247816759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754257
    },
    {
        "content": "<p>but that won't stop people from not liking that it fails</p>",
        "id": 247816770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754281
    },
    {
        "content": "<p>in lean this would work just as well as any other subtyping relation</p>",
        "id": 247816817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754314
    },
    {
        "content": "<p>Well, some things are just how they are. Subtyping does certain things, and not others.</p>",
        "id": 247816819,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754319
    },
    {
        "content": "<p>because subtyping is not limited to embeddings in some global sense</p>",
        "id": 247816830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754345
    },
    {
        "content": "<p>I would say coercions are a frontend as you describe it.</p>",
        "id": 247816831,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754345
    },
    {
        "content": "<p>they certainly are</p>",
        "id": 247816836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754362
    },
    {
        "content": "<p>or rather, the syntax mechanisms to insert them and elide them when possible is a front end feature</p>",
        "id": 247816841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754385
    },
    {
        "content": "<p>And there is no problem with that. You can define functions between different types in Practal. As a syntactic feature, you can have coercions in Practal.</p>",
        "id": 247816892,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754409
    },
    {
        "content": "<p>But you cannot have subtypes in Lean.</p>",
        "id": 247816915,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754424
    },
    {
        "content": "<p>if they are automatically inserted, never visible and never interact with any theorems you apply, then to the user they may as well not be there</p>",
        "id": 247816925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754431
    },
    {
        "content": "<p>how does that differ from having \"true subtypes\"</p>",
        "id": 247816930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754444
    },
    {
        "content": "<p>Because it is not like that. I have no experience with coercions in Lean, but I am sure they are never completely invisible.</p>",
        "id": 247816953,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754474
    },
    {
        "content": "<p>Subtypes are. By design.</p>",
        "id": 247816957,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754487
    },
    {
        "content": "<p>oh but they aren't</p>",
        "id": 247816962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754502
    },
    {
        "content": "<p>what you forget is that subtyping has a consequence around decidability of typing</p>",
        "id": 247816973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754522
    },
    {
        "content": "<p>when you can't say what type a thing has, type inference takes a hit and applying lemmas gets more painful</p>",
        "id": 247817023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754555
    },
    {
        "content": "<p>there is no free lunch</p>",
        "id": 247817031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754568
    },
    {
        "content": "<p>But that is frontend stuff. Type inference is frontend.</p>",
        "id": 247817058,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754628
    },
    {
        "content": "<p>now it's a tradeoff, and it might be worth it depending on factors, but you have to weigh that against the gains that literal subtyping give you over \"simulated subtyping\"</p>",
        "id": 247817060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754633
    },
    {
        "content": "<p>Yes, and I weighed that. simulated subtyping lost.</p>",
        "id": 247817104,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754651
    },
    {
        "content": "<p>You say you don't have much experience with coercions so I'm not sure you have actually considered the options thoroughly</p>",
        "id": 247817124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754682
    },
    {
        "content": "<p>you are right that coercions aren't always invisible, but until you know the pros and cons I'm not sure you can judge the relative benefit of literal subtyping</p>",
        "id": 247817141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754730
    },
    {
        "content": "<p>I am a fan of the literal subtyping that you have in metamath for things like 1 \\in Z -&gt; 1 \\in R, but it's also very nice that <code>n : int -&gt; n : zmod 37</code> works in lean, and I know there is no way that's going to happen in metamath because literal subtyping is tied to the concrete representation of objects</p>",
        "id": 247817207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754830
    },
    {
        "content": "<p>I don't think I can convince you otherwise, and I don't want to convince you based on what <br>\nI am thinking about subtyping.</p>",
        "id": 247817209,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754830
    },
    {
        "content": "<p>I'm just saying there are advantages on both sides, and don't be too dogmatic about it</p>",
        "id": 247817233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754883
    },
    {
        "content": "<p>coercions aren't completely intolerable</p>",
        "id": 247817261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754907
    },
    {
        "content": "<p>I am not. If coercions are possible in Practal, I want them. I just know that type extensionality I want for sure, and subtyping follows from that.</p>",
        "id": 247817269,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754922
    },
    {
        "content": "<p>but you have to experience them for yourself to see just how intolerable they are</p>",
        "id": 247817271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627754925
    },
    {
        "content": "<p>I have used coercions in Isabelle.</p>",
        "id": 247817278,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754940
    },
    {
        "content": "<p>And you don't need much experience to say what their problem is.</p>",
        "id": 247817287,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754971
    },
    {
        "content": "<p>There is something in your theorems, that is there, but you cannot see. But in some cases, it is important.</p>",
        "id": 247817292,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627754992
    },
    {
        "content": "<p>Obviously there are always going to be problems with such an approach.</p>",
        "id": 247817339,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755028
    },
    {
        "content": "<p>type extensionality is another interesting thing. In lean you don't have type equality except in trivial cases, but in a system that takes data abstraction seriously like practal it's not clear to me that you can do much better</p>",
        "id": 247817340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755031
    },
    {
        "content": "<p>Note that in lean, coercion is displayed as an up arrow operator, because invisible coercion is confusing</p>",
        "id": 247817355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755074
    },
    {
        "content": "<p>But it can. Practal is evidence (except if it turns out to be inconsistent, of course).</p>",
        "id": 247817362,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755093
    },
    {
        "content": "<p>like you say, it's bad when something you can't see changes how a tactic works</p>",
        "id": 247817364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755100
    },
    {
        "content": "<p>what kind of nontrivial type equalities are you getting?</p>",
        "id": 247817411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755140
    },
    {
        "content": "<p>Yeah, so in that sense it could also work in Practal. You insert a symbol, and it means \"coerce if undefined\"</p>",
        "id": 247817412,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755147
    },
    {
        "content": "<p>Does practal have type inference?</p>",
        "id": 247817441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755199
    },
    {
        "content": "<p>What \"non-trivial\" type equalities are you looking for?</p>",
        "id": 247817443,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755202
    },
    {
        "content": "<p>No, no type inference. Everything has to go through theorems.</p>",
        "id": 247817452,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755223
    },
    {
        "content": "<p>what's the point of the type theory then?</p>",
        "id": 247817501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755252
    },
    {
        "content": "<p>that's not meant as judgment, I literally want to know why you want types without type inference</p>",
        "id": 247817508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755296
    },
    {
        "content": "<p>Because types represent concepts. You want those concepts. It's that Lean and Coq etc. confuse them with types for programming.</p>",
        "id": 247817509,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755300
    },
    {
        "content": "<p>I want matrices. I want functions. I want functions of matrices. etc.</p>",
        "id": 247817528,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755323
    },
    {
        "content": "<p>And I like that a proposition is not a function. Because it is a different concept.</p>",
        "id": 247817532,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755342
    },
    {
        "content": "<p>Because, when I am thinking about functions, I don't want to have to think about propositions, too.</p>",
        "id": 247817581,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755369
    },
    {
        "content": "<p>There is no need for type checking in a theorem prover. I understand that it was convenient for a long time, given limited hardware etc.</p>",
        "id": 247817609,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755474
    },
    {
        "content": "<p>That's odd, I would say it the other way around</p>",
        "id": 247817658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755493
    },
    {
        "content": "<p>Like how?</p>",
        "id": 247817674,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755520
    },
    {
        "content": "<p>It is more convenient now than ever and stronger computers help us do it more</p>",
        "id": 247817676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755524
    },
    {
        "content": "<p>I have heard it said that type checking is the closest thing most programmers get to theorem proving, and type inference is automated theorem proving</p>",
        "id": 247817692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755578
    },
    {
        "content": "<p>who would say no to that?</p>",
        "id": 247817698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755591
    },
    {
        "content": "<p>Hahaha, that is not wrong.</p>",
        "id": 247817738,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755606
    },
    {
        "content": "<p>Knowing that there is a huge class of problems that can just be automated away, I would be a fool to pass it up</p>",
        "id": 247817748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755619
    },
    {
        "content": "<p>But programming is not theorem proving.</p>",
        "id": 247817749,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755621
    },
    {
        "content": "<p>I said that before, I know.</p>",
        "id": 247817762,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755639
    },
    {
        "content": "<p>If types are there because they model my concepts, great.</p>",
        "id": 247817772,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755668
    },
    {
        "content": "<p>it's the baby version, although if you look at haskell and rust you will see some stuff that is nigh-indistinguishable from the work that goes on in actual mathematical theorem proving</p>",
        "id": 247817776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755676
    },
    {
        "content": "<p>If they get in the way of me modelling my concepts like I want to, that's not acceptable.</p>",
        "id": 247817780,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755686
    },
    {
        "content": "<p>I think there is a certain kind of reasoning and thinking that programmers like to do, and Coq etc. are a good fit for that.</p>",
        "id": 247817844,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755749
    },
    {
        "content": "<p>There is a great MO post by andrej bauer about this that I need to dig up</p>",
        "id": 247817853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755777
    },
    {
        "content": "<p>I would say programmers are more \"syntax\" based.</p>",
        "id": 247817864,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755810
    },
    {
        "content": "<p>I am more \"semantics\" based.</p>",
        "id": 247817869,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755820
    },
    {
        "content": "<p><a href=\"https://mathoverflow.net/a/376973/34444\">https://mathoverflow.net/a/376973/34444</a></p>",
        "id": 247817870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755823
    },
    {
        "content": "<p>\"The field of scalars is not specified\"</p>",
        "id": 247817928,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755910
    },
    {
        "content": "<p>Exactly that. If I have a vector space U, I don't need to specify the field of scalars. Because it is already part of it.</p>",
        "id": 247817940,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755939
    },
    {
        "content": "<p>I would hope that in Practal, you don't need either.</p>",
        "id": 247817951,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755962
    },
    {
        "content": "<p>You need the two vector spaces to have the same field though, I doubt you can get that for free with practal style</p>",
        "id": 247817988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627755980
    },
    {
        "content": "<p>But as he says, you can only find out the suitability for sure by doing it.</p>",
        "id": 247817989,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627755990
    },
    {
        "content": "<p>Yes, but if you say stuff like you have a linear map from U to V, then you have it for free.</p>",
        "id": 247817999,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756014
    },
    {
        "content": "<p>because it is empty or because it is nil?</p>",
        "id": 247818015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756043
    },
    {
        "content": "<p>otherwise</p>",
        "id": 247818016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756045
    },
    {
        "content": "<p>Because it is part of the definition of what a linear map is.</p>",
        "id": 247818027,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756062
    },
    {
        "content": "<p>Getting the type of x and y in that example requires type inference, I think</p>",
        "id": 247818084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756108
    },
    {
        "content": "<p>if you just say <code>\\forall x y, ...</code> (do you have unbounded quantifiers?) then the equality is probably not true</p>",
        "id": 247818112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756156
    },
    {
        "content": "<p>The type is built into the objects, no need for inference.</p>",
        "id": 247818116,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756162
    },
    {
        "content": "<p>not sure what you mean</p>",
        "id": 247818124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756179
    },
    {
        "content": "<p>we are introducing two variables x and y and not saying the type</p>",
        "id": 247818136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756198
    },
    {
        "content": "<p>that corresponds to a quantifier like <code>\\forall x, ...</code></p>",
        "id": 247818182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756211
    },
    {
        "content": "<p>𝑓(2⋅𝑥+𝑦) =↓ 2⋅𝑓(𝑥)+𝑓(𝑦) will be true in Practal</p>",
        "id": 247818190,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756218
    },
    {
        "content": "<p>for what x and y</p>",
        "id": 247818208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756265
    },
    {
        "content": "<p>Do they have to be in the type U?</p>",
        "id": 247818225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756285
    },
    {
        "content": "<p>Let me check, I am not sure.</p>",
        "id": 247818231,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756303
    },
    {
        "content": "<p>2 * x + y needs to be in U, otherwise f(2 * x + y) would be nil</p>",
        "id": 247818273,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756325
    },
    {
        "content": "<p>likewise x needs to be in U, otherwise f(x) = nil, same for f(y)</p>",
        "id": 247818281,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756346
    },
    {
        "content": "<p>Because f: U -&gt; V</p>",
        "id": 247818283,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756355
    },
    {
        "content": "<p>But what about the 2? and the \"*\" and the \"+\"</p>",
        "id": 247818294,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756377
    },
    {
        "content": "<p>so if I write <code>\\forall x y, 𝑓(2⋅𝑥+𝑦) =↓ 2⋅𝑓(𝑥)+𝑓(𝑦)</code> then that's false</p>",
        "id": 247818301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756395
    },
    {
        "content": "<p>oh sorry, the other way around anyway, you have to write =↑</p>",
        "id": 247818314,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756425
    },
    {
        "content": "<p>which means, if either of them is defined, then they are equal</p>",
        "id": 247818358,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756445
    },
    {
        "content": "<p>While I'm sure you can make some such variant work, that only works out some of the time</p>",
        "id": 247818368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756473
    },
    {
        "content": "<p>But in this situation, you would probably want to write ∀ x y : U in the first place.</p>",
        "id": 247818369,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756474
    },
    {
        "content": "<p>I know because metamath does that kind of thing all the time</p>",
        "id": 247818374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756486
    },
    {
        "content": "<p>The question is, how are general operators like \"+\", *\" and \"2\" handled.</p>",
        "id": 247818377,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756503
    },
    {
        "content": "<p>for example if we were proving not-equals then the =↑ would cause problems</p>",
        "id": 247818385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756516
    },
    {
        "content": "<p>That's overloading / type class stuff, and you would want some of that in Practal.</p>",
        "id": 247818387,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756522
    },
    {
        "content": "<p>I thought you wanted + to just mean different things on different sets</p>",
        "id": 247818397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756540
    },
    {
        "content": "<p>like there is only one + and it somehow plays the role of all additions</p>",
        "id": 247818446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756567
    },
    {
        "content": "<p>No, that was just an example that I don't want a definition on some set to automatically mean something on other sets.</p>",
        "id": 247818452,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756578
    },
    {
        "content": "<p>I imagine there to be overloading, and types can be used for that. That is one reason why they are superior to sets.</p>",
        "id": 247818467,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756625
    },
    {
        "content": "<p>So when I defined addition on natural numbers, I don't want to have to wonder what it means on other sets that are not natural numbers.</p>",
        "id": 247818530,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756687
    },
    {
        "content": "<p>But I hope you agree that overloading is not a feature of the foundation</p>",
        "id": 247818551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756753
    },
    {
        "content": "<p>isabelle has overloading in the foundation and it's a nightmare</p>",
        "id": 247818557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756775
    },
    {
        "content": "<p>It needs to be made possible for by the foundation, I think, but not a feature, no</p>",
        "id": 247818560,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756788
    },
    {
        "content": "<p>I know, I had my fair share of thinking about that ;-)</p>",
        "id": 247818594,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756804
    },
    {
        "content": "<p>I think you need conditional definitions in the kernel, to make it work though.</p>",
        "id": 247818611,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756829
    },
    {
        "content": "<p>What provision does the foundation need?</p>",
        "id": 247818612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756833
    },
    {
        "content": "<p>and if you add another case, you prove the consistency of that case</p>",
        "id": 247818620,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756857
    },
    {
        "content": "<p>Not sure what you mean by conditional definitions, but I think that's the isabelle nightmare I mentioned</p>",
        "id": 247818627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756870
    },
    {
        "content": "<p>No, Isabelle's problem is that it needs to statically determine if it is save or not.</p>",
        "id": 247818634,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756896
    },
    {
        "content": "<p>safe</p>",
        "id": 247818635,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756901
    },
    {
        "content": "<p>In principal it is simple. If you add a definition P ==&gt; A = B, make sure that for all other other previous definitions P' ==&gt; A = B', for those cases where both P and P' are true, B and B' coincide.</p>",
        "id": 247818684,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756959
    },
    {
        "content": "<p>Introducing a definition piecemeal sounds very sketchy to me</p>",
        "id": 247818687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756965
    },
    {
        "content": "<p>how are you going to manage that context of previous definitions?</p>",
        "id": 247818700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627756989
    },
    {
        "content": "<p>And that is just a proof obligation for the definition mechanism.</p>",
        "id": 247818704,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627756996
    },
    {
        "content": "<p>Well, there are only finitely many.</p>",
        "id": 247818708,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757011
    },
    {
        "content": "<p>It is what computers are there for.</p>",
        "id": 247818712,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757024
    },
    {
        "content": "<p>It is somewhat sketchy. But it is what you do in practice, because in practice you build your theories piecemeal.</p>",
        "id": 247818770,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757072
    },
    {
        "content": "<p>it means that I can't build a model incrementally by reading clauses, any potential model could be falsified later</p>",
        "id": 247818796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757123
    },
    {
        "content": "<p>with plain definitions each entity is defined in terms of previous definitions</p>",
        "id": 247818805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757152
    },
    {
        "content": "<p>Also you would get some asymmetry/order dependence when introducing clauses</p>",
        "id": 247818860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757187
    },
    {
        "content": "<p>I have not thought through it properly. That's why I left it out of what I have written up so far.</p>",
        "id": 247818888,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757255
    },
    {
        "content": "<p>Maybe, because of types, you can do it entirely outside of the kernel, and you need no conditional definitions. And that would be actually great.</p>",
        "id": 247818960,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757290
    },
    {
        "content": "<p>But I think new types will possibly destroy models anyway?</p>",
        "id": 247818978,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757352
    },
    {
        "content": "<p>why would they?</p>",
        "id": 247818988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757363
    },
    {
        "content": "<p>Because you create a new type, and now something exists that didn't before. Could that be a problem?</p>",
        "id": 247819003,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757391
    },
    {
        "content": "<p>You just have all types existing at the outset, and you are just using a grammar to select those types that exist already</p>",
        "id": 247819060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757423
    },
    {
        "content": "<p>like in ZFC, the syntax {x \\in A| P(x)} doesn't create a new type, it names an existing type</p>",
        "id": 247819075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757462
    },
    {
        "content": "<p>Very platonic. Sounds reasonable to me, but I wouldn't do the model building in the first place. :-)</p>",
        "id": 247819084,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757482
    },
    {
        "content": "<p>In Practal, there are two different options here</p>",
        "id": 247819097,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757511
    },
    {
        "content": "<p>You don't need to do the model building, but it's useful to have that property for proof translation purposes</p>",
        "id": 247819141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757535
    },
    {
        "content": "<p>You can write { x : A | P(x) }, which is just a subtype of A</p>",
        "id": 247819142,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757535
    },
    {
        "content": "<p>and you can write <code>typedef B = { x : A | P(x) }</code>, and now B and A are disjoint</p>",
        "id": 247819151,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757568
    },
    {
        "content": "<p>But I guess B could have existed before anyway</p>",
        "id": 247819157,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757580
    },
    {
        "content": "<p>Yes, for the foundations it should be clear how to build the model. But then the user can forget about it, because Practal ensures, whatever they do, it's fine, there still will be a model.</p>",
        "id": 247819178,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757633
    },
    {
        "content": "<p>And there are different options for typedef so that you can do quotient types, and glue other existing types into the new type.</p>",
        "id": 247819243,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757715
    },
    {
        "content": "<p>One way to model that (in ZFC, say) is that you have a designated space for typedefs, for example you have pairs <code>(i, x)</code> where <code>i</code> is a natural number and <code>x</code> is any set, forming omega many copies of <code>V</code>, and the <code>n</code>th <code>typedef</code> selects a subset of <code>V_n</code></p>",
        "id": 247819246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757738
    },
    {
        "content": "<p>Yes, this is similar to what we talked about last year, isn't it</p>",
        "id": 247819294,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627757771
    },
    {
        "content": "<p>Even if you could make partial definitions work, I think it would not be good enough for the uses that people want overloading for, though. For example you might want <code>+</code> to mean one thing on <code>A</code> and a different thing on <code>B</code> (using context to distinguish them), despite the fact that <code>A</code> and <code>B</code> are not disjoint</p>",
        "id": 247819376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757928
    },
    {
        "content": "<p>I know there are examples of such in lean</p>",
        "id": 247819388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627757966
    },
    {
        "content": "<p>in fact the whole \"newtype\" pattern is specifically so that you can make the same notations on the same elements mean something different</p>",
        "id": 247819457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758010
    },
    {
        "content": "<p>Yes, I think I agree with you.</p>",
        "id": 247819469,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758015
    },
    {
        "content": "<p>I just mixed things up.</p>",
        "id": 247819490,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758031
    },
    {
        "content": "<p>But I have to think about it properly first because I can agree definitely.</p>",
        "id": 247819509,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758064
    },
    {
        "content": "<p>But yeah. This is what types are great for, and sets are bad at.</p>",
        "id": 247819523,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758091
    },
    {
        "content": "<p>The way I see it, the type checker maintains, for each expression, a typing judgment that is \"the type\" of the value, and uses that to answer questions like what type does this value have, how to I resolve this notation, etc</p>",
        "id": 247819588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758153
    },
    {
        "content": "<p>But let's say I define addition on natural numbers.</p>",
        "id": 247819589,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758153
    },
    {
        "content": "<p>Later on, I introduce real numbers that have natural numbers glued into them.</p>",
        "id": 247819605,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758184
    },
    {
        "content": "<p>Now I need to extend the definition of addition.</p>",
        "id": 247819613,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758196
    },
    {
        "content": "<p>but then there is some additional mechanism for saying \"note now that x also has this other type\" and then you can do literal subtyping</p>",
        "id": 247819615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758201
    },
    {
        "content": "<p>I think Mizar has a <code>reconsider</code> directive that does approximately this</p>",
        "id": 247819620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758216
    },
    {
        "content": "<p>I don't know how something like that would work in Practal's logic.</p>",
        "id": 247819675,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758270
    },
    {
        "content": "<p>Which part? It looks pretty natural for soft typed systems</p>",
        "id": 247819682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758293
    },
    {
        "content": "<p>You define plus : Nat -&gt; Nat -&gt; Nat</p>",
        "id": 247819687,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758303
    },
    {
        "content": "<p>What about plus : Real -&gt; Real -&gt; Real?</p>",
        "id": 247819707,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758360
    },
    {
        "content": "<p>Well in my setup you would have a different function <code>plus_real : Real -&gt; Real -&gt; Real</code>, but then set notation up so that you can use <code>+</code> for both <code>plus_nat</code> and <code>plus_real</code></p>",
        "id": 247819746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758368
    },
    {
        "content": "<p>If Real and Nat would be different types, that would be the way to go.</p>",
        "id": 247819751,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758393
    },
    {
        "content": "<p>and the system infers which one you want based on \"the type\" of the arguments</p>",
        "id": 247819752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758394
    },
    {
        "content": "<p>which is why the type checker needs to be able to answer questions about the types of things</p>",
        "id": 247819756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758420
    },
    {
        "content": "<p>But there is no type inference in Practal.</p>",
        "id": 247819762,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758427
    },
    {
        "content": "<p>the method I'm describing gives you type inference too</p>",
        "id": 247819767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758441
    },
    {
        "content": "<p>No, there can be no type inference, otherwise it doesn't work</p>",
        "id": 247819775,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758459
    },
    {
        "content": "<p>Why is that?</p>",
        "id": 247819776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758465
    },
    {
        "content": "<p>Equality can not be based on type inference, equality just \"is\"</p>",
        "id": 247819786,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758476
    },
    {
        "content": "<p>I didn't say anything about equality</p>",
        "id": 247819831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758489
    },
    {
        "content": "<p>What does x + y mean then?</p>",
        "id": 247819843,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758525
    },
    {
        "content": "<p>equality can be whatever you like, this is just a mechanism for automatically supplying typing proofs from the context where needed</p>",
        "id": 247819844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758527
    },
    {
        "content": "<p>it depends on the type of x and y</p>",
        "id": 247819848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758540
    },
    {
        "content": "<p>But if x is a nat, it is also a real</p>",
        "id": 247819857,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758556
    },
    {
        "content": "<p>that's fine, if x is a nat then it's <code>plus_nat</code></p>",
        "id": 247819865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758580
    },
    {
        "content": "<p>it's a convenient bit of data entry, it's <code>plus_nat</code> under the hood</p>",
        "id": 247819873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758600
    },
    {
        "content": "<p>the user can write <code>plus_real x y</code> if they really need to, or <code>reconsider x : Real</code> or whatever the notation is</p>",
        "id": 247819917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758624
    },
    {
        "content": "<p>I don't like it.</p>",
        "id": 247819921,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758652
    },
    {
        "content": "<p>It is OK to dispatch based on type.</p>",
        "id": 247819931,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758668
    },
    {
        "content": "<p>so, + can dispatch to \"<a href=\"http://Type.plus\">Type.plus</a>\"</p>",
        "id": 247819935,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758685
    },
    {
        "content": "<p>As long as the functions agree on the common domain it shouldn't matter which is which</p>",
        "id": 247819937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758698
    },
    {
        "content": "<p>It shouldn't, but who ensures that?</p>",
        "id": 247819941,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758716
    },
    {
        "content": "<p>The user</p>",
        "id": 247819943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758722
    },
    {
        "content": "<p>But that means that the user can mess up the system badly.</p>",
        "id": 247819984,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758750
    },
    {
        "content": "<p>I think what I described is basically what lean will do as well, with a combination of typeclass inference and coercion</p>",
        "id": 247819986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758753
    },
    {
        "content": "<p>sure, but there is definitely nothing you can do about that</p>",
        "id": 247819992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758772
    },
    {
        "content": "<p>No, in Practal, the user will have to prove that it is compatible with subtyping.</p>",
        "id": 247819993,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758778
    },
    {
        "content": "<p>you can still screw up lots of other things</p>",
        "id": 247819998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758791
    },
    {
        "content": "<p>Yeah, but this is one thing I can do something about</p>",
        "id": 247820002,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758805
    },
    {
        "content": "<p>And it makes sense.</p>",
        "id": 247820004,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758816
    },
    {
        "content": "<p>It's not necessarily desirable</p>",
        "id": 247820006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758824
    },
    {
        "content": "<p><a href=\"http://Real.plus\">Real.plus</a> should be the same as <a href=\"http://Nat.plus\">Nat.plus</a> on Nat.</p>",
        "id": 247820008,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758826
    },
    {
        "content": "<p>one could have such a thing in lean as well but it's not desirable</p>",
        "id": 247820015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758836
    },
    {
        "content": "<p>Why not?</p>",
        "id": 247820055,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758849
    },
    {
        "content": "<p>It is desirable if you have subtyping.</p>",
        "id": 247820060,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758862
    },
    {
        "content": "<p>some coercions aren't compatible with operators</p>",
        "id": 247820063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758876
    },
    {
        "content": "<p>some are only compatible with some operators</p>",
        "id": 247820064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758883
    },
    {
        "content": "<p>That's why coercions are different from subtypes.</p>",
        "id": 247820072,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758902
    },
    {
        "content": "<p>Not a problem, but as far as subtyping is concerned, you want it to be the same.</p>",
        "id": 247820085,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627758924
    },
    {
        "content": "<p>for example <code>\\u x + \\u y = \\u (x + y)</code> holds for the nat -&gt; int coercion but  <code>\\u x - \\u y = \\u (x - y)</code> doesn't</p>",
        "id": 247820086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627758925
    },
    {
        "content": "<p>For the <code>fin n -&gt; nat</code> coercion <code>\\u x + \\u y = \\u (x + y)</code> doesn't hold</p>",
        "id": 247820147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759002
    },
    {
        "content": "<p>that one is probably traditionally a subtype</p>",
        "id": 247820158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759016
    },
    {
        "content": "<p>it's even literally a <code>subtype</code> in lean</p>",
        "id": 247820163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759024
    },
    {
        "content": "<p>fin n?</p>",
        "id": 247820167,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759042
    },
    {
        "content": "<p><code>{0,...,n-1}</code></p>",
        "id": 247820171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759052
    },
    {
        "content": "<p>addition on fin n is as in Z/nZ</p>",
        "id": 247820225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759088
    },
    {
        "content": "<p>Well, it would not be a subtype in Practal, but a whole new type</p>",
        "id": 247820231,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759113
    },
    {
        "content": "<p>the coercion is still useful though</p>",
        "id": 247820234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759138
    },
    {
        "content": "<p>Definitely.</p>",
        "id": 247820240,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759146
    },
    {
        "content": "<p>As I said, I would want coercions in Practal as well!</p>",
        "id": 247820245,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759158
    },
    {
        "content": "<p>If you have coercions then why not lean on them and forget literal subtyping?</p>",
        "id": 247820252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759182
    },
    {
        "content": "<p>Because subtyping is too good to have! As I said, if you have type extensionality, you getn subtyping automatically. And type extensionality is at the core of my approach.</p>",
        "id": 247820307,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759222
    },
    {
        "content": "<p>I wonder whether you could have coercions and subtype coercions in the frontend, with the latter lowering to literal subtyping</p>",
        "id": 247820322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759283
    },
    {
        "content": "<p>that way you can have type inference where <code>x : nat</code> and <code>\\u x : real</code>, but without the headache of <code>\\u x + \\u y = \\u (x + y)</code> lemmas</p>",
        "id": 247820368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759343
    },
    {
        "content": "<p>because subtype coercions commute with everything by definition (because they are literally nothing to the kernel)</p>",
        "id": 247820384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759379
    },
    {
        "content": "<p>I am not sure what \"subtype coercions\" would get you.</p>",
        "id": 247820394,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759420
    },
    {
        "content": "<p>they let the user direct the type checker, which, recall, is a mechanism for inserting typing proofs where required</p>",
        "id": 247820442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759457
    },
    {
        "content": "<p>But there is no type checker.</p>",
        "id": 247820448,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759473
    },
    {
        "content": "<p>so in a certain context you have <code>x : nat</code> because for example you were proving <code>\\forall x : nat, ...</code> and intro'd <code>x</code>, and now the typechecker keeps track of <code>x : nat</code> and when it needs to prove <code>x + x : nat</code> it uses this fact; and then the user can talk about <code>\\u x : real</code> and the typechecker knows that the coercion <code>nat -&gt; real</code> exists so that this typechecks</p>",
        "id": 247820488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759562
    },
    {
        "content": "<p>but under the hood that's really a theorem <code>nat &lt;= real</code></p>",
        "id": 247820535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759575
    },
    {
        "content": "<p>But why would the user talk about \\u x : real ?</p>",
        "id": 247820549,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759633
    },
    {
        "content": "<p>actually they would probably write <code>x : real</code> and the frontend would insert the <code>\\u</code> (and the backend would take it out again)</p>",
        "id": 247820554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759660
    },
    {
        "content": "<p>or they would apply <code>x</code> to a real function</p>",
        "id": 247820557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759673
    },
    {
        "content": "<p>Well, I think we can agree that coercions can come in handy. But when the types in questions are already subtypes, they don't make sense.</p>",
        "id": 247820602,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759706
    },
    {
        "content": "<p>you might wonder why to go around in circles like this but the advantage is that you can handle true coercions in exactly the same way</p>",
        "id": 247820604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759718
    },
    {
        "content": "<p>Maybe you want to embed Nat into Real in a different way . Then you need coercions.</p>",
        "id": 247820608,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759732
    },
    {
        "content": "<p>No, the point is that you can handle subtyping much better than coercing.</p>",
        "id": 247820627,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759750
    },
    {
        "content": "<p>and also having the <code>\\u</code> in there means that you get stable answers to what the type of a thing is, which is important for stuff like typeclass inference</p>",
        "id": 247820633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759762
    },
    {
        "content": "<p>Why would you want to make subtyping as bad as coercions? That's kind of besides the point.</p>",
        "id": 247820635,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759768
    },
    {
        "content": "<p>Why not ensure that subtyping coercions are as good as literal subtyping? Then it doesn't matter</p>",
        "id": 247820687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759829
    },
    {
        "content": "<p>Because they cannot be.</p>",
        "id": 247820691,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759838
    },
    {
        "content": "<p>how so</p>",
        "id": 247820693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759843
    },
    {
        "content": "<p>Coercions can never be as good as subtyping. At least that's what I believe. They are just simpler, conceptually.</p>",
        "id": 247820700,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759870
    },
    {
        "content": "<p>subtyping coercions are frontend magic around literal subtyping, so it should be possible to make them just as good in practice</p>",
        "id": 247820704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759881
    },
    {
        "content": "<p>They don't always apply though. And that's when coercions come in.</p>",
        "id": 247820705,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759883
    },
    {
        "content": "<p>this is just an implementation trick to make sure the typechecker remains usable</p>",
        "id": 247820714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759919
    },
    {
        "content": "<p>the typechecker that practal doesn't have</p>",
        "id": 247820752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627759929
    },
    {
        "content": "<p>There is no type checker.</p>",
        "id": 247820753,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759931
    },
    {
        "content": "<p>:-)</p>",
        "id": 247820754,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627759937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247820687\">said</a>:</p>\n<blockquote>\n<p>Why not ensure that subtyping coercions are as good as literal subtyping? Then it doesn't matter</p>\n</blockquote>\n<p>If I may, I will jump into this dialogue. I agree with <span class=\"user-mention\" data-user-id=\"429698\">@Steven Obua</span> that coercions are, in general, bad. I would argue they are largely an artifact of the types being  (usually)represented as tagged unions and thus the coercion allows the compiler to have a point where it can switched between tags. When possible, I would always prefer subtypes, supertypes, and unions. In fact, this is one of the reasons why I consider TypeScript to be the language with the best type system on the market.</p>",
        "id": 247826720,
        "sender_full_name": "Mac",
        "timestamp": 1627770399
    },
    {
        "content": "<p>On the other hand, I disagree with <span class=\"user-mention\" data-user-id=\"429698\">@Steven Obua</span> on the following claim:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247817864\">said</a>:</p>\n<blockquote>\n<p>I would say programmers are more \"syntax\" based.</p>\n</blockquote>\n<p>I would argue programmers are much more \"semantic\" than \"syntax\" in how they view types and computer languages in general. I would also say mathematics is much more \"syntactic\".  </p>\n<p>Mathematical logic is essentially just a complex rewrite system (at least from a proof theory perspective) -- and rewrite systems are about as syntactic in nature as you can get. Furthermore, to the due to abstract nature of math, the logic itself rarely has meaning beyond the syntactic at the  level being discussed (even if the concepts do have concrete parallels) . </p>\n<p>Programmatic logic, however, often deals entirely with the semantic meaning of programs. This is why imperative programming is the natural default and functional programming is a novel foreign concept (whereas the opposite is true for math).</p>",
        "id": 247827223,
        "sender_full_name": "Mac",
        "timestamp": 1627771328
    },
    {
        "content": "<p>Yeah, don't take my \"semantic / syntactic\" statement too serious. I think you also have to distinguish between various types of logicians, and normal mathematicians.</p>",
        "id": 247844936,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627801672
    },
    {
        "content": "<p>Certain types of logicians, in particular some proof theorists, are all about syntax. I guess that is part of their job description. But that is not how mathematics in general works.</p>",
        "id": 247844997,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627801792
    },
    {
        "content": "<p>So, when I said \"programmers are more syntax based\", that was really too general a statement.</p>",
        "id": 247845169,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627802060
    },
    {
        "content": "<p>By the way, I agree with your comment about Typescript. I looked at how Typescript uses types, and some of it made a lot of sense to me, and influenced Practical Types.</p>",
        "id": 247845241,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627802182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247844936\">said</a>:</p>\n<blockquote>\n<p>Yeah, don't take my \"semantic / syntactic\" statement too seriously. I think you also have to distinguish between various types of logicians, and normal mathematicians.</p>\n</blockquote>\n<p>Fair enough.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247844997\">said</a>:</p>\n<blockquote>\n<p>Certain types of logicians, in particular some proof theorists, are all about syntax. I guess that is part of their job description. But that is not how mathematics in general works.</p>\n</blockquote>\n<p>I think this probably depends on what one consider to be \"syntax\". As a person who ascribes to formalist philosophy of mathematics, I personally would consider all of mathematics to be about \"syntax\" . However, this is problem because I view a lot more things as \"syntax\" than a lot of people I have encountered.</p>",
        "id": 247869713,
        "sender_full_name": "Mac",
        "timestamp": 1627840679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247820608\">said</a>:</p>\n<blockquote>\n<p>Maybe you want to embed Nat into Real in a different way .</p>\n</blockquote>\n<p>This is just the sort of thing which mathematicians see computer scientists writing and think \"??\"</p>\n<p>There is only one map from Nat into Real which deserves to be called a coercion. You know it's a coercion because when it's used in mathematics papers there is no notation used for it. This is an important thing for mathematicians because they do not think about mathematics completely type-theoretically -- they use a hybrid system. For mathematicians Nat is a subset of Real, and the coercion is the inclusion, and this remains true whatever your foundations are. We're using dependent type theory here so it's important for mathematicians to make this map invisible to the user even though it exists in type theory.</p>\n<p>Of course we're interested in other maps from Nat to Real, but we call them things like <code>f</code> and not \"the coercion\".</p>",
        "id": 247870586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627841900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247870586\">said</a>:</p>\n<blockquote>\n<p>You know it's a coercion because when it's used in mathematics papers there is no notation used for it. [...] For mathematicians Nat is a subset of Real, and the coercion is the inclusion, and this remains true whatever your foundations are.</p>\n</blockquote>\n<p>While I largely agree with your point, I would argue that the fact there is is no notation for it implies it should not, ideally, be a coercion. In math a 'Nat' <em>is</em>  a 'Real', there is no translation occurring. Thus, ideally, there would be no coercion. The idea this even amounts to a coercion is an artifact of the implementation (and to a lesser extent, the type theory), not a part of mathematical logic.</p>\n<p>However, by your statement that 'the coercion is the inclusion', I suspect you may have a different concept of what a 'coercion' is. I, as a computer scientist, view a coercion as the process of translating one data type to another. Generally, this comes with conceptual rule that the what the input and output abstractly represent is equivalent in some manner. Due to the 'in some manner', there can be causes where multiple valid coercions exists. For example, if I wish to coerce a <code>Bool</code> to a <code>UInt32</code>, one valid coercion might be to coerce <code>false</code> to <code>0</code> and <code>true</code> to <code>1</code>. Another valid coercion might be to coerce <code>false</code> to <code>0</code> and <code>true</code> to <code>0xFFFF</code> (all ones). Thus, in general, there is often no 'right' coercion. Cases where there is a 'right' coercion (ex. <code>Nat</code>/<code>Real</code>) should usually ideally not really be coercions. At least, that is how I view the concept of 'coercion'.</p>",
        "id": 247880701,
        "sender_full_name": "Mac",
        "timestamp": 1627857681
    },
    {
        "content": "<blockquote>\n<p>While I largely agree with your point, I would argue that the fact there is is no notation for it implies it should not, ideally, be a coercion. In math a 'Nat' is a 'Real', there is no translation occurring. Thus, ideally, there would be no coercion. The idea this even amounts to a coercion is an artifact of the implementation (and to a lesser extent, the type theory), not a part of mathematical logic.</p>\n</blockquote>\n<p>I don't think that this actually works though, as a litmus test for coercions that should be inclusions, since generally the elements of <code>Z/nZ</code> are written as unadorned numbers despite the fact that the quotient map <code>Z -&gt; Z/nZ</code> is not an injection, so there is no hope of making this be the inclusion map</p>",
        "id": 247881131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627858510
    },
    {
        "content": "<p>In fact, I would say that the lack of any notation for the function is the <em>characteristic property</em> of a coercion. Certainly that's the way it manifests in lean</p>",
        "id": 247881188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627858614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247881131\">said</a>:</p>\n<blockquote>\n<p>since generally the elements of <code>Z/nZ</code> are written as unadorned numbers despite the fact that the quotient map <code>Z -&gt; Z/nZ</code> is not an injection, so there is no hope of making this be the inclusion map</p>\n</blockquote>\n<p>When you say unadorned numbers do you mean numerals or something else? Because numerals are notation, they are not elements of a type (in my view). Their meaning is based on context (i.e., in type theory, the expected type of the value). Thus, unadorned numerals can be part of any type without coercion.</p>",
        "id": 247887509,
        "sender_full_name": "Mac",
        "timestamp": 1627869361
    },
    {
        "content": "<p>Numerals most commonly, but also sometimes elements of <code>nat</code>. Whether notation is used here (for example writing <code>[n]</code> or something) seems to be context-dependent</p>",
        "id": 247887719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627869616
    },
    {
        "content": "<p>I can't really think of any situation where a mathematician would be okay with writing <code>37</code> in a given type but not <code>n</code> where <code>n</code> is indicated to be an arbitrary natural number</p>",
        "id": 247887774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627869711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  I would be <em>very</em> concerned about any formal writing where you explicitly indicate <code>n</code> is to represent a natural number but then use it in places where it is implicitly coerced into something else  (especially in a non-reversible manner) without any notation.</p>",
        "id": 247887911,
        "sender_full_name": "Mac",
        "timestamp": 1627869881
    },
    {
        "content": "<p>However, one part of this still has me confused. Is there even a mathematical notion of coercion? I tend to think of type coercion as a concept original to computer science. And there is certainly both explicit and implicit notions of type coercion in computer science.</p>",
        "id": 247888137,
        "sender_full_name": "Mac",
        "timestamp": 1627870267
    },
    {
        "content": "<p>For example, in Lean, type ascriptions are a form of explicit type conversion that can take the form of a cast or a coercion.</p>",
        "id": 247888288,
        "sender_full_name": "Mac",
        "timestamp": 1627870546
    },
    {
        "content": "<p>You should ask a mathematician for more attestation of coercions, but here are some examples that come to mind:</p>\n<ul>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">nx</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">x</span></span></span></span> in the definition of an archimedean field</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>ω</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\omega^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> as ordinals</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as cardinals</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> as a surreal number</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">aI</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> as a matrix where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> comes from the scalar ring</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>k</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb Z/k\\Bbb Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathbb\">Z</span></span></span></span>, as mentioned</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\Bbb R^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> is a real number</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a, b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\Bbb R^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a, b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> are real numbers</li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">x \\in E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> in a field extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E\\subseteq F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></li>\n<li>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> as an element of the polynomial ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span></li>\n</ul>",
        "id": 247888908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627871430
    },
    {
        "content": "<p>In most cases, this can be explained as \"mathematician decides that a certain subset relation holds because it is convenient in the moment, so that the coercion function is the inclusion\". The issue is that these subset relations are not globally coherent</p>",
        "id": 247889131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627871779
    },
    {
        "content": "<blockquote>\n<p>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">x \\in E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> in a field extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E\\subseteq F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></p>\n</blockquote>\n<p>Why are these subset / subtype relations not globally coherent? For example, in Practal <br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\subseteq F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> would actually hold, I believe, so no need for a coercion. Same for polynomial ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">R^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span>, scalar/ring, etc.</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>k</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb Z/k\\Bbb Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathbb\">Z</span></span></span></span> is different, here indeed a subtype relation cannot work because an operator like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">+</span></span></span></span> has a different meaning. But you gave the notation yourself, in this case one often uses <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span> as a notation, so again, no coercion needed, as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>⋅</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\cdot]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">⋅</span><span class=\"mclose\">]</span></span></span></span> does the mapping explicitly. </p>\n<p>In general, in cases where a coercion is more than just a subtype inclusion, mathematicians don't have a problem of using a bit of explicit notation instead of a coercion.</p>",
        "id": 247892879,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627880382
    },
    {
        "content": "<p>Would a mathematician draw the distinction between <code>aI</code> being a coercion (<code>↑a * I</code>) and not just a heterogeneous multiplication (<code>a • I</code>)?</p>",
        "id": 247900801,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627893676
    },
    {
        "content": "<p>I would think a heterogeneous multiplication feels more natural. Really, I don't think mathematicians use coercions at all, just subtypes. Coercions are a workaround for type theorists because they cannot deal with subtypes.</p>",
        "id": 247901115,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627894016
    },
    {
        "content": "<p>Here is an example of a typical way to construct a new \"type\", as it is planned for Practal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typedef</span> <span class=\"n\">ℤ</span> <span class=\"bp\">=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">⨯</span> <span class=\"n\">ℕ</span>\n  <span class=\"n\">identify</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n  <span class=\"n\">identify</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">ℕ</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is impossible in any current ITP system. It is a trivial and common construction for mathematicians. And it will be easy for Practal. You get a subtyping relation ℕ ⊆ ℤ, in a natural way. Nobody would think of this relation in terms of coercions.</p>\n<p>An ITP system that cannot do above construction is just not adequate for mathematics, no matter how \"constructive\" it is otherwise. It will always be a pain to use it, even though workarounds are possible, of course.</p>",
        "id": 247901385,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627894245
    },
    {
        "content": "<p>I can assure you that if v is an element of a vector space over a finite field and n is a natural then a mathematician would write none of <code>n • v</code>, <code>n * v</code>, <code>\\u n • v</code>... but would instead always write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">nv</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>.</p>",
        "id": 247901814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627894733
    },
    {
        "content": "<p>Similarly if n were in a ring and v was in a module for some algebra for that ring (for example a real number acting on a complex vector or on a module for a ring of real-valued functions)</p>",
        "id": 247901875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627894806
    },
    {
        "content": "<p>It would not even occur to the mathematician that something needed to be said here</p>",
        "id": 247902006,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627894904
    },
    {
        "content": "<p><code>identify n in ℕ with (n, 0)</code> sure looks a lot like the lean coercion <code>coe := λ n : ℕ, (n, 0)</code> to me. Sure, you've used the same keyword you're using for quotient types to make it not look like that, but I find it hard to believe those two <code>identify</code> lines have particularly similar semantics</p>",
        "id": 247903135,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627896142
    },
    {
        "content": "<p>They have pretty much the same semantics, they both define what equality in the newly created type looks like. <br>\nHere is another example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typedef</span> <span class=\"n\">ℚ</span> <span class=\"bp\">=</span> <span class=\"n\">ℤ</span> <span class=\"bp\">⨯</span> <span class=\"o\">(</span><span class=\"n\">ℤ</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span>\n  <span class=\"n\">identify</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">ℚ</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">ℚ</span> <span class=\"n\">where</span> <span class=\"n\">a</span> <span class=\"bp\">⋅</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">⋅</span> <span class=\"n\">b</span>\n  <span class=\"n\">identify</span> <span class=\"n\">z</span> <span class=\"k\">in</span> <span class=\"n\">ℤ</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">ℚ</span>\n</code></pre></div>\n<p>This time I didn't leave out the <code>in</code> clauses that are trivial.</p>\n<p>In Lean, it is just a coercion. In Practal, it is what elements of ℤ (respectively ℚ) <em>ARE</em>.</p>",
        "id": 247903354,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627896386
    },
    {
        "content": "<p>That is why you have to do it at the point of creation of the respective types. You cannot tag that on later, as with coercions.</p>",
        "id": 247903439,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627896470
    },
    {
        "content": "<p>What happens if you add something  that doesn't commute with previous <code>identify</code>s like <code>identify n in ℕ with (1, n) in ℚ</code> to that definition?</p>",
        "id": 247903602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627896612
    },
    {
        "content": "<p>Of course you have to prove that the identifies are compatible with each other. If it can be done automatically, it doesn't need to be visible. If it cannot be done automatically at the moment, but is still trivial, it can be hidden from the casual reader of the construction and shown on request. If the proof of compatibility is interesting in itself, you would show it by default, I guess.</p>",
        "id": 247903774,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627896776
    },
    {
        "content": "<p>What precisely does it mean to prove <code>identify</code>s are compatible? Presumably in the context of proving that, you don't actually have the identifies \"active\", and are proving things about explicit coercion functions?</p>",
        "id": 247903961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627896991
    },
    {
        "content": "<p>Because Practal doesn't have a static type system, but typing judgements are just normal theorems, I expect stuff like this to be straightforward to implement. The burden is of course on providing the necessary proofs, but I am betting on strong automation here.</p>",
        "id": 247903972,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627897001
    },
    {
        "content": "<p>Yes, you will be talking about mappings between types.</p>",
        "id": 247904003,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627897034
    },
    {
        "content": "<p>Even without strong automation, it is better that I can actually do the construction I want to do, with a little bit of computer-assisted leg work to prove it correct.</p>",
        "id": 247904215,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627897208
    },
    {
        "content": "<p>Instead, currently people are told that they shouldn't be using certain constructions of integrals, for example. How utterly ridiculous is that?</p>",
        "id": 247904264,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627897256
    },
    {
        "content": "<p>I have not worked out in detail yet which proof obligations would be generated. But it should work along these lines:</p>\n<ul>\n<li>First an equivalence relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">∼</span></span></span></span> on the representation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> of the new type is generated from those identifications entirely defined on the representation; here no inconsistency can occur, just the equivalence classes can be bigger than what you would expect if you do something wrong. </li>\n<li>Then, for each identification mapping <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>I</mi><mi>N</mi></msub><mo>:</mo><mi>N</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">I_N : N \\rightarrow R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> from a different type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> into the representation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> of the new type it must be shown that equality on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is equivalent to equality according to the equivalence relation on the image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>I</mi><mi>N</mi></msub><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">I_N(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>u</mi><mtext> </mtext><mi>v</mi><mo>:</mo><mi>N</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo>=</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>I</mi><mi>N</mi></msub><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo>∼</mo><msub><mi>I</mi><mi>N</mi></msub><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall u\\, v : N. (u = v) = (I_N(u) \\sim I_N(v))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">))</span></span></span></span> </li>\n<li>Finally, if we have done this for multiple types <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>N</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">N_1, \\ldots, N_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, we need to prove that on the pairwise intersections of the images of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">N_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> the mappings are compatible with the original equality relationship between the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">N_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>: <br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>i</mi><mtext> </mtext><mi>j</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">∀</mi><mi>u</mi><mo>:</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">∀</mi><mi>v</mi><mo>:</mo><msub><mi>N</mi><mi>j</mi></msub><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><msub><mi>I</mi><msub><mi>N</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo>∼</mo><msub><mi>I</mi><msub><mi>N</mi><mi>j</mi></msub></msub><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>u</mi><mo>=</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall i\\, j. \\forall u : N_i. \\forall v : N_j. (I_{N_i}(u) \\sim I_{N_j}(v)) = (u = v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord\">.∀</span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">.∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0973199999999999em;vertical-align:-0.34731999999999996em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833100000000004em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2818857142857143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34731999999999996em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span>    </li>\n</ul>\n<p>If all these conditions can be proven, the new type can be created.</p>",
        "id": 247906955,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627899982
    },
    {
        "content": "<p>For your suggested mapping of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(1, n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, this would not work from the start, as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> cannot be represented in R = ℤ ⨯ ℤ \\ {0}. </p>\n<p>But if we mapped not ℕ, but ℕ \\ {0}, then this would be fine. The third condition is not relevant, as there is only one other type injected into ℚ. And the second condition holds, as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">n = m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> must mean <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>∼</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(1, n) \\sim (1, m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>, which is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">m = n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</p>\n<p>Now, if you start defining addition on ℚ, you will want to ensure that it is compatible with addition on all of its subtypes, which is where you will run into problems here.  I haven't worked out yet in detail how overloading should work in the presence of subtypes.</p>",
        "id": 247907521,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627900713
    },
    {
        "content": "<p>Oh I just saw that you wanted your mapping in <em>addition</em> to the previous one. That would then clash because of the third condition.</p>",
        "id": 247911169,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627904232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247892879\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">x \\in E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> in a field extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E\\subseteq F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></p>\n</blockquote>\n<p>Why are these subset / subtype relations not globally coherent? For example, in Practal <br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\subseteq F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> would actually hold, I believe, so no need for a coercion. Same for polynomial ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">R^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span>, scalar/ring, etc.</p>\n</blockquote>\n<p>My contention is that the mathematician isn't <em>thinking</em> of them as being globally coherent, whether or not they actually are. So even if you try to make them so and pop up proof obligations to ensure it is consistent, the proof obligations will seem weird and unmotivated, and contribute to the usual complaint of \"formalization isn't like regular mathematics\".</p>\n<p>The examples I gave of \"coercions\" may or may not actually be realized as coercions in a proof assistant. For example, as Eric mentions, we do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">nx</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">x</span></span></span></span> using scalar actions in mathlib instead of any kind of coercion. Additionally, some are at least apparently \"true subtypes\", like the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E\\subseteq F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> example - this one gives that away right in the notation. It's hard to gather evidence on this without picking the brains of mathematicians that use the notation, but I think that even these \"true subtyping\" relations are only meant to hold by some kind of abuse of notation, because the actual mechanism needed to make it hold, by cutting out a piece of the newly constructed field extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> to make room for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>, is far too troublesome to countenance in informal maths.</p>",
        "id": 247911675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627904681
    },
    {
        "content": "<p>I'm curious how you intend to make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>⊆</mo><msup><mi>R</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">R\\subseteq R^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span> hold in practal.</p>",
        "id": 247911699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627904705
    },
    {
        "content": "<p>You will certainly have trouble with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mn>3</mn></msup><mo>=</mo><mi>R</mi><mo>×</mo><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><msup><mi>R</mi><mn>2</mn></msup><mo>×</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R^3=R\\times R^2=R^2\\times R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi_1(1,2,3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mclose\">)</span></span></span></span> (where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo>:</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\pi_1:A\\times B\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is the pairing projection) depends on which one you choose</p>",
        "id": 247911841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627904823
    },
    {
        "content": "<p>These identifications may be done with a comment that acknowledges the coercion, for example \"viewing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">R^{m+n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>m</mi></msup><mo>×</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">R^m\\times R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, ... <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u, v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo>∈</mo><msup><mi>R</mi><mi>m</mi></msup></mrow><annotation encoding=\"application/x-tex\">u\\in R^m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>∈</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">v\\in R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, ...\". I would argue that the \"viewing\" clause is saying \"let's assume this coercion exists for the purpose of this proof\", and it will not be explicitly notated, but there is no intent for the coercion to be globally coherent and a proof obligation to show it is would be undesirable</p>",
        "id": 247912076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627905044
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mn>1</mn></msup><mo>=</mo><mi>R</mi><mo separator=\"true\">,</mo><msup><mi>R</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>R</mi><mi>n</mi></msup><mo>×</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R^1 = R, R^{n+1} = R^n \\times R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span></p>\n<p>Then  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mo>⋃</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi mathvariant=\"normal\">∞</mi></msubsup><msup><mi>R</mi><mi>i</mi></msup></mrow><annotation encoding=\"application/x-tex\">P(R) = \\bigcup_{n=1}^\\infty R^i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.124374em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⋃</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">∞</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 247912784,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627905803
    },
    {
        "content": "<p>That's how I would do it.</p>",
        "id": 247912801,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627905816
    },
    {
        "content": "<p>As for how to extend <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, see my examples above with ℕ, ℤ and ℚ. No cutting out required, just proving sensible compatibility conditions. And EVERY mathematician does these proofs, it's just that they are so obvious usually they can be skipped. This is just how it would be in Practal as well.</p>",
        "id": 247912937,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627905943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247912801\">said</a>:</p>\n<blockquote>\n<p>That's how I would do it.</p>\n</blockquote>\n<p>Of course it's possible to just make a choice and stick with it, this is what all existing formal systems do in the first place. My point is that the mathematician wants to avoid making such commitments, so that they can pretend they made the convenient choice when it comes up later in a proof</p>",
        "id": 247914338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627907165
    },
    {
        "content": "<p>I don't think any mathematician is particularly worried about that choice. If you just stick to it, no problems will arise. If for some reason you cannot stick to it in a particular situation, well, there is something more to explain here then.</p>",
        "id": 247914549,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627907347
    },
    {
        "content": "<p>So does <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mn>0</mn></msup><mo>×</mo><mi>R</mi><mo>=</mo><msup><mi>R</mi><mrow><mn>0</mn><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>R</mi><mn>1</mn></msup><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R^0 \\times R = R^{0+1} = R^1 = R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>?</p>",
        "id": 247925937,
        "sender_full_name": "Reid Barton",
        "timestamp": 1627914467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429698\">@Steven Obua</span> I've looked over PractTal. How would you handle quotient types?</p>",
        "id": 247928106,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1627915622
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  Depends on what you want to do, I guess. Let's say you have a <code>List(R)</code> type already. As it is just a data structure, you will NOT want <code>R ⊆ List(R)</code> by design. But if you want to use it to model polynomials, you can define this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typedef</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">List</span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"n\">identify</span> <span class=\"n\">r</span> <span class=\"k\">in</span> <span class=\"n\">R</span> <span class=\"k\">with</span> <span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>You can then go on and define </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typealias</span> <span class=\"n\">R</span><span class=\"bp\">^</span><span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">length</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>You should then be able to define <code>⨯</code> on <code>P(R)</code> so that your equation holds. </p>\n<p>I am not sure if the above leads to problems, because now <code>R = R^1 = (R^1)^1</code> etc. Sounds reasonable, but maybe there is a problem here somewhere.</p>",
        "id": 247929060,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627916149
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"430092\">@Florian Rabe</span> , see the examples above from <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385\">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385</a> on</p>",
        "id": 247929293,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627916270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247929293\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"430092\">Florian Rabe</span> , see the examples above from <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385\">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385</a> on</p>\n</blockquote>\n<p>Ah, so every type comes with its own equality, which can be used for quotienting.<br>\nCould you have a look at my paper on Type-Dependent Equality (<a href=\"https://kwarc.info/people/frabe/Research/rabe_tde_21.pdf\">https://kwarc.info/people/frabe/Research/rabe_tde_21.pdf</a>) and explain how Practal handles the rule for substitution?</p>",
        "id": 247932087,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1627917635
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429698\">@Steven Obua</span> With that definition of <code>P(R)</code>, I think you don't have <code>List(R) ⊆ P(R)</code> or some similar thing, so <code>{ p : P(R) | length p = i }</code> doesn't typecheck, assuming that <code>length</code> is a function defined on <code>List(R)</code>. In fact, you can't have <code>List(R) ⊆ P(R)</code> because <code>P(R)</code> adds some identifications that aren't true in <code>List(R)</code>.</p>",
        "id": 247935236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627919444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"430092\">@Florian Rabe</span> The problem of inconsistency is handled in Practal by making sure that there is only one equality. So, you could call it type dependent, but at the same time it is not, because there is only one equality.</p>",
        "id": 247935326,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627919493
    },
    {
        "content": "<p>There are the initial types of propositions, types, natural numbers and function spaces. They don't intersect, so there is no problem caused by pairs of types. There can only be problems within a type, and I have been careful to avoid them. For example, function spaces are only in a subtyping relationship if they have the same domain.</p>",
        "id": 247935594,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627919627
    },
    {
        "content": "<p>More than the base types, I think the interesting thing going on here is where <code>typedef</code>s come from and how they manage to have all the identifications you ask for</p>",
        "id": 247935713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627919694
    },
    {
        "content": "<p>Note that equality in Practal does not take an additional type parameter, it is just <code>A = B</code>, without any hidden type annotations etc.</p>",
        "id": 247935724,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627919699
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Yes, I think so too. The conditions I have stated earlier should do the job, so applying that to the List example should show a problem if there is one.</p>",
        "id": 247935867,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627919783
    },
    {
        "content": "<p>That is why it is crucial that all the glueing happens at type creation time.</p>",
        "id": 247935982,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627919861
    },
    {
        "content": "<p>That doesn't answer the question about how <code>length p</code> works without a coercion though</p>",
        "id": 247936197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627919999
    },
    {
        "content": "<p>what are the introduction and elimination principles for <code>typedef</code>?</p>",
        "id": 247936345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920050
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Yes, the <code>length</code> definition is the problem. I would like to say  something along the lines of <code>length(rep p)</code> instead, but I guess it has to be <code>length(rep R p)</code> instead or something.</p>",
        "id": 247936476,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627920128
    },
    {
        "content": "<p><code>typedef</code> should introduce <code>rep</code> and <code>abs</code> functions after a successful definition, similar to HOL. How exactly that would work, I haven't thought about yet.</p>",
        "id": 247936657,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627920230
    },
    {
        "content": "<p>I think it has to be <code>rep[P(R)] p</code> or something that picks out precisely which typedef rep you want, because <code>p</code> could have a type that doesn't have anything to do with it, like <code>p : R</code> due to your identification</p>",
        "id": 247936753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920284
    },
    {
        "content": "<p>In HOL the type definition command itself will give you new <code>rep</code> and <code>abs</code> functions that you have an opportunity to name</p>",
        "id": 247936936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920413
    },
    {
        "content": "<p>Basically, rep and abs are overloaded functions, and as I said, I don't know the interplay between overloading and subtyping. Could be that it is easy to solve, could be that a serious problem hides here.</p>",
        "id": 247937048,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627920491
    },
    {
        "content": "<p><code>rep</code> can't be an overloaded function because it takes conflicting values on different typedefs</p>",
        "id": 247937257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920648
    },
    {
        "content": "<p>Each typedef creates a new type, so why would they be conflicting?</p>",
        "id": 247937351,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627920732
    },
    {
        "content": "<p>because <code>rep</code> maps <em>from</em> a type not under your control</p>",
        "id": 247937373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920747
    },
    {
        "content": "<p><code>abs</code> can probably be an overloaded function, but not <code>rep</code></p>",
        "id": 247937392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920759
    },
    {
        "content": "<p>but <code>abs</code> is mathematically unnatural anyway</p>",
        "id": 247937440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920786
    },
    {
        "content": "<p>Ok, so there is one function mapping from the new type T to the representing type R, in symbols T → R. What do we call this function?</p>",
        "id": 247937492,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627920833
    },
    {
        "content": "<p>I am calling it <code>rep</code></p>",
        "id": 247937564,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627920870
    },
    {
        "content": "<p>That's <code>abs</code></p>",
        "id": 247937570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920876
    },
    {
        "content": "<p><code>rep</code> maps into the new type IIRC</p>",
        "id": 247937579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920886
    },
    {
        "content": "<p>I find it more intuitive the other way around, but OK</p>",
        "id": 247937635,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627920919
    },
    {
        "content": "<p>I find them both unintuitive, I might have them mixed up</p>",
        "id": 247937672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920941
    },
    {
        "content": "<p>lean has <code>quot.mk</code> and <code>quot.lift</code></p>",
        "id": 247937708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920964
    },
    {
        "content": "<p><code>quot.mk : A -&gt; A/r</code> and <code>quot.lift : (A -&gt; B) -&gt; conditions -&gt; (A/r -&gt; B)</code></p>",
        "id": 247937742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627920992
    },
    {
        "content": "<p>people tell me <code>lift</code> isn't the right word either though</p>",
        "id": 247937777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921028
    },
    {
        "content": "<p>but notice that <code>quot.lift</code> is not simply <code>A/r -&gt; A</code>. That's the map I call unnatural</p>",
        "id": 247937839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921069
    },
    {
        "content": "<p>let me check hol light for the naming</p>",
        "id": 247937854,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921079
    },
    {
        "content": "<p><code>abs</code> goes into the new type and <code>rep</code> maps back out in HOL</p>",
        "id": 247938003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921175
    },
    {
        "content": "<p>but HOL uses it for subtypes instead of quotients, so some of the polarity is switched</p>",
        "id": 247938043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921203
    },
    {
        "content": "<p>yes, just checked, so that makes sense. Because <code>rep</code> maps to the representing type, and <code>abs</code> abstracts to the new type</p>",
        "id": 247938092,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921229
    },
    {
        "content": "<p>No, the polarity is the same. There is nothing special about quotient types here in that sense.</p>",
        "id": 247938138,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921250
    },
    {
        "content": "<p>quotient maps are defined by a universal property involving a map into the new type, while subtypes are defined by a universal property involving a map out of it</p>",
        "id": 247938213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921297
    },
    {
        "content": "<p>because quotient types are equalizers and subtypes are coequalizers</p>",
        "id": 247938258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921323
    },
    {
        "content": "<p>Well, maybe in category theory.</p>",
        "id": 247938263,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921328
    },
    {
        "content": "<p>Not in Practal.</p>",
        "id": 247938278,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921334
    },
    {
        "content": "<p>in mathematics</p>",
        "id": 247938298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921340
    },
    {
        "content": "<p>if you have something that isn't isomorphic to that it's not a quotient type</p>",
        "id": 247938339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921366
    },
    {
        "content": "<p>Identify just glues things together. I don't see why \"polarity\" or anything like that comes into play.</p>",
        "id": 247938352,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921376
    },
    {
        "content": "<p>The map into your quotient is easy. That's what lean calls <code>quot.mk</code>, and it's like the function <code>List(R) -&gt; P(R)</code> in your example</p>",
        "id": 247938498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921459
    },
    {
        "content": "<p>the hard part is mapping out of the type, because you have to respect all that gluing you did</p>",
        "id": 247938541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921487
    },
    {
        "content": "<p>Yes, like I said: <code>rep</code> is an overloaded function, and how do you define it safely in the presence of subtyping?</p>",
        "id": 247938899,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921690
    },
    {
        "content": "<p>I think if you have a solution for that general problem, you have the solution for <code>typedef</code></p>",
        "id": 247938957,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627921724
    },
    {
        "content": "<p>Consider:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typedef</span> <span class=\"n\">Foo</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">identify</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"mi\">1</span>\n<span class=\"n\">typedef</span> <span class=\"n\">Bar</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">identify</span> <span class=\"mi\">1</span> <span class=\"k\">with</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>Now <code>rep 0 : Foo</code> and <code>rep 0 : Bar</code>, so in particular <code>rep 0 = rep 1 : Bar</code> which seems bad</p>",
        "id": 247939773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922235
    },
    {
        "content": "<p>without knowing what the rules are for elimination from a typedef I can't derive a contradiction from this but it seems fishy</p>",
        "id": 247939953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922386
    },
    {
        "content": "<p>So first we should get the names straight :-)</p>",
        "id": 247940399,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922665
    },
    {
        "content": "<p>I think you mean <code>abs 0 : Foo</code> and <code>abs 0 : Bar</code></p>",
        "id": 247940426,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922685
    },
    {
        "content": "<p>I prefer <code>mk</code></p>",
        "id": 247940546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922764
    },
    {
        "content": "<p>And the <code>abs</code> function is of course dependent on the type, so there would be <code>abs_Foo</code>, and <code>abs_Bar</code>.</p>",
        "id": 247940551,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922769
    },
    {
        "content": "<p>I don't. Let's take <code>rep</code> and <code>abs</code>.</p>",
        "id": 247940568,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922780
    },
    {
        "content": "<p>what even is <code>rep</code> in this example?</p>",
        "id": 247940593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922792
    },
    {
        "content": "<p><code>abs</code> is sort of already taken in mathematics</p>",
        "id": 247940636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922816
    },
    {
        "content": "<p>And also, probably helpful to not get overloading into this, it probably doesn't play a role after all.</p>",
        "id": 247940674,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922837
    },
    {
        "content": "<p>Ok, then <code>represent</code> and <code>abstract</code></p>",
        "id": 247940712,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922853
    },
    {
        "content": "<p>lean uses <code>mk</code> consistently for constructors of inductive types, quotient types and other \"new\" types</p>",
        "id": 247940766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922882
    },
    {
        "content": "<p>So after your definitions, we have functions <code>represent_Foo</code> and <code>abstract_Foo</code> and <code>represent_Bar</code> and <code>abstract_Bar</code></p>",
        "id": 247940799,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922902
    },
    {
        "content": "<p>So if <code>mk</code> is <code>abs</code>, what is <code>rep</code> ?</p>",
        "id": 247940854,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922931
    },
    {
        "content": "<p>honestly spelling the names out doesn't help me at all</p>",
        "id": 247940857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922934
    },
    {
        "content": "<p>there is no <code>rep</code></p>",
        "id": 247940885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922941
    },
    {
        "content": "<p>exactly</p>",
        "id": 247940899,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922946
    },
    {
        "content": "<p>no I mean it doesn't make any sense to have in the first place</p>",
        "id": 247940929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922962
    },
    {
        "content": "<p>like I said, what is it in this example?</p>",
        "id": 247940957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627922975
    },
    {
        "content": "<p>But in our context it makes a lot of sense.</p>",
        "id": 247940971,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627922983
    },
    {
        "content": "<p>Ok, I call it <code>rep_Foo</code>, <code>rep_Bar</code>, <code>abs_Foo</code> and <code>abs_Bar</code></p>",
        "id": 247941040,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923013
    },
    {
        "content": "<p>Do you have empty types?</p>",
        "id": 247941048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923016
    },
    {
        "content": "<p>Yes.</p>",
        "id": 247941072,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923024
    },
    {
        "content": "<p>If so, you can't have a <code>rep</code></p>",
        "id": 247941076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923025
    },
    {
        "content": "<p>You mean for an empty type you cannot have a <code>rep</code>.</p>",
        "id": 247941148,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923059
    },
    {
        "content": "<p>yes</p>",
        "id": 247941166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923065
    },
    {
        "content": "<p>and for nonempty types it's always going to be arbitrary, for example is <code>rep_Foo (abs_Foo 0)</code> equal to 0 or 1</p>",
        "id": 247941271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923109
    },
    {
        "content": "<p>Yes, so I guess a good proof obligation is to show that it is not empty. Makes a lot of sense, because otherwise the new type would be equal to the empty type due to type extensionality</p>",
        "id": 247941297,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923123
    },
    {
        "content": "<p>So, let's assume our new types are not empty from now on.</p>",
        "id": 247941379,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923170
    },
    {
        "content": "<p>That sounds like an unnecessary thing to worry about, and a limitation that will add unnatural proof obligations</p>",
        "id": 247941411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923187
    },
    {
        "content": "<p>there are lots of type families that are not necessarily nonempty</p>",
        "id": 247941449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923206
    },
    {
        "content": "<p>don't go the mizar route</p>",
        "id": 247941487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923224
    },
    {
        "content": "<p>this is why <code>lift</code> is better than <code>rep</code></p>",
        "id": 247941563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923273
    },
    {
        "content": "<p>So, in your case, <code>rep_Foo : Foo → ℕ</code>, <code>abs_Foo : ℕ → Foo</code>, <code>rep_Bar : Bar → ℕ</code> and <code>abs_Bar : ℕ → Bar</code>.</p>",
        "id": 247941595,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923290
    },
    {
        "content": "<p>Forget about lift and so on. It's different.</p>",
        "id": 247941657,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923321
    },
    {
        "content": "<p>what are the axioms for those functions?</p>",
        "id": 247941710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923352
    },
    {
        "content": "<p>And there is no problem with making a special case for the empty type. It even makes a lot of sense, as I explained.</p>",
        "id": 247941715,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923353
    },
    {
        "content": "<p>What would you think the axioms are?</p>",
        "id": 247941808,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923408
    },
    {
        "content": "<p>I know what the axioms for <code>lift</code> are, but for <code>rep</code> you have a symmetry breaking problem</p>",
        "id": 247941855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923437
    },
    {
        "content": "<p><span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span>  I don't know, does HOL Light also have a symmetry breaking problem?</p>",
        "id": 247941968,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923493
    },
    {
        "content": "<p>HOL light isn't doing quotient types</p>",
        "id": 247941985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923504
    },
    {
        "content": "<p>you are</p>",
        "id": 247941992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923508
    },
    {
        "content": "<p>You are in your Foo / Bar example also not doing quotient types</p>",
        "id": 247942012,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923522
    },
    {
        "content": "<p>So maybe just forget about \"quotient types\"</p>",
        "id": 247942040,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923536
    },
    {
        "content": "<p>yeah, that's a quotient of nat making 0 = 1</p>",
        "id": 247942049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923540
    },
    {
        "content": "<p>That's glueing <code>0</code> together with <code>1</code>.</p>",
        "id": 247942084,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923559
    },
    {
        "content": "<p>that's called a quotient type</p>",
        "id": 247942100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923566
    },
    {
        "content": "<p>importantly, 2 and 3 are not equal in Foo</p>",
        "id": 247942163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923590
    },
    {
        "content": "<p>that is, elements are equal only if they were \"glued\" or if they follow from equality axioms from gluing prescriptions</p>",
        "id": 247942244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923619
    },
    {
        "content": "<p>that's a quotient type</p>",
        "id": 247942257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923622
    },
    {
        "content": "<p>As I said, let's not use the word \"quotient type\". It seems to have a certain meaning to you, and not all of them apply in our case, I think.</p>",
        "id": 247942398,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923676
    },
    {
        "content": "<p>To define a function on <code>Foo -&gt; A</code>, you give a function <code>f : Nat -&gt; A</code> such that <code>f 0 = f 1</code></p>",
        "id": 247942414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923685
    },
    {
        "content": "<p>and the resulting function <code>lift f : Foo -&gt; A</code>  will satisfy <code>lift f (abs n) = f n</code></p>",
        "id": 247942477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923719
    },
    {
        "content": "<p>Yes, let's talk about how to define functions on <code>Foo</code>.</p>",
        "id": 247942501,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923728
    },
    {
        "content": "<p>no need for <code>rep</code></p>",
        "id": 247942528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627923741
    },
    {
        "content": "<p>To define <code>f : Foo → A</code>, I want to do it by defining <code>g : ℕ → A</code> first, and then set <code>f x = g(rep x)</code></p>",
        "id": 247942675,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923807
    },
    {
        "content": "<p>So you see, there is a <code>rep</code> in here, or rather <code>rep_Foo</code></p>",
        "id": 247942706,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923827
    },
    {
        "content": "<p>let' say that <code>a ~ b</code> in ℕ if a and b are glued together by <code>abs_Foo</code></p>",
        "id": 247942819,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627923890
    },
    {
        "content": "<p>We might have <code>x ≠ y</code>, but <code>abs_Foo x = abs_Foo y</code>. So we need <code>g(x) = g(y)</code> for <code>abs_Foo x = abs_Foo y</code>, I guess.</p>",
        "id": 247943528,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924085
    },
    {
        "content": "<p>So that's the condition on <code>g</code> we need to make <code>f</code> well-defined.</p>",
        "id": 247943639,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924115
    },
    {
        "content": "<p>right, that's exactly the condition on <code>lift</code> that I mentioned</p>",
        "id": 247943772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924168
    },
    {
        "content": "<p>It doesn't help to switch names all the time. Let's stick with <code>rep</code> and <code>abs</code>.</p>",
        "id": 247943834,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924196
    },
    {
        "content": "<p><code>lift</code> has a different type signature than <code>rep</code></p>",
        "id": 247943867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924209
    },
    {
        "content": "<p>What is it?</p>",
        "id": 247943903,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924228
    },
    {
        "content": "<p><code>lift : (OldType -&gt; A) -&gt; conditions -&gt; (NewType -&gt; A)</code></p>",
        "id": 247943940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924249
    },
    {
        "content": "<p>if you don't use dependent types then the <code>conditions</code> are not actually arguments to the function</p>",
        "id": 247943984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924269
    },
    {
        "content": "<p>so it would just be <code>lift_Foo : (Nat -&gt; A) -&gt; (Foo -&gt; A)</code> in this example</p>",
        "id": 247944030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924296
    },
    {
        "content": "<p>you probably need <code>A</code> to be an additional argument, it's a family of functions over any target type <code>A</code></p>",
        "id": 247944159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924349
    },
    {
        "content": "<p>So <code>lift</code> is about how to go from functions on <code>OldType</code> to functions on <code>NewType</code>. But <code>rep</code> and <code>abs</code> are more basic. They are about going from members of <code>OldType</code> to members of <code>NewType</code></p>",
        "id": 247944183,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924363
    },
    {
        "content": "<p><code>lift</code> can then be defined in terms of those.</p>",
        "id": 247944219,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924384
    },
    {
        "content": "<p>yes, and I assert that's the wrong way to think about quotient types</p>",
        "id": 247944222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924387
    },
    {
        "content": "<p>It might be a way you don't like. Doesn't mean its wrong.</p>",
        "id": 247944256,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924405
    },
    {
        "content": "<p>I have never seen any presentation of quotient types that prefers that approach outside of formalization (and HOL in particular)</p>",
        "id": 247944328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924447
    },
    {
        "content": "<p>it's almost always about the quotient map and the \"well definedness condition\"</p>",
        "id": 247944362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924465
    },
    {
        "content": "<p>You have never seen an approach like Practal either. It's the best though :-)</p>",
        "id": 247944369,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924468
    },
    {
        "content": "<p>In the end, I think <code>rep</code> and <code>abs</code> is conceptually simpler.</p>",
        "id": 247944607,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924584
    },
    {
        "content": "<p>It is simpler to talk about members of types, than about functions on types. At least for me.</p>",
        "id": 247944656,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924610
    },
    {
        "content": "<p>So I'll stick to that terminology for now, to understand why the <code>List</code> example is problematic.</p>",
        "id": 247944786,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924670
    },
    {
        "content": "<p>So what are the proof obligations for the <code>P(R)</code> example?</p>",
        "id": 247944948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627924760
    },
    {
        "content": "<p>I'll think about the problem offline for now, gotta eat :-)  I'll post later if I have something!</p>",
        "id": 247945303,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627924972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247940766\">said</a>:</p>\n<blockquote>\n<p>lean uses <code>mk</code> consistently for constructors of inductive types, quotient types and other \"new\" types</p>\n</blockquote>\n<p>I quite dislike Lean's use of <code>mk</code>. The word 'mk' (i.e. 'make') is very imperative and  I associate that strongly with a side-effect having action (i.e. a monadic action) and yet most <code>mk</code> functions are pure. This, to me, is very counterintuitive.</p>",
        "id": 248183502,
        "sender_full_name": "Mac",
        "timestamp": 1627968444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247941271\">said</a>:</p>\n<blockquote>\n<p>and for nonempty types it's always going to be arbitrary, for example is <code>rep_Foo (abs_Foo 0)</code> equal to 0 or 1</p>\n</blockquote>\n<p>Wouldn't it definitely be <code>0</code>? I mean the whole idea is that <code>abs</code> abstracts from a primitive type to an abstract <code>typedef</code> and <code>rep</code> converts the abstract typdef back to its primitive type representation, right? So <code>rep . abs = id</code> should always hold?</p>",
        "id": 248183741,
        "sender_full_name": "Mac",
        "timestamp": 1627968817
    },
    {
        "content": "<p>I would also suggest the shorthand <code>repr</code> and <code>abst</code> for <code>rep</code> and <code>abs</code> to prevent the name clash with math's <code>abs</code>.</p>",
        "id": 248183942,
        "sender_full_name": "Mac",
        "timestamp": 1627969096
    },
    {
        "content": "<p>I think Mario's point is that <code>abs_Foo 0 = abs_Foo 1</code>, so by substitution we would assume <code>rep_Foo (abs_Foo 0) = rep_Foo (abs_Foo 1)</code>. If you pick <code>rep_Foo (abs_Foo 0) = 0</code> you can't also pick <code>rep_Foo (abs_Foo 1) = 1</code>, because if you did you no longer have <code>x = y → f x = f y</code>.</p>",
        "id": 248191347,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627976995
    },
    {
        "content": "<p>Lean resolves this by having both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quot.unquot\">docs#quot.unquot</a>, which satisfies <code>unquot (mk x) = x</code> but lives in unsound <code>meta</code> land, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quot.out\">docs#quot.out</a> which only satisfies <code>mk (out q) = q</code> and is noncomputable</p>",
        "id": 248195535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627980042
    },
    {
        "content": "<p>I've been thinking about it for a bit now, and I think the best strategy is to just implement it in Practal Light. That should clarify problems with this typedef approach if there are any. There will be a better basis for discussion then, and the proof obligations will be clear then.  From what I see currently, typedef that defines a type without parameters works fine as described, including quotients and injected subtypes. For a typedef that takes a parameter, as in <code>Poly X</code>, which has parameter <code>X</code>, there are (at least) two options what that can mean, even without any quotient or injecting features. It can be a \"disjoint\" typedef, where each different <code>X</code> yields a different type, that is <code>X ≠ Y ⟶ Poly X ∩ Poly Y = ∅</code>. This case should be similar to the parameterless case, just that everything takes a parameter <code>X</code> in addition. Or it can be a \"union\" typedef , where equal representations imply equal abstractions regardless of parameter: <br>\n<code>r : Repr[X] ∩ Repr[Y] ⟶ abstr X r = abstr Y r</code>.  <br>\nI think both options make sense.</p>",
        "id": 248223105,
        "sender_full_name": "Steven Obua",
        "timestamp": 1627998624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429698\">@Steven Obua</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> regarding Quotient types and abs/rep:</p>\n<p>I didn't follow all the discussion, but the following might be helpful.<br>\nThe abs/rep intuition from HOL-style predicate subtypes carries over to quotient types as follows:</p>\n<p>For predicate types<br>\nabs: newtype -&gt; oldtype   is the canonical injection<br>\nrep: oldtype -&gt; newtype   is a partial function (undefined for values not in the subtype)</p>\n<p>For quotient types<br>\nabs: newtype -&gt; oldtype  is a non-deterministic function (returns any element of the equivalence class)<br>\nrep: oldtype -&gt; newtype  is the canonical projection</p>\n<p>You can unify the two by using a total, injective relation<br>\nr : newtype x oldtype -&gt; prop<br>\nr is functional for a subtype, surjective for a quotient type, and both functional and surjective for an isomorphism.</p>",
        "id": 248248916,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1628009982
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"430092\">@Florian Rabe</span> Hah, you also got <code>rep</code> and <code>abs</code> the wrong way around :-)</p>",
        "id": 248254038,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628012500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248254038\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"430092\">Florian Rabe</span> Hah, you also got <code>rep</code> and <code>abs</code> the wrong way around :-)</p>\n</blockquote>\n<p>Seriously? I checked back and forth like 5 times before I gave up :)</p>",
        "id": 248263697,
        "sender_full_name": "Florian Rabe",
        "timestamp": 1628017049
    },
    {
        "content": "<p>I really am surprised at how confusing <code>rep</code> and <code>abs</code> seem to be. Could someone explain what makes the  terminology confusing to them? I would really like to know were the counterintuition lies since the terms seem rather intuitive to me.</p>",
        "id": 248429616,
        "sender_full_name": "Mac",
        "timestamp": 1628127947
    },
    {
        "content": "<p>\"abstraction\" is not helpful because I'm not sure which side is considered to be more abstract, and \"representation\" sounds like it might be the map into the new type but apparently it's the other way around</p>",
        "id": 248429701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628128055
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Interesting. It thus appears we have very different notions of 'abstract' and 'representation'. In my view, the if type <code>A is defined in terms of type </code>B<code>  (ex. </code>typdef A = B<code>), I would always describe </code>A<code> as more 'abstract than </code>B`.  And I view the 'representation' of an 'abstract' type to be said definition. I feel like this close to the usual CS definitions of those words. Could it be that 'abstract' and 'representation' have very different intuitions in math vs CS?</p>",
        "id": 248431719,
        "sender_full_name": "Mac",
        "timestamp": 1628130471
    },
    {
        "content": "<p>I can see why you might call <code>A</code> more abstract than <code>B</code>, but it still seems categorically wrong to talk about the constructor of an (abstract) data type as \"abstraction\"</p>",
        "id": 248433103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628132050
    },
    {
        "content": "<p>abstraction is the meta-level mechanism of introducing <code>A</code> as a type</p>",
        "id": 248433120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628132076
    },
    {
        "content": "<p>but the constructor is just a constructor</p>",
        "id": 248433129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628132107
    },
    {
        "content": "<p>which is why I prefer names like <code>new</code> or <code>mk</code> or <code>of</code> or <code>intro</code></p>",
        "id": 248433145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628132149
    },
    {
        "content": "<p>similarly, the reverse map is a destructor or (field) projection, so I would prefer a name like <code>dest</code> or <code>out</code> or <code>proj</code></p>",
        "id": 248433244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628132278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Interesting, it seems we have very different views on terminology. </p>\n<p>First, I have long had mixed feelings about the terms 'constructor' and 'destructor' being used to describe the manipulation of pure terms, as I associate those terms with imperative impure actions. However, there are admittedly many cases where no better term exists. (Luckily, as far as I am concerned, this is not one of those cases! <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span>) </p>\n<p>Also, as an aside, I do not get where the term 'projection' for  dot notation (or destructors) came from -- I suspect math -- but it strikes me as wholly unintuitive jargon. Admittedly, the term 'field' for such things does seem natural to me, despite the fact that it is also jargon from I am not sure where). </p>\n<p>On the other hand, it seems perfectly natural to me to define as 'abstraction' the operation of producing some 'newtype from some 'oldtype', or as I would phrase it: (further) abstracting 'oldtype' to 'newtype'..</p>",
        "id": 248443151,
        "sender_full_name": "Mac",
        "timestamp": 1628145438
    },
    {
        "content": "<p>I suspect this may all came down to the natural jargon of  someone coming from a primarily computer science background vs. the natural jargon of someone coming from a more math-focused background (if I am correct in assuming your background) .</p>",
        "id": 248443731,
        "sender_full_name": "Mac",
        "timestamp": 1628146171
    },
    {
        "content": "<p>Maybe just call the functions <code>new</code> and <code>old</code> :-)</p>",
        "id": 248478946,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628171232
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> </p>\n<blockquote>\n<p>First, I have long had mixed feelings about the terms 'constructor' and 'destructor' being used to describe the manipulation of pure terms, as I associate those terms with imperative impure actions.</p>\n</blockquote>\n<p>Constructors in lean are a very direct analogue to constructors in java or rust. Constructors in non-functional languages can have side effects, but, well, so can everything else. Rust in particular uses <code>new</code> as a conventional function name for a function returning the new type and calls it a constructor, even if it is a pure function (and it usually is), and at the memory level lean's constructor is allocating memory and filling it with provided stuff, so I don't think it is a misnomer at all.</p>\n<p>An alternative view point from formal logic is to call this the \"introduction rule\", and it is usually paired with an \"elimination rule\". Lean calls these eliminators or recursors, although the latter terminology only makes sense for a non-recursive type so it would be a bit of a weird choice if the language doesn't support recursion through this mechanism. So for example the introduction rule for 'and' is <code>A -&gt; B -&gt; A /\\ B</code> and the elimination rule is <code>A /\\ B -&gt; A</code> and <code>A /\\ B -&gt; B</code>. In lean this is exactly the same thing as a constructor and the two projections, so that's why those names get conflated.</p>\n<blockquote>\n<p>Also, as an aside, I do not get where the term 'projection' for dot notation (or destructors) came from -- I suspect math -- but it strikes me as wholly unintuitive jargon.</p>\n</blockquote>\n<p>As for why \"projection\", the reason comes from the product type, which is a structure with two fields <code>fst : A</code> and <code>snd : B</code>. These functions of types <code>A x B -&gt; A</code> and <code>A x B -&gt; B</code> are called projection functions in mathematics, and the reason for this is because of the geometric effect of the function, for example if you have some shape in R^2 and get the image of the first projection you get its \"shadow\" on the y-axis. There are other kinds of projection in mathematics like stereographic projection but they all involve some kind of noninjective map and a lowering of dimension.</p>",
        "id": 248480698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628171998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>at the memory level lean's constructor is allocating memory and filling it with provided stuff, so I don't think it is a misnomer at all.</p>\n</blockquote>\n<p>This is an implementation detail, not part of the conceptual abstraction, thus I have qualms with it bleeding into the terminology. Furthermore, during compilation various optimizations can 'constructors' entirely stateless (evaluate them at runtime, turn it into an immediate, etc.). So even a implementation level, this is not necessarily a correct description.</p>\n<blockquote>\n<p>An alternative view point from formal logic is to call this the \"introduction rule\", and it is usually paired with an \"elimination rule\". Lean calls these eliminators or recursors</p>\n</blockquote>\n<p>Yep,  I personally  quite like this terminology, though I realize it also may be unintuitive for some.</p>\n<blockquote>\n<p>As for why \"projection\", the reason comes from the product type, which is a structure with two fields fst : A and snd : B. These functions of types <code>A x B -&gt; A</code> and <code>A x B -&gt; B</code> are called projection functions in mathematics, and the reason for this is because of the geometric effect of the function, for example if you have some shape in R^2 and get the image of the first projection you get its \"shadow\" on the y-axis. There are other kinds of projection in mathematics like stereographic projection but they all involve some kind of noninjective map and a lowering of dimension.</p>\n</blockquote>\n<p>Ah, so my suspicious was correct -- math is the culprit! I would say the complexity of that explanation should be reason enough as to why 'projection' is very unintuitive terminology.  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 248551848,
        "sender_full_name": "Mac",
        "timestamp": 1628207636
    },
    {
        "content": "<p>I won't deny that the word \"projection\" has travelled far from its roots, but it is still fairly standard CS terminology to call the functions out of a record/tuple type projections</p>",
        "id": 248552668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628208348
    },
    {
        "content": "<p>That last point is something of a pet peeve of mine in mathematics. Jargon in math generally takes way to many level of allegory to explain. For example, in this case 'projection' requires about 7 levels of allegory (physical shadow -&gt; geometric projection of a shape -&gt; geometrically reduces dimension -&gt; mathematical projection function -&gt; product type projection -&gt;  field projection -&gt; dot notation). </p>\n<p>While jargon in computer science also often to involve allegory, it tends to be more direct. For example 'constructor' (physical construction -&gt; abstraction construction). A more technical example could be something like a tail call (tail of an animal -&gt; end of an object -&gt; call at the end of a procedure).</p>\n<p>(fyi, I wrote this as continuation to my previous statement, but didn't finish it before you responded XD)</p>",
        "id": 248552763,
        "sender_full_name": "Mac",
        "timestamp": 1628208413
    },
    {
        "content": "<p>googling field projection reminds me also that this is standard terminology in databases - selecting one field from a table is called a projection operator</p>",
        "id": 248552876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628208503
    },
    {
        "content": "<p>Well there are a lot of mathematicians in computer science so I would expect the terminology to mix. <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 248552927,
        "sender_full_name": "Mac",
        "timestamp": 1628208552
    },
    {
        "content": "<p>That doesn't make the terminology any more intuitive to the uninitiated (or those not as mathematically inclined).</p>",
        "id": 248553075,
        "sender_full_name": "Mac",
        "timestamp": 1628208683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248551848\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>at the memory level lean's constructor is allocating memory and filling it with provided stuff, so I don't think it is a misnomer at all.</p>\n</blockquote>\n<p>This is an implementation detail, not part of the conceptual abstraction, thus I have qualms with it bleeding into the terminology. Furthermore, during compilation various optimizations can 'constructors' entirely stateless (evaluate them at runtime, turn it into an immediate, etc.). So even a implementation level, this is not necessarily a correct description.</p>\n</blockquote>\n<p>Well you are the one saying it has to be stateful. I think a constructor only needs to construct an element of the new type, and whether that is pure or not is besides the point. I prefer my constructors to be pure functions, even in impure languages.</p>",
        "id": 248553177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628208775
    },
    {
        "content": "<p>For me, when my brain hears projection, it thinks of the physical phenomena and is incapable of properly connect that to the abstract concept. Even with that background, the connection is too distant for my brain to internalize it as intuitive.</p>",
        "id": 248553212,
        "sender_full_name": "Mac",
        "timestamp": 1628208809
    },
    {
        "content": "<p>also, your description of compilers playing tricks with constructors applies just as much to <code>new Foo()</code> in java, which are for me the ur-example of constructors in CS</p>",
        "id": 248553375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628208957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248553177\">said</a>:</p>\n<blockquote>\n<p>Well you are the one saying it has to be stateful. I think a constructor only needs to construct an element of the new type, and whether that is pure or not is besides the point. I prefer my constructors to be pure functions, even in impure languages.</p>\n</blockquote>\n<p>Fair. While I do personally find it pure constructors/destructors a little counterintuitive, I do admit they are still often the best terms for the concept (as I mentioned before).</p>",
        "id": 248553429,
        "sender_full_name": "Mac",
        "timestamp": 1628208971
    },
    {
        "content": "<p>Yes, language is overloaded, especially in particle physics: spin, flavor, charm...</p>",
        "id": 248553439,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628208977
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Yep. Neologisms and overloaded language are quite a common part of math, philosophy, and computer science. While any new jargon is confusing at some level, it is a necessary part of formalization and I have no problem with it in general. My problem is when the overloaded definition is far removed from its natural definition even when reason for the name is explained.</p>",
        "id": 248553635,
        "sender_full_name": "Mac",
        "timestamp": 1628209154
    },
    {
        "content": "<p>For me at least, distance connections make it extremely hard to remember the overloaded meaning as my brain keeps trying to default to natural meaning and the clash causes cognitive dissonance.</p>",
        "id": 248553877,
        "sender_full_name": "Mac",
        "timestamp": 1628209380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248553375\">said</a>:</p>\n<blockquote>\n<p>also, your description of compilers playing tricks with constructors applies just as much to <code>new Foo()</code> in java, which are for me the ur-example of constructors in CS</p>\n</blockquote>\n<p>True. For me, though, there is a difference conceptually at where the optimization occurs. </p>\n<p>Part of the defined behavior of the constructor <code>new Foo()</code> in Java is to constructor a new <code>Foo</code> in memory. Thus, when optimization is turned off, it will always construct a new Foo in memory. In a pure language, however, It is <em>not</em> part of the defined behavior of a constructor to allocate memory. Thus a compiler, even with optimization turn off, can choose to compile a constructor to something else (e.g., because it is more efficient to do so).</p>\n<p>In C++ terms, in an imperative language, memory allocation is part of the standardized behavior of a constructor. In a pure language, it is not. It is instead part of the compiler-specific behavior of the constructor.</p>",
        "id": 248555126,
        "sender_full_name": "Mac",
        "timestamp": 1628210893
    },
    {
        "content": "<p>This difference in the what is the defined behavior of a constructor is why I consider the application of the same term to both cases to be a (little) bit of a misnomer.</p>",
        "id": 248555221,
        "sender_full_name": "Mac",
        "timestamp": 1628211016
    },
    {
        "content": "<p>That kind of analogy is pretty common in programming languages. Sure it's not exactly the same as the imperative case, but the word constructor doesn't fit any other concept in the language better</p>",
        "id": 248555267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628211110
    },
    {
        "content": "<p>Here are some common CS jargon words that are quite removed from their original meaning:</p>\n<blockquote>\n<p>block, boot, bug, class, closure, code, daemon, execution, glob, inheritance, linker, stack, subroutine</p>\n</blockquote>",
        "id": 248555269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628211113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248555269\">said</a>:</p>\n<blockquote>\n<p>Here are some common CS jargon words that are quite removed from their original meaning:</p>\n<blockquote>\n<p>block, boot, bug, class, closure, code, daemon, execution, glob, inheritance, linker, stack, subroutine</p>\n</blockquote>\n</blockquote>\n<p>I disagree largely with this list. I would consider 'block, class, code, and execution' to be direct parallels, 'linker, closure, stack, inheritance, subroutine' to be close parallels. I would also consider 'bug' to be a close metaphor and only 'daemon and glob' to be esoteric.</p>",
        "id": 248555766,
        "sender_full_name": "Mac",
        "timestamp": 1628211627
    },
    {
        "content": "<p>close parallel to what? A programming error is not like an insect at all, a code block is not a \"cuboid piece of substance\" to borrow wiktionary, \"execution\" is not how you kill people unless you are a malfeasant programmer</p>",
        "id": 248556100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628212060
    },
    {
        "content": "<p>anyway this is just how language goes. Meanings evolve from other meanings, and if you trace it all back you get some odd results</p>",
        "id": 248556280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628212259
    },
    {
        "content": "<p>there isn't anything to be said for intuitive naming besides \"you get used to it\"</p>",
        "id": 248556306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628212302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  The word execution is defined as \"\"a carrying out, a putting into effect\" which is exactly what it means in CS. (its use to describe the death penalty is simply a euphemistic use of this meaning) . Block in CS (i.e. 'a block of text') comes from a 'block of text' where block is used to mean a large chunk/piece of something. The word 'block' initially being used to mean a piece/chunk of wood.</p>",
        "id": 248556312,
        "sender_full_name": "Mac",
        "timestamp": 1628212308
    },
    {
        "content": "<p>I'm aware that in each case there is a chain of meaning, often quite logical</p>",
        "id": 248556365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628212340
    },
    {
        "content": "<p>My point is that they are directly related to their natural language meaning and etymology.</p>",
        "id": 248556373,
        "sender_full_name": "Mac",
        "timestamp": 1628212364
    },
    {
        "content": "<p>With, at most, one level of analogy/metaphor.</p>",
        "id": 248556392,
        "sender_full_name": "Mac",
        "timestamp": 1628212398
    },
    {
        "content": "<p>most math terms have the same kind of chain, but one is limited by the strength of analogy to something abstract</p>",
        "id": 248556409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628212440
    },
    {
        "content": "<p>This would be the same for a geometric projection of an image in space. That is one hop. Going from that to a projection is CS is like another 5 hops that require mathematical expertise to see the logic in.</p>",
        "id": 248556459,
        "sender_full_name": "Mac",
        "timestamp": 1628212479
    },
    {
        "content": "<p>I thought of putting \"global\" on the list, but the meaning of \"everywhere\" is also common, even though it originally derives from \"round\"</p>",
        "id": 248556496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628212541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248556409\">said</a>:</p>\n<blockquote>\n<p>most math terms have the same kind of chain, but one is limited by the strength of analogy to something abstract</p>\n</blockquote>\n<p>Yes, the problem here is the 'chain' part. Jargon should ideally be directly analogous (either by parallel or metaphor)  to its natural meaning.</p>",
        "id": 248556498,
        "sender_full_name": "Mac",
        "timestamp": 1628212549
    },
    {
        "content": "<p>The problem I have with jargon is in math is that that it makes jargon of jargon of jargon (and so on).</p>",
        "id": 248556580,
        "sender_full_name": "Mac",
        "timestamp": 1628212620
    },
    {
        "content": "<p>Instead of just making different terms (or composite terms) for things.</p>",
        "id": 248556611,
        "sender_full_name": "Mac",
        "timestamp": 1628212674
    },
    {
        "content": "<p>As a CS person, I do sympathize with the desire, for example, to not call a 'group' a 'unital invertible associative magma'. (we do like our short terms) But I would at least like the term to have a close analogy (even by metaphor) to its definition in natural language.</p>",
        "id": 248556814,
        "sender_full_name": "Mac",
        "timestamp": 1628212885
    },
    {
        "content": "<p>This is also why I like the term 'binar' better than 'magma'. It at least incorporates the fact the the function in question is binary.</p>",
        "id": 248556975,
        "sender_full_name": "Mac",
        "timestamp": 1628213061
    },
    {
        "content": "<p>Admittedly, there is often not good analogues to be had for some very abstract concepts and thus largely arbitrary terms are sometimes needed. One of the reasons to teach math to children is so that they can learn these arbitrary terms at the same time the are learning natural language so that the become intuitive words in their vocabulary.</p>",
        "id": 248557183,
        "sender_full_name": "Mac",
        "timestamp": 1628213298
    },
    {
        "content": "<p>Once a person becomes an adult it is much harder to learn such arbitrary language. This is in part why learning a different (natural) languages as an adult is so hard.</p>",
        "id": 248557207,
        "sender_full_name": "Mac",
        "timestamp": 1628213343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> When you send around the request for CICM videos I realised just then that you had a new paper out on CICM, and I checked it out this morning. No wonder that you are the only one I've found so far who is interested in Practical Types! I see that with MM0 you have a very similar approach to theorem proving as I do now. Practical Types and MM0 need to solve similar problems, and it is interesting to look at what the differences are. I have now implemented a first version of a Kernel for Practal Light (that sits in a separate branch currently), with the one missing feature being <code>typedef</code>, which is next in the works. So I see clearer now on a few points. \"First-Order Abstract Syntax\" seems to be a really useful concept that works very well for me so far. I am not sure if it is new, or if it has been around under other names already. I think what it does is solve the same problem as Higher-Order Abstract Syntax, but not introduce function sorts, etc., but stay first-order. In MM0 you also need to solve the binder problem, and you seem to do that with the V(t) / FV(t) mechanism, and by including the names of dependent variables in the types of meta-variables. In Practal Light, meta variables are just the free variables, and the type of these meta variables is just their arity.   I have two term representations now: <code>Term</code>, which doesn't explicitly distinguish between bound and free variables, and <code>Tm</code>, which is based on de Bruijn indices, and much better suited for things like substitutions. I am currently converting between the two in the kernel, but for an efficient implementation I should probably just stick to <code>Tm</code> internally and reserve <code>Term</code> for the frontend. </p>\n<p>Implementing the Kernel also cleared up some other issues for me. In particular, it makes a lot of sense to design Practal Light also as a logical framework, just as MM0 is a logical framework also. In the beginning I conceived Practical Types as a whole, but it is better to break it down. You voiced concerns earlier about the underlying logic being too complex and not simple enough, and I think that should address your concern. The kernel doesn't know about most of Practical Types so far, and it should stay that way, except for <code>typedef</code> of course, which is not implemented in the kernel yet. The kernel currently only knows these constants: </p>\n<ul>\n<li>Truth <code>⊤</code></li>\n<li>Propositions <code>ℙ</code></li>\n<li>Equality <code>=</code></li>\n<li>Type membership <code>:</code></li>\n<li>Conjunction <code>∧</code></li>\n<li>Implication <code>⟶</code></li>\n<li>Universal Quantification <code>∀</code></li>\n<li>Existential Quantification <code>∃</code></li>\n</ul>\n<p>Furthermore it has the concept of a <em>context</em>, and lifting theorems between contexts. The <code>typedef</code> feature needs to be added to complete the kernel.</p>\n<p>The rest of Practical Types can then be built on top of this Kernel, but so can intuitionistic logic, paraconsistent logic, etc. (at least I believe so, currently). So this is very similar to MM0, but I am pushing EVERYTHING into a uniform universe of logical discourse, including sorts (which are just types introduced via <code>typedef</code>), for example <code>wff</code> in MM0 corresponds to <code>ℙ</code>, the only type built into the kernel.  It would be very interesting to know if Practal Light can in principle achieve similar speeds as MM0, or if <code>V(t)/FV(t)</code> is superior for that purpose.</p>",
        "id": 249082653,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628671650
    },
    {
        "content": "<p>Note that what MM0 calls \"sorts\" are really more like syntactic classes for logical entities than types. In fact they are deliberately too weak to get any kind of interesting type system going in the sorts. Usually, a logical theory will have only a few of them. For example in HOL-in-MM0, the sorts are terms and types; in DTT they are terms, in FOL they are terms and propositions. Metamath + ZFC has a second order thing going on with sets, propositions, and classes. I'm not sure whether types constitute a separate syntactic class in your case so I think in practal they would be either terms or terms and types.</p>",
        "id": 249132550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628699302
    },
    {
        "content": "<p>I don't think it is inevitable that <code>typedef</code> should be part of the kernel. If you go that route it is sure to be by far the largest part, just as inductive types are in lean. Instead, see if you can axiomatize it so that you don't need complicated definition schemata in the kernel</p>",
        "id": 249133130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628699570
    },
    {
        "content": "<p>I think your list of built in constants is still larger than it could be, and it also seems to bake in a notion of first order logic, which means that it's not clear how to represent weaker systems. The MM0 kernel doesn't have any constants built in, but it does have a notion of definitional equality similar to (but much weaker than) lean's which is used to implement definitional unfolding. The user can't manipulate this equality relation directly, it's not a binary operator in the logic itself.</p>\n<p>By the way, I believe that MM0 would work just as well with V(t) being replaced everywhere by FV(t). I suspect it is slightly less efficient but that is just an untested hypothesis.</p>",
        "id": 249134132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628700078
    },
    {
        "content": "<p>The primitive rule \"introducing a constant from an existence theorem\" sounds like the axiom of choice, so that's shutting out the intuitionists. You might not care, but it's good to be upfront about that sort of thing.</p>",
        "id": 249134334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628700162
    },
    {
        "content": "<p>The rules on contexts sound like the module system I considered and discarded early in MM0's design. The reason I didn't go for it was because I determined that it is possible to simulate such a system without the kernel's assistance, and MM0 is aiming to have the most bare bones kernel that can efficiently support the common high level reasoning patterns in formal mathematics. Practal seems to be aiming more to be the front end itself, rather than the foundation on which the front end is built, so it makes sense that there would be divergence at this point.</p>",
        "id": 249134864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628700421
    },
    {
        "content": "<p>You make important points, let me go through them one by one:</p>\n<ul>\n<li>Yes, sorts are very weak types. Isabelle has them too. Practal doesn't have them as separate syntactical entities, because everything is a term. But you can make new sorts via <code>typedef</code> as objects in the universe. In that sense, Practal is simpler and more uniform than MM0! </li>\n<li>Practal's <code>typedef</code> will be much simpler than what you seem to have in mind, I don't think it has much to do with inductive types as in lean. It is more a special kind of definition that can create \"bubbles\" within the universe that are guaranteed to not overlap with other bubbles. And you are right, it should actually be possible that it just introduces axioms, given that a type is just a constant with some properties! But let's say that you have 100 different bubbles, then you need (100*99/2) axioms to state that they are pairwise disjoint without trying to be clever about it. So these axioms should be generated on the fly. That's why I put <code>typedef</code> automatically into the kernel in my mind, but of course there is no reason why that axiom generation should not just happen outside of the kernel, with a \"source\" attached to them of where they come from, in that case <code>typedef</code>.</li>\n<li>I guess the question of how many constants a foundation has depends on what you count as constants. MM0 has the sort relationship, that's the constant <code>:</code> in Practal, except that Practal's <code>:</code> is both simpler and more powerful. A logic that doesn't have propositions, truth, implication and conjunction is not that practical, so these are OK as well. Universal and existential quantifiers are necessary because they allow to talk about the universe. That there is a universe to talk about is an assumption built into any logic that can be modelled with Practal, that is right, but also a very practical assumption, because without any universe, what are you talking about?</li>\n<li>Contexts work in a very natural and simple way. I have experimented with them before. In Practal they boil down to their essentials and the cruft of previous designs has been removed from them. Experience will show how much cruft is still left in the current design. I basically don't think a sane implementation of Practal should be done <em>without</em> contexts. Also note that EVERY ITP system needs some sort of notion of context for representing the hypotheses of theorems, and I would not expect MM0 to be an exception in that regard.  And yes, it should be easy to implement modules on top of them. In my opinion, that works actually in favour of them, not against them. I believe because of Practal's uniform design it is simpler to provide them in Practal than it would be in MM0. For example, contexts don't need to track sorts, especially with a typedef that is not part of the kernel.</li>\n<li>\"Introducing a constant from an existence theorem\" might indeed be inviting the axiom of choice in through the backdoor, but that depends a lot on what kind of existence theorems you can prove in your logic. For example, if you have intuitionistic logic, then this should not imply the axiom of choice. If you use classical logic, then it will. I think that is reasonable, but yes, it should definitely be mentioned on the packaging. Right now contexts are baked into the kernel, but maybe it should be possible to introduce types of contexts just like you can introduce axioms and constants.</li>\n<li>Practal aims to provide both a frontend AND a foundation, but the goal of its foundation is not to be minimal or being able to model every logic out there. The goal of its foundation is to be simple and easy to understand, but still to be able to cover the entire reasoning spectrum that a mathematician would expect. The goal is that when a user of Practal wants to understand how it works under the hood, Practal's foundation explains EVERYTHING, in a simple way.</li>\n</ul>",
        "id": 249150349,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628707087
    },
    {
        "content": "<p>I actually don't think that the <code>choose</code> context implies the axiom of choice. It basically corresponds to the deduction rule <br>\n<code>(Γ,φ(x) ⊢ ψ) ⇒ (Γ, ∃ x φ(x) ⊢ ψ)</code> if <code>x</code> is not free in <code>ψ</code> or any formula of <code>Γ</code><br>\nthat I copied from \"Logic and Structure\" by Dirk van Dalen, Lemma 3.9.1 (ii).</p>",
        "id": 249163319,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628712907
    },
    {
        "content": "<p>Contexts really just correspond 1-1 to natural deduction rules like the rule for existential elimination above, so it is actually hard to imagine having a simpler and more natural implementation <em>without</em> contexts.</p>",
        "id": 249163518,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628713029
    },
    {
        "content": "<p>What plays the role of <code>ψ</code> in your context then?</p>",
        "id": 249163665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628713113
    },
    {
        "content": "<p>That is the formula that you prove in the context.</p>",
        "id": 249163697,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628713135
    },
    {
        "content": "<p>Could you sketch how the user would encounter a rule like this in a practal file?</p>",
        "id": 249163734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628713169
    },
    {
        "content": "<p>It's not clear yet how the practal file exactly would look like, but it is implemented in the kernel here: <a href=\"https://github.com/practal/practal-light/blob/9146aaf52df1ba3afda8f0708cc2c0d13b528980/Sources/practal-light/Kernel/KernelContext.swift#L224\">https://github.com/practal/practal-light/blob/9146aaf52df1ba3afda8f0708cc2c0d13b528980/Sources/practal-light/Kernel/KernelContext.swift#L224</a></p>",
        "id": 249163948,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628713287
    },
    {
        "content": "<p>That describes the lifting of <code>ψ</code> out of a <code>choose</code> context.</p>",
        "id": 249164046,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628713338
    },
    {
        "content": "<p>But basically it should look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">choose</span> <span class=\"bp\">`</span><span class=\"n\">x</span><span class=\"bp\">`</span> <span class=\"n\">such</span> <span class=\"n\">that</span> <span class=\"bp\">`</span><span class=\"n\">φ</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"n\">obligation</span><span class=\"o\">:</span> <span class=\"bp\">`∃</span> <span class=\"n\">x.</span> <span class=\"n\">φ</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">`</span><span class=\"o\">)</span>\n<span class=\"bp\">....</span>\n<span class=\"k\">have</span>  <span class=\"n\">ψ</span>\n</code></pre></div>",
        "id": 249164527,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628713583
    },
    {
        "content": "<blockquote>\n<p>Yes, sorts are very weak types. Isabelle has them too. Practal doesn't have them as separate syntactical entities, because everything is a term. But you can make new sorts via typedef as objects in the universe. In that sense, Practal is simpler and more uniform than MM0! </p>\n</blockquote>\n<p>Those aren't sorts, if they aren't new syntactic classes. So it sounds like you are saying Practal has only one syntactic class of terms, similar to DTT. This is a reasonable choice, although it has consequences elsewhere...</p>\n<blockquote>\n<p>Practal's typedef will be much simpler than what you seem to have in mind, I don't think it has much to do with inductive types as in lean.</p>\n</blockquote>\n<p>I'm talking about the complexity of syntax and semantics needed to specify schemas like <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247903354\">this one</a>. Already there we see lots of syntactic classes that aren't terms: lists of <code>identify</code>, constraints, constructors, <code>with</code>/<code>in</code>/<code>where</code> modifiers. You will either need a lot more built in constants, or another syntactic class separate from terms to encode the space of valid typedef specifications. Not to mention all the proof obligations that this kicks up, and how to describe those obligations as well. This is all fairly close to the complexity of an inductive specification, which has a list of constructors with types, and a bunch of constraints / proof obligations on top to ensure positivity and generate the recursor and equations.</p>",
        "id": 249164881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628713745
    },
    {
        "content": "<p>But that syntax is just frontend, as you would say. The kernel itself does not contain any of that. This is just like you can have elaborate packages in Isabelle for defining recursive functions, but the Isabelle/HOL kernel just allows for a fixpoint combinator.</p>",
        "id": 249166027,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628714309
    },
    {
        "content": "<p>Maybe there is a misunderstanding here. When I say that Practal wants to be both frontend and foundation, I don't mean that frontend and foundation are the same. I mean that there is a frontend, and a kernel, and these are separate entities. The kernel provides the foundation, and the frontend the sugar on top of it.</p>",
        "id": 249166236,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628714428
    },
    {
        "content": "<p>As for sorts / syntactical classes, what I mean that what you are able to achieve with sorts in MM0, you can achieve with types generated via <code>typedef</code> in Practal. These types are <em>not</em> separate syntactical classes, but that is the point.</p>",
        "id": 249166742,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628714730
    },
    {
        "content": "<p>That means that you can reason about them, while you cannot really reason much about sorts.</p>",
        "id": 249166851,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628714782
    },
    {
        "content": "<blockquote>\n<p>I guess the question of how many constants a foundation has depends on what you count as constants. MM0 has the sort relationship, that's the constant <code>:</code> in Practal, except that Practal's <code>:</code> is both simpler and more powerful.</p>\n</blockquote>\n<p>A constant is a term or term constructor which the user can use arbitrarily in other terms. Metamath and MM0 take the approach of having no actual constants, with all primitives being expressed at the meta level, so that they don't unduly affect the provability relation. As I understand it, Practal's constants are actually constants in this sense.</p>\n<blockquote>\n<p>A logic that doesn't have propositions, truth, implication and conjunction is not that practical, so these are OK as well. Universal and existential quantifiers are necessary because they allow to talk about the universe. That there is a universe to talk about is an assumption built into any logic that can be modelled with Practal, that is right, but also a very practical assumption, because without any universe, what are you talking about?</p>\n</blockquote>\n<p>You might be studying pure modal logic, where there are no quantifiers, or session types, where implication is linear and quantification is optional, or primitive recursive arithmetic, where there are only bounded quantifiers. Again, it's a choice if you want to consider these weird logics as in scope or not. MM0 made the explicit choice to reject the <a href=\"https://en.wikipedia.org/wiki/MU_puzzle\">MIU \"logic\"</a>, at least with the metamath inspired encoding, because of its undesirable constraints on more normal proof systems.</p>\n<blockquote>\n<p>Also note that EVERY ITP system needs some sort of notion of context for representing the hypotheses of theorems, and I would not expect MM0 to be an exception in that regard. </p>\n</blockquote>\n<p>Yes and no. Metamath and MM0 are both based on (tuned for) hilbert-style axiomatizations, which basically means that the proof judgments look like <code> ⊢ φ</code> instead of <code>Γ  ⊢ φ</code>. This is tempered by the ability to locally assume that a theorem is provable, but this is more like <code> ⊢ ψ =&gt; ⊢ φ</code> than <code>ψ  ⊢ φ</code>. The most obvious difference is that in metamath/mm0 there is no hypothesis discharge rule. You can then layer a hypothesis system on top of this if the logic supports it (i.e. there is a <code>-&gt;</code> operator that acts sufficiently like implication). This approach is necessary for directly supporting logics that require control of the context, like modal logic (or first order logic, for that matter, if it's not already baked into the system).</p>",
        "id": 249166965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628714868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249164527\">said</a>:</p>\n<blockquote>\n<p>But basically it should look like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">choose</span> <span class=\"bp\">`</span><span class=\"n\">x</span><span class=\"bp\">`</span> <span class=\"n\">such</span> <span class=\"n\">that</span> <span class=\"bp\">`</span><span class=\"n\">φ</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"n\">obligation</span><span class=\"o\">:</span> <span class=\"bp\">`∃</span> <span class=\"n\">x.</span> <span class=\"n\">φ</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">`</span><span class=\"o\">)</span>\n<span class=\"bp\">....</span>\n<span class=\"k\">have</span>  <span class=\"n\">ψ</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is there a sectioning mechanism, or a way to know what the goal is at the point you have the <code>choose</code> line?</p>",
        "id": 249167102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628714930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249166027\">said</a>:</p>\n<blockquote>\n<p>But that syntax is just frontend, as you would say. The kernel itself does not contain any of that. This is just like you can have elaborate packages in Isabelle for defining recursive functions, but the Isabelle/HOL kernel just allows for a fixpoint combinator.</p>\n</blockquote>\n<p>Right. I'm interested to know what the analogue of the \"fixpoint combinator\" is for your <code>typedef</code>.</p>",
        "id": 249167190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628714977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249166851\">said</a>:</p>\n<blockquote>\n<p>That means that you can reason about them, while you cannot really reason much about sorts.</p>\n</blockquote>\n<p>Yes, this is the distinction I'm getting at. A sort is essentially metatheoretic structure that you use to define the theory you want to work in. You can't directly reason about it in the logic because that would be part of the metalogic. Making the logic the same as the metalogic tends to really pump up the consistency strength of the system, and if you are not careful you can make the system inconsistent this way.</p>",
        "id": 249167505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628715139
    },
    {
        "content": "<blockquote>\n<p>Right. I'm interested to know what the analogue of the \"fixpoint combinator\" is for your typedef.</p>\n</blockquote>\n<p>Me too! I will let you know once it is implemented.</p>",
        "id": 249167557,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628715174
    },
    {
        "content": "<p>The analogue in practal would be something like proving something by induction on terms and <code>typedef</code> constructions</p>",
        "id": 249167567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628715178
    },
    {
        "content": "<p>You cannot talk about terms in Practal, or about typedef constructions. You can just <em>use</em> terms, and <em>use</em> the axioms generated by a typedef. Therefore, I don't think there is any danger of a \"pump up effect\" in Practal. But yes, you have to be very careful in implementing any kernel.</p>",
        "id": 249167798,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628715296
    },
    {
        "content": "<p>I was initially worried about inconsistency issues in Practical Types, but the more I work with / on them, the less worried I become. It is really just all very straightforward and just simplifies existing systems, for example not needing sorts and having just a single syntactical class of terms, but at the same time not going down that rabbit hole of curry-howard.</p>",
        "id": 249168231,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628715556
    },
    {
        "content": "<p>As for sectioning, imagine each context starting its own reasoning branch. There is no goal, just a sequence of theorems you prove in some context.</p>",
        "id": 249168796,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628715819
    },
    {
        "content": "<p>Each theory development will have a main branch of contexts. You can bring theorems proved in contexts that branch of that main branch by lifting them back into the contexts of the main branch.</p>",
        "id": 249168958,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628715892
    },
    {
        "content": "<p>Basically each context is its own mini-kernel, and without lifting the theorems you prove are only valid in that context, not in any other.</p>",
        "id": 249169029,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628715943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429698\">Steven Obua</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249168796\">said</a>:</p>\n<blockquote>\n<p>As for sectioning, imagine each context starting its own reasoning branch. There is no goal, just a sequence of theorems you prove in some context.</p>\n</blockquote>\n<p>In that case, I don't see how you can make use of the rule \"<code>(Γ,φ(x) ⊢ ψ) ⇒ (Γ, ∃ x φ(x) ⊢ ψ)</code> if <code>x</code> is not free in <code>ψ</code> or any formula of <code>Γ</code>\" to justify your constant introduction rule. The formula <code>ψ</code> is not determined at the point of the rule, so it must somehow mean \"all theorems I am about to prove\"; but those theorems can reference the new constant, so \"<code>x</code> is not free in <code>ψ</code>\" will not be satisfied</p>",
        "id": 249169467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628716135
    },
    {
        "content": "<p>It works like that: You enter the context <code>Γ,φ(x)</code> and you start proving theorems. Say you proved a theorem <code>ψ</code>. If <code>ψ</code> does not contain <code>x</code>, then you can lift it out into the context <code>Γ, ∃ x φ(x)</code>. That's the deduction rule. If <code>ψ</code> contains <code>x</code>, you cannot lift it out of the context, but just their existential quantification <code>∃ x. ψ</code>.</p>",
        "id": 249170330,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628716492
    },
    {
        "content": "<p>This is also the deduction rule, together with the introduction rule for the existential quantifier.</p>",
        "id": 249170561,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628716603
    },
    {
        "content": "<p>I have an additional rule for existential introduction in the kernel, but I guess I could just drop that, as it is part of how lifting for the <code>choose</code> context works. That part of the lifting code is also much simpler than the code for the additional rule.</p>",
        "id": 249171367,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717070
    },
    {
        "content": "<p>Or rather not, I cannot drop it.</p>",
        "id": 249171458,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717125
    },
    {
        "content": "<p>But I could drop the part of the lifting code that converts <code>ψ</code> into <code>∃ x. ψ</code> and just demand that this is done explicitly via existential introduction. I think.</p>",
        "id": 249171623,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717199
    },
    {
        "content": "<p>Or actually I think I CAN drop it, as I can always enter the <code>choose</code> context like that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">choose</span> <span class=\"n\">x</span> <span class=\"n\">such</span> <span class=\"n\">that</span> <span class=\"bp\">`∃</span> <span class=\"n\">x.</span> <span class=\"bp\">⊤`</span>\n<span class=\"bp\">...</span>\n<span class=\"k\">have</span> <span class=\"bp\">`</span><span class=\"n\">ψ</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">`</span>\n</code></pre></div>",
        "id": 249172079,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717486
    },
    {
        "content": "<p>That would require an additional axiom <code>∃ x. ⊤</code>, though.</p>",
        "id": 249172589,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717779
    },
    {
        "content": "<p>is that an unbounded quantifier btw, or is there a type somewhere?</p>",
        "id": 249172647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628717816
    },
    {
        "content": "<p>Unbounded first-order quantifier.</p>",
        "id": 249172685,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717850
    },
    {
        "content": "<p>it ranges over all objects, types, everything?</p>",
        "id": 249172706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628717872
    },
    {
        "content": "<p>Yes.</p>",
        "id": 249172712,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717879
    },
    {
        "content": "<p>that seems kind of inconvenient for normal uses of <code>choose</code></p>",
        "id": 249172765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628717891
    },
    {
        "content": "<p>Why? You can just use the bounded version <code>∃ x: S. φ</code> which is defined in terms of <code>∃</code></p>",
        "id": 249172861,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628717974
    },
    {
        "content": "<p>I think it would be good for you to mock up what a user's interaction with the system would look like, including all the file level / module level stuff. My first public discussion of MM0 was accompanied by a file that defined the axioms of ZFC and proved some trivial things, or at least purported to do so since the parser hadn't been written yet at the time</p>",
        "id": 249172948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628718020
    },
    {
        "content": "<p>it makes it easy to discuss things like concrete syntax, as well as motivate the role that each rule and bit of syntax has in the system</p>",
        "id": 249173044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628718096
    },
    {
        "content": "<p>That definitely needs to happen at some point, as it constitutes the frontend, but I have done that before so I know already how that will work. So I am currently just focusing on getting the foundation right, but having that piece of frontend would make it definitely simpler in discussing it with somebody!</p>",
        "id": 249173278,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628718207
    },
    {
        "content": "<p>You might find out that some part of your design doesn't work well once you have the mockup. That happened to me with MM0, it turned out that the syntax I had chosen for delimiting math sections was hard to read and I changed it based on feedback</p>",
        "id": 249173850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628718579
    },
    {
        "content": "<p>Sure, that will definitely happen, but I consider that just as normal iteration of software. I was more worried about doing something hilariously inconsistent, but I know now that it will work :-) This discussion was already very valuable to me!</p>",
        "id": 249174071,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628718718
    },
    {
        "content": "<p>From a pure frontend point of view, you cannot go much wrong by just following the looks of Isabelle/Isar. It just all becomes so much more simple and powerful, because of the uniformity of Practal's foundations.</p>",
        "id": 249174537,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628718990
    },
    {
        "content": "<p>The basic looks will be similar as here in ProofScript, which also uses contexts: </p>\n<ul>\n<li><a href=\"https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/root.thy\">https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/root.thy</a></li>\n<li><a href=\"https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/bootstrap/classical.thy\">https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/bootstrap/classical.thy</a></li>\n</ul>\n<p>The basic logic in ProofScript was set theory embedded in higher-order logic though, and that's just not good enough.</p>",
        "id": 249175217,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628719332
    },
    {
        "content": "<p>Also, the focus of ProofScript was wrong. I tried to make a programming language perfectly designed for scripting proofs, but that's not what is needed. I call it the \"bootstrap trap\". What is <em>actually</em> needed I wrote down in the <a href=\"https://doi.org/10.47757/practal.1\">Practal position paper</a>.</p>",
        "id": 249175763,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628719683
    },
    {
        "content": "<p>there aren't any proofs in the code examples there though</p>",
        "id": 249176315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628719951
    },
    {
        "content": "<p>There are proofs in the second file?</p>",
        "id": 249177700,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628720798
    },
    {
        "content": "<p>Everything that comes indented after a <code>theorem</code> is a proof.</p>",
        "id": 249177877,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628720908
    },
    {
        "content": "<p>I mean in the practal position paper</p>",
        "id": 249181437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628723484
    },
    {
        "content": "<p>Ah <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> <br>\nWell, a proof really should be just a sequence of theorems, the intermediate steps being filled out by automation. Very similar to what an Isabelle/Isar proof looks like. So contexts in Practal then basically correspond to contexts in Isabelle/Isar. It's pretty clear how that is supposed to work, so I have not given it any attention in the paper.</p>",
        "id": 249195162,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628740351
    },
    {
        "content": "<p>I've roamed the internet in search of support that the \"choose\" context is fine, and here is what I found:</p>\n<blockquote>\n<p>Before proceeding to the next stage, let us clear up one last misconception. Suppose that in a mathematical text we have the assumption that there exists <code>x</code> such that <code>φ(x)</code>. We customarily say “choose an <code>x</code> satisfying <code>φ(x)</code>” to give ourselves an <code>x</code> satisfying <code>φ</code>. This is not an application of the axiom of choice, but rather an elimination of an existential quantifier. Similarly, if we know that a set <code>A</code> is inhabited and we say “choose <code>x ∈ A</code>”, it is not choice but existential quantifier elimination again.</p>\n</blockquote>\n<p>This is a quote from <a href=\"https://doi.org/10.1090/bull/1556\">\"Five stages of accepting constructive mathematics\"</a> by Andrej Bauer,  at the end of the first section \"Denial\".</p>",
        "id": 249221539,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628767106
    },
    {
        "content": "<p>So this matches my initial intuition: Given an existence theorem, choosing an <code>x</code> such that it has the corresponding property is fine. Because what would existence mean otherwise? This is just existential elimination. The axiom of choice is not about existential elimination, but about which objects you can prove to exist in the first place.</p>",
        "id": 249221837,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628767331
    },
    {
        "content": "<p>I'm aware of the rule of existential elimination, but it is dubious to apply it at the top level, when you aren't proving any particular theorem. There is a <code>choose</code> like tactic in lean (actually called <code>cases</code>) for unpacking an existential, but it only works inside a proof, so there is a current goal, and it has restrictions on the goals to which it will apply, which you can't possibly check if you don't know what the goal is</p>",
        "id": 249253352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628783622
    },
    {
        "content": "<p>On the Kernel level there is no such thing as a proof in Practal, just various ways for constructing theorems. Of course you can call such a construction a \"proof\", if you want. There is not really such a thing as a \"toplevel\" as well, each context forms its own little world in which you create theorems. A context can have a parent though, and you can form chains of contexts in this way, and there are rules for how to move a theorem between contexts along such a chain. Note that Bauer doesn't mention anything about toplevel or tactics, either... So I am pretty sure there is nothing dubious about it.</p>",
        "id": 249270944,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628791578
    },
    {
        "content": "<p>Do you have a formal (abstract) syntax for the language? What are the syntactic elements in the file, and what are their meanings? This is a major question that the practal paper does not address. Looking at the linked bit of code, I see <code>assume</code>, <code>choose</code>, <code>declare</code>, <code>define</code>, <code>seal</code>, and none of these are discussed in the practal paper</p>",
        "id": 249273063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628792535
    },
    {
        "content": "<p>For a language like yours, a \"proof\" is the syntax that is translated into kernel calls to construct theorems, so the structure / extent of this syntax is very important for users</p>",
        "id": 249273325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628792643
    },
    {
        "content": "<p>and that's not even talking about concrete syntax, i.e. where you put the punctuation, just the actual moves available to the user</p>",
        "id": 249273428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628792684
    },
    {
        "content": "<p>I absolutely agree with you, syntax is very important. That's why I developed a new semantics for parsing in terms of <a href=\"https://doi.org/10.47757/obua.ll.1\">pyramid grammars</a>. This will make user-extensible and composable syntax possible for Practal.</p>\n<p>The Practal position paper presents a vision of what an ITP system should look like. So of course it doesn't contain all details worked out. I am right now working them out! Practal doesn't exist yet, but it is progressing much faster currently than I was expecting when writing that paper. Turns out, once you have defined for yourself clearly what you are going after it becomes much easier to achieve it! The practical types stuff I created just shortly after setting out that vision. A first version of the kernel is already finished apart from defining and implementing <code>typedef</code>. Within one or two months (I wish earlier, but I need to work on other things as well so I can eat), expect another paper / another iteration of the practical types paper that explains contexts, assume, etc. You can also look at my <a href=\"https://doi.org/10.1007/978-3-319-46750-4_19\">ProofScript paper</a>, contexts work a lot like described there, but it is cleaner and nicer now.  </p>\n<p>If you want to know what the syntax will look like, you can just look at Isabelle/Isar and the <a href=\"https://www.isa-afp.org\">Archive of Formal Proofs</a>, or at the ProofScript code I linked. It will look a lot like that. Given that it is all converted into Kernel calls, one can iterate quickly on what it exactly looks like depending on what works best. Finding the best concrete syntax will be an iterative process. It's not something you start with set in stone. Exactly because it is so important for the user, as you rightly pointed out.</p>",
        "id": 249286019,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628798797
    },
    {
        "content": "<p>I'm trying to say that the focus is <em>not</em> the concrete syntax, but rather the abstract syntax, and what you call kernel calls. Suppose the user didn't have any syntax apart from calling the kernel directly; what would those trees of kernel calls look like? When are they accepted / rejected, what are the side conditions and so on</p>",
        "id": 249287663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628799568
    },
    {
        "content": "<p>It's all in the code. If you call the kernel and it gives you back a theorem, then this theorem is valid in that context. You could start proving right now, but it will not be pretty as it will be just Swift code, and there is no automation yet apart from First-Order Abstract syntax pattern matching.</p>",
        "id": 249287928,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628799710
    },
    {
        "content": "<p>Pointing to AFP is not very helpful for understanding what your system will do because isabelle is huge and you will not implement it all (and there is probably a fair amount you don't want to implement even given infinite time). That's a way to indicate the general style of the concrete syntax, which is fair enough, but again, concrete syntax isn't so important because it is easy to change</p>",
        "id": 249288019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628799743
    },
    {
        "content": "<p>So you have a novel proof theory which has no specification apart from the code?</p>",
        "id": 249288129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628799807
    },
    {
        "content": "<p>I mean, you wouldn't be the first to do so, but it's not a good idea</p>",
        "id": 249288161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628799834
    },
    {
        "content": "<p>No, it is the part of the specification that is available right now. The practical types paper is another one. The practal position paper is another one. If you want ALL the details and not piece them together yourself, you will need to wait. Or pay me about £20000, and you will get them in two or three weeks :-)</p>",
        "id": 249288419,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628799962
    },
    {
        "content": "<p>I'm mostly trying to understand roughly how the system is laid out at a logical level. Is there an actual paper BTW, or are you talking about the two HTML pages?</p>",
        "id": 249288622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628800059
    },
    {
        "content": "<p>My main argument is that it is good to have such information available for yourself upfront, so that you can avoid backing yourself into a corner with a feature that leads to contradiction</p>",
        "id": 249288742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628800111
    },
    {
        "content": "<p>Once you have a sketch of the argument for how deductions in the kernel map to something in FOL as traditionally conceived, you will find it much easier to justify and add more proof rules to the kernel</p>",
        "id": 249288917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628800196
    },
    {
        "content": "<p>You can print out the two HTML pages, they are about paper size :-) </p>\n<p>As I said, for information about contexts, you could look at the ProofScript paper. It is an actual paper, but I would say that the two HTML pages are more important.</p>\n<p>I have a sketch of how deductions map. It is really just first-order logic. And contexts make it rigorous of what proving actually means, just like sequent calculus etc., but better, because, 2021 and computers. For example, the choose context is just existential elimination, as we discussed. You are probably not familiar with Isabelle/Isar and in particular Isar contexts, otherwise how the system is supposed to work would be clearer to you, I think.</p>",
        "id": 249289970,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628800725
    },
    {
        "content": "<p>Isabelle has a bunch of other stuff like locales though and I'm not sure what you are doing at that level</p>",
        "id": 249290719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628801187
    },
    {
        "content": "<p>Locales come basically for free with contexts. At least that's what I believe right now, as I have not worked through that yet. At lot of work in getting locales right consists in dealing with type variables, etc., and in general getting locale stuff converted into Isabelle kernel stuff. That should not be a problem in Practal, as the kernel is designed from the start supporting contexts.</p>",
        "id": 249291038,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628801378
    },
    {
        "content": "<p>I see <a href=\"https://github.com/practal/practal-light/blob/9146aaf52df1ba3afda8f0708cc2c0d13b528980/Sources/practal-light/Kernel/KernelContext.swift#L223\">here</a> that you are universally quantifying any assumptions that have been made. I assume that is because you have a mechanism to instantiate a hypothesis. But then how do you prove <code>x &gt; 0 -&gt; x &gt; 0</code> and not <code>(\\all x, x &gt; 0) -&gt; x &gt; 0</code>?</p>",
        "id": 249292175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628801928
    },
    {
        "content": "<p>Yes, because free variables are implicitly universally quantified; so if they are contained in an assumption, they need to be explicitly quantified over. I find this a little bit confusing, and in the beginning I was just forbidding free variables in assumptions. But then I started to write down a few axioms, and being able to use free variables was just very practical. So I allow it now. In the frontend there needs to be a clear visual distinction between free variables and constants, then it will not be confusing, I think.</p>\n<p>The way to prove <code>x &gt; 0 ⟶ x &gt; 0</code> would be like that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">context</span>\n  <span class=\"n\">declare</span> <span class=\"n\">x</span>\n  <span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"k\">assume</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">print</span> <span class=\"n\">H</span>\n</code></pre></div>\n<p>So you would first introduce the <em>constant</em> <code>x</code>. Then make the assumption on <code>x</code>. </p>\n<p>When the theorem is printed, is has been lifted out of the context in which it was originally stated into the context where it is printed, and it will have the form <code>x &gt; 0 ⟶ x &gt; 0</code> where <code>x</code> is a free variable now. </p>\n<p>By the way, I just reread the Practal position paper, and some things are already outdated by now. For example I still think there of <code>∀</code> having a dependent type, which is not the case anymore. Sorry for that! I hope this all stabilizes soon enough and proper documentation becomes available.</p>",
        "id": 249315549,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628822000
    },
    {
        "content": "<p>From your indentation (?) it seems like that would also discharge the <code>declare x</code>, in which case the proof would be showing <code>∀ x, ∃ x, (x &gt; 0 ⟶ x &gt; 0)</code>, if I understand your discharge rules correctly</p>",
        "id": 249317947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628824702
    },
    {
        "content": "<p>By the way, short examples like that are good. Do more of that (here or in the public docs)</p>",
        "id": 249318007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628824794
    },
    {
        "content": "<p>Is there name hygiene?</p>",
        "id": 249319621,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628826616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Not sure what you mean, so let me guess. Can the declared <code>x</code> in the above example clash with a previously declared <code>x</code>? No, it cannot, each constant you introduce must be different from all other constants declared so far. But there are namespaces, so this is not a real restriction.</p>",
        "id": 249331752,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628840445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> The context chain will look like that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Top</span><span class=\"o\">::</span>\n<span class=\"n\">C1</span><span class=\"o\">::</span> <span class=\"n\">declare</span> <span class=\"n\">x</span>\n<span class=\"n\">C2</span><span class=\"o\">::</span> <span class=\"k\">assume</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span>\n<span class=\"n\">H</span>\n</code></pre></div>\n<p>So the theorem <code>H</code> (<code>x &gt; 0</code>) is originally an axiom in context <code>C2</code>. Lifting it into C1 results in <code>x &gt; 0 ⟶ x &gt; 0</code> where <code>x</code> is a constant. Lifting it further into context <code>Top</code> will turn the constant <code>x</code> into a free variable <code>x</code>.</p>",
        "id": 249332349,
        "sender_full_name": "Steven Obua",
        "timestamp": 1628841102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I've worked more on the foundations of Practical Types. It is not exactly first-order logic, but something I call <em>Abstraction Logic</em>. I've published a report about it: <a href=\"https://doi.org/10.47757/abstraction.logic.1\">https://doi.org/10.47757/abstraction.logic.1</a></p>",
        "id": 258701989,
        "sender_full_name": "Steven Obua",
        "timestamp": 1634904406
    }
]
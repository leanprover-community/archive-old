[
    {
        "content": "<p>What is your use case?</p>",
        "id": 237066424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975122
    },
    {
        "content": "<p>I am writing a metalogic in Lean 4.</p>",
        "id": 237066443,
        "sender_full_name": "Mac",
        "timestamp": 1619975158
    },
    {
        "content": "<p>Each logic thus has its own <code>Prop</code> type (and thus possibly its own definition of equality).</p>",
        "id": 237066487,
        "sender_full_name": "Mac",
        "timestamp": 1619975176
    },
    {
        "content": "<p>Okay, that's been done in lean 3 and it doesn't require eliminating <code>=</code></p>",
        "id": 237066495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975180
    },
    {
        "content": "<p>You can overload the syntax if you really want to, but I wouldn't recommend it</p>",
        "id": 237066525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975222
    },
    {
        "content": "<p>because you need that equality for metatheory reasoning</p>",
        "id": 237066541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975234
    },
    {
        "content": "<p>So what, you want to always write <code>L |- eq a b</code> instead of the cleaner <code>L |- a = b</code>?</p>",
        "id": 237066551,
        "sender_full_name": "Mac",
        "timestamp": 1619975253
    },
    {
        "content": "<p>no, I would use some other = like symbol</p>",
        "id": 237066558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975267
    },
    {
        "content": "<p>I think flypitch used <code>\\simeq</code></p>",
        "id": 237066568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975281
    },
    {
        "content": "<p>But, <em>it is</em> equality?</p>",
        "id": 237066606,
        "sender_full_name": "Mac",
        "timestamp": 1619975287
    },
    {
        "content": "<p>No it's not equality</p>",
        "id": 237066617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975294
    },
    {
        "content": "<p>it's provable equivalence in the theory</p>",
        "id": 237066622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975302
    },
    {
        "content": "<p>equality is equality of terms which is something else</p>",
        "id": 237066659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975319
    },
    {
        "content": "<p>Which is what Lean's <code>Eq</code> is: provable equivalence in Lean's theory?</p>",
        "id": 237066668,
        "sender_full_name": "Mac",
        "timestamp": 1619975333
    },
    {
        "content": "<p>Lean is the metatheory</p>",
        "id": 237066683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975349
    },
    {
        "content": "<p>your logic is the theory</p>",
        "id": 237066687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975354
    },
    {
        "content": "<p>I am aware?</p>",
        "id": 237066696,
        "sender_full_name": "Mac",
        "timestamp": 1619975382
    },
    {
        "content": "<p>You can only say that <code>Eq</code> is not true equality if you can step outside lean, which only works inside tactics and such</p>",
        "id": 237066697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975383
    },
    {
        "content": "<p>if you are doing mathematics in lean then <code>Eq</code> is equality</p>",
        "id": 237066709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975402
    },
    {
        "content": "<p>Maybe you and I have different ideas of what qualifies as \"true equality\"</p>",
        "id": 237066753,
        "sender_full_name": "Mac",
        "timestamp": 1619975418
    },
    {
        "content": "<p>It depends on the metalogic we are working in</p>",
        "id": 237066774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975436
    },
    {
        "content": "<p>Honestly, I am not even sure I agree that there is a \"true equality\" (except maybe identity -- and Lean's equality is most certainly not that)</p>",
        "id": 237066783,
        "sender_full_name": "Mac",
        "timestamp": 1619975454
    },
    {
        "content": "<p>identity is just another word for equality</p>",
        "id": 237066795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975477
    },
    {
        "content": "<p>I disagree?</p>",
        "id": 237066809,
        "sender_full_name": "Mac",
        "timestamp": 1619975493
    },
    {
        "content": "<p>Lean's equality is equality in the mathematical sense, provided we are not doing lean metatheory</p>",
        "id": 237066812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975506
    },
    {
        "content": "<p>No its not? Considering that defeq and Eq are not synonymous?</p>",
        "id": 237066863,
        "sender_full_name": "Mac",
        "timestamp": 1619975528
    },
    {
        "content": "<p>if we are using lean as a metatheory for another logic then that logic has provable equivalence and lean has equality</p>",
        "id": 237066866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975529
    },
    {
        "content": "<p>defeq is a metatheoretic notion</p>",
        "id": 237066881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975538
    },
    {
        "content": "<p>But as a result Lean's <code>Eq</code> does not satisfying the axioms of logical equality over Lean programs</p>",
        "id": 237066910,
        "sender_full_name": "Mac",
        "timestamp": 1619975588
    },
    {
        "content": "<p>Huh?</p>",
        "id": 237066920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975599
    },
    {
        "content": "<p><code>Eq</code> certainly does satisfy the axioms of equality</p>",
        "id": 237066925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975622
    },
    {
        "content": "<p>because we axiomatize it to be so</p>",
        "id": 237066934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975633
    },
    {
        "content": "<p>within proofs, yes, but not within Lean as a whole.</p>",
        "id": 237066997,
        "sender_full_name": "Mac",
        "timestamp": 1619975681
    },
    {
        "content": "<p>I'm not sure what that means. In lean's logic, Eq is equality</p>",
        "id": 237067018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975705
    },
    {
        "content": "<p>A theory with logical equality should not be able (within the theory) to distinguish between two equal terms</p>",
        "id": 237067027,
        "sender_full_name": "Mac",
        "timestamp": 1619975714
    },
    {
        "content": "<p>Lean can, thus its <code>Eq</code> is not exactly true equality -- but I think you are said that when you were talking about tactics.</p>",
        "id": 237067057,
        "sender_full_name": "Mac",
        "timestamp": 1619975749
    },
    {
        "content": "<p>How can it?</p>",
        "id": 237067097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975764
    },
    {
        "content": "<p>tactics can distinguish between defeq and Eq terms?</p>",
        "id": 237067124,
        "sender_full_name": "Mac",
        "timestamp": 1619975794
    },
    {
        "content": "<p>I feel like we are going very deep on a tangent that I am not sure is that important.</p>",
        "id": 237067147,
        "sender_full_name": "Mac",
        "timestamp": 1619975820
    },
    {
        "content": "<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>",
        "id": 237067165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067165\">said</a>:</p>\n<blockquote>\n<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>\n</blockquote>\n<p>What do you consider to be Lean? I would certainly consider tactics part of Lean.</p>",
        "id": 237067248,
        "sender_full_name": "Mac",
        "timestamp": 1619975910
    },
    {
        "content": "<p>I mean the lean logic</p>",
        "id": 237067256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975919
    },
    {
        "content": "<p>After all, you can prove things about them within Lean.</p>",
        "id": 237067259,
        "sender_full_name": "Mac",
        "timestamp": 1619975925
    },
    {
        "content": "<p>So there are two Lean logics then in your view? The Lean metalogic (used in tactics) and the Lean logic (where <code>Eq</code> is logical equality)?</p>",
        "id": 237067280,
        "sender_full_name": "Mac",
        "timestamp": 1619975953
    },
    {
        "content": "<p>Eh, things get complicated if you do that. It's true that lean's tactics are expressed in lean's logic, but there are unverified bits performing the reflection, compilation and such</p>",
        "id": 237067301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975999
    },
    {
        "content": "<p>It's certainly easiest to view them as entirely separate systems</p>",
        "id": 237067376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976037
    },
    {
        "content": "<p>Yes, but in Lean 4, all that is now writing in Lean, and can be dealt with in Lean proper.</p>",
        "id": 237067380,
        "sender_full_name": "Mac",
        "timestamp": 1619976040
    },
    {
        "content": "<p>The fact that lean 4 is implemented in lean is incidental to this discussion</p>",
        "id": 237067383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976053
    },
    {
        "content": "<p>In fact isn't one of the main long-term goals of Lean 4 to verify Lean's parser/compiler  in Lean?</p>",
        "id": 237067418,
        "sender_full_name": "Mac",
        "timestamp": 1619976079
    },
    {
        "content": "<p>The lean kernel is not implemented in lean (yet)</p>",
        "id": 237067419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976080
    },
    {
        "content": "<p>I don't know about that... I've suggested as much before but it seems that the developers have no intention of doing that themselves (although I think they would be fine with someone else doing it)</p>",
        "id": 237067500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976145
    },
    {
        "content": "<p>Certainly <code>partial</code> is one roadblock to doing that in today's lean 4</p>",
        "id": 237067526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976178
    },
    {
        "content": "<p>Well yes, but that is partly due to the limitations of well-founded recursion in current Lean 4.</p>",
        "id": 237067543,
        "sender_full_name": "Mac",
        "timestamp": 1619976208
    },
    {
        "content": "<p>Also, so is the Lean logic (in your view) that which is verified by the kernel? Though, aren't tactics verified by the kernel too? After all, it verifies proofs.</p>",
        "id": 237067552,
        "sender_full_name": "Mac",
        "timestamp": 1619976220
    },
    {
        "content": "<p>Yes, and yes (although calling tactics \"verified by the kernel\" is a bit of a stretch - they are typechecked)</p>",
        "id": 237067616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976265
    },
    {
        "content": "<p>As an analogue, perhaps it helps to consider that peano arithmetic is a logic that is capable of talking about other logics, including peano arithmetic. It can serve as its own metalogic</p>",
        "id": 237067713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976371
    },
    {
        "content": "<p>lean is doing something similar when you talk about lean tactics being objects in lean's logic</p>",
        "id": 237067725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976391
    },
    {
        "content": "<p>But it is best to keep them separate, name them PA(meta) and PA(object) if you need to</p>",
        "id": 237067743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976439
    },
    {
        "content": "<p>Perhaps \"identity\" and \"equality\" for you mean meta-<code>=</code> vs object-<code>=</code></p>",
        "id": 237067805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976497
    },
    {
        "content": "<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>",
        "id": 237067845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976592
    },
    {
        "content": "<p>\"identity\" for me means syntactic equality, but that is a fair alternative definition,</p>",
        "id": 237067866,
        "sender_full_name": "Mac",
        "timestamp": 1619976603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067845\">said</a>:</p>\n<blockquote>\n<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>\n</blockquote>\n<p>That is a fair approach. It is simply not mine.</p>",
        "id": 237067932,
        "sender_full_name": "Mac",
        "timestamp": 1619976641
    },
    {
        "content": "<p>When doing metamathematics in lean, it gets one step more complicated because we also get theory T and lean(object) is the metatheory for T</p>",
        "id": 237067959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976695
    },
    {
        "content": "<p>I treat Lean more as the basic system by which to express my notions. I actually try to avoid Lean <code>Eq</code> as it destroys syntactic equality which is what I want to try to keep as my background equality.</p>",
        "id": 237067972,
        "sender_full_name": "Mac",
        "timestamp": 1619976723
    },
    {
        "content": "<p>For example, one place where <code>Eq</code> would come up when doing metamathematics is in defining substitution, which is an operation on terms</p>",
        "id": 237068042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976769
    },
    {
        "content": "<p>you might have a theorem that says <code>(P x)[a -&gt; b] = P[a -&gt; b] x[a -&gt; b]</code> where <code>=</code> is lean's <code>=</code></p>",
        "id": 237068094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976800
    },
    {
        "content": "<p>Equality comes up in a few places when defining proof rules. For example modus ponens, <code>|- P =&gt; |- P -&gt; Q =&gt; |- Q</code>, is asserting equality between the two instances of <code>P</code></p>",
        "id": 237068230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976920
    },
    {
        "content": "<p>not equality in the theory, \"syntactic equality\", which since lean is the metatheory means <code>Eq</code></p>",
        "id": 237068250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619976947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237068250\">said</a>:</p>\n<blockquote>\n<p>not equality in the theory, \"syntactic equality\", which since lean is the metatheory means <code>Eq</code></p>\n</blockquote>\n<p>With all the macros and parsers, this is no longer entirely true.</p>",
        "id": 237068316,
        "sender_full_name": "Mac",
        "timestamp": 1619976997
    },
    {
        "content": "<p>the macros and parsers don't matter for this</p>",
        "id": 237068325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977010
    },
    {
        "content": "<p>they are all meta-lean</p>",
        "id": 237068326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977015
    },
    {
        "content": "<p>we're using lean to write the proof theory for some axiom system T here</p>",
        "id": 237068352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977043
    },
    {
        "content": "<p>meta-lean is only there to help us automate the construction of the inductive types defining provability and so on</p>",
        "id": 237068371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977081
    },
    {
        "content": "<p>Also how does \" For example modus ponens, |- P =&gt; |- P -&gt; Q =&gt; |- Q, is asserting equality between the two instances of P\" hold. Modus Ponens is not symmetric, equality is.</p>",
        "id": 237068410,
        "sender_full_name": "Mac",
        "timestamp": 1619977093
    },
    {
        "content": "<p>Modus Ponens is a rewrite/reduction rule, not an equivalence rule.</p>",
        "id": 237068438,
        "sender_full_name": "Mac",
        "timestamp": 1619977135
    },
    {
        "content": "<p>I'm saying that <code>MP(h, h2)</code> is a proof of <code>|- Q</code> provided <code>h</code> proves <code>|- P</code>, <code>h2</code> proves <code>|- P' -&gt; Q</code>, and <code>P = P'</code> where <code>=</code> is <code>@Eq term</code></p>",
        "id": 237068454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977172
    },
    {
        "content": "<p>Ah</p>",
        "id": 237068519,
        "sender_full_name": "Mac",
        "timestamp": 1619977215
    },
    {
        "content": "<p>as a rough sketch, that might look like this in lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Terms of theory T -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n\n<span class=\"sd\">/-- Provable terms in theory T -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mp</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">imp</span> <span class=\"n\">P</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"n\">Q</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">P'</span> <span class=\"n\">Q</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">imp</span> <span class=\"n\">P'</span> <span class=\"n\">Q</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">P'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">proof.mp</span> <span class=\"n\">h</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 237068672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977391
    },
    {
        "content": "<p>That looks pretty familiar to me! XD <br>\nConsidering that I am writing  a metalogic in Lean, I have a definition very similar to this already.</p>",
        "id": 237068781,
        "sender_full_name": "Mac",
        "timestamp": 1619977510
    },
    {
        "content": "<p>The observation I want to make here is that the <code>=</code> in <code>e</code> is lean's interpretation of \"syntactic equality\"</p>",
        "id": 237068816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977550
    },
    {
        "content": "<p>if you step up a metalevel you will say \"that's not syntactic equality! <em>This</em> is syntactic equality!\" but you can keep playing that game</p>",
        "id": 237068899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977604
    },
    {
        "content": "<p>at every level there is some <code>=</code> relation that the logic thinks is equality and is valid up to the rules of the logic</p>",
        "id": 237068958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977647
    },
    {
        "content": "<p>Well then there is also just real syntactic equality? What you are describing is what I would call logical equality.</p>",
        "id": 237068961,
        "sender_full_name": "Mac",
        "timestamp": 1619977649
    },
    {
        "content": "<p>Again, one person's syntactic equality is another's logical equality</p>",
        "id": 237069067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977739
    },
    {
        "content": "<p>what meta-lean thinks is syntactic equality is just logical equality in meta-meta-lean</p>",
        "id": 237069095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977776
    },
    {
        "content": "<p>No? Syntactically equality is equality of strings \"a\" = \"a\", \"a\" ne \"b\"?</p>",
        "id": 237069102,
        "sender_full_name": "Mac",
        "timestamp": 1619977787
    },
    {
        "content": "<p>That looks exactly like the way logical equality of strings is defined</p>",
        "id": 237069160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977816
    },
    {
        "content": "<p>Yes within a logic</p>",
        "id": 237069183,
        "sender_full_name": "Mac",
        "timestamp": 1619977837
    },
    {
        "content": "<p>Syntactic equality is formal language concept, not a logical concept</p>",
        "id": 237069196,
        "sender_full_name": "Mac",
        "timestamp": 1619977860
    },
    {
        "content": "<p>At least in my view.</p>",
        "id": 237069208,
        "sender_full_name": "Mac",
        "timestamp": 1619977886
    },
    {
        "content": "<blockquote>\n<p>Syntactic equality is formal language concept</p>\n</blockquote>\n<p>Yes, that formal concept being equality, within the logic of the formalism itself</p>",
        "id": 237069225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619977921
    },
    {
        "content": "<p>A logic can define an equality that does or does not mirror syntactic equality on the language, but that is different</p>",
        "id": 237069270,
        "sender_full_name": "Mac",
        "timestamp": 1619977931
    },
    {
        "content": "<p>I am curious, what is your position the philosophy of mathematics, are you a formalist or logicist (or something else)?</p>",
        "id": 237069331,
        "sender_full_name": "Mac",
        "timestamp": 1619977988
    },
    {
        "content": "<p>Formalist, of course <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 237069343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978001
    },
    {
        "content": "<p>? Well that makes me confused.</p>",
        "id": 237069367,
        "sender_full_name": "Mac",
        "timestamp": 1619978042
    },
    {
        "content": "<p>Because, afaik, formalism generally asserts that the notion of strings (and their identity) comes first before logic.</p>",
        "id": 237069424,
        "sender_full_name": "Mac",
        "timestamp": 1619978075
    },
    {
        "content": "<p>Which is my position</p>",
        "id": 237069427,
        "sender_full_name": "Mac",
        "timestamp": 1619978087
    },
    {
        "content": "<p>Whenever you look at a logical system from a meta-perspective, all the things that used to look like \"actual equality\" become \"equality in the theory\" or what you call \"logical equality\", and you gain access to another more precise \"actual equality\", which you might call \"syntactic equality\"</p>",
        "id": 237069465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978121
    },
    {
        "content": "<p>But any formal system can be meta-ified</p>",
        "id": 237069484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978142
    },
    {
        "content": "<p>My point is that there exists (imo) a notion of equality that lies outside of logic.</p>",
        "id": 237069547,
        "sender_full_name": "Mac",
        "timestamp": 1619978182
    },
    {
        "content": "<p>Sure, there is some philosophical notion of equality but I would not generally admit something like \"a\" = \"a\" under that because the two a's have different positions in space</p>",
        "id": 237069573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978227
    },
    {
        "content": "<p>This notion may or may not be the concept which a given logic chooses to formalize as \"equality\"</p>",
        "id": 237069576,
        "sender_full_name": "Mac",
        "timestamp": 1619978229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069573\">said</a>:</p>\n<blockquote>\n<p>Sure, there is some philosophical notion of equality but I would not generally admit something like \"a\" = \"a\" under that because the two a's have different positions in space</p>\n</blockquote>\n<p>Which is why the abstraction of characters and strings is need, only then can the philosophical notion bet applied. Neither of these, however, requires formal logic. At least from my formalist perspective. In fact, in my view, formal logic can only defined after these notions are grasped.</p>",
        "id": 237069685,
        "sender_full_name": "Mac",
        "timestamp": 1619978332
    },
    {
        "content": "<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>",
        "id": 237069712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978377
    },
    {
        "content": "<p>Formal logics can then, of course, formalize these notions within themselves.</p>",
        "id": 237069716,
        "sender_full_name": "Mac",
        "timestamp": 1619978379
    },
    {
        "content": "<p>and since formal logic can be applied to any mathematical field, including itself, you get this meta business</p>",
        "id": 237069807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069712\">said</a>:</p>\n<blockquote>\n<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>\n</blockquote>\n<p>That strikes me more as a statement of Logicism <a href=\"https://en.wikipedia.org/wiki/Logicism\">https://en.wikipedia.org/wiki/Logicism</a> than Formalism <a href=\"https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)\">https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)</a></p>",
        "id": 237069814,
        "sender_full_name": "Mac",
        "timestamp": 1619978430
    },
    {
        "content": "<p>To quote from the page \"In the philosophy of mathematics, formalism is the view that holds that statements of mathematics and <strong>logic</strong> can be considered to be statements about the consequences of the manipulation of strings (alphanumeric sequences of symbols, usually as equations) using established manipulation rules.\" (Emphasis mine)</p>",
        "id": 237069854,
        "sender_full_name": "Mac",
        "timestamp": 1619978461
    },
    {
        "content": "<p>I don't disagree with that</p>",
        "id": 237069905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978516
    },
    {
        "content": "<p>Mathematics is a game of symbols on a page</p>",
        "id": 237069964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978548
    },
    {
        "content": "<p>or in the computer, as it were</p>",
        "id": 237069975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978560
    },
    {
        "content": "<p>As someone who considers myself a formalist more than a logicism (by these definitions) I would thus disagree with your definition of Logic.</p>",
        "id": 237069978,
        "sender_full_name": "Mac",
        "timestamp": 1619978561
    },
    {
        "content": "<p>Though I would also somewhat agree.</p>",
        "id": 237069989,
        "sender_full_name": "Mac",
        "timestamp": 1619978577
    },
    {
        "content": "<p>For me, \"Reason\" is closer to what you defined to be \"Logic\" and \"Logic\" is the manipulation of strings.</p>",
        "id": 237070054,
        "sender_full_name": "Mac",
        "timestamp": 1619978629
    },
    {
        "content": "<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>",
        "id": 237070059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978638
    },
    {
        "content": "<p>However, a fair alternative definition is \"Logic\" as you defined and \"Formal Logic\" as I have defined.</p>",
        "id": 237070115,
        "sender_full_name": "Mac",
        "timestamp": 1619978657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070059\">said</a>:</p>\n<blockquote>\n<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>\n</blockquote>\n<p>Logicism just claims that everything <em>in mathematics</em> reduces to logic (not everything in general). Do you disagree with that?</p>",
        "id": 237070175,
        "sender_full_name": "Mac",
        "timestamp": 1619978727
    },
    {
        "content": "<p>depends on what \"reduces to\" means</p>",
        "id": 237070189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978749
    },
    {
        "content": "<p>limiting to mathematics seems prudent</p>",
        "id": 237070204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070189\">said</a>:</p>\n<blockquote>\n<p>depends on what \"reduces to\" means</p>\n</blockquote>\n<p>Hence why the Wikipedia article phrases it 3 different ways: \"mathematics is an extension of logic, some or all of mathematics is reducible to logic, or some or all of mathematics may be modelled in logic\" XD</p>",
        "id": 237070277,
        "sender_full_name": "Mac",
        "timestamp": 1619978832
    },
    {
        "content": "<p>If you rephrase something enough times it's hard to disagree with</p>",
        "id": 237070395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619978924
    },
    {
        "content": "<p>Lol!</p>",
        "id": 237070399,
        "sender_full_name": "Mac",
        "timestamp": 1619978940
    },
    {
        "content": "<p>I think the key thrust of my point is this: I consider that abstraction of characters and strings and their identity (which I term \"syntactic equality\" or \"identity\")  to be a more fundamental concept than \"logic\".</p>",
        "id": 237070547,
        "sender_full_name": "Mac",
        "timestamp": 1619979087
    },
    {
        "content": "<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>",
        "id": 237070604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979131
    },
    {
        "content": "<p>\"logic\"s can (and may or may not) model these concepts but they exist (and can be conceived of) without them</p>",
        "id": 237070622,
        "sender_full_name": "Mac",
        "timestamp": 1619979144
    },
    {
        "content": "<p>When viewing lean itself as a logic it is not</p>",
        "id": 237070631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070604\">said</a>:</p>\n<blockquote>\n<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>\n</blockquote>\n<p>No. In fact <code>Eq</code> to a certain extent prevents the true notion of \"syntactic equality\" from being modelled (in my view).</p>",
        "id": 237070691,
        "sender_full_name": "Mac",
        "timestamp": 1619979244
    },
    {
        "content": "<p>As syntactically distinct things such as '1 + 1' and '2' can be considered <code>Eq</code> and can be substituted with one another in proofs (prohibiting distinction)</p>",
        "id": 237070748,
        "sender_full_name": "Mac",
        "timestamp": 1619979305
    },
    {
        "content": "<p>1+1 is just a way to denote 2, says lean</p>",
        "id": 237070788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979337
    },
    {
        "content": "<p>Logical equality undermines syntactic equality.</p>",
        "id": 237070789,
        "sender_full_name": "Mac",
        "timestamp": 1619979337
    },
    {
        "content": "<p>if you want 1+1 in the logic you would use <code>term.add term.one term.one</code></p>",
        "id": 237070803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979352
    },
    {
        "content": "<p>and lean will agree that this is not <code>term.two</code></p>",
        "id": 237070847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070788\">said</a>:</p>\n<blockquote>\n<p>1+1 is just a way to denote 2, says lean</p>\n</blockquote>\n<p>Exactly! Thus Lean does not preserve syntactic equality (within itself).</p>",
        "id": 237070869,
        "sender_full_name": "Mac",
        "timestamp": 1619979393
    },
    {
        "content": "<p>but the logic will agree that <code>proof (prop.eq (term.add term.one term.one) term.two)</code></p>",
        "id": 237070883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979407
    },
    {
        "content": "<p>However, with the new metaprogramming capabilities this can be resolved by cheating in many cases.</p>",
        "id": 237070893,
        "sender_full_name": "Mac",
        "timestamp": 1619979418
    },
    {
        "content": "<p>I feel like you are missing the point of mathematics, 1+1=2 is how it's supposed to work</p>",
        "id": 237070938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979466
    },
    {
        "content": "<p>those two are the same number</p>",
        "id": 237070988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979490
    },
    {
        "content": "<p>they aren't terms, they are two ways to write the same natural number</p>",
        "id": 237071015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979515
    },
    {
        "content": "<p>That's fine, in mathematics.</p>",
        "id": 237071018,
        "sender_full_name": "Mac",
        "timestamp": 1619979519
    },
    {
        "content": "<p>yes, and lean is \"mathematics\" here</p>",
        "id": 237071025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979527
    },
    {
        "content": "<p>and theory T is \"the logic under study\"</p>",
        "id": 237071039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979542
    },
    {
        "content": "<p>No, Lean can be much more general than that.</p>",
        "id": 237071040,
        "sender_full_name": "Mac",
        "timestamp": 1619979543
    },
    {
        "content": "<p>After all, it is now a general purpose programming language.</p>",
        "id": 237071056,
        "sender_full_name": "Mac",
        "timestamp": 1619979559
    },
    {
        "content": "<p>But we're using it to do mathematics</p>",
        "id": 237071065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979578
    },
    {
        "content": "<p>My system is a metalogic and it needs to be able to represent logics where <code>1 + 1</code> is not exactly <code>2</code></p>",
        "id": 237071072,
        "sender_full_name": "Mac",
        "timestamp": 1619979588
    },
    {
        "content": "<p>They may be mathematically equal, but not equal in other ways.</p>",
        "id": 237071132,
        "sender_full_name": "Mac",
        "timestamp": 1619979616
    },
    {
        "content": "<p>That requires that you use the language of the theory under study</p>",
        "id": 237071149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979624
    },
    {
        "content": "<p>Like in general programming.</p>",
        "id": 237071150,
        "sender_full_name": "Mac",
        "timestamp": 1619979625
    },
    {
        "content": "<p>don't use <code>Nat</code> if you want that</p>",
        "id": 237071158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979630
    },
    {
        "content": "<p>Which I am not.</p>",
        "id": 237071178,
        "sender_full_name": "Mac",
        "timestamp": 1619979643
    },
    {
        "content": "<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>",
        "id": 237071221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979677
    },
    {
        "content": "<p>In computer science <code>1 + 1</code> is generally not <strong>logically</strong> equal to <code>2</code> (as one is a computation and one is a constant)</p>",
        "id": 237071225,
        "sender_full_name": "Mac",
        "timestamp": 1619979690
    },
    {
        "content": "<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>",
        "id": 237071295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071221\">said</a>:</p>\n<blockquote>\n<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>\n</blockquote>\n<p>Yeah, and I do do something like this.</p>",
        "id": 237071299,
        "sender_full_name": "Mac",
        "timestamp": 1619979747
    },
    {
        "content": "<p>Certainly compilers seem to think that <code>1 + 1</code> is interchangeable with <code>2</code></p>",
        "id": 237071357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071295\">said</a>:</p>\n<blockquote>\n<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>\n</blockquote>\n<p>Yes, but when it comes to compiling/optimizing they are initially distinct.</p>",
        "id": 237071369,
        "sender_full_name": "Mac",
        "timestamp": 1619979829
    },
    {
        "content": "<p>they are logically equal but syntactically different, in the language from earlier</p>",
        "id": 237071427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979864
    },
    {
        "content": "<p>The point of optimization is to pick the computational representation of two logically equivalent expressions that is more efficient (faster/less space), which requires you to be able to distinguish two logically equivalent terns.</p>",
        "id": 237071456,
        "sender_full_name": "Mac",
        "timestamp": 1619979910
    },
    {
        "content": "<p>right, which works because compilers work at the meta-level with respect to the program logic</p>",
        "id": 237071502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619979953
    },
    {
        "content": "<p>Correct, though, you can also do the same within a single logic by reducing the scope of equality.</p>",
        "id": 237071570,
        "sender_full_name": "Mac",
        "timestamp": 1619980001
    },
    {
        "content": "<p>i.e. by making mathematical equality not identical to logical equality.</p>",
        "id": 237071593,
        "sender_full_name": "Mac",
        "timestamp": 1619980062
    },
    {
        "content": "<p>There are issues that crop up when you use a logic as its own metalogic. I think if the object-<code>=</code> and meta-<code>=</code> coincide it would have to be a fairly trivial logic</p>",
        "id": 237071600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980081
    },
    {
        "content": "<p>I disagree. In fact, I don't think equality is all that significant of a concept in the first place (to computation). For example, Peano arithmetic can be defined without it (or with just partial equality -- symmetric and transitive with no substitution).</p>",
        "id": 237071749,
        "sender_full_name": "Mac",
        "timestamp": 1619980226
    },
    {
        "content": "<p>peano arithmetic at least lets you prove 1+1=2</p>",
        "id": 237071781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980251
    },
    {
        "content": "<p>that theorem would fail if logical equality is exactly syntactic equality</p>",
        "id": 237071796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980272
    },
    {
        "content": "<p>For some definition of equality.</p>",
        "id": 237071801,
        "sender_full_name": "Mac",
        "timestamp": 1619980277
    },
    {
        "content": "<p>for a very useful definition of equality</p>",
        "id": 237071806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980289
    },
    {
        "content": "<p>Peano equality is actually not logical equality (it does not have predicate substitution as one of its axioms).</p>",
        "id": 237071813,
        "sender_full_name": "Mac",
        "timestamp": 1619980314
    },
    {
        "content": "<p>It is only reflexive, transitive, and symmetric (and only for natural numbers).</p>",
        "id": 237071856,
        "sender_full_name": "Mac",
        "timestamp": 1619980335
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Peano_axioms\">https://en.wikipedia.org/wiki/Peano_axioms</a></p>",
        "id": 237071874,
        "sender_full_name": "Mac",
        "timestamp": 1619980349
    },
    {
        "content": "<p>It's closure property for nats is also not symmetric.</p>",
        "id": 237071880,
        "sender_full_name": "Mac",
        "timestamp": 1619980365
    },
    {
        "content": "<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>",
        "id": 237071932,
        "sender_full_name": "Mac",
        "timestamp": 1619980397
    },
    {
        "content": "<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>",
        "id": 237072001,
        "sender_full_name": "Mac",
        "timestamp": 1619980447
    },
    {
        "content": "<p>In fact, the lack of symmetry is why Peano arithmetic is so popular in computer science. Because its definitions really don't need symmetry.</p>",
        "id": 237072080,
        "sender_full_name": "Mac",
        "timestamp": 1619980555
    },
    {
        "content": "<p>They only need rewrite and joinability.</p>",
        "id": 237072128,
        "sender_full_name": "Mac",
        "timestamp": 1619980573
    },
    {
        "content": "<p>PA builds on FOL, which generally has the substitution property either built in or derivable</p>",
        "id": 237072129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980574
    },
    {
        "content": "<p><strong>Modern</strong> PA builds on FOL, <strong>original</strong> PA does not.</p>",
        "id": 237072153,
        "sender_full_name": "Mac",
        "timestamp": 1619980596
    },
    {
        "content": "<p>In fact, original PA is second-order.</p>",
        "id": 237072171,
        "sender_full_name": "Mac",
        "timestamp": 1619980627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071932\">said</a>:</p>\n<blockquote>\n<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>\n</blockquote>\n<p>This one is listed as number 5 on wiki</p>",
        "id": 237072178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980630
    },
    {
        "content": "<p>number 5 is the converse</p>",
        "id": 237072194,
        "sender_full_name": "Mac",
        "timestamp": 1619980649
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237072001\">said</a>:</p>\n<blockquote>\n<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>\n</blockquote>",
        "id": 237072207,
        "sender_full_name": "Mac",
        "timestamp": 1619980675
    },
    {
        "content": "<p>equality is symmetric</p>",
        "id": 237072218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980680
    },
    {
        "content": "<p>Only for nats in PA.</p>",
        "id": 237072265,
        "sender_full_name": "Mac",
        "timestamp": 1619980698
    },
    {
        "content": "<p>number 3: \"For all <strong>natural numbers</strong> x and y, if x = y, then y = x.\"</p>",
        "id": 237072278,
        "sender_full_name": "Mac",
        "timestamp": 1619980717
    },
    {
        "content": "<p>If b is unknown you can't use symmetry.</p>",
        "id": 237072282,
        "sender_full_name": "Mac",
        "timestamp": 1619980729
    },
    {
        "content": "<p>You first have prove that both sides are natural before you can use symmetry.</p>",
        "id": 237072304,
        "sender_full_name": "Mac",
        "timestamp": 1619980756
    },
    {
        "content": "<p>That seems like a typo or oversight in the presentation</p>",
        "id": 237072319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980773
    },
    {
        "content": "<p>I wrote proofs of all these things to test my metalogic.</p>",
        "id": 237072340,
        "sender_full_name": "Mac",
        "timestamp": 1619980803
    },
    {
        "content": "<p>It works as formulated on the Wiki page.</p>",
        "id": 237072377,
        "sender_full_name": "Mac",
        "timestamp": 1619980815
    },
    {
        "content": "<p>In formal treatments of this usually \"is a natural number\" isn't even a thing</p>",
        "id": 237072386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980822
    },
    {
        "content": "<p>you just have all things be natural numbers</p>",
        "id": 237072412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980848
    },
    {
        "content": "<p>true, but some interesting prosperities emerge if you do it like written.</p>",
        "id": 237072425,
        "sender_full_name": "Mac",
        "timestamp": 1619980863
    },
    {
        "content": "<p>It also probably because PA is generally embedded in other logics rather than used on its own.</p>",
        "id": 237072491,
        "sender_full_name": "Mac",
        "timestamp": 1619980924
    },
    {
        "content": "<p>Incidentally, I have been working for a while on a formal library which is based on PA; I don't know of any larger practical formal development using PA as the basis</p>",
        "id": 237072534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619980985
    },
    {
        "content": "<p>Nat in Lean (and  most other functional languages) is  a embedding of (modern) PA?</p>",
        "id": 237072564,
        "sender_full_name": "Mac",
        "timestamp": 1619981031
    },
    {
        "content": "<p>DTT is way stronger than PA</p>",
        "id": 237072605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981047
    },
    {
        "content": "<p>Yes, true</p>",
        "id": 237072619,
        "sender_full_name": "Mac",
        "timestamp": 1619981067
    },
    {
        "content": "<p>I mean a formalization of the axiom system PA and its consequences</p>",
        "id": 237072627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981093
    },
    {
        "content": "<p>yes, you can do this in lean (in principle)</p>",
        "id": 237072655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981113
    },
    {
        "content": "<p>as far as I know no one has worked out a significant amount of mathematics in that setting</p>",
        "id": 237072684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981152
    },
    {
        "content": "<p>Well, now its done in practice.:)</p>",
        "id": 237072685,
        "sender_full_name": "Mac",
        "timestamp": 1619981152
    },
    {
        "content": "<p>I mostly just did it as a test of my system. I did find a lot of (what I consider to be) interesting results though.</p>",
        "id": 237072744,
        "sender_full_name": "Mac",
        "timestamp": 1619981189
    },
    {
        "content": "<p>It's one thing to write the axioms and quite another to construct finite set theory in it, recursive functions, provability, and some CS stuff</p>",
        "id": 237072797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981248
    },
    {
        "content": "<p>Well yeah</p>",
        "id": 237072861,
        "sender_full_name": "Mac",
        "timestamp": 1619981291
    },
    {
        "content": "<p>I would like lean 4 to get to the point that writing extended formal developments in embedded languages is easy; in lean 3 it's a pretty big ergonomic step down from regular lean proofs</p>",
        "id": 237072882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981322
    },
    {
        "content": "<p>What do you mean by an \"embedded language\"?</p>",
        "id": 237072905,
        "sender_full_name": "Mac",
        "timestamp": 1619981368
    },
    {
        "content": "<p>like, <em>in principle</em> you can write tactics and things to work on the embedded language but for the most part you are starting from scratch</p>",
        "id": 237072913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981384
    },
    {
        "content": "<p>I mean \"theory T\" that you are defining in lean</p>",
        "id": 237072921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981400
    },
    {
        "content": "<p>like if you define the language and proof theory of PA and then want to prove a bazillion theorems in it because you want to prove godel incompleteness</p>",
        "id": 237072994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981448
    },
    {
        "content": "<p>the reason for writing it in lean is so that you can also prove theorems <em>about</em> the system, but theorems <em>in</em> the system are also important</p>",
        "id": 237073010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981498
    },
    {
        "content": "<p>I think my approach is rather ergonomic to a degree. I don't know what others would think of it though. It is also in super super alpha.</p>",
        "id": 237073015,
        "sender_full_name": "Mac",
        "timestamp": 1619981508
    },
    {
        "content": "<p>You can more or less create one-for-one tactics.</p>",
        "id": 237073065,
        "sender_full_name": "Mac",
        "timestamp": 1619981536
    },
    {
        "content": "<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>",
        "id": 237073081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981549
    },
    {
        "content": "<p>I think the most annoying thing to work with though would be linear logic as you <strong>cannot</strong> reduce most things to functions any more.</p>",
        "id": 237073089,
        "sender_full_name": "Mac",
        "timestamp": 1619981570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073081\">said</a>:</p>\n<blockquote>\n<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>\n</blockquote>\n<p>Ah, then no, you would probably not like my approach then. I avoid those two commands like the plague.</p>",
        "id": 237073116,
        "sender_full_name": "Mac",
        "timestamp": 1619981621
    },
    {
        "content": "<p>Hm, makes me wonder about porting Iris to lean 4</p>",
        "id": 237073118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981627
    },
    {
        "content": "<p>why are you avoiding them?</p>",
        "id": 237073175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981650
    },
    {
        "content": "<p>I dislike <code>rw</code> and <code>simp</code> because they hide what rules/theorems you are actually using.</p>",
        "id": 237073190,
        "sender_full_name": "Mac",
        "timestamp": 1619981657
    },
    {
        "content": "<p>if you are just trying to establish provability that's usually not a big deal</p>",
        "id": 237073215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981703
    },
    {
        "content": "<p>I want my proofs to be clear (and <code>go to definition</code> able)</p>",
        "id": 237073223,
        "sender_full_name": "Mac",
        "timestamp": 1619981713
    },
    {
        "content": "<p>plus you can use <code>simp only</code> or only mark things as simp lemmas that you want to elide</p>",
        "id": 237073239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073215\">said</a>:</p>\n<blockquote>\n<p>if you are just trying to establish provability that's usually not a big deal</p>\n</blockquote>\n<p>True, but that is rarely my goal.</p>",
        "id": 237073242,
        "sender_full_name": "Mac",
        "timestamp": 1619981740
    },
    {
        "content": "<p>I am more interested in reverse mathematics.</p>",
        "id": 237073260,
        "sender_full_name": "Mac",
        "timestamp": 1619981755
    },
    {
        "content": "<p>i.e. I want to know exactly what assumptions were made to get to a given proof.</p>",
        "id": 237073318,
        "sender_full_name": "Mac",
        "timestamp": 1619981781
    },
    {
        "content": "<p>And  I want to minimize them.</p>",
        "id": 237073326,
        "sender_full_name": "Mac",
        "timestamp": 1619981793
    },
    {
        "content": "<p>That's what <code>#print axioms</code> is for</p>",
        "id": 237073327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981796
    },
    {
        "content": "<p>well, you have more refined mechanisms for that in a deep embedding</p>",
        "id": 237073340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981816
    },
    {
        "content": "<p>You can literally define a function on proofs that will tell you if you used only such and such assumptions</p>",
        "id": 237073382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981868
    },
    {
        "content": "<p>I like that stuff to be explicit. Also, print axioms only works for Lean axioms not other kinds of assumptions.</p>",
        "id": 237073387,
        "sender_full_name": "Mac",
        "timestamp": 1619981878
    },
    {
        "content": "<p>I also would like them to be readable in isolation from the source code.</p>",
        "id": 237073449,
        "sender_full_name": "Mac",
        "timestamp": 1619981907
    },
    {
        "content": "<p>If you don't want to assume something, don't assume it</p>",
        "id": 237073455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619981917
    },
    {
        "content": "<p>I want my lean proofs to more-or-less work (and be readable) in a vacuum.</p>",
        "id": 237073497,
        "sender_full_name": "Mac",
        "timestamp": 1619981982
    },
    {
        "content": "<p>And I am pretty happy with what I have gotten working in that regard.</p>",
        "id": 237073557,
        "sender_full_name": "Mac",
        "timestamp": 1619982015
    },
    {
        "content": "<p>Those are not words I would use to describe lean</p>",
        "id": 237073560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982017
    },
    {
        "content": "<p>there are quite a lot of things that go into turning lean text into a theorem/assertion</p>",
        "id": 237073739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982167
    },
    {
        "content": "<p>Here is my proof of commutativity of PA addition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">addNatCommProof</span>\n<span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Logic</span> <span class=\"n\">P</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">PNat</span> <span class=\"n\">P</span> <span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">SEq</span> <span class=\"n\">P</span> <span class=\"n\">T</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">SAdd</span> <span class=\"n\">T</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">I</span>   <span class=\"o\">:</span> <span class=\"n\">NatInductionRight</span> <span class=\"n\">L</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">NS</span>  <span class=\"o\">:</span> <span class=\"n\">NatSuccNat</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">NA</span>  <span class=\"o\">:</span> <span class=\"n\">NatAddNat</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">QEL</span> <span class=\"o\">:</span> <span class=\"n\">EqNatLeftEuc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">QtS</span> <span class=\"o\">:</span> <span class=\"n\">EqNatToEqSucc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">A0C</span> <span class=\"o\">:</span> <span class=\"n\">AddNatZeroComm</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">A</span> <span class=\"n\">N.toZero</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ASn</span> <span class=\"o\">:</span> <span class=\"n\">AddSuccNatEqSucc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">A</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">AnS</span> <span class=\"o\">:</span> <span class=\"n\">AddNatSuccEqSucc</span> <span class=\"n\">L</span> <span class=\"n\">N.toIsNat</span> <span class=\"n\">Q</span> <span class=\"n\">A</span> <span class=\"n\">N.toSucc</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">natInductionRight</span> <span class=\"bp\">?</span><span class=\"n\">f0</span> <span class=\"bp\">?</span><span class=\"n\">fS</span>\n  <span class=\"n\">case</span> <span class=\"n\">f0</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">Na</span>\n    <span class=\"n\">exact</span> <span class=\"n\">addNatZeroComm</span> <span class=\"n\">Na</span>\n  <span class=\"n\">case</span> <span class=\"n\">fS</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">Nb</span> <span class=\"n\">Anb_eq_Abn</span> <span class=\"n\">a</span> <span class=\"n\">Na</span>\n    <span class=\"k\">have</span> <span class=\"n\">NSb</span> <span class=\"o\">:=</span> <span class=\"n\">natS</span> <span class=\"n\">Nb</span>\n    <span class=\"k\">have</span> <span class=\"n\">NAab</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">Na</span> <span class=\"n\">Nb</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">NSAab</span> <span class=\"o\">:=</span> <span class=\"n\">natS</span> <span class=\"n\">NAab</span><span class=\"bp\">;</span>\n    <span class=\"k\">have</span> <span class=\"n\">NAba</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">Nb</span> <span class=\"n\">Na</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">NSAba</span> <span class=\"o\">:=</span> <span class=\"n\">natS</span> <span class=\"n\">NAba</span>\n    <span class=\"k\">have</span> <span class=\"n\">NASba</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">NSb</span> <span class=\"n\">Na</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">NASab</span> <span class=\"o\">:=</span> <span class=\"n\">natAdd</span> <span class=\"n\">Na</span> <span class=\"n\">NSb</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eqNatLeftEuc</span> <span class=\"n\">NSAab</span> <span class=\"n\">NASab</span> <span class=\"n\">NASba</span>\n    <span class=\"n\">exact</span> <span class=\"n\">addNatSuccEqSucc</span> <span class=\"n\">Na</span> <span class=\"n\">Nb</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eqNatLeftEuc</span> <span class=\"n\">NSAba</span> <span class=\"n\">NASba</span> <span class=\"n\">NSAab</span>\n    <span class=\"n\">exact</span> <span class=\"n\">addSuccNatEqSucc</span> <span class=\"n\">Nb</span> <span class=\"n\">Na</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eqNatToEqSucc</span> <span class=\"n\">NAab</span> <span class=\"n\">NAba</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Anb_eq_Abn</span> <span class=\"n\">a</span> <span class=\"n\">Na</span>\n</code></pre></div>\n<p>I still think it needs some refinement, but I like the general structure (and notation).</p>",
        "id": 237073744,
        "sender_full_name": "Mac",
        "timestamp": 1619982172
    },
    {
        "content": "<p>I do want to try to automate the <code>nat</code> proofs though.</p>",
        "id": 237073809,
        "sender_full_name": "Mac",
        "timestamp": 1619982220
    },
    {
        "content": "<p>I'm not so sure about \"readable in a vaccum\" from this end</p>",
        "id": 237073911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982314
    },
    {
        "content": "<p>have/apply/exact is not a great recipe for proofs that can be read offline</p>",
        "id": 237073947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982351
    },
    {
        "content": "<p>True</p>",
        "id": 237073997,
        "sender_full_name": "Mac",
        "timestamp": 1619982377
    },
    {
        "content": "<p>I do think my current orientation is more for reading in an editor sadly (with the goal info view).</p>",
        "id": 237074013,
        "sender_full_name": "Mac",
        "timestamp": 1619982409
    },
    {
        "content": "<p>My point here was mostly to demonstrate what I mean by making assumption/inference rules explicit</p>",
        "id": 237074068,
        "sender_full_name": "Mac",
        "timestamp": 1619982476
    },
    {
        "content": "<p>I think that part at least is readable in a vacuum.</p>",
        "id": 237074148,
        "sender_full_name": "Mac",
        "timestamp": 1619982504
    },
    {
        "content": "<p>I would have preferred to see the actual statements rather than <code>AddNatZeroComm</code></p>",
        "id": 237074175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982532
    },
    {
        "content": "<p>That's fair. My approach to that is one of things I want to fine. Though the actual statement approach can get a little verbose, and makes synthesizing derivative statements impossible (the reason they are written like this is to make them type classes).</p>",
        "id": 237074469,
        "sender_full_name": "Mac",
        "timestamp": 1619982729
    },
    {
        "content": "<p>why aren't they in square brackets then?</p>",
        "id": 237074515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982769
    },
    {
        "content": "<p>Because they aren't being synthesized.</p>",
        "id": 237074590,
        "sender_full_name": "Mac",
        "timestamp": 1619982832
    },
    {
        "content": "<p>I think that it would be better to just have a <code>#print axioms</code> like approach here, since listing the axioms on every theorem will get repetitive (for you and your readers)</p>",
        "id": 237074661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982862
    },
    {
        "content": "<p>just add the ability to query the axioms used by any theorem</p>",
        "id": 237074681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982874
    },
    {
        "content": "<p>That's fair. I just personally don't like that approach myself (though I will admit adding the axioms to every theorem can be tiresome).</p>",
        "id": 237074789,
        "sender_full_name": "Mac",
        "timestamp": 1619982953
    },
    {
        "content": "<p>For example, this <a href=\"http://us.metamath.org/mpeuni/ancom.html\">metamath theorem</a> is a proof of commutativity of and, and in the axiom list it says it depends on ax-1, ax-2, ax-3, ax-mp, and definitions df-bi, df-an</p>",
        "id": 237074853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619982976
    },
    {
        "content": "<p>Though, also, I am not sure how I would do that.</p>",
        "id": 237074856,
        "sender_full_name": "Mac",
        "timestamp": 1619982976
    },
    {
        "content": "<p>it's much easier for the computer to collect and organize this information, and it doesn't prevent the proof author from optimizing it</p>",
        "id": 237074907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983015
    },
    {
        "content": "<p>In principle <code>#print axioms</code> does the same thing but because most of the DTT axioms aren't listed it has limited usefulness</p>",
        "id": 237074958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983073
    },
    {
        "content": "<p>I don't think Lean has a way of automatically inferring hypotheses though?</p>",
        "id": 237075044,
        "sender_full_name": "Mac",
        "timestamp": 1619983119
    },
    {
        "content": "<p>No, they aren't hypotheses here, just axioms/theorems</p>",
        "id": 237075066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983145
    },
    {
        "content": "<p>They are hypotheses.</p>",
        "id": 237075082,
        "sender_full_name": "Mac",
        "timestamp": 1619983159
    },
    {
        "content": "<p>In your version they are, but they can be set up as axioms</p>",
        "id": 237075098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983177
    },
    {
        "content": "<p>and then you can track the usage of those axioms</p>",
        "id": 237075108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983186
    },
    {
        "content": "<p>How so?</p>",
        "id": 237075120,
        "sender_full_name": "Mac",
        "timestamp": 1619983198
    },
    {
        "content": "<p>They are attached to a specific logic.</p>",
        "id": 237075165,
        "sender_full_name": "Mac",
        "timestamp": 1619983209
    },
    {
        "content": "<p>They don't hold in a vacuum</p>",
        "id": 237075191,
        "sender_full_name": "Mac",
        "timestamp": 1619983224
    },
    {
        "content": "<p>Yeah, the logic contains constructors for all the axioms</p>",
        "id": 237075194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983226
    },
    {
        "content": "<p>like the <code>proof</code> inductive I showed earlier</p>",
        "id": 237075205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983236
    },
    {
        "content": "<p>no it does not</p>",
        "id": 237075208,
        "sender_full_name": "Mac",
        "timestamp": 1619983238
    },
    {
        "content": "<p>Not in my system</p>",
        "id": 237075217,
        "sender_full_name": "Mac",
        "timestamp": 1619983246
    },
    {
        "content": "<p>which has a constructor for <code>mp</code></p>",
        "id": 237075218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983247
    },
    {
        "content": "<p>In fact, many of the inference rules I have cannot be written DTT.</p>",
        "id": 237075236,
        "sender_full_name": "Mac",
        "timestamp": 1619983270
    },
    {
        "content": "<p>??</p>",
        "id": 237075242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983277
    },
    {
        "content": "<p>as part of an inductive type</p>",
        "id": 237075247,
        "sender_full_name": "Mac",
        "timestamp": 1619983282
    },
    {
        "content": "<p>I don't believe you :P</p>",
        "id": 237075276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983294
    },
    {
        "content": "<p>For example by conditional proof, <code>((L |- p) -&gt; (L |- q)) -&gt; (L |- p -&gt; q)</code></p>",
        "id": 237075301,
        "sender_full_name": "Mac",
        "timestamp": 1619983315
    },
    {
        "content": "<p>That's fine</p>",
        "id": 237075306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983322
    },
    {
        "content": "<p>If L was an inductive type this could not be written like that.</p>",
        "id": 237075352,
        "sender_full_name": "Mac",
        "timestamp": 1619983335
    },
    {
        "content": "<p>well, actually it won't have the right effect</p>",
        "id": 237075359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983336
    },
    {
        "content": "<p>that's not how imp introduction works</p>",
        "id": 237075376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983359
    },
    {
        "content": "<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>",
        "id": 237075417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983402
    },
    {
        "content": "<p>Yes that is how conditional proof works (the mp was a typo).</p>",
        "id": 237075422,
        "sender_full_name": "Mac",
        "timestamp": 1619983406
    },
    {
        "content": "<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>",
        "id": 237075493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983449
    },
    {
        "content": "<p>basically you need the context to be an explicit part of the provability judgment</p>",
        "id": 237075510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983464
    },
    {
        "content": "<p>at least, if you want gentzen style imp introduction rules</p>",
        "id": 237075534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075417\">said</a>:</p>\n<blockquote>\n<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>\n</blockquote>\n<p>What do you mean by this?</p>",
        "id": 237075539,
        "sender_full_name": "Mac",
        "timestamp": 1619983493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493\">said</a>:</p>\n<blockquote>\n<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>\n</blockquote>\n<p>I also don't know what that notation is meant to say.</p>",
        "id": 237075568,
        "sender_full_name": "Mac",
        "timestamp": 1619983519
    },
    {
        "content": "<p>Suppose <code>p</code> is neither provable nor disprovable. Then <code>L |- p</code> is false, so <code>L |- p -&gt; L |- false</code> is true, so <code>L |- (p -&gt; false)</code> by your proof rule and so <code>p</code> is provably false. Thus every statement is provable or disprovable in the logic</p>",
        "id": 237075647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983575
    },
    {
        "content": "<p>\"Suppose <code> p</code> is neither provable nor disprovable.\" That would mean that neither <code>L |- p</code> or <code>(L |- p) -&gt; False</code> hold.</p>",
        "id": 237075722,
        "sender_full_name": "Mac",
        "timestamp": 1619983661
    },
    {
        "content": "<p>No, It means that <code>not (L |- p)</code> and <code>not (L |- not p)</code></p>",
        "id": 237075803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983723
    },
    {
        "content": "<p><code>L |- P</code> is not (necessarily) a Prop</p>",
        "id": 237075830,
        "sender_full_name": "Mac",
        "timestamp": 1619983749
    },
    {
        "content": "<p>doesn't really matter, use -&gt; False if you like</p>",
        "id": 237075846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983777
    },
    {
        "content": "<p><code>L |- not p</code> is not (necessarily) well-formed</p>",
        "id": 237075848,
        "sender_full_name": "Mac",
        "timestamp": 1619983779
    },
    {
        "content": "<p>That requires the language of L to have a <code>not</code></p>",
        "id": 237075860,
        "sender_full_name": "Mac",
        "timestamp": 1619983792
    },
    {
        "content": "<p>Okay... I am indeed making some bare minimum assumptions on the logic here</p>",
        "id": 237075927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983814
    },
    {
        "content": "<p>if the logic doesn't have a false then perhaps it's not inconsistent if only because you can't express it</p>",
        "id": 237075966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983841
    },
    {
        "content": "<p>The logic is initially devoid of any rules and the prop is initially devoid of any syntax.</p>",
        "id": 237075983,
        "sender_full_name": "Mac",
        "timestamp": 1619983857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075568\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493\">said</a>:</p>\n<blockquote>\n<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>\n</blockquote>\n<p>I also don't know what that notation is meant to say.</p>\n</blockquote>\n<p>I'm not sure what L is, so let's add a context <code>G</code>, which is a list or set of formulas. The proof inductive is <code>L, G |- p</code>, and means that if we assume the formulas <code>G</code> then <code>p</code> follows. So in particular <code>L, G |- p</code> if <code>p \\in G</code>. Then, the implication introduction rule is <code>(L, p::G |- q) -&gt; (L, G |- p -&gt; q)</code></p>",
        "id": 237076106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619983955
    },
    {
        "content": "<p>But yes with conditional proof, if I have <code>(L |- p) -&gt; False</code> then <code>L |- p -&gt; q</code> for all <code>q</code>. I don't see why that is a problem.</p>",
        "id": 237076182,
        "sender_full_name": "Mac",
        "timestamp": 1619984010
    },
    {
        "content": "<p>Because you are lifting metalogical falsity into the logic</p>",
        "id": 237076212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984043
    },
    {
        "content": "<p>That says \"if p is not provable then p is disprovable\"</p>",
        "id": 237076286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984059
    },
    {
        "content": "<p>which is a very strong assumption</p>",
        "id": 237076299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984077
    },
    {
        "content": "<p>in particular it is false for PA and ZFC and every other reasonable first order logic</p>",
        "id": 237076351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984127
    },
    {
        "content": "<p>If one wants a weaker assumption, feel free to use a weaker rule. But that, at least, is how I view the conditional proof rule to work.</p>",
        "id": 237076358,
        "sender_full_name": "Mac",
        "timestamp": 1619984137
    },
    {
        "content": "<p>If I can prove that (L |- p) does not hold, I can with the law of excluded middle, prove (L |- ~p) in most FO logic.</p>",
        "id": 237076705,
        "sender_full_name": "Mac",
        "timestamp": 1619984478
    },
    {
        "content": "<p>The proof that L |- p does not hold is happening in the metalogic here</p>",
        "id": 237076723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984511
    },
    {
        "content": "<p>for example, Godel's unprovable sentence</p>",
        "id": 237076758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984524
    },
    {
        "content": "<p>It's not that the logic proves <code>not p</code></p>",
        "id": 237076777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984545
    },
    {
        "content": "<p>it is that the metalogic proves that <code>L |- p</code> is false, i.e. axiom system L does not prove p</p>",
        "id": 237076807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984577
    },
    {
        "content": "<p>the law of excluded middle says <code>L |- (p \\/ ~p)</code></p>",
        "id": 237076826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984601
    },
    {
        "content": "<p>Incompleteness would be ((L |- p) \\/ (L |- ~p) -&gt; False), right? Not for a given p, (L |- p) -&gt; False, correct?</p>",
        "id": 237076832,
        "sender_full_name": "Mac",
        "timestamp": 1619984608
    },
    {
        "content": "<p>Yes. The first one says <code>p</code> is independent, and the second one says that <code>p</code> is not provable</p>",
        "id": 237076911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984668
    },
    {
        "content": "<p>independent just means that neither <code>p</code> nor <code>not p</code> is provable</p>",
        "id": 237076923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984688
    },
    {
        "content": "<p>but your axiom is essentially declaring that there are no independent sentences, which is also known as (syntactic) completeness</p>",
        "id": 237076962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984722
    },
    {
        "content": "<p>So it is saying that it implies that independence implies inconsistency, right?</p>",
        "id": 237077079,
        "sender_full_name": "Mac",
        "timestamp": 1619984823
    },
    {
        "content": "<p>and Godel proved that such a system is inconsistent if it can handle basic arithmetic</p>",
        "id": 237077082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984827
    },
    {
        "content": "<p>Well, that is only true if the logical also includes FOL</p>",
        "id": 237077124,
        "sender_full_name": "Mac",
        "timestamp": 1619984847
    },
    {
        "content": "<p>yes</p>",
        "id": 237077130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984851
    },
    {
        "content": "<p>If the metalogic is FOL (or DTT i.e. Lean), and the logic is just arithmatic that does not hold.</p>",
        "id": 237077146,
        "sender_full_name": "Mac",
        "timestamp": 1619984876
    },
    {
        "content": "<p>there are complete axiom systems that are not strong enough for basic arithmetic</p>",
        "id": 237077188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984889
    },
    {
        "content": "<p>but if it is strong enough to run godel's argument then it is inconsistent</p>",
        "id": 237077213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619984920
    },
    {
        "content": "<p>take a look at <a href=\"https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem\">https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem</a> to see whether your logic is weak enough; as long as it doesn't have FOL quantifiers or multiplication isn't total or something like that you might be able to get out of the issue</p>",
        "id": 237077348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985065
    },
    {
        "content": "<p>My point is that if you split the logic you can avoid that in many cases. For example, my fragment of PA is complete because only the equations and nat membership are statements in the logic. (It lacks quantifiers and propositional logical.)</p>",
        "id": 237077356,
        "sender_full_name": "Mac",
        "timestamp": 1619985071
    },
    {
        "content": "<p>Because all that is handled by the metalogic.</p>",
        "id": 237077369,
        "sender_full_name": "Mac",
        "timestamp": 1619985100
    },
    {
        "content": "<p>If there are no quantifiers, then just have \"all true sentences\" as your axiom system and this is complete (and decidable)</p>",
        "id": 237077388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985123
    },
    {
        "content": "<p>Exactly</p>",
        "id": 237077449,
        "sender_full_name": "Mac",
        "timestamp": 1619985165
    },
    {
        "content": "<p>in that case the <code>L |- </code> is just window dressing though</p>",
        "id": 237077487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985220
    },
    {
        "content": "<p>How so?</p>",
        "id": 237077509,
        "sender_full_name": "Mac",
        "timestamp": 1619985242
    },
    {
        "content": "<p>you can prove <code>L |- x = y &lt;-&gt; eval x = eval y</code> more or less</p>",
        "id": 237077550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985252
    },
    {
        "content": "<p>Well I might not be able to evaluate x and y in the metalogic though by default.</p>",
        "id": 237077595,
        "sender_full_name": "Mac",
        "timestamp": 1619985307
    },
    {
        "content": "<p>that's what I mean when I say it's decidable</p>",
        "id": 237077620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985333
    },
    {
        "content": "<p>you can just lift the expressions into the metalogic</p>",
        "id": 237077628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985344
    },
    {
        "content": "<p>you need some assumptions about plus and times</p>",
        "id": 237077654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985364
    },
    {
        "content": "<p>but the ones in your sample proof should be close to all you need</p>",
        "id": 237077687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985381
    },
    {
        "content": "<p>Wait, but L is only a subset of the things provable in the metalogic.</p>",
        "id": 237077729,
        "sender_full_name": "Mac",
        "timestamp": 1619985446
    },
    {
        "content": "<p>You will need to assume L is consistent for the reverse implication</p>",
        "id": 237077741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985468
    },
    {
        "content": "<p>like if I have (L |- 3 = 2) that does not mean that 3 = 2 in the metalogic.</p>",
        "id": 237077788,
        "sender_full_name": "Mac",
        "timestamp": 1619985486
    },
    {
        "content": "<p>It does, if L is consistent</p>",
        "id": 237077792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985494
    },
    {
        "content": "<p>no it doesn't</p>",
        "id": 237077809,
        "sender_full_name": "Mac",
        "timestamp": 1619985511
    },
    {
        "content": "<p>you might need something equivalent to not equal or less than in the logic</p>",
        "id": 237077817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985534
    },
    {
        "content": "<p>If I literally I have one axiom in I L, i.e L |- 3 = 2, that does not prove anything about 3 = 2 in the metalogic.</p>",
        "id": 237077820,
        "sender_full_name": "Mac",
        "timestamp": 1619985538
    },
    {
        "content": "<p>normally you would be able to combine that with other axioms of L to prove L is inconsistent</p>",
        "id": 237077836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985563
    },
    {
        "content": "<p>so if L is consistent then 3 = 2</p>",
        "id": 237077841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985572
    },
    {
        "content": "<p>consistency does not prove anything about the metalogic.</p>",
        "id": 237077851,
        "sender_full_name": "Mac",
        "timestamp": 1619985594
    },
    {
        "content": "<p>All consistency says is the ((p : P) -&gt; (L |- p) /\\ (L |- ~p)  -&gt; False)</p>",
        "id": 237077933,
        "sender_full_name": "Mac",
        "timestamp": 1619985630
    },
    {
        "content": "<p>If L is consistent, and L |- 3 = 2, then (by using other axioms) L |- False and so L is inconsistent, contradiction, thus 3 = 2</p>",
        "id": 237077990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985675
    },
    {
        "content": "<p>I'm assuming here that L is enough like PA that we can prove that L |- 3 != 2</p>",
        "id": 237078016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985715
    },
    {
        "content": "<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>",
        "id": 237078031,
        "sender_full_name": "Mac",
        "timestamp": 1619985723
    },
    {
        "content": "<p>You can use PA's other axioms to prove that 3 != 2</p>",
        "id": 237078144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985787
    },
    {
        "content": "<p>I am not talking about PA, I am just talking about some  random logic L</p>",
        "id": 237078180,
        "sender_full_name": "Mac",
        "timestamp": 1619985824
    },
    {
        "content": "<p>I'm talking about a random logic L with enough structure to run these arguments</p>",
        "id": 237078196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985841
    },
    {
        "content": "<p>That is sufficient structure.</p>",
        "id": 237078257,
        "sender_full_name": "Mac",
        "timestamp": 1619985869
    },
    {
        "content": "<p>A logic can be empty, it does not need proposition or rules.</p>",
        "id": 237078263,
        "sender_full_name": "Mac",
        "timestamp": 1619985884
    },
    {
        "content": "<p>Okay but then you can't prove anything about it</p>",
        "id": 237078277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985904
    },
    {
        "content": "<p>your earlier example had loads of assumptions about the logic</p>",
        "id": 237078293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985923
    },
    {
        "content": "<p>I'm using those assumptions, more or less</p>",
        "id": 237078305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078031\">said</a>:</p>\n<blockquote>\n<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>\n</blockquote>\n<p>The logic here is a valid logic with 2 propositions and 1 axiom and is complete and consistent.</p>",
        "id": 237078308,
        "sender_full_name": "Mac",
        "timestamp": 1619985934
    },
    {
        "content": "<p>yes</p>",
        "id": 237078311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985939
    },
    {
        "content": "<p>I'm talking about a logic with at least <code>x + 0 = x</code> and <code>x + s y = s (x+y)</code></p>",
        "id": 237078377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619985964
    },
    {
        "content": "<p>Yeah but the PA fragment used to prove the semiring properities doesn't even need negation.</p>",
        "id": 237078384,
        "sender_full_name": "Mac",
        "timestamp": 1619985970
    },
    {
        "content": "<p>So it is trivially consistent</p>",
        "id": 237078395,
        "sender_full_name": "Mac",
        "timestamp": 1619985978
    },
    {
        "content": "<p>If you add 3 = 2 to such a theory then you will get <code>x = y</code> for all x, y</p>",
        "id": 237078413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986003
    },
    {
        "content": "<p>which is the nearest equivalent to inconsistency</p>",
        "id": 237078421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986016
    },
    {
        "content": "<p>Yes, if you add that to axiom list</p>",
        "id": 237078469,
        "sender_full_name": "Mac",
        "timestamp": 1619986071
    },
    {
        "content": "<p>so if we assume that it is not inconsistent in that sense, then we will indeed have <code>L |- x = y -&gt; eval x = eval y</code></p>",
        "id": 237078470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986072
    },
    {
        "content": "<p>and the converse is trivial by reflexivity</p>",
        "id": 237078531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986097
    },
    {
        "content": "<p>actually no, L |- S 0 = 1 in PA, but S 0 = 1 is not true in the metalogic (Lean).</p>",
        "id": 237078572,
        "sender_full_name": "Mac",
        "timestamp": 1619986118
    },
    {
        "content": "<p><code>eval x = eval y</code></p>",
        "id": 237078581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986130
    },
    {
        "content": "<p>there is no eval (S 0) in the metalogic.</p>",
        "id": 237078598,
        "sender_full_name": "Mac",
        "timestamp": 1619986152
    },
    {
        "content": "<p>the right side equality is equality in <code>Nat</code></p>",
        "id": 237078599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986155
    },
    {
        "content": "<p>there is, it's pretty easy to define</p>",
        "id": 237078605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986171
    },
    {
        "content": "<p>Yes, if I define S and 0 and 1 as there Nat counterparts true.</p>",
        "id": 237078613,
        "sender_full_name": "Mac",
        "timestamp": 1619986180
    },
    {
        "content": "<p>but if I define them all as separate terms, then no.</p>",
        "id": 237078668,
        "sender_full_name": "Mac",
        "timestamp": 1619986215
    },
    {
        "content": "<p>the idea here is to turn any provability question <code>L |- x = y</code> into a statement <code>eval x = eval y</code> that we can just evaluate in lean</p>",
        "id": 237078672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986218
    },
    {
        "content": "<p>i.e.</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>inductive term\n| zero : term\n| one  : term\n| succ : term -&gt; term\n</code></pre></div>",
        "id": 237078702,
        "sender_full_name": "Mac",
        "timestamp": 1619986242
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">term.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">term.one</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">term.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 237078728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986286
    },
    {
        "content": "<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>",
        "id": 237078789,
        "sender_full_name": "Mac",
        "timestamp": 1619986336
    },
    {
        "content": "<p>Mario, your <code>eval</code> is not injective</p>",
        "id": 237078812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619986355
    },
    {
        "content": "<p>it's not supposed to be</p>",
        "id": 237078849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078789\">said</a>:</p>\n<blockquote>\n<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>\n</blockquote>\n<p>But that isomorphism does exist organically.</p>",
        "id": 237078862,
        "sender_full_name": "Mac",
        "timestamp": 1619986419
    },
    {
        "content": "<p>it's supposed to translate L-provably equal terms into equal natural numbers</p>",
        "id": 237078865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078789\">said</a>:</p>\n<blockquote>\n<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>\n</blockquote>\n<p>Not obviously: That only holds for the decidable fragment. If I use PA in place of L, then that will not be true for many quantified statements</p>",
        "id": 237079006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986539
    },
    {
        "content": "<p>for example PA |- Con(PA) is false but Con(PA) is true (in lean)</p>",
        "id": 237079058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986566
    },
    {
        "content": "<p>I meant the PA fragment we were discussing.</p>",
        "id": 237079077,
        "sender_full_name": "Mac",
        "timestamp": 1619986581
    },
    {
        "content": "<p>Without quantifiers, the logic becomes a roundabout way of talking about <code>Nat</code></p>",
        "id": 237079106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986616
    },
    {
        "content": "<p>that was my point</p>",
        "id": 237079114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986622
    },
    {
        "content": "<p>Okay, and that is a problem why?</p>",
        "id": 237079132,
        "sender_full_name": "Mac",
        "timestamp": 1619986635
    },
    {
        "content": "<p>well, L doesn't contribute much in that case</p>",
        "id": 237079138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986649
    },
    {
        "content": "<p>well it is more limited than Nat</p>",
        "id": 237079150,
        "sender_full_name": "Mac",
        "timestamp": 1619986664
    },
    {
        "content": "<p>At least my fragment is</p>",
        "id": 237079157,
        "sender_full_name": "Mac",
        "timestamp": 1619986672
    },
    {
        "content": "<p>Does your fragment have the axioms needed to establish the theorem I mentioned?</p>",
        "id": 237079217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986698
    },
    {
        "content": "<p>For example with my semiring fragment you can't prove <code>0 = 1</code> or <code>0 \\ne 1</code></p>",
        "id": 237079221,
        "sender_full_name": "Mac",
        "timestamp": 1619986704
    },
    {
        "content": "<p>but you can prove that 0 = 1 -&gt; x = y</p>",
        "id": 237079230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986723
    },
    {
        "content": "<p>which seems like basically the same as 0 \\ne 1</p>",
        "id": 237079244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237079230\">said</a>:</p>\n<blockquote>\n<p>but you can prove that 0 = 1 -&gt; x = y</p>\n</blockquote>\n<p>How?</p>",
        "id": 237079265,
        "sender_full_name": "Mac",
        "timestamp": 1619986764
    },
    {
        "content": "<p>You can only prove that <code>(L |- x = y) -&gt; (eval x = eval y)</code> for your <code>eval</code></p>",
        "id": 237079298,
        "sender_full_name": "Mac",
        "timestamp": 1619986797
    },
    {
        "content": "<p>You can't prove <code>eval x = eval y -&gt; (L |- x = y)</code></p>",
        "id": 237079366,
        "sender_full_name": "Mac",
        "timestamp": 1619986828
    },
    {
        "content": "<p>That should be the easy direction</p>",
        "id": 237079384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986839
    },
    {
        "content": "<p>My fragment lacks reflexivity</p>",
        "id": 237079400,
        "sender_full_name": "Mac",
        "timestamp": 1619986851
    },
    {
        "content": "<p>ah... what</p>",
        "id": 237079412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986864
    },
    {
        "content": "<p>ok then</p>",
        "id": 237079429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986869
    },
    {
        "content": "<p>do you have 0 = 0?</p>",
        "id": 237079480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986899
    },
    {
        "content": "<p>no</p>",
        "id": 237079489,
        "sender_full_name": "Mac",
        "timestamp": 1619986905
    },
    {
        "content": "<p>That is not necessary for the semiring proofs</p>",
        "id": 237079502,
        "sender_full_name": "Mac",
        "timestamp": 1619986915
    },
    {
        "content": "<p>do you have symmetry and transitivity?</p>",
        "id": 237079543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986925
    },
    {
        "content": "<p>and 0 + 0 = 0</p>",
        "id": 237079561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986935
    },
    {
        "content": "<p>only transitivity and left euclideanness</p>",
        "id": 237079563,
        "sender_full_name": "Mac",
        "timestamp": 1619986936
    },
    {
        "content": "<p>left euclidean implies transitive and symmetric</p>",
        "id": 237079582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619986952
    },
    {
        "content": "<p>no it does not.</p>",
        "id": 237079595,
        "sender_full_name": "Mac",
        "timestamp": 1619986963
    },
    {
        "content": "<p>transitive and symmetric does imply left euclidean though</p>",
        "id": 237079610,
        "sender_full_name": "Mac",
        "timestamp": 1619986975
    },
    {
        "content": "<p>do you have x + 0 = x?</p>",
        "id": 237079662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987024
    },
    {
        "content": "<p>yes</p>",
        "id": 237079671,
        "sender_full_name": "Mac",
        "timestamp": 1619987035
    },
    {
        "content": "<p>then by left euclidean you have reflexivity</p>",
        "id": 237079717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987050
    },
    {
        "content": "<p>How?</p>",
        "id": 237079732,
        "sender_full_name": "Mac",
        "timestamp": 1619987069
    },
    {
        "content": "<p>x + 0 = x and x + 0 = x so x = x</p>",
        "id": 237079746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987078
    },
    {
        "content": "<p>left euclidean, not right euclidean</p>",
        "id": 237079755,
        "sender_full_name": "Mac",
        "timestamp": 1619987101
    },
    {
        "content": "<p>x + 0 = x and x + 0 = x so x + 0 = x + 0</p>",
        "id": 237079793,
        "sender_full_name": "Mac",
        "timestamp": 1619987124
    },
    {
        "content": "<p>Furthermore, even if I had <code>(L |- x = y) &lt;-&gt; eval x = eval y</code> that does not prove that <code>(L |- ~(x \\ne y)) &lt;-&gt; (eval x \\ne eval y)</code>, right or even <code>((L |- x = y) -&gt; False) &lt;-&gt; ((eval x = eval y) -&gt; False)</code> (because Lean is intuitionistic)?</p>",
        "id": 237080029,
        "sender_full_name": "Mac",
        "timestamp": 1619987333
    },
    {
        "content": "<p>Nat equality is decidable (also Lean is pretty classical)</p>",
        "id": 237080072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987381
    },
    {
        "content": "<p>the last one is just <code>not_congr</code> applied to the first</p>",
        "id": 237080201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237080201\">said</a>:</p>\n<blockquote>\n<p>the last one is just <code>not_congr</code> applied to the first</p>\n</blockquote>\n<p>Ah, but does it matter that (L |- x = y) is not necessarily a prop?</p>",
        "id": 237080372,
        "sender_full_name": "Mac",
        "timestamp": 1619987580
    },
    {
        "content": "<p>not really, except that <code>&lt;-&gt;</code> doesn't apply to non-props</p>",
        "id": 237080425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987612
    },
    {
        "content": "<p>just substitute <code>L |- p = q</code> with <code>nonempty (L |- p = q)</code></p>",
        "id": 237080436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987627
    },
    {
        "content": "<p>Also, now that I think about it how do you even get <code>(L |- x = y) -&gt; eval x = eval y</code></p>",
        "id": 237080514,
        "sender_full_name": "Mac",
        "timestamp": 1619987655
    },
    {
        "content": "<p>how do you get from (L |- 0 = 0) to <code>eval  0 = eval 0</code>?</p>",
        "id": 237080525,
        "sender_full_name": "Mac",
        "timestamp": 1619987672
    },
    {
        "content": "<p>That was the argument by inconsistency I mentioned</p>",
        "id": 237080526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987674
    },
    {
        "content": "<p>That one is easy, ignore the proof</p>",
        "id": 237080536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987688
    },
    {
        "content": "<p>0 = 0 is true</p>",
        "id": 237080540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987692
    },
    {
        "content": "<p>Oops, dumb me XD</p>",
        "id": 237080583,
        "sender_full_name": "Mac",
        "timestamp": 1619987740
    },
    {
        "content": "<p>how do you get from (L |- S 0 = 1) to eval  (S 0) = eval 1</p>",
        "id": 237080597,
        "sender_full_name": "Mac",
        "timestamp": 1619987760
    },
    {
        "content": "<p>That one is also true</p>",
        "id": 237080641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987770
    },
    {
        "content": "<p>it's true by rfl</p>",
        "id": 237080646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987777
    },
    {
        "content": "<p>How so?</p>",
        "id": 237080673,
        "sender_full_name": "Mac",
        "timestamp": 1619987787
    },
    {
        "content": "<p>This is where eric's observation that eval is not injective comes in</p>",
        "id": 237080685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987801
    },
    {
        "content": "<p>Remember that 0, S, and 1 are members of some arbitrary type P</p>",
        "id": 237080691,
        "sender_full_name": "Mac",
        "timestamp": 1619987812
    },
    {
        "content": "<p>sure, you gave an example of <code>eval</code> for one possible P</p>",
        "id": 237080714,
        "sender_full_name": "Mac",
        "timestamp": 1619987836
    },
    {
        "content": "<p>But you would need an eval instance of every possible type P</p>",
        "id": 237080725,
        "sender_full_name": "Mac",
        "timestamp": 1619987852
    },
    {
        "content": "<p>that has 0, S, and 1 instances</p>",
        "id": 237080740,
        "sender_full_name": "Mac",
        "timestamp": 1619987871
    },
    {
        "content": "<p>In that generality it requires more assumptions: specifically, it only holds for terms built from 0, S, 1, and only if 0, S, 1 are distinct</p>",
        "id": 237080818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987910
    },
    {
        "content": "<p>what \"it\" requires more assumptions?</p>",
        "id": 237080843,
        "sender_full_name": "Mac",
        "timestamp": 1619987943
    },
    {
        "content": "<p><code>eval</code>?</p>",
        "id": 237080865,
        "sender_full_name": "Mac",
        "timestamp": 1619987964
    },
    {
        "content": "<p>In order to define <code>eval</code>, you need those assumptions</p>",
        "id": 237080873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987970
    },
    {
        "content": "<p>and the theorem about eval that I mentioned only holds on those terms</p>",
        "id": 237080882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619987985
    },
    {
        "content": "<p>So, i.e. the point of L</p>",
        "id": 237080933,
        "sender_full_name": "Mac",
        "timestamp": 1619988007
    },
    {
        "content": "<p>If there are weird extra terms then you don't know whether they are equal or not</p>",
        "id": 237080951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988024
    },
    {
        "content": "<p>unless there is an induction principle</p>",
        "id": 237080964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988036
    },
    {
        "content": "<p>exactly</p>",
        "id": 237080968,
        "sender_full_name": "Mac",
        "timestamp": 1619988037
    },
    {
        "content": "<p>the induction principle lets you prove that there are no weird extra terms</p>",
        "id": 237080987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988062
    },
    {
        "content": "<p>So now eval has become almost as complex as L (and maybe more so)?</p>",
        "id": 237081030,
        "sender_full_name": "Mac",
        "timestamp": 1619988122
    },
    {
        "content": "<p>I again am missing your point.</p>",
        "id": 237081081,
        "sender_full_name": "Mac",
        "timestamp": 1619988140
    },
    {
        "content": "<p>eval is exactly as complex as L, it's a function defined on L</p>",
        "id": 237081125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988199
    },
    {
        "content": "<p>so what was the point of this whole endeavor?</p>",
        "id": 237081145,
        "sender_full_name": "Mac",
        "timestamp": 1619988230
    },
    {
        "content": "<p>if the theory is decidable then it is nice to have a decision procedure</p>",
        "id": 237081206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988257
    },
    {
        "content": "<p><code>eval x = eval y</code> is a decision procedure</p>",
        "id": 237081218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988282
    },
    {
        "content": "<p>But as we have already pointed out my fragment of PA is not decidable</p>",
        "id": 237081221,
        "sender_full_name": "Mac",
        "timestamp": 1619988285
    },
    {
        "content": "<p>I'm not sure that's true</p>",
        "id": 237081240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988305
    },
    {
        "content": "<p>for one, it lacks reflexivity</p>",
        "id": 237081245,
        "sender_full_name": "Mac",
        "timestamp": 1619988308
    },
    {
        "content": "<p>your fragment is perhaps not as simple as I said but that doesn't mean it's not decidable</p>",
        "id": 237081263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988326
    },
    {
        "content": "<p>I would actually be surprised if it's not decidable</p>",
        "id": 237081300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988362
    },
    {
        "content": "<p>I mean I can't decide if (L |- 0 = 0) is true or false, that makes L undecidable, right?</p>",
        "id": 237081316,
        "sender_full_name": "Mac",
        "timestamp": 1619988363
    },
    {
        "content": "<p>(I'm not entirely sure this is true, but) assuming that there is no hidden extra way to prove 0 = 0, then <code>L |- 0 = 0</code> is false and hence decidable</p>",
        "id": 237081404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988434
    },
    {
        "content": "<p>the goal here is to decide whether <code>L |- x = y</code> is true or false given terms x, y</p>",
        "id": 237081433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988457
    },
    {
        "content": "<p>I also can not prove <code>(L |- 0 = 0) -&gt; False</code> either.</p>",
        "id": 237081440,
        "sender_full_name": "Mac",
        "timestamp": 1619988467
    },
    {
        "content": "<p>After all, Lean is not complete, right?</p>",
        "id": 237081470,
        "sender_full_name": "Mac",
        "timestamp": 1619988483
    },
    {
        "content": "<p>I would be extremely surprised if it is actually independent of lean</p>",
        "id": 237081504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988500
    },
    {
        "content": "<p>How would I prove that?</p>",
        "id": 237081524,
        "sender_full_name": "Mac",
        "timestamp": 1619988542
    },
    {
        "content": "<p>None of the axioms provide me with a way to get false. I have no knowledge of the structure of L or P to do a proof by cases.</p>",
        "id": 237081555,
        "sender_full_name": "Mac",
        "timestamp": 1619988576
    },
    {
        "content": "<p>You do have to assume that there are no additional axioms beyond the ones enumerated</p>",
        "id": 237081571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988592
    },
    {
        "content": "<p>So I would assume that <code>(L |- 0 = 0)</code> and <code>(L |- 0 = 0) -&gt; False</code> are both not provable from the PA fragment</p>",
        "id": 237081619,
        "sender_full_name": "Mac",
        "timestamp": 1619988605
    },
    {
        "content": "<p>I am saying that the PA fragment does not prove 0 = 0</p>",
        "id": 237081666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237081571\">said</a>:</p>\n<blockquote>\n<p>You do have to assume that there are no additional axioms beyond the ones enumerated</p>\n</blockquote>\n<p>Ah, well then yes, <code>(L |- 0 = 0) -&gt; False</code> is trivially provable.</p>",
        "id": 237081670,
        "sender_full_name": "Mac",
        "timestamp": 1619988657
    },
    {
        "content": "<p>Not trivially, I think</p>",
        "id": 237081676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988668
    },
    {
        "content": "<p>By trivially. I meant under the current assumption that (L |- 0 = 0) is not an entailment of the fragment</p>",
        "id": 237081708,
        "sender_full_name": "Mac",
        "timestamp": 1619988715
    },
    {
        "content": "<p>Proving it might not be so fun.</p>",
        "id": 237081756,
        "sender_full_name": "Mac",
        "timestamp": 1619988730
    },
    {
        "content": "<p>So the thing that is being proven in lean is really <code>not ((L : Logic) -&gt; (assumptions) -&gt; (L |- 0 = 0))</code></p>",
        "id": 237081840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988820
    },
    {
        "content": "<p>Logic would have to a minimal representation of assumptions to show that though.</p>",
        "id": 237081946,
        "sender_full_name": "Mac",
        "timestamp": 1619988922
    },
    {
        "content": "<p>and the proof is that if you take L to be the minimal logic satisfying the assumptions, then you can disprove L |- 0 = 0</p>",
        "id": 237081961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988940
    },
    {
        "content": "<p>i.e. you would also need an hypothesis stating that.</p>",
        "id": 237081968,
        "sender_full_name": "Mac",
        "timestamp": 1619988945
    },
    {
        "content": "<p>so therefore it is not the case that every logic satisfying the assumptions has L |- 0 = 0</p>",
        "id": 237081998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237081961\">said</a>:</p>\n<blockquote>\n<p>and the proof is that if you take L to be the minimal logic satisfying the assumptions, then you can disprove L |- 0 = 0</p>\n</blockquote>\n<p>correct</p>",
        "id": 237082003,
        "sender_full_name": "Mac",
        "timestamp": 1619988965
    },
    {
        "content": "<p>you don't need minimality to be part of the theorem statement</p>",
        "id": 237082027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619988983
    },
    {
        "content": "<p>So this maybe: <code>exists (L : Logic) =&gt; not ((assumptions) -&gt; (L |- 0 = 0))</code>?</p>",
        "id": 237082082,
        "sender_full_name": "Mac",
        "timestamp": 1619989054
    },
    {
        "content": "<p>yes, that's equivalent</p>",
        "id": 237082089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619989062
    },
    {
        "content": "<p>Do you mind if I relocate this conversation to <a class=\"stream\" data-stream-id=\"236446\" href=\"/#narrow/stream/236446-Type-theory\">#Type theory</a> ? It's not a perfect fit but I feel like this has gotten somewhat off topic for the lean 4 stream</p>",
        "id": 237082199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619989199
    },
    {
        "content": "<p>sure feel free</p>",
        "id": 237082412,
        "sender_full_name": "Mac",
        "timestamp": 1619989242
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/associativity.20of.20.02klzzwxh.3A0000.03\">#lean4 &gt; associativity of <code>↔</code></a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>",
        "id": 237082710,
        "sender_full_name": "Notification Bot",
        "timestamp": 1619989322
    },
    {
        "content": "<p>though I might be more inclined to put it in the more general <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> instead (since that is one of the default streams)</p>",
        "id": 237083461,
        "sender_full_name": "Mac",
        "timestamp": 1619989514
    },
    {
        "content": "<p>well I'm also concerned about putting hundreds of messages in everyone's inbox for a conversation that is mostly just us</p>",
        "id": 237083699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619989603
    },
    {
        "content": "<p>I don't think there are too many folks who do mathematical logic around here</p>",
        "id": 237083831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619989662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237083831\">said</a>:</p>\n<blockquote>\n<p>I don't think there are too many folks who do mathematical logic around here</p>\n</blockquote>\n<p>That surprises me.</p>",
        "id": 237083999,
        "sender_full_name": "Mac",
        "timestamp": 1619989720
    },
    {
        "content": "<p>mathlib doesn't really have any definition of a logic; the closest analogue is the definition of logic in flypitch (which was needed in order to state and prove the independence of CH)</p>",
        "id": 237084201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619989797
    },
    {
        "content": "<p>There are a few individual projects that have defined logics, but they are mostly one-off projects. I think <span class=\"user-mention silent\" data-user-id=\"110187\">Minchao Wu</span> has a definition of a modal logic, as well as <span class=\"user-mention silent\" data-user-id=\"198364\">Paula Neeley</span>; <span class=\"user-mention silent\" data-user-id=\"121542\">Alexandre Rademaker</span> has some ontology thing that I don't fully understand; and there have been a few definitions of lambda calculus (with or without types) in this stream</p>",
        "id": 237084714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619989981
    },
    {
        "content": "<p>By the way, check out <a href=\"#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/202076965\">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/202076965</a> ; <code>and_to_imp</code> is the implication introduction rule I mentioned, although in this version <code>G</code> is just a single formula connected by conjunctions instead of a list</p>",
        "id": 237085102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619990124
    },
    {
        "content": "<p>I still think my conditional proof rule is fine for the general case (and it mirrors the elimination rule, which is nice). It works fine in complete logics (such as propositional and first-order), so I will probably leave it as is. May introduce a more restrained version later. I would also argue that the restrained version is just relevant logic implication then (and, as such, I may touch on it if I end up spending some time formalizing that).</p>",
        "id": 237086570,
        "sender_full_name": "Mac",
        "timestamp": 1619990783
    },
    {
        "content": "<p>I also don't generally end up using the propositional logic rules in my proofs because I can generally leave that to the metalogic (as I did in my PA fragment).</p>",
        "id": 237086716,
        "sender_full_name": "Mac",
        "timestamp": 1619990959
    },
    {
        "content": "<p>i.e.<code> PProd (L |- p) (L |- q)</code> is just as good as <code>(L |- p /\\ q)</code> and (outside of classical logic) <code>PSum (L |- p) (L |- q)</code> is often just as good as <code>L |- p \\/ q</code></p>",
        "id": 237086868,
        "sender_full_name": "Mac",
        "timestamp": 1619991107
    },
    {
        "content": "<blockquote>\n<p>I still think my conditional proof rule is fine for the general case (and it mirrors the elimination rule, which is nice). It works fine in complete logics (such as propositional and first-order), so I will probably leave it as is.</p>\n</blockquote>\n<p>The fact that it's not well founded should make it very suspicious as a proof rule. It's a constraint on the provability judgment that is not satisfiable like a standard axiom rule</p>",
        "id": 237086940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991165
    },
    {
        "content": "<p>What is wrong with it not being well-founded?</p>",
        "id": 237087005,
        "sender_full_name": "Mac",
        "timestamp": 1619991217
    },
    {
        "content": "<p>it sort of fails the concept that a theory is inductively generated by axioms and rules of inference</p>",
        "id": 237087095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991267
    },
    {
        "content": "<p>I wonder what you would think of this variation of the natural induction rule then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Sort</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 237087102,
        "sender_full_name": "Mac",
        "timestamp": 1619991281
    },
    {
        "content": "<p>Oh, I can definitely use that to prove nonsense</p>",
        "id": 237087209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991366
    },
    {
        "content": "<p>That axiom implies that all terms are syntactically of the form <code>S S S ... S 0</code>, so <code>1</code> doesn't exist</p>",
        "id": 237087232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991404
    },
    {
        "content": "<p>I'd love to see it. I figured as much, but I have yet to see any pitfalls. Maybe I'm just not that creative.</p>",
        "id": 237087236,
        "sender_full_name": "Mac",
        "timestamp": 1619991408
    },
    {
        "content": "<p>well, I guess it's fine if the term language isn't really a term language and is really <code>Nat</code></p>",
        "id": 237087261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237087232\">said</a>:</p>\n<blockquote>\n<p>That axiom implies that all terms are syntactically of the form <code>S S S ... S 0</code>, so <code>1</code> doesn't exist</p>\n</blockquote>\n<p>How does it imply that?</p>",
        "id": 237087268,
        "sender_full_name": "Mac",
        "timestamp": 1619991452
    },
    {
        "content": "<p>It does have the <code>(L |- nat n)</code> constraint for <code>n</code></p>",
        "id": 237087284,
        "sender_full_name": "Mac",
        "timestamp": 1619991472
    },
    {
        "content": "<p>you take <code>f</code> to be the assertion that <code>n = S^i 0</code> for some <code>i : Nat</code></p>",
        "id": 237087323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237087284\">said</a>:</p>\n<blockquote>\n<p>It does have the <code>(L |- nat n)</code> constraint for <code>n</code></p>\n</blockquote>\n<p>That's true, I really only mean that <code>L |- nat n</code> implies <code>n = S^i 0</code> for some i</p>",
        "id": 237087397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991577
    },
    {
        "content": "<p>Isn't that generally true?</p>",
        "id": 237087407,
        "sender_full_name": "Mac",
        "timestamp": 1619991599
    },
    {
        "content": "<p><code>=</code> here is lean's <code>Eq</code>, i.e. syntactic equality</p>",
        "id": 237087460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991615
    },
    {
        "content": "<p>If <code>T</code> is a term language containing things like <code>0 + 0</code> or <code>1</code> then that would usually not be true</p>",
        "id": 237087490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991639
    },
    {
        "content": "<p>in particular you can probably use this to prove reflexivity</p>",
        "id": 237087504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619991665
    },
    {
        "content": "<p>Also how would you show <code>n = S^i 0</code>?</p>",
        "id": 237087514,
        "sender_full_name": "Mac",
        "timestamp": 1619991673
    },
    {
        "content": "<p>ah I see.</p>",
        "id": 237087592,
        "sender_full_name": "Mac",
        "timestamp": 1619991744
    },
    {
        "content": "<p>I don't actually use this prove the Peano fragment though, luckily.</p>",
        "id": 237087632,
        "sender_full_name": "Mac",
        "timestamp": 1619991802
    },
    {
        "content": "<p>I use this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n        <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n        <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">c</span><span class=\"o\">))))</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 237087637,
        "sender_full_name": "Mac",
        "timestamp": 1619991822
    },
    {
        "content": "<p>and this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">c</span><span class=\"o\">))))</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 237087705,
        "sender_full_name": "Mac",
        "timestamp": 1619991871
    },
    {
        "content": "<p>Also, considering how quickly you poked a hole in that natural induction rule, I'm curious as to whether you think there is also a problem with this disjunction elimination rule:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span> <span class=\"bp\">\\/</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">r</span>\n</code></pre></div>",
        "id": 237087876,
        "sender_full_name": "Mac",
        "timestamp": 1619992045
    },
    {
        "content": "<p>That one also implies that the theory is complete, if it satisfies excluded middle</p>",
        "id": 237087942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992086
    },
    {
        "content": "<p>I guess a better question is, is it any worse than:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span> <span class=\"bp\">\\/</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 237088011,
        "sender_full_name": "Mac",
        "timestamp": 1619992193
    },
    {
        "content": "<p>Since, yeah, I keep the metalogic <code>(L |- p) -&gt; (L |- q)</code> as entailment throughout.</p>",
        "id": 237088097,
        "sender_full_name": "Mac",
        "timestamp": 1619992241
    },
    {
        "content": "<p>Which I still think is reasonable.</p>",
        "id": 237088126,
        "sender_full_name": "Mac",
        "timestamp": 1619992271
    },
    {
        "content": "<p>Why not just have axioms like <code>(L |- p \\/ q) &lt;-&gt; (L |- p) \\/ (L |- q)</code>, <code>(L |- p -&gt; q) &lt;-&gt; ((L |- p) -&gt; (L |- q))</code> and so on, if you want metalogical connectives</p>",
        "id": 237088149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992307
    },
    {
        "content": "<p>Because (L |- p) is not a prop and <code>&lt;-&gt;</code> is not function.</p>",
        "id": 237088215,
        "sender_full_name": "Mac",
        "timestamp": 1619992369
    },
    {
        "content": "<p>insert nonempty everywhere</p>",
        "id": 237088224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992380
    },
    {
        "content": "<p>The point is to reduce complexity, not increase it. XD</p>",
        "id": 237088241,
        "sender_full_name": "Mac",
        "timestamp": 1619992408
    },
    {
        "content": "<p>I'm not sure why <code>|-</code> isn't a prop though</p>",
        "id": 237088250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992427
    },
    {
        "content": "<p>Also, a proof my depend on only one direction of the rule.</p>",
        "id": 237088255,
        "sender_full_name": "Mac",
        "timestamp": 1619992432
    },
    {
        "content": "<p><code>|-</code> is not a prop so that a judgment can potential be an inductive type which one can do proof by cases on.</p>",
        "id": 237088319,
        "sender_full_name": "Mac",
        "timestamp": 1619992486
    },
    {
        "content": "<p>it can still be an inductive prop</p>",
        "id": 237088326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992498
    },
    {
        "content": "<p>you can do proof by cases on an inductive prop</p>",
        "id": 237088354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992519
    },
    {
        "content": "<p>And for cases where I want type safety from Props.</p>",
        "id": 237088374,
        "sender_full_name": "Mac",
        "timestamp": 1619992548
    },
    {
        "content": "<p>type safety?</p>",
        "id": 237088416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237088354\">said</a>:</p>\n<blockquote>\n<p>you can do proof by cases on an inductive prop</p>\n</blockquote>\n<p>Doesn't that violate proof irrelevance?</p>",
        "id": 237088450,
        "sender_full_name": "Mac",
        "timestamp": 1619992621
    },
    {
        "content": "<p>Proof by cases to prove a proposition</p>",
        "id": 237088470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992659
    },
    {
        "content": "<p>I guess my point is: I am trying to avoid proof irrelevance.</p>",
        "id": 237088477,
        "sender_full_name": "Mac",
        "timestamp": 1619992680
    },
    {
        "content": "<p>you don't need to use proof irrelevance</p>",
        "id": 237088516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992693
    },
    {
        "content": "<p>but AFAICT your theory is not really changed at all by putting everything in prop</p>",
        "id": 237088558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992751
    },
    {
        "content": "<p>If <code>(L |- p) : Prop</code> then for all <code>p1 p2 : L |- p </code>, <code>p1 = p2</code> by proof irrelevance, correct?</p>",
        "id": 237088561,
        "sender_full_name": "Mac",
        "timestamp": 1619992758
    },
    {
        "content": "<p>yes</p>",
        "id": 237088566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992765
    },
    {
        "content": "<p>That's what I don't want</p>",
        "id": 237088574,
        "sender_full_name": "Mac",
        "timestamp": 1619992778
    },
    {
        "content": "<p>You can just have <code>Derivation L p</code> and define <code>L |- p = nonempty (Derivation L p)</code></p>",
        "id": 237088604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992804
    },
    {
        "content": "<p>which matches conventional usage better anyway</p>",
        "id": 237088665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992822
    },
    {
        "content": "<p>but <code>L |- p</code> is suppose to be the proof type not a proposition that there is a proof.</p>",
        "id": 237088696,
        "sender_full_name": "Mac",
        "timestamp": 1619992853
    },
    {
        "content": "<p>so <code>L |- p</code> means <code>p</code> is provable and <code>Derivation L p</code> is the type of proofs of <code>p</code></p>",
        "id": 237088700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992855
    },
    {
        "content": "<p>By <code>(L |- p) -&gt;  (L |- q)</code> I mean given a proof in L of <code>p</code> I can construct a proof in L of <code>q</code> which is the result of this function.</p>",
        "id": 237088746,
        "sender_full_name": "Mac",
        "timestamp": 1619992910
    },
    {
        "content": "<p>lean is classical so that doesn't really mean as much as you want it to</p>",
        "id": 237088804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992941
    },
    {
        "content": "<p>Lean is not classical</p>",
        "id": 237088811,
        "sender_full_name": "Mac",
        "timestamp": 1619992955
    },
    {
        "content": "<p>sure it is, <code>Classical.em</code> is a thing</p>",
        "id": 237088820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992965
    },
    {
        "content": "<p>yes, but that adds axioms to proof</p>",
        "id": 237088848,
        "sender_full_name": "Mac",
        "timestamp": 1619992984
    },
    {
        "content": "<p>and the core tactics don't particularly shy away from it</p>",
        "id": 237088853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619992986
    },
    {
        "content": "<p>Hence why I am avoiding the core</p>",
        "id": 237088878,
        "sender_full_name": "Mac",
        "timestamp": 1619993000
    },
    {
        "content": "<p>If you are working in an intuitionistic metatheory then things are different, but I think lean isn't the best choice for that</p>",
        "id": 237088960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993076
    },
    {
        "content": "<p>Why not? And what do you think would be a better place?</p>",
        "id": 237089008,
        "sender_full_name": "Mac",
        "timestamp": 1619993127
    },
    {
        "content": "<p>I'm mostly assuming that you are comfortable with assuming classical logic and countably many inaccessible cardinals (in the metatheory) because lean is kind of hostile to not assuming that</p>",
        "id": 237089036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993152
    },
    {
        "content": "<p>Also I use Lean primarily for its metaprogramming power, not its logical base.</p>",
        "id": 237089038,
        "sender_full_name": "Mac",
        "timestamp": 1619993158
    },
    {
        "content": "<p>You can restrict the object logic if you want to, but you have to be careful not to let the excessively strong metalogic bleed into the object logic</p>",
        "id": 237089136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237089136\">said</a>:</p>\n<blockquote>\n<p>You can restrict the object logic if you want to, but you have to be careful not to let the excessively strong metalogic bleed into the object logic</p>\n</blockquote>\n<p>Very true.</p>",
        "id": 237089158,
        "sender_full_name": "Mac",
        "timestamp": 1619993281
    },
    {
        "content": "<p>which means things like <code>(L |- p) -&gt; (L |- q)</code> are problematic</p>",
        "id": 237089198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993288
    },
    {
        "content": "<p>because that's Lean's function space, not the object logic's</p>",
        "id": 237089218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993310
    },
    {
        "content": "<p>who knows what crazy things are in there</p>",
        "id": 237089228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993328
    },
    {
        "content": "<p>True, I understand that. I am using it mostly for ease of use.</p>",
        "id": 237089379,
        "sender_full_name": "Mac",
        "timestamp": 1619993444
    },
    {
        "content": "<p>Otherwise I would have to create some alternative syntax to do proofs in, which I am not quite ready to do yet.</p>",
        "id": 237089399,
        "sender_full_name": "Mac",
        "timestamp": 1619993481
    },
    {
        "content": "<p>have you considered using a <a href=\"https://en.wikipedia.org/wiki/Hilbert_system\">hilbert style axiomatization</a>? That avoids the need for a context in the provability judgment</p>",
        "id": 237089409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993514
    },
    {
        "content": "<p>One of the key parts of logics in my metalogic is that they are initially devoid of both inference rules and syntaxes. Rules and syntax are part of the hypotheses of proofs.</p>",
        "id": 237089560,
        "sender_full_name": "Mac",
        "timestamp": 1619993649
    },
    {
        "content": "<p>I mean as hypotheses</p>",
        "id": 237089574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993675
    },
    {
        "content": "<p>that is, you can assume <code>L |- p -&gt; p</code> and <code>L |- (p -&gt; (q -&gt; r)) -&gt; (p -&gt; q) -&gt; p -&gt; r</code> and such</p>",
        "id": 237089635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993737
    },
    {
        "content": "<p>I think it would be easier to bundle them into sets though</p>",
        "id": 237089692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993770
    },
    {
        "content": "<p>Yes, but most proofs ideally operate in heavily constrained logics (as my Peano proofs did).  They don't generally even have any propositional logic at all.</p>",
        "id": 237089693,
        "sender_full_name": "Mac",
        "timestamp": 1619993772
    },
    {
        "content": "<p>So the goal is not to minimize the axiomization (but in many cases, to maximize it).</p>",
        "id": 237089721,
        "sender_full_name": "Mac",
        "timestamp": 1619993826
    },
    {
        "content": "<p>I've heard of an axiomatization of primitive recursive arithmetic that doesn't use any logical connectives, only inference rules and <code>=</code></p>",
        "id": 237089730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993851
    },
    {
        "content": "<p>oh, it's on wiki: <a href=\"https://en.wikipedia.org/wiki/Primitive_recursive_arithmetic#Logic-free_calculus\">https://en.wikipedia.org/wiki/Primitive_recursive_arithmetic#Logic-free_calculus</a></p>",
        "id": 237089802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619993915
    },
    {
        "content": "<p>I believe that if I wanted to better constrain Lean from bleeding into my proofs, I would have construct a restricted logic within Lean and then construct my metalogic system within that restricted logic.</p>",
        "id": 237089844,
        "sender_full_name": "Mac",
        "timestamp": 1619993965
    },
    {
        "content": "<p>I am not really sure I want to do that yet.</p>",
        "id": 237089866,
        "sender_full_name": "Mac",
        "timestamp": 1619993989
    },
    {
        "content": "<p>It kind of sounds like you want LF</p>",
        "id": 237090005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619994091
    },
    {
        "content": "<p>Or possibly MM0, although I'm pretty scared to suggest my language to anyone. But it was designed for use cases roughly like this</p>",
        "id": 237090122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619994234
    },
    {
        "content": "<p>What kind of automation are you using from lean 4?</p>",
        "id": 237090306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619994403
    },
    {
        "content": "<p>My big draw to Lean is its metaprogramming power (namely its customizable syntax).</p>",
        "id": 237090414,
        "sender_full_name": "Mac",
        "timestamp": 1619994539
    },
    {
        "content": "<p>Is it just notations like <code>L |- p</code> and <code>x = y</code>? Because that's not hard to find</p>",
        "id": 237090521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619994633
    },
    {
        "content": "<p>would lean 3 satisfy your notational needs?</p>",
        "id": 237090541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619994652
    },
    {
        "content": "<p>Also things like <code>forall</code> and <code>exists</code>, but yeah, for this project its probably not that much.</p>",
        "id": 237090584,
        "sender_full_name": "Mac",
        "timestamp": 1619994723
    },
    {
        "content": "<p>Lean 3's problem is that it has to many reserved notations (which tends to be a problem in a lot of languages).</p>",
        "id": 237090755,
        "sender_full_name": "Mac",
        "timestamp": 1619994847
    },
    {
        "content": "<p>Though, yeah, initially started in Lean 3 before moving to Lean 4, so I don't think it'd be impossible.</p>",
        "id": 237090801,
        "sender_full_name": "Mac",
        "timestamp": 1619994901
    },
    {
        "content": "<p>Though I do value the easy of use of Lean 4 (and the syntax highlighting of custom notation).</p>",
        "id": 237090834,
        "sender_full_name": "Mac",
        "timestamp": 1619994933
    },
    {
        "content": "<p>Interesting. You might actually like MM0 then, it is kind of like lean but you define the entire theory yourself; generally it's some kind of FOL but you get to pick all the axioms, notations and so on</p>",
        "id": 237090852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619994958
    },
    {
        "content": "<p>You really should get some github syntax highlighting for it :)</p>",
        "id": 237090918,
        "sender_full_name": "Mac",
        "timestamp": 1619995003
    },
    {
        "content": "<p>You need to have X number of users before github will care about you</p>",
        "id": 237090929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995023
    },
    {
        "content": "<p>I checked</p>",
        "id": 237090939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995030
    },
    {
        "content": "<p>it would be great if they had repo-specific highlighting but I guess that's some kind of security concern</p>",
        "id": 237090958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995071
    },
    {
        "content": "<p>also, what is with all the <code>$</code></p>",
        "id": 237091022,
        "sender_full_name": "Mac",
        "timestamp": 1619995136
    },
    {
        "content": "<p>just pretend it's latex</p>",
        "id": 237091033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995156
    },
    {
        "content": "<p>it is to prevent weird mathematical notation from corrupting the \"outer\" syntax</p>",
        "id": 237091043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995178
    },
    {
        "content": "<p>inside the <code>$</code> you can have whatever you like</p>",
        "id": 237091052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995196
    },
    {
        "content": "<p>why?</p>",
        "id": 237091053,
        "sender_full_name": "Mac",
        "timestamp": 1619995196
    },
    {
        "content": "<p>why not just use braces for definitions then?</p>",
        "id": 237091125,
        "sender_full_name": "Mac",
        "timestamp": 1619995230
    },
    {
        "content": "<p>I don't follow</p>",
        "id": 237091138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995245
    },
    {
        "content": "<p>i.e. <code>{ ... }</code> instead of <code>= $ .. $</code> (or <code>: $ ... $</code></p>",
        "id": 237091148,
        "sender_full_name": "Mac",
        "timestamp": 1619995261
    },
    {
        "content": "<p>The <code>$</code> delimit user-defined mathematical notation sections</p>",
        "id": 237091169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995307
    },
    {
        "content": "<p>It could be <code>{ ... }</code> but then that would limit the use of <code>{ ... }</code> inside mathematical notation</p>",
        "id": 237091230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995344
    },
    {
        "content": "<p>yes but in <a href=\"https://github.com/digama0/mm0/blob/master/examples/x86.mm0\">https://github.com/digama0/mm0/blob/master/examples/x86.mm0</a>, virtually every definition is within <code>$</code>s</p>",
        "id": 237091238,
        "sender_full_name": "Mac",
        "timestamp": 1619995353
    },
    {
        "content": "<p>yes, they are mandatory</p>",
        "id": 237091244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995370
    },
    {
        "content": "<p>Inside the <code>$</code> you can use literally any character, keyword, whatever</p>",
        "id": 237091276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995413
    },
    {
        "content": "<p>my point is why not instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">):</span> <span class=\"n\">nat</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">e.</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">$;</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bitT</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">):</span> <span class=\"bp\">$</span> <span class=\"n\">bool</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">$;</span>\n</code></pre></div>\n<p>having:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">):</span> <span class=\"n\">nat</span> <span class=\"o\">{</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">e.</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bitT</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">):</span> <span class=\"n\">bool</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 237091284,
        "sender_full_name": "Mac",
        "timestamp": 1619995437
    },
    {
        "content": "<p>were the colon consume math notation until the end-of-line</p>",
        "id": 237091339,
        "sender_full_name": "Mac",
        "timestamp": 1619995465
    },
    {
        "content": "<p>because newlines are permitted in math strings</p>",
        "id": 237091355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995484
    },
    {
        "content": "<p>in which case you use braces instead</p>",
        "id": 237091362,
        "sender_full_name": "Mac",
        "timestamp": 1619995500
    },
    {
        "content": "<p>and semicolons</p>",
        "id": 237091364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995501
    },
    {
        "content": "<p>and braces</p>",
        "id": 237091397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995528
    },
    {
        "content": "<p>and unmatched braces</p>",
        "id": 237091401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995535
    },
    {
        "content": "<p>arguably that's too permissive</p>",
        "id": 237091417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995560
    },
    {
        "content": "<p>okay, ignore the colon sugar, here is also a possibility:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">):</span> <span class=\"n\">nat</span> <span class=\"o\">{</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">e.</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bitT</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">{</span>  <span class=\"n\">bool</span> <span class=\"o\">(</span><span class=\"n\">bit</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 237091462,
        "sender_full_name": "Mac",
        "timestamp": 1619995574
    },
    {
        "content": "<p>Yeah the unmatched braces seem a bit of a stretch.</p>",
        "id": 237091488,
        "sender_full_name": "Mac",
        "timestamp": 1619995599
    },
    {
        "content": "<p>However, why not run a custom parser?</p>",
        "id": 237091493,
        "sender_full_name": "Mac",
        "timestamp": 1619995610
    },
    {
        "content": "<p>like Lean 4 does?</p>",
        "id": 237091498,
        "sender_full_name": "Mac",
        "timestamp": 1619995620
    },
    {
        "content": "<p>Because MM0 is designed to be simple to parse</p>",
        "id": 237091511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995633
    },
    {
        "content": "<p>lean 4 is... not</p>",
        "id": 237091515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237091515\">said</a>:</p>\n<blockquote>\n<p>lean 4 is... not</p>\n</blockquote>\n<p>In one manner of speaking yes, In another manner of speaking, no</p>",
        "id": 237091560,
        "sender_full_name": "Mac",
        "timestamp": 1619995673
    },
    {
        "content": "<p>Lean actually has a pretty simple parsing algorithm (outside of anti-quotes)</p>",
        "id": 237091621,
        "sender_full_name": "Mac",
        "timestamp": 1619995701
    },
    {
        "content": "<p>I'm not sure how to interpret that to make it true. Lean has an extremely extensible parsing system, which has been extended already in the core quite a bit to build the core syntax</p>",
        "id": 237091661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995769
    },
    {
        "content": "<p>As a person who has long been toying with a writing a metaprogramming language with the parsing flexibility of Lean (and beyond), I am actually amazed at how they were able to write such a flexible parser with such simple rules.</p>",
        "id": 237091668,
        "sender_full_name": "Mac",
        "timestamp": 1619995781
    },
    {
        "content": "<p>Yes but the core is surprisingly simple for being so flexible.</p>",
        "id": 237091755,
        "sender_full_name": "Mac",
        "timestamp": 1619995838
    },
    {
        "content": "<p>sure, but in order to actually parse things you need all the extensions too</p>",
        "id": 237091772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995867
    },
    {
        "content": "<p>Yes, but the extensions are written in Lean, so that is less of a problem.</p>",
        "id": 237091787,
        "sender_full_name": "Mac",
        "timestamp": 1619995891
    },
    {
        "content": "<p>So as long as you can parse the basics, you can parse the more complex cases by interpreting the basics.</p>",
        "id": 237091806,
        "sender_full_name": "Mac",
        "timestamp": 1619995917
    },
    {
        "content": "<p>It has to be staged though, notations are used before they are defined</p>",
        "id": 237091881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619995969
    },
    {
        "content": "<p>true</p>",
        "id": 237091906,
        "sender_full_name": "Mac",
        "timestamp": 1619995994
    },
    {
        "content": "<p>I went for more the opposite approach, what's the simplest extensible parser that can be used to define not terrible looking formal maths</p>",
        "id": 237091980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996062
    },
    {
        "content": "<p>and can be specified in a page or two</p>",
        "id": 237092001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996089
    },
    {
        "content": "<p>which I applaud, as the result looks quite good</p>",
        "id": 237092006,
        "sender_full_name": "Mac",
        "timestamp": 1619996101
    },
    {
        "content": "<p>the dollar delimiters are so that the outer syntax parser can be a fully static parser like what yacc gives you</p>",
        "id": 237092039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996130
    },
    {
        "content": "<p>although it doesn't have to be implemented that way</p>",
        "id": 237092048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996139
    },
    {
        "content": "<p>However, I must admit it does offend my sensibilities somewhat.</p>",
        "id": 237092063,
        "sender_full_name": "Mac",
        "timestamp": 1619996158
    },
    {
        "content": "<p>I suspect that means the syntax highlighting leaves much to be desired.</p>",
        "id": 237092123,
        "sender_full_name": "Mac",
        "timestamp": 1619996181
    },
    {
        "content": "<p>I'll find a nice subdued color for the syntax highlighter :)</p>",
        "id": 237092130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996190
    },
    {
        "content": "<p>there is an online tutorial video which shows the syntax highlighting</p>",
        "id": 237092160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996232
    },
    {
        "content": "<p>but the dollars are just white</p>",
        "id": 237092177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996268
    },
    {
        "content": "<p>How does it highlight the bits of notation within the dollars?</p>",
        "id": 237092261,
        "sender_full_name": "Mac",
        "timestamp": 1619996350
    },
    {
        "content": "<p>right now it doesn't. The regex highlighter isn't smart enough to know the user notation</p>",
        "id": 237092279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996380
    },
    {
        "content": "<p>that was my point</p>",
        "id": 237092286,
        "sender_full_name": "Mac",
        "timestamp": 1619996396
    },
    {
        "content": "<p>but I am planning to add \"semantic highlighting\" messages from the server, which would allow various kinds of highlighting, although I'm not sure what to do besides highlighting the variables</p>",
        "id": 237092379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996423
    },
    {
        "content": "<p>to be fair, lean doesn't do any math highlighting either</p>",
        "id": 237092465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996496
    },
    {
        "content": "<p>One of the things love about Lean's syntax highlighting is that custom keywords (ex. <code>forall</code>) get highlighted the same as builtin keywords.</p>",
        "id": 237092514,
        "sender_full_name": "Mac",
        "timestamp": 1619996524
    },
    {
        "content": "<p>heh that's a bug</p>",
        "id": 237092538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996543
    },
    {
        "content": "<p>what makes you say that?</p>",
        "id": 237092551,
        "sender_full_name": "Mac",
        "timestamp": 1619996568
    },
    {
        "content": "<p><code>forall</code> is a lean keyword</p>",
        "id": 237092571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996576
    },
    {
        "content": "<p>I know, I was just using that as an example</p>",
        "id": 237092636,
        "sender_full_name": "Mac",
        "timestamp": 1619996599
    },
    {
        "content": "<p>As I can't quite give an common example of a custom keyword, can I?</p>",
        "id": 237092653,
        "sender_full_name": "Mac",
        "timestamp": 1619996633
    },
    {
        "content": "<p>Actually you are right, there is an actual feature along those lines. There was a bug like that in lean 3 for a while though</p>",
        "id": 237092661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996640
    },
    {
        "content": "<p>I presumed it was feature, as it isn't in <code>4.0.0-m2</code> but it is in the <code>nightly</code> so it must have been added recently.</p>",
        "id": 237092736,
        "sender_full_name": "Mac",
        "timestamp": 1619996691
    },
    {
        "content": "<p>For example the <code>obtain</code> tactic was nicely highlighted, not because the highlighter knew that <code>obtain</code> was a tactic, but because <code>obtain</code> was a keyword in lean 2 and the highlighter was never updated</p>",
        "id": 237092738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996694
    },
    {
        "content": "<p>Obviously none of this occurs on Github :(</p>",
        "id": 237092774,
        "sender_full_name": "Mac",
        "timestamp": 1619996726
    },
    {
        "content": "<p>But you are right, if you define a custom tactic in lean 4 it will get highlighted using the \"semantic highlighting\" feature</p>",
        "id": 237092794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996748
    },
    {
        "content": "<p>I love that. It makes custom notation feel natural as opposed to a wart you glued onto the system.</p>",
        "id": 237092860,
        "sender_full_name": "Mac",
        "timestamp": 1619996797
    },
    {
        "content": "<p>you can tell because it takes a little bit of extra time to get highlighted compared to the rest of the text</p>",
        "id": 237092862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996800
    },
    {
        "content": "<p>Exactly! XD</p>",
        "id": 237092892,
        "sender_full_name": "Mac",
        "timestamp": 1619996830
    },
    {
        "content": "<p>I think variable highlighting is another way to give the text a little more texture</p>",
        "id": 237092896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996837
    },
    {
        "content": "<p>I wouldn't know how to start highlighting user notations though</p>",
        "id": 237092907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619996853
    },
    {
        "content": "<p>I am said that most color schemes and highlighters have gotten rid of operator highlighting. I quite liked that.</p>",
        "id": 237092935,
        "sender_full_name": "Mac",
        "timestamp": 1619996880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237087102\">said</a>:</p>\n<blockquote>\n<p>I wonder what you would think of this variation of the natural induction rule then:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Sort</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Something I was curious about: Is there a clean way of restricting f to judgments or functions of judgments (since they are both just Sorts)?</p>",
        "id": 237093620,
        "sender_full_name": "Mac",
        "timestamp": 1619997540
    },
    {
        "content": "<p>Even with the judgment version, I think it wouldn't be sufficient, since you can still let f be <code>if \\exists i, n = S^i 0 then term.true else term.false</code> as long as the proposition language contains something true and something false</p>",
        "id": 237093776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619997678
    },
    {
        "content": "<p>but to answer your question, yes you can make an inductive type out of this</p>",
        "id": 237093905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619997822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237093905\">said</a>:</p>\n<blockquote>\n<p>but to answer your question, yes you can make an inductive type out of this</p>\n</blockquote>\n<p>Yeah, but that's a different type then.</p>",
        "id": 237093971,
        "sender_full_name": "Mac",
        "timestamp": 1619997882
    },
    {
        "content": "<p>I mean you can have a predicate on functions <code>f</code> meaning \"<code>f</code> is a judgment or function of judgments\"</p>",
        "id": 237094069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619997967
    },
    {
        "content": "<p>Now that I think about this, is the <code>exists i, n = S^i 0</code> that bad? It would expand to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">S</span><span class=\"bp\">^</span><span class=\"n\">i</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n<span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">exists</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">S</span><span class=\"bp\">^</span><span class=\"n\">i</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">exists</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">S</span><span class=\"bp\">^</span><span class=\"n\">i</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span>\n<span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">|-</span> <span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">exists</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">S</span><span class=\"bp\">^</span><span class=\"n\">i</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This is what natural induction means right: that every nat is 0 or a S of a nat?</p>",
        "id": 237094392,
        "sender_full_name": "Mac",
        "timestamp": 1619998362
    },
    {
        "content": "<p>It is certainly stronger than my current PA fragment, but it seems pretty standard for arithmetic</p>",
        "id": 237094456,
        "sender_full_name": "Mac",
        "timestamp": 1619998440
    },
    {
        "content": "<p>well, like I said, if <code>T</code> is a type of terms, such that <code>0 + 0</code> and <code>0</code> are not equal in the lean sense, then this property will fail because <code>0 + 0</code> is not of the form <code>S^i 0</code></p>",
        "id": 237094536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998473
    },
    {
        "content": "<p>take note that the assumption is not <code>L |- n = S^i 0</code> but <code>n = S^i 0</code></p>",
        "id": 237094553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998509
    },
    {
        "content": "<p>true, but that makes sense, considering this is metalogical object-nat induction rather than object logic nat induction.</p>",
        "id": 237094593,
        "sender_full_name": "Mac",
        "timestamp": 1619998551
    },
    {
        "content": "<p>Right, so this can be used to prove that the object nats are really the metalogic nats</p>",
        "id": 237094652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998583
    },
    {
        "content": "<p>makes sense.</p>",
        "id": 237094675,
        "sender_full_name": "Mac",
        "timestamp": 1619998616
    },
    {
        "content": "<p>in essence, this is a way of encoding that property.</p>",
        "id": 237094686,
        "sender_full_name": "Mac",
        "timestamp": 1619998629
    },
    {
        "content": "<p>which can then be used to prove other things like reflexivity or Con(PA)</p>",
        "id": 237094689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998631
    },
    {
        "content": "<p>I forgot, what does <code>Con(PA)</code> denoted again?</p>",
        "id": 237094708,
        "sender_full_name": "Mac",
        "timestamp": 1619998677
    },
    {
        "content": "<p>PA Is consistent</p>",
        "id": 237094745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998685
    },
    {
        "content": "<p>ah, should have guessed that.</p>",
        "id": 237094756,
        "sender_full_name": "Mac",
        "timestamp": 1619998701
    },
    {
        "content": "<p>indeed Con(ZFC) can probably be smuggled in too</p>",
        "id": 237094763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998726
    },
    {
        "content": "<p>essentially L will look like \"true arithmetic\" from lean's point of view, so all true (that is, lean-provable) nat facts become L facts</p>",
        "id": 237094795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998776
    },
    {
        "content": "<p>this induction is thus structural induction for nats opposed to equality-based induction for nats</p>",
        "id": 237094798,
        "sender_full_name": "Mac",
        "timestamp": 1619998784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237094795\">said</a>:</p>\n<blockquote>\n<p>essentially L will look like \"true arithmetic\" from lean's point of view, so all true (that is, lean-provable) nat facts become L facts</p>\n</blockquote>\n<p>isn't it that opposite, all L nat facts become Lean nat facts?</p>",
        "id": 237094873,
        "sender_full_name": "Mac",
        "timestamp": 1619998843
    },
    {
        "content": "<p>it's both, to the extent that L models negative nat facts</p>",
        "id": 237094894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619998887
    },
    {
        "content": "<p>Wait a second does this even prove <code>L |- 0 = 0</code>?</p>",
        "id": 237094990,
        "sender_full_name": "Mac",
        "timestamp": 1619999002
    },
    {
        "content": "<p>all that equality proof tells me is the structure of nat terms, it doesn't give me properties about them.</p>",
        "id": 237095054,
        "sender_full_name": "Mac",
        "timestamp": 1619999063
    },
    {
        "content": "<p>The argument is roughly that since <code>L |- 0 + 0 = 0</code>, it suffices to prove <code>0 + 0 = 0</code>. By the induction lemma <code>0 + 0 = S^i 0</code> so it is either 0 or <code>0 + 0 = S x</code>; but in this case <code>L |- S x = 0</code> and I guess this violates some axiom</p>",
        "id": 237095076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619999114
    },
    {
        "content": "<p>i.e. it tells me if <code>3 + 4</code> is a nat term then it is some successor of zero, it doesn't tell me which one, right?</p>",
        "id": 237095078,
        "sender_full_name": "Mac",
        "timestamp": 1619999116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237095076\">said</a>:</p>\n<blockquote>\n<p>The argument is roughly that since <code>L |- 0 + 0 = 0</code>, it suffices to prove <code>0 + 0 = 0</code>. By the induction lemma <code>0 + 0 = S^i 0</code> so it is either 0 or <code>0 + 0 = S x</code>; but in this case <code>L |- S x = 0</code> and I guess this violates some axiom</p>\n</blockquote>\n<p>So as long as I have the <code>S n \\ne 0</code> axiom it does, but without it, it doesn't.</p>",
        "id": 237095155,
        "sender_full_name": "Mac",
        "timestamp": 1619999167
    },
    {
        "content": "<p>I believe it's possible to use that to prove <code>L |- 1 = 0</code> by taking predecessors of both sides enough times</p>",
        "id": 237095315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619999329
    },
    {
        "content": "<p>thing is because this the term <code>0</code>, 0 itself can still be equal to the successor of some other nonzero (non-nat) number like <code>-1</code></p>",
        "id": 237095421,
        "sender_full_name": "Mac",
        "timestamp": 1619999448
    },
    {
        "content": "<p>I believe 0 = (S -1) or the like would still be consistent</p>",
        "id": 237095589,
        "sender_full_name": "Mac",
        "timestamp": 1619999654
    },
    {
        "content": "<p>Oh sorry, by <code>x</code> I actually mean <code>S^i 0</code></p>",
        "id": 237095616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619999696
    },
    {
        "content": "<p>that is, in the hypothetical we know that e.g. <code> L |- S S S 0 = 0</code></p>",
        "id": 237095641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619999722
    },
    {
        "content": "<p>so it's not <code>-1</code> unless <code>S</code> is cyclic or something</p>",
        "id": 237095660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619999761
    },
    {
        "content": "<p>which it might be without the <code>S x != 0</code> axiom</p>",
        "id": 237095710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619999780
    },
    {
        "content": "<p>yeah, that was my point</p>",
        "id": 237095724,
        "sender_full_name": "Mac",
        "timestamp": 1619999807
    },
    {
        "content": "<p>without the axiom, we have no knowledge of where the ladder starts or stops (or if it does)</p>",
        "id": 237095750,
        "sender_full_name": "Mac",
        "timestamp": 1619999865
    },
    {
        "content": "<p>I just remembered this, so I'll put this here.<br>\n<span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237075647\">said</a>:</p>\n<blockquote>\n<p>Suppose <code>p</code> is neither provable nor disprovable. Then <code>L |- p</code> is false, so <code>L |- p -&gt; L |- false</code> is true, so <code>L |- (p -&gt; false)</code> by your proof rule and so <code>p</code> is provably false. Thus every statement is provable or disprovable in the logic</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237075803\">said</a>:</p>\n<blockquote>\n<p>No, It means that <code>not (L |- p)</code> and <code>not (L |- not p)</code></p>\n</blockquote>\n<p>First, This is only true if <code>(L |- p -&gt; false) -&gt; (L |- not p)</code>holds (or, more generally, if <code>(L |- p -&gt; q) -&gt; (L |- not p)</code> for some <code>q</code> holds). Furthermore, if the logic lacks the law of excluded middle even at statement like <code>(L |- p &lt;-&gt; not p)</code> is fine. I think you may be under-estimating the number of logics in which this conditional proof rule is fine.</p>",
        "id": 237105685,
        "sender_full_name": "Mac",
        "timestamp": 1620010384
    },
    {
        "content": "<p>However, I do thank you for bringing to my attention these properties of my conditional proof rule. I probably wouldn't have noticed them myself. So thanks! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 237106406,
        "sender_full_name": "Mac",
        "timestamp": 1620011167
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Indeed, as I've said every logical argument I made requires some assumptions on the logic (and it's not too difficult to reverse engineer the required rules from the argument itself, in reverse mathematics style). You can't get anywhere if you don't make any assumptions at all. But just because the argument fails if the logic is so impoverished that <code>p -&gt; false</code> and <code>not p</code> are not equivalent doesn't mean it's a good proof rule, because at the very least it means you have an \"anti-establishment\" proof rule that is incompatible with the traditional axioms you would find in a mainstream theory like PA or ZFC. Usually, when doing this kind of theory exploration, the rules are supposed to be at least compatible with what traditional FOL does, and I am trying to show how it is not. So you are exploring some other incompatible island in theory space, which might be interesting, but probably is less applicable than you thought.</p>",
        "id": 237129262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620030536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  That 's fair. Thanks again!</p>",
        "id": 237203503,
        "sender_full_name": "Mac",
        "timestamp": 1620065245
    },
    {
        "content": "<p>One thing I'm still curious about though, is why do most standard mathematical logics embedded the logic with the math. What particular pitfalls does relegated logical connectives to the metalogic and leaving only the mathematical predicates and numbers (equality, numbers, sets, etc.) to the object logic create?</p>",
        "id": 237204384,
        "sender_full_name": "Mac",
        "timestamp": 1620065587
    },
    {
        "content": "<p>That sort of thing is often known as <a href=\"https://en.wikipedia.org/wiki/Higher-order_abstract_syntax\">higher order abstract syntax (HOAS)</a> in the biz. It works pretty well in LF, but it requires that the metatheory be very weak, so that function types correspond roughly to things that can be represented by terms in the logic</p>",
        "id": 237206571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620066483
    },
    {
        "content": "<p>for example, you would generally want the function type in such a system to be countable and satisfy a paremetricity metatheorem</p>",
        "id": 237206826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620066570
    },
    {
        "content": "<p>If the metatheory is sufficiently advanced so as to be able to do general mathematics, the function type will be uncountable and contain \"wild\" terms in it which break parametricity. HOAS is usually inconsistent in such systems, and Lean falls in this category</p>",
        "id": 237207137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620066664
    },
    {
        "content": "<p>The paper <a href=\"https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps\">Higher Order Abstract Syntax in Coq</a> discusses some of the difficulties of implementing HOAS in Coq, which has similar issues to Lean (Lean has it a bit worse because classical logic admits even more exotic terms than plain old DTT)</p>",
        "id": 237208052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620066969
    }
]
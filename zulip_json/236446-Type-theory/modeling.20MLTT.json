[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/How.20to.20get.20HoTT.20people.20into.20Lean/near/197536017\">said</a>:</p>\n<blockquote>\n<p>Here's a sketch: [...]</p>\n</blockquote>\n<p>Great. Now suppose I want to interpret this syntax into the following kind of setup (the <em>natural models</em> of <a href=\"https://arxiv.org/abs/1406.3219v4\">https://arxiv.org/abs/1406.3219v4</a>):</p>\n<ul>\n<li>we have a category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> whose objects we think of as contexts;</li>\n<li>we have a presheaf <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi></mrow><mo>:</mo><msup><mi>C</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Ty} : C^{\\mathrm{op}} \\to \\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">y</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">o</span><span class=\"mord mathrm mtight\">p</span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span> where we think of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Ty}(\\Gamma)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">y</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mclose\">)</span></span></span></span> as the types in context <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span>;</li>\n<li>we have a presheaf <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">m</mi></mrow><mo>:</mo><msup><mi>C</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Tm} : C^{\\mathrm{op}} \\to \\mathrm{Set}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\">m</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">o</span><span class=\"mord mathrm mtight\">p</span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">S</span><span class=\"mord mathrm\">e</span><span class=\"mord mathrm\">t</span></span></span></span></span>, together with a natural transformation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">m</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi></mrow></mrow><annotation encoding=\"application/x-tex\">p : \\mathsf{Tm} \\to \\mathsf{Ty}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\">m</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">y</span></span></span></span></span> where we think of those elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Tm}(\\Gamma)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\">m</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mclose\">)</span></span></span></span> which map to a given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∈</mo><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\in \\mathsf{Ty}(\\Gamma)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">y</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mclose\">)</span></span></span></span> as the terms of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> (in the context <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span>).</li>\n</ul>",
        "id": 197540924,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589456776
    },
    {
        "content": "<p>Then I want to assign</p>\n<ul>\n<li>to every \"well-formed\" <code>Γ : list exp</code> an object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>,</li>\n<li>to every pair <code>Γ : list exp</code> and <code>A : exp</code> that is well-formed/well-typed, a section <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∈</mo><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\in \\mathsf{Ty}(\\Gamma)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">y</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mclose\">)</span></span></span></span>,</li>\n<li>to every suitable <code>Γ A e</code> a suitable section in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Tm}(\\Gamma)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\">m</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mclose\">)</span></span></span></span>.</li>\n</ul>",
        "id": 197541403,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589457107
    },
    {
        "content": "<p>What's not yet obvious to me is whether I can do it by induction on <code>Γ A e</code> rather than on the derivations.</p>",
        "id": 197541482,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589457139
    },
    {
        "content": "<p>(Obviously <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Ty}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">y</span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">m</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Tm}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\">m</span></span></span></span></span> are equipped with some extra structure which tells me how to interpret type formers)</p>",
        "id": 197542495,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589457755
    },
    {
        "content": "<p>Maybe I really can define it by induction on <code>exp</code>! That would be nice.</p>",
        "id": 197543728,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589458431
    },
    {
        "content": "<p>Normally there are things called a reversion or reversal lemmas or something that let you recover the types of pieces of an expression from the type of the entire expression, right? And somewhere you must have to take into the account that definitionally equal types can be interchanged.</p>",
        "id": 197543999,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589458595
    },
    {
        "content": "<p>Like one example must be that if <code>var n</code> has type <code>A</code> in context <code>Γ</code> then <code>list.nth Γ n</code> has to be <code>some A'</code> for <code>A</code> and <code>A'</code> defeq but not necessarily equal.</p>",
        "id": 197544136,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589458692
    },
    {
        "content": "<p>Might it make sense to consider well-formed-ness and defeq-ness together as a partial equivalence relation? Type theory people seem to like those...</p>",
        "id": 197544230,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589458782
    },
    {
        "content": "<p>I'm not sure how to reconstruct the type of the function <code>f</code> in <code>app f x</code> though. Seems like you lost the information of the entire dependent type that is its output.</p>",
        "id": 197544404,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589458915
    },
    {
        "content": "<p>Actually you would need to recover type information for both <code>f</code> and <code>x</code>.</p>",
        "id": 197546505,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589460218
    },
    {
        "content": "<p>In <a href=\"https://github.com/guillaumebrunerie/initiality/blob/reflection/typetheory.agda\">https://github.com/guillaumebrunerie/initiality/blob/reflection/typetheory.agda</a> the expressions are decorated with a lot more typing information. Seems like either you have to do this, or prove that you can reconstruct all the type information--I guess this is like translating the language you sketched into a language with the extra type info.</p>",
        "id": 197547043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589460514
    },
    {
        "content": "<p>Or maybe you could just use choice to pick a derivation witnessing well-typedness, but that sounds awkward later.</p>",
        "id": 197547099,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589460546
    },
    {
        "content": "<p>The way this kind of thing usually seems to be done is by induction on typing derivations (<code>pf</code> i guess?) precisely because from those you can mostly recover the types of subexpressions. The <code>defeq</code> (conversion) rule is an exception but one can then inspect its premise.</p>",
        "id": 197547683,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1589460832
    },
    {
        "content": "<p>In that case, though, it's awkward for <code>pf</code> to be a Prop.</p>",
        "id": 197547998,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589460970
    },
    {
        "content": "<p>But, we can suppose we turn it into data.</p>",
        "id": 197548072,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589461014
    },
    {
        "content": "<p>I'm also not sure whether I expect two different derivations of the same judgment to lead to equal translations into the model, or whether it necessarily matters.</p>",
        "id": 197551089,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589462053
    },
    {
        "content": "<p>Although the Agda project <em>does</em> seem to do define the interpretation just from the very-explicit syntax, e.g. for <a href=\"https://github.com/guillaumebrunerie/initiality/blob/reflection/partialinterpretation.agda#L191\">app</a>. I'm guessing you only need the typing derivations to prove the \"totality\" (completeness?) of this interpretation.</p>",
        "id": 197551372,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1589462136
    },
    {
        "content": "<p>Yes, with the typing information in the syntax I think I can see how to do it</p>",
        "id": 197551856,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589462250
    },
    {
        "content": "<p>Guillaume's approach uses a neat trick: all the <code>assume</code> statements in the partial interpretation collect preconditions which are needed to construct the model object. The output of <code>[[ t ]]</code> is then effectively a function from 'all preconditions needed for the interpretation to make sense' to a model object. I guess he then later proves that wellfoundedness of <code>t</code> implies that these preconditions are indeed satisfied. This should be equivalent to defining the interpretation over well-foundedness derivations in the first place, only with a better separation of concerns.</p>\n<p>My hunch is that it won't be an issue to have the well-foundedness predicate in <code>Prop</code>, since you should only be using it to kill impossible cases and to build <code>Prop</code>s in the model. However, I'm not sure about this. If you can keep it in <code>Prop</code>, that's great because otherwise you'll indeed probably have to prove that different derivations are interpreted into the same object (or that well-foundedness is an hProp, but even then you only get a propositional equality rather than a definitional one).</p>",
        "id": 197554995,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1589463585
    },
    {
        "content": "<p>Hmm, I am a bit worried that in order to define the interpretation of <code>app f x</code>, one might need to conjure up not only a proof of a condition (some Prop), but actually the entire types of <code>f</code> and <code>x</code> (some data). But maybe that's actually not needed.</p>",
        "id": 197555970,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589463905
    },
    {
        "content": "<p>Based on the way these natural models work, if I know the interpretation of <code>f</code> and <code>x</code>, I know the interpretations of their types. But the interpretations of <code>A</code> and <code>Pi A B</code> might not determine that of <code>B</code>, and I think that would prevent me from constructing the interpretation of <code>f x</code>.</p>",
        "id": 197562741,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589466347
    },
    {
        "content": "<p>Anyways, I think I'm okay with assuming that we start from syntax that contains typing annotations (particularly as the Agda initiality project also does this), especially if it would be possible to tack on a preprocessor that reconstructs these annotations from a proof of type-correctness. (Isn't this basically what the Lean kernel has to do in order to type check an expression? <code>expr</code> doesn't contain these typing annotations.)</p>",
        "id": 197565953,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589467782
    }
]
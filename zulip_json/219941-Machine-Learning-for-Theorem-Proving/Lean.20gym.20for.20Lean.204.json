[
    {
        "content": "<p>To avoid confusion in the previous thread <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20started.20with.20lean-gym\">#Machine Learning for Theorem Proving &gt; Getting started with lean-gym</a>, I'm splitting off the discussion about <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span>'s  <a href=\"https://github.com/dselsam/lean-gym\">Lean 4 lean-gym prototype</a> here.</p>",
        "id": 243283377,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624159640
    },
    {
        "content": "<p>Continuing in that topic, I'm understanding the <code>match</code>, <code>case</code>, and <code>induction</code> syntax a little better. It seems that they are different from the tactic combinators like <code>focus</code>, <code>try</code>, and <code>repeat</code>.  I'm not clear if this is a fundamental difference or just superficial.  (For one, that <code>?i1</code> trick doesn't work for say <code>focus</code> or <code>repeat</code>, at least not without first wrapping the tag <code>?i1</code> in a <code>refine</code>.)</p>",
        "id": 243283387,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624159673
    },
    {
        "content": "<p>Also, thinking about <code>repeat</code> and <code>try</code>, I think the following (superficial) example is interesting.  Here I'm applying the same tactic block to both branches of a match.  It doesn't work to naively label it as shown below.  The question would be if the proof recording apparatus was robust enough to handle such cases. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- This is valid</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">}</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- This is not valid</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">i1</span>\n\n  <span class=\"n\">case</span> <span class=\"n\">i1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">}</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 243283432,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624159722
    },
    {
        "content": "<p>Also, speaking of the proof recording apparatus, it is not clear to me (just because I'm still very new to Lean 4), how proof recording would work with all the syntax sugar,  macros, and other customizations with the Lean 4 Tactic DSL.  For example, I think this \"intro\" tactic is syntax sugar for <code>intro + match</code>.  Is it implemented in lean as just a single tactic or as (parse level syntactic sugar for) two tactics?  How would it be recorded?  Would your suggested handling of <code>induction</code>, <code>cases</code>, and <code>match</code> work out out of the box on this <code>intro</code> example as well?  What if a user made their own similar tactic (or syntactic sugar)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ex2</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">_</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 243283454,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624159782
    },
    {
        "content": "<p>I don't think lean 4 makes any sharp distinction between parse-level macro expansion and tactic execution. So <code>intro | ...</code> is probably implemented as macro expanding to <code>intro h; cases h with | ...</code>, however that doesn't really mean that you can eagerly split all such tactics into subcomponents, because <code>repeat t</code> is also implemented as macro expanding to <code>t; repeat t</code>, where the macro expansion halts once <code>t</code> succeeds. So in general, you would have to treat the input syntax pre-expansion, which means that user tactics have to be treated as their own things even if they are just macro expansion wrappers around existing tactics.</p>",
        "id": 243285201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624162677
    },
    {
        "content": "<p>I played around a little with the <a href=\"https://github.com/dselsam/lean-gym\">Lean4 lean-gym prototype</a>.  As for getting started, here is what worked for me:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>git clone git@github.com:dselsam/lean-gym.git\n<span class=\"nb\">cd</span> lean-gym\nelan override <span class=\"nb\">set</span> leanprover/lean4:nightly  <span class=\"c1\"># sets up the nightly version of Lean 4 in this directory</span>\n<span class=\"nv\">LEAN_PATH</span><span class=\"o\">=</span><span class=\"nv\">$HOME</span>/.elan/toolchains/leanprover--lean4---nightly/lib/lean lean --run Gym.lean Nat.add_comm\n</code></pre></div>\n<p>Note, I used nightly version of Lean 4.  I don't think stable works for this application yet.  Also, I could't get <code>leanpkg build bin</code> to work.</p>",
        "id": 243328899,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624234818
    },
    {
        "content": "<p>Instructions can be found as comments in the <a href=\"https://github.com/dselsam/lean-gym/blob/master/Gym.lean\">Gym.lean file</a>.  Note, again that I use a more verbose command than <code>lean-gym</code>, but it works.</p>",
        "id": 243328903,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624234825
    },
    {
        "content": "<p>As for the prototype, I quickly run into errors.  For example, it doesn't backtrack well.</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>$ LEAN_PATH=$HOME/.elan/toolchains/leanprover--lean4---nightly/lib/lean lean --run Gym.lean Nat.add_comm\n{\"state\": \"⊢ ∀ (n m : Nat), n + m = m + n\",\n \"proved\": false,\n \"error\": null,\n \"branchId\": 0}\n&gt; 0 intro n\n{\"state\": \"n : Nat\\n⊢ ∀ (m : Nat), n + m = m + n\",\n \"proved\": false,\n \"error\": null,\n \"branchId\": 1}\n&gt; 0 intro n'\n{\"state\": \"n' : Nat\\n⊢ ∀ (m : Nat), n' + m = m + n'\",\n \"proved\": false,\n \"error\": null,\n \"branchId\": 2}\n&gt; 1 intro m\nuncaught exception: unknown metavariable '?_uniq.3'\n</code></pre></div>",
        "id": 243328905,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624234840
    },
    {
        "content": "<p>Also, I can't seem to run a <code>match</code> tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>$ LEAN_PATH=$HOME/.elan/toolchains/leanprover--lean4---nightly/lib/lean lean --run Gym.lean Nat.add_comm\n{\"state\": \"⊢ ∀ (n m : Nat), n + m = m + n\",\n \"proved\": false,\n \"error\": null,\n \"branchId\": 0}\n&gt; 0 intros n m\n{\"state\": \"n m : Nat\\n⊢ n + m = m + n\",\n \"proved\": false,\n \"error\": null,\n \"branchId\": 1}\n&gt; 1 match m with | 0 =&gt; simp | k+1 =&gt; simp [Nat.add_comm]\nError: index out of bounds\nError: index out of bounds\nError: index out of bounds\nError: index out of bounds\nuncaught exception: tag not found\n</code></pre></div>",
        "id": 243328914,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624234866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Thanks, fixed both.</p>",
        "id": 243407682,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624292820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> <span class=\"user-mention\" data-user-id=\"249373\">@Stanislas Polu</span> This is roughly what I had in mind for tracing: <a href=\"https://github.com/dselsam/lean4/tree/experiment-trace-tactics\">https://github.com/dselsam/lean4/tree/experiment-trace-tactics</a> There are several design decisions to be made but this version seems like a workable starting point. For <code>Nat.mod_lt</code>, it successfully creates a dataset that can replay <code>Nat.mod_lt</code> in <code>lean-gym</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">0</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n<span class=\"mi\">1</span> <span class=\"n\">induction</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"n\">using</span> <span class=\"n\">mod.inductionOn</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"mi\">2</span> <span class=\"n\">intro</span> <span class=\"n\">h₃</span>\n<span class=\"mi\">3</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">noImplicitLambda</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span>\n<span class=\"mi\">4</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">Nat.mod_eq_sub_mod</span> <span class=\"n\">h₁</span><span class=\"o\">]</span>\n<span class=\"mi\">5</span> <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span>\n<span class=\"mi\">6</span> <span class=\"n\">intro</span> <span class=\"n\">h₂</span>\n<span class=\"mi\">7</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">noImplicitLambda</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.mp</span> <span class=\"o\">(</span><span class=\"n\">Decidable.notAndIffOrNot</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h₁</span><span class=\"bp\">;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span>\n<span class=\"mi\">8</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"mi\">9</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">h₂</span> <span class=\"n\">h₁</span>\n<span class=\"mi\">10</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">noImplicitLambda</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"k\">have</span> <span class=\"n\">hgt</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">gtOfNotLe</span> <span class=\"n\">h₁</span><span class=\"bp\">;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span>\n<span class=\"mi\">11</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">noImplicitLambda</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"k\">have</span> <span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">%</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mod_eq_of_lt</span> <span class=\"n\">hgt</span><span class=\"bp\">;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span>\n<span class=\"mi\">12</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">heq</span><span class=\"o\">]</span><span class=\"n\">at</span> <span class=\"n\">hgt</span>\n<span class=\"mi\">13</span> <span class=\"n\">exact</span> <span class=\"n\">hgt</span>\n</code></pre></div>",
        "id": 243424132,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624300408
    },
    {
        "content": "<p><code>TacticM</code> should probably accumulate the datapoints (as Lean datatypes) in an array (if some flag is set) and allow a user-defined function to access/prune/postprocess/export (rather than building in the heuristics above).</p>",
        "id": 243424833,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624300694
    },
    {
        "content": "<p>This is pretty cool!  Especially considering how <a href=\"https://github.com/dselsam/lean4/commit/f577b4c6e64b0f823ac91b7c67eef6b30f3862cf\">few lines of code</a> it is to implement.  For reference, here is the original proof that is being recorded in the example above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mod_lt</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">%</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"n\">using</span> <span class=\"n\">mod.inductionOn</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h₂</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.mp</span> <span class=\"o\">(</span><span class=\"n\">Decidable.notAndIffOrNot</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h₁</span>\n    <span class=\"k\">match</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">h₂</span> <span class=\"n\">h₁</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">hgt</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">gtOfNotLe</span> <span class=\"n\">h₁</span>\n      <span class=\"k\">have</span> <span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">%</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mod_eq_of_lt</span> <span class=\"n\">hgt</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">heq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hgt</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hgt</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h₃</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mod_eq_sub_mod</span> <span class=\"n\">h₁</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span>\n</code></pre></div>",
        "id": 243463734,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624325940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20gym.20for.20Lean.204/near/243424833\">said</a>:</p>\n<blockquote>\n<p><code>TacticM</code> should probably accumulate the datapoints (as Lean datatypes) in an array (if some flag is set) and allow a user-defined function to access/prune/postprocess/export (rather than building in the heuristics above).</p>\n</blockquote>\n<p>That would be amazing!  I know HOL-Light for example has some code in the kernel that lets you record proofs if turned on.</p>",
        "id": 243463825,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624326056
    },
    {
        "content": "<p>Most of that code is implementing the heuristic syntax-cleaning, which shouldn't be built-in anyway. The tracing code itself is tiny.</p>",
        "id": 243464170,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624326528
    },
    {
        "content": "<p>Silly questions about this prototype:</p>\n<ul>\n<li>Does one just build Lean from source as normal (but from your branch) and the tactics history is traced to STDOUT?</li>\n<li>The first <code>intro x y</code>.  Is that somehow recorded, or did you just add that to match the start of the tactic proof?</li>\n<li>Is <code>refine (noImplicitLambda% ...)</code> explicitly added during the recording, or did you just know to add them when entering it back in?</li>\n<li>How automatic is it to take the output of the recording process and reproduce a proof for your lean-gym?  (This would be a great way to test if the recording and the gym both align and scale robustly to much of the library.)</li>\n<li>What is being recorded is a pretty print of the parsed tactic command, verse what the human typed in, right?  (I assume that since <code>rw [← heq] at hgt</code> was modified to be <code>rewrite [←heq]at hgt</code>.)  I have had a lot of trouble in Lean 3 with putting pretty printed expressions back into Lean.  They sometimes didn't parse.  However, I think this is mostly fixed in Lean 4, right?</li>\n</ul>",
        "id": 243464596,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624327096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20gym.20for.20Lean.204/near/243464596\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Does one just build Lean from source as normal (but from your branch) and the tactics history is traced to STDOUT?</li>\n</ul>\n</blockquote>\n<p>Yes. In this PoC commit, there is no flag to disable or redirect it.</p>\n<blockquote>\n<ul>\n<li>The first <code>intro x y</code>.  Is that somehow recorded, or did you just add that to match the start of the tactic proof?</li>\n</ul>\n</blockquote>\n<p>This was not recorded, and I added it.</p>\n<blockquote>\n<ul>\n<li>Is <code>refine (noImplicitLambda% ...)</code> explicitly added during the recording, or did you just know to add them when entering it back in?</li>\n</ul>\n</blockquote>\n<p>Evaluating many of the tactics involves constructing a new term <code>t</code> with holes, and then evaluating the tactic <code>refine t</code>. I did not add these.</p>\n<blockquote>\n<ul>\n<li>How automatic is it to take the output of the recording process and reproduce a proof for your lean-gym?  (This would be a great way to test if the recording and the gym both align and scale robustly to much of the library.)</li>\n</ul>\n</blockquote>\n<p>It is not automatic, but you may automate it. If you do, note that the datapoints are not currently printed in chronological order, so you would either need to (a) fix that or (b) hash the goal strings to find the next tactic.</p>\n<blockquote>\n<ul>\n<li>What is being recorded is a pretty print of the parsed tactic command, verse what the human typed in, right?  (I assume that since <code>rw [← heq] at hgt</code> was modified to be <code>rewrite [←heq]at hgt</code>.)  I have had a lot of trouble in Lean 3 with putting pretty printed expressions back into Lean.  They sometimes didn't parse.  However, I think this is mostly fixed in Lean 4, right?</li>\n</ul>\n</blockquote>\n<p>The tactic syntax is formatted into a string automatically. Roundtripping <em>expressions</em> (i.e. <code>Expr → String → Expr</code>) may never work perfectly, but roundtripping syntax (i.e. <code>Syntax → String → Syntax</code>) should already work perfectly (AFAIK).</p>",
        "id": 243465108,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624327690
    },
    {
        "content": "<p>For more context, here are the three heuristics I implemented above:</p>\n<ul>\n<li>For every goal, keep the <em>last</em> tactic to be evaluated on that goal.</li>\n<li>Post-process the syntax to replace parts that are evaluated downstream with <code>?_</code>.</li>\n<li>Store the datapoints in the backtracking part of the tactic state, so <code>f &lt;|&gt; g</code> won't keep the datapoints from <code>f</code> if <code>f</code> fails.</li>\n</ul>\n<p>I didn't consider whether this approach makes sense for every combinator. This approach also has some known downsides. For example, <code>intros x y</code> will always trace as <code>intro x</code> and then <code>intro y</code>. One alternative would be to create additional data at different \"levels\", where you keep the first tactic that is \"small enough\", or the last otherwise.</p>",
        "id": 243465363,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624328043
    },
    {
        "content": "<p>Thanks.  Yes, I think there is still a lot of design work here.  And given there isn't much Lean 4 data, I don't think we have to work it out all that soon, but having these as a place to start is really good!  This is plenty to play with.</p>",
        "id": 243465692,
        "sender_full_name": "Jason Rute",
        "timestamp": 1624328486
    }
]
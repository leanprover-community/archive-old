[
    {
        "content": "<p>I worked on the Olympiad-formalization repository for a few months back in August to January and stopped for the past three months. Now I want to get back into it and I am thinking about the idea of formalizing as much as I can about Olympiad geometry in Lean. The reasons why are straightforward:</p>\n<ol>\n<li>\n<p>As far as I am aware, there is a dire lack of geometry problems in the repo right now, due to the fact that it has been very difficult to express some (or maybe even most) geometric concepts concisely in Lean. (Maybe this has changed?)</p>\n</li>\n<li>\n<p>I am looking for something to do over the summer and this feels like a nice project to start. I am also just very interested in the work being done with AI and ITPs so far and want to contribute.</p>\n</li>\n</ol>\n<p>The plan is to work off the Art of Problem Solving \"Introduction to Geometry\" book. This is just the default choice, and it might change if more challenging books are better suited for formalizing IMO level problems. A nice goal to set would be to formalize a few interesting examples of IMO geometry problems that use extensive triangle/circle theorems concisely. (Does this already exist?) Any suggestions or advice about this idea are also welcome! (cc: <span class=\"user-mention\" data-user-id=\"249373\">@Stanislas Polu</span> I suppose)</p>",
        "id": 279017642,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1649968398
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/IMO.20Geometry/near/279017642\">said</a>:</p>\n<blockquote>\n<p>I worked on the Olympiad-formalization repository for a few months back in August to January and stopped for the past three months. Now I want to get back into it and I am thinking about the idea of formalizing as much as I can about Olympiad geometry in Lean. The reasons why are straightforward:</p>\n<ol>\n<li>\n<p>As far as I am aware, there is a dire lack of geometry problems in the repo right now, due to the fact that it has been very difficult to express some (or maybe even most) geometric concepts concisely in Lean. (Maybe this has changed?)</p>\n</li>\n<li>\n<p>I am looking for something to do over the summer and this feels like a nice project to start. I am also just very interested in the work being done with AI and ITPs so far and want to contribute.</p>\n</li>\n</ol>\n<p>The plan is to work off the Art of Problem Solving \"Introduction to Geometry\" book. This is just the default choice, and it might change if more challenging books are better suited for formalizing IMO level problems. A nice goal to set would be to formalize a few interesting examples of IMO geometry problems that use extensive triangle/circle theorems concisely. (Does this already exist?) Any suggestions or advice about this idea are also welcome! (cc: <span class=\"user-mention silent\" data-user-id=\"249373\">Stanislas Polu</span> I suppose)</p>\n</blockquote>\n<p>Hi Hanting! I recommend you sync with <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> -- he has added some basic euclidean geometry to mathlib (@ <a href=\"https://github.com/leanprover-community/mathlib/tree/master/src/geometry/euclidean\">https://github.com/leanprover-community/mathlib/tree/master/src/geometry/euclidean</a>)</p>",
        "id": 279024696,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1649972447
    },
    {
        "content": "<p>Hi Hanting! I think it's an interesting project to attempt to solve progressively difficult geometry problems. Any exercise in that book that you can formalize with <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> 's work as a starting point?</p>",
        "id": 279063551,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1650014407
    },
    {
        "content": "<p>I think we're still at the stage where you should expect to add thousands of lines of API to mathlib proper for any geometry problem you want to formalize (and, thus, should expect to do a very large number of PRs along the way, whenever you find something that could go in mathlib; simply adding oriented angles took 50 PRs). Having a particular problem in mind may help guide you in what API you want to formalize along the way, but the main work will still be adding that API not formalizing the solution to that particular problem. And all that API should be added in properly general form rather than just what you need for that lemma (though in some cases there may be subjective judgement about just how general you want to go, when you're dealing with API for something five levels of dependencies down from the problem you're actually aiming for). That includes both defining and proving things in appropriate generality (not restricting things to the plane case unnecessarily, for example), and making sure that, when you add definitions, you add all the associated trivial lemmas that you can think of that may come up when using that API but are too trivial to state in textbooks. (In practice, as you use the API you'll then find more missing pieces you need to add.)</p>",
        "id": 279101906,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650043267
    },
    {
        "content": "<p>Example 1: most IMO geometry problems state betweenness conditions. So you need to define betweenness, both strict and weak, in an affine space over an ordered ring (for example - once the affine space and convexity refactors are done, it would be over an ordered semiring), prove loads of trivial lemmas (such as those found in Tarski's axioms for geometry, but not limited to those), link it to convexity as far as possible in the absence of those refactors, and then link to geometrical properties such \"angle = pi\". And that's just API setup to be able to <em>state</em> the problems.</p>",
        "id": 279102196,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650043450
    },
    {
        "content": "<p>Example 2: say you want to use congruent triangle lemmas, such as SSS congruence. Don't prove something specific to triangles, prove an appropriate result for possibly infinite indexed families of points in possibly infinite-dimensional Euclidean affine spaces. (The pairwise distances in an indexed family of points uniquely determine which combinations of points with sum of weights 0 are the 0 vector, and thus the dimension of the affine span of the points; if that span is finite-dimensional, and there is an isometric equivalence between the two spaces, there is one that maps points in one family to corresponding points in the other, which serves as a definition of congruence for indexed families of points.)</p>",
        "id": 279102599,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650043695
    },
    {
        "content": "<p>Example 3: many IMO geometry problems involve the incenter of a triangle in either the problem or the solution. That concept makes sense for a simplex, so should be defined for a simplex not just a triangle, just as <code>circumcenter</code> is defined for a simplex. But then you want to state \"incenter equals intersection of angle bisectors\", and the angle bisectors are those of angles between faces of the simplex. So you get into wanting to talk about oriented angles between oriented subspaces in order to distinguish the two bisectors, which can involve talking about orientations of at least three subspaces at the same time. That's probably going to involve lots of API (with very little mathematical content) for manipulating orientations of subspaces, before you then specialize things to the two-dimensional case after developing the API in n dimensions.</p>",
        "id": 279103121,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650043968
    },
    {
        "content": "<p>Example 4: some IMO geometry problems involve angles, and those are unoriented angles, but for a formal proof it's probably more convenient to use oriented angles. To use oriented angles to prove something involving unoriented angles, I expect you'll need lots of lemmas relating the two, and in particular lemmas of the form \"these two angles have the same orientation\". My inclination is the right way to prove \"same orientation\" lemmas is via continuity: the function from an oriented angle to its sign is constant away from 0 and pi, and the function from two vectors or three points to the corresponding oriented or unoriented angle is continuous when the vectors aren't 0 / no two points are equal, and once you've proved those things you can use existing API for continuity in mathlib to deduce that the function from two vectors / three points to the sign of the corresponding angle is constant on appropriate subsets of <code>V × V</code> or <code>P × P × P</code> where the oriented angles don't go through 0 or pi.</p>",
        "id": 279103639,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650044263
    },
    {
        "content": "<p>Example 5: I suspect lots of things involving circles would be simpler with a bundled <code>sphere</code> type (a structure bundling <code>center</code> and <code>radius</code>) to help with talking about points lying in a circle, tangency, power of a point, radical subspace, etc. - which itself needs lots of API, and involves the non-mathematical design question of whether you also bundle a hypothesis that the radius is positive or nonnegative or just pass appropriate hypotheses like that to lemmas that need it.</p>",
        "id": 279104014,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650044448
    },
    {
        "content": "<p>I don't think there's any sort of fundamental obstacle to formalizing geometrical proofs - it's simply there's a lot to define first before you actually get onto the sort of proofs involved in IMO geometry problems. (Other examples that could be given of missing API include e.g. cyclic polygons - ordering of points on a circle - and linking into the measure theory parts of the library for anything involving talking about areas / volumes.)</p>",
        "id": 279104351,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650044689
    },
    {
        "content": "<p>And the need to set up a lot of API is not of course at all unique to geometry.</p>",
        "id": 279104387,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650044726
    },
    {
        "content": "<p>This should probably become an issue or even better a project</p>",
        "id": 279135137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650066464
    },
    {
        "content": "<p>That's what I'm saying <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 279140997,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1650074230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> Sorry for the slow response, you wrote a lot of interesting information that I would've never thought of, so thank you for doing that <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> </p>\n<p>For betweenness, could you elaborate on why this would be difficult? I am thinking that the canonical definition would be something like \"z is on the segment (2-simplex) xy.\" Then Tarski's axioms would follow pretty easily. (Unless we want to do it the \"axiomatic way\" where we formulate everything from Tarski's axioms and then show that mathlib's concept of euclidean spaces is an instance of such a geometry. In my head this is the \"opposite way\" to do things and am I wondering if this is a serious consideration at all -- I also just realized that we would only be modeling plane geometry with Tarski's axiom, so nevermind.) I am not very aware of current convexity/ring things going on in mathlib, so are these refactors actually important in doing geometry? Or is it more like the technical lean/cs details that need to be dealt with?</p>\n<p>This is sort of the idea I was expecting for congruence, so your agreement on this is great motivation. One question I am interested in is the analogous deal with similarity. We would actually want to define similar transformations (which maybe already exists?) in affine spaces, and then define similarity for (arbitrary?) sets of points as the most general starting point, right? Then limit that down to all the other stuff we need. This also seems straightforward but requires lots of API.</p>\n<p>You've clearly thought way more about these things than I did; I was not thinking that defining higher dimensional triangle centers would be that difficult, but reading your thoughts I agree that orientations will become a mess. ...I suspect should be a general way to deal with orientations. If this is possible then it should be straightforward on how to proceed. The details of converting general theorems down to the specific 2/3 dimensional cases might be messy, though. But I'd love to hear more about what ideas you have for this!</p>\n<p>Could you clarify what you mean by needing to prove \"same orientation\" lemmas via continuity? I kind of understand what you mean but the details are going over my head. </p>\n<p>I feel like circles themselves are not that complicated; in your example, for example, I would probably choose to use take the radius in the reals and have a coe from the sphere structure to the set of its realization; then <code>S</code> would be the empty set when <code>r &lt; 0</code> and statements like <code>x in S</code> would be degenerate. This is just the very bottom layer, though. Things like power of a point and tangency probably need their own separate consideration.</p>\n<p>As you mentioned there is basically nothing about volumes right now in mathlib; all the measure-theoretic infrastructure exists, though, which is cool. Do you have any thoughts on what's needed for volume API? Or will it be relatively straightforward? I personally don't have a good feel for measure theory, so I am wondering how one would glue the current API with the geometric structures we define in a nice generalizable way...</p>\n<p>Yeah if I had to say I would probably start working on similarity towards congruences with the goal of stating the SSS-SAS-ASA congruence theorems. Or, do you have anything incomplete that you think would be a nice place to start?</p>",
        "id": 279200779,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1650167796
    },
    {
        "content": "<p>Some things such as betweenness and spheres aren't difficult, it's simply that you need to set up at least hundreds of lines of API (mostly too trivial to appear in textbooks) before you can do anything much useful with them. For betweenness, you probably need API for both strict and weak betweenness as both are relevant in geometry in practice (even if axiomatic geometry tends to use just one version). There's also the notion of an affine subspace being between two points, or a point being between a point and an affine subspace (e.g. two points being on opposite sides / same side of a line), though that can probably wait until later.</p>",
        "id": 279890701,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650670292
    },
    {
        "content": "<p>The idea of the proposed convexity / affine spaces refactor is as follows. You can define affine combinations with nonnegative coefficients summing to 1, and thus convexity (of which betweenness is a special case) in two different contexts: for a semimodule over an ordered semiring, or for an affine space for a module over an ordered ring. In the case where you have a module over an ordered ring, which can be considered as an affine space over itself, the resulting two definitions of affine combinations are equal, but not defeq. So the proposed refactor would be to define abstract affine combination spaces, and then there would be a type class to assert that a type that is both an <code>add_torsor</code> for a <code>module</code> and also an abstract affine combination space has equal affine combinations from the two definitions. And then you can have a single definition of convexity and betweenness for such abstract affine combination spaces, which applies to both the semimodule and the <code>add_torsor</code> cases.</p>\n<p>I think it's reasonable to define betweenness for affine spaces (i.e., <code>add_torsor</code>s for modules over an ordered ring) without waiting for that refactor, but it might best be done in a way that facilitates such a refactor in future (for example, making definitions irreducible to avoid too much reliance on defeq for the definitions).</p>",
        "id": 279891191,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650670713
    },
    {
        "content": "<p>For congruence and similarity (definitions that apply in arbitrary metric spaces, not just in a linear or affine context): we have the unbundled <code>isometry</code> proposition, and bundled types for isometric equivalences, and linear and affine isometries and isometric equivalences. I think we still need to apply the morphism refactor to these type classes (i.e. have type classes for types of isometries or isometric equivalences, so that a single lemma can apply to multiple kinds of bundled isometries). Once that's done, there should probably be a corresponding collection of unbundled propositions, bundled morphisms and type classes for them, for the case of similarities (so at least five bundled types of similarities as well as whatever type classes) - I don't know whether a similarity with scale factor 0 should be allowed by those types etc. or not. Note that then e.g. the lemma that a similarity is a continuous function would only need proving for the unbundled propositions and for the most general type class of similarities - using type classes as in the morphism refactor should remove most of the need for separate <code>affine_isometry.continuous</code>, <code>affine_isometry_equiv.continuous</code> etc. lemmas for each of the many such bundled types.</p>",
        "id": 279891700,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650671203
    },
    {
        "content": "<p>For proving \"same orientation\" lemmas for angles via continuity: a typical such lemma might be of the form: the angle between vectors <code>x</code> and <code>y</code> has the same orientation as that between <code>x</code> and <code>a • x + b • y</code>, for any positive <code>b</code>; I expect lots of lemmas like that will be needed for when you want to move between oriented and unoriented angles in a proof. While you no doubt could prove that with some ad hoc argument about <code>complex.arg</code>, I don't think that's the right (clean, general) approach for mathlib. All that's actually needed is that <code>a • x + b • y</code> is a continuous function of <code>(a, b)</code> (should follow from composition of existing continuity lemmas in mathlib), that angles are continuous functions of the vectors involved as long as those vectors are nonzero (not currently in mathlib, should be added, should be straightforward to prove), and that if the angle between <code>x</code> and <code>y</code> isn't 0 or pi, neither is that between <code>x</code> and <code>a • x + b • y</code> (what you first need to add there is an <code>iff</code> condition for twice the oriented angle between two vectors to be 0, I think). And given those continuity properties, the \"same orientation\" lemma then follows, without any special argument about <code>arg</code> being needed at all.</p>",
        "id": 279892332,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650671833
    },
    {
        "content": "<p>I don't know what API will be needed for volumes in geometry (beyond having some way to talk about convex hulls in affine spaces so we can take their measure - see the convexity refactor discussion above). Once there's a way of referring to the convex hull of the vertices of a simplex, you also need to define a measure on a Euclidean affine space in terms of what we have for measures in vector spaces. And then a good test would be whether you can prove that the volume of a simplex is 1/n * volume of base * height. (You may also need API here to move conveniently between the full space and subspaces, since the volume of the base is a (n-1)-dimensional measure in a subspace.)</p>\n<p>Note that once we have a proper link to the measure theory library, <code>archive/100-theorems-list/57_herons_formula.lean</code> ought to have its result restated to refer to measures rather than an ad hoc expression involving angles, and be moved from the mathlib archive to mathlib proper (statements about areas in relation to angles belong in mathlib proper as well). <code>9_area_of_a_circle.lean</code> really also belongs in mathlib proper in more general form (we have the gamma function now, so could state the volume of a sphere in n dimensions using the gamma function, though two-dimensional and three-dimensional special cases seem appropriate as well).</p>",
        "id": 279893010,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650672366
    },
    {
        "content": "<p>For SSS congruence in the general form I described above, <code>inner_weighted_vsub</code> and <code>dist_affine_combination</code> should be a reasonable basis for proving the key fact that all affine dependencies between an indexed family of points are determined by the pairwise distances between those points.</p>",
        "id": 279893181,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1650672545
    },
    {
        "content": "<p>Hi again, thank you for all the input!</p>",
        "id": 282453316,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1652682040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/IMO.20Geometry/near/279891700\">said</a>:</p>\n<blockquote>\n<p>For congruence and similarity (definitions that apply in arbitrary metric spaces, not just in a linear or affine context): we have the unbundled <code>isometry</code> proposition, and bundled types for isometric equivalences, and linear and affine isometries and isometric equivalences. I think we still need to apply the morphism refactor to these type classes (i.e. have type classes for types of isometries or isometric equivalences, so that a single lemma can apply to multiple kinds of bundled isometries). Once that's done, there should probably be a corresponding collection of unbundled propositions, bundled morphisms and type classes for them, for the case of similarities (so at least five bundled types of similarities as well as whatever type classes) - I don't know whether a similarity with scale factor 0 should be allowed by those types etc. or not. Note that then e.g. the lemma that a similarity is a continuous function would only need proving for the unbundled propositions and for the most general type class of similarities - using type classes as in the morphism refactor should remove most of the need for separate <code>affine_isometry.continuous</code>, <code>affine_isometry_equiv.continuous</code> etc. lemmas for each of the many such bundled types.</p>\n</blockquote>\n<p>I was wondering for this comment, what did you mean by \"type classes for types of isometries or isometric equivalences, so that a single lemma can apply to multiple kinds of bundled isometries\"? Does that mean adding some common type class like <code>[is_isometry f]</code> for maps? I'm having a hard time understanding how this would be concretely done to allow a single lemma to apply across all 5 different isometries.</p>\n<p>And to be clear, by \"five bundled types of similarities as well as whatever type classes,\" you mean the natural ones you get from generalizing what is done for isometries, correct?</p>",
        "id": 282453951,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1652682517
    },
    {
        "content": "<p>By any chance would you also know of any good references for developing general affine Euclidean geometry? I'm currently looking at Geometry I by Marcel Berger, but it feels too dense for me</p>",
        "id": 282459087,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1652686642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/IMO.20Geometry/near/282453951\">said</a>:</p>\n<blockquote>\n<p>I was wondering for this comment, what did you mean by \"type classes for types of isometries or isometric equivalences, so that a single lemma can apply to multiple kinds of bundled isometries\"? Does that mean adding some common type class like <code>[is_isometry f]</code> for maps? I'm having a hard time understanding how this would be concretely done to allow a single lemma to apply across all 5 different isometries.</p>\n<p>And to be clear, by \"five bundled types of similarities as well as whatever type classes,\" you mean the natural ones you get from generalizing what is done for isometries, correct?</p>\n</blockquote>\n<p>It would be <code>{F : Type*} [isometry_class F A B] (f : F)</code> for isometries from <code>A</code> to <code>B</code> (and likewise with <code>isometry_equiv_class</code>). See the doc strings for <code>data.fun_like.basic</code> for more explanation of the morphism type class pattern.</p>\n<p>Yes, generalize the types and type classes from isometries to similarities (most lemmas will then be true for similarities, not just for isometries).</p>",
        "id": 282577138,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1652746131
    },
    {
        "content": "<p>Thanks, I've started working on this!</p>",
        "id": 283208756,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1653191651
    },
    {
        "content": "<p>And if you don't mind another few questions... <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>Was there any particular reason you didn't start by defining <code>add_subtorsor</code> and then extending that to <code>affine_subspace</code>? There's also stuff like multiplicative <code>torsor</code>s and quotients that can be done too. Was it just a high effort to immediate usefulness ratio that turned you away from the trouble or was there something deeper that stopped you?</p>",
        "id": 283211372,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1653195257
    },
    {
        "content": "<p>This is what I have started with quotients, I would love to hear what you think about these definitions, if you don't mind!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.add_torsor</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.quotient_group</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">pointwise</span>\n<span class=\"kn\">section</span> <span class=\"n\">subtorsor</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">add_torsor</span> <span class=\"n\">G</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n<span class=\"kn\">include</span> <span class=\"n\">T</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">add_subtorsor</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">vsub_vadd_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">},</span> <span class=\"n\">p1</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">p2</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">p3</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"bp\">-ᵥ</span> <span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">+ᵥ</span> <span class=\"n\">p3</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">subtorsor</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">subgroup</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_add_subtorsor</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_subtorsor</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"n\">vsub_vadd_mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">p3</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"n\">p.add_mem</span> <span class=\"o\">(</span><span class=\"n\">p.sub_mem</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">)</span> <span class=\"n\">h3</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">subgroup</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">add_subtorsor</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">add_torsor</span> <span class=\"n\">G</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n<span class=\"kn\">include</span> <span class=\"n\">T</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">set_like</span> <span class=\"o\">(</span><span class=\"n\">add_subtorsor</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">carrier</span><span class=\"o\">,</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- not sure what this is supposed to be called</span>\n<span class=\"kd\">def</span> <span class=\"n\">direction</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">add_subtorsor</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">add_subgroup.closure</span> <span class=\"o\">((</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-ᵥ</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">add_subtorsor</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">subtorsor</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">add_torsor</span> <span class=\"n\">G</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n<span class=\"kn\">include</span> <span class=\"n\">T</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">add_subtorsor</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">-ᵥ</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t.direction</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">mk_equivalence</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">-ᵥ</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t.direction</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">vsub_self</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">zero_mem</span> <span class=\"n\">t.direction</span><span class=\"o\">,</span> <span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">neg_vsub_eq_vsub_rev</span><span class=\"o\">,</span> <span class=\"n\">neg_mem_iff</span><span class=\"o\">],</span> <span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">vsub_add_vsub_cancel</span> <span class=\"n\">z</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">add_subgroup.add_mem</span> <span class=\"n\">_</span> <span class=\"n\">hyz</span> <span class=\"n\">hxy</span><span class=\"o\">,</span> <span class=\"o\">})</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">add_subtorsor</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_quotient</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">add_subtorsor</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">quotient'</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- proof omitted</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">add_subtorsor</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.direction.normal</span><span class=\"o\">]</span>  <span class=\"o\">:</span> <span class=\"n\">add_torsor</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">t.direction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">⧸</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">subtorsor</span>\n</code></pre></div>",
        "id": 283211451,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1653195351
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> )</p>",
        "id": 283212517,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1653196580
    },
    {
        "content": "<p>At the time I defined affine subspaces, we didn't have any way for the theory of one structure type to be applied to another structure type building on it, so <code>add_subtorsor</code> wouldn't have helped at all in setting up the theory of <code>affine_subspace</code>. This was long before the subobject type class pattern (<a href=\"https://github.com/leanprover-community/mathlib/pull/11545\">#11545</a>) was invented.</p>",
        "id": 283227604,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1653219111
    },
    {
        "content": "<p>At the time I defined <code>add_torsor</code>, multiplicative groups didn't have <code>div</code> defined, and it was controversial whether it <em>should</em> be defined for multiplicative groups. Since many lemmas for <code>add_torsor</code> involve subtraction in the underlying additive group, that would have been a significant obstacle to setting up the theory of <code>add_torsor</code> via <code>to_additive</code> applied to a theory of <code>torsor</code>. Now that multiplicative groups do have <code>div</code>, it should be reasonable to set up multiplicative <code>torsor</code> and use <code>to_additive</code> to derive the theory of <code>add_torsor</code>.</p>",
        "id": 283227718,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1653219265
    },
    {
        "content": "<p>I see, thank you for the explanation!</p>",
        "id": 283255976,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1653259486
    }
]
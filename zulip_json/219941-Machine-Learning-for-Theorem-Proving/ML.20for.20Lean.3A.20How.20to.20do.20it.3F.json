[
    {
        "content": "<p>I want to start the conversation of how to enable machine learning for Lean 3 and Lean 4.  Of course there isn't just one application of machine learning or one type of machine learning.  Right now, I can see two immediate applications/connections of machine learning and Lean:</p>\n<ul>\n<li>Extending <a href=\"https://sites.google.com/view/holist/home\" target=\"_blank\" title=\"https://sites.google.com/view/holist/home\">HOList</a> to Lean.  I’ve already started a <a href=\"https://gist.github.com/jasonrute/00109af2bdc0974d2e8e79faf26ba556\" target=\"_blank\" title=\"https://gist.github.com/jasonrute/00109af2bdc0974d2e8e79faf26ba556\">document here</a> on what this would take (and if we are serious about doing this, the N2Formal team at Google AI would probably be willing to provide some assistance).  At first this would probably be more of a machine learning benchmark than a useable system, but I think we could also incorporate it into (a forked version of) Lean with some work.</li>\n<li><a href=\"#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Proposal.3A.20Apply.20premise.20selection.20to.20Hammer\" title=\"#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Proposal.3A.20Apply.20premise.20selection.20to.20Hammer\">Adding machine learning premise selection to the Lean hammer project</a></li>\n</ul>\n<p>Here are the four areas where machine learning will eventually need to interface with Lean.</p>\n<ol>\n<li><strong>At the tactic level.</strong>  If we are to ever use ML <em>from within</em> Lean, there would be to have tactics which apply machine learning under the hood.  The tactics could behave like <code>simp</code> and close the goal, or like <code>library_search</code> and suggest a proof which doesn’t use machine learning.  Both have their uses.  <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> has <a href=\"http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/slides/fomm_ebner.pdf\" target=\"_blank\" title=\"http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/slides/fomm_ebner.pdf\">already implemented something like this in Lean 3</a> with his Lean <code>hammer</code> tactic.  The tactic uses C++ for premise selection which means it could interface with TensorFlow or PyTorch instead.  However, it also sounds like to do this he had to hack Lean to make it work.  <strong>So it sounds like we know how to do this in Lean 3, and hopefully it will be easier in Lean 4 (where we don’t have to fork Lean to make this work).  However, one probably needs to document this more to see what is possible.</strong></li>\n<li><strong>Theorem dependency recording and statistics.</strong> For some applications of machine learning, it is important to have training data.  The minimum needed for something like HOList is a list of theorems statements (and either their dependencies or a linear order of theorems where the dependencies come before the theorem which uses it).  For the hammer premise selection, one needs something similar, the list of premises used for the proof of each theorem (and for further training, the premises actually used in the hammer proof).  It sounds like (at least for the hammer project) <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Hammer.20talk\" title=\"#narrow/stream/113488-general/topic/Hammer.20talk\">has a script which generates this information</a>.  It might not be in the form needed by the HOList project however.  Others have talked about how Lean stores theorems in the “environment”, although I don't understand the details. <strong>So it sounds like we have at least one way to do this in Lean 3 if not more.  Again, the question remains of what form this information is available in and what needs it meets.  I wonder if this will be easier in Lean 4.</strong></li>\n<li><strong>(Optional) Full proof recording at the tactic level</strong> For supervised learning of tactics (and again this is NOT needed for HOList, but could be a nice to have), one needs recorded tactic proofs (so one needs the tactics used and their parameters).  I have no idea if there is any work done here and if this is easy or hard.</li>\n<li><strong>Outside communication and control of Lean’s tactic framework</strong>  For a system like DeepHOL/HOList, one needs to (from within Python preferably) control a tactic search inside of Lean.  Let me describe how this currently works in DeepHOL/HOList.  A forked HOL Light version is put in a docker container.  This container also contains a gRPC server which takes three request types.  These requests are sent to the HOL Light docker container server from another docker container which handles the proof guidance and training.)  The three requests are as follows: ApplyTactic says “apply [tactic] with [parameters] to [goal].\"  Then the server tries that in HOL Light and if it succeeds, it returns a new list of goals.  VerifyProof says “check if [list of tactics with parameters] solves [theorem/goal].\"  Last, RegisterTheorem registers a theorem so that it can be called later by the system.  (Technically, in HOList it has to be the most recently verified theorem.  Also, it returns an integer fingerprint of the theorem.)  For a more detailed descriptions of how these three requests work, see <a href=\"https://github.com/jasonrute/holist-communication-example/blob/master/walkthrough_of_holist_api.ipynb\" target=\"_blank\" title=\"https://github.com/jasonrute/holist-communication-example/blob/master/walkthrough_of_holist_api.ipynb\">here</a>.  For DeepHOL/HOList or a similar system we would probably need to build something like this communication interface.  (For DeepHOL/HOList, we would probably need to implement these three commands, but it might be good to step back and think about how this could be done to support other systems besides DeepHOL.) Some have mentioned there is already <a href=\"https://github.com/dselsam/lean-python-bindings\" target=\"_blank\" title=\"https://github.com/dselsam/lean-python-bindings\">Python bindings for Lean</a> which does something like this.  Others have mentioned that the LSP handles stuff like this.  It would be great to discuss this more concretely.  <strong>Is there a clear path to implementing something like this in Lean 3?  (It doesn’t need to be that fast, so we should try the easiest to implement idea first I think.)  Will this be easier in Lean 4?</strong></li>\n</ol>",
        "id": 186014952,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579387587
    },
    {
        "content": "<p>I looked a bit into <a href=\"https://github.com/dselsam/lean-python-bindings\" target=\"_blank\" title=\"https://github.com/dselsam/lean-python-bindings\">Daniel's old Python bindings for Lean</a>.  They aren't documented, but the test code gives a hint at what they can do.  It looks promising.  However, I can't get them installed correctly.  (It is probably my own not understanding C++ and other things involved in the install.)  Someone suggested also that the bindings may not work with current Lean.  Has anyone got them to work recently?</p>",
        "id": 186070121,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579488891
    },
    {
        "content": "<p>Also, I think I said something wrong about LSP.  I suggested that Lean 3 uses LSP.  That will be Lean 4 I guess.  Lean 3 I guess can communicate with <code>lean --server</code> <a href=\"#narrow/stream/113488-general/topic/guides/near/184985918\" title=\"#narrow/stream/113488-general/topic/guides/near/184985918\">by sending JSON messages via STDIN and reading JSON responses from STDOUT</a>.  It seems that one can deduce the Lean 3 message format from the <a href=\"https://github.com/leanprover/lean-client-js/tree/master/lean-client-js-core/\" target=\"_blank\" title=\"https://github.com/leanprover/lean-client-js/tree/master/lean-client-js-core/\">lean-client-js-core</a> package.  Honestly, this is getting outside my wheelhouse, so I would have to do a lot of digging and learning to figure out how this all works.  However, if I do, I'll try to write some descriptions of what is possible here and if it fits the needs of something like DeepHOL.</p>",
        "id": 186070522,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579489764
    },
    {
        "content": "<p>Feel free to ask here if you've got questions about Lean 3's server mode!</p>",
        "id": 186070634,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1579489997
    },
    {
        "content": "<p>you can observe the Lean 3 server protocol in Emacs by enabling <code>M-x lean-turn-on-debug-mode</code></p>",
        "id": 186071195,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1579491056
    },
    {
        "content": "<p>You can also see it action in the <a href=\"https://leanprover-community.github.io/lean-web-editor/\" target=\"_blank\" title=\"https://leanprover-community.github.io/lean-web-editor/\">community web editor</a> if you click the question mark and scroll down to the \"Debug settings\" and then open your browser's console.</p>",
        "id": 186071312,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1579491266
    },
    {
        "content": "<p>Taking <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>'s advice, I looked at Lean's server mode through the <a href=\"https://leanprover-community.github.io/lean-web-editor/\" target=\"_blank\" title=\"https://leanprover-community.github.io/lean-web-editor/\">community web editor</a>.  First, I could only get it to work on Firefox (it didn't work on Safari or Chrome on my Mac).  Second, when <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> says my \"browser's console\", that means go to Tools &gt; Web Developer &gt; Web Console.</p>",
        "id": 186143472,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579567062
    },
    {
        "content": "<p>From my limited experimentation, there appears to be three requests one can make of the server, \"info\", \"sync\", and \"complete\".  I'm still trying to figure out what these three do.  I should probably next try to interact directly with the Lean3 server via python.  Until I do that, it appears that \"sync\" does most of the heavy lifting.  It appears to send the whole file contents.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n  <span class=\"nt\">&quot;command&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;sync&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;file_name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;/test.lean&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;content&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;example (m n : ℕ) : m + n = n + m :=\\nby refl&quot;</span><span class=\"p\">,</span>\n  <span class=\"nt\">&quot;seq_num&quot;</span><span class=\"p\">:</span> <span class=\"mi\">40</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>And then one gets back responses about the state of the file, including messages about tactics which don't work.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"p\">{</span>\n  <span class=\"nt\">&quot;msgs&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span>\n      <span class=\"nt\">&quot;caption&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;&quot;</span><span class=\"p\">,</span>\n      <span class=\"nt\">&quot;file_name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;/test.lean&quot;</span><span class=\"p\">,</span>\n      <span class=\"nt\">&quot;pos_col&quot;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span>\n      <span class=\"nt\">&quot;pos_line&quot;</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n      <span class=\"nt\">&quot;severity&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;error&quot;</span><span class=\"p\">,</span>\n      <span class=\"nt\">&quot;text&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;invalid apply tactic, failed to unify\\n  m + n = n + m\\nwith\\n  ?m_2 = ?m_2\\nstate:\\nm n : ℕ\\n⊢ m + n = n + m&quot;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">],</span>\n  <span class=\"nt\">&quot;response&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;all_messages&quot;</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>The \"info\" command seems for getting more information about variable types, squiggly lines, and other information displayed in the side bar.  I think the \"complete\" command is for autocompletion.  (Again, using a Python (or other) client to manually communicate with <code>lean --server</code> would make all this more clear.)</p>",
        "id": 186143475,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579567070
    },
    {
        "content": "<p>If the \"sync\" command is the natural way to use try out tactics on a goal via Lean3 server, that would be a pretty blunt tool, but could be workable.  One could enter the goal with a hole (e.g. <code>example (m n : ℕ) : m + n = n + m := begin end</code>).  Then one can try filling in the hole with various tactics and see what the responses are, including the new goal state (e.g. enter <code>example (m n : ℕ) : m + n = n + m := begin induction n end</code>).  However, it seems that the agent would have to interact with the actual Lean code and parse the pretty printed human readable responses (e.g. the agent would have to parse: <code>\"tactic failed, there are unsolved goals\\nstate:\\n2 goals\\ncase nat.zero\\nm : ℕ\\n⊢ m + 0 = 0 + m\\n\\ncase nat.succ\\nm n_n : ℕ,\\nn_ih : m + n_n = n_n + m\\n⊢ m + nat.succ n_n = nat.succ n_n + m\"</code>).  This isn't impossible.  There are only a few message templates the agent would have to deal with and possibly one could turn off some pretty printers to make the formulas more machine readable.  Nonetheless, I think something like the Python bindings look more promising.</p>",
        "id": 186143481,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579567080
    },
    {
        "content": "<p>Am I understanding this correctly, <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>?</p>",
        "id": 186143525,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579567096
    },
    {
        "content": "<p>With pretty printing, the goal mentioned above is:</p>\n<div class=\"codehilite\"><pre><span></span>tactic failed, there are unsolved goals\nstate:\n2 goals\ncase nat.zero\nm : ℕ\n⊢ m + 0 = 0 + m\ncase nat.succ\nm n_n : ℕ,\nn_ih : m + n_n = n_n + m\n⊢ m + nat.succ n_n = nat.succ n_n + m\n</pre></div>\n\n\n<p>After setting <code>set_option pp.all true</code>, it becomes</p>\n<div class=\"codehilite\"><pre><span></span>tactic failed, there are unsolved goals\nstate:\n2 goals\ncase nat.zero\nm : nat\n⊢ @eq.{1} nat (@has_add.add.{0} nat nat.has_add m nat.zero) (@has_add.add.{0} nat nat.has_add nat.zero m)\n\ncase nat.succ\nm n_n : nat,\nn_ih : @eq.{1} nat (@has_add.add.{0} nat nat.has_add m n_n) (@has_add.add.{0} nat nat.has_add n_n m)\n⊢ @eq.{1} nat (@has_add.add.{0} nat nat.has_add m (nat.succ n_n)) (@has_add.add.{0} nat nat.has_add (nat.succ n_n) m)\n</pre></div>\n\n\n<p>which is fairly machine parsable (on a level similar to the s-expressions used by HOList/DeepHOL).  Given that tools like HOList don't need the fastest server, it would be interesting to see if something like the HOList server interface could be built from the Lean server.</p>",
        "id": 186144329,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579568538
    },
    {
        "content": "<p>Most of what you wrote about the commands looks correct to me. There are actually a few more commands like \"search\" and \"hole\", that are used for text editor integration. If you can read typescript, you can also get an idea of the interface for the server commands by browsing <a href=\"https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/server.ts\" target=\"_blank\" title=\"https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/server.ts\">this</a> and <a href=\"https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/commands.ts\" target=\"_blank\" title=\"https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/commands.ts\">this</a> from <code>lean-client-js-core</code>.</p>\n<blockquote>\n<p>However, it seems that the agent would have to interact with the actual Lean code and parse the pretty printed human readable responses</p>\n</blockquote>\n<p>I'm not a Lean metaprogramming expert, but I think it should be possible to write meta code which will return whatever info you want in machine-readable form as well. For instance, the info in the error messages you quoted is available from <code>tactic.local_context</code>. See <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md\">mathlib's \"tactic writing\" tutorial</a> for some more info.</p>\n<p>The hole commands might also be interesting to you, since they let you trigger Lean meta code at positions in the code (\"holes\") that are surrounded by <code>{!</code> and <code>!}</code>. Among other things, you can write meta code which returns a string in the \"replacements\" field of the response message; you might be able to use this to query Lean for something you're interested in and return it in JSON or some other format. <a href=\"https://github.com/leanprover-community/mathlib/blob/ff2a41e4579d2238b8864e2bd072831a2006a808/docs/holes.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/ff2a41e4579d2238b8864e2bd072831a2006a808/docs/holes.md\">Here's</a> some docs on the hole commands provided by mathlib.</p>",
        "id": 186144616,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1579569014
    },
    {
        "content": "<p>Ok interesting.  Thanks!</p>",
        "id": 186144989,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579569549
    },
    {
        "content": "<p>From what I recall, if you've used Lean from inside VS Code/emacs, you've pretty much directly experienced all the functionality the server mode has to offer</p>",
        "id": 186146224,
        "sender_full_name": "Reid Barton",
        "timestamp": 1579571496
    },
    {
        "content": "<p>The more I think about it, this VS Code/emacs functionality is probably all that is needed to reproduce something like the HOList interface.  I think the only added thing would be to use a small amount of custom meta programming to get the outputs (such as the current goal state after applying a tactic) in the most useful form.  (And even this is optional since the current text outputs are fairly useful and parsable.)  The only worries I have is that (1) it is not fast enough, and (2) the idea I have of how to implement it is too hacky.  Maybe I'll sketch out my idea soon since it is pretty straightforward.</p>",
        "id": 186146645,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579572233
    },
    {
        "content": "<p>Here is how one could implement something very similar to HOList’s API but for Lean, using the Lean server.  (As with the HOList API, I am assuming tactics are only applied to single goals and not to lists of goals.)</p>",
        "id": 186178485,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579610498
    },
    {
        "content": "<p>The HOList API has an <code>ApplyTactic</code> request which sends a goal and a tactic command (with parameters).  The response is either a success or failure.  A success returns the new goal state. In the Lean Server (ignoring right now the details of how to represent formulas), all I would have to do is take my goal:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">m</span> <span class=\"n\">n_n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">n_ih</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n_n</span> <span class=\"bp\">=</span> <span class=\"n\">n_n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span>\n<span class=\"err\">⊢</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n_n</span> <span class=\"bp\">=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n_n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span>\n</pre></div>\n\n\n<p>and my tactic (plus parameters) <code>induction m</code>.<br>\nNext, I convert this all to an <code>example</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n_n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">n_ih</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n_n</span> <span class=\"bp\">=</span> <span class=\"n\">n_n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n        <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n_n</span> <span class=\"bp\">=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n_n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">induction</span> <span class=\"n\">m</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I put this in a file and run sync on it.</p>",
        "id": 186178492,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579610509
    },
    {
        "content": "<p>Implementing HOList’s <code>VerifyProof</code> request is even more straight forward.  It is given a theorem (e.g. <code>⊢ ∀  m n : nat, m + n = n + m</code>) and a proof which is a list of tactics (with parameters) (e.g. [<code>intro</code>, <code>intro</code>, <code>simp</code>]) and returns whether that proof succeeds.  Just put it into a file and check it with the server:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>  <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span><span class=\"bp\">;</span>\n<span class=\"n\">intro</span><span class=\"bp\">;</span>\n<span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 186178541,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579610523
    },
    {
        "content": "<p>Finally there is HOList’s <code>RegisterTheorem</code>.  If one is using it to register a theorem (e.g. <code>(m n_n : ℕ) ⊢ m + n = n + m</code>) one just needs to enter the theorem into Lean with a unique identifier.  If one is ok with sorries, then</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">thm_1862938746298</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n_n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>If like HOList, one wants to use the proof from VerifyProof (see my documentation of the HOList API), then use the proof (just [<code>simp</code>] in this case):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">thm_1862938746298</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n_n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>These registered theorems should probably go in another file so they don’t have to be checked every time.</p>",
        "id": 186178558,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579610534
    },
    {
        "content": "<p>Also, there is adding definitions via <code>RegisterTheorem</code>.  Again, this seems straight forward.</p>",
        "id": 186178568,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579610548
    },
    {
        "content": "<p>It think the next thing would be to try this out (calling the Lean server as above) in a simple Python client to make sure it works.</p>",
        "id": 186178574,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579610556
    },
    {
        "content": "<p>I’m not saying this will 100% fulfill the HOList API since that was intended for HOL Light, but it will get 90% of the way there.  Then we can have a discussion about the other 10%.  (Ok, maybe that remaining 10% will take 90% of the time.  One still needs to catalog the Lean tactics and their parameters for example.)</p>",
        "id": 186178580,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579610564
    },
    {
        "content": "<p>We would be super happy to help supporting Lean from HOList. End of last October I asked Daniel Selsam his opinion of integration. <br>\nHe suggested us to wait until Lean 4 is ready (suggested that it would take several months on their side to get there) . </p>\n<p>I think that given the relative simplicity of our interface and the HOL Light interface as a template, it should not be a huge amount of work to integrate Lean with HOList and our team would be very happy to support this integration on our side.</p>",
        "id": 186228304,
        "sender_full_name": "Christian Szegedy",
        "timestamp": 1579641272
    },
    {
        "content": "<p>The official line of MIcrosoft Research does seem to be “wait until Lean 4”, and this makes sense.  It is a waste of their time to support Lean 3.  Nonetheless, there is a large and vibrant community using (and hacking) Lean 3, and it isn’t unreasonable to build something in Lean 3.  If nothing else, it helps make clear what we need in Lean 4.  From my investigation so far it is plausible that the lean server can be used to implement something like HOList for Lean 3.  (And there would be no need to fork Lean.)  IMO, after building a hacked together Lean 3 to DeepHOL interface (which lives safely in a Docker container), that would provide a template for a more flexible Lean-to-MLGym interface that would satisfy more researcher’s needs.</p>",
        "id": 186236639,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579646947
    },
    {
        "content": "<p>Speaking as someone who's both hacking on Lean 3.5 and Lean 4, I don't see using Lean 3 as a waste of time.</p>",
        "id": 186237107,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1579647307
    },
    {
        "content": "<p>Porting code from Lean 3 to Lean 4 might not be completely straightforward but what you learned about Lean 3 should be transferable to Lean 4. Lean 4 is really an attempt at making all the goodies that the community loves in Lean 3 even better. If you discover a pain point (that others haven't discovered) you can already point it out and it could get better in Lean 4</p>",
        "id": 186237316,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1579647475
    },
    {
        "content": "<p>(I say \"it could get better\" because it has to fit in the overall vision of Lean 4, we won't introduce ML-style modules for instance)</p>",
        "id": 186237434,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1579647560
    },
    {
        "content": "<p>Interacting with the Lean server is basically how Rob and I implemented the interface between Lean 3 and Mathematica. Jesse and I had also discussed the possibility of doing this for ML at last year’s ITP. Talking to Lean server should be fine, the challenging part is parsing and managing proof states from what’s returned from Lean. For that we probably want some meta-programs to do it for us, and that’s why Jesse and I have also decided (for now) to wait until Lean 4 to see if there are new meta-level tools to use.</p>",
        "id": 186237459,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1579647592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> I've been playing around with the lean server.  The good news is that I can get it to behave in a back-and-forth manner where I feed it a goal and a tactic and it tells me if that tactic succeeds and what the goal state is.  The bad news is that it is really slow.  The only way I can reliably get it to work is to:</p>\n<ul>\n<li>feed in my partial proof to a \"sync\" request</li>\n<li>wait for it to send back an \"all_messages\" response</li>\n<li>parse that response</li>\n</ul>\n<p>This takes consistently about .1 seconds which is REALLY slow for this sort of simple round trip. I thought I can use the \"info\" request instead (which is much faster), but that is unreliable.  The response to an info request is often referencing a previous version of the file before the sync request.  Do you know of a faster way, or is this a fundamental limitation of the lean server that it takes .1 seconds to fully process a sync request.</p>",
        "id": 186555403,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579923604
    },
    {
        "content": "<p>Also, a way to make the info request reliable is to use a new file for each call, but again if I do that it is still 0.1 seconds per call, so there is no speed up to use the \"info\" request.</p>",
        "id": 186555577,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579923982
    },
    {
        "content": "<p>For Google research, I think 0.1 seconds would be fine (and I understand that some tactics would inherently take a while to execute), but it would make it hard for us mere mortals to do cool stuff.</p>",
        "id": 186555858,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579924591
    },
    {
        "content": "<p>Unfortunately I don't know of a faster way. Maybe <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> might have ideas?</p>",
        "id": 186556185,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1579925209
    },
    {
        "content": "<p>And, either way, I'll play more with this and put some simple code on GitHub in the hopes that:</p>\n<ul>\n<li>Someone with a lot of computing power (e.g. Google research) can make use of it</li>\n<li>Someone who knows better can tell me a faster way</li>\n<li>Those building Lean 4 know what the sort of things those in ML would like to be able to do.</li>\n</ul>",
        "id": 186556257,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579925388
    },
    {
        "content": "<p>I think the more sustainable option is to hack lean to have an appropriate RPC or FFI interface</p>",
        "id": 186557120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1579927265
    },
    {
        "content": "<p>I was worried someone would say that.  I know Daniel Selsam has some old hacked <a href=\"https://github.com/dselsam/lean-python-bindings\" target=\"_blank\" title=\"https://github.com/dselsam/lean-python-bindings\">Lean python bindings</a> (which I don't think currently work).  I don't know if those might be along the same lines.  Anyway, I don't think I'm going to start mucking in the Lean C++ code soon, but someone else is welcome and encouraged to try.</p>",
        "id": 186559313,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579931792
    },
    {
        "content": "<p>Ok, with batching (sending about 32 multiple goals/tactics to the same sync request) gives me about a 15x speedup.  I don't know that I can do much better with the Lean server, but 7 ms does seem more reasonable than 100 ms.</p>",
        "id": 186588867,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579986704
    },
    {
        "content": "<p>By comparison, HOList takes about 3ms, so it is comparable (but that is without batching).</p>",
        "id": 186588922,
        "sender_full_name": "Jason Rute",
        "timestamp": 1579986802
    },
    {
        "content": "<blockquote>\n<p>For Google research, I think 0.1 seconds would be fine (and I understand that some tactics would inherently take a while to execute), but it would make it hard for us mere mortals to do cool stuff.</p>\n</blockquote>\n<p>Currently our timeout for proving is 5 seconds, because we make heavy use of the MESON tactic. We have a lot of other overhead, especially neural networks become the bottleneck if we go to sub-second range. We are perfectly fine with 0.1 second for now.</p>",
        "id": 186742467,
        "sender_full_name": "Christian Szegedy",
        "timestamp": 1580172474
    },
    {
        "content": "<blockquote>\n<p>Currently our timeout for proving is 5 seconds, because we make heavy use of the MESON tactic. We have a lot of other overhead, especially neural networks become the bottleneck if we go to sub-second range. We are perfectly fine with 0.1 second for now.</p>\n</blockquote>\n<p>On that note, are these the default config on the docker image?</p>",
        "id": 186760471,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580198639
    },
    {
        "content": "<p>Ok, for those interested, here is a <a href=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\" target=\"_blank\" title=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\">prototype of communicating with Lean via the Lean Server from an external program</a>.    It looks like it is possible to implement a Lean version of HOList's <code>ApplyTactic</code> request.  I think the next step would be to see if we can get a list of all Lean theorems and if we can plug them into this interface (specifically see if we can run the do-nothing <code>skip</code> tactic on the theorem goal).  I'm not entirely happy with how this turned out.  The Lean server is really not intended for this purpose and had to be fought with a lot, but I think it works now (if a bit slowly).</p>",
        "id": 186839725,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580252713
    },
    {
        "content": "<p>Also, if anyone is interested in using the Lean server for another purpose (other than a text editor/IDE) I hope this would give them inspiration.</p>",
        "id": 186840485,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580253354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> I think you told me you can get a List of all theorems from the environment.  How does one do this?</p>",
        "id": 186840703,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580253579
    },
    {
        "content": "<p>Don't have time to go into detail now, but look at the implementation of <code>library_search</code>, which does exactly this.</p>",
        "id": 186840788,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1580253645
    },
    {
        "content": "<p>You can also find similar implementation in our Mathematica-Lean link repo</p>",
        "id": 186841186,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580254056
    },
    {
        "content": "<p><a href=\"https://github.com/minchaowu/mm-lean/blob/master/src/dump.lean\" target=\"_blank\" title=\"https://github.com/minchaowu/mm-lean/blob/master/src/dump.lean\">https://github.com/minchaowu/mm-lean/blob/master/src/dump.lean</a></p>",
        "id": 186841188,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580254061
    },
    {
        "content": "<p>By the way, we’ve done similar things (i.e., an interface with experimental RL results) to HOL4, which is to appear in this year’s AITP.</p>",
        "id": 186841353,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580254211
    },
    {
        "content": "<p>Oh cool.  I look forward to reading all the slides and abstracts from AITP this year.</p>",
        "id": 186843148,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580255641
    },
    {
        "content": "<p>Also, <span class=\"user-mention\" data-user-id=\"110187\">@Minchao Wu</span>, did you interface with Mathematica in a similar way to how I did it above?  You used the lean server, right?</p>",
        "id": 186843368,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580255775
    },
    {
        "content": "<p>Yes, it works the same way as I can see from you repo, except that there is no python scripts involved. The Lean server subprocess is handled directly by Mathematica.</p>",
        "id": 186843645,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580255966
    },
    {
        "content": "<p>We also called the virtual file \"dummy.lean\" :-)</p>",
        "id": 186843896,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580256114
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110187\">@Minchao Wu</span> !  Your code has been very helpful, but it also points out a number of subtle flaws in my current implementation.  I was too quick to claim victory. :(</p>\n<ul>\n<li>I don't handle universes, so if I try to put in the goal <code>Π {α : Sort u} {a : α} {p : α → Sort v} {b : α}, a == b → p a → p b</code>, Lean will complain about <code>u</code> and <code>v</code>.  I could store the universes with the goal, and use a section to enter them, so that isn't a huge deal-breaker.</li>\n<li>Lean's pretty printed goal output is not necessarily valid lean code.  Example, this is the Lean pretty printed theorem, but <code>∀ (s : list char), string.mk_iterator {data := s} = {fst := list.nil char, snd := s}</code> is not valid Lean.  The problem is that in <code>list.nil char</code>, the <code>char</code> is implicit (the type of <code>list.nil</code> is <code>Π {T : Type}, list T</code>).  I would have to know to enter it as <code>@list.nil char</code> or know that the <code>char</code> can be inferred.  Similarly, <code>and.symm = and.swap</code> isn't valid Lean.  It needs to be <code>∀ a b : Prop, @and.symm a b = @and.swap a b</code></li>\n<li>Without knowing the theorems exact place, Lean can't fill in type classes.  For example, if I try to enter <code>∀ (c : Prop) [_inst_1 : decidable c] (a b : ordering), ite c a b = ordering.gt = ite c (a = ordering.gt) (b = ordering.gt)</code> I get complaints about \"failed to synthesize type class instance [...]\".</li>\n<li>This isn't a problem with my app, but it should be noted that auto-generated equation theorems for definitions and type class instances get outputted in the dump.  For example,<code> ∀ {α : Type u₁} {β : Type u₂} (a : α) (b : β), combinator.K a b = a</code> and <code>∀ {α : Type u}, list.has_append = {append := list.append α}</code>.  They aren't really something that is \"provable\" except using themselves.  At least <code>refl</code> solves them.</li>\n</ul>",
        "id": 186857523,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580275800
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116045\">Jesse Michael Han</span> I think you told me you can get a List of all theorems from the environment.  How does one do this?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  you can do something like this in Lean (the code in <code>library_search</code> is a bit more specialized, but essentially does the same thing):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">process_thm</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">declaration</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">declaration</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">to_name</span> <span class=\"k\">in</span>\n  <span class=\"k\">if</span> <span class=\"bp\">¬</span> <span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">is_trusted</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">is_internal</span> <span class=\"k\">then</span> <span class=\"n\">none</span>\n  <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n       <span class=\"bp\">|</span> <span class=\"n\">declaration</span><span class=\"bp\">.</span><span class=\"n\">defn</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n       <span class=\"bp\">|</span> <span class=\"n\">t</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">declaration</span><span class=\"bp\">.</span><span class=\"n\">thm</span> <span class=\"n\">n</span> <span class=\"n\">ns</span> <span class=\"n\">e</span> <span class=\"n\">te</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">t</span>\n       <span class=\"bp\">|</span> <span class=\"n\">declaration</span><span class=\"bp\">.</span><span class=\"n\">cnst</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n       <span class=\"bp\">|</span> <span class=\"n\">declaration</span><span class=\"bp\">.</span><span class=\"n\">ax</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n       <span class=\"kn\">end</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">library_thms</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"err\">$</span> <span class=\"n\">list</span> <span class=\"n\">declaration</span> <span class=\"o\">:=</span>\n  <span class=\"n\">environment</span><span class=\"bp\">.</span><span class=\"n\">decl_filter_map</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">get_env</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">return</span> <span class=\"n\">process_thm</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">list_all_theorems</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">do</span> <span class=\"n\">library_thms</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">declaration</span><span class=\"bp\">.</span><span class=\"n\">to_name</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">run_cmd</span> <span class=\"n\">list_all_theorems</span>\n</pre></div>",
        "id": 186859952,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1580279943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Did you look at how format_lean and the lean crawler handle all those issues? <a href=\"https://github.com/leanprover-community/leancrawler\" target=\"_blank\" title=\"https://github.com/leanprover-community/leancrawler\">leancrawler</a> is entirely devoted to listing declarations and statistics about them. And <a href=\"https://github.com/leanprover-community/format_lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/format_lean\">format_lean</a> does need tactic state information from python, implementing a very rough interface at <a href=\"https://github.com/leanprover-community/format_lean/blob/master/src/format_lean/server.py\" target=\"_blank\" title=\"https://github.com/leanprover-community/format_lean/blob/master/src/format_lean/server.py\">https://github.com/leanprover-community/format_lean/blob/master/src/format_lean/server.py</a>.</p>",
        "id": 186864181,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580285552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  The issues you mentioned are exactly some of the many reasons we prefer to delay the implementation until Lean 4. There could be even more issues with parsing and managing proof states, e.g., sometimes you might also see meta-variables occurring in the local context so that you can't directly send them back (as-is) to Lean as assumptions. <br>\nFor toy examples, the hardcore parsing as you have done would work well, but for serious theorems we probably need a more robust (and fast) system. It seems to me that the ideal way of doing it is having a Lean meta-program that manages proof states for us, and return directly Python-readable objects containing the information we need. In that case, Python only needs to be responsible for sending proper requests and doing machine learning.</p>",
        "id": 186876591,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580297027
    },
    {
        "content": "<p>Also this is why we prefer systems that implement a simple type theory (at current stage). Too much information about types not only increases the amount of knowledge the agent needs to learn, but also complicates proof states management.</p>",
        "id": 186876802,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580297215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110187\">@Minchao Wu</span>  When you say \"the hardcore parsing\", do you mean parsing the whole syntax tree of the expression?  (I assume if we have that, we could reconstruct the expression in Lean, but even then I'm not sure if it has everything to unambiguously do that.)</p>",
        "id": 186886365,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580305458
    },
    {
        "content": "<p>I mean parsing the pretty-printed responses from the server on the Python side</p>",
        "id": 186886846,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580305882
    },
    {
        "content": "<blockquote>\n<p>...but even then I'm not sure if it has everything to unambiguously do that.)</p>\n</blockquote>\n<p>Yes, hopefully Lean 4 would offer us more tools.</p>",
        "id": 186887038,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580306025
    },
    {
        "content": "<p>What is it that Lean 4 will provide that Lean 3 doesn’t have?  That is not clear to me.</p>",
        "id": 186887896,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580306692
    },
    {
        "content": "<p>I don't know, either. But there could be more well-documented meta constants that expose more internal stuff.</p>",
        "id": 186888226,
        "sender_full_name": "Minchao Wu",
        "timestamp": 1580306958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110187\">@Minchao Wu</span>  More experiments are needed, but if I work with the Lean expressions themselves, then my above issues go away.  It might still not cover all (or most?) cases, but I think it is worth exploring more...</p>",
        "id": 186940896,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580341511
    },
    {
        "content": "<p>For example, the following code allows me to create a goal from an expression.</p>\n<div class=\"codehilite\"><pre><span></span>meta def make_goal_from_expression (e : expr) : tactic unit :=\ndo\n   v &lt;- tactic.mk_meta_var e,\n   gs &lt;- tactic.get_goals,\n   tactic.set_goals $ v :: gs,\n   t &lt;- tactic.target,\n   tactic.trace t,\n   return ()\n\nmeta def my_expr : expr :=  ( expr.pi ( name.mk_string &quot;c&quot; name.anonymous ) binder_info.default  ( expr.sort level.zero ) ( expr.pi ( name.mk_string &quot;_inst_1&quot; name.anonymous ) binder_info.inst_implicit ( expr.app ( expr.const ( name.mk_string &quot;decidable&quot; name.anonymous ) list.nil ) ( expr.var 0 ) ) ( expr.pi ( name.mk_string &quot;a&quot; name.anonymous ) binder_info.default  ( expr.const ( name.mk_string &quot;ordering&quot; name.anonymous ) list.nil ) ( expr.pi ( name.mk_string &quot;b&quot; name.anonymous ) binder_info.default  ( expr.const ( name.mk_string &quot;ordering&quot; name.anonymous ) list.nil ) ( expr.app ( expr.app ( expr.app ( expr.const ( name.mk_string &quot;eq&quot; name.anonymous ) ( list.cons ( level.succ level.zero ) list.nil ) ) ( expr.sort level.zero ) ) ( expr.app ( expr.app ( expr.app ( expr.const ( name.mk_string &quot;eq&quot; name.anonymous ) ( list.cons ( level.succ level.zero ) list.nil ) ) ( expr.const ( name.mk_string &quot;ordering&quot; name.anonymous ) list.nil ) ) ( expr.app ( expr.app ( expr.app ( expr.app ( expr.app ( expr.const ( name.mk_string &quot;ite&quot; name.anonymous ) ( list.cons ( level.succ level.zero ) list.nil ) ) ( expr.var 3 ) ) ( expr.var 2 ) ) ( expr.const ( name.mk_string &quot;ordering&quot; name.anonymous ) list.nil ) ) ( expr.var 1 ) ) ( expr.var 0 ) ) ) ( expr.const ( name.mk_string &quot;gt&quot; ( name.mk_string &quot;ordering&quot; name.anonymous ) ) list.nil ) ) ) ( expr.app ( expr.app ( expr.app ( expr.app ( expr.app ( expr.const ( name.mk_string &quot;ite&quot; name.anonymous ) ( list.cons ( level.succ level.zero ) list.nil ) ) ( expr.var 3 ) ) ( expr.var 2 ) ) ( expr.sort level.zero ) ) ( expr.app ( expr.app ( expr.app ( expr.const ( name.mk_string &quot;eq&quot; name.anonymous ) ( list.cons ( level.succ level.zero ) list.nil ) ) ( expr.const ( name.mk_string &quot;ordering&quot; name.anonymous ) list.nil ) ) ( expr.var 1 ) ) ( expr.const ( name.mk_string &quot;gt&quot; ( name.mk_string &quot;ordering&quot; name.anonymous ) ) list.nil ) ) ) ( expr.app ( expr.app ( expr.app ( expr.const ( name.mk_string &quot;eq&quot; name.anonymous ) ( list.cons ( level.succ level.zero ) list.nil ) ) ( expr.const ( name.mk_string &quot;ordering&quot; name.anonymous ) list.nil ) ) ( expr.var 0 ) ) ( expr.const ( name.mk_string &quot;gt&quot; ( name.mk_string &quot;ordering&quot; name.anonymous ) ) list.nil ) ) ) ) ) ) ) )\n\nrun_cmd make_goal_from_expression my_expr\n</pre></div>\n\n\n<p>The trace is correctly:</p>\n<div class=\"codehilite\"><pre><span></span>∀ (c : Prop) [_inst_1 : decidable c] (a b : ordering), ite c a b = ordering.gt = ite c (a = ordering.gt) (b = ordering.gt)\n</pre></div>",
        "id": 186941210,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580341800
    },
    {
        "content": "<p>Right now I see ways to do what I am trying to do:</p>\n<ol>\n<li>Use the Lean server and work directly with Lean syntax.  This is flexible and easy to enter and play with stuff, but quickly runs into parsing problems.</li>\n<li>Use the Lean server but work with plain text of Lean expressions for the goals.  It is no longer human readable, but works more robustly.  It is still possible to enter tactics as plain text, but that might have similar issues with robustness.</li>\n<li>Use a lean program to enter serialized expressions.  This is really fast and robust.  The problem is that I don't think it is easy to enter the tactics in such an easy way.  We would have to create a custom syntax for tactics, but this is what HOList does already, so it would be similar.  This is my vote, but I think I'll build all three.</li>\n</ol>",
        "id": 187044474,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580428432
    },
    {
        "content": "<p>It might not be clear what I'm talking about, but for concreteness, see my <a href=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\" target=\"_blank\" title=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\">recent notebook</a> for (1) and see <a href=\"#narrow/stream/113488-general/topic/Parsing.20a.20string.20into.20an.20expression\" title=\"#narrow/stream/113488-general/topic/Parsing.20a.20string.20into.20an.20expression\">this thread</a> for (3).  I'll try to prototype all three.</p>",
        "id": 187044612,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580428548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> really interesting to follow you progress.  (First wanted to point out that as soon as you have something ready, I'm eager to try it out). Can you elaborate a bit on the parsing problem you encounter with (1)? The speed does not seem too bad at all from what you report on your notebook. I was myself planning to fork format_lean. Are those parsing problems solved there? Why not start with it?</p>",
        "id": 187245741,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580722241
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249373\">@Stanislas Polu</span> Thanks for the encouraging words.  As the \"parsing problems\" I'm referring to, see <a href=\"#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/ML.20for.20Lean.3A.20How.20to.20do.20it.3F/near/186857523\" title=\"#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/ML.20for.20Lean.3A.20How.20to.20do.20it.3F/near/186857523\">above</a>.  However, the more I think about this, I made it sound worse than it is.  One problem is universe levels.  Maybe I just need to add those to my interface.  The main problem is that when I \"dump\" the current theorems of Lean (as training examples), the representation I get can't always be put back into my interface.  However, as I look at this more, if use the more verbose representation given by <code>set_option pp.all true</code> then that works much better.  It is clear to me now that my next step is to dump all the Lean theorems (at least in the core Lean) to a file and test which ones I can enter into my interface successfully.</p>",
        "id": 187261627,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580736607
    },
    {
        "content": "<p>I also have some more comments for you, but I have to run...</p>",
        "id": 187261869,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580736802
    },
    {
        "content": "<p>That sounds super encouraging! I'm still quite busy integrating against holist but as soon as I'm out of the woods on this one I'll gladly land a hand here <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 187263596,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580738109
    },
    {
        "content": "<p>Ok, it sounds like you are busy, but since you mentioned you are eager to try it out, my notebook code is still very usable with a few caveats:</p>\n<ul>\n<li>I need to add support for universes and other binder types.</li>\n<li>I might need to switch to another Lean output format to make it more robust (so that you can more robustly plug the output of one call into the input of the next, avoiding the issues I was talking about in my previous message).</li>\n<li>It is just a bare bones low-level inference to Lean.  You would have to build your own higher-level interface for your purposes.  (However, I did provide an example of breath first search prover as an example of the ideas involved.)  In particular, it doesn't come with any of these features:<ul>\n<li>A library of theorems (for either training examples or premise selection).</li>\n<li>A curated list of tactics or a clear way to specify/enter their parameters (except as plain text).</li>\n</ul>\n</li>\n</ul>\n<p>Nonetheless, you can do a lot with it right away.  If you look at the breath first prover examples, this gives you a clear way to build a learned AI which works for minimal logic.  The tactics <code>apply _</code>, <code>cases _</code>, <code>intro</code>, <code>split</code>, <code>left</code>, and <code>right</code> should be complete for minimal propositional logic.  For intuitionistic propositional logic add the tactic <code>exfalso</code>.  So  you can train an intuitionistic logic AI for example.  You can also look at Buzzard's natural number game for other examples of tactic systems which one could play with.  It all depends what you are going for...</p>",
        "id": 187267803,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580741021
    },
    {
        "content": "<p>I'll work on shoring up this prototype and I'm also working on a different prototype which directly enters the theorems to a Lean program which then parses them and runs the specified tactics.  This has some advantages and disadvantages.  I'm trying to compare and contrast both approaches.  My hope is that after I make my prototypes, someone with more time can turn them into usable systems for their (and other's) needs.</p>",
        "id": 187267969,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580741146
    },
    {
        "content": "<blockquote>\n<p>I might need to switch to another Lean output format to make it more robust (so that you can more robustly plug the output of one call into the input of the next, avoiding the issues I was talking about in my previous message).</p>\n</blockquote>\n<p>That looks very promising! Can you cc me (@spolu) on this diff?</p>\n<blockquote>\n<p>It is just a bare bones low-level inference to Lean. You would have to build your own higher-level interface for your purposes. (However, I did provide an example of breath first search prover as an example of the ideas involved.) In particular, it doesn't come with any of these features:<br>\n-  library of theorems (for either training examples or premise selection).<br>\n- curated list of tactics or a clear way to specify/enter their parameters (except as plain text).</p>\n</blockquote>\n<p>I've seen your BFS example which looks great. First thing I would do is try to get a dump of theorems and their proofs in a format compatible with your environment. That's probably a bit involved but obviously a crucial step to enable ML work beyond pure RL.</p>",
        "id": 187269304,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580742003
    },
    {
        "content": "<p>I don't know that proof recording (at the tactic level) is going to be possible (or at least easy) in Lean 3.   It should be possible to record proofs in terms of basic Lean inference rules (think \"assembly language\" for theorem proving), but not the high level tactics.  (I guess anything is possible if one modifies the C++ code, but I have no idea where to start with this.)  Instead, I'm going to record just the theorem statements.  This would be enough to do reinforcement learning (and when I talked to Markus Rabe, it seems for Google's work, this is all that they need).</p>",
        "id": 187314854,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580770969
    },
    {
        "content": "<p>Of course, if there is a way to record proofs, this is the place to ask.  Does anyone know a way to record tactic-proofs?</p>",
        "id": 187314886,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580771004
    },
    {
        "content": "<p>Isn't the interaction demonstrated in format_lean[0] enough to record proofs. For each statement we have the tactic state it is applied to and the tactic sate it maps to? <br>\n[0] <a href=\"https://leanprover-community.github.io/format_lean/example/sandwich.html\" target=\"_blank\" title=\"https://leanprover-community.github.io/format_lean/example/sandwich.html\">https://leanprover-community.github.io/format_lean/example/sandwich.html</a></p>",
        "id": 187343805,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580810084
    },
    {
        "content": "<blockquote>\n<p>Instead, I'm going to record just the theorem statements. This would be enough to do reinforcement learning (and when I talked to Markus Rabe, it seems for Google's work, this is all that they need).</p>\n</blockquote>\n<p>This is a very specific (and therefore somewhat limited) approach to AITP, I think it would be an error to over-index on that statement. Yes RL on statements works for Hammer-ish / Premise-selection-only type of automated theorem proving, but that's not everything there is to automated theorem proving, especially in Lean.</p>",
        "id": 187344191,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580810438
    },
    {
        "content": "<p>First, to be clear, I was ignoring proof recording because (1) I didn't think it was easy and (2) we can do a lot without it (how much remains to be seen, but I don't think one can say with certainty that reinforcement learning only works on some types of projects and not others).  If it is indeed easy to get that data, then of course I want it!  (Also, remember that Lean proofs are human written and Lean hasn't been around for that long.  Right now I count about 8300 occurrences of the <code>theorem</code> keyword in mathlib.  I'm not sure it that is enough training data or not.)</p>",
        "id": 187353422,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580818785
    },
    {
        "content": "<p>Now as for getting the theorem data, so far I have been using the above mentioned approaches which are internal to Lean (i.e. looking at the Lean environment for all the declared theorems.)  I hadn't considered doing it externally to Lean (i.e. using the Lean server to look at each line of a proof).  This is very interesting and I'm curious how well it works.  I think it would be fiddly, but it probably is the best option we have.  As an implementation detail, recall that Lean proofs don't have to be linear, so one has to take into account nested structure.  Also, recall that not all proofs are tactic proofs, some are term-mode proofs.  (The <code>format_lean</code> approach might be a bit simplistic in that it seems that the human tells the formatter where to look by adding comments to the Lean file.  We would need something that looks at the Lean file automatically, but I agree it is promising.)</p>",
        "id": 187354504,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580819770
    },
    {
        "content": "<p>For now I am just going to focus on the bare essentials of getting the theorems and premises, but if you can get proof recording to work, I'm glad to help were I can.</p>",
        "id": 187354536,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580819821
    },
    {
        "content": "<blockquote>\n<p>Right now I count about 8300 occurrences of the <code>theorem</code> keyword in mathlib.  I'm not sure it that is enough training data or not.)</p>\n</blockquote>\n<p>Most statements in mathlib are introduced by the <code>lemma</code> keyword.</p>",
        "id": 187357808,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580822836
    },
    {
        "content": "<blockquote>\n<p>The <code>format_lean</code> approach might be a bit simplistic in that it seems that the human tells the formatter where to look by adding comments to the Lean file.  We would need something that looks at the Lean file automatically, but I agree it is promising.</p>\n</blockquote>\n<p>The formatter looks at the beginning and at the end of each line, without human intervention (except maybe that each proof should start with a comment, I don't remember the current status).</p>",
        "id": 187357945,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580822910
    },
    {
        "content": "<p>That being said, <code>format_lean</code> is openly a temporary  hack. We are all waiting for the Lean 4 parser that will give us access to everything, including white spaces and comments. Writing a formatter should be pure joy and much more powerful.</p>",
        "id": 187358099,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1580823006
    },
    {
        "content": "<blockquote>\n<p>Most statements in mathlib are introduced by the lemma keyword.</p>\n</blockquote>\n<p>Ok.  I stand corrected.  I count about 11600 occurrences of the <code>lemma</code> keyword.</p>",
        "id": 187363747,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580827358
    },
    {
        "content": "<blockquote>\n<p>Of course, if there is a way to record proofs, this is the place to ask.  Does anyone know a way to record tactic-proofs?</p>\n</blockquote>\n<p>I guess it depends on exactly what you have in mind, since the set of tactics is extensible, and while the C++-Lean tactic interface is fixed, it's probably lower-level than you want. Also, mathlib-style proofs use a lot of <code>exact</code> and <code>refine</code> with terms (pre-expressions) of nontrivial complexity, maybe because we do not have much automation to deal with those parts of proofs. So the syntax you would need to model is more complicated.</p>",
        "id": 187375204,
        "sender_full_name": "Reid Barton",
        "timestamp": 1580834735
    },
    {
        "content": "<p>In any case, it is certainly possible to do something along these lines by replacing <code>tactic.interactive</code> or <code>begin ... end</code> by your own version. I think the natural number game does something of this sort.</p>",
        "id": 187375314,
        "sender_full_name": "Reid Barton",
        "timestamp": 1580834797
    },
    {
        "content": "<p>Ok, the more I think about it there is this spectrum of how to “record” proof data.  At the most “human” level one can just download all the Lean files as they are.  Of course this doesn’t contain any parsing information or intermediate goal states or any other information private to Lean, but this is the sort of messy data that data scientists and machine learning researchers are used to working with, and one can still learn a lot from this.  On the other extreme is to modify the tactic framework in Lean’s C++ code to record tactics.  It would contain very specific information about tactics and and subgoals, and hopefully let one replay a proof, but it might (???) be a lot of work to implement.  </p>\n<p>The intermediate level seems to be to go through all the proof files and inspect them with the Lean server.  This seems like a good approach and is the one Stanislas is advocating for.  It involves a bit of programming but not too much and one gets information private to Lean about goal states.  </p>\n<p>Even this has two extremes.  Again on the human side, one can treat each line as a “tactic” and just run the Lean server “info” command at the start of each line.  If it shows goals, then you know you are inside a tactic proof and you can record the goals and the “tactic” (i.e. the line), which might be many tactic commands in one line or the partial beginning of a tactic command spanning multiple lines.  Also we wouldn’t be keeping track of the whole proof tree, but just what tactics to apply at each intermediate goal state.  Another thing is that we will have no information about notation, implicits, or other things that Lean keeps track of. Even so, it would be <em>very</em> good training data.  On the more “computer” side one could carefully find the start and end of each tactic command and keep track of the flow status of the proof including universes, term expressions, etc. (maybe using “holes commands”) so that we could replay the whole proof perfectly.   This again seems like a lot of work.</p>\n<p>Anyway, I’d be in favor of doing the happy medium where one runs the Lean server “info” command on every line of a file.  (Then later one could start to modify this to maybe look at commas/semicolons or add some hole commands until the benefits start to outweigh the cost.)</p>",
        "id": 187417353,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580865658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> this seems like the most amenable format to modern machine learning techniques. There's always a trade-off around the granularity of the training signal you get/use. As an example, from past experience, training a model at the kernel level (which would be one of the extreme you propose) is not very efficient because the data is too granular and the number of steps required to complete a proof too high wrt to how errors compound. At the opposite of it, as you mention as well, there's the lean code, but here the data is probably not granular enough and generating a full proof's code in one go is probably just too hard to be achievable at scale (also you give up on \"search\").</p>\n<p>Plugging where the humans operate therefore appears as a sweet spot in that trade-off (which is kind of obvious). I wouldn't worry too much about the data not including all the internal state of Lean; humans don't have access to it either arguably. Also one can always condition its prediction on more data coming from what precedes in the lean file if need be.</p>\n<p>All that to say +1 on your analysis :)</p>",
        "id": 187435714,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580893056
    },
    {
        "content": "<p>To be clear, I don’t think anyone is talking about training at the kernel level (i.e. proof terms).  The suggestions about modifying C++ are about training at the tactic framework level.  I still think in the future, when the tools are available, this is the best approach.  (Of course, even then one can still use the hand-readable pretty printed statements if that is indeed the best representation for training.  One can just save this during the tactic-level proof recording.). However, until that is available, using the lean server to inspect the files seems the right happy medium.</p>",
        "id": 187503707,
        "sender_full_name": "Jason Rute",
        "timestamp": 1580943241
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249373\">@Stanislas Polu</span></p>\n<blockquote>\n<p>This is a very specific (and therefore somewhat limited) approach to AITP, I think it would be an error to over-index on that statement. Yes RL on statements works for Hammer-ish / Premise-selection-only type of automated theorem proving, but that's not everything there is to automated theorem proving, especially in Lean.</p>\n</blockquote>\n<p>DeepHOL-zero does not just focus on lemma selection. We do full proof-search with tactics without imitation. I think we could easily do forward proving without imitation and I have hopes that we can do expression synthesis as well by trying to training on (truncated) sub-trees of theorems or intermediate goal steps.</p>",
        "id": 187517342,
        "sender_full_name": "Christian Szegedy",
        "timestamp": 1580959765
    },
    {
        "content": "<blockquote>\n<p>We do full proof-search with tactics without imitation</p>\n</blockquote>\n<p>Yes totally. Sorry I wasn't implying that you were not producing full proofs, just noting that the proofs rely on TACTIC selection + premise selection which does not, as you rightfully mention, cover term generation.</p>",
        "id": 187535802,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1580984560
    },
    {
        "content": "<p>I improved my prototype notebook which uses the Lean server to make a theorem proving API: <a href=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\" target=\"_blank\" title=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\">https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb</a>  The big changes are to the output format which makes it more robust and I've also added the ability to add universes and imports.  I also added a section mentioning all the current issues I've seen so far.</p>",
        "id": 188289018,
        "sender_full_name": "Jason Rute",
        "timestamp": 1581783095
    },
    {
        "content": "<p>I'm now working on scrapping all of the Lean files.  I should be able to get the following quite easily:</p>\n<ul>\n<li>Every goal state which occurs inside a Lean tactic proof in its pretty printed form (and with a tiny amount more work, in its <code>pp.all</code> form).</li>\n<li>The tactic command (including arguments) used on that goal state.  (Some caveats here: if semicolons are used, that will fuse multiple tactic commands into one.  With more work, I can separate them, but then it starts to get more complicated. Also, it might take some work to make sure I get a complete tactic command with arguments if that tactic command invokes other tactics.  Parentheses matching is the first step.)</li>\n<li>The doc string for each tactic used.  (I don't think I have to manually identify which keywords are tactics verse theorems, etc. which is nice.)</li>\n<li>Meta information about theorems and terms used as tactic arguments.</li>\n</ul>\n<p>This will be a lot of really good information.  Cross your fingers that this works...</p>",
        "id": 188296878,
        "sender_full_name": "Jason Rute",
        "timestamp": 1581797603
    },
    {
        "content": "<p>This is super exciting. Do you already have a plan towards reconstructing proofs interactively?</p>",
        "id": 188318676,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1581843576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249373\">@Stanislas Polu</span> What do you mean by reconstructing proofs interactively (especially the <em>interactively</em> part)?</p>",
        "id": 188322909,
        "sender_full_name": "Jason Rute",
        "timestamp": 1581853260
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> the \"ApplyTactic\" API</p>",
        "id": 188325333,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1581858552
    },
    {
        "content": "<p>Sorry for the late reply <span class=\"user-mention\" data-user-id=\"249373\">@Stanislas Polu</span>.   I certainly have \"ApplyTactic for Lean\" in mind.  I've never had the plan to single-handedly make a system which is at the level needed for HOList level machine learning, but I am trying to prototype all the necessary parts so it is easy for others to make the final system.  If in the end I create a fully-functional system, then great!  To recap, the notebook at <a href=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\" target=\"_blank\" title=\"https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb\">https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb</a> is a prototype for a fairly usable \"state free\" API for Lean.  It however is nowhere near where HOList is.  Here are next steps:</p>\n<ul>\n<li>See how well we can enter goals without the system breaking.  There are a couple of sources of goals: top level declared theorems and intermediate goals used in actual proofs.  I'm experimenting with entering both in and seeing how it goes.</li>\n<li>Come up with a library of tactics.  Unless one wants the user to enter free-form text into the state-free API, we need to come up with a list of the most common tactics, the most common ways to use them, and an API for them.  This is by far the most tedious process.  I'm scrapping all the Lean files and this should give a lot of good data on stuff like this.</li>\n<li>Figure out how to enter premises, local context variables, and other things.  Will we give the user a method to enter premises (and definitions?) or will we be more restrictive and only let the user use theorems already in the environment.</li>\n<li>Make sure the tactics aren't going to cheat and use the theorem to prove the theorem.  Lean's <code>simp</code> tactic isn't really a pure function (its behavior changes as theorems are proved).  This means if we are not careful, <code>simp</code> could solve a goal because that goal was added to simp's list of usable theorems.  I guess a simple step would be to remove all <code>simp</code>-provable (and probably <code>refl</code>-provable) theorems from the list of testing examples.  Another option is to not use <code>simp</code>, but the more restrictive <code>simp only</code>.</li>\n</ul>\n<p>Anyway, I'm slowly working on this in my spare time.  I will also have to take a break for a number of weeks soon.  (Good personal life event coming up!)</p>",
        "id": 188411856,
        "sender_full_name": "Jason Rute",
        "timestamp": 1581980259
    },
    {
        "content": "<p>Also, in a day, I'll be done scrapping the info command on all the Lean files.  If you want access to the data (it's pretty raw!),  let me know.  Besides using it for simple analysis, statistics, and debugging, it would be a perfectly good machine learning data set:  From a goal (pretty-printed with pp.all set to true), predict the next tactic used.  (One can try to predict the tactic parameters too, but for a number of reasons this is still really messy.)</p>",
        "id": 188412227,
        "sender_full_name": "Jason Rute",
        "timestamp": 1581980783
    },
    {
        "content": "<p>Definitely interested in getting access to the data <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 188784079,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1582327100
    },
    {
        "content": "<p>The extraction script, including a decent amount of documentation, is here: <a href=\"https://github.com/jasonrute/lean_info_scrapper\" target=\"_blank\" title=\"https://github.com/jasonrute/lean_info_scrapper\">https://github.com/jasonrute/lean_info_scrapper</a>.  If you want the raw data, let me know your gmail account in a private message, and I can share the data via Google Drive (this seems easiest).  It is less than 100 MB.  I'm working on cleaning the data up to be more useful.</p>",
        "id": 188840347,
        "sender_full_name": "Jason Rute",
        "timestamp": 1582418584
    },
    {
        "content": "<p>Fantastic! I will go through the exercise of running it <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 188844944,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1582425646
    },
    {
        "content": "<p>I need to read this thread in more detail but from what I read, I am curious, <br>\n1) is it worth while developing any RL Environment for any ITP given that HOList exists (or that there seems to be an interest to integrate them to HOList)?<br>\n2) What are the features if HOList as a system itself that are (seem) to be superior to standard RL Gym's?<br>\n3) What are the advantages of integrating Lean (or any ITP) to HOList?<br>\n4) How easy is it to integrate any of these systems to HOList?</p>",
        "id": 197157022,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1589208950
    },
    {
        "content": "<p>Brando I don't understand your question 1. My understanding is that HOList currently can only help you prove theorems in Isabelle/HOL. A reason to build learners that are not HOList is so that you can build one that is compatible with Lean, since you might like to write Lean code and have a computer help.</p>",
        "id": 197214359,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589236944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span>  So is it only possible to incorporate ITPs that are based on higher order logic HOL into HOList? (i.e. is it trivial to incorporate Isabelle?). I was under the impression the environment for HOList only supported HOL Light. I am trying to understand when it makes sense to extend HOList and it's advantages &amp; disadvantages at supporting other ITPs (and when it's worth building a new ITP env from scratch).</p>",
        "id": 197215285,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1589237592
    },
    {
        "content": "<p>Oh I don't actually make any claim that HOList supports Isabelle, I just have always seen references to Isabelle/HOL and never figured out what it is.</p>",
        "id": 197215830,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589237971
    },
    {
        "content": "<p>I have no idea what it would mean to \"extend\" HOList to support Lean</p>",
        "id": 197215848,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589237982
    },
    {
        "content": "<p>My best guess at what one should do is write a thing that interacts with Lean \"from scratch\" by following the design of HOList closely</p>",
        "id": 197216003,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589238014
    },
    {
        "content": "<p>and yeah you might be able to re-use a lot of the code</p>",
        "id": 197216023,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589238029
    },
    {
        "content": "<p>but in the early days you shouldn't expect to usefully share weights between models trained on HOL examples and models trained on Isabelle examples</p>",
        "id": 197216058,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589238057
    },
    {
        "content": "<p>in order for one model to be effective in both domains, you'd effectively be requiring that the model has its own \"internal type theory\" that it can translate between it and HOL and Lean</p>",
        "id": 197216189,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589238123
    },
    {
        "content": "<p>First, let's address the narrow question about using HOList in Lean.  As <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> mentioned, HOList (and DeepHOL, the AI associated with the HOList environment) are designed for HOL-Light.  For sake of argument let's consider the different ways that Lean (or another tactic-based ITP) could \"use HOList\".</p>\n<ul>\n<li>Most directly Lean could translate a Lean goal into a HOL.  This already isn't always possible (for logical differences between HOL and DTT), but I think something similar is done in practice for Hammer systems in Coq (but I'm really not an expert here).  Then one can send that to a pertained version of DeepHOL (there are many but for sake of argument let's choose the public version). However, DeepHOL and HOList actually have the vocabulary of HOL-Light hard coded (in the same way that many NLP models have all the English words hard coded as indices for each word).  This will require that not only that we translate the goal into HOL, but HOL with a similar vocabulary to HOL-Light.  While some concepts like the natural numbers are easy to align, it is incredibly difficult to translate between all of the concepts even in the same logic.  There are academic papers written on this subject of concept aligning between ITPs.  So we would have to align some of the most common concepts (like natural numbers, logical symbols, etc) and just except that we can't align all of the vocabulary.  That however, may not be a complete bust.  HOList is capable of expanding to another vocabulary, but one just has to mask the new definitions.  Surprisingly HOL-Light still does ok in this setting, e.g. on Flyspeck trained on the core HOL-LIght library.  Ok, so taking stock, we have translated our Lean goal into an HOL-Light goal with HOL-Light syntax.  However, DeepHOL also needs premises to select.  We would have to translate Lean theorems into HOL-Light theorems and supply those as premises.  Then after all that, DeepHOL will find an HOL-Light proof.  This will need to be translated into a Lean proof, which is not straightforward either since HOL-Light has some really powerful automation (e.g. MESON_TAC).</li>\n<li>Slightly less directly, we could use HOList/DeepHOL as in the previous bullet, but only one tactic at a time.  Then one would have to build a tree search in Lean and an environment to try tactics.  (We aren't using it for RL yet, but it has a similar purpose of being an RL Gym.)  This would have a better chance of guiding us to the correct proof since we can correct the proof translation as we go.</li>\n<li>Now, there are a number of places we can go from here.  For example, we can use the DeepHOL architecture but with a \"LeanGym\".  Indeed the Google team has expressed interest in this.  Another option is to just copy the concepts in the HOList paper.  Again we need a LeanGym and maybe prerecorded proof data.</li>\n<li>In the end, I think unless Google wants to support DeepHOL for Lean (retrained from scratch), the best we can directly exact from the DeepHOL algorithm is the graph embeddings.  As you know <span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span>, all the state of the art tools in image processing and natural language processing use pertained networks (e.g. Resnet trained on Imagenet, BERT trained on a large corpus of English, etc).  There isn't anything similar yet for theorem proving.  But all of Szegedy's recent works (and the talks for this years AITP) strongly suggest that his team is working on this exact problem.  In about a year or two, I bet we can have some standard graph embeddings that could work for HOL-Light, Lean, Coq,  Isabelle, etc.  I still think we are going to have the vocabulary and logic alignment issue, but maybe the embeddings will work solely on the structure of the formula graph.</li>\n</ul>",
        "id": 197221364,
        "sender_full_name": "Jason Rute",
        "timestamp": 1589242190
    },
    {
        "content": "<p>I think I misunderstood slightly.  I think you are talking about incorporating Lean (and maybe Coq, Isabelle, etc) into HOList.  Here are my thoughts on that.  (Just a point of disambiguation here:  I'm now using HOList to only mean the HOL-Light interface, not DeepHOL.)</p>\n<ul>\n<li>HOList isn't much more than a thin wrapper around HOL-Light.  I've documented it already.  Honestly, to \"incorporate Lean\" into HOList basically means writing a completely separate wrapper around Lean, but with the same protobuf API.  It would reuse none of the current HOList code (which is just a fork of the HOL-Light directory).  I'm already working on making a prototype of such an interface.  It is not for Google directly, but it could be used by Google (and it wouldn't be more than a week's work to write a protobuf wrapper around it).</li>\n<li>The HOList interface is sort of specific to HOL-Light.  Dependent type theory for example has a notion of a local context which I don't think HOList has any sense of.  This would require an extension of the API.  (And of course the tactics are different.)</li>\n<li>I am 100% on board having some standardized theorem-proving gyms for the common ITPs.  Just as the Atari gym allowed a researcher to try a single algorithm on many Atari games, it would be great to make it easy to apply the same algorithm to many ITPs.  Also, it would make transfer of knowledge between separate logics an important research topic.</li>\n<li>However, I don't think this should be solely under the HOList umbrella.  Google is doing AMAZING stuff and they are far ahead of anyone else, but they also don't have any interest in documenting their interface.  I've seen many good AI researchers (most of them here on Zulip) attempt to work with HOList, only to get frustrated by the difficulty and give up.  Even you <span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span> pointed out that CoqGym is the only documented API right now.  Also, no-one so far has written a paper using the HOList interface apart from Google.</li>\n<li>There is something that almost none of the current ML environments do well.  None of them serve both as an RL Gym for training an algorithm and a tool for ITP researchers.  DeepHOL is unusable as a tool even in HOL-Light.  The TacticToe frameworks are designed to be usable for Coq and HOL4, but at the cost of being trained in OCaml and SML.  :(   This greatly constrains the ability to get ML researchers involved and to rapidly prototype ideas.  (Good luck using TensorFlow or PyTorch.)  My vision is a system which is both: a gym usable by ML researchers, and a tool which can be used directly in Lean.  That is what I'm trying to build (or at least prototype) and I think Lean has the tools for this.  (Lean 4 will even be better!)</li>\n</ul>",
        "id": 197223032,
        "sender_full_name": "Jason Rute",
        "timestamp": 1589243666
    },
    {
        "content": "<p><a href=\"https://github.com/LaurentMazare/ocaml-torch\">https://github.com/LaurentMazare/ocaml-torch</a><br>\nobviously using pytorch in ocaml is harder than using it in python, but I think Laurent has done the hardest bits of work</p>",
        "id": 197223326,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589243990
    },
    {
        "content": "<p>Ok, I might have gone a bit too far, but I think avoiding Python for experimentation will alienate ML researchers and make prototyping harder.  If however, this is not the case, then by all means...  (Also, even if the experimentation is done in Python, there is obviously value in incorporating the final ML pipeline into a \"production\" OCaml environment.)</p>",
        "id": 197223562,
        "sender_full_name": "Jason Rute",
        "timestamp": 1589244182
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span>, I don't understand your question (2).  HOList addresses a complicated and interesting problem that the standard RL domains don't.  I don't however want to claim there are no other RL environments that don't share some of the difficulties of theorem proving.  (Optimization, automatic code generation, and to some degree robotics also offer model-based RL opportunities with sparse rewards.)  However, mathematical reasoning is intrinsically valuable in its own right.  In analogy, NLP and Image processing are studied both as a way to improve AI, but also because there are millions of dollars of business interests in those areas as well as hope (probably false) that it will improve society.  While mathematical reasoning isn't a lucrative, I think many see it as a holy grail of AI reasoning.  (I think no one is saying that Szegedy's team is not ambitious enough.  I usually hear the opposite.)</p>",
        "id": 197223739,
        "sender_full_name": "Jason Rute",
        "timestamp": 1589244363
    },
    {
        "content": "<p>Also, I should point out that, <span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span> , you come at this from the point of view of an ML researcher looking for interesting problems to work on. Many here in this community just want to advance and improve theorem proving.  I'd like to see systems like DeepHOL, TacticToe, etc be easy to work with for the typical proof engineer.  Since Lean is so popular, it makes sense to build tools to at least try to start adding powerful AI to Lean.  (For example, in another thread here, someone asked about ranking the possible rewrite theorems.  They aren't looking for SOTA graph embeddings, just some tool that works ok.  Right now, even that is hard to do in Lean.  I'd like to make that situation better.)</p>",
        "id": 197224126,
        "sender_full_name": "Jason Rute",
        "timestamp": 1589244826
    },
    {
        "content": "<p>(Another point before I head into work.)  HOList is implemented as a \"stateless API\", meaning that after all the definitions and theorems are loaded, you enter in each goal state and the tactic to apply.  This is good for tree searching.  However, I think it is much easier to do in HOL-Light than many other ITPs, including Lean.  For Lean, I tried to make this work, but ran into multiple problems.  Some of them might be fixed in Lean4, but I don't know about all of them.  Instead, I've decided to go a different route where Lean keeps track of all the visited goal states in a proof for you and gives you an index for each.  You can revisit any previously visited state by referencing that index.  (Another approach could be to use the partially built tactic script as the \"state\".  One can keep track of the proof scripts and use them to jump back to a previous state, but I was worried about performance here and having to re-run the tactic script every time if my tree search bounces around too much.  I wonder if this is how CoqGym does it.  Do you know <span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span>?)</p>",
        "id": 197269164,
        "sender_full_name": "Jason Rute",
        "timestamp": 1589287400
    },
    {
        "content": "<p>A colleague of mine just pointed me to this:<br>\n<a href=\"https://www.quantamagazine.org/symbolic-mathematics-finally-yields-to-neural-networks-20200520/\">https://www.quantamagazine.org/symbolic-mathematics-finally-yields-to-neural-networks-20200520/</a></p>",
        "id": 198483185,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1590175024
    },
    {
        "content": "<p>This is the same dubious work that was discussed here a long time ago, right?</p>",
        "id": 198484962,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590175879
    },
    {
        "content": "<p>yeah, the preprint has been out for a while</p>",
        "id": 198484977,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1590175887
    },
    {
        "content": "<p>it \"just\" guesses antiderivatives for a small class of functions, using neural nets and NLP architecture to power the guessing</p>",
        "id": 198485016,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1590175916
    },
    {
        "content": "<p>If I remember correctly the paper claims were borderline so I guess the journalist version goes way over the top</p>",
        "id": 198485080,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590175932
    },
    {
        "content": "<p>yeah the folks at quanta are good writers but i don't have any understanding on their topic selection</p>",
        "id": 198485128,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1590175963
    },
    {
        "content": "<p>one time they wrote an article about an unsurprising incremental improvement to a lower bound in incidence geometry; they did a lovely job explaining the problem, but way overstated the contribution of the paper they were responding to</p>",
        "id": 198485290,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1590176043
    },
    {
        "content": "<p>I think they're really excited by the phrase \"grad student does X\"</p>",
        "id": 198485318,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1590176059
    },
    {
        "content": "<p>Thanks for the assessment -- it's save the time of looking into it.</p>",
        "id": 198485406,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1590176122
    },
    {
        "content": "<p>This topic has been discussed  on the <a href=\"#narrow/stream/113488-general/topic/deep.20learning.20for.20symbolic.20mathematics\">deep learning for symbolic mathematics</a> topic before.  For what it's worth, I think it overall is a good paper with interesting and thought provoking results.  I don't think it is nearly as dubious as Patrick or Jalex suggest.  (I could go into more detail, but probably in that thread or a new one.)</p>",
        "id": 198535871,
        "sender_full_name": "Jason Rute",
        "timestamp": 1590240698
    },
    {
        "content": "<p>Sorry, I didn't mean to be too dismissive. The paper does what it says it does, it guesses antiderivatives with a neural net, using a training loop that involves a differentiation algorithm but not an antidifferentiation algorithm. You could possibly apply the same idea to other inverse problems.</p>",
        "id": 198538787,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1590245490
    },
    {
        "content": "<p>I just meant to counterbalance the quanta article, which is too much.</p>",
        "id": 198538833,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1590245523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/ML.20for.20Lean.3A.20How.20to.20do.20it.3F/near/198538833\">said</a>:</p>\n<blockquote>\n<p>I just meant to counterbalance the quanta article, which is too much.</p>\n</blockquote>\n<p>For people like myself, who work with neural networks a lot, this seemed like a highly surprising results as the network can predict relatively complex antiderivatives straight out of box. I think it is a great paper.</p>",
        "id": 202044587,
        "sender_full_name": "Christian Szegedy",
        "timestamp": 1593135540
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> I’m looking for the html file that visualize the output of the scrapper; but can’t find it anymore. Mind sharing the link here again? Thanks thanks!</p>",
        "id": 207682027,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1598042342
    },
    {
        "content": "<p>Found it!</p>",
        "id": 207711723,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1598079965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249373\">@Stanislas Polu</span> Sorry.  I’ve been preoccupied.  Do you have everything you need?</p>",
        "id": 207831398,
        "sender_full_name": "Jason Rute",
        "timestamp": 1598267921
    },
    {
        "content": "<p>Yes! All good <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> Thanks!</p>",
        "id": 207834288,
        "sender_full_name": "Stanislas Polu",
        "timestamp": 1598270317
    }
]
[
    {
        "content": "<p>Has anyone tried implementing bounded quantifiers in Lean 4?</p>\n<p>For context, I am working with <code>mathlib4</code>, which has these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Mem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Mem.mem</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">x</span> <span class=\"s2\">\" ∉ \"</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mem</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">mem</span> <span class=\"n\">a</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Mem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mem</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>This seems to work reasonably well for parsing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">forallb</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">existsb</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"∀ \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\", \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">forallb</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"∃ \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\", \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">existsb</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I tried to see if I could get the expressions to pretty-print. This seems to have no effect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[appUnexpander forallb]</span> <span class=\"kd\">def</span> <span class=\"n\">unexpandForallb</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">forallb</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">@[appUnexpander existsb]</span> <span class=\"kd\">def</span> <span class=\"n\">unexpandExistsb</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">existsb</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>These definitions work reasonably well, but they leave the body of the expression eta-expanded:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span>\n\n<span class=\"kd\">@[delab app.forallb]</span> <span class=\"kd\">def</span> <span class=\"n\">delabForallb</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">$</span> <span class=\"n\">e.getAppNumArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">3</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">withAppFn</span> <span class=\"bp\">$</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!.</span><span class=\"n\">bindingName</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">n</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[delab app.existsb]</span> <span class=\"kd\">def</span> <span class=\"n\">delabExistsb</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">$</span> <span class=\"n\">e.getAppNumArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">3</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">withAppFn</span> <span class=\"bp\">$</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!.</span><span class=\"n\">bindingName</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">n</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I thought using <code>withBindingBody</code> would extract the body of the lambda expression, but then I get the error message indicated below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span>\n\n<span class=\"kd\">@[delab app.forallb]</span> <span class=\"kd\">def</span> <span class=\"n\">delabForallb</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">$</span> <span class=\"n\">e.getAppNumArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">3</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">withAppFn</span> <span class=\"bp\">$</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!.</span><span class=\"n\">bindingName</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">withBindingBody</span> <span class=\"n\">n</span> <span class=\"bp\">$</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">n</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[delab app.existsb]</span> <span class=\"kd\">def</span> <span class=\"n\">delabExistsb</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">$</span> <span class=\"n\">e.getAppNumArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">3</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">withAppFn</span> <span class=\"bp\">$</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!.</span><span class=\"n\">bindingName</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">withBindingBody</span> <span class=\"n\">n</span> <span class=\"bp\">$</span> <span class=\"n\">withAppArg</span> <span class=\"n\">delab</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">n</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation) : Prop</span>\n</code></pre></div>\n<p>I'd be grateful for any help or suggestions.</p>",
        "id": 243847074,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624568989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> Your unexpander just needs to include the type of the binder:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[appUnexpander forallb]</span> <span class=\"kd\">def</span> <span class=\"n\">unexpandForallb</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">forallb</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">forallb</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"c1\">-- ∀ x ∈ [1, 2, 3], x = x : Prop</span>\n</code></pre></div>",
        "id": 243848082,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624569441
    },
    {
        "content": "<p>Beautiful! Many thanks.</p>",
        "id": 243848618,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624569768
    },
    {
        "content": "<p>Did you manage to get bounded existential to expand to what we want?</p>",
        "id": 243848796,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1624569874
    },
    {
        "content": "<p>The outcome of the <code>#check</code> is <code>∃ x ∈ [1, 2, 3], x = x : Prop</code>, but we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Is that what you were hoping for?</p>",
        "id": 243849178,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624570104
    },
    {
        "content": "<p>Yes!</p>",
        "id": 243849403,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1624570253
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> I am still curious as to why the longer code with <code>withBindingBody</code> did not work. (It is similar to the delaboration for dite expressions in <code>PrettyPrinter/Delaborator/Builtins.lean</code>. ) But if it is not easy to give me a quick answer, don't worry about it. I am just curious.</p>",
        "id": 243849423,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624570265
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> We should be able to generalize the notation to other types and other kinds of bounding (like &lt;). I'll consult my oracle (Mario) as to how best to do it.</p>",
        "id": 243849598,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624570390
    },
    {
        "content": "<p>You used the wrong order :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">withAppArg</span> <span class=\"bp\">$</span> <span class=\"n\">withBindingBody</span> <span class=\"n\">n</span> <span class=\"n\">delab</span>\n</code></pre></div>",
        "id": 243850146,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1624570757
    },
    {
        "content": "<p>Yes, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[delab app.forallb]</span> <span class=\"kd\">def</span> <span class=\"n\">delabForallb</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">$</span> <span class=\"n\">e.getAppNumArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">3</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!.</span><span class=\"n\">bindingName</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">n</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">withAppFn</span> <span class=\"o\">(</span><span class=\"n\">withAppArg</span> <span class=\"n\">delab</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">withAppArg</span> <span class=\"o\">(</span><span class=\"n\">withBindingBody</span> <span class=\"n\">n</span> <span class=\"n\">delab</span><span class=\"o\">)</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"c1\">-- ∀ x ∈ [1, 2, 3], x = x : Prop</span>\n</code></pre></div>",
        "id": 243850504,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624570973
    },
    {
        "content": "<p>Whoa, all this monad trickery is above my pay grade. Initially, the expression being delaborated is of the form <code>forallb t p</code>. The <code>let t ← ...</code> picks out the <code>t</code> part. The next step is to get the body of <code>p</code>. Don't we have to get <code>p</code> first, and then get the binding body?</p>",
        "id": 243851277,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624571377
    },
    {
        "content": "<p>The <code>with*</code> functions only change the <code>ReaderT</code> context, so when e.g. <code>let t ← withAppFn (withAppArg delab)</code> returns, the context is reset so that <code>delab</code> would refer back to the original expression.</p>",
        "id": 243851578,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624571550
    },
    {
        "content": "<p>I may not have understood your question -- are you confused about the \"resetting\" or the order of the <code>with*</code> calls?</p>",
        "id": 243851743,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624571670
    },
    {
        "content": "<p>That's what I thought -- so that after the <code>let t ← ...</code> returns, we should be back to the original expression <code>forallb t p</code>. Then I would use expect <code>withAppArg delab</code> to return <code>p</code>, and then <code>withBindingBody n (withAppArg delab)</code> to return the body of <code>p</code>. So I guess it is the order of the <code>with*</code> calls that is confusing me.</p>",
        "id": 243851955,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624571807
    },
    {
        "content": "<p>Yes, it is confusing :) Here is the relevant code for application:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">descend</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">child</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">childIdx</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">DelabM</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DelabM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withReader</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">cfg</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">cfg</span> <span class=\"k\">with</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">child</span><span class=\"o\">,</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">cfg.pos</span> <span class=\"bp\">*</span> <span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"n\">childIdx</span> <span class=\"o\">})</span> <span class=\"n\">d</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">withAppFn</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">DelabM</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DelabM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">Expr.app</span> <span class=\"n\">fn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span> <span class=\"bp\">|</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n  <span class=\"n\">descend</span> <span class=\"n\">fn</span> <span class=\"mi\">0</span> <span class=\"n\">d</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">withAppArg</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">DelabM</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DelabM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">Expr.app</span> <span class=\"n\">_</span> <span class=\"n\">arg</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span> <span class=\"bp\">|</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n  <span class=\"n\">descend</span> <span class=\"n\">arg</span> <span class=\"mi\">1</span> <span class=\"n\">d</span>\n</code></pre></div>\n<p>So the line <code>withAppFn (withAppArg delab)</code> will evaluate <code>withAppArg delab</code> in the context of the app-function, which will evaluate <code>delab</code> in the context of the app-function's app-argument. So the \"actions\" go left-to-right.</p>",
        "id": 243852389,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1624572075
    },
    {
        "content": "<p>Ah, yes, that makes sense. Many thanks for the patient explanation.</p>",
        "id": 243852635,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1624572242
    }
]
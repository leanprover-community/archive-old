[
    {
        "content": "<p>So; I want to generate functions using tactics, and the easiest way to do that is to use induction. Unfortunately; induction lowers to usage of the recursor, and therefore I get \"code generator does not support recursor\" errors; I do want my functions to be computable, so this is irritating. Is there anything in the way of the code generator supporting recursors for at least simple inductive types? I mean, it should be quite trivial to lower it to the appropriate recursive function, no?</p>",
        "id": 275601700,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1647484984
    },
    {
        "content": "<p>Posting some code might be helpful on this one</p>",
        "id": 275601893,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647485214
    },
    {
        "content": "<p>I think the error message for this is \"does not support recursor <em>yet</em>\", I'm sure there's a reason why they haven't gotten around to this. You can use <code>match</code> in tactics which should be able to get you pretty close.</p>",
        "id": 275607593,
        "sender_full_name": "Chris B",
        "timestamp": 1647493124
    },
    {
        "content": "<p>match in tactics doesn't let me automate my cases properly, so that doesn't work. As for source code, something as simple as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyTree</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span><span class=\"o\">:</span> <span class=\"n\">MyTree</span>\n<span class=\"bp\">|</span> <span class=\"n\">branch</span><span class=\"o\">:</span> <span class=\"n\">MyTree</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyTree</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyTree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">count_leaves</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">MyTree</span><span class=\"o\">):</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">branch</span> <span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"n\">Il</span> <span class=\"n\">Ir</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Il</span> <span class=\"bp\">+</span> <span class=\"n\">Ir</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">code</span> <span class=\"n\">generator</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">support</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">MyTree.rec'</span> <span class=\"n\">yet</span><span class=\"o\">,</span> <span class=\"n\">consider</span> <span class=\"n\">using</span> <span class=\"bp\">'</span><span class=\"k\">match</span> <span class=\"bp\">...</span> <span class=\"k\">with</span><span class=\"bp\">'</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n</code></pre></div>\n<p>Manual use of <code>MyTree.rec</code> yields the same error; but the recursor should be extremely easy to generate code for, no?</p>",
        "id": 275651196,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1647523423
    },
    {
        "content": "<p>Note that this works if I stick to <code>noncomputable def</code>, which is fine for now but irritating long-term, especially since it's infectious. Ofc I could manually implement this with partial recursion, but the whole reason why I want to use induction is to avoid writing out a massive 30-branch induction</p>",
        "id": 275651735,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1647523669
    },
    {
        "content": "<p>Kind of <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> but would something like this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyTree</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span><span class=\"o\">:</span>   <span class=\"n\">MyTree</span>\n<span class=\"bp\">|</span> <span class=\"n\">branch</span><span class=\"o\">:</span> <span class=\"n\">MyTree</span> <span class=\"bp\">→</span> <span class=\"n\">MyTree</span> <span class=\"bp\">→</span> <span class=\"n\">MyTree</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MyTree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyTree.countLeaves</span> <span class=\"o\">:</span> <span class=\"n\">MyTree</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span>       <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">branch</span> <span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.countLeaves</span> <span class=\"bp\">+</span> <span class=\"n\">r.countLeaves</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">treeEx</span> <span class=\"o\">:</span> <span class=\"n\">MyTree</span> <span class=\"o\">:=</span>\n  <span class=\"n\">branch</span> <span class=\"n\">leaf</span> <span class=\"n\">leaf</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">treeEx.countLeaves</span> <span class=\"c1\">-- 2</span>\n</code></pre></div>",
        "id": 275653598,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647524516
    },
    {
        "content": "<p>I'm a new Lean user, but, to me, the strength of tactic mode is to provide an interface that helps you generate a term that type checks. For computations in which the generated term matters, I would just stick to functions</p>",
        "id": 275655355,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647525230
    },
    {
        "content": "<p>Do you have a motivation to use tactics for your computation?</p>",
        "id": 275656707,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1647525727
    },
    {
        "content": "<p>In Lean 3 the big problem with using tactics to generate data is that it can become very difficult to prove anything about the data, because in general tactics are just designed to \"get that proof term, no matter how\" so it doesn't matter if they produce horrible code because it's all erased after. With data you don't know what you're getting with the <code>induction</code> tactic, whereas the equation compiler is specifically designed for this purpose.</p>",
        "id": 275659166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647526656
    },
    {
        "content": "<p>In lean 4 it is somewhat the other way around: using the <code>induction</code> tactic is the simplest / most reliable way to get a <code>foo.rec</code> term with no extra fluff (you can't easily write <code>foo.rec</code> directly because the motive is not inferred correctly because <code>@[elab_as_eliminator]</code> doesn't exist)</p>",
        "id": 275669850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647530604
    },
    {
        "content": "<p>I recently had to deal with this when writing an expression that needed to compute in the kernel. I did this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">hasEdge'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">found</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">hasEdge'</span> <span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"n\">found</span> <span class=\"n\">n</span> <span class=\"k\">else</span>\n  <span class=\"n\">bif</span> <span class=\"n\">found</span> <span class=\"bp\">||</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"mi\">2</span> <span class=\"bp\">||</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">==</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n    <span class=\"n\">n</span> <span class=\"bp\">||</span> <span class=\"n\">hasEdge'</span> <span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"n\">true</span> <span class=\"n\">true</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">hasEdge'</span> <span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"n\">false</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">@[implementedBy hasEdge']</span> <span class=\"kd\">def</span> <span class=\"n\">hasEdge</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span><span class=\"bp\">;</span> <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">r</span><span class=\"bp\">;</span> <span class=\"n\">induction</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span>\n      <span class=\"n\">bif</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">ih</span> <span class=\"n\">r</span> <span class=\"k\">else</span> <span class=\"k\">fun</span> <span class=\"n\">found</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">bif</span> <span class=\"n\">found</span> <span class=\"bp\">||</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"mi\">2</span> <span class=\"bp\">||</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">==</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n          <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">||</span> <span class=\"n\">ih</span> <span class=\"n\">r</span> <span class=\"n\">true</span> <span class=\"n\">true</span>\n        <span class=\"k\">else</span>\n          <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih</span> <span class=\"n\">r</span> <span class=\"n\">false</span> <span class=\"n\">true</span>\n</code></pre></div>",
        "id": 275670149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647530696
    },
    {
        "content": "<p>the first term is optimized for the compiler and the second one is optimized for the kernel</p>",
        "id": 275670399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647530769
    },
    {
        "content": "<p>The simple solution here is indeed to just implement <code>foo.rec</code> (and <code>foo.casesOn</code>) in the compiler. It should not be too hard, and I'm even thinking of trying my hand at it although the compiler is definitely in <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> 's jurisdiction</p>",
        "id": 275671324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647531093
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> The compiler already has support for <code>casesOn</code>. The support for <code>rec</code> will only happen after we port the parts of the compiler still written in C++ to Lean. Unfortunately, this port will not happen any time soon. It is a tough decision, we need to port this C++ code to Lean and fix many problems we have there, but we also have many higher priority tasks.  <br>\nBTW,  I view the support for <code>rec</code> as a super low priority and it will benefit very few users.</p>",
        "id": 275683665,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647534275
    },
    {
        "content": "<p>It is something I have run into a half dozen times so far, I'm working up the courage to do it myself since I'm aware it's a low priority</p>",
        "id": 275684794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647534513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Are they all the same use-case? Could you explain it?</p>",
        "id": 275685249,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647534597
    },
    {
        "content": "<p>The use case that appeared above was that I wanted a term that computes as efficiently as possible in the kernel because it is part of a large proof by reflection; I don't know how to get <code>casesOn</code> applications using <code>cases</code> but <code>induction</code> produces <code>rec</code> applications</p>",
        "id": 275686182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647534812
    },
    {
        "content": "<p>and then I wanted such a term to be sanity-checkable using the compiler</p>",
        "id": 275686646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647534919
    },
    {
        "content": "<p>as you can see above my workaround is to rewrite the whole term in compiler-friendly format</p>",
        "id": 275686729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647534953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275686182\">said</a>:</p>\n<blockquote>\n<p>The use case that appeared above was that I wanted a term that computes as efficiently as possible in the kernel because it is part of a large proof by reflection; I don't know how to get <code>casesOn</code> applications using <code>cases</code> but <code>induction</code> produces <code>rec</code> applications</p>\n</blockquote>\n<p>We are planning to improve the reduction engine in the kernel, and have better support for proofs by reflection. <br>\nYou will not need to use the trick above after we implement these improvements. I think you should avoid these tricks for now and try to survive with the current performance overhead. Is it bigger than 2x?</p>",
        "id": 275687257,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647535063
    },
    {
        "content": "<p>I suspect it would be possible to write the <code>foo.rec</code> generator entirely in lean: you just have to call <code>compileDecl</code> on <code>foo.rec</code> with a term that looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo.rec'.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Foo.one</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Foo.two</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">t</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h1</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h2</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">rec'</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 275688568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647535352
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> Not 2x, but measurable. I have a proof of (the computational part of) the Keller conjecture counterexample in dimension 8, and without using bare terms the proof by reflection (essentially an enumeration of 2*16^2 possibilities) takes 10.65 s, with the optimizations it is 7.9 s. I can send you the file as a test case</p>",
        "id": 275690418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647535753
    },
    {
        "content": "<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>\nIn Lean 4, we also have extra complexity: mutual and nested inductives.</p>",
        "id": 275690425,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647535755
    },
    {
        "content": "<p>One thing that I would like to see improved with this kind of stuff is better debugging support for kernel reduction. It is hard to tell whether a reduction is being cached or redone, for example</p>",
        "id": 275690887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647535848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690418\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> Not 2x, but measurable. I have a proof of (the computational part of) the Keller conjecture counterexample in dimension 8, and without using bare terms the proof by reflection (essentially an enumeration of 2*16^2 possibilities) takes 10.65 s, with the optimizations it is 7.9 s. I can send you the file as a test case</p>\n</blockquote>\n<p>It would be great if you can survive with this overhead. The new reduction engine will make it way faster, and make the trick above obsolete.<br>\nYes, it would be great to have the file.</p>",
        "id": 275690890,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647535850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690887\">said</a>:</p>\n<blockquote>\n<p>One thing that I would like to see improved with this kind of stuff is better debugging support for kernel reduction. It is hard to tell whether a reduction is being cached or redone, for example</p>\n</blockquote>\n<p>Yes, it would be great to have better profiling tools in the kernel as we embrace proofs-by-reflection more and more.</p>",
        "id": 275691202,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647535951
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/WmXo7NFIM0rYpT9WMnQ-ypfW/Keller.lean\">Keller.lean</a></p>",
        "id": 275691341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647535965
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 275691397,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647535973
    },
    {
        "content": "<p>it has some minor dependencies on mathlib for the <code>List.Pairwise</code> decision procedure and <code>run_cmd</code></p>",
        "id": 275691400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647535976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275691400\">said</a>:</p>\n<blockquote>\n<p>it has some minor dependencies on mathlib</p>\n</blockquote>\n<p>Could you please remove them? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> <br>\nIt would be great to have them on our benchmark suite. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> has a system for tracking progress over time. We have found many performance regression issues with this system.</p>",
        "id": 275691785,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647536109
    },
    {
        "content": "<p><code>run_cmd</code> should totally be part of lean 4 anyway <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 275692063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647536155
    },
    {
        "content": "<p>Something I brought up recently is to add timing information to the traces. Together with lazy traces (because tracing the whole reduction would be counterproductive for benchmarking), that should give you a pretty quick idea on what parts are cached/exprensive, even without specific profiling support for reductions.</p>",
        "id": 275692362,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1647536255
    },
    {
        "content": "<p>Lazy traces are not really necessary for that as long as the trace classes are sufficiently granular</p>",
        "id": 275692537,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1647536302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> We don't have trace messages in the kernel :(</p>",
        "id": 275692635,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647536348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275692063\">said</a>:</p>\n<blockquote>\n<p><code>run_cmd</code> should totally be part of lean 4 anyway <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>Sure, do you want to submit a PR?</p>",
        "id": 275692670,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647536365
    },
    {
        "content": "<p>Oops, I was purely thinking of reduction in the elaborator :)</p>",
        "id": 275692737,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1647536394
    },
    {
        "content": "<blockquote>\n<p>@Sebastian Ullrich has a system for tracking progress over time. We have found many performance regression issues with this system.</p>\n</blockquote>\n<p>Now I am curious; what system are you using?</p>",
        "id": 275693264,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1647536508
    },
    {
        "content": "<p>Yet another PSE project of course :) <a href=\"http://speedcenter.informatik.kit.edu/velcom/home\">http://speedcenter.informatik.kit.edu/velcom/home</a></p>",
        "id": 275693416,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1647536544
    },
    {
        "content": "<p>mathlib-free via copious inlining: <a href=\"/user_uploads/3121/zEIkO1_I3_v5nm2Ih0mGffvS/Keller.lean\">Keller.lean</a></p>",
        "id": 275694054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647536709
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 275694092,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647536724
    },
    {
        "content": "<p>Uh, pretty. <code>rm -rf gipeda</code> :-)</p>",
        "id": 275694108,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1647536730
    },
    {
        "content": "<p>Oh, Java. <code>borg extract gipeda/</code>.</p>",
        "id": 275694714,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1647536885
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275692670\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275692063\">said</a>:</p>\n<blockquote>\n<p><code>run_cmd</code> should totally be part of lean 4 anyway <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>Sure, do you want to submit a PR?</p>\n</blockquote>\n<p>In the process of inlining I found that it depends on two other, also useful features:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Util/Eval.lean\">More convenient forms of <code>evalExpr</code></a>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">evalExpr</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">safety</span> <span class=\"o\">:=</span> <span class=\"n\">DefinitionSafety.safe</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">α</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">evalTerm</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">safety</span> <span class=\"o\">:=</span> <span class=\"n\">DefinitionSafety.safe</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Util/TermUnsafe.lean\">term mode <code>unsafe</code></a>, as in <code>def cool := unsafe (unsafeCast () : Nat)</code></li>\n</ul>\n<p>Are you interested in receiving these as well, or should I extract just <code>run_cmd</code>?</p>",
        "id": 275695208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647537025
    },
    {
        "content": "<p>By the way, this is not the original proof I had for Keller dim 8. The first version used a naive clique check which is 256^2 tests; this is easy enough with <code>#eval</code> / <code>nativeDecide</code> but took longer than I had patience to wait for in <code>by decide</code>. The version here does a lot more reasoning to get the computational part to a feasible level, but perhaps if the reduction engine gets good enough the simpler version will work as a benchmark</p>",
        "id": 275696186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647537394
    },
    {
        "content": "<blockquote>\n<p>Are you interested in receiving these as well, or should I extract just run_cmd?</p>\n</blockquote>\n<p>Sure.</p>",
        "id": 275696453,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647537526
    },
    {
        "content": "<blockquote>\n<p>The version here does a lot more reasoning to get the computational part to a feasible level, but perhaps if the reduction engine gets good enough the simpler version will work as a benchmark</p>\n</blockquote>\n<p>Whoa, we can try to make it fast, not sure we will be able to handle this one in the near future.</p>",
        "id": 275696609,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647537600
    },
    {
        "content": "<p>Heh, there's always a bigger mountain. You don't want to see how much worse <a href=\"https://arxiv.org/abs/1910.03740\">Keller dim 7</a> is</p>",
        "id": 275696885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647537689
    },
    {
        "content": "<p>I'm confused; <em>why</em> is it difficult for the code-generator to support recursors? Isn't it possible to simply (hackily) lower them to partial recursive functions for now?</p>",
        "id": 275868380,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1647641132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690425\">said</a>:</p>\n<blockquote>\n<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>\nIn Lean 4, we also have extra complexity: mutual and nested inductives.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> would it be possible to temporarily have this hack and later swap it out for something better? I believe that mutual/nested inductives could be taken care of very easily by just generating partial functions as the implementation. Would this be a good issue for a beginner to tackle?</p>",
        "id": 275999533,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1647828579
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690425\">said</a>:</p>\n<blockquote>\n<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>\nIn Lean 4, we also have extra complexity: mutual and nested inductives.</p>\n</blockquote>\n<p>I missed this comment earlier. In what sense is this a hack? This is literally the meaning of <code>foo.rec</code> as a function. I'm not saying that we should <em>only</em> use these recursor functions, but when you use it directly then this is the behavior I would expect.</p>\n<p>What alternatives are there? The fact that <code>nat.rec</code> will eagerly evaluate <code>motive 0</code> is not great, I agree, but it's hard to see what else to do. I suppose you could make that match definition <code>macroInline</code> which could recover some of the laziness...?</p>",
        "id": 276006987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647839437
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>I missed this comment earlier. In what sense is this a hack? This is literally the meaning of foo.rec as a function. I'm not saying that we should only use these recursor functions, but when you use it directly then this is the behavior I would expect.</p>\n</blockquote>\n<p>This is not the behavior users expect. It is also not consistent with the approach we use for <code>casesOn</code> where we use lazy semantics.<br>\nBTW, in previous versions of Lean, we did generate a <code>rec</code> function, and users were confused when they realized it was not lazy.</p>\n<blockquote>\n<p>What alternatives are there? The fact that nat.rec will eagerly evaluate motive 0 is not great, I agree, but it's hard to see what else to do. I suppose you could make that match definition macroInline which could recover some of the laziness...?</p>\n</blockquote>\n<p>One possibility is to have special support for <code>rec</code> in the compiler,  similar to what we have for <code>casesOn</code>. </p>\n<blockquote>\n<p>I suppose you could make that match definition macroInline which could recover some of the laziness...?</p>\n</blockquote>\n<p>Not sure how far you can go using just <code>macroInline</code>, but some code transformation that replaces <code>rec</code> with <code>recLazy</code> should also. For example, <code>Nat.recLazy</code> would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.recLazy</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">hz</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hs</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">recLazy</span> <span class=\"n\">motive</span> <span class=\"n\">hz</span> <span class=\"n\">hs</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now, whenever we find code such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">@</span><span class=\"n\">Nat.rec</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">dbg_trace</span> <span class=\"s2\">\"hz\"</span><span class=\"bp\">;</span> <span class=\"mi\">10</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dbg_trace</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"hs: {n}\"</span><span class=\"bp\">;</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">10</span> <span class=\"k\">then</span> <span class=\"mi\">2</span><span class=\"bp\">*</span> <span class=\"n\">ih</span> <span class=\"k\">else</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"mi\">20</span>\n</code></pre></div>\n<p>We replace it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">Nat.recLazy</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"hz\"</span><span class=\"bp\">;</span> <span class=\"mi\">10</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dbg_trace</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"hs: {n}\"</span><span class=\"bp\">;</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">10</span> <span class=\"k\">then</span> <span class=\"mi\">2</span><span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">())</span> <span class=\"k\">else</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"mi\">20</span>\n</code></pre></div>",
        "id": 276037356,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647862596
    },
    {
        "content": "<p>Do you think that <code>recLazy</code> should actually exist and be used by users etc, or is this just a compiler internal thing that isn't in the environment?</p>",
        "id": 276037799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647862902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461231\">Jad Ghalayini</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275999533\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/275690425\">said</a>:</p>\n<blockquote>\n<p>If I recall correctly, we used this hack in Lean 3, but it didn't work well: poor performance, unexpected behavior because Lean is a strict language.<br>\nIn Lean 4, we also have extra complexity: mutual and nested inductives.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> would it be possible to temporarily have this hack and later swap it out for something better? I believe that mutual/nested inductives could be taken care of very easily by just generating partial functions as the implementation. Would this be a good issue for a beginner to tackle?</p>\n</blockquote>\n<p>This kind of temporary hack is a headache for us because the proper solution is not a priority right now. <br>\nSuppose we add the hack, then I am very confident another user will hit the unexpected behavior I described above and will file a bug report. Now, we have a bug report for a feature that we did not even consider important, and is usually misused by users. <br>\nWe do use hacks sometimes, but there are hacks for features we consider important.</p>\n<blockquote>\n<p>Would this be a good issue for a beginner to tackle?</p>\n</blockquote>\n<p>I would suggest you manually define your own <code>recLazy</code> function for the types you care about. Note that the tactic <code>induction</code> has the <code>using</code> modifier that allows us to specify a different elimination principle. That is, you can use <code>induction x using Nat.recLazy</code></p>",
        "id": 276038115,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647863134
    },
    {
        "content": "<p>Perhaps a target that might be more accessible for newcomers interested in usefully contributing to this issue is to write a program to generate <code>recLazy</code> for an arbitrary inductive type</p>",
        "id": 276038382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647863322
    },
    {
        "content": "<p>and defer the question of how to integrate this with the compiler</p>",
        "id": 276038421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647863356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276037799\">said</a>:</p>\n<blockquote>\n<p>Do you think that <code>recLazy</code> should actually exist and be used by users etc, or is this just a compiler internal thing that isn't in the environment?</p>\n</blockquote>\n<p>I don't have a preference here. To be honest, I would prefer to have really good documentation explaining why we have <code>rec</code>, and why it should not be used directly in programs. Make it clear to the user that <code>rec</code> is just one of the tools we have to show termination. We could also explain <code>Nat.recLazy</code>, and why even this approach would produce suboptimal code.</p>",
        "id": 276038981,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647863719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276038382\">said</a>:</p>\n<blockquote>\n<p>Perhaps a target that might be more accessible for newcomers interested in usefully contributing to this issue is to write a program to generate <code>recLazy</code> for an arbitrary inductive type</p>\n</blockquote>\n<p>Yes, this can be a fun project for newcomers.</p>",
        "id": 276039020,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647863758
    },
    {
        "content": "<p>I think there is a tension with the fact that <code>rec</code> is a primitive of dependent type theory (and lean 4 doesn't change this). It feels like it should be the most efficient thing from one perspective, but for the compiler something like <code>match</code> is more primitive. Writing code that works well in both the compiler and the kernel is therefore tricky</p>",
        "id": 276039191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647863867
    },
    {
        "content": "<p>As a library writer, I want to write code that is good in all the ways, and that means reaching for <code>implementedBy</code> which is the best tool we have at the moment for this kind of thing</p>",
        "id": 276039346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647863968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I agree the \"kernel vs compiled\" issue is annoying, and it will be fixed in the future. We will have better reduction engines in the kernel in the future, and you will not need to be concerned about this anymore. Recall the messages we exchanged in the other thread about the workaround you were using for this issue.</p>",
        "id": 276040678,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647864739
    },
    {
        "content": "<p>Right, sorry to rehash the issue. External verifiers will probably still use the original reduction algorithm though, so I doubt it will ever become completely irrelevant</p>",
        "id": 276040916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647864883
    },
    {
        "content": "<p>Anyway I think we're on the same page for this issue. There are plans for this but they are all rather long term</p>",
        "id": 276041025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647864950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276040916\">said</a>:</p>\n<blockquote>\n<p>Right, sorry to rehash the issue. External verifiers will probably still use the original reduction algorithm though, so I doubt it will ever become completely irrelevant</p>\n</blockquote>\n<p>Yes, I care about external verifiers too. We want to make sure our developments can still be checked by relatively simple external verifiers. <br>\nI believe one of the optimizations we are going to use is easy to implement in external verifiers.</p>",
        "id": 276041353,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647865122
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor/near/276038981\">said</a>:</p>\n<blockquote>\n<p>I don't have a preference here. To be honest, I would prefer to have really good documentation explaining why we have <code>rec</code>, and why it should not be used directly in programs. Make it clear to the user that <code>rec</code> is just one of the tools we have to show termination. We could also explain <code>Nat.recLazy</code>, and why even this approach would produce suboptimal code.</p>\n</blockquote>\n<p>Just seconding this -- I'd encountered the compiler error before, but had no idea why <code>rec</code> didn't compile until reading this thread (and now it makes sense). I'd be happy to help write something up if nobody else is taking it on.</p>\n<p>The compiler error could even provide a link to the discussion, kinda like rustc does with common errors.</p>",
        "id": 276084916,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647882832
    },
    {
        "content": "<blockquote>\n<p>The compiler error could even provide a link to the discussion, kinda like rustc does with common errors</p>\n</blockquote>\n<p>This is a great suggestion.<br>\n<span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> You once told me that the Zulip links are not very stable and may change if, for example, someone marks the topic as resolved. Should we use links to <a href=\"https://leanprover-community.github.io/archive/\">https://leanprover-community.github.io/archive/</a> in error messages instead?</p>",
        "id": 276120691,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647900663
    },
    {
        "content": "<p>There have been more recent changes to the way Zulip can be accessed by people who are not part of the community. They're still in beta though so perhaps they might change again.</p>",
        "id": 276155134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647937240
    },
    {
        "content": "<p>The archive was mostly intended as a stop-gap solution until it was implemented in Zulip itself.  As Kevin said, Zulip can now be accessed without an account.  Once it can be indexed by search engines as well, we might even retire the archive.</p>",
        "id": 276155329,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1647937379
    },
    {
        "content": "<blockquote>\n<p>You once told me that the Zulip links are not very stable and may change</p>\n</blockquote>\n<p>The Zulip team is slowly working on that.  Apparently links to <em>messages</em> are stable now, see the discussion at <a href=\"https://github.com/zulip/zulip/issues/21505\">https://github.com/zulip/zulip/issues/21505</a> (not sure if the change referenced in that issue still needs to be deployed).</p>",
        "id": 276155517,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1647937513
    }
]
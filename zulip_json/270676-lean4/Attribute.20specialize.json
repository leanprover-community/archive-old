[
    {
        "content": "<p>What does the new attribute <code>@[specialize]</code> do?</p>",
        "id": 221797702,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1609954877
    },
    {
        "content": "<p>It is an instruction to the compiler. If you write a function <code>def foo {m a} [Monad m] : Int -&gt; m a</code>, the straightforward way to generate code is to make it a higher-order function that takes <code>bind</code> and <code>pure</code> as parameter. Invoking parameters is typically slow and <code>foo</code> can be made more efficient if new code is generated by the compiler for every monad with which <code>foo</code> is being called.</p>",
        "id": 221803005,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609957432
    },
    {
        "content": "<p>This is useful in general when taking type class instances as parameter but also when simply taking functions as parameters.</p>",
        "id": 221803106,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609957467
    },
    {
        "content": "<p>Interesting! How do I find out what specializations the compiler has generated? Will it inline small functions? What happens to functions when I provide a second function with a more specific type signature? (I am just now starting to read about the details of Lean 4...)</p>",
        "id": 221805784,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1609958751
    },
    {
        "content": "<p>There are options you can set (something like <code>set_option compiler.ir true</code>, I don't remember the exact name of the option) that causes the output of various stages of the compiler to be printed out</p>",
        "id": 221806137,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609958957
    },
    {
        "content": "<p>It is extremely useful when you want to make sure that large data structures are actually used in a linear manner (and that destructive updates are enabled)</p>",
        "id": 221806196,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609959001
    },
    {
        "content": "<p>What do you mean by \"when I provide a second function\"? What does the second function do?</p>",
        "id": 221806310,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609959041
    },
    {
        "content": "<p>ahh, I am thinking in terms of C++, like how the compiler chooses the correct template specialization</p>",
        "id": 221806561,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1609959157
    },
    {
        "content": "<p>I guess as a 1st order approximation you can take <a href=\"https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pragmas.html#specialize-pragma\">https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pragmas.html#specialize-pragma</a> as the documentation</p>",
        "id": 221806766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609959253
    },
    {
        "content": "<p>I realize it came out yesterday so if the answer is: read the source code, that is OK</p>",
        "id": 221806778,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1609959262
    },
    {
        "content": "<p>Ah! I see! This is not like template specialization. With template specialization, the user provides different \"versions\" of the same declaration. Here, the compiler see your definition of <code>mmap</code> (for instance), sees that you use it with the state monad and generates code for <code>mmap</code> that specifically uses your state monad. That is to say that calls to <code>bind</code> and <code>pure</code> are statically bound instead of dynamically bound.</p>",
        "id": 221806859,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609959305
    },
    {
        "content": "<p>Actually, in the case of <code>mmap f</code>, you can specialize further and bind statically the exact function <code>f</code> being passed as a parameter. That function is often a lambda abstraction and the specialization also saves us from allocating a thunk at run time</p>",
        "id": 221808217,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609959962
    },
    {
        "content": "<p>Thank you Simon, this is very helpful!</p>",
        "id": 222052644,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1610098828
    }
]
[
    {
        "content": "<p>Given a typeclass <code>myTC</code> with one field <code>f</code>.<br>\nAn instance for a recursive type <code>T</code> requires to define the field by structural induction on <code>T</code>.<br>\nSo, we have to define an inductive function <code>g</code> separately and then use it to declare the instance (<code>instance : myTC T where f := g</code>).<br>\nNow, imagine that the body of <code>g</code> needs an instance <code>myTC T'</code> (where <code>T'</code> is another type) but to resolve <code>myTC T'</code>, you need the instance of <code>myTC T</code>.<br>\nThis might look like it doesn't terminate.<br>\nBut, in my case, <code>myTC T'</code> uses the field <code>f</code> of the instance <code>myTC T</code> only for smaller values.<br>\nSo, in theory, everything terminates.<br>\nThe problem is that we have to define <code>g</code> before we can define the instance <code>myTC T</code> and we have to define the instance <code>myTC T</code>, in order to, define <code>g</code> (because of the recursive call).<br>\nChicken and the egg problem...</p>\n<p>There are 3 solutions:<br>\n1) Inline typeclass resolution in the body of <code>g</code> to replace the use of the instance by a recursive call to <code>g</code>. But sadly in my application this solution isn't appropriate.<br>\n2) Trick lean into replacing the recursive call generated by typeclass resolution by itself.<br>\n3) Modify typeclass resolution.<br>\nI would like to avoid solution 3.<br>\nDo you know how to implement the second idea? Or do you have any other solutions?</p>\n<p>This situation is not made up. A solution would be really nice for my use case.</p>\n<p>Here is an artificial example:<br>\nI would like to be able to write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">Nat</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">T</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">T'</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">Nat</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T'</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">myTC</span> <span class=\"n\">where</span>\n  <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">myTC</span>\n<span class=\"kn\">open</span> <span class=\"n\">T</span>\n<span class=\"kn\">open</span> <span class=\"n\">T'</span>\n\n<span class=\"kd\">mutual</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">myTC</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">myTC</span> <span class=\"n\">T'</span> <span class=\"n\">where</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons'</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons'</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"c1\">-- `f y` uses `I`</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"c1\">-- x &gt; y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cons'</span> <span class=\"n\">y</span><span class=\"o\">)</span>  <span class=\"k\">with</span> <span class=\"c1\">-- Lean doesn't accept that.</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"n\">res</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">res</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  Indeed, `f (cons' y)` requires the instance `myTC T'` which requires `myTC T`.</span>\n<span class=\"cm\">  But even with the mutual block, Lean doesn't to figure it out.</span>\n<span class=\"cm\">  In the case `y = none`, it works.</span>\n<span class=\"cm\">  In the case `y = some (n, z)`, x &gt; z.</span>\n<span class=\"cm\">  And, `myTC T` is only needed to call `f z` which is defined as `g z`.</span>\n<span class=\"cm\">  So, my definition makes sense.</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">myTC</span> <span class=\"n\">T</span> <span class=\"n\">where</span>\n  <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">g</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The solution one would be (but it isn't appropriate in my setting):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"c1\">-- We inline the result of typeclass resolution.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">cons'</span> <span class=\"n\">y</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons'</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons'</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">z</span><span class=\"o\">)))</span> <span class=\"c1\">-- `f` is replaced by `g` here.</span>\n    <span class=\"c1\">-- x = cons y = cons (cons' (some (n, z))) so, x &gt; z.</span>\n    <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"n\">res</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">res</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> Lean isn't able to prove termination automatically because of the multiple wrapping and unwrapping.</span>\n<span class=\"cm\">  (Lean isn't able to prove x &gt; z.)</span>\n<span class=\"cm\">  The termination is proved automatically when useless `cons'` are removed in the mattern matching. -/</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">myTC</span> <span class=\"n\">T</span> <span class=\"n\">where</span>\n  <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>Many thanks for reading this far :)</p>",
        "id": 295220933,
        "sender_full_name": "Gabriel DORIATH DÖHLER",
        "timestamp": 1661432140
    },
    {
        "content": "<p>If I turn your <code>instance</code>s into <code>def</code>s and perform the instance synthesis manually (using <code>f (self := [...])</code>) then I get an error about \"structural recursion does not handle mutually recursive functions\". So I think that needs to be dealt with anyways.</p>",
        "id": 295224008,
        "sender_full_name": "Reid Barton",
        "timestamp": 1661433026
    },
    {
        "content": "<p>I suggest to first define bare functions in a mutual block then define instances because extra wrapping in the class structure makes structural recursion inapplicable.</p>\n<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">T'</span> <span class=\"bp\">→</span> <span class=\"n\">T'</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons'</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons'</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cons'</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"n\">res</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">res</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">myTC</span> <span class=\"n\">T'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">myTC</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 295225628,
        "sender_full_name": "pcpthm",
        "timestamp": 1661433504
    },
    {
        "content": "<p>Thank you very much for your answers! But, it doesn't work in my case because what you did is inlining the typeclass resolution.<br>\nIn my case, I want to avoid that because the typeclass resolution might look something like that: <code>myTC T</code> needs <code>myTC T'</code> which needs <code>my TC''</code> which needs <code>myTC T'''</code> which needs ... which needs <code>myTC T</code> (but the arguments are decreasing at recursive calls).  I do not want to inline this by hand. But if a macro exists for that, it could be a solution. I do not want to write this macro myself because it would need to be kept in sync with the typeclass resolution algorithm.</p>",
        "id": 295240565,
        "sender_full_name": "Gabriel DORIATH DÖHLER",
        "timestamp": 1661437993
    },
    {
        "content": "<p>I cannot imagine a situation where type class resolution is so complicated where it is not feasible to manually write that. Probably a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> is useful.</p>",
        "id": 295243052,
        "sender_full_name": "pcpthm",
        "timestamp": 1661438688
    },
    {
        "content": "<p>Here is a minimal example (I didn't say small...).<br>\nThe goal is to create a generic deriving framework.</p>\n<ul>\n<li>A type is represented by sums and products of units. This is done automatically from its definition by a macro.</li>\n<li>Instances for sums and products are given.</li>\n<li>They are then automatically combined and lifted to create an instance for any type that has a representation.</li>\n</ul>\n<p>Here is an example for a binary operation typeclass and lists, but the mechanism has to remain general.<br>\nIn particular, if instead of lists we used a recursive type that has a deeper functor, inlining by hand in painful.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Representation</span> <span class=\"n\">where</span>\n  <span class=\"n\">to_repr</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n  <span class=\"n\">from_repr</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kn\">open</span> <span class=\"n\">Representation</span>\n<span class=\"kn\">open</span> <span class=\"n\">Sum</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">inr</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span> <span class=\"n\">Unit</span> <span class=\"o\">(</span><span class=\"n\">unit</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- This instance will be generated automatically from the definition of `List`.</span>\n<span class=\"c1\">-- List α ~ Sum Unit (Prod α (List α))</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Representation.fromList</span> <span class=\"o\">:</span> <span class=\"n\">Representation</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Unit</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"n\">where</span>\n  <span class=\"n\">to_repr</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inl</span> <span class=\"n\">unit</span>\n    <span class=\"bp\">|</span> <span class=\"n\">h</span> <span class=\"o\">::</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inr</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"n\">from_repr</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">::</span> <span class=\"n\">t</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n\n<span class=\"c1\">-- A typeclass for binary operations.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Binop</span> <span class=\"n\">where</span>\n  <span class=\"n\">binop</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kn\">open</span> <span class=\"n\">Binop</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Binop.fromUnit</span> <span class=\"o\">:</span> <span class=\"n\">Binop</span> <span class=\"n\">Unit</span> <span class=\"n\">where</span>\n  <span class=\"n\">binop</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Binop.fromProd</span> <span class=\"o\">[</span><span class=\"n\">Binop</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Binop</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Binop</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">binop</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">binop</span> <span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">binop</span> <span class=\"n\">y</span> <span class=\"n\">y'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Binop.fromSum</span> <span class=\"o\">[</span><span class=\"n\">Binop</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Binop</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Binop</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">binop</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">inl</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inl</span> <span class=\"bp\">$</span> <span class=\"n\">binop</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inr</span> <span class=\"bp\">$</span> <span class=\"n\">binop</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- Defining generic binop by lifting.</span>\n<span class=\"c1\">-- This will also be generated by macros from the typeclass definition.</span>\n<span class=\"kd\">def</span> <span class=\"n\">gbinop</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">repr</span> <span class=\"o\">:</span> <span class=\"n\">Representation</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Binop</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">from_repr</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">repr</span> <span class=\"bp\">$</span> <span class=\"n\">binop</span> <span class=\"o\">(</span><span class=\"n\">to_repr</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_repr</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- This block would be generated by a macro from the representation type, the type and the typeclass.</span>\n<span class=\"kd\">mutual</span> <span class=\"c1\">-- This block doesn't work.</span>\n<span class=\"kd\">def</span> <span class=\"n\">binopList</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">gbinop</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Unit</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Binop.ListT</span> <span class=\"o\">[</span><span class=\"n\">Binop</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Binop</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">binop</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">gbinop</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Unit</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Intuitively, I define the Binop typeclass mutually for <code>List α</code>, <code>Sum Unit (Prod α (List α))</code>, and <code>Prod α (List α)</code>.<br>\nI could define it using bare mutually recursive functions, as you proposed.<br>\nBut, it would be long (and even more so if the functor is large) and writing a macro for it essentially reimplements typeclass resolution (because it cannot be hard coded for a particular datatype or typeclass).<br>\nI do not want to reimplement typeclass resolution, and would like to avoid having to modify it.</p>",
        "id": 295253271,
        "sender_full_name": "Gabriel DORIATH DÖHLER",
        "timestamp": 1661440826
    },
    {
        "content": "<p>Typeclass resolution constructs elements of structure types, by applying higher order functions of the form <code>C α -&gt; C (T α)</code>. Neither of those things plays well with mutual defs, which have to be function types and cannot call each other in a higher order way</p>",
        "id": 295259398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661442799
    },
    {
        "content": "<p>I would suggest you use W types explicitly in the repr macros, generating something like <code>W (fun T =&gt; Sum Unit (Prod α T))</code> for the list type instead of an unfolding that still makes use of <code>List A</code></p>",
        "id": 295259907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661442954
    }
]
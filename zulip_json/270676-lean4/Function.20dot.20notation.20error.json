[
    {
        "content": "<p>Is dot notation on functions supposed to respect which arguments are explicit vs implicit?</p>\n<p>In this example, it appears dot notation is inserting the function as the implicit argument:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Function.foo</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">f.foo</span>\n<span class=\"c1\">-- fun g x =&gt; g (f x)</span>\n</code></pre></div>\n<p>This is what I was experimenting with until I realized it might be that dot notation is trying to fill in <code>γ</code> in <code>Function.swap</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Function.swap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">Function.swap</span> <span class=\"n\">mul</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"n\">mul.swap</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">:6:7 application type mismatch</span>\n<span class=\"cm\">  @Function.swap ?m.151 ?m.152 mul</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  mul</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Nat → Nat → Nat : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ?m.151 → ?m.152 → Sort ?u.142 : Sort (max (max (?u.142 + 1) ?u.143) ?u.144)</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">mul.swap</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">:17:17 invalid universe level, ?u.264 is not greater than 0</span>\n\n<span class=\"cm\">:17:8 application type mismatch</span>\n<span class=\"cm\">  @Function.swap ?m.239 ?m.240 mul</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  mul</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Nat → Nat → Nat : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ?m.239 → Nat → Sort ?u.230 : Sort (max (?u.230 + 1) ?u.232)</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">Function.swap</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">mul.swap</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">:31:8 application type mismatch</span>\n<span class=\"cm\">  @Function.swap ?m.1489 ?m.1490 mul</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  mul</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Nat → Nat → Nat : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ?m.1489 → ?m.1490 → Sort ?u.1480 : Sort (max (max (?u.1480 + 1) ?u.1481) ?u.1482)</span>\n\n<span class=\"cm\">:31:7 type mismatch</span>\n<span class=\"cm\">  Function.swap</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ((a : ?m.1489) → (b : ?m.1490) → ?m.1511 a b) →</span>\n<span class=\"cm\">    (b : ?m.1490) → (a : ?m.1489) → ?m.1511 a b : Sort (imax (imax ?u.1482 ?u.1481 ?u.1480) ?u.1481 ?u.1482 ?u.1480)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Nat → Nat → Nat : Type</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 296716830,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662076438
    },
    {
        "content": "<p>Oh, I didn't realize that Lean 4 has changed how dot notation works from Lean 3 like this. In Lean 3 dot notation looks for the first explicit argument with the right type, but now it allows implicit arguments too. (It looks like Lean 4 started the Lean 3 way but changed in <a href=\"https://github.com/leanprover/lean4/commit/d137ecf4e8f5992f02dbdd05dbeb2d9b9574837b\">this commit</a> from 2020).</p>\n<p>A short example illustrating the difference:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S.foo</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">s.n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">37</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">s.foo</span>\n<span class=\"c\">/-</span><span class=\"cm\"> works, but in Lean 3 would give</span>\n<span class=\"cm\">invalid field notation, function 'S.foo' does not have explicit argument with type (S ...)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 296735820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662083154
    },
    {
        "content": "<p>Here's an example (in addition to <code>Function.swap</code>) that I might have expected to work with dot notation, but the function arguments conflict with the type family arguments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Function.pi_comp</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">forall_imp</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">h.pi_comp</span> <span class=\"n\">h'</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  Function.pi_comp ?m.171</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ((x : ?m.124) → ?m.144 x) → (x : ?m.124) → ?m.145 x : Sort (imax (imax ?u.117 ?u.116) ?u.117 ?u.115)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ∀ (a : α), q a : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 296742595,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662085713
    },
    {
        "content": "<p>I guess I certainly remember thinking more than once \"grr, I wish lean 3 would let dot notation work here even though the argument I want to insert is implicit\"</p>",
        "id": 296754776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662098016
    },
    {
        "content": "<p>Very brief RFC:</p>\n<p>As a first step when inserting arguments for an LVal in <code>addLValArg</code>, the elaborator should look for an argument named <code>self</code>, check that it is the only argument with that name (otherwise raise an error), and then use that argument for the expression for the field notation no matter the <code>baseName</code>.</p>\n<p>This (1) allows one to use field notation to work for <code>Function</code> even if there are type family arguments like in the above examples and (2) allows one to use field notation for extension methods that make use of typeclass instances (or coercions) associated to a type.</p>",
        "id": 296860982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662138390
    },
    {
        "content": "<p>Do you have an example for your second use case? The function must still be in the type's namespace for the elaborator to find it.</p>",
        "id": 296862940,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1662139065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Yes, I have a number of example applications (this goes back to some posts I had about graphs and getting <code>G.adj u v</code> to work for <code>G</code> having a type that implement a <code>HasAdj</code> class).</p>\n<p>Here's an example from a recent mathlib discussion that would be useful, since many different types re-implement a <code>.nonempty</code> predicate in the same way, and we like dot notation in mathlib for <code>nonempty</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HasMem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HasMem.mem</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">HasMem.nonempty</span> <span class=\"o\">[</span><span class=\"n\">HasMem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">self</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasMem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Set</span>\n<span class=\"kn\">export</span> <span class=\"n\">HasMem</span> <span class=\"o\">(</span><span class=\"n\">nonempty</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">s.nonempty</span> <span class=\"c1\">-- currently an error</span>\n</code></pre></div>",
        "id": 296865418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662139932
    },
    {
        "content": "<p>I see, it makes sense in combination with <code>export</code></p>",
        "id": 296872315,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1662142436
    },
    {
        "content": "<p>how do I import a file in the same dir? I'm trying <code>import Base</code>, but it says <code>nat_exp.lean:1:0: error: unknown package 'Base'</code>, even though <em>there is</em> a file named <code>Base.lean</code> on the same directory, which type-checks just fine</p>",
        "id": 296879268,
        "sender_full_name": "Victor Maia",
        "timestamp": 1662145207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372571\">@Victor Maia</span> if this question is unrelated to the above discussion can you ask it in a new thread?</p>",
        "id": 296884035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662147310
    },
    {
        "content": "<p>oops, sorry - I'm new to Zulip</p>",
        "id": 296884187,
        "sender_full_name": "Victor Maia",
        "timestamp": 1662147374
    },
    {
        "content": "<p>No problem!</p>",
        "id": 296884621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662147599
    },
    {
        "content": "<p>Would it be worth fleshing out the mini-RFC at <a href=\"#narrow/stream/270676-lean4/topic/Function.20dot.20notation.20error/near/296860982\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Function.20dot.20notation.20error/near/296860982</a> further? Or is it clear what the problem is and what sorts of applications would be enabled by letting a user specify the argument that field notation applies to?</p>\n<p>There are a couple alternative designs to the simplistic one of using an argument named <code>self</code>:</p>\n<ul>\n<li>Use a type annotation for the argument that should receive the object of the field notation.</li>\n<li>Use an attribute to specify the name of the argument that should receive the object of the field notation. (This also makes the feature more opt-in.)</li>\n</ul>",
        "id": 297681056,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662588359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Yes, a GitHub issue would be perfect.</p>",
        "id": 297682789,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1662589467
    }
]
[
    {
        "content": "<p>is there a mathlib for lean 4 yet? as in, a place to port lean 3 mathlib to</p>",
        "id": 221658709,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1609860332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I heard that you're working on <code>logic.basic</code></p>",
        "id": 221658834,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1609860378
    },
    {
        "content": "<p>working is a strong word</p>",
        "id": 221658853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609860390
    },
    {
        "content": "<p>There is certainly no place to port mathlib yet, and I think that's still premature</p>",
        "id": 221658911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609860418
    },
    {
        "content": "<p>I think for the present we should be doing single file experiments</p>",
        "id": 221658947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609860435
    },
    {
        "content": "<p>what do you have now?</p>",
        "id": 221658975,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1609860450
    },
    {
        "content": "<p>~nothing</p>",
        "id": 221658990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609860461
    },
    {
        "content": "<p>Well at least it would be better if there's an empty repository on github that has Lean 4 environment</p>",
        "id": 221659329,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1609860626
    },
    {
        "content": "<p>Is it too early to start threads to discuss design changes to mathlib that could be implemented during the port?</p>",
        "id": 221688953,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1609874190
    },
    {
        "content": "<p>I think we should get <code>logic.basic</code> working first</p>",
        "id": 221689537,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1609874515
    },
    {
        "content": "<p>Zulip threads are cheap, so I would say no; it's not too early. Proposals with supporting evidence from code experiments will of course be more useful, and it will also take some time before enough people are comfortable with Lean 4 for there to be much feedback. </p>\n<p>(I agree that porting <code>logic.basic</code> is a reasonable first milestone.)</p>",
        "id": 221689762,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609874628
    },
    {
        "content": "<p>It's the <code>logic.basic</code> game!</p>",
        "id": 221690968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609875308
    },
    {
        "content": "<p>Johannes Holzl used to warn against mixing porting and design changes. He said you would fail on both parts if you tried that.</p>",
        "id": 221692999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609876287
    },
    {
        "content": "<p>I can't see full porting ever happening unless we either:</p>\n<ul>\n<li>Work out a compatibility layer, like how the python ecosystem ran against both 2 and 3 with the same source code.</li>\n<li>Freeze the lean3 mathlib</li>\n<li>Automate the translation (a la <code>2to3.py</code>)</li>\n</ul>\n<p>Is there a path I'm missing?</p>",
        "id": 221694273,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609876878
    },
    {
        "content": "<p>Manual porting over the next few years</p>",
        "id": 221694440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609876943
    },
    {
        "content": "<p>I am planning to implement a preliminary version of the tool Leo suggested yesterday, with the hope that it will be easy enough for the community to tweak and extend as desired.</p>",
        "id": 221694493,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1609876984
    },
    {
        "content": "<p>(For reference, <a href=\"https://youtu.be/UeGvhfW1v9M?t=4311\">here's the relevant timestamp to Leo's talk</a>)</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"UeGvhfW1v9M\" href=\"https://youtu.be/UeGvhfW1v9M?t=4311\"><img src=\"https://i.ytimg.com/vi/UeGvhfW1v9M/default.jpg\"></a></div>",
        "id": 221694566,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609877023
    },
    {
        "content": "<p>which tool do you mean Daniel - a tool to let include both lean 3 and lean 4 files in the same build, or a tool to export lean 3 things to lean 4?</p>",
        "id": 221694754,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1609877117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238605\">Kevin Lacker</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221694754\">said</a>:</p>\n<blockquote>\n<p>which tool do you mean Daniel - a tool to let include both lean 3 and lean 4 files in the same build, or a tool to export lean 3 things to lean 4?</p>\n</blockquote>\n<ol>\n<li>add functionality to Lean3 to allow exporting the declarations plus metadata such as typeclass instances and notation in (say) a <code>foo.lean3port</code> file for each <code>foo.lean</code></li>\n<li>a stand-alone executable that transforms <code>.lean3port</code> files into the <code>.olean</code> format that Lean4 can import.</li>\n</ol>",
        "id": 221695633,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1609877600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221688953\">said</a>:</p>\n<blockquote>\n<p>Is it too early to start threads to discuss design changes to mathlib that could be implemented during the port?</p>\n</blockquote>\n<p>I'd say instead: it's not too late to start threads about design changes that could be implemented before the port <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 221696409,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609878008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> had a similar tool described here: <a href=\"#narrow/stream/113488-general/topic/Importing.20mathlib.20into.20Lean.204/near/187561178\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Importing.20mathlib.20into.20Lean.204/near/187561178</a></p>",
        "id": 221697128,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609878394
    },
    {
        "content": "<p>Presumably we'll want a tool in both directions if we're starting from logic.basic - otherwise we'd have to start at the other end</p>",
        "id": 221697455,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609878557
    },
    {
        "content": "<p>That is, importing lean 4 data into lean3 source files</p>",
        "id": 221697490,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609878583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221697128\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> had a similar tool described here: <a href=\"#narrow/stream/113488-general/topic/Importing.20mathlib.20into.20Lean.204/near/187561178\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Importing.20mathlib.20into.20Lean.204/near/187561178</a></p>\n</blockquote>\n<p>Thanks, looking at it now. It seems like the two things missing (besides all the tweaks I wasn't planning to add) are:</p>\n<ul>\n<li>don't require a monolithic import, and instead do this for each file individually</li>\n<li>export more metadata, in particular instances and notation</li>\n</ul>",
        "id": 221697792,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1609878726
    },
    {
        "content": "<p>Is \"exporting instances\" anything other than exporting attributes?</p>",
        "id": 221698586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609879184
    },
    {
        "content": "<p>My importer tool actually handles classes, instances, and simp lemmas.  (There's a separate text file for the additional metadata).</p>",
        "id": 221700845,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1609880410
    },
    {
        "content": "<p>The hard parts are:</p>\n<ol>\n<li>Recursors are now different.  (The construction of the old recursor is not hard, but you to invent a new name, etc.)</li>\n<li>I think it's important to map at least some core definition to the Lean 4 equivalent, such as natural numbers, logical constants, decidability, etc.  Otherwise the imported library is basically impossible to use.  A lot of stuff maps directly, but it's a chore to list all the new names.</li>\n<li>However many definitions in core were already different when I wrote the tool.  Now the core library has diverged even further.  (Think HasCoe, or numerals, etc.)</li>\n<li>Some definitions no longer check because of subtle changes in the type checker.  (Think large numerals, e.g. in <code>unsigned</code>.)  This should be trivial to fix when porting manually, but in an automatic tool it's a nasty curveball.</li>\n</ol>",
        "id": 221701710,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1609880812
    },
    {
        "content": "<p>my current translation of the very beginning of <a href=\"https://github.com/leanprover-community/mathlib/blob/d1b2d6eb6d5934c086393014ce93258ff0fe5090/src/logic/basic.lean\"><code>logic.basic</code></a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"sd\">/-- Ex falso, the nondependent eliminator for the `Empty` type. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Empty.elim</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Empty</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">nomatch</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Subsingleton</span> <span class=\"n\">Empty</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.elim</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Subsingleton</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a₁</span><span class=\"o\">,</span> <span class=\"n\">b₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">a₂</span><span class=\"o\">,</span> <span class=\"n\">b₂</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">_</span> <span class=\"bp\">$</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Empty</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.elim</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instSortInhabited'</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Inhabited.default</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">PUnit.unit</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">decidableEqOfSubsingleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">Subsingleton.elim</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">eqIffTrueOfSubsingleton</span> <span class=\"o\">[</span><span class=\"n\">Subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 221706623,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1609883492
    },
    {
        "content": "<p>Porting has officially begun :D</p>",
        "id": 221711032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1609886142
    },
    {
        "content": "<p>So where's the repo? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 221711171,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1609886217
    },
    {
        "content": "<p>Rather than creating a new community repo and reinviting everyone, for now I think we could create one (or several) orphan branches in the mathlib repo for Lean 4 experiments. These branches won't share any history or files with the Lean 3 mathlib (so CI won't run on them).</p>\n<p>Instructions (copied from <a href=\"https://stackoverflow.com/a/4288660\">this SO post</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>git checkout --orphan my_lean4_experiment\ngit rm -rf .\n&lt;do work&gt;\ngit add your files\ngit commit -m 'Initial commit'\n</code></pre></div>",
        "id": 221713443,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609887661
    },
    {
        "content": "<p>Then anyone can add commits to these branches as usual. <code>leanproject get-cache</code> won't work on these branches (until we set up some kind of CI), so anyone checking out such a branch will have to compile everything themselves.</p>",
        "id": 221713715,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609887835
    },
    {
        "content": "<p>(Feel free to point out reasons why this might be a terrible idea...)</p>",
        "id": 221713799,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609887873
    },
    {
        "content": "<p>If there's no CI/olean compilation concerns, I guess a Lean 4 mathlib repo could theoretically use the \"normal\" model for a Github repository. E.g. a repo with the maintainers invited, but then people work on forks + PRing rather than pushing their branches to the main repo? Which would mean no worries about reinviting everyone? Although I think orphan branches is a certainly clever approach if the preference is to avoid a new repo <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 221714487,
        "sender_full_name": "Alex Peattie",
        "timestamp": 1609888329
    },
    {
        "content": "<p>Has anyone made a back-of-the-envelope estimate of how much time it would take to just port Mathlib manually, bottom-up? Here is a heavily-simplified first attempt:</p>\n<p>Assuming:</p>\n<ul>\n<li>50,000 theorems</li>\n<li>100 collaborators</li>\n<li>X minutes on average to port a theorem (this has high variance)</li>\n<li>40 hour work-weeks</li>\n</ul>\n<p>It would take:</p>\n<ul>\n<li>500 theorems per person</li>\n<li>500 * X minutes per person</li>\n<li>500 * X / (60 * 40) weeks in total</li>\n</ul>\n<p>After an initial investment to write Lean3-parity tactics/automation in Lean4 (which will presumably be necessary anyway), what would be a good estimate for X? 2? 5? 10? Even if X is 10, the porting would only take two weeks under this model. Even if a better model predicted 2 months, it might still be worth just pulling off the band-aid. Note: I am not suggesting this approach, only floating the idea.</p>",
        "id": 221726706,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1609899398
    },
    {
        "content": "<p>I think we should be using some sort of automation, maybe parse the current mathlib into some sort of abstract syntax tree and then visit that syntax tree to emit Lean 4 code. <a href=\"https://blog.isquaredsoftware.com/2018/11/git-js-history-rewriting/\">https://blog.isquaredsoftware.com/2018/11/git-js-history-rewriting/</a></p>",
        "id": 221726907,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1609899654
    },
    {
        "content": "<p>At the end of the day there would many steps that are purely mechanical and doing them by hand would be a waste of time.</p>",
        "id": 221726992,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1609899772
    },
    {
        "content": "<p>Yes, there is a lot that could be done automatically, though I expect the porting time will be dominated by the time it takes to fix the tactic scripts that (even after syntactically adjusting them) no longer work for subtle reasons.</p>",
        "id": 221727169,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1609899976
    },
    {
        "content": "<p>As someone who has written automation to parse proofs into abstract syntax trees, it is really hard to do.  Lean's grammar is dynamic and only Lean can truly parse Lean.  One option is to modify the current C++ Lean 3 parser to output the needed information.  </p>\n<p>Or, we were able to get pretty far by hacking into to parts of the Lean parsing framework and writing a light weight parser to get the rest of the way there. (It would also be possible to build on the current C++ Lean 3 parser to get this data as well.) I'm happy to share what we have when it's ready.  We don't have ASTs for the whole file, just for tactic proofs and we don't parse expressions (which one would have to change because of capitalization changes).  We just store the expressions as strings right now.  I'm not sure if this would be helpful or not (especially in light of Daniel's comments).</p>",
        "id": 221727603,
        "sender_full_name": "Jason Rute",
        "timestamp": 1609900483
    },
    {
        "content": "<p>I'm wondering how feasible it would be to adopt an incremental approach where files in Lean 3 are incrementally \"frozen\" in Lean 3 and then ported to Lean 4.   Once a given file is done, you shouldn't merge any PR changes into those files, but before then, it's ok to keep working on the Lean 3 versions.  If you are predominantly working in certain files, then you could migrate to Lean 4 once they are ported.  A file would only be eligible for freezing after all it's imports are.</p>",
        "id": 221727954,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1609900953
    },
    {
        "content": "<p>That sounds a lot like the \"strangler pattern\".</p>",
        "id": 221728274,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1609901448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span> One risk for any incremental approach is a bad Nash-equilibrium. I fear that individuals may not have sufficient incentive to invest heavily in Lean4 until they are confident that others will as well. In the 'pulling off the band-aid' approach, the community-optimal incentives could be achieved immediately by a community decision to freeze mathlib3 and to port to Lean4 before resuming business-as-usual.</p>",
        "id": 221729668,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1609903194
    },
    {
        "content": "<p>I was thinking kinda thinking that it would be good to let people interested in formalizing particular theories continue to do so while the more fundamental building blocks (e.g., decision procedures, logical foundations) are ported.  The collective community decision though would be that Lean 3 versions are not to be updated for any reason once the Lean 4 porting of those versions is underway.<br>\nThere could be a long tail of porting various particular contributions over with this though, so maybe there would be a deadline associated with freezing the entire codebase.<br>\nI'm not familiar with the strangler pattern, but I wasn't thinking about intermingling the ability to use Lean 3 within Lean 4 (or vice versa).</p>",
        "id": 221735602,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1609911224
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> the problem with your calculation is that it only works if you can port file <code>xyzzy</code> even though you don't know what its ported dependencies <code>foo</code>, <code>bar</code>, and <code>quux</code> look like. You can do it with 100 people in two weeks <em>if</em> you can parallelise the tasks. But I don't know if that is true.</p>",
        "id": 221735671,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609911343
    },
    {
        "content": "<p>We had a lintsprint two months ago. That worked well, with say 10-15 people contributing several PRs a day. But there were no interdependencies between those PRs.</p>",
        "id": 221735723,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609911380
    },
    {
        "content": "<p>So, if we can get lean 4 to work with special <code>.lean3olean_plus_mathlib_metadata</code> files, then we might be able to parallelise the porting effort.</p>",
        "id": 221735733,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609911421
    },
    {
        "content": "<p>Also, as warned above, porting would need to be very <em>very</em> strict, otherwise the parallelism will break. Everytime you see some bad design, leave a comment, but copy it faithfully. People importing your file will thank you later.</p>",
        "id": 221735751,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609911466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221726706\">said</a>:</p>\n<blockquote>\n<p>Assuming:</p>\n<ul>\n<li>50,000 theorems</li>\n<li>100 collaborators</li>\n<li>X minutes on average to port a theorem (this has high variance)</li>\n<li>40 hour work-weeks</li>\n</ul>\n<p>It would take:</p>\n<ul>\n<li>500 theorems per person</li>\n<li>500 * X minutes per person</li>\n<li>500 * X / (60 * 40) weeks in total</li>\n</ul>\n</blockquote>\n<p>Also, I don't think 100 people will invest 2 weeks of 40 hours in porting stuff. In Feb/March I can probably invest 3 full weeks, but I guess I'm an exception. So it will probably be more like 10 people working for 20 weeks... and then, I don't have 20 weeks that I can work nonstop on this project.</p>",
        "id": 221742242,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609920255
    },
    {
        "content": "<p>I guess the olean export/import is what is meant to allow parallelism. But I also think that some kind of automatic preliminary translation of <em>statements</em> would be nice (tactic proofs are probably hopeless and for term proofs we want to use the new features of Lean 4 to kill <code>@ _ _ _ _</code>).</p>",
        "id": 221744326,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1609922204
    },
    {
        "content": "<p>My two cents here:</p>\n<p>Some of us remember the old days when Lean was always changing underneath us, and we all know the \"bump Lean to 3.24.0c\" PRs to mathlib. These can be painful, and Lean 4 is brand new and presumably in flux. <em>This is fine,</em> even good. It's a sign the system is improving. But it adds tremendously to the cost of a port.</p>",
        "id": 221746207,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923889
    },
    {
        "content": "<p>I don't think we should start a full port now, or even necessarily soon. It's time to experiment. And there are a number of experiments to do, all somewhat independent.</p>",
        "id": 221746214,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923894
    },
    {
        "content": "<p>One is what Leo suggested in his talk: import Lean 3 mathlib with metadata and try to build on that, or port files at the top of the import hierarchy. This gives very important information about how Lean 4 features will scale. There was a lot about Lean 3 that we didn't learn until mathlib got big.</p>",
        "id": 221746218,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923899
    },
    {
        "content": "<p>This is a really important experiment but I'm skeptical about it as a long-term survival strategy for mathlib. IMO the Frankenstein approach will be harder to maintain and much harder for new contributors to wrap their heads around. The community development style is an essential part of mathlib and if we arrive at something that we can't teach newcomers, we've lost the game.</p>",
        "id": 221746227,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923906
    },
    {
        "content": "<p>Two is what people started yesterday, just start porting things from the ground up. Learn Lean 4 syntax and bug hunt on smaller proofs. This is totally independent of the first approach. As I said, I think it's too early to dump everyone's full effort into doing this. But carving out an initial chunk -- <code>logic.basic</code>, some of <code>algebra</code>, core pieces of <code>data</code> -- will be really helpful, especially to see the effects of the inevitable changes to Lean 4.</p>",
        "id": 221746234,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923912
    },
    {
        "content": "<p>Three, there's the 20k loc in <code>tactic</code>. Any kind of automated porting here seems hopeless. Many mathlib tactics are basically just linguistic things (<code>obtain</code>, <code>set</code>, etc) that might even be two-line macros in Lean 4. <code>ring</code>, <code>linarith</code>, <code>slim_check</code>, etc will be hard to port. (Leo said he plans to implement a version of <code>linarith</code> himself at some point.) The current <code>omega</code> is almost certainly dead. For a native Lean 4 mathlib, we need versions of most of this. Porting tactics isn't completely independent of the second approach, but I think it can be started independently. And as before, we should experiment with metaprogramming before committing to porting the big stuff.</p>",
        "id": 221746240,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923920
    },
    {
        "content": "<p>So I'd like to see three experiments done in parallel and independently. These can help us in the future but none is expected to be the future. Lean 3 mathlib development can continue in Lean 3, albeit likely at a slower pace if people are directing their time to the porting effort. After some iteration on these experiments, we'll have a better idea how to approach a full port. In particular we'll have more accurate numbers for Daniel's time estimate.</p>",
        "id": 221746246,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923928
    },
    {
        "content": "<p>(Sorry for the essay!)</p>",
        "id": 221746250,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609923932
    },
    {
        "content": "<p>Don't forget to add experimentation with rebuilding the basic algebraic hierarchy (without proving any lemma) using the structure command provided by Lean4 or a new new structure command somewhat simulating the old structure command using the new one. Or even try to rebuild it using unification hints!</p>",
        "id": 221746424,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1609924075
    },
    {
        "content": "<p>I mostly agree with Rob, except that the critique of Frankenlean's monster maybe misses the point a bit.  The motivation behind a hybrid Lean 3 / Lean 4 mathlib is as a viable <em>temporary transition strategy</em>.  Porting mathlib is gonna take a few months.  We know from linting sprints that we can organize incremental library cleanups.  I am not sure we can pull off having two separate repositories.</p>",
        "id": 221746913,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1609924505
    },
    {
        "content": "<p>I don't see how we achieve a full port top-down, but I'd be happy to be proven wrong.</p>",
        "id": 221747307,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1609924826
    },
    {
        "content": "<p>I fear the rate at which mathlib is ported will be slower that the rate at which the lean3 version grows - so a multiple repository approach seems like it wouldn't work, and a hybrid approach is the only option.</p>",
        "id": 221747371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609924899
    },
    {
        "content": "<p>Can we strive for a bottom-up port instead?</p>",
        "id": 221747377,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609924914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221747371\">said</a>:</p>\n<blockquote>\n<p>I fear the rate at which mathlib is ported will be slower that the rate at which the lean3 version grows - so a multiple repository approach seems like it wouldn't work</p>\n</blockquote>\n<p>I wonder if there are some areas of interest to mathlib that are not well represented in mathlib so far (and so have few serious dependecies). People could start working on some of these from almost nothing in a mathlib 4, such projects might be a fun way for the community to learn lean 4 that isn't just porting existing work.</p>",
        "id": 221747581,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1609925098
    },
    {
        "content": "<p>numerical analysis?</p>",
        "id": 221747746,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609925225
    },
    {
        "content": "<p>see the undergrad page, there are several sections that are just empty</p>",
        "id": 221747767,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1609925242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221747371\">said</a>:</p>\n<blockquote>\n<p>I fear the rate at which mathlib is ported will be slower that the rate at which the lean3 version grows - so a multiple repository approach seems like it wouldn't work, and a hybrid approach is the only option.</p>\n</blockquote>\n<p>Once the porting gets far enough, it will be stable enough that people can feel comfortable writing new things in lean 4 mathlib, so the rate of lean 3 mathlib contributions will plateau and eventually dwindle</p>",
        "id": 221749112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609926507
    },
    {
        "content": "<p>But I definitely think that porting will take far too long for a global freeze to be viable</p>",
        "id": 221749144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609926562
    },
    {
        "content": "<p>Freezing at a file level is maybe doable, although I don't think it's particularly necessary, since the changes that happen to a given file are usually pretty low frequency. We have done lint sprints and other refactorings at about this level of disruptiveness already in the past</p>",
        "id": 221749339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609926707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221749144\">said</a>:</p>\n<blockquote>\n<p>But I definitely think that porting will take far too long for a global freeze to be viable</p>\n</blockquote>\n<p>Once all tactic files and all basic algebra files are ported, I wouldn't be surprised if the port were essentially mechanical. Maybe I'm too optimistic, but I guess we will stumble all the time on the same issues, so once we know how to fix these I don't see why it wouldn't be pretty smooth.</p>",
        "id": 221756086,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1609931754
    },
    {
        "content": "<p>I think it is definitely worth the time to set up the means to make it as mechanical as possible, but I don't think we will be able to reduce the manual part of the porting to zero. A few files a day seems like an upper limit on the amount of work one person could get done if it's all going smoothly, so together with the PRs and coordination I think a few months sounds about right</p>",
        "id": 221767444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609940326
    },
    {
        "content": "<p>In terms of new designs for mathlib, after the port, it would be valuable to move tactics into a separate packages so that we can run them in mathlib in compiled form. (unless Leo implements just-in-time compilation) That will likely be a big change.</p>",
        "id": 221802435,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609957158
    },
    {
        "content": "<p>in my experience with porting projects, they fail not when there is too much overall work, but when there are 2 or 3 critical things that are so hard to port, the people working on it eventually give up and nobody wants to try any more. so I am curious what are the hardest parts of mathlib to port, that are critical for mathlib. is it complex but commonly used tactics like <code>ring</code>, <code>omega</code>, <code>simp</code>, <code>linarith</code>, etc?</p>",
        "id": 221825799,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1609968360
    },
    {
        "content": "<p>I haven't thought through the implementation, but it seems like it should be possible to compile tactics in one module and use the compiled version in other modules without a JIT.  I think this would result in using the compiled versions in most cases.</p>",
        "id": 221825951,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1609968437
    },
    {
        "content": "<p>Lean 4 has a simplifier, but all the other tactics you mentioned will have to be ported.</p>",
        "id": 221826020,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1609968475
    },
    {
        "content": "<p>For most tactics, I expect that we can port them just like we port other things. That said I would bet that we want to make more significant changes to some of them: <code>omega</code> needs to be rewritten, <code>simp</code> will be rewritten, <code>linarith</code> might be rewritten</p>",
        "id": 221832551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609972329
    },
    {
        "content": "<p>Should mathlib porting guidelines make a firm statement about <code>set_option autoBoundImplicitLocal false</code>?</p>",
        "id": 221834072,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609973268
    },
    {
        "content": "<p>What's it mean?</p>",
        "id": 221834190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609973322
    },
    {
        "content": "<p>Consider the following: <a href=\"https://gist.github.com/shingtaklam1324/7451d7e329aa32efd42dd49d784ac8a5#file-algebra_groups_defs-lean-L15\">https://gist.github.com/shingtaklam1324/7451d7e329aa32efd42dd49d784ac8a5#file-algebra_groups_defs-lean-L15</a></p>",
        "id": 221834229,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609973343
    },
    {
        "content": "<p>The <code>u</code> is coming from the fact that it is a lowercase letter, and can be inferred, so it is.</p>",
        "id": 221834251,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609973361
    },
    {
        "content": "<p>I would say use it freely</p>",
        "id": 221834289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609973384
    },
    {
        "content": "<p>As remarked on here <a href=\"https://leanprover.github.io/lean4/doc/autobound.html?highlight=lower#auto-bound-implict-arguments\">https://leanprover.github.io/lean4/doc/autobound.html?highlight=lower#auto-bound-implict-arguments</a></p>",
        "id": 221834295,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609973387
    },
    {
        "content": "<p>If it's possible, I want to bring back <code>Sort*</code> via notation</p>",
        "id": 221834354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609973403
    },
    {
        "content": "<p>I think, as long as it's still basically making the right guesses, we should use <code>Sort*</code> or <code>Type*</code> wherever possible, because it makes universe errors less likely</p>",
        "id": 221834440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609973466
    },
    {
        "content": "<p>The bottom snippet in <a href=\"https://leanprover.github.io/lean4/doc/typeobjs.html?highlight=type%20_#types-as-objects\">https://leanprover.github.io/lean4/doc/typeobjs.html?highlight=type%20_#types-as-objects</a> is about <code>Type*</code> or <code>Sort*</code></p>",
        "id": 221834462,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609973482
    },
    {
        "content": "<p>Right, we're going to need a mathlib prelude anyway and this should go in it</p>",
        "id": 221834494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609973519
    },
    {
        "content": "<p>For times when it's necessary to use explicit universes, it's marginally more convenient to use implicit universe arguments than <code>universes u v</code> which is mostly noise</p>",
        "id": 221834633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609973630
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/mathlib4/blob/master/src/logic/basic.lean\">https://github.com/kckennylau/mathlib4/blob/master/src/logic/basic.lean</a></p>",
        "id": 221935363,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1610022127
    },
    {
        "content": "<p>Is that the official mathlib port repo? :D</p>",
        "id": 221935386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610022144
    },
    {
        "content": "<p>it’s my unofficial mathlib port repo</p>",
        "id": 221935419,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1610022167
    },
    {
        "content": "<p>You'd better document your instances or the linter will complain</p>",
        "id": 221935430,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610022183
    },
    {
        "content": "<p>In fact <span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> was telling me that we should document all theorems too, because then AI will be able to learn better about mathematical natural language</p>",
        "id": 221935478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610022232
    },
    {
        "content": "<p>Maybe then we can train <code>gpt</code> to insert a comment explaining in natural language why it rewrote <code>add_comm</code> repeatedly</p>",
        "id": 221936110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610022676
    },
    {
        "content": "<p>\"Because it's there\"</p>",
        "id": 221936133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610022701
    },
    {
        "content": "<p>More seriously though, that knowledge would definitely help build a more powerful method for searching theorems in the docs</p>",
        "id": 221936242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610022773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/mathlib/near/221935478\">said</a>:</p>\n<blockquote>\n<p>In fact <span class=\"user-mention silent\" data-user-id=\"116045\">Jesse Michael Han</span> was telling me that we should document all theorems too, because then AI will be able to learn better about mathematical natural language</p>\n</blockquote>\n<p>yes, this would be extremely useful as training data for informal-to-formal machine translation</p>",
        "id": 221997949,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1610052189
    },
    {
        "content": "<p>Perhaps vice versa too, given the discussion in the teaching panel about transitioning to paper from lean</p>",
        "id": 221999616,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610053003
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 222017609,
        "sender_full_name": "Mohamed Al-Fahim",
        "timestamp": 1610062867
    },
    {
        "content": "<blockquote>\n<p>I wonder if there are some areas of interest to mathlib that are not well represented in mathlib so far (and so have few serious dependecies). </p>\n</blockquote>\n<p>graph theory and combinatorics!</p>",
        "id": 222081040,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1610117743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> so are you going to work on graph theory in Lean 4</p>",
        "id": 222081281,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1610117866
    },
    {
        "content": "<p>I might</p>",
        "id": 222081303,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1610117879
    },
    {
        "content": "<p>I've just barely started wrapping my head around how Lean 3 works but it might be worth it for me to start experimenting w/ Lean 4 since we're planning to port anyway</p>",
        "id": 222081446,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1610117934
    },
    {
        "content": "<p>let's go</p>",
        "id": 222081749,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1610118064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270523\">@Huỳnh Trần Khanh</span> thank you. i am interested in experimenting with some category theory stuff in lean. is anything available yet for lean4? how long would you expect for mathlib to be upgraded for lean4? as someone who has never uesd lean before, would you suggest i stick to lean3 for now or to try to port myself the relevant bits from mathlib to lean4?</p>",
        "id": 224828740,
        "sender_full_name": "Nasos Evangelou-Oost",
        "timestamp": 1612241334
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"386149\">@Nasos Evangelou-Oost</span> I'd say stick with Lean 3 for now. Lean 4 is still unstable.</p>",
        "id": 224829607,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1612242398
    },
    {
        "content": "<p>There was a recent soundness bug. Already fixed, but who knows if there are still other bugs lurking somewhere.</p>",
        "id": 224829697,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1612242486
    },
    {
        "content": "<p>more importantly, it doesn't have many of the features of lean 3 yet, only the ability to eventually write them. This is going to take a while</p>",
        "id": 224829718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612242537
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270523\">@Huỳnh Trần Khanh</span> i see. actually what i'm more interested is in computational category theory and general purpose programming. i recently was surprised to learn that lean4 is actually quite capable of this.  i'm currently working on a project in F# but the lack of dependent types is limiting. i also considered idris2 as a general-purpose dependently typed language but it is in prerelease and its development seems slow (idris 1 seems too slow to be able to do anything useful).</p>",
        "id": 224830030,
        "sender_full_name": "Nasos Evangelou-Oost",
        "timestamp": 1612242925
    },
    {
        "content": "<p>Is there a roadmap until <code>port : Lean3 -&gt; Lean4</code> <code>port mathlib</code>?</p>",
        "id": 230591743,
        "sender_full_name": "SnowFox",
        "timestamp": 1615928943
    },
    {
        "content": "<p>lean4 seems significantly different. Does this mean mathlib has to be written again?</p>",
        "id": 232122060,
        "sender_full_name": "Sayantan Majumdar",
        "timestamp": 1616883351
    },
    {
        "content": "<p>Lean 4 is very similar to lean 3, but sufficiently different to make porting the maths library a nontrivial problem. Right now we're letting the experts think about this but it's still early days.</p>",
        "id": 232123823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616885311
    }
]
[
    {
        "content": "<p>I'd like to start the repo for mathlib 4. The idea is that for the present it will serve a role similar to <code>library_dev</code> from the old days: it will collect some basic theorems about nat, list and a few other things that I think everyone who is using lean 4 is rediscovering. The intent will be to later replace this with the ported version when the mathlib porting effort is ready, but in the meanwhile there are still a lot of things that can be done with only a basic library, where the cost of duplicated work is worth having these lemmas available for the current small experiments.</p>\n<p>Additionally, as I've mentioned before, there is a second mathlib spinoff project, that I'm calling the mathlib prelude. This will collect all the tactics used by mathlib proper such as <code>ring</code>, <code>linarith</code> and the myriad small tactics. Due to lean 4's architecture, it is necessary for these tactics to exist in a separate compilation unit so that they can be available in their compiled form in mathlib. (You can use a tactic immediately after its definition but this uses the interpreter and so doesn't benefit from the tremendous work done on the lean 4 compiler.)</p>\n<p>Which brings me to the issue: should these two be separate repositories or not? I think that having all of mathlib in one monorepo reduces the maintenance cost of adding features to lean significantly, and I think most would agree that making even a comparatively simple change in lean core today is higher friction than adding to mathlib, since at the very least a new version of lean containing the modification has to be released and mathlib updated for the new version, both things that mathlib changes don't have to worry about.</p>\n<p>A natural solution would be to have mathlib and the prelude in two folders of one repo. But I don't know if lean 4 (or more accurately leanpkg) can currently handle packages that exist in subfolders of a repo.</p>\n<p>What do people think about the plan and/or the timing? I don't think there is any reason to delay further, once the logistical issues are resolved.</p>",
        "id": 237986680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620510206
    },
    {
        "content": "<p>I think that it is a good idea to have a mathlib. If you create it, I will use it.</p>",
        "id": 237987342,
        "sender_full_name": "Guilherme Silva",
        "timestamp": 1620510977
    },
    {
        "content": "<p>Why can't you just have a directory <code>prelude</code> in a mathlib 4 repo? I don't understand your question about <code>leanpkg</code>. Why does <code>prelude</code> have to be a package? If it becomes constant later you could split it off maybe?</p>\n<p>I have been porting parts of mathlib to Lean 4. It's fun. My main worry is that lean 3 keeps moving. I started on some famous file (maybe <code>data.list.basic</code>?) yesterday and discovered that it was last edited about a week ago.</p>",
        "id": 237988067,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620511809
    },
    {
        "content": "<blockquote>\n<p>Why can't you just have a directory prelude in a mathlib 4 repo?</p>\n</blockquote>\n<p>That's also a theoretical possibility, although I'm quite sure that lean 4 doesn't currently support a project setup like this. But we can quite possibly make it work if we use a custom build process, since lean itself can be driven at the per-file level and we just need to call the compiler at the right time and import it when compiling other mathlib files. In the end we'll surely need our own build process so this isn't totally outlandish.</p>",
        "id": 237988275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620512083
    },
    {
        "content": "<blockquote>\n<p>I have been porting parts of mathlib to Lean 4. It's fun. My main worry is that lean 3 keeps moving. I started on some famous file (maybe data.list.basic?) yesterday and discovered that it was last edited about a week ago.</p>\n</blockquote>\n<p>I have no intention of being completionist or trying to keep it up to date with mathlib. That will wait until the port is ready, at which point we can just make sure that any divergence between the mathlib 3 and mathlib 4 libraries in those files is merged.</p>",
        "id": 237988368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620512210
    },
    {
        "content": "<p>The main goal at this point is to have the things that lean 4 users need, not feature parity with mathlib 3</p>",
        "id": 237988457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620512310
    },
    {
        "content": "<blockquote>\n<p>A natural solution would be to have mathlib and the prelude in two folders of one repo. But I don't know if lean 4 (or more accurately leanpkg) can currently handle packages that exist in subfolders of a repo.</p>\n</blockquote>\n<p>Keeping things in a single repository makes sense to me. In my understanding, <code>leanpkg</code> is at least somewhat modeled after Rust's <code>cargo</code>, and <code>cargo</code> supports that kind of pattern very nicely (with <a href=\"https://doc.rust-lang.org/cargo/reference/workspaces.html\">cargo workspaces</a> and some other features).</p>",
        "id": 237993571,
        "sender_full_name": "David Renshaw",
        "timestamp": 1620518224
    },
    {
        "content": "<p>This is a great idea, and the timing is good.  We've been waiting for this to happen.</p>\n<p>I'd definitely prefer a monorepo (in particular if we need to move stuff from mathlib to prelude and back to satisfy the staging requirements of Lean 4).  I fully expect some issues to arise with this setup, but I believe the whole point of mathlib4 is to find and iron out these bugs.</p>",
        "id": 238015462,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620544207
    },
    {
        "content": "<p>What <code>leanpkg</code> can do:</p>\n<ul>\n<li>depend on a package in a subdir using <code>{ path = \"prelude\" }</code></li>\n</ul>\n<p>What <code>leanpkg</code> cannot do yet:</p>\n<ul>\n<li>automatically compile a dependency into a shared library and pass it in <code>--plugin</code></li>\n<li>share a common lock file between related packages, cargo workspaces-like<ul>\n<li>We don't even have lock files yet. We should.</li>\n</ul>\n</li>\n<li>depend on packages in a subdirectory of a <em>different</em> repository (apparently cargo simply searches the whole repo for a <code>Cargo.toml</code>...?)<ul>\n<li>only relevant if someone wants to depend on mathlib prelude without mathlib</li>\n</ul>\n</li>\n</ul>\n<p>In summary, leanpkg is in need of some serious love in general (contributions welcome), but it has (almost) equal support for both repo approaches</p>",
        "id": 238015823,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620544619
    },
    {
        "content": "<p>Ah, this works much better than I'd expected: <a href=\"https://github.com/gebner/lean4-split-leanpkg\">https://github.com/gebner/lean4-split-leanpkg</a>   At least, <code>leanpkg build</code> works in every subdirectory.  And you can also use it as a dependency.</p>",
        "id": 238016694,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620545547
    },
    {
        "content": "<blockquote>\n<p>We don't even have lock files yet. We should.</p>\n</blockquote>\n<p>leanpkg has <em>only</em> lock files (the revisions of the dependencies are fixed after all)</p>",
        "id": 238016749,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620545617
    },
    {
        "content": "<p>Ah, I didn't remember whether <code>rev</code> was optional. An actual reproducibility issue is <code>lean_version = \"leanprover/lean4:nightly\"</code> though.</p>",
        "id": 238016949,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620545838
    },
    {
        "content": "<p>Right, elan should just reject that.</p>",
        "id": 238016964,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620545866
    },
    {
        "content": "<p>What heuristic would elan use? Reject \"nightly\" specifically? Reject all branches?</p>",
        "id": 238017194,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620546163
    },
    {
        "content": "<p>Even tags are a reproducibility issue, as they can in principle be moved</p>",
        "id": 238017210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620546188
    },
    {
        "content": "<p>Okay, I've created <a href=\"https://github.com/leanprover-community/mathlib4\">https://github.com/leanprover-community/mathlib4</a> . I tried to set something up like <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> 's demo but I'm not sure what to do about the \"main\" files, since mathlib is a library, not an application</p>",
        "id": 238017742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620546845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  I think nightly is even more special, since it isn't a tag or branch.  Instead it refers to the latest tag in the nightlies repository.</p>",
        "id": 238017761,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620546884
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think <code>prelude/leanpkg.toml</code> is missing.</p>",
        "id": 238017834,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620546965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238017742\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what to do about the \"main\" files, since mathlib is a library, not an application</p>\n</blockquote>\n<p>I think the main file needs to import all of the other ones, otherwise they won't be compiled.</p>",
        "id": 238017877,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620547060
    },
    {
        "content": "<p>Why can't they just be compiled separately e.g. via make</p>",
        "id": 238017930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620547103
    },
    {
        "content": "<p>Right now the hierarchy looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">prelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">Tactic</span><span class=\"bp\">/</span>\n    <span class=\"n\">Basic.lean</span>\n  <span class=\"n\">Main.lean</span>\n  <span class=\"n\">leanpkg.toml</span>\n<span class=\"n\">src</span><span class=\"bp\">/</span>\n  <span class=\"n\">Algebra</span><span class=\"bp\">/</span>\n    <span class=\"n\">etc.</span>\n<span class=\"n\">leanpkg.toml</span>\n</code></pre></div>\n<p>Inside <code>prelude/Main.lean</code> I tried to <code>import Tactic.Basic</code> but it doesn't like it. (unknown package 'Tactic') There are no path settings in <code>prelude/leanpkg.toml</code></p>",
        "id": 238018298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620547510
    },
    {
        "content": "<p>I've just pushed a fix.  You're not going to like it.</p>",
        "id": 238019009,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620548405
    },
    {
        "content": "<p>Apparently, Lean 4 doesn't like the <code>src</code> directory.  It wants a <code>Mathlib</code> directory and a <code>Mathlib.lean</code> file (you could also use <code>OMGPleaseNo/</code> and <code>OMGPleaseNo.lean</code>).</p>",
        "id": 238019045,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620548459
    },
    {
        "content": "<p>Lean's standard library has a makefile that does this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">stdlib</span><span class=\"o\">:</span>\n<span class=\"bp\">#</span> <span class=\"n\">Use</span> <span class=\"bp\">`+`</span> <span class=\"n\">to</span> <span class=\"n\">use</span> <span class=\"n\">the</span> <span class=\"n\">Make</span> <span class=\"n\">jobserver</span> <span class=\"k\">with</span> <span class=\"bp\">`</span><span class=\"n\">leanmake</span><span class=\"bp\">`</span> <span class=\"n\">for</span> <span class=\"n\">parallelized</span> <span class=\"n\">builds</span>\n    <span class=\"bp\">+</span><span class=\"s2\">\"${LEAN_BIN}/leanmake\"</span> <span class=\"n\">lib</span> <span class=\"n\">PKG</span><span class=\"bp\">=</span><span class=\"n\">Init</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">LEANMAKE_OPTS</span><span class=\"o\">)</span>\n    <span class=\"bp\">+</span><span class=\"s2\">\"${LEAN_BIN}/leanmake\"</span> <span class=\"n\">lib</span> <span class=\"n\">PKG</span><span class=\"bp\">=</span><span class=\"n\">Std</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">LEANMAKE_OPTS</span><span class=\"o\">)</span>\n    <span class=\"bp\">+</span><span class=\"s2\">\"${LEAN_BIN}/leanmake\"</span> <span class=\"n\">lib</span> <span class=\"n\">PKG</span><span class=\"bp\">=</span><span class=\"n\">Lean</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">LEANMAKE_OPTS</span><span class=\"o\">)</span>\n    <span class=\"bp\">+</span><span class=\"s2\">\"${LEAN_BIN}/leanmake\"</span> <span class=\"n\">bin</span> <span class=\"n\">PKG</span><span class=\"bp\">=</span><span class=\"n\">Leanpkg</span> <span class=\"n\">BIN_NAME</span><span class=\"bp\">=</span><span class=\"n\">leanpkg</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">LEANMAKE_OPTS</span><span class=\"o\">)</span> <span class=\"n\">LINK_OPTS</span><span class=\"bp\">=</span><span class=\"s2\">\"${CMAKE_EXE_LINKER_FLAGS}\"</span>\n</code></pre></div>\n<p>The corresponding directory structure is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">src</span><span class=\"bp\">/</span>\n  <span class=\"n\">Init</span><span class=\"bp\">/</span>\n    <span class=\"n\">stuff...</span>\n  <span class=\"n\">Std</span><span class=\"bp\">/</span>\n    <span class=\"n\">stuff...</span>\n  <span class=\"n\">Init.lean</span>\n  <span class=\"n\">Std.lean</span>\n</code></pre></div>\n<p>and you can refer to things as <code>Init.*</code> and <code>Std.*</code>, with no extra prefix. Can we make that work?</p>",
        "id": 238019071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620548471
    },
    {
        "content": "<p>It is not clear to me whether <code>Init</code> is used compiled when building <code>Std</code>... probably it's just using stage 0</p>",
        "id": 238019144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620548547
    },
    {
        "content": "<p>your fix isn't working for me</p>",
        "id": 238019322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620548784
    },
    {
        "content": "<p>I still get \"unknown package 'Tactic'\" when running <code>leanmake</code> in the <code>prelude</code> directory</p>",
        "id": 238019335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620548809
    },
    {
        "content": "<p>It worked for me.  But that was probably due to old olean files. :-/</p>",
        "id": 238019361,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620548845
    },
    {
        "content": "<p>It works if I use <code>MathlibPrelude.Tactic.Basic</code> inside <code>MathlibPrelude.lean</code></p>",
        "id": 238019457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620548991
    },
    {
        "content": "<p>that also works inside the editor for <code>Logic/Basic.lean</code> but <code>leanmake</code> at the root fails with <code>build/temp/Mathlib/Logic/Basic.depend: No such file or directory</code></p>",
        "id": 238019537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620549046
    },
    {
        "content": "<p>Can you try <code>git clean -fdx</code>?  It works for me, now.</p>",
        "id": 238019561,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620549114
    },
    {
        "content": "<p>The <code>src/</code> directory in the Lean repo is just a historical artifact</p>",
        "id": 238019652,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620549189
    },
    {
        "content": "<p>I pulled the latest and used <code>git clean -fdx</code>, and <code>leanmake</code> works inside <code>prelude</code> but not at <code>/</code></p>",
        "id": 238019872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620549430
    },
    {
        "content": "<p>Ok, this is weird.  I can't reproduce this at all.</p>",
        "id": 238019951,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620549527
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">leanmake</span>\n<span class=\"n\">unknown</span> <span class=\"n\">package</span> <span class=\"bp\">'</span><span class=\"n\">MathlibPrelude'</span>\n<span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">mario</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"bp\">-</span><span class=\"n\">lean4</span><span class=\"bp\">-</span><span class=\"n\">nightly</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/../</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">lean.mk</span><span class=\"o\">:</span><span class=\"mi\">98</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">temp</span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Logic</span><span class=\"bp\">/</span><span class=\"n\">Basic.depend</span><span class=\"o\">:</span> <span class=\"n\">No</span> <span class=\"n\">such</span> <span class=\"n\">file</span> <span class=\"n\">or</span> <span class=\"n\">directory</span>\n<span class=\"n\">make</span><span class=\"o\">:</span> <span class=\"bp\">***</span> <span class=\"o\">[</span><span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">mario</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"bp\">-</span><span class=\"n\">lean4</span><span class=\"bp\">-</span><span class=\"n\">nightly</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/../</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">lean.mk</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">temp</span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Logic</span><span class=\"bp\">/</span><span class=\"n\">Basic.depend</span><span class=\"o\">]</span> <span class=\"n\">Error</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 238019965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620549559
    },
    {
        "content": "<p><code>leanmake</code> doesn't know about dependencies, that's <code>leanpkg</code>'s job. There usually is no reason to ever use <code>leanmake</code> directly.</p>",
        "id": 238020055,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620549634
    },
    {
        "content": "<p>and what's the mumbo jumbo</p>",
        "id": 238020069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620549656
    },
    {
        "content": "<p><code>leanpkg build</code> looks like it worked</p>",
        "id": 238020091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620549695
    },
    {
        "content": "<p>and it doesn't require going into prelude first either</p>",
        "id": 238020138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620549727
    },
    {
        "content": "<p>okay, so since leanpkg is... opinionated about the names of files and folders, is there a way to make this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Mathlib</span><span class=\"bp\">/</span>\n  <span class=\"n\">Logic</span><span class=\"bp\">/</span>\n    <span class=\"n\">Basic.lean</span>\n<span class=\"n\">Mathlib.lean</span>\n<span class=\"n\">Prelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">Tactic</span><span class=\"bp\">/</span>\n    <span class=\"n\">Basic.lean</span>\n<span class=\"n\">Prelude.lean</span>\n<span class=\"n\">leanpkg.toml</span>\n</code></pre></div>",
        "id": 238020248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620549889
    },
    {
        "content": "<p>Maybe you're taking from the wrong end. Sebastian and <a href=\"https://github.com/leanprover/lean4/issues/397\">https://github.com/leanprover/lean4/issues/397</a> clearly state that help on <code>leanpkg</code> is very much welcome.</p>",
        "id": 238020345,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620549992
    },
    {
        "content": "<p>Okay, if this behavior is up for modification then I can certainly try to make the appropriate code changes, if someone doesn't get there first. In that case we can just plan the layout we want and make leanpkg work with it</p>",
        "id": 238020436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550093
    },
    {
        "content": "<p>I'll let <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> confirm of course, but that's my understanding.</p>",
        "id": 238020461,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550148
    },
    {
        "content": "<p>But my impression, at least partially, is that this behavior is deliberate and viewed as better than the alternatives. Personally I liked the flexibility of the lean 3 <code>leanpkg.path</code> file: just point to the project roots and imports are relative to that</p>",
        "id": 238020478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550194
    },
    {
        "content": "<p>Tooling is really important and non-trivial, but it makes sense that Leo and Sebastian have no time to work on that. It would be really to have something flexible enough so that it could also do everything <code>leanproject</code> does, maybe through a <code>leanpkg</code> plugin or something.</p>",
        "id": 238020560,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550277
    },
    {
        "content": "<p>Sure, at this point I'm just trying to solicit design criteria</p>",
        "id": 238020565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550310
    },
    {
        "content": "<p>The existence of <code>leanproject</code> in some ways indicates that <code>leanpkg</code> was not fulfilling its goal, or at least that it was abandoned and the new crowd didn't want to work with the old code base</p>",
        "id": 238020640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550397
    },
    {
        "content": "<p>Are we going to reinvent <code>leanproject</code> for mathlib 4? I don't think it's necessarily a bad idea - mathlib has to handle several things beyond what leanpkg itself is even aware of, like downloading built oleans, plus things like docgen might end up in it as well (I don't actually know if this is currently the case).</p>",
        "id": 238020752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550536
    },
    {
        "content": "<p>I think Lean 3 was not very convenient for this kind of programming, but this may very well be incompetence from me.</p>",
        "id": 238020755,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550546
    },
    {
        "content": "<p>Since we know that users will have a copy of lean, it's quite possible that the best scripting language to use for build tooling is lean 4</p>",
        "id": 238020809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550577
    },
    {
        "content": "<p>I also wrote it under the misconceptions that everybody on earth could easily get a sane python environment. At least once per month we see on Zulip how wrong I was.</p>",
        "id": 238020817,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550608
    },
    {
        "content": "<p>About doing it in Lean 4, I guess the main roadblock is available libraries. <code>leanproject</code> talks to git (not from simply executing the command line git client), downloads files, decompresses files. How far are we from doing that in a Lean 4 project (without implementing the zip compression and decompression  algorithm)?</p>",
        "id": 238020935,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550717
    },
    {
        "content": "<p>Is it already possible to simply link Lean code and a C library and call C functions from Lean?</p>",
        "id": 238020962,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550756
    },
    {
        "content": "<p>you can get by with the equivalent of shell scripting for a lot of that</p>",
        "id": 238020964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550757
    },
    {
        "content": "<p>oh that's a good point</p>",
        "id": 238020977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550780
    },
    {
        "content": "<p>Isn't this assuming the existence of a sane shell/POSIX environment?</p>",
        "id": 238020980,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550786
    },
    {
        "content": "<p>However I think that a program that needs to link with a C library is at risk of environment issues</p>",
        "id": 238021041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550819
    },
    {
        "content": "<p>a shell script is too</p>",
        "id": 238021068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550830
    },
    {
        "content": "<p>Can't we statically link to make sure everything is in the executable?</p>",
        "id": 238021087,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550845
    },
    {
        "content": "<p>I never knew much about C compilation and forgot most of it.</p>",
        "id": 238021105,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550861
    },
    {
        "content": "<p>Yes, if we statically link and distribute the binary that's probably the most reliable method</p>",
        "id": 238021113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550869
    },
    {
        "content": "<p>I would hope that embarking git and a compression/decompression lib wouldn't be too huge.</p>",
        "id": 238021141,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550903
    },
    {
        "content": "<p>That doesn't answer my question: is this currently possible in Lean 4 (from user land)?</p>",
        "id": 238021230,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620550964
    },
    {
        "content": "<p>I'm not sure. I think so, we just need a good demo of it</p>",
        "id": 238021287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620550993
    },
    {
        "content": "<p>You can use <code>@[extern]</code> to inline bits of C code, that can call an external function; then during the compilation stage you just link in the libraries you need to supply the function</p>",
        "id": 238021391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620551068
    },
    {
        "content": "<p>Yeah, with the help of some inline C code you should be able to fill out most FFI holes (strings, structures as long as they are behind a pointer, ...)</p>",
        "id": 238021602,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620551271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238020248\">said</a>:</p>\n<blockquote>\n<p>okay, so since leanpkg is... opinionated about the names of files and folders, is there a way to make this work?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Mathlib</span><span class=\"bp\">/</span>\n  <span class=\"n\">Logic</span><span class=\"bp\">/</span>\n    <span class=\"n\">Basic.lean</span>\n<span class=\"n\">Mathlib.lean</span>\n<span class=\"n\">Prelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">Tactic</span><span class=\"bp\">/</span>\n    <span class=\"n\">Basic.lean</span>\n<span class=\"n\">Prelude.lean</span>\n<span class=\"n\">leanpkg.toml</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>How do you declare what parts should be compiled and loaded as plugins for the other files? Our assumption was that packages are the most intuitive boundary for that (like with Rust's procedural macros, with the important difference that in Lean you <em>can</em> just interpret macros inside the same package), and I believe that each package should have its own <code>leanpkg.toml</code> (like in Rust).</p>",
        "id": 238021769,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620551408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238021287\">said</a>:</p>\n<blockquote>\n<p>we [just] need a good demo of it</p>\n</blockquote>\n<p>This sounds very true to me.</p>",
        "id": 238021896,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620551566
    },
    {
        "content": "<p>If this were rust, the hierarchy would look more like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">src</span><span class=\"bp\">/</span>\n  <span class=\"n\">Logic</span><span class=\"bp\">/</span>\n    <span class=\"n\">Basic.lean</span>\n  <span class=\"n\">Lib.lean</span>\n  <span class=\"n\">leanpkg.toml</span>\n<span class=\"n\">prelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">Tactic</span><span class=\"bp\">/</span>\n    <span class=\"n\">Basic.lean</span>\n  <span class=\"n\">Lib.lean</span>\n  <span class=\"n\">leanpkg.toml</span>\n</code></pre></div>\n<p>Here I'm imagining that leanpkg is either defaulting to a file named <code>Lib.lean</code>, or (preferably) this can be set inside the toml file. Similarly, the mathlib toml file uses a path dependency like <code>../prelude</code> to point to the other file.</p>",
        "id": 238023278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553164
    },
    {
        "content": "<p>In particular, the names <code>src/</code> and <code>prelude/</code> don't have to be anything in particular</p>",
        "id": 238023300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553185
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/issues/1\">mathlib4#1</a></p>",
        "id": 238023380,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553265
    },
    {
        "content": "<p>Actually it should also be a possibility to put the mathlib toml file at the root, where the file has a <code>src = \"./src\"</code> key to find the actual root for the sources</p>",
        "id": 238023482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553369
    },
    {
        "content": "<p>That PR does a bit of Makefile hackery to get rid of the separate project requirement for plugins.</p>",
        "id": 238023485,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553380
    },
    {
        "content": "<p>I see a reference to stage0, does this mean that mathlib can be it's own prelude? :D</p>",
        "id": 238023512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553419
    },
    {
        "content": "<p>Yes!</p>",
        "id": 238023517,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553426
    },
    {
        "content": "<p>It is a bit wasteful since it compiles that plugin's dependencies twice.  In principle that's solvable, but it requires copy&amp;pasting the makefile.</p>",
        "id": 238023664,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553569
    },
    {
        "content": "<p>how does that work exactly? Do we still need to keep the files separate</p>",
        "id": 238023671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553576
    },
    {
        "content": "<p>At that point it might be easier/faster to just rewrite leanmake in lean.</p>",
        "id": 238023672,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553579
    },
    {
        "content": "<p>No need to keep the files separate.  It operates in two stages:</p>\n<ol>\n<li>stage0 compiles Mathlib/Plugin.lean (and its dependencies) and links it into <code>Mathlib_Plugin.so</code></li>\n<li>Then all of mathlib is compiled with the <code>--plugin=Mathlib_Plugin.so</code> argument.</li>\n</ol>",
        "id": 238023696,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553627
    },
    {
        "content": "<p>So the only rule is that any dependency of <code>Plugin.lean</code> can't use tactics from the plugin</p>",
        "id": 238023736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553663
    },
    {
        "content": "<p>I think you can still use the tactics, they'll just be interpreted, right?</p>",
        "id": 238023782,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553692
    },
    {
        "content": "<p>or maybe they still can, but interpreted?</p>",
        "id": 238023783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553692
    },
    {
        "content": "<p>certainly you can't use a tactic before it's defined though, unlike lean</p>",
        "id": 238023813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553741
    },
    {
        "content": "<p>(we would need to keep a copy of the source tree if we wanted that, which sounds like way too much effort)</p>",
        "id": 238023841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620553781
    },
    {
        "content": "<p>The intended layout was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">prelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">MathlibPrelude.lean</span>\n  <span class=\"n\">MathlibPrelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">leanpkg.toml</span>\n<span class=\"n\">Mathlib.lean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span>\n<span class=\"n\">leanpkg.toml</span>\n</code></pre></div>",
        "id": 238023893,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620553812
    },
    {
        "content": "<p>Tactics in proofs would be fine (stage0 could set a -Dskip_all_proofs=true flag or something).</p>",
        "id": 238023896,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553814
    },
    {
        "content": "<p>But I believe plugins can also add other features (like linters) that can take effect before they are defined.</p>",
        "id": 238023931,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238023893\">said</a>:</p>\n<blockquote>\n<p>The intended layout was</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">prelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">MathlibPrelude</span><span class=\"bp\">/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is pretty cumbersome, since you need to write <code>import MathlibPrelude.Tactic.Core</code> instead of <code>import Mathlib.Tactic.Core</code> (which is already too long).  You also need to remember where it happened to be defined.</p>",
        "id": 238024009,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620553975
    },
    {
        "content": "<p>Didn't Leo told us we don't want to go to <code>stage0</code> hell?</p>",
        "id": 238024011,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620553979
    },
    {
        "content": "<p>Also <code>MathlibPrelude</code> / <code>Mathlib</code> is the name of the project, it's silly to have all sources in a file with the name of the project because you are already presumably in such a folder</p>",
        "id": 238024034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554027
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  The stage0 thing in core is something different: they include the compiled C files in the git repository.  We'd just be compiling (a small part of) mathlib twice.</p>",
        "id": 238024093,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620554066
    },
    {
        "content": "<p>I would prefer if the folder hierarchy just skips that top level, and then <code>src/Foo/Bar.lean</code> exists at <code>ProjectName.Foo.Bar</code>, where <code>ProjectName</code> is in the toml file</p>",
        "id": 238024125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554117
    },
    {
        "content": "<p>or you can set the source folder to <code>.</code> and just put it at <code>Foo/Bar.lean</code></p>",
        "id": 238024139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554151
    },
    {
        "content": "<p>Looking at the lean source layout, I wonder whether we can also do something similar, where the mathlib project actually consists of multiple lean \"packages\" along some kind of topical lines. Perhaps even the current top level folders. As long as these projects can reference each other that would seem to be a way to get rid of that top level qualifier</p>",
        "id": 238024286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554298
    },
    {
        "content": "<p>(referring to the fact that there are four top level lean packages defined in the lean source tree - <code>Init</code>, <code>Lean</code>, <code>Src</code>, <code>Leanpkg</code>)</p>",
        "id": 238024314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620554358
    },
    {
        "content": "<p>Gabriel, I remember a discussion during LT2021 when someone suggested we could have something like stage0 to handle precisely this issue in mathlib, and Leo laughed and told us we definitely don't want to go in this direction. But I don't remember any more detail.</p>",
        "id": 238024468,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620554517
    },
    {
        "content": "<p>I'm pretty sure that he referred to using macros before they're defined.  E.g. we might want to implement a <code>derive EquivFunctor</code> handler (for Scott's transfer tactic).  Since it is so useful, we might want to use <code>derive EquivFunctor</code> when implementing it.  One crazy proposal to make that work is to commit \"expanded\" Lean files to the mathlib repository, where all occurrences of <code>derive EquivFunctor</code> have been (automatically) expanded.  I believe this is what Leo was laughing at.</p>",
        "id": 238024759,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620554772
    },
    {
        "content": "<p>I think I should just remove the stage0 name.</p>",
        "id": 238024793,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620554832
    },
    {
        "content": "<p>We don't really need to compile anything twice here, right? We can just avoid compiling any file that is a dependency of <code>Plugin.lean</code> during the second pass</p>",
        "id": 238025101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620555194
    },
    {
        "content": "<p>which should happen automatically since the build files already exist</p>",
        "id": 238025112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620555210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238024793\">said</a>:</p>\n<blockquote>\n<p>I think I should just remove the stage0 name.</p>\n</blockquote>\n<p>It's more of a stage 1</p>",
        "id": 238025195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620555312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238025101\">said</a>:</p>\n<blockquote>\n<p>We don't really need to compile anything twice here, right? We can just avoid compiling any file that is a dependency of <code>Plugin.lean</code> during the second pass</p>\n</blockquote>\n<p>This is unfortunately hard, we'd need to add the <code>Mathlib_Plugin.so</code>dependency to those files only.  This is hard to do in make.</p>",
        "id": 238025303,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620555467
    },
    {
        "content": "<p>By the way, feel free to merge the PR yourself when you think it is ready. I'm not planning for us to have any review standards in the mathlib4 repo higher than your average wiki during this experimentation phase, at least until we start putting CI credentials or something in it</p>",
        "id": 238025965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620556168
    },
    {
        "content": "<p>Done. It's so nice to work on a project where CI takes only 16s.</p>",
        "id": 238026104,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620556246
    },
    {
        "content": "<p>I would have hoped that we could come up with a less hackish approach when we have the chance to reimagine Lean package management <span aria-label=\"frowning\" class=\"emoji emoji-1f626\" role=\"img\" title=\"frowning\">:frowning:</span> . Something principled that we can put in leanpkg, eventually without depending on <code>make</code>, so that other projects can use the same approach.</p>",
        "id": 238027227,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620557401
    },
    {
        "content": "<p>To be fair, that Makefile hack is more of a proof of concept showing that:</p>\n<ol>\n<li>We only need one <code>Mathlib</code> directory.</li>\n<li>We don't need to manually split mathlib into stages.</li>\n<li>This doesn't require large changes to Lean.</li>\n</ol>",
        "id": 238027396,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620557538
    },
    {
        "content": "<blockquote>\n<p>eventually without depending on <code>make</code></p>\n</blockquote>\n<p>Indeed, my next step would be to rewrite the Makefile into a <code>build.lean</code> file.  (No need to spawn a subprocess for <code>lean --deps</code> anymore!)  If that works out well, we can move it into Lean/leanpkg.</p>",
        "id": 238027507,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620557666
    },
    {
        "content": "<p>I still think that separate (sub)packages are the most natural solution to compiling different parts of a project in different modes. How these packages are laid out on disk is a related but separate question. Also consider third parties that want to use mathlib tactics without mathlib.</p>",
        "id": 238028053,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620558194
    },
    {
        "content": "<blockquote>\n<p>How these packages are laid out on disk is a related but separate question.</p>\n</blockquote>\n<p>Ultimately, I don't think anybody on the mathlib side cares about the packaging.  The core issue <em>is</em> the disk layout:</p>\n<ol>\n<li>Simple directory structure (no <code>mathlib/prelude/MathlibPrelude</code>).</li>\n<li>Uniform imports (no figuring out whether its <code>MathlibPrelude.LinearAlgebra.Basic</code> or <code>Mathlib.LinearAlgebra.Basic</code> or <code>LinearAlgebra.Basic</code>).</li>\n<li>All <code>LinearAlgebra</code> files (e.g.) should be in the same subdirectory.</li>\n</ol>",
        "id": 238028970,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620559122
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238028053\">said</a>:</p>\n<blockquote>\n<p>Also consider third parties that want to use mathlib tactics without mathlib.</p>\n</blockquote>\n<p>Then you can just import mathlib; all the interesting tactics in mathlib depend on types and lemmas from mathlib anyhow.  I have seen one good argument why you wouldn't want to do that in Lean 3: Joe Hendrix said that the <code>nat.cast</code> coercion introduced a performance footgun in a bitvector library.  Note that 1) this will most likely no longer be an issue in Lean 4, and 2) such an instance would already be in the prelude, so you don't gain anything from the split.</p>",
        "id": 238031700,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620562161
    },
    {
        "content": "<p>Do you have a feeling for how big the prelude will be? I get the point that it will probably be too big to put in a separate package. But I still wonder about whether the double compilation will (ever) be an issue, whether people will unknowingly increase the prelude, what the ramifications for separate compilation, if that can be applied at all to mathlib, are, etc...</p>",
        "id": 238032624,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620563124
    },
    {
        "content": "<p>I'm also assuming that even disregarding the prelude, there are too many (cyclic) interconnections between topics to e.g. put (most of) <code>LinearAlgebra</code> in a separate package.</p>",
        "id": 238032712,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620563217
    },
    {
        "content": "<blockquote>\n<p>But I still wonder about whether the double compilation will (ever) be an issue</p>\n</blockquote>\n<p>I think I was not clear enough about this.  The double compilation is a hack because anything more clever is too hard to do with a Makefile.  After rewriting the Makefile in Lean, it should be easy enough to compile the plugin+dependencies only once, and the rest with <code>--plugin=...</code>.  Or maybe the double compilation is actually useful (so that we can use automation in Mathlib.Logic.Base, I don't know yet).</p>",
        "id": 238032946,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620563501
    },
    {
        "content": "<p>So it would be something like \"compile these modules and their dependencies into a shared library, then compile all remaining modules using the library\"?</p>",
        "id": 238033085,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620563629
    },
    {
        "content": "<p>Yes. AFAICT, there are two possible reasons why we want plugins:</p>\n<ul>\n<li><code>linarith</code>, etc. should be as fast as possible.</li>\n<li>It would be cool if <code>#lint</code> worked everywhere.</li>\n</ul>",
        "id": 238033220,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620563755
    },
    {
        "content": "<blockquote>\n<p>there are too many (cyclic) interconnections between topics to e.g. put (most of) LinearAlgebra in a separate package.</p>\n</blockquote>\n<p>Pretty much.  The mathlib import graph is a big hairy ball.</p>",
        "id": 238033467,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620564026
    },
    {
        "content": "<p>(Luckily it can still be combed because mathlib has holes.)</p>",
        "id": 238033509,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620564090
    },
    {
        "content": "<p>are some  / most of the issues solved or become non-issue in the presence of a nix-based per-file build or in case we had per-file JIT and therefore would only rely on interpretation within a file but not across files?</p>",
        "id": 238033519,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620564115
    },
    {
        "content": "<p>I don't see how nix per-file builds would change anything.  JIT compilation would probably make a difference (no idea about the warm-up costs).  Another very brutal solution would be to produce one shared object per lean file, and then pass all of them as <code>--plugin</code> arguments.</p>",
        "id": 238033610,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620564239
    },
    {
        "content": "<p>well, the way how the lean compiler itself is built using nix works such, that the main module and its transitive dependencies are built and become available as imports for downstream dependencies.</p>",
        "id": 238033717,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620564350
    },
    {
        "content": "<p>That's pretty much the same a JIT, no? At least insofar, as the thing you're importing is an already-built binary IIUC</p>",
        "id": 238033774,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620564389
    },
    {
        "content": "<blockquote>\n<p>the way how the lean compiler itself is built using nix works such, that the main module and its transitive dependencies are built and become available as imports for downstream dependencies.</p>\n</blockquote>\n<p>It's not how the compiler is built itself (this is a different mechanism).  The nix build files included with Lean do support plugins though, but you can only compile a single package into a plugin.</p>\n<p>You can also use nix to execute the two-staged approach that is now (temporarily) used in mathlib4.  Unfortunately the nix cache can't help you here.</p>",
        "id": 238034139,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620564823
    },
    {
        "content": "<blockquote>\n<p>That's pretty much the same a JIT, no? At least insofar, as the thing you're importing is an already-built binary IIUC</p>\n</blockquote>\n<p>As the name implies, just-in-time compilation refers to compilation while the program is running.  If you're loading the binaries from disk, then it's ahead-of-time compilation.</p>",
        "id": 238034334,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620565005
    },
    {
        "content": "<p>what I was referring to was the question when a tactic defined is turned into compiled code and when is it interpreted. IIUC, inside of a file, the tactic would always be interpreted (it is available in the line straight after being defined), whereas when it's imported, then it ideally is already compiled. </p>\n<p>So that subsequent files compile potentially much faster. This is important for something like mathlib that is its own consumer. And my understanding was, that the nix build AOT compiles as port of the <code>import</code>, effectively.</p>\n<p>It is in that sense, that JIT would have a similar benefit. Depending of course, when exactly you JIT... One proposal was to JIT as part of the <code>import</code> as opposed to after each definition.</p>",
        "id": 238035142,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620565708
    },
    {
        "content": "<p>No, there is no per-file native compilation in the Nix build either</p>",
        "id": 238035400,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620565954
    },
    {
        "content": "<p>thanks for the clarification.</p>",
        "id": 238035413,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620565980
    },
    {
        "content": "<p>so then, JIT would potentially really be a good thing.</p>",
        "id": 238035439,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620566009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238031700\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238028053\">said</a>:</p>\n<blockquote>\n<p>Also consider third parties that want to use mathlib tactics without mathlib.</p>\n</blockquote>\n<p>Then you can just import mathlib; all the interesting tactics in mathlib depend on types and lemmas from mathlib anyhow.  I have seen one good argument why you wouldn't want to do that in Lean 3: Joe Hendrix said that the <code>nat.cast</code> coercion introduced a performance footgun in a bitvector library.  Note that 1) this will most likely no longer be an issue in Lean 4, and 2) such an instance would already be in the prelude, so you don't gain anything from the split.</p>\n</blockquote>\n<p>Personally, I find \"Then you can just import mathlib\" to be a horrible solution. That introduces an absolutely massive dependency which severely pollutes the global namespace. This is one of the main reasons I heavily avoided mathlib in my own projects in Lean 3. If I want to toy around with proofs in some aspect of mathematics or build a formalization for some subsection that is different then mathlib's then I have to deal with mathlib having eaten all the reasonable names for concepts in the global namespace. This would be less of a problem if mathlib stuck its content inside its own namespace or if Lean did not use transitive flat imports, but neither of those things seem likely to change this iteration, so I still consider this to be a major problem with mathlib.</p>",
        "id": 238041751,
        "sender_full_name": "Mac",
        "timestamp": 1620572891
    },
    {
        "content": "<p>Mac, why do you use mathlib at all? Is it only because it gives you the opportunity to be rude?</p>",
        "id": 238042091,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620573252
    },
    {
        "content": "<p>I had no intentions of being rude, and I apologize if my comment came off that way.  I was simply giving my thoughts on the matter and pointing out a potential concern with the solution of \"Then just import mathlib\" for a monolithic mathlib. It seemed to fit well with the discussion, seeing as there was a lot of back-and-forth about what package/repo split there should be (if any). </p>\n<p>I used descriptions like \"horrible\" to emphasize the strength of my feelings/opinions on the matter. I believe this to be appropriate, though I guess I can see how it could appear rude.</p>",
        "id": 238043303,
        "sender_full_name": "Mac",
        "timestamp": 1620574654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238028970\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>How these packages are laid out on disk is a related but separate question.</p>\n</blockquote>\n<p>Ultimately, I don't think anybody on the mathlib side cares about the packaging.  The core issue <em>is</em> the disk layout:</p>\n<ol>\n<li>Simple directory structure (no <code>mathlib/prelude/MathlibPrelude</code>).</li>\n<li>Uniform imports (no figuring out whether its <code>MathlibPrelude.LinearAlgebra.Basic</code> or <code>Mathlib.LinearAlgebra.Basic</code> or <code>LinearAlgebra.Basic</code>).</li>\n<li>All <code>LinearAlgebra</code> files (e.g.) should be in the same subdirectory.</li>\n</ol>\n</blockquote>\n<p>To resolve the <code>MathlibPrelude</code>/<code>Mathlib</code> problem, you could have dummy files like <code>Mathlib.LinearAlgebra.Basic</code> that simply import <code>MathlibPrelude.LinearAlgebra.Basic</code>, thus making the imports appear uniform to consumers.</p>\n<p>Alternatively, could this work as a potential directory structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Mathlib.lean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span>\n  <span class=\"n\">Prelude</span><span class=\"bp\">/</span>\n  <span class=\"n\">Prelude.lean</span>\n  <span class=\"n\">leanpkg.toml</span>\n<span class=\"n\">leanpkg.toml</span>\n</code></pre></div>\n<p>That is, is it possible to get <code>leanpkg</code> to work with subpackages within the current package's directory structure? This may be a good question for <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> ,</p>",
        "id": 238044292,
        "sender_full_name": "Mac",
        "timestamp": 1620575816
    },
    {
        "content": "<p>The fact that mathlib takes all the names in the global namespace shouldn't be a problem as long as your code doesn't operate in the global namespace, right? Or are there still pain points there? Expecting mathlib to stay out of the global namespace so that you can use it instead seems somewhat hypocritical, although admittedly mathlib's use of it is easy to construe as selfish.</p>",
        "id": 238063308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620595851
    },
    {
        "content": "<p>Looking at the results of <code>leanpkg build</code> on mathlib4 right now, I notice that it has to call <code>leanc</code> on every file. This is likely to be wasted work for a large fraction of mathlib files, which have no computable definitions, or at least nothing that we care to have compiled. Maybe there should be a way for lean files to signal that they are in \"mathematician mode\" and want to opt out of compilation</p>",
        "id": 238064600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620597260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238063308\">said</a>:</p>\n<blockquote>\n<p>The fact that mathlib takes all the names in the global namespace shouldn't be a problem as long as your code doesn't operate in the global namespace, right?</p>\n</blockquote>\n<p>Unfortunately, that is not how Lean works. Local and scoped notation that clashes with global notation is considered ambiguous and global names clash with namespace names if the namespace has been <code>open</code>'d. See the example here: <a href=\"#narrow/stream/270676-lean4/topic/Lean.20Hide.20Root.20Names.2FMacros/near/234738423\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Lean.20Hide.20Root.20Names.2FMacros/near/234738423</a> (that thread in general was about my issues with global name clashes).</p>",
        "id": 238064805,
        "sender_full_name": "Mac",
        "timestamp": 1620597576
    },
    {
        "content": "<p>Note that mathlib is generally very conservative about global notation for exactly this reason, and uses local and scoped (\"localized\") notations since those don't have ambiguity issues</p>",
        "id": 238066438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620599319
    },
    {
        "content": "<p>It is possible that lean 4 has a different resolution mechanism that means that this strategy doesn't work anymore</p>",
        "id": 238066448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620599350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Not quite sure if this is hijacking the thread, so please do tell so, if you think my discussion should be a separate topic.</p>\n<p>How do you plan to structure mathlib 4? Specifically, how can we go about structuring it into packages that limit the dependency you need to take on? E.g. you want to build some crypto verification. In this case you most likely mostly care about some fairly basic algebra, but not analysis. Chances are you'd not even need the reals, etc.</p>",
        "id": 238075261,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620609296
    },
    {
        "content": "<p>Well, mathlib has historically been reasonably good at importing only the things that are needed, so you can depend on a file and only the dependencies of that particular file need to be compiled. In the last year or so I think I haven't been exerting enough pressure to make sure that it stays this way so I think it might be more of a tangled web now, but in theory if someone needed to curate a particular subset for some purpose they could split up more files and decrease transitive dependencies to ensure that there isn't too much baggage getting pulled in</p>",
        "id": 238075507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620609519
    },
    {
        "content": "<p>For low level things like <code>nat</code>, <code>list</code>, and even <code>rat</code> and <code>real</code> to some extent, you should be able to get the basic stuff without pulling in half of the library</p>",
        "id": 238075562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620609583
    },
    {
        "content": "<p>However, I don't think that this can be accomplished with package level splits. That's way too coarse for mathlib</p>",
        "id": 238075630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620609630
    },
    {
        "content": "<p>so the proposed strategy is to rely on mathlib as a package and then depend on specific modules?</p>",
        "id": 238075859,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620609891
    },
    {
        "content": "<p>yes</p>",
        "id": 238076205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620610319
    },
    {
        "content": "<p>should we have 10-20 for the lack of a better word \"interface files\" for mathlib, then? I.e. main entry points like algebra or analysis and compile each one into a package? These would still sit in the monorepo but would allow for us to distribute them more easily and wouldn't require a full mathlib dependency if you work in a limited domain?</p>",
        "id": 238076861,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620611132
    },
    {
        "content": "<p>The problem with \"main entry points\" is that those files tend to be the source of a lot of spurious dependencies, so we try to avoid using them inside mathlib itself, and from outside mathlib it all comes down to your individual requirements. It is possible to import entire folders but that's generally not a good idea if you want to have a small dependency footprint</p>",
        "id": 238077124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620611413
    },
    {
        "content": "<p>I think stripping down imports and making parts of mathlib more orthogonal is a great discussion to have about mathlib3, but should not be considered as part of porting mathlib to Lean 4.</p>",
        "id": 238086750,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620622062
    },
    {
        "content": "<p>Fair enough, I'll open the discussion there, then</p>",
        "id": 238102653,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620634477
    },
    {
        "content": "<p>I just ported <code>init.data.nat.lemmas</code> in the mathlib4 repo. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> However, I left an easter egg in it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">min_le_left</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\"></span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\"></span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.min</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">by_cases</span> <span class=\"n\">a</span> <span class=\"bp\"></span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.le_refl</span> <span class=\"n\">_</span>\n  <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">_</span> <span class=\"c1\">-- &lt;- is this a bug? I'm not getting an error here</span>\n</code></pre></div>\n<p>There are no errors thrown up when processing this definition, and in fact the full build completes successfully. If you don't put a tactic there it clearly shows there is a remaining goal, and if you put <code>sorry</code> then it will say the proof uses sorry, so it seems that the hole is actually a part of the proof. I don't think <code>simp</code> is finishing the goal because you need an application of <code>Nat.le_of_not_le</code> to complete the proof and that's not a simp lemma. I'm not sure how to do the trust zero dance in lean 4 though.</p>",
        "id": 238105157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620635611
    },
    {
        "content": "<p>print the term?</p>",
        "id": 238108089,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620637269
    },
    {
        "content": "<p>the kernel doesn't eat meta variables, so it must have done <em>something</em></p>",
        "id": 238108195,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620637329
    },
    {
        "content": "<p>The term puts all the interesting stuff in private lemmas that I can't even <code>#print</code></p>",
        "id": 238110546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620638621
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">Nat.min_le_left</span> <span class=\"o\">:</span> <span class=\"bp\"></span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\"></span><span class=\"o\">),</span> <span class=\"n\">Nat.min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\"></span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\"></span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">Or.casesOn</span> <span class=\"o\">(</span><span class=\"n\">Decidable.em</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\"></span> <span class=\"n\">b</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\"></span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">Decidable.em</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\"></span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">Eq.ndrec</span>\n        <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span>\n          <span class=\"o\">(</span><span class=\"n\">congrFun</span>\n            <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">LE.le</span>\n              <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">iteCongr</span> <span class=\"o\">(</span><span class=\"n\">eqTrue</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\"></span><span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">if_pos</span> <span class=\"o\">(</span><span class=\"n\">ofEqTrue</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">True</span><span class=\"o\">)))))</span>\n            <span class=\"n\">a</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">Nat.le_refl</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">Eq.symm</span> <span class=\"n\">h_1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\"></span><span class=\"n\">a</span> <span class=\"bp\"></span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">Decidable.em</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\"></span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">Eq.ndrec</span>\n        <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span>\n          <span class=\"o\">(</span><span class=\"n\">congrFun</span>\n            <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">LE.le</span>\n              <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">iteCongr</span> <span class=\"o\">(</span><span class=\"n\">eqFalse</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\"></span><span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">if_neg</span> <span class=\"o\">(</span><span class=\"n\">ofEqTrue</span> <span class=\"o\">(</span><span class=\"n\">eqTrueOfDecide</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">true</span><span class=\"o\">))))))</span>\n            <span class=\"n\">a</span><span class=\"o\">)</span>\n          <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">Eq.symm</span> <span class=\"n\">h_1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Decidable.em</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\"></span> <span class=\"n\">b</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 238110682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620638696
    },
    {
        "content": "<p>Oh no I guess not, there is a <code>sorry</code> right there</p>",
        "id": 238110717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620638712
    },
    {
        "content": "<p>still it's surprising that this made it past the kernel without a peep</p>",
        "id": 238110771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620638741
    },
    {
        "content": "<p>the kernel eats <code>sorry</code> quite happily, I know that.</p>",
        "id": 238111262,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620638999
    },
    {
        "content": "<p>but you should really see it in axioms for this one... don't you?</p>",
        "id": 238111321,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620639010
    },
    {
        "content": "<p>yes</p>",
        "id": 238111394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620639043
    },
    {
        "content": "<p>It's not really a soundness issue, but the usual \"theorem uses 'sorry'\" message is missing</p>",
        "id": 238111461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620639084
    },
    {
        "content": "<p>still not great... please open a github issue for this.</p>",
        "id": 238111743,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620639207
    },
    {
        "content": "<p>that feels like a fairly clear bug to me</p>",
        "id": 238111758,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620639215
    },
    {
        "content": "<p>I've also run into this but couldn't minimize it.  It's a pretty frustrating bug because 1) you don't know you messed up and 2) you don't know how to fix it (because you can't see the goal state).</p>",
        "id": 238111999,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1620639323
    },
    {
        "content": "<p>minimized:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\"></span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\"></span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">o</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 238113049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620639852
    },
    {
        "content": "<p>it does the same thing with <code>induction</code> and <code>match</code> tactics, but not term mode match</p>",
        "id": 238113177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620639930
    },
    {
        "content": "<p>Oh so you have finished bikeshedding about directory structure? Do you want submissions? Do you want any of <a href=\"https://github.com/kbuzzard/mathlib4_experiments\">https://github.com/kbuzzard/mathlib4_experiments</a> ?</p>",
        "id": 238114082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620640411
    },
    {
        "content": "<p>It doesn't compile right now because I was in the middle of <code>nodup</code> when I got called for dinner...</p>",
        "id": 238114203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620640468
    },
    {
        "content": "<p>All your experiments are belong to us</p>",
        "id": 238114240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620640475
    },
    {
        "content": "<p>I nearly have a definition of <code>finset</code></p>",
        "id": 238114405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620640542
    },
    {
        "content": "<p>Stuff in CoreExt is stuff which is in core Lean 3 but which I (or SReichelt) couldn't find in core Lean 4. I work on this stuff on Thursdays on the discord, just to teach myself Lean 4. If there are any particular mathlib files which you want ported then let me know. Right now my goal was to port direct sums (as a random high-up point in the algebra heirarchy) to see if the elaboration issues which Eric was having could be reproduced in Lean 4, but this was just a random goal.</p>",
        "id": 238114859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620640792
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Just a quick reminder about this thread:<br>\n<a href=\"#narrow/stream/113488-general/topic/finiteness/near/206179081\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206179081</a></p>",
        "id": 238186856,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620670146
    },
    {
        "content": "<p>Johannes Hoelzl strongly advocated against doing any refactoring at the same time as porting.</p>",
        "id": 238187187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620670260
    },
    {
        "content": "<p>How much money do we need to buy him back from Apple? <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 238187364,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620670323
    },
    {
        "content": "<p><code></code></p>",
        "id": 238188431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620670725
    },
    {
        "content": "<p>I implemented the block structuring tactic we talked about a few weeks ago:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\"></span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\"></span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">split</span>\n  <span class=\"bp\">-</span> <span class=\"n\">split</span>\n    <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n    <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n  <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n</code></pre></div>\n<p>It's even better than lean 3 blocks because the blocks can be processed independently, so if one branch is incomplete you can also work on the other branch</p>",
        "id": 238202984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620676981
    },
    {
        "content": "<p>Well I implemented <code>split</code> ;-)</p>",
        "id": 238203336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620677127
    },
    {
        "content": "<p>actually this isn't too much harder than <code>split</code>. It's just a small variant on <code>focus</code> with a shorter name</p>",
        "id": 238203504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620677184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238202984\">said</a>:</p>\n<blockquote>\n<p>I implemented the block structuring tactic we talked about a few weeks ago:</p>\n</blockquote>\n<p>Nice work! Permission to upstream it?</p>",
        "id": 238205445,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620678033
    },
    {
        "content": "<p>Absolutely</p>",
        "id": 238205766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620678181
    },
    {
        "content": "<p>What about not recompiling a finished block when working on later blocks? (dreaming is still allowed, right?)</p>",
        "id": 238206085,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620678333
    },
    {
        "content": "<p>The lean 4 strategy is to make everything fast enough that this won't bother you <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 238206246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620678399
    },
    {
        "content": "<p>Sounds pretty good!</p>",
        "id": 238206266,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620678414
    },
    {
        "content": "<p>It's seriously impressive to see how fast it can get through <code>Data.Nat.Basic</code></p>",
        "id": 238206325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620678443
    },
    {
        "content": "<p>Actually I'm not sure where caching is handled. It might need to be in the C++?</p>",
        "id": 238206925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620678694
    },
    {
        "content": "<p>Whatever the speed, we'll always manage to come up with slow tactics. We'll simply become more ambitious and brutal.</p>",
        "id": 238207087,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620678751
    },
    {
        "content": "<p>Yes, that's a law of nature</p>",
        "id": 238207132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620678772
    },
    {
        "content": "<p>I'm working on really slow automation already. :)</p>",
        "id": 238209272,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1620679665
    },
    {
        "content": "<p>Chris Hughes for his MSc thesis implemented a tactic which in the worst case scenario performs worse than any finite tower of exponentials</p>",
        "id": 238209273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620679666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> do you know how that compares to ackermann? IIRC ackermann is also worse than that.</p>",
        "id": 238210896,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620680302
    },
    {
        "content": "<p>Ackermann is faster growing. power tower is something like <code>A(n, 4)</code> compared to <code>A(n, n)</code> which is the ackermann function</p>",
        "id": 238215240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620682181
    },
    {
        "content": "<p>I don't know any algorithm that needs ackermann running time though</p>",
        "id": 238215363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620682227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> do you know the actual worst case running time of that word problem algorithm?</p>",
        "id": 238216788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620683014
    },
    {
        "content": "<p>I think it is just power tower and it never gets worse than that. I don't recall where I read that though.</p>",
        "id": 238217367,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1620683326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  neither do I ;-). But I did come across the inverse ackermann as a complexity once. Which was quite funny. Also they casually mentioned that it's quite fair to consider it constant time, because for any input that fits into the universe you'd be limited to 4</p>",
        "id": 238217562,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620683435
    },
    {
        "content": "<p>Right -- my son has certainly shown me algorithms with inverse Ackermann running time -- I thought these were normal in your world.</p>",
        "id": 238218226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620683831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I've only skimmed it myself, but found <a href=\"https://arxiv.org/pdf/1312.5686.pdf\">this paper</a> interesting.  It provides a survey of different complexity classes and problems more complex than elementary.  It looks like Petri-nets and vector addition containment problems naturally give rise to problems with an Ackermann running time.</p>",
        "id": 238219857,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1620684708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238218226\">said</a>:</p>\n<blockquote>\n<p>Right -- my son has certainly shown me algorithms with inverse Ackermann running time -- I thought these were normal in your world.</p>\n</blockquote>\n<p>Union-find is fairly common</p>",
        "id": 238220049,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1620684831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238202984\">said</a>:</p>\n<blockquote>\n<p>I implemented the block structuring tactic we talked about a few weeks ago:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\"></span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\"></span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">split</span>\n  <span class=\"bp\">-</span> <span class=\"n\">split</span>\n    <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n    <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n  <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n</code></pre></div>\n<p>It's even better than lean 3 blocks because the blocks can be processed independently, so if one branch is incomplete you can also work on the other branch</p>\n</blockquote>\n<p>Any way to perform both splits at once? For example, the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\"></span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\"></span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">split</span> <span class=\"mi\">3</span>\n  <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n  <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n  <span class=\"bp\">-</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 238228221,
        "sender_full_name": "Mac",
        "timestamp": 1620690066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> What should <code>split 3</code> do with <code>a  b  c  d </code>?</p>",
        "id": 238248677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620705855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> I was talking of union find, yes. You get the inverse ackermann by path compression or path halving, otherwise it's log. But that's also the only one I'm aware of. So I wouldn't say it's exactly common ;-).</p>",
        "id": 238249436,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1620706582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238248677\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> What should <code>split 3</code> do with <code>a  b  c  d </code>?</p>\n</blockquote>\n<p>The idea was that <code>split n</code> would preform <code>n-1</code> splits, creating <code>n</code> goals. So <code>split 3</code> on <code>a  b  c  d</code> would produce goals for<code>a</code>, <code>b</code>, and <code>c  d</code> (as <code></code> is right-associative).</p>",
        "id": 238251463,
        "sender_full_name": "Mac",
        "timestamp": 1620708387
    },
    {
        "content": "<p><code>split 4</code> on <code>a  b  c  d </code>would produce 4 goals (<code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>).</p>",
        "id": 238251618,
        "sender_full_name": "Mac",
        "timestamp": 1620708553
    },
    {
        "content": "<p>I think <code>rcases</code> is better for such things, because you can give it the exact pattern along which you want to split.</p>",
        "id": 238251769,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620708715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> I mean, by that logic, is there really a need for <code>split</code> at all then? I think the idea here is to avoid the need to provide such patterns.</p>",
        "id": 238251903,
        "sender_full_name": "Mac",
        "timestamp": 1620708834
    },
    {
        "content": "<p>What does <code>split 4</code> do to <code>(a  b  c)  (d  (e  f)  g)</code>?</p>",
        "id": 238254369,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620711211
    },
    {
        "content": "<p>But I guess <code>simp only [and_assoc]</code> and then <code>split n</code> would give useful behaviour.</p>",
        "id": 238254417,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620711247
    },
    {
        "content": "<p>But if the parens are all over the place, I think <code>rcases</code> is a lot easier to wrap my head around. (At least for me.)</p>",
        "id": 238254435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620711271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/238254435\">said</a>:</p>\n<blockquote>\n<p>But if the parens are all over the place, I think <code>rcases</code> is a lot easier to wrap my head around. (At least for me.)</p>\n</blockquote>\n<p>That's fair. However, for the normal form (where parens are not all over the place), I certainly think <code>split n</code> would be a useful tool.</p>",
        "id": 238266427,
        "sender_full_name": "Mac",
        "timestamp": 1620719874
    },
    {
        "content": "<p>I think it's time for a Mathlib 4 topic stream? (<span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ?) This thread is getting confusing.</p>",
        "id": 238292814,
        "sender_full_name": "Franois G. Dorais",
        "timestamp": 1620733562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> The <code>split</code> tactic applies to any inductive with one constructor. <code>And</code> is one of those but the others aren't associative, in general.</p>",
        "id": 238293002,
        "sender_full_name": "Franois G. Dorais",
        "timestamp": 1620733664
    },
    {
        "content": "<p>Maybe <code>split_and</code> is a better tactic, so you don't have to count how many <code>and</code>s you have and you don't split other inductives.</p>",
        "id": 238297013,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1620735741
    },
    {
        "content": "<p>I have just created a separate stream titled \"mathlib4\". Please subscribe yourselves if interested!</p>",
        "id": 238302888,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620738251
    },
    {
        "content": "<p>I propose not moving any historical topics from this stream to that, but that we try to have future discussions about porting efforts over there.</p>",
        "id": 238303519,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620738503
    },
    {
        "content": "<p>Eh, why is it a non-default stream? That will make it almost private for folks who missed the notification</p>",
        "id": 238327143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620746892
    },
    {
        "content": "<p>oh I wondered why it hadn't shown up. Why not kill it and create it again?</p>",
        "id": 238342446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620752262
    },
    {
        "content": "<p>I don't think zulip lets you do that. I've signed up everyone from the lean 4 stream, hopefully I didn't just ping everyone</p>",
        "id": 238346743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620752437
    },
    {
        "content": "<p>I'm afraid you did, including all of our course students <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 238350161,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620753773
    },
    {
        "content": "<p>It's now a default stream for new users.</p>",
        "id": 238392927,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620773172
    }
]
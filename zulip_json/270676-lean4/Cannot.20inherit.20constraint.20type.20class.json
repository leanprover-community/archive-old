[
    {
        "content": "<p>hello everyone, I try to learn lean4 and stuck with some problem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Base</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Recursive</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Base</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">Base.T</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">project</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Base.T</span> <span class=\"n\">t</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Corecursive</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Base</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">Base.T</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">embed</span> <span class=\"o\">:</span> <span class=\"n\">Base.T</span> <span class=\"n\">t</span> <span class=\"n\">t</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">t</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Corecursive</span> <span class=\"n\">Recursive</span> <span class=\"n\">Functor</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">cata</span> <span class=\"o\">[</span><span class=\"n\">Recursive</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">alg</span> <span class=\"o\">:</span> <span class=\"n\">Base.T</span> <span class=\"n\">t</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">alg</span> <span class=\"bp\">∘</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">cata</span> <span class=\"n\">alg</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">project</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">ana</span> <span class=\"o\">[</span><span class=\"n\">Corecursive</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">coalg</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Base.T</span> <span class=\"n\">t</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"n\">embed</span> <span class=\"bp\">∘</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">ana</span> <span class=\"n\">coalg</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">coalg</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ListF</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nilF</span> <span class=\"o\">:</span> <span class=\"n\">ListF</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n  <span class=\"bp\">|</span> <span class=\"n\">consF</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ListF</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ListF</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Base</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">Base.T</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nilF</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nilF</span>\n    <span class=\"bp\">|</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Recursive</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">project</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nilF</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consF</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ListF</span>\n</code></pre></div>\n<p>can I use <code>Functor (ListF α)</code> instead of <code>Functor (Base.T (List α))</code>?</p>",
        "id": 280759663,
        "sender_full_name": "Denis Stoyanov",
        "timestamp": 1651357802
    },
    {
        "content": "<p>when I try this one</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nilF</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nilF</span>\n    <span class=\"bp\">|</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Recursive</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">project</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nilF</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consF</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>I got <code>field 'map' is missing</code></p>",
        "id": 280759706,
        "sender_full_name": "Denis Stoyanov",
        "timestamp": 1651357888
    },
    {
        "content": "<p>Instance search doesn't seem to unfold definitions. That's probably a good thing because it might get pretty slow otherwise. So I guess the answer to your question is no. Maybe it makes sense to register both instances?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instFunctorListF</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nilF</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nilF</span>\n    <span class=\"bp\">|</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">Base.T</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">instFunctorListF</span>\n</code></pre></div>",
        "id": 280762843,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1651362925
    },
    {
        "content": "<p>What version are you using? On v4.0.0-m4 the example you posted doesn't throw any errors.</p>",
        "id": 280762911,
        "sender_full_name": "Chris B",
        "timestamp": 1651363064
    },
    {
        "content": "<p>Only second part of Denis's post is supposed to throw the error. I can reproduce it on <code>leanprover/lean4:nightly-2022-04-25</code>.</p>",
        "id": 280763191,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1651363386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129120\">Alexander Bentkamp</span> <a href=\"#narrow/stream/270676-lean4/topic/Cannot.20inherit.20constraint.20type.20class/near/280762843\">said</a>:</p>\n<blockquote>\n<p>Instance search doesn't seem to unfold definitions. That's probably a good thing because it might get pretty slow otherwise. So I guess the answer to your question is no. Maybe it makes sense to register both instances?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instFunctorListF</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nilF</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nilF</span>\n    <span class=\"bp\">|</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">Base.T</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">instFunctorListF</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>You can make instance search unfold your definitions by declaring them as <code>abbrev</code>s (which is equivalent to tagging them with the <code>reducible</code> attribute)</p>",
        "id": 280763197,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1651363417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129120\">Alexander Bentkamp</span> <a href=\"#narrow/stream/270676-lean4/topic/Cannot.20inherit.20constraint.20type.20class/near/280763191\">said</a>:</p>\n<blockquote>\n<p>Only second part of Denis's post is supposed to throw the error. I can reproduce it on <code>leanprover/lean4:nightly-2022-04-25</code>.</p>\n</blockquote>\n<p>Yeah, the second part is fine on m4.</p>",
        "id": 280763411,
        "sender_full_name": "Chris B",
        "timestamp": 1651363711
    },
    {
        "content": "<p>look like this is some duplicate of instance, I mean I need use <code>instance : Functor (Base.T (List α)) := instFunctorListF</code></p>",
        "id": 280763423,
        "sender_full_name": "Denis Stoyanov",
        "timestamp": 1651363792
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">app</span><span class=\"o\">:</span><span class=\"n\">master</span><span class=\"bp\">*</span> <span class=\"bp\">λ</span> <span class=\"n\">elan</span> <span class=\"n\">toolchain</span> <span class=\"n\">list</span>\n<span class=\"n\">stable</span>\n<span class=\"n\">leanprover</span><span class=\"bp\">/</span><span class=\"n\">lean4</span><span class=\"o\">:</span><span class=\"n\">nightly</span>\n<span class=\"n\">leanprover</span><span class=\"bp\">/</span><span class=\"n\">lean4</span><span class=\"o\">:</span><span class=\"n\">nightly</span><span class=\"bp\">-</span><span class=\"mi\">2022</span><span class=\"bp\">-</span><span class=\"mi\">04</span><span class=\"bp\">-</span><span class=\"mi\">12</span> <span class=\"o\">(</span><span class=\"n\">default</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>this is my version of lean</p>",
        "id": 280763472,
        "sender_full_name": "Denis Stoyanov",
        "timestamp": 1651363841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Cannot.20inherit.20constraint.20type.20class/near/280763197\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"129120\">Alexander Bentkamp</span> <a href=\"#narrow/stream/270676-lean4/topic/Cannot.20inherit.20constraint.20type.20class/near/280762843\">said</a>:</p>\n<blockquote>\n<p>Instance search doesn't seem to unfold definitions. That's probably a good thing because it might get pretty slow otherwise. So I guess the answer to your question is no. Maybe it makes sense to register both instances?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instFunctorListF</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nilF</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nilF</span>\n    <span class=\"bp\">|</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consF</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">Base.T</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">instFunctorListF</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>You can make instance search unfold your definitions by declaring them as <code>abbrev</code>s (which is equivalent to tagging them with the <code>reducible</code> attribute)</p>\n</blockquote>\n<p>what do u mean?</p>",
        "id": 280763547,
        "sender_full_name": "Denis Stoyanov",
        "timestamp": 1651363974
    },
    {
        "content": "<blockquote>\n<p>You can make instance search unfold your definitions by declaring them as abbrevs (which is equivalent to tagging them with the reducible attribute)</p>\n</blockquote>\n<p>For regular definitions, yes, but it seems you can't do that to <code>Base.T</code>, which is defined via <code>instance : Base (List α) := ⟨ListF α⟩</code>.</p>",
        "id": 280763559,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1651364028
    },
    {
        "content": "<p>So I think this is what Henrik means:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 280763670,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1651364212
    }
]
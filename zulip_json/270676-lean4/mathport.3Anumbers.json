[
    {
        "content": "<p>Currently, <code>mathport</code> detects Lean3 numerals (has_zero, has_one, bit0, bit1) and simply wraps them in <code>ofNat</code>. However, these are not the instances that would be found by Lean4's typeclass synthesis, which (assuming Mario's TC-construction suggestion will never be merged) will need to synthesize something like <a href=\"https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49\">https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49</a> that will not compute in the kernel. It seems desirable to have a standard encoding, which would involve replacing the Lean3 numbers with this Lean4 encoding. However, Lean3 relies on some numeral operations computing in the kernel in a few places, e.g. to prove that <code>bit0 1 + bit0 1 = bit0 (bit0 1)</code>. How about backporting this never happening (i.e. using <code>norm_num</code> in a few additional places), so that <code>mathport</code> can replace numbers with the lean4-friendly <code>OfNat</code> instances?</p>",
        "id": 231530734,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1616528097
    },
    {
        "content": "<p>What is  the Lean4 way to define an <code>ofNat</code> instance for every additive monoid?</p>",
        "id": 231532269,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616528769
    },
    {
        "content": "<p>Even if it will never happen in kernel, we'll definitely need this instance in <code>mathlib</code>.</p>",
        "id": 231532327,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616528804
    },
    {
        "content": "<p>(then we'll probably have a diamond for <code>OfNat int _</code>)</p>",
        "id": 231532598,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616528926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Can you please clarify? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n<span class=\"kd\">def</span> <span class=\"n\">mk5</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"c1\">-- ^ error: failed to synthesize type class instance for ... has_one a</span>\n</code></pre></div>",
        "id": 231533498,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1616529318
    },
    {
        "content": "<p>Shouldn't <code>add_monoid</code> only have <code>0</code>? I did not mention above but that is handled separately in the proposal, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instZero2Nat</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">HasZero.zero</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>(<a href=\"https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L39\">https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L39</a>)</p>",
        "id": 231533713,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1616529408
    },
    {
        "content": "<p>Sorry, I meant \"add monoid with one\". E.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.defs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk5</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231533718,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616529410
    },
    {
        "content": "<p>I'm afraid that with <code>(5 : a)</code> depending on a typeclass instance we'll have two definitions of <code>(5 : int)</code>: one comes from the fact that <code>int</code> is a ring (and we definitely want numerals in any ring in <code>mathlib</code>), and the other is some default computationally efficient implementation.</p>",
        "id": 231534035,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616529543
    },
    {
        "content": "<p>Then a user will see a goal <code>(5 : int) = (5 : int)</code> that is not a <code>rfl</code>.</p>",
        "id": 231534124,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616529583
    },
    {
        "content": "<p>Even worse, we'll have two meanings of <code>(5 : Nat)</code>. Now we can have <code>(coe : nat → nat) 5 = 5</code> but it shows an up arrow in the goal view.</p>",
        "id": 231535632,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616530153
    },
    {
        "content": "<p>For the latter case, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.cast_id\">docs#nat.cast_id</a></p>",
        "id": 231536008,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616530315
    },
    {
        "content": "<p>Probably we'll need to make sure that Lean4 parses <code>(5 : Nat)</code> using the generic <code>[AddMonoid Nat] [HasOne Nat]</code> definition and simplify the prelude instance <code>OfNat Nat n</code> (I guess, it is defined as the identity map) to the generic one.</p>",
        "id": 231536093,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616530347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Of course, we can have a lemma \"these two definitions are equal\" but I want to apply a lemma about <code>[Semiring R] (5 : R)</code> to <code>(5 : Nat)</code> without converting between two instances of <code>OfNat</code>.</p>",
        "id": 231536261,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616530433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Just to confirm, this is the issue you are concerned about:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">abstract_5_eq_0</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">elabAcceptsKernelRejects</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">abstract_5_eq_0</span> <span class=\"n\">Nat</span>\n<span class=\"c1\">-- error: (kernel) declaration type mismatch, 'elabAcceptsKernelRejects' has type ...</span>\n</code></pre></div>\n<p>where the <code>OfNat</code> instances are not definitionally equal in both the elaborator and the kernel</p>",
        "id": 231540532,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1616532173
    },
    {
        "content": "<p>Yes.</p>",
        "id": 231541083,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616532414
    },
    {
        "content": "<p>Zooming out, here are the proposals for numbers that I am aware of:</p>\n<ol>\n<li>write custom elab/delab for lean3-style numerals, possibly not even mapping <code>nat</code> -&gt; <code>Nat</code></li>\n<li>extend Lean4 TC (on lean-community fork) with ability to post-process instances (<a href=\"https://github.com/dselsam/mathport/issues/17#issuecomment-781430391\">https://github.com/dselsam/mathport/issues/17#issuecomment-781430391</a>)</li>\n<li>some kind of <code>nat2bits</code> instance as in <a href=\"https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49\">https://github.com/dselsam/mathport/blob/master/Lib4/PrePort/Numbers.lean#L49</a> which would (once partial is replaced with WF) still use WF and so not compute reliabliy</li>\n</ol>",
        "id": 231541759,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1616532709
    },
    {
        "content": "<p>My concern is not about porting of our lean 3 code but about Lean 4 mathlib that we want to have in future: should we somehow disable the default instance <code>OfNat Nat _</code>? If not, how should we deal with conflicting instances? I assume that we definitely want to have <code>instance (R : Type*) [Semiring R] (n : Nat) : OfNat R n</code>.</p>",
        "id": 231545431,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616534277
    },
    {
        "content": "<p>It seems to me that something like <code>nat2bits</code> (probably with an override that uses better functions for <code>Nat</code> and <code>Int</code>) + disabling the default <code>OfNat</code> instances is the way to go. Am I wrong for some reason?</p>",
        "id": 231545725,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616534409
    },
    {
        "content": "<p>Basically, this means replicating Lean 3 numerals on top of Lean 4. I would be happy to see a solution that (a) does not involve disabling the default <code>OfNat Nat n</code> instance; (b) does not create <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231540532\">this</a> problem.</p>",
        "id": 231546252,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616534683
    },
    {
        "content": "<p>I think we will need a typeclass <code>Numeric := \\all n, OfNat Nat n</code>, and this will be mixed in to <code>Semiring</code> and other relevant classes. This is onerous for constructing instances of <code>Semiring</code> but lets individual types decide how best to implement it. Daniel's well founded instance looks like a \"last resort\" instance similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_space.of_core\">docs#uniform_space.of_core</a></p>",
        "id": 231559375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616541962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> How would <code>normNum</code> work in this proposal?</p>",
        "id": 231565319,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1616546036
    },
    {
        "content": "<p>We would need the <code>OfNat</code> instance to be coherent with the semiring structure, of course; one way would be to posit <code>ofNat R n + ofNat R m = ofNat R (n + m)</code> and similar axioms for the other operations. Then <code>normNum</code> would work by using these to rewrite operations on add and mul to primitive add and mul on nat, using kernel evaluation to finish the job</p>",
        "id": 231566206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616546676
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Numeric</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Numeric.OfNat</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Numeric</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Numeric.ofNat</span> <span class=\"n\">n</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Numeric</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n  <span class=\"n\">zero_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n  <span class=\"n\">mul_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n  <span class=\"n\">mul_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n  <span class=\"n\">add_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n  <span class=\"n\">ofNat_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ofNat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ofNat</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">ofNat</span> <span class=\"n\">b</span>\n  <span class=\"n\">ofNat_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ofNat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ofNat</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">ofNat</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Semiring.OfNat</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Numeric.OfNat</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">normNum</span><span class=\"o\">)</span> <span class=\"s2\">\"normNum\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkOfNatLit</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">sα</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">inst</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">`</span><span class=\"n\">Semiring.OfNat</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span> <span class=\"n\">sα</span> <span class=\"n\">n</span>\n  <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">`</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"n\">inst</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">NormNum</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ofNat_add</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">b'</span> <span class=\"bp\">→</span> <span class=\"n\">a'</span> <span class=\"bp\">+</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Semiring.ofNat_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ofNat_mul</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">b'</span> <span class=\"bp\">→</span> <span class=\"n\">a'</span> <span class=\"bp\">*</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Semiring.ofNat_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e.withApp</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">args</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">f.isConstOf</span> <span class=\"bp\">`</span><span class=\"n\">HAdd.hAdd</span> <span class=\"k\">then</span>\n    <span class=\"n\">evalB</span> <span class=\"bp\">`</span><span class=\"n\">NormNum.ofNat_add</span> <span class=\"o\">(</span><span class=\"bp\">·+·</span><span class=\"o\">)</span> <span class=\"n\">args</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">f.isConstOf</span> <span class=\"bp\">`</span><span class=\"n\">HMul.hMul</span> <span class=\"k\">then</span>\n    <span class=\"n\">evalB</span> <span class=\"bp\">`</span><span class=\"n\">NormNum.ofNat_mul</span> <span class=\"o\">(</span><span class=\"bp\">·*·</span><span class=\"o\">)</span> <span class=\"n\">args</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">f.isConstOf</span> <span class=\"bp\">`</span><span class=\"n\">OfNat.ofNat</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mkEqRefl</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"fail\"</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">evalB</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"n\">args</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">Level.succ</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">getLevel</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"fail\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstance</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">`</span><span class=\"n\">Semiring</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">pa</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">eval</span> <span class=\"n\">a</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">b'</span><span class=\"o\">,</span> <span class=\"n\">pb</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">eval</span> <span class=\"n\">b</span>\n      <span class=\"k\">let</span> <span class=\"n\">la</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.getRevArg</span><span class=\"bp\">!</span> <span class=\"n\">a'</span> <span class=\"mi\">1</span>\n      <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">na</span> <span class=\"bp\">←</span> <span class=\"n\">la.natLit</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"fail\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">lb</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.getRevArg</span><span class=\"bp\">!</span> <span class=\"n\">b'</span> <span class=\"mi\">1</span>\n      <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">nb</span> <span class=\"bp\">←</span> <span class=\"n\">lb.natLit</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"fail\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">lc</span> <span class=\"o\">:=</span> <span class=\"n\">mkNatLit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">na</span> <span class=\"n\">nb</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">mkOfNatLit</span> <span class=\"n\">u</span> <span class=\"n\">α</span> <span class=\"n\">sα</span> <span class=\"n\">lc</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">mkApp10</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"n\">name</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span> <span class=\"n\">sα</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">la</span> <span class=\"n\">lb</span> <span class=\"n\">lc</span> <span class=\"n\">pa</span> <span class=\"n\">pb</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkEqRefl</span> <span class=\"n\">lc</span><span class=\"o\">))</span>\n    <span class=\"k\">else</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"fail\"</span>\n\n<span class=\"kd\">@[tactic normNum]</span> <span class=\"kd\">def</span> <span class=\"n\">evalNormNum</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">matchEq</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMVarType</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"fail\"</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhs2</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">NormNum.eval</span> <span class=\"n\">lhs</span>\n    <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">lhs2</span> <span class=\"n\">rhs</span> <span class=\"k\">do</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"fail\"</span>\n    <span class=\"n\">assignExprMVar</span> <span class=\"n\">g</span> <span class=\"n\">p</span>\n    <span class=\"n\">pure</span> <span class=\"o\">[]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">NormNum</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.debug</span> <span class=\"n\">true</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">normNum</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">7</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">12</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">normNum</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">70</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">33</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2450</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">normNum</span>\n</code></pre></div>",
        "id": 231579651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616558448
    },
    {
        "content": "<p>Probably it suffices to require <code>ofNat 0 = 0</code> and <code>ofNat (n + 1) = ofNat n + 1</code></p>",
        "id": 231683771,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616609990
    },
    {
        "content": "<p>The solution with <code>Numeric</code> typeclass looks very nice.</p>",
        "id": 231684028,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616610077
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Constructing terms in this <code>normNum</code> port is super painful. Is there a trick I'm missing? Both matching terms and constructing terms using expr quotations are sorely missing here</p>",
        "id": 231718938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616624460
    },
    {
        "content": "<p>Also double backtick name quotations don't seem to work properly</p>",
        "id": 231719269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616624633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231719269\">said</a>:</p>\n<blockquote>\n<p>Also double backtick name quotations don't seem to work properly</p>\n</blockquote>\n<p>In what way?</p>",
        "id": 231719970,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1616625023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231718938\">said</a>:</p>\n<blockquote>\n<p>Is there a trick I'm missing?</p>\n</blockquote>\n<p>I don't think so, it's just a kind of program no-one else has written in Lean 4 before</p>",
        "id": 231720057,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1616625074
    },
    {
        "content": "<p>Ah, nvm about double backtick name quotations, I think there were just less things in scope than I thought</p>",
        "id": 231720267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616625202
    },
    {
        "content": "<p>Would it be possible to have <code>(·+·)</code> expand to <code>HAdd.hAdd</code> instead of <code>fun x y =&gt; x + y</code>? I think that will eventually turn into a mathport issue</p>",
        "id": 231720531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616625355
    },
    {
        "content": "<p>It looks like expr quotations like <code> `((·+·) : Nat → Nat → Nat).subst a</code> don't work anymore</p>",
        "id": 231720683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616625455
    },
    {
        "content": "<p>(I was offline for a few days) <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I like this approach for Lean4. It would be extremely ambitious to try to automate this change in mathport though. Will you be able to backport it?</p>\n<p>EDIT: Actually, I am not sure yet how hard it would be to autoport this change. I will think more about it.</p>",
        "id": 232699778,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617248893
    },
    {
        "content": "<p>Which part? The <code>normNum</code> implementation was intended to be a lean 4 tactic; it would be hard to backport it since it relies on primitive nats</p>",
        "id": 232712294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617260314
    },
    {
        "content": "<p>The main thing that mathport certainly cannot do automatically is guess the desired <code>Semiring</code> instances. If you backport the change to <code>semiring</code>, then even if you don't connect the <code>ofNat</code> to anything else, it may be feasible for mathport to detect old numerals and replace them with new numerals, and detect old <code>norm_num</code> proofs and replace them with <code>normNum</code> proofs.</p>",
        "id": 232774547,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617290223
    },
    {
        "content": "<p>Also, it would be nice if <code>norm_num</code> wrapped its proofs with <code>idNormNum</code>.</p>",
        "id": 232774802,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617290277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What do you think about backporting the <code>semiring</code> change?</p>",
        "id": 233859771,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617988758
    },
    {
        "content": "<p>We don't need it to make mathlib work, right? I think it would be better to do as a refactor on lean 4 mathlib</p>",
        "id": 233860086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617988876
    },
    {
        "content": "<p>Yes, it could be a future refactor in Lean4, after the <code>.lean</code> files have been manually resurrected.</p>",
        "id": 233860407,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617989026
    },
    {
        "content": "<p>It will solve some defeq diamond issues but those are second order concerns</p>",
        "id": 233860589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617989110
    },
    {
        "content": "<p>In the meantime, we will still need to be able to implement a <code>normNum</code> that works for both auto-ported terms and newly-elaborated terms. The three options for now are still roughly <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231541759\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/231541759</a></p>",
        "id": 233860626,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617989123
    },
    {
        "content": "<p>I don't know, it sounds like running before we can walk. We still need the mathlib tactic suite</p>",
        "id": 233860878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617989235
    },
    {
        "content": "<p>it makes more sense for <code>normNum</code> to just deal with lean 4 numerals expressed the way we want them to be expressed</p>",
        "id": 233861069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617989323
    },
    {
        "content": "<p>if it's not possible to get mathport to do the translation, a tactic on the lean 4 side can also simplify numerals and other lean 3 cruft</p>",
        "id": 233861285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617989416
    },
    {
        "content": "<p>Are you suggesting option (3)? We define a generic <code>nat2bits</code> non-computing instance, and then have <code>normNum</code> use <code>semiring</code> lemmas in terms of these instances? Then once <code>semiring</code> adds <code>Numeric</code>, we can just change the instances to ones that compute (when applicable)?</p>",
        "id": 233861882,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617989662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/233860878\">said</a>:</p>\n<blockquote>\n<p>I don't know, it sounds like running before we can walk. We still need the mathlib tactic suite</p>\n</blockquote>\n<p>I am not sure I follow your line of thought here -- <code>normNum</code> is a core part of the mathlib tactic suite with few dependencies</p>",
        "id": 233862008,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617989728
    },
    {
        "content": "<p>Perhaps, but it depends a lot on how the library is set up and it's not particularly hard to write otherwise. I would like to see us get the infrastructure so that we can actually port basic files. I tried doing a nontrivial lean 4 proof a few days ago and I hit a whole bunch of issues that made it pretty hard even for non-mathlib proofs (aside from just missing lemmas). Right now no one is actually trying to prove theorems with lean 4 and getting the rough edges polished there is a higher priority IMO</p>",
        "id": 233862819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617990098
    },
    {
        "content": "<p>Do you think needing to build a custom lean is prohibitive for would-be tinkerers? If so, I can look into the VSCode-docker setup. </p>\n<p>EDIT: oh you mean playing with Lean4 independent of mathport</p>",
        "id": 233863420,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617990377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/233862819\">said</a>:</p>\n<blockquote>\n<p>...I tried doing a nontrivial lean 4 proof a few days ago and I hit a whole bunch of issues that made it pretty hard even for non-mathlib proofs (aside from just missing lemmas). Right now no one is actually trying to prove theorems with lean 4 and getting the rough edges polished there is a higher priority IMO</p>\n</blockquote>\n<p>Out of curiosity, could you mention some of the current limitations to doing non-trivial proofs in Lean 4 (ignoring the lack of existing lemmas etc to build off of)?</p>",
        "id": 233873943,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1617994831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243102\">@Brandon Brown</span> In my own experience doing mini-experiments on top of mathport, there are a few open Lean4 issues that are painful (e.g. <a href=\"https://github.com/leanprover/lean4/issues/382\">https://github.com/leanprover/lean4/issues/382</a>), a bunch of somewhat-annoying loose-ends (e.g. some name clashes, can't use dot notation for aligned types), but for basic stuff the elaborator works well. And all the lemmas are there and usable. There isn't much that can be proved without <code>normNum</code>, <code>ring</code>, etc. though.</p>",
        "id": 233875023,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617995224
    },
    {
        "content": "<p>I have not played around much with tactics either way though, so I don't know how dense the rough edges are still in the lean4 built-in tactics.</p>",
        "id": 233875579,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617995441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Anumbers/near/233862819\">said</a>:</p>\n<blockquote>\n<p>I hit a whole bunch of issues</p>\n</blockquote>\n<p>Can you tell us more?</p>",
        "id": 233878757,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1617996879
    },
    {
        "content": "<p>I'll make another topic for it.</p>",
        "id": 233922432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618026199
    }
]
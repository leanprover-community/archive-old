[
    {
        "content": "<p>For Lake reasons, I am constructing a \"well-formed\" version of the <code>Lean.Name</code> type. It works fine, but I feel my lack of experience with Lean techniques for thereon proving is making my approach less ergonomic than it should be.  For example, here is a relevant <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Name</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">WellFormed</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">anonymousWff</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"n\">anonymous</span>\n<span class=\"bp\">|</span> <span class=\"n\">strWff</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">mkStr</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">numWff</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">mkNum</span> <span class=\"n\">p</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">WellFormed.elimStr</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"o\">(</span><span class=\"n\">Name.str</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">strWff</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mkStr</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">h.1.symm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">w</span>\n  <span class=\"n\">exact</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">WellFormed.elimNum</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"o\">(</span><span class=\"n\">Name.num</span> <span class=\"n\">p</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">numWff</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mkNum</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">h.1.symm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">w</span>\n  <span class=\"n\">exact</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Name</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">WfName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">//</span> <span class=\"n\">n.WellFormed</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">WfName</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">anonymous</span> <span class=\"o\">:</span> <span class=\"n\">WfName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Name.anonymous</span><span class=\"o\">,</span> <span class=\"n\">Name.WellFormed.anonymousWff</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkStr</span> <span class=\"o\">:</span> <span class=\"n\">WfName</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">WfName</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">Name.mkStr</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Name.WellFormed.strWff</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkNum</span> <span class=\"o\">:</span> <span class=\"n\">WfName</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">WfName</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">Name.mkNum</span> <span class=\"n\">p</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">Name.WellFormed.numWff</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Syntax</span> <span class=\"k\">in</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">quote</span> <span class=\"o\">:</span> <span class=\"n\">WfName</span> <span class=\"bp\">→</span> <span class=\"n\">Syntax</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkCIdent</span> <span class=\"bp\">``</span><span class=\"n\">anonymous</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkCApp</span> <span class=\"bp\">``</span><span class=\"n\">mkStr</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">WfName.quote</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">w.elimStr</span><span class=\"o\">⟩,</span> <span class=\"n\">quote</span> <span class=\"n\">s</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"n\">p</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkCApp</span> <span class=\"bp\">``</span><span class=\"n\">mkNum</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">WfName.quote</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">w.elimNum</span><span class=\"o\">⟩,</span> <span class=\"n\">quote</span> <span class=\"n\">v</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Quote</span> <span class=\"n\">WfName</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">WfName.quote</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>In particular, I feel like I could be using match pattern or something in <code>quote</code> to have Lean deduce the fact that <code>p</code> is a proper <code>WfName</code> for free, but I am not sure how. Attempting to mark <code>anonymous</code>, <code>mkStr</code>, and <code>mkNum</code> as <code>@[matchPattern]</code> and use them directly in the <code>match</code> does not work and produces the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">patterns</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">p</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"n\">explicit</span> <span class=\"n\">pattern</span> <span class=\"kd\">variable</span><span class=\"o\">,</span> <span class=\"n\">but</span> <span class=\"n\">it</span> <span class=\"n\">only</span> <span class=\"n\">occurs</span> <span class=\"k\">in</span> <span class=\"n\">positions</span> <span class=\"n\">that</span> <span class=\"n\">are</span> <span class=\"n\">inaccessible</span> <span class=\"n\">to</span> <span class=\"n\">pattern</span> <span class=\"n\">matching</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">Name.str</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">p.1</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">mixHash</span> <span class=\"o\">(</span><span class=\"n\">hash</span> <span class=\"n\">p.val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hash</span> <span class=\"n\">s</span><span class=\"o\">)),</span>\n    <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Name.WellFormed</span> <span class=\"o\">(</span><span class=\"n\">Name.str</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">p.1</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">mixHash</span> <span class=\"o\">(</span><span class=\"n\">hash</span> <span class=\"n\">p.val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hash</span> <span class=\"n\">s</span><span class=\"o\">))))</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Any ideas on how I could improve my code?</p>",
        "id": 286843335,
        "sender_full_name": "Mac",
        "timestamp": 1655763330
    },
    {
        "content": "<p>Also, as a side note, in <code>quote</code> the linter reports <code>w</code> as an used variable despite it clearly being used in the code (e.g., <code>w.elimStr</code>, <code>w.elimNum</code>).</p>",
        "id": 286843655,
        "sender_full_name": "Mac",
        "timestamp": 1655763625
    },
    {
        "content": "<p>I don't think your <code>quote</code> definition can be improved much, but your <code>elimStr</code> theorem can be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">WellFormed</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">anonymous</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"n\">anonymous</span>\n<span class=\"bp\">|</span> <span class=\"n\">str</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">mkStr</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">num</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">mkNum</span> <span class=\"n\">p</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">WellFormed.elimStr</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"o\">(</span><span class=\"n\">Name.str</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">str</span> <span class=\"n\">w</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">WellFormed.elimNum</span> <span class=\"o\">:</span> <span class=\"n\">WellFormed</span> <span class=\"o\">(</span><span class=\"n\">Name.num</span> <span class=\"n\">p</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">num</span> <span class=\"n\">w</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">w</span>\n</code></pre></div>",
        "id": 286848247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655768135
    },
    {
        "content": "<p>(I removed the <code>Wff</code> suffix, since the convention is to use the namespace for disambiguation here)</p>",
        "id": 286848321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655768186
    },
    {
        "content": "<p>you could have a definition which packages up <code>⟨p, w.elimStr⟩</code> to make it a bit shorter</p>",
        "id": 286848359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655768265
    },
    {
        "content": "<p>But if you are hoping for a way to get <code>mkStr</code> and <code>mkNum</code> directly out of a pattern match, I think you will be disappointed. While it is possible to get something approximately like this, you would have to match on <code>w</code> to do this, not <code>p</code>; but matching on <code>w</code> would not allow you to construct data. The fundamental issue is that <code>mkStr</code> and <code>mkNum</code> can be arbitrary functions here, they are not obviously nonoverlapping. Matching on <code>p</code> has the desired codegen and the <code>elimStr</code> theorem allows you to patch things up after the fact.</p>",
        "id": 286848567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655768455
    },
    {
        "content": "<p>One other thing you could do is provide an induction principle that does the pattern match on <code>p</code> and patches things up</p>",
        "id": 286848661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655768541
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">WfName</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">anonymous</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">p.mkStr</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">p.mkNum</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">rec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">anonymous</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"n\">w</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">mkStr</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">w.elimStr</span><span class=\"o\">⟩</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">Name.str</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩)</span> <span class=\"bp\">▸</span>\n    <span class=\"n\">str</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"n\">p</span> <span class=\"n\">v</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"n\">w</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">mkNum</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">w.elimNum</span><span class=\"o\">⟩</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">Name.num</span> <span class=\"n\">p</span> <span class=\"n\">v</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩)</span> <span class=\"bp\">▸</span>\n    <span class=\"n\">num</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Syntax</span> <span class=\"k\">in</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">quote</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">WfName</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">rec</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">anonymous</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">mkCIdent</span> <span class=\"bp\">``</span><span class=\"n\">anonymous</span>\n  <span class=\"bp\">|</span> <span class=\"n\">str</span> <span class=\"n\">_p</span> <span class=\"n\">s</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">mkCApp</span> <span class=\"bp\">``</span><span class=\"n\">mkStr</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">quote</span> <span class=\"n\">s</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">num</span> <span class=\"n\">_p</span> <span class=\"n\">v</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">mkCApp</span> <span class=\"bp\">``</span><span class=\"n\">mkNum</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">quote</span> <span class=\"n\">v</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 286849578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655769608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Matching.20Recursive.20Subtypes/near/286848661\">said</a>:</p>\n<blockquote>\n<p>One other thing you could do is provide an induction principle that does the pattern match on <code>p</code> and patches things up [...]</p>\n</blockquote>\n<p>Cool! I see, though, that term-mode / <code>match</code> sadly does not support <code>using</code>. :(</p>",
        "id": 286851762,
        "sender_full_name": "Mac",
        "timestamp": 1655772200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Matching.20Recursive.20Subtypes/near/286848321\">said</a>:</p>\n<blockquote>\n<p>(I removed the <code>Wff</code> suffix, since the convention is to use the namespace for disambiguation here)</p>\n</blockquote>\n<p>I patterned my style off the <code>WellFormed</code> for <code>RBNode</code> which uses the <code>Wff</code> suffix. So are there conflicting conventions or is there some nuance I'm missing?</p>",
        "id": 286851868,
        "sender_full_name": "Mac",
        "timestamp": 1655772346
    },
    {
        "content": "<p>I guess that's a conflicting convention, although my impression is that very little work went into that <code>WellFormed</code> inductive - lean 4 stuff is not very proof optimized right now</p>",
        "id": 286853636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655774315
    }
]
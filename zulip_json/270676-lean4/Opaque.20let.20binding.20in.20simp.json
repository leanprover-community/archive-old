[
    {
        "content": "<p>When you turn off zeta reduction in the simplifier the free variable introduced by let becomes completely opaque. </p>\n<p>In my use case this is a problem. I want the discharger/typeclass system to see through these free variables.</p>\n<p>Here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.discharge</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"bp\">=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inv</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span>  <span class=\"c1\">-- [Meta.Tactic.simp.discharge] @comp_inv, failed to synthesize instance HasInv f</span>\n</code></pre></div>\n<p>The simplifier fails to apply <code>(f ∘ f)⁻¹ = f⁻¹ ∘ f⁻¹</code> because <code>f</code> is complete opaque with zeta reduction off and it can't prove that <code>f</code> is invertible.</p>\n<p>Is there a way to deal with this? </p>\n<hr>\n<p>My ultimate goal is to have a tactic that turns an expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>into:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"k\">let</span> <span class=\"n\">inv_f</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inv_f</span> <span class=\"o\">(</span><span class=\"n\">inv_f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 309167211,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1668163511
    },
    {
        "content": "<p>mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">HasInv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">has_inverse</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">comp_inv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasInv</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasInv</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inv</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HasInv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">add_inv</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.discharge</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"bp\">=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inv</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span>\n</code></pre></div>",
        "id": 309167249,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1668163528
    },
    {
        "content": "<p>Here is an idea how to deal with this problem by modifying the simplifier.  However, I would like to know if anyone has a simpler idea before I get into this.</p>\n<p>The root of this behavior is the line <a href=\"https://github.com/leanprover/lean4/blob/140d10819d1db4bc3be9d755599b009d6cdf8cf8/src/Lean/Meta/Tactic/Simp/Main.lean#L676\"><code>let bx := b.instantiate1 x</code></a> which replaces the let free variable with brand new free variable with no value in it. </p>\n<p>If I want to have zeta reduction off but allow discharger/typeclass system to see through the free variables introduced by let bindings, I probably have to modify the function <a href=\"https://github.com/leanprover/lean4/blob/140d10819d1db4bc3be9d755599b009d6cdf8cf8/src/Lean/Meta/Tactic/Simp/Rewrite.lean#L22\"><code>synthesizeArgs</code></a> and restore the original value for all the newly introduced free variables.</p>",
        "id": 309168192,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1668163930
    }
]
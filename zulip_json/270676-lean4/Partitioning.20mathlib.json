[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> What are the smallest strongly connected components? (i.e. pick a point, close under all forward edges)</p>",
        "id": 240749889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622371462
    },
    {
        "content": "<p>Regarding <code>data</code>, I think you should just treat the top level subfiles/folders in <code>data</code> as their own nodes in this graph. It's kind of a \"misc\" directory</p>",
        "id": 240749953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622371581
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">In</span><span class=\"o\">[</span><span class=\"mi\">76</span><span class=\"o\">]:=</span> <span class=\"n\">ConnectedComponents</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">]</span>\n\n<span class=\"n\">Out</span><span class=\"o\">[</span><span class=\"mi\">76</span><span class=\"o\">]</span><span class=\"bp\">=</span> <span class=\"o\">{{</span><span class=\"s2\">\"algebraic_topology\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"geometry\"</span><span class=\"o\">},</span> <span class=\"bp\">\\</span>\n<span class=\"o\">{</span><span class=\"s2\">\"representation_theory\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"probability_theory\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"computability\"</span><span class=\"o\">},</span> <span class=\"bp\">\\</span>\n<span class=\"o\">{</span><span class=\"s2\">\"algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"algebraic_geometry\"</span><span class=\"o\">,</span> <span class=\"s2\">\"analysis\"</span><span class=\"o\">,</span> <span class=\"s2\">\"category_theory\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"combinatorics\"</span><span class=\"o\">,</span> <span class=\"s2\">\"control\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data\"</span><span class=\"o\">,</span> <span class=\"s2\">\"deprecated\"</span><span class=\"o\">,</span> <span class=\"s2\">\"dynamics\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"field_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"group_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"linear_algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"logic\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"number_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"order\"</span><span class=\"o\">,</span> <span class=\"s2\">\"ring_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"system\"</span><span class=\"o\">,</span> <span class=\"s2\">\"tactic\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"topology\"</span><span class=\"o\">,</span> <span class=\"s2\">\"measure_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"testing\"</span><span class=\"o\">,</span> <span class=\"s2\">\"meta\"</span><span class=\"o\">,</span> <span class=\"s2\">\"set_theory\"</span><span class=\"o\">}}</span>\n</code></pre></div>",
        "id": 240750427,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622372509
    },
    {
        "content": "<p>:-(</p>",
        "id": 240750475,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622372536
    },
    {
        "content": "<p>Doesn't appreciably improve if we explode <code>data</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{{</span><span class=\"s2\">\"algebraic_topology\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"computability\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"data$ordmap\"</span><span class=\"o\">},</span> <span class=\"bp\">\\</span>\n<span class=\"o\">{</span><span class=\"s2\">\"geometry\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"probability_theory\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"data$analysis\"</span><span class=\"o\">},</span> <span class=\"bp\">\\</span>\n<span class=\"o\">{</span><span class=\"s2\">\"data$qpf\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"data$pfunctor\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"data$fp\"</span><span class=\"o\">},</span> <span class=\"bp\">\\</span>\n<span class=\"o\">{</span><span class=\"s2\">\"representation_theory\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"algebraic_geometry\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"analysis\"</span><span class=\"o\">,</span> <span class=\"s2\">\"category_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"combinatorics\"</span><span class=\"o\">,</span> <span class=\"s2\">\"control\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"data$complex\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$equiv\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$finset\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$finsupp\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"data$fintype\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$int\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$list\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$matrix\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"data$multiset\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$mv_polynomial\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$nat\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$padics\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"data$pnat\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$polynomial\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$rat\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$real\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$set\"</span><span class=\"o\">,</span>\n   <span class=\"s2\">\"data$zmod\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$zsqrtd\"</span><span class=\"o\">,</span> <span class=\"s2\">\"deprecated\"</span><span class=\"o\">,</span> <span class=\"s2\">\"dynamics\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"field_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"group_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"linear_algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"logic\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"number_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"order\"</span><span class=\"o\">,</span> <span class=\"s2\">\"ring_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"system\"</span><span class=\"o\">,</span> <span class=\"s2\">\"tactic\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"topology\"</span><span class=\"o\">,</span> <span class=\"s2\">\"measure_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$array\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$buffer\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"data$dlist\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$lazy_list\"</span><span class=\"o\">,</span> <span class=\"s2\">\"testing\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$bitvec\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"data$string\"</span><span class=\"o\">,</span> <span class=\"s2\">\"set_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$num\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$seq\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$stream\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"meta\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$option\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$setoid\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data$sigma\"</span><span class=\"o\">}}</span>\n</code></pre></div>",
        "id": 240750567,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622372739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240750427\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">In</span><span class=\"o\">[</span><span class=\"mi\">76</span><span class=\"o\">]:=</span> <span class=\"n\">ConnectedComponents</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">]</span>\n\n<span class=\"n\">Out</span><span class=\"o\">[</span><span class=\"mi\">76</span><span class=\"o\">]</span><span class=\"bp\">=</span> <span class=\"o\">{{</span><span class=\"s2\">\"algebraic_topology\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"geometry\"</span><span class=\"o\">},</span> <span class=\"bp\">\\</span>\n<span class=\"o\">{</span><span class=\"s2\">\"representation_theory\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"probability_theory\"</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"s2\">\"computability\"</span><span class=\"o\">},</span> <span class=\"bp\">\\</span>\n<span class=\"o\">{</span><span class=\"s2\">\"algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"algebraic_geometry\"</span><span class=\"o\">,</span> <span class=\"s2\">\"analysis\"</span><span class=\"o\">,</span> <span class=\"s2\">\"category_theory\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"combinatorics\"</span><span class=\"o\">,</span> <span class=\"s2\">\"control\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data\"</span><span class=\"o\">,</span> <span class=\"s2\">\"deprecated\"</span><span class=\"o\">,</span> <span class=\"s2\">\"dynamics\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"field_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"group_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"linear_algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"logic\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"number_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"order\"</span><span class=\"o\">,</span> <span class=\"s2\">\"ring_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"system\"</span><span class=\"o\">,</span> <span class=\"s2\">\"tactic\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"topology\"</span><span class=\"o\">,</span> <span class=\"s2\">\"measure_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"testing\"</span><span class=\"o\">,</span> <span class=\"s2\">\"meta\"</span><span class=\"o\">,</span> <span class=\"s2\">\"set_theory\"</span><span class=\"o\">}}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Note that there is nothing special about <code>algebraic_topology</code>, <code>geometry</code>, or <code>representation_theory</code>. The fact that these are their own SCC just means that we haven't gone very far in these directions yet.<br>\nThere are quite-easy-to-state <del>conjectures</del>theorems in commutative algebra that were only proven a couple of years ago using perfectoid spaces. The Breen-Deligne resolutions in homological algebra that we carefully avoided in LTE are proven to exist using some hammers from algebraic topology. Representation theory uses a lot of Lie theory and algebraic geometry. At the same time, motivic conjectures in number theory/algebraic geometry use a lot of representation theory.<br>\nThis list can go on and on.</p>",
        "id": 240753595,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622377810
    },
    {
        "content": "<p>Something looks odd about that result. I know that <code>computability</code> references <code>data$nat</code> for example. Perhaps we have the arrows the wrong way around?</p>",
        "id": 240758226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622384984
    },
    {
        "content": "<p>(I'm interested in a node in the graph and it's <em>dependencies</em>, since that represents a subcomponent that could possibly be extracted to a library. The lonely points in your analysis are just \"endpoint theorems\" that have no current applications outside their own field, like computability and representation theory.)</p>",
        "id": 240758313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622385100
    },
    {
        "content": "<p>What I did was take the equivalence relation <code>a ~ b</code> iff there is a path from a to b, and a path from b to a. (I think...)</p>",
        "id": 240782328,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622422948
    },
    {
        "content": "<p>This is the strongly connected components. (And is invariant under reversing all arrows.)</p>\n<p>What you suggested above (just take the closure under arrows in one direction) doesn't give a partition, but I agree is still useful. I'll compute it in a moment.</p>",
        "id": 240782419,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622423153
    },
    {
        "content": "<p>The smallest set of top-level (+data) directories closed under adding imports is sadly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"analysis\"</span><span class=\"o\">,</span> <span class=\"s2\">\"category_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"control\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"data.equiv\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.finset\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.finsupp\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.fintype\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"data.int\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.list\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.matrix\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.multiset\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"data.mv_polynomial\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.nat\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.option\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.polynomial\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"data.rat\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.seq\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.set\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.zmod\"</span><span class=\"o\">,</span> <span class=\"s2\">\"deprecated\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"group_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"linear_algebra\"</span><span class=\"o\">,</span> <span class=\"s2\">\"logic\"</span><span class=\"o\">,</span> <span class=\"s2\">\"number_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"order\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"ring_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"tactic\"</span><span class=\"o\">,</span> <span class=\"s2\">\"topology\"</span><span class=\"o\">,</span> <span class=\"s2\">\"combinatorics\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.complex\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"data.real\"</span><span class=\"o\">,</span> <span class=\"s2\">\"field_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"measure_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.sigma\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"set_theory\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.stream\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.array\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.num\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.pnat\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"data.string\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.setoid\"</span><span class=\"o\">,</span> <span class=\"s2\">\"dynamics\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.zsqrtd\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"algebraic_geometry\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.padics\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.buffer\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.dlist\"</span><span class=\"o\">,</span> <span class=\"bp\">\\</span>\n<span class=\"s2\">\"meta\"</span><span class=\"o\">,</span> <span class=\"s2\">\"testing\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.bitvec\"</span><span class=\"o\">,</span> <span class=\"s2\">\"data.lazy_list\"</span><span class=\"o\">,</span> <span class=\"s2\">\"system\"</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 240802649,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622447440
    },
    {
        "content": "<p>Wait, I don't think I understand what you mean with \"closed under adding imports\".</p>",
        "id": 240802819,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622447550
    },
    {
        "content": "<p>Say directory A imports directory B if _some_ file in A imports _some_ file in B.</p>",
        "id": 240802851,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622447579
    },
    {
        "content": "<p>Say directory A transitively imports directory B is there is a chain of such...</p>",
        "id": 240802889,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622447608
    },
    {
        "content": "<p>Ooh, wow. What is the complement of that smallest set?</p>",
        "id": 240802891,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622447609
    },
    {
        "content": "<p>Claim, this is the smallest set of directories closed under \"imports\".</p>",
        "id": 240802910,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622447628
    },
    {
        "content": "<p>{\"algebraic_topology\", \"computability\", \"data.analysis\", \"data.fp\", \\<br>\n\"data.ordmap\", \"data.pfunctor\", \"data.qpf\", \"geometry\", \\<br>\n\"probability_theory\", \"representation_theory\"}</p>",
        "id": 240802968,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622447658
    },
    {
        "content": "<p>So just the \"brand new\" stuff plus some abandonware.</p>",
        "id": 240802981,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622447672
    },
    {
        "content": "<p>If you take any point v in the graph and add all points it points to and all points they point to and so on, you get a set. You can do this for every point in the graph and many of them will be the same, and the ones that are minimal by subset order will also be SCCs (every point in the set will generate the set by this procedure)</p>",
        "id": 240802992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622447682
    },
    {
        "content": "<p>The problem here is that blurring things out to directory level makes mathlib very much not a DAG.</p>",
        "id": 240803061,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622447734
    },
    {
        "content": "<p>I think this is all making the point that every directory uses every other directory very well though</p>",
        "id": 240803145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622447768
    },
    {
        "content": "<p>for example with the graph <code>A -&gt; B &lt;-&gt; C</code> you get the sets <code>{A, B, C}</code> (not a SCC) and <code>{B, C}</code> (a SCC)</p>",
        "id": 240803296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622447883
    },
    {
        "content": "<p>I don't think that effect of directory blurring is surprising; if you have a lemma connecting two directories A and B, its file usually ends up in one of A or B without much thought as to which.</p>",
        "id": 240806677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622450275
    },
    {
        "content": "<p>Any particular reason why dependencies are being analyzed at the directory level rather than the file level? I would imagine that each area of theory would be interconnected with others. However, I also imagine there exists some \"basic\" foundation that each area defines without reference to others that could be extracted out into some \"prelude\" that could be imported by each area that leverages it. The interconnected components would then be add latter in the main file.</p>\n<p>For example,  you could have <code>prelude/algebra</code> which defines all the type classes relevant to algebra and that may be imported by other things like <code>ring_theory</code> and then <code>algebra</code> proper that imports <code>prelude/algebra</code> along with stuff in others areas to fill in the interconnections.</p>",
        "id": 240845511,
        "sender_full_name": "Mac",
        "timestamp": 1622474475
    },
    {
        "content": "<p>I guess that means we'll have north of 50 pkgs. Which is probably fine. As long as they don't have to be maintained manually.</p>",
        "id": 240846934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622475333
    },
    {
        "content": "<p>Yeah I have no problem with having 50 packages <em>if</em> it can all be handled transparently and doesn't affect the naming of things. The problem is that naming things <code>prelude27/algebra</code> makes it absolutely atrocious to find anything. I really want a solution that allows the packaging to work on a level orthogonal to file layout and module naming (which is topical, not based on dependency order)</p>",
        "id": 240851136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622478118
    },
    {
        "content": "<p>Is just splitting mathlib into two things still on the table, a \"complib\" and a \"mathlib\" where complib (or whatever it would be called) just contains tactics and other basic things that mathlib or any computation-focused people alike would need?</p>",
        "id": 240859836,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1622485033
    },
    {
        "content": "<p>quite frankly I would like to call that other lib \"std\"</p>",
        "id": 240860046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485217
    },
    {
        "content": "<p>I do think there is a place for a more separate piece of mathlib which is more focused on comp sci, tactics, and the basic mathematics needed to support it, while still being batteries-included like mathlib</p>",
        "id": 240860269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485411
    },
    {
        "content": "<p>That is at least topically separate enough that people can probably get their heads around it (although there is conceivably a good deal of overlap when it comes to the kind of stuff that ends up in <code>data</code>)</p>",
        "id": 240860422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240851136\">said</a>:</p>\n<blockquote>\n<p>Yeah I have no problem with having 50 packages <em>if</em> it can all be handled transparently and doesn't affect the naming of things. The problem is that naming things <code>prelude27/algebra</code> makes it absolutely atrocious to find anything.</p>\n</blockquote>\n<p>I am not sure this would be a problem. For example if I have I want all of algebra I import<code>Algebra</code>, if I just want algebra's prelude I import <code>Algebra.Prelude</code>. The prelude, if necessary, could be split into separate modules as well (ex. <code>Algebra.PreludeA</code>and <code>Algebra.PreludeB</code> -- the real modules would have more informative names -- like <code>Classes</code> or <code>Basic</code> or whatever). If said splits are sequential (i.e. <code>PreludeB</code> imports <code>PreludeA</code>) then only the relevant level would need to be imported by users. If said splits are independent than the user can imported whichever of <code>PreludeA</code> and/or <code>PreludeB</code> they need.</p>",
        "id": 240860425,
        "sender_full_name": "Mac",
        "timestamp": 1622485529
    },
    {
        "content": "<blockquote>\n<p>if said splits are independent than the user can imported whichever of PreludeA or PreludeB they need.</p>\n</blockquote>\n<p>Right, this is the problem - you won't be able to tell which one you want most of the time because the names are likely to be very difficult to make informative</p>",
        "id": 240860529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485613
    },
    {
        "content": "<p>We already have this kind of thing, at the file level. Mathlib almost always uses precise imports to combat dependency creep. I just want to leverage that instead of adding another thing for users to deal with</p>",
        "id": 240860684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240860529\">said</a>:</p>\n<blockquote>\n<p>you won't be able to tell which one you want most of the time because the names are likely to be very difficult to make informative</p>\n</blockquote>\n<p>Why? What makes it so hard to give informative names? For example, If have a module with <code>foo</code>, <code>bar</code>, and <code>baz</code>. I could, in the worst case,  call it <code>FooBarBaz</code>.</p>",
        "id": 240860713,
        "sender_full_name": "Mac",
        "timestamp": 1622485770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240860684\">said</a>:</p>\n<blockquote>\n<p>We already have this kind of thing, at the file level. Mathlib almost always uses precise imports to combat dependency creep. I just want to leverage that instead of adding another thing for users to deal with</p>\n</blockquote>\n<p>I thought we were talking about the file level?</p>",
        "id": 240860800,
        "sender_full_name": "Mac",
        "timestamp": 1622485804
    },
    {
        "content": "<p>What if it's <code>foo</code> and then <code>bar</code> and then more <code>foo</code> and then <code>foo</code> and <code>bar</code> together?</p>",
        "id": 240860808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485811
    },
    {
        "content": "<p>sometimes it gets hard to name things beyond <code>Foo1</code>, <code>Bar</code>, <code>Foo2</code>, <code>FooBar</code></p>",
        "id": 240860837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485856
    },
    {
        "content": "<p>Or what if there are 10 files that progressively treat more and more theory of <code>foo</code>?</p>",
        "id": 240860856,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622485873
    },
    {
        "content": "<p>and then if you have a foo fact you want you have to go looking through several files</p>",
        "id": 240860857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240860808\">said</a>:</p>\n<blockquote>\n<p>What if it's <code>foo</code> and then <code>bar</code> and then more <code>foo</code> and then <code>foo</code> and <code>bar</code> together?</p>\n</blockquote>\n<p>If there is no greater logical grouping than I really should have six modules: <code>Foo.Basic</code>, <code>Bar.Basic</code>, <code>Foo.Extra</code>,  <code>FooBar</code>,  <code>Foo</code> (<code>Foo.Basic</code> + <code>Foo.Extra</code> + <code>FooBar</code>), and <code>Bar</code> (<code>Bar.Basic</code> + <code>FooBar</code>).</p>",
        "id": 240860880,
        "sender_full_name": "Mac",
        "timestamp": 1622485908
    },
    {
        "content": "<p>mathlib has this issue a <em>lot</em>, because that's how math works: the concepts are few but the layers of theorems keep coming. Reminder that FLT is a theorem about the natural numbers</p>",
        "id": 240860960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622485969
    },
    {
        "content": "<p>So <code>Foo</code> is the complete theory of <code>foo</code>? Does that mean that it conceptually could import literally anything in mathlib?</p>",
        "id": 240861082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486071
    },
    {
        "content": "<p>because that means it will be unusable (in mathlib)</p>",
        "id": 240861093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486084
    },
    {
        "content": "<p>That is what I would expect, yes</p>",
        "id": 240861109,
        "sender_full_name": "Mac",
        "timestamp": 1622486101
    },
    {
        "content": "<p>(as an end user)</p>",
        "id": 240861124,
        "sender_full_name": "Mac",
        "timestamp": 1622486116
    },
    {
        "content": "<p>Unfortunately a lot of mathlib files fall in roughly this category which is why the dependency graph is such a rats nest</p>",
        "id": 240861126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486118
    },
    {
        "content": "<p>In what category do you mean?</p>",
        "id": 240861391,
        "sender_full_name": "Mac",
        "timestamp": 1622486347
    },
    {
        "content": "<p>From an end user perspective (someone importing the library), there aren't any dependency issues, you can just use whatever you like. I'm talking about the within-mathlib perspective. (When I said \"users\" earlier I meant contributors)</p>",
        "id": 240861400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486357
    },
    {
        "content": "<p>Almost every new file conceptually builds on everything that came before. If you are a mathematician expanding the theory in some area you don't want to be bothered with this dependency tetris, you just import what you need</p>",
        "id": 240861503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240861503\">said</a>:</p>\n<blockquote>\n<p>Almost every new file conceptually builds on everything that came before. If you are a mathematician expanding the theory in some area you don't want to be bothered with this dependency tetris, you just import what you need</p>\n</blockquote>\n<p>That's fine for prototyping, but upon actual addition to the library, optimizing imports should be done.</p>",
        "id": 240861577,
        "sender_full_name": "Mac",
        "timestamp": 1622486514
    },
    {
        "content": "<p>As a maintainer, this approach doesn't bother me so much, because dependency pruning is an activity that can be dealt with separately and requires very little mathematical skill</p>",
        "id": 240861586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486517
    },
    {
        "content": "<p>Okay so we seem to be on the same page there.</p>",
        "id": 240861652,
        "sender_full_name": "Mac",
        "timestamp": 1622486564
    },
    {
        "content": "<p>In which case a contributor could write their new file using the complete endpoints (ex. <code>Foo</code> and <code>Bar</code>) and the later dependency pruning step could optimize the dependencies and add that file to its relevant  theories (including, possibly <code>Foo</code> and/or <code>Bar</code>).</p>",
        "id": 240861699,
        "sender_full_name": "Mac",
        "timestamp": 1622486632
    },
    {
        "content": "<p>However, what this means is that the actual intended position of most files in the dependency graph is not clear. Is this a high-end theorem? Something foundational? Many files mix a bit of both, and high-end theorems often try to race each other to the top</p>",
        "id": 240861767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486678
    },
    {
        "content": "<p>Maybe some tooling could be written to take a Lean file and inject its definitions into the proper place in the dependency graph based on used name?</p>",
        "id": 240861833,
        "sender_full_name": "Mac",
        "timestamp": 1622486759
    },
    {
        "content": "<p>Given that, a naming/foldering convention that makes dependency height important is a distraction for most contributors. Dependency organization is important but should be centralized in a way that doesn't impact the contributor experience</p>",
        "id": 240861880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486774
    },
    {
        "content": "<p>for example, a build file that explicitly orders everything</p>",
        "id": 240861909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486805
    },
    {
        "content": "<p>although full dependency inference is also possible</p>",
        "id": 240861930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486832
    },
    {
        "content": "<p>the advantage being that you never have to worry about dependency order unless you hit a cycle</p>",
        "id": 240861966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486866
    },
    {
        "content": "<p>Yeah that is what I was thinking. The idea would be contributors would all stick their contributions in a <code>newstuff</code> folder (or something like that) that would use the easy-to-access endpoints (ex. <code>Algebra</code> or <code>Foo</code>/<code>Bar</code>) and a latter dependency pruning / build step would reorder things to be reasonable (by refactor additions into <code>Foo.Basic</code> / <code>Bar.Basic</code> or whatever).</p>",
        "id": 240862040,
        "sender_full_name": "Mac",
        "timestamp": 1622486912
    },
    {
        "content": "<p>We want people to organize new material though. The organization is based on topic, not dependency order, though</p>",
        "id": 240862104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622486997
    },
    {
        "content": "<p>okay, so the contributions in the postulated <code>newstuff</code> folder (or whatever) could be organized into folders based on topic?</p>",
        "id": 240862162,
        "sender_full_name": "Mac",
        "timestamp": 1622487035
    },
    {
        "content": "<p>and the other part?</p>",
        "id": 240862195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487071
    },
    {
        "content": "<p>which other part?</p>",
        "id": 240862207,
        "sender_full_name": "Mac",
        "timestamp": 1622487093
    },
    {
        "content": "<p>right now all of mathlib is organized like your <code>newstuff</code> folder</p>",
        "id": 240862236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487114
    },
    {
        "content": "<p>it sounds like you are trying to add an explicit transition point to a different organization scheme which is based on dependencies</p>",
        "id": 240862299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487147
    },
    {
        "content": "<p>So then the dependency pruning step involves taking those definitions and sticking them into the proper modules based on their dependency order (and topic).</p>",
        "id": 240862333,
        "sender_full_name": "Mac",
        "timestamp": 1622487175
    },
    {
        "content": "<p>but then users have to know about that dependency order in order to import the file</p>",
        "id": 240862353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487203
    },
    {
        "content": "<p>Yes, that is generally how end user importing of files/libraries works? If they want to be specific about things, otherwise they also just use the easy endpoints.</p>",
        "id": 240862441,
        "sender_full_name": "Mac",
        "timestamp": 1622487260
    },
    {
        "content": "<p>The point in this whole effort would be for those users who specifically only want to leverage stuff at higher levels of the dependency chain.</p>",
        "id": 240862527,
        "sender_full_name": "Mac",
        "timestamp": 1622487355
    },
    {
        "content": "<p>It would also then help in migrating some of that stuff into a separate less mathy, more standard library.</p>",
        "id": 240862597,
        "sender_full_name": "Mac",
        "timestamp": 1622487391
    },
    {
        "content": "<p>Why can't the naming just not be related to dependency order?</p>",
        "id": 240862622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487430
    },
    {
        "content": "<p>It is strange to me that this needs to be so intertwined</p>",
        "id": 240862631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487454
    },
    {
        "content": "<p>Just let people name things as they like</p>",
        "id": 240862639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487465
    },
    {
        "content": "<p>When you start going to the very fine grained approach, your packages again won't make much sense. You need the packages to talk about a topic, at least roughly</p>",
        "id": 240862871,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622487618
    },
    {
        "content": "<p>Yes, but I think we are talking about files within packages though.</p>",
        "id": 240862922,
        "sender_full_name": "Mac",
        "timestamp": 1622487661
    },
    {
        "content": "<p>If end users have the ability to make a la carte sub-packages from mathlib according to whatever they feel like importing, then that pretty much solves the problem without having to do solve the hardest problem in computer science (naming things)</p>",
        "id": 240863022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622487727
    },
    {
        "content": "<p>Why don't we simply have a MacLib organized and developped by Mac the way Mac thinks is good and keep mathlib the way it works so great for everyone else?</p>",
        "id": 240863031,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1622487732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240863031\">said</a>:</p>\n<blockquote>\n<p>Why don't we simply have a MacLib organized and developped by Mac the way Mac thinks is good and keep mathlib the way it works so great for everyone else?</p>\n</blockquote>\n<p>Fyi, I wasn't the one who proposed partitioning mathlib here.</p>",
        "id": 240863075,
        "sender_full_name": "Mac",
        "timestamp": 1622487792
    },
    {
        "content": "<p>I was simply providing some ideas as to how that could occur.</p>",
        "id": 240863105,
        "sender_full_name": "Mac",
        "timestamp": 1622487822
    },
    {
        "content": "<p>I asked about topical packages early in the thread and I got legitimate issues. The idea of splitting up must make sense in order to happen.</p>",
        "id": 240863234,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622487933
    },
    {
        "content": "<p>The idea of doing ad hoc packages sounds like dead code elimination which is something we could do in the compiler domain</p>",
        "id": 240863337,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488000
    },
    {
        "content": "<p>this would be more like leanpkg domain, but that's the general idea</p>",
        "id": 240863379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488058
    },
    {
        "content": "<p>Not really... Why bother with files. Might just as well do it on the definition level</p>",
        "id": 240863490,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488141
    },
    {
        "content": "<p>It's like dead code elimination and you choosing to re export what you want to reuse</p>",
        "id": 240863519,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488178
    },
    {
        "content": "<p>that would be even better, but it's almost science fiction level I think</p>",
        "id": 240863530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488187
    },
    {
        "content": "<p>It's what Javascript does more of less</p>",
        "id": 240863586,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488212
    },
    {
        "content": "<p>The domain of <code>leanpkg</code> is download/building/running packages, it has more-or-less nothing to do with how those packages are used in code.</p>",
        "id": 240863587,
        "sender_full_name": "Mac",
        "timestamp": 1622488213
    },
    {
        "content": "<p>dependency management is definitely in the purview of <code>cargo</code></p>",
        "id": 240863625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488259
    },
    {
        "content": "<p>To get that fine grained dependency management that you like about mathlib, the most logical approach is a source dependency with dead code elimination</p>",
        "id": 240863723,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240863519\">said</a>:</p>\n<blockquote>\n<p>It's like dead code elimination and you choosing to re export what you want to reuse</p>\n</blockquote>\n<p>For the latter, this should actually be pretty possible once Lean gets it module system. The former would require retooling the compiler to keep track of which imported symbols are used and prune the unused ones from the result <code>olean</code> and providing  that information in a way that the rebuilder (which <em>is</em> part of <code>leanpkg</code>) can figure out whether or not to rebuild the file when its dependencies change.</p>",
        "id": 240863758,
        "sender_full_name": "Mac",
        "timestamp": 1622488399
    },
    {
        "content": "<p>That could totally be a way of depending on mathlib, effectively as a submodule with pruning</p>",
        "id": 240863765,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488405
    },
    {
        "content": "<p>How do you know if an import is dead though? Simon looked at this problem a while back and unfortunately the most reliable method is just to take the import line out and see if lean complains</p>",
        "id": 240863769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488411
    },
    {
        "content": "<p>because lean imports can have so many kinds of side effects on the environment and parsing</p>",
        "id": 240863842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488447
    },
    {
        "content": "<p>Yeah, that is the major problem with automatic approach.</p>",
        "id": 240863880,
        "sender_full_name": "Mac",
        "timestamp": 1622488488
    },
    {
        "content": "<p>Interesting. I think we will learn more about the problem space when we build the module system</p>",
        "id": 240863907,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488507
    },
    {
        "content": "<p>You can still do it, but it is computationally expensive enough that it's worth just taking the import lines at face value and relying on external processes to optimize them</p>",
        "id": 240863928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488541
    },
    {
        "content": "<p>I could for instance see having an isolated environment per module or similar</p>",
        "id": 240863937,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"235513\">@Daniel Fabian</span> In fact, this also sounds similar to the discussion around changing <code>Notation.lean</code> and having to rebuild all of Lean.</p>",
        "id": 240863959,
        "sender_full_name": "Mac",
        "timestamp": 1622488562
    },
    {
        "content": "<p>It is certainly worth thinking about</p>",
        "id": 240864016,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240863928\">said</a>:</p>\n<blockquote>\n<p>You can still do it, but it is computationally expensive enough that it's worth just taking the import lines at face value and relying on external processes to optimize them</p>\n</blockquote>\n<p>Alternatively, the ad-hoc package approach (within the module system) where someone just imports the entirety of Mathlib and then only manual exports select symbols would also work (and remove the need for optimizing imports).</p>",
        "id": 240864062,
        "sender_full_name": "Mac",
        "timestamp": 1622488647
    },
    {
        "content": "<p>ala JavaScript and Haskell</p>",
        "id": 240864180,
        "sender_full_name": "Mac",
        "timestamp": 1622488735
    },
    {
        "content": "<p>If mathlib becomes more narrowly math-focused, then it seems that it makes sense to keep it a monolith since a monolith is simple and many of the math-focused users are not well-versed with complexities of all these dependency/build issues and just want to be doing math, and it's easy to contribute to a monolith. Packages that are meant for writing practical programs can do the typical programming language package dichotomization.</p>",
        "id": 240864188,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1622488741
    },
    {
        "content": "<p>Another option might be ex post dead code elimination. After elaboration it might be much easier</p>",
        "id": 240864300,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622488807
    },
    {
        "content": "<p>It is definitely easier post elaboration, but it's also \"wrong\", you miss out on imports that were required for the lean file to build</p>",
        "id": 240864336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488845
    },
    {
        "content": "<p>If you only care about the output files then that's quite doable. <code>olean</code> files have an easily accessible explicit dependency relation</p>",
        "id": 240864389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622488907
    },
    {
        "content": "<p>If lean4 compiles to C, can't the gcc linker do the dead code elimination? If we're not eliminating dead code to reduce binary sizes, what are we eliminating it for?</p>",
        "id": 240864526,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622489035
    },
    {
        "content": "<p>Regarding \"Packages that are meant for writing practical programs can do the typical programming language package dichotomization.\", keep in mind that a big part of the draw (for me, at least) is the ability to write programs <em>and then prove things about them</em>. This is an anti-modular pattern though, because you need to know what a program is doing to prove it is correct. So splitting the mathy stuff from the programming stuff doesn't really work, or rather it works as long as you accept that the packages are separate but actually tightly coupled</p>",
        "id": 240864699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622489174
    },
    {
        "content": "<p>This is part of why I have argued against the pervasive use of <code>private</code> in lean core, because it hinders reusability and introspection from external packages like mathlib</p>",
        "id": 240864783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622489275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240864526\">said</a>:</p>\n<blockquote>\n<p>If lean4 compiles to C, can't the gcc linker do the dead code elimination? If we're not eliminating dead code to reduce binary sizes, what are we eliminating it for?</p>\n</blockquote>\n<p>The idea is to create ad-hoc packages that only have some subset of the functionality of mathlib. So let's say I want to create the package <code>OpenPrivate</code> that only has the <code>open private</code> command from mathlib. I could import all of mathlib export open private and its related syntax and then the dead code elimination would remove the rest of the code in mathlib so that the resulting binary library for <code>OpenPrivate</code> only has the code it needs to support <code>open private</code>.</p>",
        "id": 240865210,
        "sender_full_name": "Mac",
        "timestamp": 1622489673
    },
    {
        "content": "<p>If you are building a binary, the linker should already do that</p>",
        "id": 240865319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622489790
    },
    {
        "content": "<p><code>open private</code> seems like one of those this-should-actually-be-in-core modules that could be easily split from mathlib.</p>",
        "id": 240865342,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1622489822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240864699\">said</a>:</p>\n<blockquote>\n<p>Regarding \"Packages that are meant for writing practical programs can do the typical programming language package dichotomization.\", keep in mind that a big part of the draw (for me, at least) is the ability to write programs <em>and then prove things about them</em>.</p>\n</blockquote>\n<p>However the idea is that Lean is now going to be a general purpose language. That is, many people will write programs and libraries without necessarily proving anything about them. Then, if someone else comes along and wants to verify the contents of said libraries they can create a separate (but related) library that proves things about it. Thus, the dichotomization can still appear.</p>",
        "id": 240865379,
        "sender_full_name": "Mac",
        "timestamp": 1622489865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240865319\">said</a>:</p>\n<blockquote>\n<p>If you are building a binary, the linker should already do that</p>\n</blockquote>\n<p>I'm pretty sure it doesn't. In fact, I believe that resulting library will be the entirety of math lib plus whatever code you write (because transitive imports).</p>",
        "id": 240865462,
        "sender_full_name": "Mac",
        "timestamp": 1622489926
    },
    {
        "content": "<blockquote>\n<p>That is, many people will write programs and libraries without necessarily proving anything about them. Then, if someone else comes along and wants to verify the contents of said libraries they can create a separate (but related) library that proves things about it.</p>\n</blockquote>\n<p>Yes, that's exactly the situation we currently find ourselves in. The unverified package is lean core, and the someone else is mathlib</p>",
        "id": 240865464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622489926
    },
    {
        "content": "<p>Yes? So? I'm confused as to what you are getting at.</p>",
        "id": 240865518,
        "sender_full_name": "Mac",
        "timestamp": 1622489987
    },
    {
        "content": "<p>But the dependent proofy package needs to be able to couple to the unverified package and encapsulation mechanisms from traditional programming languages are actively hostile to this effort</p>",
        "id": 240865524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622489999
    },
    {
        "content": "<p>I agree completely with your desire to remove <code>private</code> as concept.</p>",
        "id": 240865589,
        "sender_full_name": "Mac",
        "timestamp": 1622490030
    },
    {
        "content": "<p>I think, if desired, being able to get at any definition should be possible.</p>",
        "id": 240865613,
        "sender_full_name": "Mac",
        "timestamp": 1622490057
    },
    {
        "content": "<p>I am vaguely uncomfortable with discussions about a module system because I expect it to be another, possibly stronger, iteration of the same idea</p>",
        "id": 240865630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622490074
    },
    {
        "content": "<p>why not do an in-between thing? private could hide intellsense, making the UX nice and clean, but you might eg do something like <code>obj.#privateMethod</code> to access privates?</p>",
        "id": 240865653,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622490117
    },
    {
        "content": "<p>There's value to private stuff due to encapsulation, but in a pure language you don't need to worry about corrupting state.</p>",
        "id": 240865698,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622490143
    },
    {
        "content": "<p>so maybe making it a UX thing is good enough?</p>",
        "id": 240865704,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622490155
    },
    {
        "content": "<p>That kind of privacy is totally fine by me</p>",
        "id": 240865705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622490158
    },
    {
        "content": "<p>I think python also does something like that</p>",
        "id": 240865711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622490168
    },
    {
        "content": "<p>privacy by ugly naming convention</p>",
        "id": 240865716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622490178
    },
    {
        "content": "<p>Sounds good to me as well.</p>",
        "id": 240865718,
        "sender_full_name": "Mac",
        "timestamp": 1622490180
    },
    {
        "content": "<p>but in python you can shoot yourself into the foot.</p>",
        "id": 240865727,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622490188
    },
    {
        "content": "<p>In a pure language, not so much...</p>",
        "id": 240865732,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622490196
    },
    {
        "content": "<p>In Python the \"private\" methods start with underscores. Not really hidden just a prefix naming convention</p>",
        "id": 240865753,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1622490227
    },
    {
        "content": "<p>I would suggest leaving <code>#</code> to mean side-effecting commands though and use something else for the notation.</p>",
        "id": 240865819,
        "sender_full_name": "Mac",
        "timestamp": 1622490275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243102\">Brandon Brown</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240865753\">said</a>:</p>\n<blockquote>\n<p>In Python the \"private\" methods start with underscores. Not really hidden just a prefix naming convention</p>\n</blockquote>\n<p>Yeah I like the underscore / double underscore naming convention unfortunately that clashes with placeholders in Lean.</p>",
        "id": 240865872,
        "sender_full_name": "Mac",
        "timestamp": 1622490343
    },
    {
        "content": "<p>sounds at least worth an RFC, we can see what others think?</p>",
        "id": 240865878,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622490347
    },
    {
        "content": "<p>This would also have the possible side effect of fixing <a href=\"https://github.com/leanprover/lean4/issues/418\">#418</a>.</p>",
        "id": 240866123,
        "sender_full_name": "Mac",
        "timestamp": 1622490541
    },
    {
        "content": "<p>How about <code>obj.@private_method</code>  since the <code>@</code> symbol is already used to make the implicit explicit in functions, so sort of semantically in the same ballpark</p>",
        "id": 240866244,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1622490662
    },
    {
        "content": "<p>That's a good idea! The only qualm I have is that users may confuse it to mean explicit applying a function field.</p>",
        "id": 240866407,
        "sender_full_name": "Mac",
        "timestamp": 1622490815
    },
    {
        "content": "<p>not <code>@</code>, please. Because <code>private</code> still can have implicits.</p>",
        "id": 240866475,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622490868
    },
    {
        "content": "<p>ah right, of course</p>",
        "id": 240866506,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1622490915
    },
    {
        "content": "<p>I don't think anything like this is really needed, though. We already have a convention of using <code>fooAux</code> or <code>foo.impl</code> and such for internal function names, that is generally sufficient</p>",
        "id": 240866507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622490916
    },
    {
        "content": "<p>leading underscore is also used in some places, although lean takes a harder stance here since you can't actually use it in definition names</p>",
        "id": 240866577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622490965
    },
    {
        "content": "<p>But that would appear in auto-complete which we want to avoid by marking the definitions private.</p>",
        "id": 240866581,
        "sender_full_name": "Mac",
        "timestamp": 1622490972
    },
    {
        "content": "<p>you could have the effect of <code>private</code> or an equivalent attribute be to hide it from such displays, or the tooling could pick up on the naming convention</p>",
        "id": 240866625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491028
    },
    {
        "content": "<p>The goal is to make private definitions \"hidden\" in some sense (ex. from auto complete) while still providing a means to access them.</p>",
        "id": 240866633,
        "sender_full_name": "Mac",
        "timestamp": 1622491034
    },
    {
        "content": "<p><code>private</code> serves three encapsulation purposes in a normal programming language: Hiding stuff in the namespace, preventing corruption of state, and making it impossible to depend on internal details to lower coupling.</p>",
        "id": 240866736,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491112
    },
    {
        "content": "<p>we need all 3 to still be true after we weaken the restrictions imposed by <code>private</code>.</p>",
        "id": 240866760,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491146
    },
    {
        "content": "<p>State corruption we get for free due to being a pure language.</p>",
        "id": 240866772,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491159
    },
    {
        "content": "<p>the other two we have to solve somehow.</p>",
        "id": 240866780,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491168
    },
    {
        "content": "<p>In Lean, (2) isn't a concern (as you said), and (3) is just undesirable, because as <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  said proofs sometimes need to do just that.</p>",
        "id": 240866793,
        "sender_full_name": "Mac",
        "timestamp": 1622491187
    },
    {
        "content": "<p>so only real use is (1)</p>",
        "id": 240866948,
        "sender_full_name": "Mac",
        "timestamp": 1622491274
    },
    {
        "content": "<p>and since we need to violate that sometimes for the same reason as (3), even it should only hold conditionally.</p>",
        "id": 240866971,
        "sender_full_name": "Mac",
        "timestamp": 1622491312
    },
    {
        "content": "<p>yeah, I see how (3) is a potential concern. We <em>might</em> restrict accessing privates to proofs? It feels a bit weird. But on the other hand, if someone goes through enough effort to access <code>private</code>s, I wouldn't care too much to break them by refactoring. (E.g. in .net you can use reflection to access privates).</p>",
        "id": 240867032,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240866625\">said</a>:</p>\n<blockquote>\n<p>you could have the effect of <code>private</code> or an equivalent attribute be to hide it from such displays</p>\n</blockquote>\n<p>The disadvantage here is that it would then always hide it (which would be annoying in proofs that rely heavily on it). The <code>.#</code> or whatever syntax would allow for auto-completion in such contexts.</p>",
        "id": 240867063,
        "sender_full_name": "Mac",
        "timestamp": 1622491386
    },
    {
        "content": "<p><code>local attribute [-private] foobar</code> would fix that</p>",
        "id": 240867085,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622491413
    },
    {
        "content": "<blockquote>\n<p>But on the other hand, if someone goes through enough effort to access privates, I wouldn't care too much to break them by refactoring. (E.g. in .net you can use reflection to access privates).</p>\n</blockquote>\n<p>Exactly. <code>open private</code> isn't a code smell, it is explicitly opting out of stability of the upstream package. When you have dependent types, dependent packages can be a thing too</p>",
        "id": 240867161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491462
    },
    {
        "content": "<p>it doesn't need to be easy, but it does need to be possible</p>",
        "id": 240867182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491489
    },
    {
        "content": "<p><code>open private</code> is a bit like .net reflection to access <code>private</code>s.</p>",
        "id": 240867200,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491516
    },
    {
        "content": "<p>I think the \"private\" as an attribute seems reasonable. I would also probably rename it to \"hidden\" as that is more indicative of what is actually doing.</p>",
        "id": 240867201,
        "sender_full_name": "Mac",
        "timestamp": 1622491518
    },
    {
        "content": "<p>rust has <code>doc(hidden)</code></p>",
        "id": 240867224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491547
    },
    {
        "content": "<p>the experience for writing production code needs to be natural. You can easily have a large-ish development with only very light proving, e.g. lean4 compiler itself.</p>",
        "id": 240867279,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491566
    },
    {
        "content": "<p>And that kind of thing needs to be natural, so a keyword for private stuff seems warranted.</p>",
        "id": 240867296,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491586
    },
    {
        "content": "<p>seems reasonable</p>",
        "id": 240867361,
        "sender_full_name": "Mac",
        "timestamp": 1622491653
    },
    {
        "content": "<p>so... long story short... <code>open private</code> would pretty much cover all the requirements?</p>",
        "id": 240867373,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491666
    },
    {
        "content": "<p>I think avoiding <em>accidental</em> use of an unstable internal implementation detail is a good reason to have <code>private</code> as a language concept</p>",
        "id": 240867375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491668
    },
    {
        "content": "<p>so something like <code>open private</code> is probably the best UX to give it just enough syntax salt. The only thing I would change is that it shouldn't need to be <code>open private foo in bar</code>, which is currently needed due to the absolute hackery going on in the implementation</p>",
        "id": 240867494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240867373\">said</a>:</p>\n<blockquote>\n<p>so... long story short... <code>open private</code> would pretty much cover all the requirements?</p>\n</blockquote>\n<p>That and <code>export private</code> as well (for cases where an dependent package disagrees on visibility). It is also currently defined/used in mathlib</p>",
        "id": 240867506,
        "sender_full_name": "Mac",
        "timestamp": 1622491771
    },
    {
        "content": "<p>I have more misgivings about <code>export private</code>, because it's basically saying the upstream author was wrong about their decision</p>",
        "id": 240867590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491827
    },
    {
        "content": "<p>Which as the fallible humans we are, that can, in fact, sometimes be the case. ;)</p>",
        "id": 240867618,
        "sender_full_name": "Mac",
        "timestamp": 1622491863
    },
    {
        "content": "<p>plus you can always emulate it by <code>def foo := private.foo</code></p>",
        "id": 240867630,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622491879
    },
    {
        "content": "<p>I don't mind <code>open private</code> as an escape hatch, but I can almost guarantee that it will not become part of the stdlib, nor will the semantics of <code>private</code> change. On the positive side, that means the current <code>open private</code> code is <em>relatively</em> unlikely to break in the future.</p>",
        "id": 240867631,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1622491882
    },
    {
        "content": "<p>I would prefer if <code>private</code> just kept the name as is but made it an error to directly reference</p>",
        "id": 240867710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491949
    },
    {
        "content": "<p>rather than mangling the name and/or sticking some <code>_hyg</code>'s in there</p>",
        "id": 240867719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622491967
    },
    {
        "content": "<p>those names are way too hard to reference, even after you have paid the \"I know what I'm doing\" tax</p>",
        "id": 240867746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622492014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240867630\">said</a>:</p>\n<blockquote>\n<p>plus you can always emulate it by <code>def foo := private.foo</code></p>\n</blockquote>\n<p>Sadly, that is semantic different from an alias like that created by <code>export</code> in many cases.</p>",
        "id": 240867750,
        "sender_full_name": "Mac",
        "timestamp": 1622492019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240867710\">said</a>:</p>\n<blockquote>\n<p>I would prefer if <code>private</code> just kept the name as is but made it an error to directly reference</p>\n</blockquote>\n<p>That would preclude using the same name for <code>private</code>s in module diamonds, which would be super counterintuitive. We went through <em>multiple</em> designs before converging on the current one.</p>",
        "id": 240867818,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1622492073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240867746\">said</a>:</p>\n<blockquote>\n<p>those names are way too hard to reference, even after you have paid the \"I know what I'm doing\" tax</p>\n</blockquote>\n<p>So hard, in fact, that it creates issue <a href=\"https://github.com/leanprover/lean4/issues/418\">#418</a>.</p>",
        "id": 240867821,
        "sender_full_name": "Mac",
        "timestamp": 1622492078
    },
    {
        "content": "<p>Module diamonds?</p>",
        "id": 240867828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622492091
    },
    {
        "content": "<p><code>private foo</code> in two files you import</p>",
        "id": 240867867,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1622492131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Partitioning.20mathlib/near/240867494\">said</a>:</p>\n<blockquote>\n<p>so something like <code>open private</code> is probably the best UX to give it just enough syntax salt. The only thing I would change is that it shouldn't need to be <code>open private foo in bar</code>, which is currently needed due to the absolute hackery going on in the implementation</p>\n</blockquote>\n<p>You can also do <code>open private something from MyModule</code> now.  Not sure if that helps you.</p>",
        "id": 240867937,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1622492179
    },
    {
        "content": "<p>While we're on the topic, I've seen some issues with excessive privacy around <code>deriving instance DecidableEq</code> and other automatic constructions</p>",
        "id": 240868089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622492305
    },
    {
        "content": "<p><code>DecidableEq</code> might not be the best example here.  The type already contains everything you could prove about it.</p>",
        "id": 240868144,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1622492361
    },
    {
        "content": "<p>Actually it was <code>BEq</code>. I'll post the example in another thread</p>",
        "id": 240868978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622493127
    }
]
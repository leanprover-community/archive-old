[
    {
        "content": "<p>Sometimes it would be nice to compute and effectively cache a value that's derived from a structure's earlier fields. In the past I've broken up the structure like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S.def1</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"bp\">..</span>\n<span class=\"kd\">def</span> <span class=\"n\">S.def2</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"bp\">..</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">WellFormedS</span> <span class=\"kd\">extends</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span>\n  <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span>\n  <span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">toS.def1</span>\n  <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">toS.def2</span>\n</code></pre></div>\n<p>But this can be cumbersome if you have more than one stage you want to go through. Writing an alternate constructor that requires <code>c</code> and <code>d</code> to be defined properly is another way to do it, but you don't end up having the equalities on hand without some extra plumbing, and having <code>c : Option C</code>, where <code>def1</code> caches the value has sort of the same issue, and <code>def1</code> isn't visible to the structure definition, so you can't restrict the type of <code>C</code>.</p>\n<p>If anyone's worked with alternate solutions to this kind of thing and has thoughts on better/worse ways to go about this, I would appreciate your insights.</p>",
        "id": 273269215,
        "sender_full_name": "Chris B",
        "timestamp": 1645815079
    },
    {
        "content": "<p>I've been using this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Hashable</span> <span class=\"o\">(</span><span class=\"n\">Subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hash</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">hash</span> <span class=\"n\">x.1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Cached</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">b</span> <span class=\"bp\">//</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"o\">(</span><span class=\"n\">Cached</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable.isTrue</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Hashable</span> <span class=\"o\">(</span><span class=\"n\">Cached</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hash</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">Cached</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Repr.addAppParen</span> <span class=\"s2\">\"cached _\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">Cached</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">Cached</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x.1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cached</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Cached</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Cached</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">cached</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cached_val</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Cached</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">b.2</span>\n</code></pre></div>",
        "id": 273276596,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645818661
    },
    {
        "content": "<p>You can then just write <code>c := cached (... a ... b)</code>.</p>",
        "id": 273276625,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1645818686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  That's a good idea, thanks for your input. Is there a rule of thumb to determine when/whether a declaration like this will be kept alive/cached in a compiled Lean program?</p>",
        "id": 273310014,
        "sender_full_name": "Chris B",
        "timestamp": 1645841582
    },
    {
        "content": "<p>You need to manually pass the cached fields around, if you don't do that it will be recomputed.</p>",
        "id": 273489851,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1646055793
    },
    {
        "content": "<p>Ok, thank you.</p>",
        "id": 273503038,
        "sender_full_name": "Chris B",
        "timestamp": 1646061028
    }
]
[
    {
        "content": "<p>I was playing with the idea of \"finite pre-games\" in Lean, because I am writing a talk on Number for a conference next week. There's no reason not to try it in Lean 4. Notation is <em>amazing</em>. You define something and you instantly make notation for it and then you can use it immediately afterwards in everything (e.g. equation compiler). </p>\n<p>But the equation compiler and I are not getting on with <code>neg</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Conway-type games with the `List` monad. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">list_game</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">list_game</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">list_game</span> <span class=\"bp\">→</span> <span class=\"n\">list_game</span>\n\n<span class=\"c1\">-- notation for the constructor of `list_game`</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"{\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"∣\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"}\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"c1\">-- definition of the notation</span>\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">L</span> <span class=\"bp\">∣</span> <span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">list_game.mk</span> <span class=\"bp\">$</span><span class=\"n\">L</span> <span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list_game</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">list_game</span> <span class=\"bp\">→</span> <span class=\"n\">list_game</span>\n<span class=\"bp\">|</span> <span class=\"o\">{</span> <span class=\"n\">L</span> <span class=\"bp\">∣</span> <span class=\"n\">R</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">R.map</span> <span class=\"n\">neg</span> <span class=\"bp\">∣</span> <span class=\"n\">L.map</span> <span class=\"n\">neg</span><span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">fail to show termination for</span>\n<span class=\"cm\">  neg</span>\n<span class=\"cm\">with errors</span>\n<span class=\"cm\">structural recursion cannot be used</span>\n\n<span class=\"cm\">well founded recursion has not been implemented yet</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list_game</span>\n</code></pre></div>\n<p>I suspect I can make it directly with the recursor but I confess I haven't tried yet. I wondered whether the equation compiler could be persuaded or whether this is still a WIP or even not possible for some good reason</p>",
        "id": 239894027,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621711013
    },
    {
        "content": "<p>Doesn't lean3 notation work just as well for this example?</p>",
        "id": 239894356,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621711378
    },
    {
        "content": "<p>you can in fact be a bit naughty and use <code>notation</code> even in the definition itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">hygiene</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"s2\">\" ==&gt; \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">step</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"n\">tm</span> <span class=\"bp\">→</span> <span class=\"n\">tm</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ST_PlusConstConst</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n1</span> <span class=\"n\">n2</span><span class=\"o\">,</span>\n      <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">n1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">n2</span><span class=\"o\">)</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">n1</span> <span class=\"bp\">+</span> <span class=\"n\">n2</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ST_Plus1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t1</span> <span class=\"n\">t1'</span> <span class=\"n\">t2</span><span class=\"o\">,</span>\n      <span class=\"n\">t1</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">t1'</span> <span class=\"bp\">→</span>\n      <span class=\"n\">P</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">P</span> <span class=\"n\">t1'</span> <span class=\"n\">t2</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ST_Plus2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n1</span> <span class=\"n\">t2</span> <span class=\"n\">t2'</span><span class=\"o\">,</span>\n      <span class=\"n\">t2</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">t2'</span> <span class=\"bp\">→</span>\n      <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">n1</span><span class=\"o\">)</span> <span class=\"n\">t2</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">n1</span><span class=\"o\">)</span> <span class=\"n\">t2'</span>\n</code></pre></div>",
        "id": 239897358,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621714529
    },
    {
        "content": "<p>I think in lean 3 you'd need brackets around a notation constructor</p>",
        "id": 239909802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621728186
    },
    {
        "content": "<p>I'm a bit confused about which monads all this works for. I think <code>option</code> and <code>list</code> are fine for <code>neg</code>, and <code>set</code> you can't make the type because of <code>mk univ univ</code></p>",
        "id": 239909920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621728298
    },
    {
        "content": "<p>It works if you avoid the nested inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Game</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Game</span>\n<span class=\"bp\">|</span> <span class=\"n\">consL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span>\n<span class=\"bp\">|</span> <span class=\"n\">consR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Game.neg</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">consL</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consR</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">consR</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">consL</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 239922903,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1621744264
    },
    {
        "content": "<p>From memory this is identical behaviour to Lean3.</p>",
        "id": 239928702,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621751392
    },
    {
        "content": "<p>This is a different definition of Game, as far as I can see. Edit: Oh, I see!</p>",
        "id": 239940665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621765375
    },
    {
        "content": "<p>I made my recursor anyway, so I can continue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">useful_recursor</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">game</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"bp\">ᴸ</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"bp\">ᴿ</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">g.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">LL</span> <span class=\"n\">RR</span> <span class=\"o\">(</span><span class=\"n\">hL</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">LL</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hR</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">RR</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">IH</span> <span class=\"o\">{</span><span class=\"n\">LL</span> <span class=\"bp\">∣</span> <span class=\"n\">RR</span><span class=\"o\">}</span> <span class=\"n\">hL</span> <span class=\"n\">hR</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False.elim</span> <span class=\"bp\">$</span> <span class=\"n\">List.not_mem_nil</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">T</span> <span class=\"n\">hh</span> <span class=\"n\">hT</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"bp\">;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.mem_cons_iff</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span><span class=\"bp\">;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hdone</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">hg</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">hh</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">hT</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Classical.choose</span> <span class=\"n\">hdone</span> <span class=\"o\">}</span><span class=\"bp\">;</span>\n</code></pre></div>",
        "id": 239940880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621765602
    },
    {
        "content": "<p>Wait, this _is_ a different definition of <code>Game</code>, because <code>consL</code> and <code>consR</code> don't commute with this definition. However this is not really a game, because there are other much stronger definitions of \"equality\" that you want to put on this type, so perhaps it doesn't matter.</p>",
        "id": 239941095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621765847
    },
    {
        "content": "<p>Yes, you're going to be quotienting later anyway, so it's not mathematically important exactly which \"pregame\" you use. Using a list rather than an indexing type is a bit weird, however. :-)</p>",
        "id": 239942682,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621767581
    },
    {
        "content": "<p>I was just experimenting with this stuff, because you suggested a while ago that in my talk about numbers I could use Conway's numbers as an example, but I was trying to make the definition look conceptual whilst still giving me enough to get the naturals.</p>",
        "id": 239943607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621768558
    }
]
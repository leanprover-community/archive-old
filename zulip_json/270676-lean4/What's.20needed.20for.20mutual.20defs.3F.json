[
    {
        "content": "<p>Hi! Not sure how troublesome this is but we're trying to make <code>mutual</code> blocks with a somewhat minimal baggage. What else do we need to make this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">prelude</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Unit</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">unit</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hi</span> <span class=\"bp\">|</span> <span class=\"n\">bye</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">Bar.hi</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">PProd</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">mutual</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"c1\">-- tactic 'cases' failed, nested error:</span>\n  <span class=\"c1\">-- tactic 'cases' failed, not applicable to the given hypothesis</span>\n  <span class=\"c1\">-- _fun_discr✝ : MyNat</span>\n  <span class=\"c1\">-- motive : MyNat → Sort ?u.74</span>\n  <span class=\"c1\">-- h_1 : Unit → motive MyNat.zero</span>\n  <span class=\"c1\">-- h_2 : (n : MyNat) → motive (MyNat.succ n)</span>\n  <span class=\"c1\">-- ⊢ motive _fun_discr✝ after processing</span>\n  <span class=\"c1\">--   _</span>\n  <span class=\"c1\">-- the dependent pattern matcher can solve the following kinds of equations</span>\n  <span class=\"c1\">-- - &lt;var&gt; = &lt;term&gt; and &lt;term&gt; = &lt;var&gt;</span>\n  <span class=\"c1\">-- - &lt;term&gt; = &lt;term&gt; where the terms are definitionally equal</span>\n  <span class=\"c1\">-- - &lt;constructor&gt; = &lt;constructor&gt;, examples: List.cons x xs = List.cons y ys, and List.cons x xs = List.nil</span>\n  <span class=\"c1\">--     | .succ n =&gt; (g n).succ</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 286214112,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655300943
    },
    {
        "content": "<p>You should probably get comfortable with navigating the Lean source code if that's your goal. For example, starting at \"tactic 'cases' failed, not applicable to the given hypothesis\" you should soon find the next missing type.</p>",
        "id": 286214734,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655301241
    },
    {
        "content": "<p>Sorry, the error message is cryptic to me :/<br>\nI can't parse that there is a missing type, so I can't parse what the missing type is</p>",
        "id": 286216294,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655301900
    },
    {
        "content": "<p>BTW, when defining your own prelude, be aware of the issue <a href=\"https://github.com/leanprover/lean4/issues/188\">https://github.com/leanprover/lean4/issues/188</a></p>",
        "id": 286216337,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1655301917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286216294\">said</a>:</p>\n<blockquote>\n<p>Sorry, the error message is cryptic to me :/<br>\nI can't parse that there is a missing type, so I can't parse what the missing type is</p>\n</blockquote>\n<p>That's why I talked about navigating the codebase: if you grep for the message (preferable the second half, as the first half could be templated), you're already very close.</p>",
        "id": 286217162,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655302258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> Regarding <a href=\"https://github.com/leanprover/lean4/pull/188\">lean4#188</a>, I think lean should have something like rust's \"lang items\": when you declare <code>Nat</code> you would put a <code>@[lang]</code> (or <code>@[lang = \"Nat\"]</code>) attribute on it and this would use the given key / the declaration name to determine what to check about the definition</p>",
        "id": 286218336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655302748
    },
    {
        "content": "<p>This is also useful for documenting which types have extra special compiler magic on top of the usual</p>",
        "id": 286218451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655302803
    },
    {
        "content": "<p>(The <code>@[lang = \"Nat\"]</code> form would allow decoupling lang items from their names, so that for example you could declare it to have the name <code>nat</code> instead in a custom prelude. But this would require plumbing the name lookups everywhere instead of hardcoding names like <code> `Nat.add</code> around and personally I don't think it's worth it.)</p>",
        "id": 286219819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655303387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286217162\">said</a>:</p>\n<blockquote>\n<p>grep for the message</p>\n</blockquote>\n<p>Ah, now I understood the idea. Thanks!</p>",
        "id": 286220056,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655303490
    },
    {
        "content": "<p>So, apparently <a href=\"https://github.com/leanprover/lean4/blob/ce78c17f2d0602bcf8201181938a97a048e3bcf7/src/Lean/Meta/Tactic/Cases.lean#L147\">this match</a> is falling in the \"anything else\" case, which means that <code>casesOn</code> is not being found in the environment. However, I couldn't find a <code>casesOn</code> type that I could add to my prelude file <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 286258969,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655320034
    },
    {
        "content": "<p>I tried another approach: copy increasingly longer bits of <code>Prelude.lean</code> until it works.<br>\nApparently no more types are missing, but I don't have what's needed to allow Lean to prove terminations by itself. How does that work?</p>",
        "id": 286262320,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655321658
    },
    {
        "content": "<p>This is the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">prelude</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">id</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">Function.comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">Function.const</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">checkBinderAnnotations</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">inferInstance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">i</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">checkBinderAnnotations</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">bootstrap.inductiveCheckResultingUniverse</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">PUnit</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">PUnit</span>\n\n<span class=\"sd\">/-- An abbreviation for `PUnit.{0}`, its most common instantiation.</span>\n<span class=\"sd\">    This Type should be preferred over `PUnit` where possible to avoid</span>\n<span class=\"sd\">    unnecessary universe parameters. -/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Unit</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">PUnit</span>\n\n<span class=\"kd\">@[matchPattern]</span> <span class=\"n\">abbrev</span> <span class=\"n\">Unit.unit</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">PUnit.unit</span>\n\n<span class=\"sd\">/-- Auxiliary unsafe constant used by the Compiler when erasing proofs from code. -/</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">axiom</span> <span class=\"n\">lcProof</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"sd\">/-- Auxiliary unsafe constant used by the Compiler to mark unreachable code. -/</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">axiom</span> <span class=\"n\">lcUnreachable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">True</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"n\">True</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">False</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Empty</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">bootstrap.inductiveCheckResultingUniverse</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">PEmpty</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Not</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">@[macroInline]</span> <span class=\"kd\">def</span> <span class=\"n\">False.elim</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n  <span class=\"n\">False.rec</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[macroInline]</span> <span class=\"kd\">def</span> <span class=\"n\">absurd</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Not</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"n\">False.elim</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"n\">h₁</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"n\">abbrev</span> <span class=\"n\">Eq.ndrec.</span><span class=\"o\">{</span><span class=\"n\">u1</span><span class=\"o\">,</span> <span class=\"n\">u2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">motive</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[matchPattern]</span> <span class=\"kd\">def</span> <span class=\"n\">rfl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">id_eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Eq.subst</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Eq.ndrec</span> <span class=\"n\">h₂</span> <span class=\"n\">h₁</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Eq.symm</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Eq.trans</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h₂</span> <span class=\"bp\">▸</span> <span class=\"n\">h₁</span>\n\n<span class=\"kd\">@[macroInline]</span> <span class=\"kd\">def</span> <span class=\"n\">cast</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">congrArg</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">congr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">a₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h₁</span> <span class=\"bp\">▸</span> <span class=\"n\">h₂</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">congrFun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">init_quot</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">HEq</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">@[matchPattern]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">HEq.rfl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HEq.refl</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_of_heq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">HEq</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n    <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">HEq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">h₂</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n        <span class=\"n\">h₁</span>\n  <span class=\"n\">this</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">unbox</span><span class=\"o\">]</span> <span class=\"n\">Prod</span>\n\n<span class=\"sd\">/-- Similar to `Prod`, but `α` and `β` can be propositions.</span>\n<span class=\"sd\">   We use this Type internally to automatically generate the brecOn recursor. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">PProd</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">And</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">intro</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">PSum</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PSum</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PSum</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hi</span> <span class=\"bp\">|</span> <span class=\"n\">bye</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">Bar.hi</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kd\">mutual</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 286262371,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655321688
    },
    {
        "content": "<p>When I check your example with ordinary nats:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>And print what they elaborate to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f._mutual</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>There is this magical _mutual declaration which if you print it is quite huge and among other things requires WellFounded recursion and the corresponding instances for well founded relation etc.</p>\n<p>So I would imagine you need at least parts of <code>Init.WF</code> and maybe also <code>Init.WFTactics</code></p>",
        "id": 286262752,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655321893
    },
    {
        "content": "<p>(Which as you can see in doc-gen adds up to a whole lot of files because these already make use of quite a few imports)</p>",
        "id": 286262981,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655322051
    },
    {
        "content": "<p>Alright, thanks!!<br>\nI will try another route then <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 286263167,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655322155
    },
    {
        "content": "<p>I don't really think you can avoid well founded recursion here though, mutual just always seems to involve using well founded recursion to show termination so you won't be able to get around it. How much of it you need for your trivial examples is a completely different question though</p>",
        "id": 286263491,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655322331
    },
    {
        "content": "<p>Yeah turns out my plan to end up with a very small environment was slipping through my fingers</p>",
        "id": 286264000,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655322598
    },
    {
        "content": "<p>Why exactly are you doing this btw?</p>",
        "id": 286264096,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655322626
    },
    {
        "content": "<p>Long story short, we're trying to achieve some kind of \"translation\" of the Lean environment through metaprogramming. And I'm trying to test our method to translate mutual definitions</p>",
        "id": 286264354,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655322766
    },
    {
        "content": "<p>But if you were to just translate every declaration that is in a regular <code>Environment</code> right now things would just work out by themselves no? After all in a regular one all of this stuff is in place.</p>",
        "id": 286264519,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655322859
    },
    {
        "content": "<p>Yeah but the environment is HUGE, so I was looking for a small and controlled environment</p>",
        "id": 286264640,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655322925
    },
    {
        "content": "<p>It definitley is yes, but e.g. before I started to try and obtain all of the equational lemmata for doc-gen (which requires running additional meta code with tactics for every <code>def</code> because they are calculated dynamically) doc-gen did actually run through an environment with a fully loaded mathlib quite quickly, pretty printing and analyzing every declaration and even now it is in the minute span at most so processing large environments in short time definitley is possible.</p>",
        "id": 286265067,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655323135
    },
    {
        "content": "<p>ah it is not a timing concern i see.</p>",
        "id": 286265081,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655323142
    },
    {
        "content": "<p>In that case maybe you could use the regular environment and write some code that recursively figures out what declarations a certain other declaration depends on so you can make a list of things for your <code>mutual</code> example and only translate all the declarations that are required for it?</p>",
        "id": 286265597,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655323373
    },
    {
        "content": "<p>Yeah that's precisely what I'm trying right now</p>",
        "id": 286266174,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655323618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286264354\">said</a>:</p>\n<blockquote>\n<p>Long story short, we're trying to achieve some kind of \"translation\" of the Lean environment through metaprogramming. And I'm trying to test our method to translate mutual definitions</p>\n</blockquote>\n<p>A slightly longer version of the story is that we're trying to transform a <code>Lean.Environment</code> which is a map keyed on names, to a map keyed on cryptographic hashes of a name-irrelevant representation of the constants (vaguely similar to the hashing of <a href=\"https://www.unison-lang.org/\">https://www.unison-lang.org/</a>). This lets us content-address any constant in a way that bypasses the hierarchical namespace. So</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">id1</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">id2</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>which are identical except for names, would hash to the same anonymous constant.</p>\n<p>Anyway, to do this for <code>mutual</code> blocks is complicated (since you can't hash a cyclic reference graph in the same way you would an acyclic one), so we're trying to create some simple test cases to try our solution against</p>",
        "id": 286278230,
        "sender_full_name": "John Burnham",
        "timestamp": 1655329421
    },
    {
        "content": "<p>A this is a thing I've been wondering for a while: Why exactly is this desirable? :D</p>",
        "id": 286283317,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655332187
    },
    {
        "content": "<p>I get that it has a certain \"technical beauty\" appeal but i never understood why people actually want this.</p>",
        "id": 286283380,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655332209
    },
    {
        "content": "<p>Well, there are a lot of <em>potential</em> benefits to content addressing (like for build systems etc). But the concrete use-case our Yatima project (<a href=\"https://github.com/yatima-inc/yatima-lang/wiki\">https://github.com/yatima-inc/yatima-lang/wiki</a>) needs this for is that we're compiling Lean to the Lurk language for recursive zkSNARKs (<a href=\"https://github.com/lurk-lang\">https://github.com/lurk-lang</a>), so that we can have lightweight cryptographic certificates that <code>myProof : myTheorem</code> validly checks (which can be verified in constant time without re-running a kernel)</p>\n<p>Having nameless content-addressing allows us to compose any such certificate of <code>proof1 : Theorem1</code> with any other certificate of<code>proof2 : Theorem2</code> irrespective of their use of the hierarchical namespace (like if they rely on two different constants both with the same name). This greatly improves certificate generation performance</p>",
        "id": 286286464,
        "sender_full_name": "John Burnham",
        "timestamp": 1655334220
    },
    {
        "content": "<p>I know there have been threads around Unison-style content-addressing for Lean (or <code>lake</code>) here in the past, and totally open to generalizing Yatima's content-addressing schema if that's of interest. But we're implementing this for a very domain-specific reason, which may have different  constraints.</p>\n<p>One thing though is that our content-addressing uses <a href=\"https://ipld.io/\">https://ipld.io/</a>, which will let you composably share Lean constants and environments over  IPFS (<a href=\"https://ipfs.io/\">https://ipfs.io/</a>), which is kinda neat</p>",
        "id": 286286819,
        "sender_full_name": "John Burnham",
        "timestamp": 1655334502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/What's.20needed.20for.20mutual.20defs.3F/near/286283317\">said</a>:</p>\n<blockquote>\n<p>A this is a thing I've been wondering for a while: Why exactly is this desirable? :D</p>\n</blockquote>\n<p>Outside of a concrete use cases like John mentioned there are two other notable general advantages:  it eliminates code bloat caused by cross-package code duplication and it allows for easy, transparent aliasing of definitions (ie.g., <code>nat</code>, <code>Nat</code>, <code>natural</code>, <code>Natural</code> can all resolve to the same thing). The later feature is general to any language that decouples names from unit identifiers .</p>",
        "id": 286316652,
        "sender_full_name": "Mac",
        "timestamp": 1655365018
    }
]
[
    {
        "content": "<p>Currently, the first example typechecks while the second does not.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">True</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>This is because <code>Sort (imax 1 u)</code> is currently not being reduced to <code>Sort u</code>, despite them being equivalent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">Nat.imax</span> <span class=\"mi\">1</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I modified <code>src/Lean/Level.lean</code> and <code>src/kernel/level.cpp</code> to perform this simplification, basing it off of the initial code that simplifies <code>imax 0 u</code> to <code>u</code>. The result successfully handles both examples, as well as a more complicated situation where I first ran into this issue. Is there a reason this simplification is not already implemented? Does adding this cause breakage elsewhere?</p>",
        "id": 304368427,
        "sender_full_name": "Parth Shastri",
        "timestamp": 1665972252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"497571\">Parth Shastri</span> <a href=\"#narrow/stream/270676-lean4/topic/Simplification.20of.20imax.201.20u/near/304368427\">said</a>:</p>\n<blockquote>\n<p>Currently, the first example typechecks while the second does not.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">True</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>This is because <code>Sort (imax 1 u)</code> is currently not being reduced to <code>Sort u</code>, despite them being equivalent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">Nat.imax</span> <span class=\"mi\">1</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I modified <code>src/Lean/Level.lean</code> and <code>src/kernel/level.cpp</code> to perform this simplification, basing it off of the initial code that simplifies <code>imax 0 u</code> to <code>u</code>. The result successfully handles both examples, as well as a more complicated situation where I first ran into this issue. Is there a reason this simplification is not already implemented? Does adding this cause breakage elsewhere?</p>\n</blockquote>\n<p>Isn't the simplification false when <code>u</code> is <code>Prop</code>?</p>",
        "id": 304372824,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1665976645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span>, in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil4</a> they say:</p>\n<blockquote>\n<p><code>imax i j</code> is the maximum of <code>i</code> and <code>j</code> if <code>j</code> is not <code>0</code>, and <code>0</code> otherwise.</p>\n</blockquote>\n<p>So <code>imax 1 0 = 0</code>.</p>\n<p>Also, Lean's implementation of <code>Nat.imax</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.imax</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">Nat.max</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n</code></pre></div>",
        "id": 304381818,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1665984158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/stream/270676-lean4/topic/Simplification.20of.20imax.201.20u/near/304381818\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span>, in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil4</a> they say:</p>\n<blockquote>\n<p><code>imax i j</code> is the maximum of <code>i</code> and <code>j</code> if <code>j</code> is not <code>0</code>, and <code>0</code> otherwise.</p>\n</blockquote>\n<p>So <code>imax 1 0 = 0</code>.</p>\n<p>Also, Lean's implementation of <code>Nat.imax</code> is:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.imax</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">Nat.max</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks.</p>",
        "id": 304383568,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1665985254
    },
    {
        "content": "<p>Note that <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> validates the use of this rule, since it uses a more elaborate decision procedure that is complete for level arithmetic. AFAIK Lean's simplification-based universe checker is necessarily incomplete, so there will always be examples like this. The \"correct\" solution is to do case splitting on <code>imax</code> subexpressions, but this can have poor performance in some edge cases (which wouldn't check at all in lean's implementation). This is what the <code>trepplein</code> external typechecker implements</p>",
        "id": 304383998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1665985487
    }
]
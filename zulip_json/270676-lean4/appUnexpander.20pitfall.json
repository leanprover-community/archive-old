[
    {
        "content": "<p>When I declare an <code>appUnexpander</code> involving an identifier that is not in the root namespace,<br>\nand then I change the namespace, the unexpander is not applied anymore.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Test</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Special</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"kd\">def</span> <span class=\"n\">special</span> <span class=\"o\">:</span> <span class=\"n\">Special</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[appUnexpander Test.Special]</span> <span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">unexpander</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Special</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"c1\">-- The unexpander is applied.</span>\n<span class=\"c1\">-- `special : Nat`</span>\n<span class=\"k\">#check</span> <span class=\"n\">special</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Test</span>\n\n<span class=\"c1\">-- The unexpander is not applied.</span>\n<span class=\"c1\">-- Test.special : Test.Special Nat</span>\n<span class=\"k\">#check</span> <span class=\"n\">Test.special</span>\n\n<span class=\"c1\">-- Workaround: don't match against the identifier</span>\n<span class=\"kd\">@[appUnexpander Test.Special]</span> <span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">unexpander</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_Special</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>I think this is because the quotation matching inside my unexpander definition is failing.<br>\nI could work around this issue by not matching against the identifier like the workaround above,<br>\nbut I think this is confusing for users.<br>\nCould this situation be improved somehow?</p>",
        "id": 232932724,
        "sender_full_name": "pcpthm",
        "timestamp": 1617387013
    },
    {
        "content": "<p>I'm afraid not. A purely syntactic match can only compare identifiers syntactically, or not at all. There is no magic bullet.</p>",
        "id": 233331152,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1617720534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/appUnexpander.20pitfall/near/233331152\">said</a>:</p>\n<blockquote>\n<p>I'm afraid not. A purely syntactic match can only compare identifiers syntactically, or not at all. There is no magic bullet.</p>\n</blockquote>\n<p>Why not fully qualify names before running unexpanders? That way unexpanders could always target the fully qualified names to work. To make name output still pretty, you could then unqualify the names (as possible) after running the unexpanders.</p>",
        "id": 235882391,
        "sender_full_name": "Mac",
        "timestamp": 1619200439
    }
]
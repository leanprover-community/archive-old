[
    {
        "content": "<p>Hi everyone,<br>\nSo I have been working on creating Lean4 source files for Mathlib from the tlean files. For now, <code>sorry</code> is used everywhere, but apart from that the results are getting decent.<br>\nWhat I have worked on is mainly:</p>\n<ul>\n<li>detecting autogenerated definitions</li>\n<li>prettyprinting classes, structures, inductive types, instances and notations</li>\n<li>moving a reasonable amount of arguments before the colon in definitions and theorems</li>\n<li>parsing the namespace structure and comments of the Lean3 source files</li>\n</ul>\n<p>There are still a handful of problems, some of the most frequent being:</p>\n<ul>\n<li>prettyprinted expressions that do not compile because of missing type annotations or implicit arguments that cannot be synthesized, </li>\n<li>class/structure extensions not handled</li>\n</ul>\n<p>Here is for instance the result I get on algebra/add_torsor: <a href=\"https://gist.github.com/AurelienSaue/4d9e54100bb231a1196c881dfcb63454\">https://gist.github.com/AurelienSaue/4d9e54100bb231a1196c881dfcb63454</a><br>\nWhat do you think of the approach?</p>",
        "id": 238283727,
        "sender_full_name": "Aurélien Saue",
        "timestamp": 1620728754
    },
    {
        "content": "<p>Just glancing through that file, it looks marvellous!</p>",
        "id": 238286967,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620730559
    },
    {
        "content": "<p>About the <code>sorry</code>d proofs: do you have plans to also auto-port those later on?</p>",
        "id": 238287063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620730591
    },
    {
        "content": "<p>Yes that would of course be great  but the main problem for now is that a lot of them are referencing autogenerated definitions (<code>._main</code>, <code>._proof_1</code>, ...) which are eliminated</p>",
        "id": 238287296,
        "sender_full_name": "Aurélien Saue",
        "timestamp": 1620730741
    },
    {
        "content": "<p>Seeing progress on this is wonderful! Do you think you could do anything to hide of these universe variables? I guess the original file has <code>Type*</code> everywhere and not a single explicit <code>max</code> or universes.</p>",
        "id": 238288860,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620731519
    },
    {
        "content": "<p>Something very easy to fix would be to remove those empty lines between docstrings and declarations.</p>",
        "id": 238288946,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620731546
    },
    {
        "content": "<p>Yes sure I will try, that should not be too hard</p>",
        "id": 238289220,
        "sender_full_name": "Aurélien Saue",
        "timestamp": 1620731690
    },
    {
        "content": "<p>Just checking, but the <code>[(i : I) → add_group (fg i)]</code> (in <code>add_torsor</code>) is not valid Lean 4, right? Functions can't be classes?</p>",
        "id": 238354326,
        "sender_full_name": "Mac",
        "timestamp": 1620755404
    },
    {
        "content": "<p>I think it's valid.</p>",
        "id": 238354422,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620755442
    },
    {
        "content": "<p>It's valid in lean 3</p>",
        "id": 238354425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620755443
    },
    {
        "content": "<p>lean will just do typeclass search in the extended context</p>",
        "id": 238354514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620755478
    },
    {
        "content": "<p>the requirement is only that it be a pi type ending in a class</p>",
        "id": 238354555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620755497
    },
    {
        "content": "<p>interesting! I learn something new about Lean every day :)</p>",
        "id": 238355363,
        "sender_full_name": "Mac",
        "timestamp": 1620755829
    },
    {
        "content": "<p>FYI there has been some off-channel discussion of an alternative approach to porting that avoids the <code>.tlean</code>s and tries to port syntax directly. Specifically, this would entail:</p>\n<ul>\n<li>writing a complete lean3/mathlib parser in lean4 (without elaboration)</li>\n<li>writing syntax transformers to convert the parsed syntax to lean4 syntax (e.g. <code>fun _, _</code> -&gt; <code>fun _ =&gt; _</code>)</li>\n<li>improving the formatter (not the delaborator) so the generated lean4 files are (mostly) aesthetic</li>\n<li>dealing with the gillion squiggly lines this will produce (e.g. from missing or modified tactics, elaborator changes, etc)<ul>\n<li>possibly by implementing missing tactics</li>\n<li>possibly by updating syntax transformers </li>\n<li>possibly by running bulk automation (e.g. a \"squeezing\" tree-search tactic)</li>\n<li>probably largely by hand</li>\n</ul>\n</li>\n</ul>",
        "id": 238810908,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621017433
    },
    {
        "content": "<blockquote>\n<p>writing a complete lean3/mathlib parser in lean4 (without elaboration)</p>\n</blockquote>\n<p>I want to add that an alternative to this is to modify lean 3 to produce AST export data, kind of like tlean but focused on the input syntax, and then parsing that export data in lean 4</p>",
        "id": 238811238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621017601
    },
    {
        "content": "<p>I believe <span class=\"user-mention\" data-user-id=\"399706\">@Aurélien Saue</span>'s tool is also parsing the Lean 3 source file to extract comments, etc. (in addition to the mathported olean file).  <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files/near/238283727\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files/near/238283727</a></p>",
        "id": 238811966,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621017965
    },
    {
        "content": "<p>Sorry for seeing this so late.<br>\nThis seems like a very good idea to me since all the issues I face currently are due to delaboration. <br>\nHas anyone started this process yet?</p>",
        "id": 239051407,
        "sender_full_name": "Aurélien Saue",
        "timestamp": 1621240238
    },
    {
        "content": "<p>I just quickly scraped together a scaffold: <a href=\"https://github.com/dselsam/synport\">https://github.com/dselsam/synport</a></p>",
        "id": 239530403,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621482796
    },
    {
        "content": "<p>this is for the \"complete lean3/mathlib parser in lean4\" plan, right?</p>",
        "id": 239530490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621482895
    },
    {
        "content": "<ul>\n<li><code>synport.py</code>: takes a lean3 file and prints the lean4 file to stdout</li>\n<li>it does this by prepending <code>import SynPort; #lean3</code> to the file and calling lean4 on the resulting file</li>\n<li>the lean4 elaboration of the <code>#lean3</code> command will do the rest</li>\n<li>there is almost no syntax/transformers there yet, but enough to see the pattern</li>\n</ul>",
        "id": 239530533,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621482951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files/near/239530490\">said</a>:</p>\n<blockquote>\n<p>this is for the \"complete lean3/mathlib parser in lean4\" plan, right?</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 239530536,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621482959
    },
    {
        "content": "<p>I'm not sure that a fully faithful lean 3 parser can be written in the lean 4 parser infrastructure. In particular lean 3 parsers can do IO and access the tactic state</p>",
        "id": 239530576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621482971
    },
    {
        "content": "<p>What do you think this means for SynPort in practice? How many things will be unparseable? Can you backport a sanity-restriction to prevent this behavior?</p>",
        "id": 239530740,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621483158
    },
    {
        "content": "<p>Not clear. I have long held the belief that lean 3 parsing for anything other than lean 3 is nigh impossible, and I have had very little success in approximating it from the outside. Plus the lean 3 grammar is pretty complicated even assuming the edge cases are somehow dealt with, and portions of the grammar (tactic parsers) are written in lean and it's not clear how to get at that without adding a lean 3 interpreter to the mix</p>",
        "id": 239531131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621483454
    },
    {
        "content": "<p>My guess is that we can find a way to syn-port the parts that syn-port and skip the edge cases, and that it will work well for a big chunk of the library</p>",
        "id": 239531216,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621483559
    },
    {
        "content": "<p>In my manual porting experiments on top of mathport, so much of the work was just changing lambda/match syntax + friends</p>",
        "id": 239531270,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621483581
    },
    {
        "content": "<p>One way to get something close without too much work is to copy and paste the lean 4 grammar and see if it works on lean 4 files</p>",
        "id": 239531385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621483684
    },
    {
        "content": "<p>did you mean for those both to be 4s?</p>",
        "id": 239531471,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621483767
    },
    {
        "content": "<p>yes</p>",
        "id": 239531480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621483776
    },
    {
        "content": "<p>lean 4 already has its own grammar written using lean 4 notations, so if you use that as a base for modification you can get a rough lean 3 parser easier than if you wrote one from scratch</p>",
        "id": 239531601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621483849
    },
    {
        "content": "<p>That I definitely agree with. I was assuming we would effectively copy-paste.</p>",
        "id": 239531642,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621483898
    },
    {
        "content": "<p>Note: I tried just adding new Lean4 syntax for the lean3 fun and match, and it seemed to work well also. So we could even try reusing Lean4's <code>term</code> category, but it seems like it could cause problems downstream</p>",
        "id": 239531743,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621483958
    },
    {
        "content": "<p>No we want <code>term3</code> because we are going to reflect on tactic proofs</p>",
        "id": 239531947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621484162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files/near/239531947\">said</a>:</p>\n<blockquote>\n<p>No we want <code>term3</code> because we are going to reflect on tactic proofs</p>\n</blockquote>\n<p>What exactly does that mean?</p>",
        "id": 239546055,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621495544
    },
    {
        "content": "<p>We want to be able to transform the lean 3 tactic AST into equivalent lean 4 tactic structures. It's not clear that this can be done if we just directly produce lean 4 exprs because when they get elaborated we lose the tactics. But I might just be confused about lean 4 macro expansion</p>",
        "id": 239549012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621496869
    },
    {
        "content": "<p>Ah no, I don't think the plan is to expand <em>all</em> macros in order to move from Lean 3 to Lean 4 syntax, if that is what you were referring to. Instead we would selectively expand macros from <code>SynPort</code> only.</p>",
        "id": 239549417,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621497043
    },
    {
        "content": "<p>I.e. if there is a mathlib3 tactic that we want to map to an existing/different Lean 4 syntax, we would describe it as a macro and expand away, but no further.</p>",
        "id": 239549681,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621497178
    },
    {
        "content": "<p>right, I don't really know how macro expansion is controlled like that</p>",
        "id": 239549816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621497249
    },
    {
        "content": "<p>What about type-aware expansion? For example we might want to select a lean 4 tactic based on what actually works on the given goal</p>",
        "id": 239549907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621497316
    },
    {
        "content": "<p>Hah, alright, that would be the next difficulty level. We could possibly retrieve that information from the <code>InfoTree</code>, which is the data structure used to transfer infromation from the elaborator to the server.</p>",
        "id": 239550412,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621497610
    },
    {
        "content": "<p>Currently the info tree only holds macro expansion steps, not elaboration steps, but we will likely need to change that anyway if we want to implement \"go to macro/elaborator\" on arbitrary syntax.</p>",
        "id": 239550595,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621497706
    },
    {
        "content": "<p>I was thinking we could parse the whole file into some <code>command3</code> syntax object, then write an elaborator that uses the syntax object as instructions to construct a lean 4 syntax and simultaneously elaborate it to inform the construction</p>",
        "id": 239550714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621497777
    },
    {
        "content": "<p>So you basically want to reimplement (an extended version of) the Lean 3 elaborator in Lean 4? I would have hoped we could avoid that.</p>",
        "id": 239550882,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621497853
    },
    {
        "content": "<p>Not really, it is the lean 4 elaborator which is informing the construction</p>",
        "id": 239550918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621497881
    },
    {
        "content": "<p>Okay, I'm not completely sure how you will coerce/extend the Lean 4 elaborator into constructing a new syntax tree on the side</p>",
        "id": 239550986,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621497928
    },
    {
        "content": "<p>But also we should evaluate how often we actually think that will happen and if it is worthwhile to automate it away, or if it makes sense to offload it to the manual porting steps that will need to happen anyway. Same with Lean 3 parsing using I/O, how often does that happen?</p>",
        "id": 239551031,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621497960
    },
    {
        "content": "<p>True, there is an obvious fallback if this doesn't work or isn't useful enough. I figure that given the size of mathlib it's worth investing in anything we can do to improve the success rate</p>",
        "id": 239551150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621498023
    },
    {
        "content": "<p>I agree. The <code>InfoTree</code> would be my best bet for doing that so far.</p>",
        "id": 239551387,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621498149
    },
    {
        "content": "<p>To give an example of what I mean, suppose there is a lean 3 tactic <code>foo</code> that lean 4 writes as <code>bar</code> on goals of the form <code>|- bar</code> and <code>foo</code> otherwise. So we parse <code>foo : tactic3</code>, and then we have a program with type <code>Syntax -&gt; Option Expr -&gt; TermElabM Syntax</code> which does:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"n\">tactic3</span><span class=\"o\">)</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bar</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">bar</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">foo</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 239551699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621498331
    },
    {
        "content": "<p>in general, it would go through the motions of actually running said lean 4 tactic, in addition to constructing the syntax for the tactic</p>",
        "id": 239551822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621498418
    },
    {
        "content": "<p>If you use <a href=\"https://github.com/leanprover/lean4/blob/cd5dbc66ce2fd6bf1d38e40599a279df8c01a9ce/src/Lean/Elab/Term.lean#L1167-L1169\"><code>adaptExpander</code></a>, this will actually log the transformation in the info tree today.</p>",
        "id": 239551902,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621498445
    },
    {
        "content": "<p>(tactic version: <a href=\"https://github.com/leanprover/lean4/blob/cd5dbc66ce2fd6bf1d38e40599a279df8c01a9ce/src/Lean/Elab/Tactic/Basic.lean#L258-L260\">https://github.com/leanprover/lean4/blob/cd5dbc66ce2fd6bf1d38e40599a279df8c01a9ce/src/Lean/Elab/Tactic/Basic.lean#L258-L260</a>)</p>",
        "id": 239552022,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621498507
    },
    {
        "content": "<p>This would still not be perfect since it doesn't know lean 3's opinion about how it is supposed to elaborate, which is often more important than lean 4's reconstruction. That could be addressed by augmenting the lean 3 AST dump with type information about the goal state after each tactic or at each application. I think that the highest fidelity version would be if lean 3 elaborated everything into an AST dump and lean 4 parsed that instead of trying to parse lean 3 directly. That way lean 4 would have access both to the lean 3 type information and the lean 4 type information and could fill in motives and repair gaps.</p>",
        "id": 239552598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621498873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files/near/239549417\">said</a>:</p>\n<blockquote>\n<p>Ah no, I don't think the plan is to expand <em>all</em> macros in order to move from Lean 3 to Lean 4 syntax, if that is what you were referring to. Instead we would selectively expand macros from <code>SynPort</code> only.</p>\n</blockquote>\n<p>Right -- the current scaffold doesn't even use macros, it is literally a function <code>Syntax -&gt; &lt;some monad&gt; Syntax</code> that we have complete control over.</p>",
        "id": 239595887,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621519218
    },
    {
        "content": "<p>It then calls the formatter on the new syntax and that is it.</p>",
        "id": 239596006,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621519252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204.20source.20files/near/239549907\">said</a>:</p>\n<blockquote>\n<p>What about type-aware expansion? For example we might want to select a lean 4 tactic based on what actually works on the given goal</p>\n</blockquote>\n<p>This could be a second pass -- i.e. read the new lean4 files and for each squiggly in a proof, try running proof search and if it works, replace what is there with the new proof.</p>",
        "id": 239596789,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621519478
    },
    {
        "content": "<p>^ I wouldn't even want to try this right away, not until manually inspecting a bunch of the squigglies to see if they are caused by important issues/bugs</p>",
        "id": 239597937,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1621519907
    },
    {
        "content": "<p>(deleted, posted in the wrong thread!)</p>",
        "id": 239680298,
        "sender_full_name": "Mac",
        "timestamp": 1621557508
    }
]
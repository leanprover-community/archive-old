[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Path</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- error:</span>\n<span class=\"c1\">-- code generator does not support recursor 'Path.rec' yet,</span>\n<span class=\"c1\">-- consider using 'match ... with' and/or structural recursion</span>\n<span class=\"kd\">def</span> <span class=\"n\">Path.symm</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">α</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Path.refl</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Why?</p>",
        "id": 258997339,
        "sender_full_name": "Uranus Testing",
        "timestamp": 1635185024
    },
    {
        "content": "<p>As the error message suggests, this has not been implemented. <br>\nThe compiler only has support for <code>casesOn</code> recursor.<br>\nNote that the following works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Path</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Path.symm</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">α</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Path.refl</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The <code>casesOn</code> recursor is equivalent to the <code>rec</code> one for nonrecursive types.<br>\nFor recursive types, we strongly encourage users to write recursive definitions. It is easier to write, and the generated code is more efficient.</p>",
        "id": 259000104,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1635186250
    },
    {
        "content": "<p>Types of <code>Path.rec</code> and <code>Path.casesOn</code> are very similar:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">Path.rec</span>\n<span class=\"c1\">-- {α : Type u_2} →</span>\n<span class=\"c1\">--  {motive : (a a_1 : α) → Path α a a_1 → Sort u_1} →</span>\n<span class=\"c1\">--    ({a : α} → motive a a Path.refl) → {a a_1 : α} → (t : Path α a a_1) → motive a a_1 t</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Path.casesOn</span>\n<span class=\"c1\">-- {α : Type u_2} →</span>\n<span class=\"c1\">--   {motive : (a a_1 : α) → Path α a a_1 → Sort u_1} →</span>\n<span class=\"c1\">--     {a a_1 : α} → (t : Path α a a_1) → ({a : α} → motive a a Path.refl) → motive a a_1 t</span>\n</code></pre></div>\n<p>So what’s the difference?</p>",
        "id": 259001779,
        "sender_full_name": "Uranus Testing",
        "timestamp": 1635187048
    },
    {
        "content": "<p>Ah, missed the part about “The casesOn recursor is equivalent to the rec one for nonrecursive types.”</p>",
        "id": 259002506,
        "sender_full_name": "Uranus Testing",
        "timestamp": 1635187349
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>  </p>\n<p>Mario, I'm not sure I can give a minimum <em>working</em> example, because I can't get it to work <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<p>However, I've tried to separate the data from the constaint checking. For the data I've used a structure with a generic type variable, and then I use a recursive function to figure out the correct nested type.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">MorphData</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">Name</span>\n  <span class=\"n\">input</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">output</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MorphDataT</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MorphData</span> <span class=\"mi\">0</span> <span class=\"o\">{</span><span class=\"bp\">⋆</span><span class=\"o\">}</span>\n <span class=\"bp\">|</span> <span class=\"n\">nonZero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MorphData</span> <span class=\"n\">nonZero</span>  <span class=\"o\">(</span><span class=\"n\">MorphDataT</span> <span class=\"o\">(</span><span class=\"n\">nonZero</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>It's obvious to me that this recursion terminates, but I get an error, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fail</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">termination</span> <span class=\"n\">for</span>\n  <span class=\"n\">MorphDataT</span>\n<span class=\"k\">with</span> <span class=\"n\">errors</span>\n<span class=\"n\">argument</span> <span class=\"bp\">#</span><span class=\"mi\">1</span> <span class=\"n\">was</span> <span class=\"n\">not</span> <span class=\"n\">used</span> <span class=\"n\">for</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n  <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">eliminate</span> <span class=\"n\">recursive</span> <span class=\"n\">application</span>\n    <span class=\"n\">MorphDataT</span> <span class=\"o\">(</span><span class=\"n\">nonZero</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, I don't know what to put in the termination_by clause. I searched for examples, but the obvious things don't work. I need to say that  d will keep getting smaller until it terminates upon reaching zero,</p>\n<p>A good general learning point for me would be this. Is there a way to print the proposition that needs to be proven to prove recursion for a function that is not itself a theorem?</p>",
        "id": 298414892,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1662999420
    },
    {
        "content": "<p>The easiest way to fix this particular error is to use <code>n + 1</code> instead of <code>n</code> in the nonzero case</p>",
        "id": 298415401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662999606
    },
    {
        "content": "<p>If I understand your construction correctly, this should do what you want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">RawMorph</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pair</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">RawMorph.isGlobular</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph.isGlobular</span> <span class=\"bp\">.</span><span class=\"n\">unit</span>\n  <span class=\"bp\">|</span> <span class=\"n\">self</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">i.isGlobular</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">i.pair</span> <span class=\"n\">nm</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isGlobular</span>\n  <span class=\"bp\">|</span> <span class=\"n\">parallel</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">i.pair</span> <span class=\"n\">nm₁</span> <span class=\"n\">o</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isGlobular</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">i.pair</span> <span class=\"n\">nm₃</span> <span class=\"n\">o</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isGlobular</span> <span class=\"bp\">→</span>\n    <span class=\"o\">((</span><span class=\"n\">i.pair</span> <span class=\"n\">nm₁</span> <span class=\"n\">o</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pair</span> <span class=\"n\">nm₂</span> <span class=\"o\">(</span><span class=\"n\">i.pair</span> <span class=\"n\">nm₃</span> <span class=\"n\">o</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">isGlobular</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Morph</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">RawMorph</span> <span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"n\">m.isGlobular</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 298419423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663000901
    },
    {
        "content": "<p>Thanks for the code example. I don't entirely understand it, but I'll try to figure it out. </p>\n<p>My own version is progressing. With the recursive morphism data structure type I can eliminate the mutual recursion between Constraint and MorphSym. Since they both depend only on MorphData.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">MorphData</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">Name</span>\n  <span class=\"n\">input</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">output</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MorphDataT</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MorphData</span> <span class=\"mi\">0</span> <span class=\"o\">{</span><span class=\"bp\">⋆</span><span class=\"o\">}</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MorphData</span> <span class=\"n\">d</span>  <span class=\"o\">(</span><span class=\"n\">MorphDataT</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Constraint</span> <span class=\"o\">:</span>  <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"bp\">|</span> <span class=\"n\">globular</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">input</span><span class=\"o\">:</span> <span class=\"n\">MorphDataT</span> <span class=\"n\">d</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">output</span><span class=\"o\">:</span> <span class=\"n\">MorphDataT</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:(</span><span class=\"n\">input</span> <span class=\"bp\">=</span> <span class=\"n\">output</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">input.input</span> <span class=\"bp\">=</span> <span class=\"n\">output.input</span> <span class=\"bp\">∧</span> <span class=\"n\">input.output</span> <span class=\"bp\">=</span> <span class=\"n\">output.output</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Constraint</span>\n</code></pre></div>\n<p>However, now I get the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">input</span> <span class=\"o\">:</span> <span class=\"n\">MorphDataT</span> <span class=\"n\">d</span>\n<span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"bp\">'</span><span class=\"n\">input'</span><span class=\"o\">,</span> <span class=\"n\">the</span> <span class=\"n\">environment</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">contain</span> <span class=\"bp\">'</span><span class=\"n\">MorphDataT.input'</span>\n  <span class=\"n\">input</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">MorphDataT</span> <span class=\"n\">dLean</span>\n</code></pre></div>\n<p>I'm guessing this is because the type checker doesn't resolve <code>MorphDataT d</code> to the type it returns. Is there some flag I should add to MorphDataT to tell the compiler to replace it with the actual type it returns?</p>",
        "id": 298424073,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1663002307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Thanks again. I managed to adapt and build on the code sample you posted above. I  think I see how to do what I wanted to do now. If I understand correctly, the basic strategy is have a \"raw\" type that gives you all the values with their basic shape but without propositional constraints on which ones can be formed. Then use subtyping to form the actual set of relevant values. Is this a common pattern?</p>\n<p>I was also curious to know what the difference is between using a Sigma type and using the { _ // _  } notation. At first I assumed the { _ // _ }  notation must be syntactic sugar for a Sigma type, but it seems to produce something different.</p>",
        "id": 298626845,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1663088015
    },
    {
        "content": "<p>The difference between <code>Sigma</code> and <code>Subtype</code> is that one takes <code>A : Type</code> and <code>B : A -&gt; Type</code> and the other takes <code>A : Type</code> and <code>p : A -&gt; Prop</code></p>",
        "id": 298636524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663091458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346046\">@Avi Craimer</span> See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sigma\">docs#sigma</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype\">docs#subtype</a> (Lean 3 but I doubt it is different in Lean 4).</p>",
        "id": 298636593,
        "sender_full_name": "Jason Rute",
        "timestamp": 1663091486
    },
    {
        "content": "<p>Alright, I understand now. If I want to filter our certain elements with a proposition use Subtype, if I  want a dependent product where the second value can be more than a singleton use Sigma.</p>",
        "id": 298665712,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1663102417
    }
]
[
    {
        "content": "<p>What is the right way to simplify/rewrite using typeclass definitions? In <code>Fin.val_zero</code>, I want to simplify <code>(@OfNat.ofNat (Fin (Nat.succ n)) 0 (@Fin.instOfNatFinHAdd n 0))</code> to the definition of <code>Fin.instOfNatFinHAdd.ofNat</code>, which is <code>Fin.ofNat 0</code>. If I go directly with <code>simp only [OfNat.ofNat]</code>, I get a maximum recursion error. </p>\n<p>The intermediate thing <code>h0</code> is a workaround that makes the simplifier happy; the trace output is <code>h0:1000, @OfNat.ofNat (Fin (Nat.succ n)) 0 (@Fin.instOfNatFinHAdd n 0) ==&gt; @Fin.ofNat n 0</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Defs</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Fin</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.ofNat</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Fin.val_zero</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Fin.ofNat</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">OfNat.ofNat</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h0</span><span class=\"o\">,</span> <span class=\"n\">Fin.ofNat</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_mod</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 260590065,
        "sender_full_name": "Chris B",
        "timestamp": 1636311478
    },
    {
        "content": "<blockquote>\n<p>What is the right way to simplify/rewrite using typeclass definitions?</p>\n</blockquote>\n<p>The usual way is to just state the desired rewrite as a lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ofNat_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">Fin.ofNat</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>In a similar vein, you can restate lemmas in terms of the canonical representation (i.e., OfNat.ofNat instead of Fin.ofNat):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ofNat_val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 260635361,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1636365436
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  Thanks, that makes sense. I got used to the convenience of being able to write <code>simp [&lt;def&gt;]</code> for definitions and thought classes might have similar behavior without writing explicit lemmas.</p>",
        "id": 260720130,
        "sender_full_name": "Chris B",
        "timestamp": 1636406193
    },
    {
        "content": "<p>In working with USize more today, the solution of extracting things into lemmas does not work well in some cases. For this: <code>lemma val_zero : (0 : USize).val = (0 : Fin size)</code>, where the instance of Zero is defined as <code>instance : Zero (Fin size) := (Nat.succ_pred_eq_of_pos size_positive) ▸ inferInstance</code>, things are really obscured by the fact that <code>size</code> isn't reducible and isn't defined in terms of <code>succ</code>. </p>\n<p>Without being able to just reduce what's already in the context of the theorem, it seems like I have set pp.all to true, then extract something about <code>Zero (Fin size)</code>, which actually requires <code>Zero (Fin size.pred.succ)</code>, and now I need another lemma to relate the two.</p>",
        "id": 261316503,
        "sender_full_name": "Chris B",
        "timestamp": 1636754255
    },
    {
        "content": "<p>Also where does the recursion depth error for <code>simp only [OfNat.ofNat]</code> come from?</p>",
        "id": 261316590,
        "sender_full_name": "Chris B",
        "timestamp": 1636754288
    }
]
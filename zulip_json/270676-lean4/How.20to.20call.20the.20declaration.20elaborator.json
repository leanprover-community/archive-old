[
    {
        "content": "<p>Note: in the process of writing up this question, I found the answer but I think it was an interesting problem and I thought I'd share the problem and the solution here.</p>\n<p>I'm defining a command syntax for opaque definitions. I'm defining the parser by calling the <code>«def»</code> parser and my elaborator begins calling the declaration elaborator on the (slightly massaged) syntax tree.</p>\n<p>I get into a funny situation where the declaration elaborator fails when the definition has a non-atomic (e.g. <code>foo.bar</code>) name. However the Lean syntax does allow such definitions. Am I missing a step where the name has to be expanded?</p>\n<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Declaration</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Elab.Command</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">opaqueDef</span><span class=\"o\">)</span>\n   <span class=\"n\">declModifiers</span> <span class=\"s2\">\"opaque \"</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">@[commandElab opaqueDef]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabOpaqueDef</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mods</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">kw</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"n\">print_vars</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">».</span><span class=\"n\">getKind</span><span class=\"o\">,</span> <span class=\"n\">stx.getKind</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"o\">:=</span> <span class=\"n\">stx.setArgs</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mods</span><span class=\"o\">,</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span><span class=\"o\">]</span>\n  <span class=\"n\">Lean.Elab.Command.elabDeclaration</span> <span class=\"n\">stx</span>\n\n<span class=\"n\">opaque</span> <span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>   <span class=\"c1\">-- works</span>\n<span class=\"kd\">def</span> <span class=\"n\">x.x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>        <span class=\"c1\">-- works</span>\n<span class=\"n\">opaque</span> <span class=\"kd\">def</span> <span class=\"n\">x.y</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span> <span class=\"c1\">-- does not works</span>\n                    <span class=\"c1\">-- Error: atomic identifier expected 'x.y'</span>\n</code></pre></div>\n<p>(solution coming in a moment)</p>",
        "id": 271696892,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644683797
    },
    {
        "content": "<p>There are two problems with the way my code just plainly calls <code>elabDeclaration</code> on my home made declaration syntax: </p>\n<ol start=\"0\">\n<li>\n<p>Minor problem: it does not set the kind of the node. <code>elabDeclaration</code> checks the kind to see which one of <code> ``Lean.Parser.Command.«def»</code> or <code> ``Lean.Parser.Command.«instance»</code> etc.</p>\n</li>\n<li>\n<p>While <code>elabDeclaration</code> does handle namespace expansion, when it encounters a complex name, after it rewrites the syntax tree with the right constructs (a <code>namespace</code> command and a declaration with an atomic name), it calls <code>elabCommand</code> on it which starts the elaboration all over again. In my code, I rewrite the syntax tree to make it more digestible by <code>elabDeclaration</code> by removing the keyword <code>opaque</code>. That means that restarting the elaboration does not end up calling my own elaborator. </p>\n</li>\n</ol>\n<p>The consequence for the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> I showed is that, I created a syntax tree that I thought would be more digestible</p>",
        "id": 271697413,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644684617
    },
    {
        "content": "<p>Here is what the code snippet becomes:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Fixing namespace expansion</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Declaration</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Elab.Command</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">opaqueDef</span><span class=\"o\">)</span>\n   <span class=\"n\">declModifiers</span> <span class=\"s2\">\"opaque \"</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expandOpaqueDefNamespace</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">decl.getKind</span>\n    <span class=\"k\">match</span> <span class=\"n\">expandDeclIdNamespace</span><span class=\"bp\">?</span> <span class=\"n\">decl</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ns</span><span class=\"o\">,</span> <span class=\"n\">declId</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ns</span><span class=\"o\">,</span> <span class=\"n\">stx.setArg</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">decl.setArg</span> <span class=\"mi\">1</span> <span class=\"n\">declId</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span>              <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">@[commandElab opaqueDef]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabOpaqueDef</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">expandOpaqueDefNamespace</span><span class=\"bp\">?</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ns</span><span class=\"o\">,</span> <span class=\"n\">newStx</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">stx</span> <span class=\"n\">ns</span>\n    <span class=\"k\">let</span> <span class=\"n\">newStx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"n\">ns</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">newStx</span> <span class=\"kd\">end</span> <span class=\"bp\">$</span><span class=\"n\">ns</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n    <span class=\"n\">withMacroExpansion</span> <span class=\"n\">stx</span> <span class=\"n\">newStx</span> <span class=\"bp\">$</span> <span class=\"n\">elabCommand</span> <span class=\"n\">newStx</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mods</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">kw</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx'</span> <span class=\"o\">:=</span> <span class=\"n\">stx.setArgs</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mods</span><span class=\"o\">,</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span><span class=\"o\">]</span>\n    <span class=\"n\">elabMutualDef</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">stx'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">getTerminationHints</span> <span class=\"n\">stx'</span><span class=\"o\">)</span>\n\n<span class=\"n\">opaque</span> <span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>   <span class=\"c1\">-- works</span>\n<span class=\"kd\">def</span> <span class=\"n\">x.x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>        <span class=\"c1\">-- works</span>\n<span class=\"n\">opaque</span> <span class=\"kd\">def</span> <span class=\"n\">x.y</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span> <span class=\"c1\">-- now works! Yay!</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">x</span> <span class=\"c1\">-- x : Nat</span>\n<span class=\"k\">#check</span> <span class=\"n\">x.x</span> <span class=\"c1\">-- x.x : Nat</span>\n<span class=\"k\">#check</span> <span class=\"n\">x.y</span> <span class=\"c1\">-- x.y : Nat</span>\n</code></pre></div>\n</div></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Explanation</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Instead of calling <code>elabDeclaration</code>, we call <code>elabMutualDef</code> after doing the namespace expansion, possibly restarting the elaboration as a result. We mimic the structure of <code>elabDeclaration</code>.</p>\n</div></div>",
        "id": 271697638,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644684961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> The key problem in your example is that you are constructing an invalid syntax tree at</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"o\">:=</span> <span class=\"n\">stx.setArgs</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mods</span><span class=\"o\">,</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>If you create a proper <code>declaration</code> syntax object, everything works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Declaration</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Elab.Command</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">opaqueDef</span><span class=\"o\">)</span>\n   <span class=\"n\">declModifiers</span> <span class=\"s2\">\"opaque \"</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">@[commandElab opaqueDef]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabOpaqueDef</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mods</span>  <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">kw</span>    <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span>   <span class=\"o\">:=</span> <span class=\"n\">mkNode</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Command.declaration</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mods</span><span class=\"o\">,</span> <span class=\"bp\">«</span><span class=\"kd\">def</span><span class=\"bp\">»</span><span class=\"o\">]</span>  <span class=\"c1\">-- &lt;&lt;&lt; FIxed here</span>\n  <span class=\"n\">Lean.Elab.Command.elabDeclaration</span> <span class=\"n\">stx</span>\n\n<span class=\"n\">opaque</span> <span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>   <span class=\"c1\">-- works</span>\n<span class=\"kd\">def</span> <span class=\"n\">x.x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>        <span class=\"c1\">-- works</span>\n<span class=\"n\">opaque</span> <span class=\"kd\">def</span> <span class=\"n\">x.y</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 271698193,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1644685570
    },
    {
        "content": "<p>In this context, that's true but if I need to do something special during elaboration because of the <code>opaque</code> keyword, when <code>elabDeclaration</code> calls <code>elabCommand</code>, it will not see the <code>opaque</code> keyword anymore.</p>",
        "id": 271698320,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644685726
    },
    {
        "content": "<p>Addendum: ok, I see how to get around that. In hindsight, it looks like more fuss than was needed. Sorry about that</p>",
        "id": 271698401,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644685823
    },
    {
        "content": "<p>Thanks for your help!</p>",
        "id": 271698486,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644685936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>  you might be interested in <a href=\"https://github.com/leanprover-community/mathlib4/blob/89fab7c0c4b59709dbafe212a9e02261c73b7d09/Mathlib/Tactic/IrreducibleDef.lean\">https://github.com/leanprover-community/mathlib4/blob/89fab7c0c4b59709dbafe212a9e02261c73b7d09/Mathlib/Tactic/IrreducibleDef.lean</a></p>",
        "id": 271804379,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1644832459
    },
    {
        "content": "<p>Nice! Thanks! My version does something similar and also transports the equations produced by the equation compiler. It does not register them as equations but they can still be useful</p>",
        "id": 271854391,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644857432
    },
    {
        "content": "<p>I'm also preparing a feature where writing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"kn\">namespace</span> <span class=\"n\">MyOpaqueDef</span>\n<span class=\"bp\">...</span>\n<span class=\"kd\">end</span> <span class=\"n\">MyOpaqueDef</span>\n</code></pre></div>\n<p>lets you write definitions in terms of your definition as if it was not opaque (as long as the types work out when you transport them)</p>",
        "id": 271854644,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644857536
    }
]
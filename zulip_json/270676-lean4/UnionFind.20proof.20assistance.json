[
    {
        "content": "<p>Hello. I'd like some assistance writing proofs for a Union-Find implementation. I've figured out how to write all the proofs except for growing the collection, which is Fin-specific and I couldn't find the right rewrites to apply. That aside, I feel there are better ways to write the proofs. Any suggestions?</p>\n<p>Oh and I feel like it'd be nice to have a proof there cannot exist cycles, but for now I've just gone with a for-loop for worst-case fuel and exit early. Not even sure where I'd start to express such an acyclic proof, can do without, just would be a very nice property to have proven.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">UnionFind</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">correct_size</span> <span class=\"o\">:</span> <span class=\"n\">size</span> <span class=\"bp\">=</span> <span class=\"n\">data.size</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">UnionFind</span>\n  <span class=\"kd\">def</span> <span class=\"n\">parent</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span> <span class=\"o\">:=</span>\n    <span class=\"n\">u.data</span><span class=\"o\">[</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">u.correct_size</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">i</span><span class=\"o\">]</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">grow</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"n\">u.data.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin.mk</span> <span class=\"n\">x.val</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">push</span> <span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"n\">size</span> <span class=\"gr\">sorry</span><span class=\"o\">),</span>\n      <span class=\"n\">correct_size</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"o\">}</span>\n\n  <span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">set_parent</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">u.correct_size</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">i</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"n\">u.data.set</span> <span class=\"n\">i</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"n\">correct_size</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">u.data.size_set</span> <span class=\"n\">i</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">u.correct_size</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">q.symm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">s</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">u</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">i</span>\n    <span class=\"n\">for</span> <span class=\"n\">_</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">size</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">u.parent</span> <span class=\"n\">i</span>\n      <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">u.parent</span> <span class=\"n\">p</span>\n      <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"k\">then</span>\n        <span class=\"n\">break</span>\n      <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">u.set_parent</span> <span class=\"n\">i</span> <span class=\"n\">g</span>\n      <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">g</span>\n    <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">u.find</span> <span class=\"n\">a</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">u.find</span> <span class=\"n\">b</span>\n    <span class=\"n\">u.set_parent</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"kd\">end</span> <span class=\"n\">UnionFind</span>\n</code></pre></div>",
        "id": 292861343,
        "sender_full_name": "Sofia",
        "timestamp": 1660186836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I noted your UnionFind implementation in Mathlib. 300 lines, returns proofs, not quite what I expected. Was there any specific goal with this approach not met by my approach? <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean</a></p>",
        "id": 292861472,
        "sender_full_name": "Sofia",
        "timestamp": 1660186991
    },
    {
        "content": "<p>I will add ranks to my implementation.</p>",
        "id": 292861619,
        "sender_full_name": "Sofia",
        "timestamp": 1660187148
    },
    {
        "content": "<p>I have written very few proofs so far. Was happy to get as far as I did here. :)</p>",
        "id": 292861700,
        "sender_full_name": "Sofia",
        "timestamp": 1660187218
    },
    {
        "content": "<p>Updated towards adding the rank, but stuck with the proofs still.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">UFNode</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">parent</span> <span class=\"n\">rank</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">UnionFind</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">UFNode</span> <span class=\"n\">size</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">correct_size</span> <span class=\"o\">:</span> <span class=\"n\">size</span> <span class=\"bp\">=</span> <span class=\"n\">data.size</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Iff a node is not its own parent, the rank must increase.</span>\n<span class=\"c1\">--(rank_proof : forall s : Fin data.size, s != data[s].parent &lt;-&gt; data[s].rank &lt; data[data[s].parent].rank))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">UnionFind</span>\n  <span class=\"kd\">def</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"mi\">0</span> <span class=\"n\">where</span>\n    <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n    <span class=\"n\">correct_size</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">grow</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- u.data.map (fun x =&gt; Fin.mk x.val sorry) |&gt;.push (Fin.mk size sorry),</span>\n    <span class=\"n\">correct_size</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">--by decide</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">lookup</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UFNode</span> <span class=\"n\">size</span> <span class=\"o\">:=</span>\n    <span class=\"n\">u.data</span><span class=\"o\">[</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">u.correct_size</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">i</span><span class=\"o\">]</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">set_parent</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">u.correct_size</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">i</span>\n    <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">parent</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">rank</span> <span class=\"o\">:=</span> <span class=\"n\">u.lookup</span> <span class=\"n\">p</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">rank</span> <span class=\"c\">/-</span><span class=\"cm\"> + 1 -/</span> <span class=\"o\">}</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"n\">u.data.set</span> <span class=\"n\">i</span> <span class=\"n\">n</span>\n      <span class=\"n\">correct_size</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">u.data.size_set</span> <span class=\"n\">i</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">u.correct_size</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">q.symm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">s</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"o\">}</span>\n\n  <span class=\"c1\">-- find with path halving.</span>\n  <span class=\"kd\">def</span> <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">UFNode</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">node</span> <span class=\"o\">:=</span> <span class=\"n\">u.lookup</span> <span class=\"n\">i</span>\n    <span class=\"k\">if</span> <span class=\"n\">node.parent</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span>\n      <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">node</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">u.lookup</span> <span class=\"n\">node.parent</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">parent</span>\n      <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">u.set_parent</span> <span class=\"n\">i</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">g</span>\n  <span class=\"n\">decreasing_by</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- rank is monotonic</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">u.find</span> <span class=\"n\">a</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">u.find</span> <span class=\"n\">b</span>\n    <span class=\"k\">if</span> <span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">a.rank</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.rank</span> <span class=\"k\">then</span>\n      <span class=\"n\">u.set_parent</span> <span class=\"n\">a.parent</span> <span class=\"n\">b.parent</span> <span class=\"c1\">-- h</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">u.set_parent</span> <span class=\"n\">b.parent</span> <span class=\"n\">a.parent</span> <span class=\"c1\">-- h.symm</span>\n<span class=\"kd\">end</span> <span class=\"n\">UnionFind</span>\n</code></pre></div>",
        "id": 292865762,
        "sender_full_name": "Sofia",
        "timestamp": 1660192141
    },
    {
        "content": "<p>Whoops, there are 3 orders, not 2. Should be an extra branch in that union. Also.. <code>(not h).symm</code> ?</p>",
        "id": 292866358,
        "sender_full_name": "Sofia",
        "timestamp": 1660192838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455721\">Sofia</span> <a href=\"#narrow/stream/270676-lean4/topic/UnionFind.20proof.20assistance/near/292861472\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> I noted your UnionFind implementation in Mathlib. 300 lines, returns proofs, not quite what I expected. Was there any specific goal with this approach not met by my approach? <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UnionFind.lean</a></p>\n</blockquote>\n<ul>\n<li>The <code>UnionFind</code> type itself does not depend on <code>size</code></li>\n<li>It stores data associated to the nodes, although that could arguably be separated from the data structure itself</li>\n<li>It does path compression, which is required to get the famed inverse-ackermann runtime bound</li>\n<li>It supports <code>grow</code> without remapping the array (which is O(n))</li>\n</ul>\n<p>I can concede that putting the <code>size</code> in the type leads to an easier interface though, since it's easier to track the size that way.</p>",
        "id": 292868957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660195515
    },
    {
        "content": "<p>'Full' path compression has more memory accesses due to the second iteration. 'Splitting' updates the same number of nodes and 'halving' updates half the nodes. Full path compression is known to be slower, and splitting and halving perform the same. I've chosen halving to reduce write throughput regardless. <a href=\"https://arxiv.org/abs/1911.06347\">https://arxiv.org/abs/1911.06347</a></p>",
        "id": 292869723,
        "sender_full_name": "Sofia",
        "timestamp": 1660196203
    },
    {
        "content": "<p>I might add the data in, but have a few other details to figure out before deciding quite how everything is laid out. For context, I'm implementing UnionFind towards an E-graph implementation which compiles to a Datalog incremental relational database for worst-case optimal queries, with multi-patterns and adaptive query scheduling. <a href=\"https://arxiv.org/abs/2108.02290\">https://arxiv.org/abs/2108.02290</a></p>",
        "id": 292870012,
        "sender_full_name": "Sofia",
        "timestamp": 1660196444
    },
    {
        "content": "<p>Also curious about implementing an SMT solver using the E-graph with these incremental worst-case optimal queries.</p>",
        "id": 292870421,
        "sender_full_name": "Sofia",
        "timestamp": 1660196807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Oh I forgot to ask. Does the map over <code>Fin</code> values to update their bound not become free? IIUC Lean will understand the value is used once, thus do an in-place map, then realize the only changes are in proof terms, thus are no-ops, right?</p>",
        "id": 292872260,
        "sender_full_name": "Sofia",
        "timestamp": 1660198320
    },
    {
        "content": "<p>One would hope so, but you have to look at the generated code to now for sure. I'm fairly confident that this is still too magical for lean ATM</p>",
        "id": 292872537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198550
    },
    {
        "content": "<p>In general I'm dubious about all these changes without actual performance numbers for comparison</p>",
        "id": 292872645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198626
    },
    {
        "content": "<p>If you mean the path compression methods? That paper I linked is all about those numbers.</p>",
        "id": 292872698,
        "sender_full_name": "Sofia",
        "timestamp": 1660198676
    },
    {
        "content": "<p>I mean in lean</p>",
        "id": 292872758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198696
    },
    {
        "content": "<p>the paper seems to be about concurrent unionfind, which is completely different</p>",
        "id": 292872779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198716
    },
    {
        "content": "<p>all the unionfind functions are inherently serial, they mutate the data structure</p>",
        "id": 292872793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198734
    },
    {
        "content": "<p>if you used them with a shared pointer to the <code>UnionFind</code> value it would have terrible performance, since it would have to copy the whole array first</p>",
        "id": 292872904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198807
    },
    {
        "content": "<p>It discusses both. An interesting detail of the concurrent union find is you can use plain reads/writes to update the structure and you only need memory barriers to check if a self-parent candidate is actually true. No atomics, just a single fence at the end of <code>find</code> whose result is likely true.</p>",
        "id": 292872950,
        "sender_full_name": "Sofia",
        "timestamp": 1660198848
    },
    {
        "content": "<p>This is because stale or not, all invariants hold.</p>",
        "id": 292872993,
        "sender_full_name": "Sofia",
        "timestamp": 1660198890
    },
    {
        "content": "<p>This isn't C / Rust, we don't have that level of access to memory in the first place</p>",
        "id": 292873009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198903
    },
    {
        "content": "<p>Optimization is very dependent on the compiler and runtime here</p>",
        "id": 292873080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198934
    },
    {
        "content": "<p>Indeed. Would be nice though. Either way, the path compression methods were benchmarked serially in addition to later for the concurrent case.</p>",
        "id": 292873110,
        "sender_full_name": "Sofia",
        "timestamp": 1660198956
    },
    {
        "content": "<p>again, it needs to be lean numbers</p>",
        "id": 292873121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660198974
    },
    {
        "content": "<p>I think the bigger problem would be all the pointer-chasing. Ex. An array of fin or nat aren't inlined IIUC.</p>",
        "id": 292873142,
        "sender_full_name": "Sofia",
        "timestamp": 1660198987
    },
    {
        "content": "<p>Sure</p>",
        "id": 292873149,
        "sender_full_name": "Sofia",
        "timestamp": 1660198994
    },
    {
        "content": "<p>Note that the implementation of unionfind didn't start out 300 lines. That's only after doing all the proofs. It was only around 30 lines before all the proofs and invariants were added</p>",
        "id": 292873305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660199113
    },
    {
        "content": "<p>Aye. It was the interface which returns the size proof that I found surprising at first. But it does feel like that was a lot of proof work and I wonder if there would be a better way to represent it.</p>",
        "id": 292873478,
        "sender_full_name": "Sofia",
        "timestamp": 1660199185
    },
    {
        "content": "<p>you know it didn't start out looking like that, it got added because you need it to do a later part of the proof</p>",
        "id": 292873517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660199216
    },
    {
        "content": "<p>Right.</p>",
        "id": 292873561,
        "sender_full_name": "Sofia",
        "timestamp": 1660199247
    },
    {
        "content": "<p>I think there could be another way to represent it, but it's tricky to avoid passing unnecessary arguments</p>",
        "id": 292873566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660199248
    },
    {
        "content": "<p>in particular <code>size</code></p>",
        "id": 292873579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660199258
    },
    {
        "content": "<p>Speaking of, I was a little surprised when I started playing with Lean 4 that <code>Vect a k</code> isn't implemented (except in comments), everything seems to use <code>Array a</code>.</p>",
        "id": 292873666,
        "sender_full_name": "Sofia",
        "timestamp": 1660199305
    },
    {
        "content": "<p>dependent types are not good for the compiler</p>",
        "id": 292873696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660199333
    },
    {
        "content": "<p>Heh. Well, I hope this will not be true for my own.</p>",
        "id": 292873753,
        "sender_full_name": "Sofia",
        "timestamp": 1660199386
    },
    {
        "content": "<p>They block various kinds of code motion optimizations because of having to introduce <code>cast</code></p>",
        "id": 292873830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660199419
    },
    {
        "content": "<p>I don't think yours is an exception, unless you have reason to believe that the blocked optimizations aren't important for you</p>",
        "id": 292873851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660199454
    },
    {
        "content": "<p>Not quite sure which block you mean. Either way my design is largely based on equality saturation, and reasoning with symbolic terms.</p>",
        "id": 292874016,
        "sender_full_name": "Sofia",
        "timestamp": 1660199568
    },
    {
        "content": "<p>In the case of storing a vector, letting it grow, then shrink, if the compiler can see the upper bound (and it isn't too high), then it can allocate that region without re-allocating and copying the data around to make it fit. While in the earlier or intermediate stages, any unused allocated area can be repurposed for ephemeral local scratch space. Similarly any padding can be used for sentinels.</p>",
        "id": 292874447,
        "sender_full_name": "Sofia",
        "timestamp": 1660199840
    },
    {
        "content": "<p>Most of the time arrays/vectors can have statically known upper bounds through a little symbolic analysis. When this analysis fails, then we have to pay for the re-allocations and copies if necessary. Further we don't just want to consider the worst-case, as the average may be much friendlier and we don't want to waste memory just to be conservative.</p>",
        "id": 292874603,
        "sender_full_name": "Sofia",
        "timestamp": 1660199956
    },
    {
        "content": "<p>Linear memory management is a really good starting point.</p>",
        "id": 292875061,
        "sender_full_name": "Sofia",
        "timestamp": 1660200276
    },
    {
        "content": "<p>Huh. I updated Lean, now I get this error on one of my proofs which was working before.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">def</span> <span class=\"n\">lookup</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">UnionFind</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UFNode</span> <span class=\"n\">size</span> <span class=\"o\">:=</span>\n    <span class=\"n\">u.data</span><span class=\"o\">[</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">u.correct_size</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">i</span><span class=\"o\">]</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">UnionFind.lean</span><span class=\"o\">:</span><span class=\"mi\">60</span><span class=\"o\">:</span><span class=\"mi\">4</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">index</span> <span class=\"n\">is</span> <span class=\"n\">valid</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">:</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"k\">have</span><span class=\"bp\">`-</span><span class=\"n\">expressions</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"n\">index</span> <span class=\"n\">is</span> <span class=\"n\">valid</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!`</span> <span class=\"kd\">notation</span> <span class=\"n\">instead</span><span class=\"o\">,</span> <span class=\"n\">runtime</span> <span class=\"n\">check</span> <span class=\"n\">is</span> <span class=\"n\">perfomed</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"bp\">'</span><span class=\"n\">Panic'</span> <span class=\"n\">error</span> <span class=\"n\">message</span> <span class=\"n\">is</span> <span class=\"n\">produced</span> <span class=\"k\">if</span> <span class=\"n\">index</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">valid</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?`</span> <span class=\"kd\">notation</span> <span class=\"n\">instead</span><span class=\"o\">,</span> <span class=\"n\">result</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"bp\">`</span><span class=\"n\">Option</span><span class=\"bp\">`</span> <span class=\"n\">type</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">h</span><span class=\"bp\">`</span> <span class=\"kd\">notation</span> <span class=\"n\">instead</span><span class=\"o\">,</span> <span class=\"n\">where</span> <span class=\"bp\">`</span><span class=\"n\">h</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">proof</span> <span class=\"n\">that</span> <span class=\"n\">index</span> <span class=\"n\">is</span> <span class=\"n\">valid</span>\n</code></pre></div>",
        "id": 292922441,
        "sender_full_name": "Sofia",
        "timestamp": 1660221863
    },
    {
        "content": "<p>you could use <code>.get</code> there</p>",
        "id": 292929123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660224218
    },
    {
        "content": "<p>the <code>a[i]</code> syntax now expects a <code>Nat</code> in the first position</p>",
        "id": 292929217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660224244
    },
    {
        "content": "<p>or a <code>Fin _</code> but you would have to type ascribe it</p>",
        "id": 292929251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660224256
    },
    {
        "content": "<p>Ah. First it was Nat, then Fin, now Nat again. o.o</p>",
        "id": 292931894,
        "sender_full_name": "Sofia",
        "timestamp": 1660225223
    },
    {
        "content": "<p>Thanks, can confirm using <code>.get</code> worked.</p>",
        "id": 292931931,
        "sender_full_name": "Sofia",
        "timestamp": 1660225250
    },
    {
        "content": "<p>Why would the explicit type ascription work if not the type just being itself?</p>",
        "id": 292932174,
        "sender_full_name": "Sofia",
        "timestamp": 1660225332
    },
    {
        "content": "<p>It now accepts multiple types there, so a <code>by</code> block won't work because the type is unconstrained</p>",
        "id": 292932816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660225556
    },
    {
        "content": "<p>Ah, that bit. Okay. Huh.</p>",
        "id": 292932961,
        "sender_full_name": "Sofia",
        "timestamp": 1660225605
    },
    {
        "content": "<p>If you give it a <code>Nat</code>, then it expects a proof to be supplied, if you give it <code>Fin _</code> then it doesn't need the proof</p>",
        "id": 292933012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660225625
    },
    {
        "content": "<p>Not even.. <code>u.data[by rw [u.correct_size] at i; exact (i : Fin _)]</code></p>",
        "id": 292933066,
        "sender_full_name": "Sofia",
        "timestamp": 1660225646
    },
    {
        "content": "<p>try <code>u.data[(by rw [u.correct_size] at i; exact i : Fin _)]</code></p>",
        "id": 292933134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660225674
    },
    {
        "content": "<p>Or <code>u.data[(by rw [u.correct_size] at i; exact i) : Fin _]</code></p>",
        "id": 292933216,
        "sender_full_name": "Sofia",
        "timestamp": 1660225692
    },
    {
        "content": "<p>Your suggestion worked.</p>",
        "id": 292933298,
        "sender_full_name": "Sofia",
        "timestamp": 1660225726
    },
    {
        "content": "<p>Means the .get is shortest. <em>shrug</em></p>",
        "id": 292933396,
        "sender_full_name": "Sofia",
        "timestamp": 1660225772
    },
    {
        "content": "<p>you could also do <code>u.data[i.1]'(by rw [u.correct_size] at i; exact i.2)</code> IIUC</p>",
        "id": 292934065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660226017
    },
    {
        "content": "<p>I tried a variant, with <code>.val</code> and <code>.isLt</code> which didn't work because the value is detached from the rewrite it seems.</p>",
        "id": 292934772,
        "sender_full_name": "Sofia",
        "timestamp": 1660226251
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">i.isLt</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">i.val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Array.size</span> <span class=\"n\">u.data</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">i</span><span class=\"bp\">✝.</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Array.size</span> <span class=\"n\">u.data</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 292935017,
        "sender_full_name": "Sofia",
        "timestamp": 1660226327
    },
    {
        "content": "<p>MWE?</p>",
        "id": 292935802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660226586
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Unit</span>\n  <span class=\"n\">size_proof</span> <span class=\"o\">:</span> <span class=\"n\">size</span> <span class=\"bp\">=</span> <span class=\"n\">data.size</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">wme</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f.data</span><span class=\"o\">[</span><span class=\"n\">i.1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">f.size_proof</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">i.2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 292936837,
        "sender_full_name": "Sofia",
        "timestamp": 1660226913
    },
    {
        "content": "<p><code>f.data[i.1]'(by rw [← f.size_proof]; exact i.2)</code> is better in that case</p>",
        "id": 292939160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660227738
    },
    {
        "content": "<p>or just <code>f.data[i]'(f.size_proof ▸ i.2)</code></p>",
        "id": 292939188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660227752
    },
    {
        "content": "<p>Wait what, how? o.o</p>",
        "id": 292939673,
        "sender_full_name": "Sofia",
        "timestamp": 1660227921
    },
    {
        "content": "<p><code>i</code> coerces to <code>i.1</code>, which adds even more fun to this</p>",
        "id": 292940047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660228066
    },
    {
        "content": "<p>I'll go with <code>f.data.get (f.size_proof ▸ i)</code> given these options.</p>",
        "id": 292940216,
        "sender_full_name": "Sofia",
        "timestamp": 1660228114
    },
    {
        "content": "<p>How would you write <code>by have q := u.data.size_set i n; have s := u.size_proof ; rw [q.symm] at s; exact s</code> in this form?</p>",
        "id": 292941216,
        "sender_full_name": "Sofia",
        "timestamp": 1660228388
    },
    {
        "content": "<p>hard to say without MWE but probably <code>u.data.size_set i n \\t u.size_proof</code></p>",
        "id": 292941409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660228442
    },
    {
        "content": "<p>Works, neat.</p>",
        "id": 292941597,
        "sender_full_name": "Sofia",
        "timestamp": 1660228490
    },
    {
        "content": "<p>Thanks</p>",
        "id": 292941610,
        "sender_full_name": "Sofia",
        "timestamp": 1660228494
    },
    {
        "content": "<p>I thought I tried this, guess I did it backwards. Also thought I needed a .symm in there.</p>",
        "id": 292941715,
        "sender_full_name": "Sofia",
        "timestamp": 1660228523
    },
    {
        "content": "<p>Re other proof writing issues. How does one<code>Fin k -&gt; Fin k.succ</code> ? I expect to see a lift function or something but do not.</p>",
        "id": 292945864,
        "sender_full_name": "Sofia",
        "timestamp": 1660229774
    },
    {
        "content": "<p>I want to check the generated code for the <code>arr.map Fin.lift'ish'or'whatever</code>.</p>",
        "id": 292945923,
        "sender_full_name": "Sofia",
        "timestamp": 1660229791
    },
    {
        "content": "<p>Oh even better. <code>u.data[u.size_proof ▸ i]</code> works. :)</p>",
        "id": 292946778,
        "sender_full_name": "Sofia",
        "timestamp": 1660230052
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Is <code>▸</code> defined anywhere _in lean_ ? I only see a builtin term parser named <code>subst</code>.</p>",
        "id": 292953469,
        "sender_full_name": "Sofia",
        "timestamp": 1660232062
    },
    {
        "content": "<p>that is in lean?</p>",
        "id": 292953509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660232080
    },
    {
        "content": "<p>Wait, I found it. Lean/Elab/BuiltinNotation.lean</p>",
        "id": 292953635,
        "sender_full_name": "Sofia",
        "timestamp": 1660232131
    },
    {
        "content": "<p>I found the syntax definition but somehow missed the term elaborator for it.</p>",
        "id": 292953792,
        "sender_full_name": "Sofia",
        "timestamp": 1660232173
    },
    {
        "content": "<p>what does goto def do?</p>",
        "id": 292953833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660232191
    },
    {
        "content": "<p>Nothing. :(</p>",
        "id": 292953867,
        "sender_full_name": "Sofia",
        "timestamp": 1660232202
    },
    {
        "content": "<p>I'll look into it</p>",
        "id": 292953915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660232217
    },
    {
        "content": "<p>&lt;3</p>",
        "id": 292953940,
        "sender_full_name": "Sofia",
        "timestamp": 1660232222
    },
    {
        "content": "<p>I'm using the Helix editor, which integrates with the LSP out of the box.</p>",
        "id": 292953995,
        "sender_full_name": "Sofia",
        "timestamp": 1660232240
    },
    {
        "content": "<p>Normally gd/goto definition just works.</p>",
        "id": 292954029,
        "sender_full_name": "Sofia",
        "timestamp": 1660232257
    },
    {
        "content": "<p>Not on syntax it seems.</p>",
        "id": 292954159,
        "sender_full_name": "Sofia",
        "timestamp": 1660232287
    },
    {
        "content": "<p>I just tested on master and go to def goes to <code>elabSubst</code> while \"go to declaration\" goes to the <code>subst</code> syntax</p>",
        "id": 292954484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660232400
    },
    {
        "content": "<p>Ah. Go to \"definition\" and \"implementation\" don't go. To \"type definition\" goes to <code>Eq</code>.</p>",
        "id": 292954750,
        "sender_full_name": "Sofia",
        "timestamp": 1660232484
    },
    {
        "content": "<p>Go to \"implementation\" isn't even implemented in Lean's LSP, ironically.</p>",
        "id": 292954942,
        "sender_full_name": "Sofia",
        "timestamp": 1660232538
    },
    {
        "content": "<p>Odd, now that goto type definition goes to <code>Fin</code>. o.o</p>",
        "id": 292955258,
        "sender_full_name": "Sofia",
        "timestamp": 1660232633
    }
]
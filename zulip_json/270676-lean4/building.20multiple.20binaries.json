[
    {
        "content": "<p>Has anyone else felt the need for Lake to be able to compile multiple binaries? If so, are there plans to make it possible?</p>\n<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>: I'm thinking about how to setup a proper testing infrastructure for a Lake project using something like <a href=\"https://hspec.github.io/\">https://hspec.github.io/</a>. I would like to have the tests running in a way that an error can return 1 to the OS.</p>\n<p>I have somewhat done it using a Lake script. However, the Lake script looks like a solution particular to a certain repository rather than something that can be extensively used by other libraries. Hence my idea about allowing Lake to build multiple binaries, such that one would be able to build the main binary <em>and</em> the testing binary.</p>\n<p>Thanks in advance!</p>",
        "id": 282292852,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1652469247
    },
    {
        "content": "<p>I also tried running a Lean file with <code>lean --run tests.lean</code>, which has a <code>main : List String → IO UInt32</code> function. But I'm getting a lot of errors like <code>unknown constant sorryAx</code>, even though I added the line <code>Lean.initSearchPath $ ← Lean.findSysroot</code> in my function. Maybe it's missing the definition of <code>LEAN_PATH</code> in my environment, but at this point I think it could be smoother with support from Lake <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>\n<p>There's also the fact that I would prefer running the tests with the compiled binary instead of the interpreted code. Not only because of execution speed, but also because in production we would have compiled code running anyway</p>",
        "id": 282295057,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1652470562
    },
    {
        "content": "<p>I will read the question more carefully later, but maybe you are missing <code>lake env lean --run ...</code></p>",
        "id": 282297247,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1652471791
    },
    {
        "content": "<p>I think I can get away with a custom compilation command (similar to what <code>lake build</code> does).</p>\n<p>If this is an welcome addition, I might try adding an extra attribute to the Lake package config on a fork:<br>\n<code>moreBinTargets : List (String x String)</code>, that is, a list of pairs of Lean file names and binary file names</p>",
        "id": 282321564,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1652487168
    },
    {
        "content": "<p>I would definitely like the ability to build multiple binaries. Exactly the same use case, for running tests. Currently I have a custom lake script executing <code>lean --run ...</code> command</p>\n<p>Also the ability to build multiple shared libraries would be nice. That would be useful for my Lean as a scripting language project.</p>",
        "id": 282351694,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1652532959
    },
    {
        "content": "<p>I was able to make a setup that works (and is not too ugly). The idea is to build a binary for each Lean file in the <a href=\"https://github.com/yatima-inc/yatima-lang/tree/8ececbb8403924178fa744f5d1655fbacf4e17d0/Tests\"><code>Tests</code></a> directory.</p>\n<p>I simply tried to mimic the last steps of <code>lake build</code>. It's done in <a href=\"https://github.com/yatima-inc/yatima-lang/blob/8ececbb8403924178fa744f5d1655fbacf4e17d0/lakefile.lean#L36\">this Lake script</a>.</p>\n<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> you should be able to adapt this approach to your needs <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 282375395,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1652567105
    },
    {
        "content": "<p>as a more general thought: Maybe we could have Lake include scripts as dependencies? So not only have dependencies that provide Lean code but also ones that provide Lake scripts, this way one could e.g. host a general purpose <code>lake-test</code> repo and people could declare it as a <code>script-dependency</code> or w/e and just use it so we can avoid copying around such scripts from the beginning.</p>",
        "id": 282408139,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1652619068
    },
    {
        "content": "<p>Fyi, building multiple binaries / libraries is on the TODO list and I will be back to working heavily on Lake starting  tomorrow.</p>",
        "id": 282428469,
        "sender_full_name": "Mac",
        "timestamp": 1652647997
    },
    {
        "content": "<p>Good news! A new version of Lake  (v3.1.1) landed in last night's nightly and the big new feature is support for multiple libraries and binaries! (I thought I had missed the deadline and it would be in tonight's nightly, hence why I am a little late with this announcement. ) The full changelog can be found in Lake's <a href=\"https://github.com/leanprover/lake/releases/tag/v3.1.0\">v3.1.0 release notes</a> (<a href=\"https://github.com/leanprover/lake/releases/tag/v3.1.1\">v3.1.1</a> is a hotfix to solve an issue I discovered only after releasing v3.1.0). Detailed documentation on how to use the new Lake  can be found in the <a href=\"https://github.com/leanprover/lake/blob/v3.1.1/README.md\">README</a>. However, I'll give a brief description of how to use the new multi-target feature here.</p>\n<p>There are currently three target types: Lean libraries (a collection modules available to import that can be also be built into a static and/or shared library), Lean binary executables (a module with a <code>main</code> function), and external libraries (replacing <code>moreLibTargets</code>). Each comes with a new DSL command to define the target. Examples:</p>\n<p><strong>Lean Library</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">lean_lib</span> <span class=\"n\">foo</span> <span class=\"o\">{</span>\n  <span class=\"n\">roots</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span> <span class=\"bp\">...</span>\n  <span class=\"n\">globs</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span> <span class=\"bp\">...</span>\n  <span class=\"n\">libName</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span> <span class=\"bp\">...</span>\n  <span class=\"n\">moreLinkArgs</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span> <span class=\"bp\">...</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p><strong>Binary Executable</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">lean_exe</span> <span class=\"n\">foo</span> <span class=\"o\">{</span>\n  <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Main</span>\n  <span class=\"n\">supportInterpreter</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n  <span class=\"n\">moreLinkArgs</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p><strong>External Library</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">extern_lib</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span>\n  <span class=\"n\">staticLibTarget</span> <span class=\"n\">fooFile</span> <span class=\"bp\">#</span><span class=\"o\">{</span><span class=\"n\">mainOFile</span><span class=\"o\">]</span> <span class=\"c1\">-- i.e., any `FileTarget`</span>\n</code></pre></div>\n<p>Defined targets can be built on the CLI using <code>lake build foo</code> or marked with the <code>@[defaultTarget]</code> attribute to build them on a bare <code>lake build</code>.  Hopefully that all makes sense and the transition is to the new style is not too painful (and Ithere are no bugs in Lake). Good luck!</p>\n<p><strong>P.S.</strong> This new release of Lake has a number of other changes (including new syntax for specifying dependencies), so make sure you do take a look at the <a href=\"https://github.com/leanprover/lake/releases/tag/v3.1.0\">release notes</a>. However, those changes are outside the scope of this thread, so I will not got into detail on them here now.</p>",
        "id": 285788859,
        "sender_full_name": "Mac",
        "timestamp": 1654967544
    },
    {
        "content": "<p>Can I ask why the transition from using Lean arrays to a custom DSL for specifying package dependencies? Does it enable new features? I must say I liked when the specification was \"just\" a Lean array, as opposed to a DSL whose semantics are not immediately clear. As you note, this might cause problems for linking dependencies in a particular order. (Overall the package manager seems to be moving in a good direction with lockfiles and such, so thank you for your work on it <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> ! I only have the one DSL-complaint here.)</p>",
        "id": 285789313,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1654968161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285789313\">said</a>:</p>\n<blockquote>\n<p>Can I ask why the transition from using Lean arrays to a custom DSL for specifying package dependencies? </p>\n</blockquote>\n<p>I find DSLs appropriate for Lake for a few reasons: (1) it allows for more modularity (everything does not have declared before / within the package, things can be interleaved); (2) it hides Lake's internal representation of the configuration from the user, allowing it to be changed without breaking user code (which makes adding features and maintaining backwards compatibility easier); (3) it is consistent with Lean core's design (i.e., <code>syntax</code>, <code>macro</code>, <code>elab</code>, <code>initalize</code>, etc.).</p>\n<p>Point (2) is especially important. With sufficiently expressive DSLs, the internal representation can be completely hidden (making a lot of refactors that would be otherwise breaking, capable of being made non-breaking). Furthermore, for breaking syntax changes (such as a language overhaul), a new DSL namespace could be created (e.g., <code>DSLv2</code>) allow users to opt into the new syntax. In contrast, direct interaction with the internal representation makes almost all changes breaking changes (as this update demonstrates with its many would-be breaking changes).</p>\n<p>For the package dependency DSL, in particular, it can allow the eventually (possible) feature of resolving dependencies during lakefile elaboration and/or potentially enabling special syntax for referencing sub-targets of declared dependencies. It also is much terser, which I consider a major positive (I also think it is easier to read).</p>",
        "id": 285790171,
        "sender_full_name": "Mac",
        "timestamp": 1654969458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285789313\">said</a>:</p>\n<blockquote>\n<p>As you note, this might cause problems for linking dependencies in a particular order.</p>\n</blockquote>\n<p>I do have plan to resolve this: new syntax (<code>extern_lib foo requires bar, baz</code>) and a topological sort of requirements. I just haven't included it here because I wanted to get this update out and I don't think that the current caveat is likely to effect many. Note the array solution still had ordering problems if some sorting need to be done with external libraries of downstream dependencies.</p>",
        "id": 285790277,
        "sender_full_name": "Mac",
        "timestamp": 1654969671
    },
    {
        "content": "<p>Hm, but the hiding of internal representation and custom syntax are orthogonal concerns, no? For example, there could be a stable structure <code>PackageConfig</code> that users declare which you then translate into a <code>PackageConfigInternal</code>. The <code>Internal</code> variant can be changed without affecting <code>PackageConfig</code>. So it seems like that all can be achieved without much DSL, and the real concern that is addressed by it is (1). Having separate commands for separate targets seems like a pretty good idea, e.g. <a href=\"https://doc.rust-lang.org/cargo/reference/cargo-targets.html\">Cargo</a> does it. Anyway, I see you have your reasons so I am not really suggesting a change, just trying to untangle which features help where.</p>",
        "id": 285791243,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1654971163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285791243\">said</a>:</p>\n<blockquote>\n<p>For example, there could be a stable structure <code>PackageConfig</code> that users declare which you then translate into a <code>PackageConfigInternal</code>. The <code>Internal</code> variant can be changed without affecting <code>PackageConfig</code>.</p>\n</blockquote>\n<p>Yeah, maybe the word \"internal\" is misleading. What I meant by my concern was changes to the structure of the forward-facing <code>PackageConfig</code>. The structure of Lean object is very rigid, whereas syntax can be very flexible -- this makes it easier to avoid breaking changes. For example, just changing a field from type <code>Foo</code> to <code>Option Foo</code> can break compatibility in some cases. In contrast, with macros, both versions can be easily massaged into the same type.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285791243\">said</a>:</p>\n<blockquote>\n<p>Anyway, I see you have your reasons so I am not really suggesting a change, just trying to untangle which features help where.</p>\n</blockquote>\n<p>Don't worry, I don't mind the questions. Thinking through these things is quite valuable. <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 285791664,
        "sender_full_name": "Mac",
        "timestamp": 1654971900
    },
    {
        "content": "<p>If there are multiple packages, can a compiled version of one be easily used in another, the way <code>Main.lean</code> uses compiled version of the other files?</p>",
        "id": 285839301,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1655036480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> I am not sure what you mean? Could you elaborate further on what you mean?</p>",
        "id": 285846392,
        "sender_full_name": "Mac",
        "timestamp": 1655045329
    },
    {
        "content": "<p>I mean that at present if I want to run something compiled instead of in the interpreter, I run it in the <code>Main</code> after <code>lake build</code>. In the case of multiple projects, is there some way that code from one project can similarly be used in compiled form in another project, even in the interpreter.</p>",
        "id": 285846528,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1655045525
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> I am really sorry, but that still doesn't make sense to me. Why would running things in<code>Main.lean</code> have any impact on whether things are compiled or interpreted? Do you instead mean in the <code>main</code>  function and then running the executable?</p>",
        "id": 285846757,
        "sender_full_name": "Mac",
        "timestamp": 1655045850
    },
    {
        "content": "<p>Yes. I mean that.</p>",
        "id": 285847262,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1655046510
    },
    {
        "content": "<p>I mean is there a reasonably easy way to make one project use the executable form of another project.</p>",
        "id": 285847275,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1655046565
    },
    {
        "content": "<p>Is the idea that you have a package <code>A</code> which could be compiled by <code>leanc</code> into <code>libA.so</code>, and then you have a package <code>B</code> importing <code>A</code>, and you would like the interpreter on <code>B</code>'s files to use the compiled code in <code>libA.so</code>? That sounds a bit like <a href=\"https://github.com/leanprover/lake/pull/47\">leanprover/lake#47</a> which seems on hold, however.</p>",
        "id": 285848498,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655048519
    },
    {
        "content": "<p>Or do you mean that <code>A</code> is an executable with a <code>def main</code> that gets compiled to an <code>A.exe</code> (or whatever), and you would like to run that using <code>IO.Process</code> in <code>B</code>'s <code>main</code>?</p>",
        "id": 285848541,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655048573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285848498\">said</a>:</p>\n<blockquote>\n<p>Is the idea that you have a package <code>A</code> which could be compiled by <code>leanc</code> into <code>libA.so</code>, and then you have a package <code>B</code> importing <code>A</code>, and you would like the interpreter on <code>B</code>'s files to use the compiled code in <code>libA.so</code>? That sounds a bit like <a href=\"https://github.com/leanprover/lake/pull/47\">leanprover/lake#47</a> which seems on hold, however.</p>\n</blockquote>\n<p>Yes indeed I mean this. For example one package may have a tactic which I want to use in the other.</p>",
        "id": 285848795,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1655049019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> In that case, you should be happy to know that  my primary goal for this coming week is to support precompiling modules (i.e., <a href=\"https://github.com/leanprover/lake/pull/47\">leanprover/lake#47</a>).</p>",
        "id": 285853635,
        "sender_full_name": "Mac",
        "timestamp": 1655055973
    },
    {
        "content": "<p>This is kind of vaguely related so I thought I would ask here. Is it possible to point a lakefile to multiple c files? Basically, I want to Lean files each which points to its own c file that it interacts with over the FFI. Is such a thing possible?</p>",
        "id": 285854757,
        "sender_full_name": "z battleman",
        "timestamp": 1655057656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285853635\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span> In that case, you should be happy to know that  my primary goal for this coming week is to support precompiling modules (i.e., <a href=\"https://github.com/leanprover/lake/pull/47\">leanprover/lake#47</a>).</p>\n</blockquote>\n<p>Indeed that is wonderful news.</p>",
        "id": 285870392,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1655081056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I have more questions :) Why the move away from functional package parameters like <code>(args)</code> to global variables?</p>",
        "id": 285950763,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655136083
    },
    {
        "content": "<p>And one more. Previously we specified explicitly which libraries to link in with <code>moreLibTargets</code>. In the new version, are the <code>extern_lib</code>s linked into every <code>lean_lib</code> and <code>lean_exe</code>? Is it possible to specify which libraries to link per-target?</p>",
        "id": 285952860,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655136922
    },
    {
        "content": "<p>In a similar vein, should <code>require</code> really be global (per workspace) instead of being scoped to libraries? For example, there might be a separate library containing all tests, which alone should depend on a test framework.</p>",
        "id": 285953121,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655137039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285950763\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> Why the move away from functional package parameters like <code>(args)</code> to global variables?</p>\n</blockquote>\n<p>As mentioned in the <a href=\"https://github.com/leanprover/lake/releases/tag/v3.1.0\">release notes</a>, making it a global macro makes it easier to use across targets. I think adding parameters to every target would be annoying.</p>",
        "id": 285962616,
        "sender_full_name": "Mac",
        "timestamp": 1655141124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285952860\">said</a>:</p>\n<blockquote>\n<p>And one more. Previously we specified explicitly which libraries to link in with <code>moreLibTargets</code>. In the new version, are the <code>extern_lib</code>s linked into every <code>lean_lib</code> and <code>lean_exe</code>? Is it possible to specify which libraries to link per-target?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/285953121\">said</a>:</p>\n<blockquote>\n<p>In a similar vein, should <code>require</code> really be global (per workspace) instead of being scoped to libraries? For example, there might be a separate library containing all tests, which alone should depend on a test framework.</p>\n</blockquote>\n<p>Yes, as with the original <code>moreLibTargets</code> and <code>dependencies</code>, every <code>extern_lib</code> and <code>require</code> is applied globally. However, scoping them locally to a given target is a future planned feature.</p>",
        "id": 285963470,
        "sender_full_name": "Mac",
        "timestamp": 1655141540
    },
    {
        "content": "<blockquote>\n<p>Yes, as with the original <code>moreLibTargets</code> and dependencies, every <code>extern_lib</code> and require is applied globally. However, scoping them locally to a given target is a future planned feature.</p>\n</blockquote>\n<p>This would be very useful. While on this topic, maybe it would make sense to commit to the separation entirely and make the compilation-related fields — <code>moreLeancArgs</code>/<code>moreLinkArgs</code>/<code>supportInterpreter</code>/etc — all per-target fields rather than parts of <code>PackageConfig</code> — it sounds like now the <code>package</code> has become more of a metadata statement about the source / build directory locations, and maybe in the future it will include author/website/version/etc, whereas the targets deal with compilation.</p>",
        "id": 286014016,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655174589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/286014016\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Yes, as with the original <code>moreLibTargets</code> and dependencies, every <code>extern_lib</code> and require is applied globally. However, scoping them locally to a given target is a future planned feature.</p>\n</blockquote>\n<p>This would be very useful. </p>\n</blockquote>\n<p>I can see how it could be eventually, but I am surprised you feel that strongly about it now. I don't really see many use cases for fine-grained dependency management at the moment. But maybe I am missing something obvious.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/286014016\">said</a>:</p>\n<blockquote>\n<p>While on this topic, maybe it would make sense to commit to the separation entirely and make the compilation-related fields — <code>moreLeancArgs</code>/<code>moreLinkArgs</code>/<code>supportInterpreter</code>/etc — all per-target fields rather than parts of <code>PackageConfig</code> — it sounds like now the <code>package</code> has become more of a metadata statement about the source / build directory locations, and maybe in the future it will include author/website/version/etc, whereas the targets deal with compilation.</p>\n</blockquote>\n<p>Part of this is already done: <code>moreLinkArgs</code> and <code>supportInterpreter</code> have already been moved to targets.  I did not move <code>moreLeancArgs</code> and, most importantly, <code>moreLeanArgs</code> because  I was not sure if compiling Lean modules with different options in same library was entirely safe (i.e., whether it could lead to potential incompatibilities between them).  Also, if all (or multiple) targets share the same options it could be annoying to copy them to each one. One solution I am considering is to have both a package-wide field and a per target field and then combine the two when building.</p>",
        "id": 286015687,
        "sender_full_name": "Mac",
        "timestamp": 1655176470
    },
    {
        "content": "<blockquote>\n<p>I don't really see many use cases for fine-grained dependency management at the moment.</p>\n</blockquote>\n<p>For example, you may want to compile with two different implementations of a numerical library. However, it doesn't seem like I need this feature for anything at the moment, so you are right, the \"very useful\" was exaggerated :)</p>",
        "id": 286017109,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655178004
    },
    {
        "content": "<blockquote>\n<p>I was not sure if compiling Lean modules with different options in same library was entirely safe</p>\n</blockquote>\n<p>No less than doing so in different libraries, I believe <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 286032939,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655192430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/286032939\">said</a>:</p>\n<blockquote>\n<p>No less than doing so in different libraries, I believe <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>\n</blockquote>\n<p>Yeah, I was also thinking about that. Is it a problem? I could move the options from being package-wide to workspace-wide and thus avoid any possibility of incompatibility. I just don't know enough about the risks to know which direction would be better to take. That is, should I move towards target-local scoping of options or move towards workspace-global scoping?</p>",
        "id": 286034426,
        "sender_full_name": "Mac",
        "timestamp": 1655193423
    },
    {
        "content": "<p>Does workspace-global include remote dependencies?</p>",
        "id": 286035316,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655193956
    },
    {
        "content": "<p>I can't think of any unsafe options other than some <code>#define</code>s that break the ABI, and in that case you're already in trouble with compatibility with the stdlib. So I don't think this is a big concern right now.</p>",
        "id": 286035667,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655194188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/286035316\">said</a>:</p>\n<blockquote>\n<p>Does workspace-global include remote dependencies?</p>\n</blockquote>\n<p>Yes it does.</p>",
        "id": 286035942,
        "sender_full_name": "Mac",
        "timestamp": 1655194364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/286035667\">said</a>:</p>\n<blockquote>\n<p>I can't think of any unsafe options other than some <code>#define</code>s that break the ABI, and in that case you're already in trouble with compatibility with the stdlib. So I don't think this is a big concern right now.</p>\n</blockquote>\n<p>So are you saying that target-local flags should likely be fine both for <code>leanc</code> and <code>lean</code>?</p>",
        "id": 286036102,
        "sender_full_name": "Mac",
        "timestamp": 1655194446
    },
    {
        "content": "<p>Yes. Though there certainly are options that are <em>desirable</em> to be passed upstream, such as a debug compile profile.</p>",
        "id": 286036304,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655194574
    },
    {
        "content": "<p>What would be the best way to generate one binary per file in a certain directory? Should I write a command elaboration that would crawl that directory and generate bunch of <code>lean_exe</code> commands?</p>",
        "id": 293094806,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660305970
    },
    {
        "content": "<p>We are kind of doing it in LSpec: <a href=\"https://github.com/yatima-inc/LSpec#setting-up-a-testing-infra\">https://github.com/yatima-inc/LSpec#setting-up-a-testing-infra</a><br>\nBut it expects the user to edit the lakefile accordingly</p>",
        "id": 293098625,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660307304
    },
    {
        "content": "<p>Yeah I do not want to edit lakefile manually.</p>",
        "id": 293099431,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660307610
    },
    {
        "content": "<p>I thought about empowering LSpec to be able to make editions on the lakefile for the user but turns out the editions may not be trivial, as shown in this example: <a href=\"https://github.com/yatima-inc/yatima-lang/blob/main/lakefile.lean#L36-L40\">https://github.com/yatima-inc/yatima-lang/blob/main/lakefile.lean#L36-L40</a></p>",
        "id": 293100324,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660307965
    },
    {
        "content": "<p>The non-trivial part is that you need to turn on interpreter?</p>",
        "id": 293100580,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660308034
    },
    {
        "content": "<p>That's one example, but who knows what it might take to run some crazy tests some users may create. For example, one might want to test some FFI implementation with highly specific build parameters. And that's not even an unlikely scenario</p>",
        "id": 293101494,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660308379
    },
    {
        "content": "<p>My use case it for scripting in Houdini. Every script should create a new library so they should be all the same from the build perspective.</p>",
        "id": 293102073,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660308618
    },
    {
        "content": "<p>Here's a crazy hack: make a Lake script that edits the lakefile itself, generating the <code>lean_exe</code> lines for you</p>",
        "id": 293102730,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660308853
    },
    {
        "content": "<p>Just gotta be careful not to add the same line twice</p>",
        "id": 293102911,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660308920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/293102730\">said</a>:</p>\n<blockquote>\n<p>Here's a crazy hack: make a Lake script that edits the lakefile itself, generating the <code>lean_exe</code> lines for you</p>\n</blockquote>\n<p>Before I attempt doing that I will keep on browsing through the meta-programming book and hopefully figure something else out :)</p>",
        "id": 293103544,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660309149
    },
    {
        "content": "<p>When I add this to my lakefile</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"#lean_exe_generate\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lean_exe</span> <span class=\"n\">Main1</span><span class=\"o\">))</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lean_exe</span> <span class=\"n\">Main2</span><span class=\"o\">))</span>\n\n<span class=\"bp\">#</span><span class=\"n\">lean_exe_generate</span>\n</code></pre></div>\n<p>and run <code>lake build Main1</code> I get an error <code>error: unknown target 'Main' </code></p>\n<p>Why is that happening?</p>",
        "id": 293108337,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660310757
    },
    {
        "content": "<p>Dunno, but ctrl-clicking on <code>lean_exe</code> and trying to mimic that (instead of calling <code>lean_exe</code>) might take you further</p>",
        "id": 293110775,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660311526
    },
    {
        "content": "<p>Interesting, changing to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"#lean_exe_generate\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">@[leanExe]</span>  <span class=\"kd\">def</span> <span class=\"n\">Main1</span> <span class=\"o\">:</span> <span class=\"n\">Lake.LeanExeConfig</span> <span class=\"o\">:=</span>  <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Main1</span><span class=\"o\">}</span> <span class=\"o\">))</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">@[leanExe]</span>  <span class=\"kd\">def</span> <span class=\"n\">Main2</span> <span class=\"o\">:</span> <span class=\"n\">Lake.LeanExeConfig</span> <span class=\"o\">:=</span>  <span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Main2</span><span class=\"o\">}</span> <span class=\"o\">))</span>\n</code></pre></div>\n<p>now I get <code>Building Main1</code> and oleans are created but I'm not getting <code>Compling Main1</code> and <code>Linking Main1</code></p>",
        "id": 293112777,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660312262
    },
    {
        "content": "<p>Please let me know if you succeed <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 293199623,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660341442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/building.20multiple.20binaries/near/293108337\">said</a>:</p>\n<blockquote>\n<p>When I add this to my lakefile</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"#lean_exe_generate\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lean_exe</span> <span class=\"n\">Main1</span><span class=\"o\">))</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lean_exe</span> <span class=\"n\">Main2</span><span class=\"o\">))</span>\n\n<span class=\"bp\">#</span><span class=\"n\">lean_exe_generate</span>\n</code></pre></div>\n<p>and run <code>lake build Main1</code> I get an error <code>error: unknown target 'Main' </code></p>\n<p>Why is that happening?</p>\n</blockquote>\n<p>Hygiene. Lean will transform the <code>Main1</code>/<code>Main2</code> into some cryptic hygienic identifier. If you want to use raw identifiers either use <code>$(mkIdent `Main1)</code> to create an unhygienic identifier manually or turn hygiene off with <code>set_option hygiene false</code>.</p>",
        "id": 293211690,
        "sender_full_name": "Mac",
        "timestamp": 1660349436
    },
    {
        "content": "<p>Note that you can also run <code>CommandElabM</code> directly now via <code>#eval</code>, so you may not even need to create the custom syntax.</p>",
        "id": 293211742,
        "sender_full_name": "Mac",
        "timestamp": 1660349512
    },
    {
        "content": "<p>Great! got it working. This code in lakefile creates one executable for each file <code>Tests/*.lean</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lean_exe_generate</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">dirName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Tests\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">dir</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">IO.currentDir</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">dirName</span>\n  <span class=\"n\">for</span> <span class=\"n\">file</span> <span class=\"k\">in</span> <span class=\"bp\">←</span> <span class=\"n\">dir.readDir</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">file.path.extension</span> <span class=\"bp\">=</span> <span class=\"s2\">\"lean\"</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">file.path.fileStem.get</span><span class=\"bp\">!</span>\n      <span class=\"k\">let</span> <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkStrLit</span> <span class=\"o\">(</span><span class=\"n\">dirName</span> <span class=\"bp\">++</span> <span class=\"s2\">\"/\"</span> <span class=\"bp\">++</span> <span class=\"n\">file.path.fileStem.get</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n      <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lean_exe</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">{</span> <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">root</span> <span class=\"o\">}))</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">lean_exe_generate</span>\n</code></pre></div>",
        "id": 293725161,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1660658912
    },
    {
        "content": "<p>This looks nice! I might incorporate this trick in the LSpec README someday. But it would also need a way to recursively search directories (not a big issue)</p>",
        "id": 293727610,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660659754
    },
    {
        "content": "<p>It's easily doable with <a href=\"https://github.com/yatima-inc/LSpec/blob/main/Main.lean#L3-L15\">this function</a>, which only God knows how many times I've copied throughout several repos</p>\n<p>Offtopic: would it be worth PR'ing this function to the <code>System</code> API? I have replicated it too many times already. It can of course be generalized to accept a custom extension instead of being fixed on \"lean\".<br>\nWould any maintainer endorse it?</p>",
        "id": 293729087,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1660660179
    }
]
[
    {
        "content": "<p>I'm trying to prove termination on a function on an inductively-defined type. The problem is that my function uses higher-order functions, e.g. <code>map</code>, for which it seems Lean (understandably) doesn't know that they are well-behaved w.r.t induction. Here's an MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TreeNode</span> <span class=\"o\">:=</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TreeNode</span> <span class=\"k\">in</span> <span class=\"kd\">def</span> <span class=\"n\">treeToList</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">name</span><span class=\"o\">]</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">name</span> <span class=\"o\">::</span> <span class=\"n\">List.join</span> <span class=\"o\">(</span><span class=\"n\">children.map</span> <span class=\"n\">treeToList</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here, Lean won't be able to prove termination. Obviously, I can just add <code>partial</code> and be done with it, but I don't want to, for obvious reasons. For this simple example I can also just rewrite it to do it \"manually\", e.g. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">TreeNode</span> <span class=\"k\">in</span> <span class=\"kd\">def</span> <span class=\"n\">treeToList</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">name</span><span class=\"o\">]</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">treeToList</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">treeToList</span> <span class=\"n\">c</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">name</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But I guess it kind of breaks the point of using higher-order-functions if I can't use them for programming. This seems to be a pattern that should be common, so I'm hoping someone else has encountered it before. Is there a nice way to deal with it?</p>\n<p>I also tried defining the depth of my inductive type to prove termination using well-founded recursion, but I can't figure out what I'm doing wrong there :/  If I write something like: <br>\n<code>termination_by _ =&gt; t.depth</code>, I get a message that says <code>unexpected occurrence of recursive application</code>. For this MWE it would look something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">TreeNode</span> <span class=\"k\">in</span> <span class=\"kd\">def</span> <span class=\"n\">TreeNode.depth</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">::</span><span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">rest</span><span class=\"o\">))</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">_</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TreeNode</span> <span class=\"k\">in</span> <span class=\"kd\">def</span> <span class=\"n\">treeToList</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">name</span><span class=\"o\">]</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">name</span> <span class=\"o\">::</span> <span class=\"n\">List.join</span> <span class=\"o\">(</span><span class=\"n\">children.map</span> <span class=\"n\">treeToList</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t.depth</span>\n</code></pre></div>\n<p>and that tells me </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unexpected</span> <span class=\"n\">occurrence</span> <span class=\"n\">of</span> <span class=\"n\">recursive</span> <span class=\"n\">application</span>\n  <span class=\"n\">treeToList</span>\n</code></pre></div>\n<p>(and won't let me prove it's actually decreasing with <code>decreasing_by</code> either, it seems to break already with the line above).</p>\n<p>Can someone help me understand what I'm doing wrong and/or even point me to how to deal with this pattern more generally (using higher-order functions on inductively-defined types)? Thanks!</p>",
        "id": 275174999,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647205473
    },
    {
        "content": "<p>I think using well-founded recursion is the right move in general, but a limitation is that you must actually <em>apply</em> the function recursively (not pass it to a HOF)</p>",
        "id": 275175103,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647205621
    },
    {
        "content": "<p>So here if you do <code>children.map (fun T =&gt; treeToList T)</code> it should give a better error message</p>",
        "id": 275175118,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647205648
    },
    {
        "content": "<p>In particular that you need to prove the <code>T</code> there has depth &lt; the depth of <code>t</code></p>",
        "id": 275175175,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647205688
    },
    {
        "content": "<p>(And doing that is also hard in general, but my first instinct would be to somehow map <code>children</code> to a list of children with proof that their depths are strictly smaller?)</p>",
        "id": 275175217,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647205801
    },
    {
        "content": "<p>interesting, yes, that extra lambda there actually helps, thanks! it's kind of strange that it would need that <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> <br>\n<span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275175118\">said</a>:</p>\n<blockquote>\n<p>So here if you do <code>children.map (fun T =&gt; treeToList T)</code> it should give a better error message</p>\n</blockquote>",
        "id": 275175302,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647205870
    },
    {
        "content": "<p>Yeah...  Lean won't do the eta expansion automatically, and also requires that recursive calls are fully applied.</p>\n<p>The error message is pretty unhelpful there, it might be worth improving? <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span></p>",
        "id": 275175448,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647206112
    },
    {
        "content": "<p>The error message after that eta expansion is much more helpful! I'm pretty puzzled by the proof obligation term though :/ In my actual example it has some <code>sorryAx</code>. In the MWE I was using here it doesn't, but it's still pretty confusing: it doesn't seem to have the equality of the pattern match:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">:</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"k\">have</span><span class=\"bp\">`-</span><span class=\"n\">expressions</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"n\">remaining</span> <span class=\"n\">goals</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">different</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">decreasing_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specity</span> <span class=\"n\">your</span> <span class=\"n\">own</span> <span class=\"n\">tactic</span> <span class=\"n\">for</span> <span class=\"n\">discharging</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">goal</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">depth</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think I might not quite understand the input to <code>decreasing_by</code>, I thought it was a function of the inputs to some type that has a well-founded relation? But why won't it understand that the input <code>t : TreeNode</code> in this simple example here is the same as the pattern-matched <code>mkNode name children</code>?</p>",
        "id": 275176517,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647207867
    },
    {
        "content": "<p>by the way, when copy-pasting that Zulip noticed there's a typo there (specity -&gt; specify), seems to come from <a href=\"https://github.com/leanprover/lean4/blob/fa0964c07e70bd3ad546a18d9c450c9c27d29920/src/Init/WFTactics.lean#L24\">https://github.com/leanprover/lean4/blob/fa0964c07e70bd3ad546a18d9c450c9c27d29920/src/Init/WFTactics.lean#L24</a> <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span></p>",
        "id": 275176676,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647208100
    },
    {
        "content": "<p><code>t</code> is the element of <code>children</code>. <code>decreasing_by</code> is where you provide a proof that <code>depth t &lt; depth (mkNode name children)</code>, <code>termination_by</code> is where you specify what relation you want to use.</p>",
        "id": 275176699,
        "sender_full_name": "Chris B",
        "timestamp": 1647208155
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228466\">@Chris B</span> how do you know that <code>t</code> is an element of <code>children</code>?  where does it say that?</p>",
        "id": 275176847,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647208339
    },
    {
        "content": "<p>I thought you were using  the eta expanded<code>(fun t =&gt; treeToList t)</code>, my bad. What is the definition you're working with now?</p>",
        "id": 275176952,
        "sender_full_name": "Chris B",
        "timestamp": 1647208502
    },
    {
        "content": "<p>You can preserve a hypothesis about the matched element with  <code>match ht:t with</code>.</p>",
        "id": 275176961,
        "sender_full_name": "Chris B",
        "timestamp": 1647208523
    },
    {
        "content": "<p>Yep, you're right about that! I am using that eta expanded <code>(fun t =&gt; treeToList t)</code>.  The problem is then that it's not in my hypotheses then in <code>decreasing_by</code>. That's a great suggestion, preserving it with the <code>match ht:t with</code>, thanks! That actually shows that indeed it wants me to prove two entirely unrelated terms to be decreasing. It then shows as: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span>\n<span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">depth</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 275177472,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647209101
    },
    {
        "content": "<p>There seems to be something strange going on there :/ if I try to do an induction over <code>t</code>, it will then again relate the two to each other, but in a way that doesn't make sense.  This seems really confusing, is that maybe a hygiene bug? Concretely, the code: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">TreeNode</span> <span class=\"k\">in</span> <span class=\"kd\">def</span> <span class=\"n\">treeToList</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n <span class=\"k\">match</span> <span class=\"n\">ht</span><span class=\"o\">:</span><span class=\"n\">t</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">name</span><span class=\"o\">]</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">name</span> <span class=\"o\">::</span> <span class=\"n\">List.join</span> <span class=\"o\">(</span><span class=\"n\">children.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">treeToList</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">treeToList</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TreeNode.depth</span> <span class=\"n\">t</span>\n<span class=\"n\">decreasing_by</span> <span class=\"o\">{</span>\n<span class=\"n\">simp_wf</span>\n<span class=\"n\">induction</span> <span class=\"n\">t</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>will give this state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsolved</span> <span class=\"n\">goals</span>\n<span class=\"n\">case</span> <span class=\"n\">mkLeaf</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkLeaf</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span><span class=\"o\">)</span>\n\n<span class=\"n\">case</span> <span class=\"n\">mkNode</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span>\n<span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">children_ih</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m.40538</span> <span class=\"n\">children</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span><span class=\"o\">)</span>\n\n<span class=\"n\">case</span> <span class=\"n\">nil</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span>\n<span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">?</span><span class=\"n\">m.40538</span> <span class=\"o\">[]</span>\n\n<span class=\"n\">case</span> <span class=\"n\">cons</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span>\n<span class=\"n\">t</span> <span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">head_ih</span> <span class=\"o\">:</span> <span class=\"n\">depth</span> <span class=\"n\">head</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span><span class=\"o\">)</span>\n<span class=\"n\">tail_ih</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m.40538</span> <span class=\"n\">tail</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">?</span><span class=\"n\">m.40538</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And why does it also have cases for <code>t</code> being a <code>List TreeNode</code>?</p>",
        "id": 275177744,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647209445
    },
    {
        "content": "<p>Hrm, this isn't a bug, but there's a lot of complexity here. If you write <code>decreasing_by sorry</code> you can see the proof obligation there, and it should be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">depth</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"n\">t</span><span class=\"bp\">✝</span>\n</code></pre></div>",
        "id": 275183671,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647217972
    },
    {
        "content": "<p>We don't have any useful information in context because, a priori, the <code>t</code> in the lambda could be arbitrary. You have to find a way to communicate to within the lambda that the depth of <code>t</code> in the lambda is strictly smaller, i.e. that <code>map</code> only calls the function on elements of the list</p>",
        "id": 275183759,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647218130
    },
    {
        "content": "<p>This definition (not in Std) might be helpful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">def</span> <span class=\"n\">List.map_sub</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">//</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>      <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"n\">ts</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">Mem.head</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span> <span class=\"o\">::</span>\n    <span class=\"n\">map_sub</span> <span class=\"n\">ts</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">mem</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">Mem.tail</span> <span class=\"n\">_</span> <span class=\"n\">mem</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>which lets you subtype the members of a list by some property (e.g. having depth less than the parent node). Then you would have access to a proof of that property within the lambda that you make the recursive call at.</p>\n<p>This might be a terrible way to go about it though, I'm not sure.</p>",
        "id": 275184627,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647219455
    },
    {
        "content": "<p>The easier way to do this would be to index your NodeTree type on its depth, but I don't think that's a good solution either.</p>",
        "id": 275184831,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647219673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275183671\">said</a>:</p>\n<blockquote>\n<p>Hrm, this isn't a bug, but there's a lot of complexity here. If you write <code>decreasing_by sorry</code> you can see the proof obligation there, and it should be something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">depth</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"n\">t</span><span class=\"bp\">✝</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Oh I just saw you had sent this already <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> sorry</p>",
        "id": 275184885,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647219726
    },
    {
        "content": "<p>Oh, another way to get this to prove termination is via a mutually recursive definition, where you have a mutually recursive definition that essentially computes <code>children.map treeToList</code> but by explicitly recursing on <code>children</code></p>",
        "id": 275184971,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647219904
    },
    {
        "content": "<p>But I really don't like that solution, because rewriting map is annoying.</p>",
        "id": 275184979,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647219935
    },
    {
        "content": "<p>I mean, the <code>TreeNode</code> example is just the simplest example that shows the problem. I can't imagine this is a very far-fetched pattern here, but I'm starting to think there might be some problem in Lean underlying this. Perhaps because <code>List</code> is itself an inductive type? If I try to compute the simplest example it already breaks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#reduce</span> <span class=\"n\">TreeNode.depth</span> <span class=\"o\">(</span><span class=\"n\">TreeNode.mkNode</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">[</span><span class=\"n\">TreeNode.mkLeaf</span> <span class=\"s2\">\"bar\"</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>will yield: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">maximum</span> <span class=\"n\">recursion</span> <span class=\"n\">depth</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">reached</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"bp\">`</span><span class=\"kd\">set_option</span> <span class=\"n\">maxRecDepth</span> <span class=\"bp\">&lt;</span><span class=\"n\">num</span><span class=\"bp\">&gt;`</span> <span class=\"n\">to</span> <span class=\"n\">increase</span> <span class=\"n\">limit</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Even though the individual patterns all work well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#reduce</span> <span class=\"n\">TreeNode.depth</span> <span class=\"o\">(</span><span class=\"n\">TreeNode.mkLeaf</span> <span class=\"s2\">\"bar\"</span><span class=\"o\">)</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">TreeNode.depth</span> <span class=\"o\">(</span><span class=\"n\">TreeNode.mkNode</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">[])</span>\n<span class=\"k\">#reduce</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">TreeNode.depth</span> <span class=\"o\">(</span><span class=\"n\">TreeNode.mkLeaf</span> <span class=\"s2\">\"bar\"</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">TreeNode.depth</span> <span class=\"o\">(</span><span class=\"n\">TreeNode.mkNode</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">[]))</span>\n</code></pre></div>",
        "id": 275184983,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647219947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275184983\">said</a>:</p>\n<blockquote>\n<p>I can't imagine this is a very far-fetched pattern here, but I'm starting to think there might be some problem in Lean underlying this. Perhaps because <code>List</code> is itself an inductive type? </p>\n</blockquote>\n<p>This construction is called a nested inductive and it is indeed more complex than a regular inductive. Lean 4 has much better fundamental support for nested and mutual inductives than lean 3, and the developers have said that making these usable is one of their goals. While the kernel stuff is in place, I think they've mentioned elsewhere that polishing this part of the developer experience is further back in the queue (your example also uses well-founded recursion, which is in the same boat). Keep in mind you're using software that has not seen its first official stable release.</p>",
        "id": 275185454,
        "sender_full_name": "Chris B",
        "timestamp": 1647220675
    },
    {
        "content": "<p>The <code>#reduce</code> example works for me on <code>m3</code> by the way.</p>",
        "id": 275185531,
        "sender_full_name": "Chris B",
        "timestamp": 1647220749
    },
    {
        "content": "<p>Sure, I'm aware it's WIP! I'm not complaining at all, just trying to understand things :) thanks for the pointer to nested inductives.</p>",
        "id": 275185697,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647221017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275185531\">said</a>:</p>\n<blockquote>\n<p>The <code>#reduce</code> example works for me on <code>m3</code> by the way.</p>\n</blockquote>\n<p>interesting! sorry, what's <code>m3</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> ?</p>",
        "id": 275185752,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647221083
    },
    {
        "content": "<p>I didn't take it as a complaint, just saying \"it will probably work better in the near future\". <code>m3</code> is  milestone3, the version of lean; v4.0.0-m3.</p>",
        "id": 275185820,
        "sender_full_name": "Chris B",
        "timestamp": 1647221183
    },
    {
        "content": "<p>huh, interesting, it doesn't work with the latest nightly for me</p>",
        "id": 275186043,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647221535
    },
    {
        "content": "<p>(which I guess it does hint at a bug)</p>",
        "id": 275186126,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647221701
    },
    {
        "content": "<p>Also <code>#reduce</code> uses the kernel (which is very slow), if you use <code>#eval</code> it'll likely execute fine</p>",
        "id": 275186363,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647222119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275177472\">said</a>:</p>\n<blockquote>\n<p>Yep, you're right about that! I am using that eta expanded <code>(fun t =&gt; treeToList t)</code>.  The problem is then that it's not in my hypotheses then in <code>decreasing_by</code>. That's a great suggestion, preserving it with the <code>match ht:t with</code>, thanks! That actually shows that indeed it wants me to prove two entirely unrelated terms to be decreasing. It then shows as: </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span>\n<span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span>\n<span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">depth</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">depth</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This goal is not provable, and this is basically why lean has trouble with using <code>List.map</code> in this way. <code>List.map</code> takes a function on all trees, so you can't do a recursive call because you don't know that the tree it is being called on is related to the list you are mapping. You need to use something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pmap\">docs#list.pmap</a> instead (not sure whether this exists in lean4 / mathlib4 yet)</p>",
        "id": 275188648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647225543
    },
    {
        "content": "<p>that's insightful, thanks! is that a fundamental problem (i.e. it wouldn't work because of the underlying type theory and nested inductives or something), or is it more an engineering one (it's just hard to create the right goal in this context and they developers have not come to that yet)?</p>",
        "id": 275208151,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1647248494
    },
    {
        "content": "<p>Coq and Agda both support nested inductives, in the sense that the example in your initial post would compile as-is. So it's not a problem with the type theory but 'just' requires lots of engineering.</p>",
        "id": 275211598,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1647250507
    },
    {
        "content": "<p>Thanks for pointing out the typos and poor error messages. We are going to improve them.</p>\n<p>Here is the approach we are going to use in Lean to make this king of example easy to write:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/combinatorsAndWF.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/combinatorsAndWF.lean</a><br>\nIt includes a very similar example.</p>\n<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> Recall that both Coq and Agda include a termination checker in the kernel, and a lot of engineering is only really needed in Lean.</p>",
        "id": 275253508,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647272218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20higher-order.20functions.20on.20inductive.20types.3A.20termination/near/275253508\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> Recall that both Coq and Agda include a termination checker in the kernel, and a lot of engineering is only really needed in Lean.</p>\n</blockquote>\n<p>Yes, absolutely. I appreciate that you're keeping a lot of complexity out of the kernel with this approach.</p>",
        "id": 275255575,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1647273071
    },
    {
        "content": "<p>BTW, the <code>for in do</code> notation already has support for <code>for h : c in cs do ...</code> where <code>h : c ∈ cs</code>.  It is not very convenient for this example because it is pure code, but we can write it as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TreeNode</span> <span class=\"o\">:=</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TreeNode</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">treeToList</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkLeaf</span> <span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">name</span><span class=\"o\">]</span>\n <span class=\"bp\">|</span> <span class=\"n\">mkNode</span> <span class=\"n\">name</span> <span class=\"n\">children</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">name</span><span class=\"o\">]</span>\n   <span class=\"n\">for</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">child</span> <span class=\"k\">in</span> <span class=\"n\">children</span> <span class=\"k\">do</span>\n     <span class=\"c1\">-- We will not this the following `have` in the future</span>\n     <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">child</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">name</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">children</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_trans</span> <span class=\"o\">(</span><span class=\"n\">List.sizeOf_lt_of_mem</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp_arith</span><span class=\"o\">)</span>\n     <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"n\">treeToList</span> <span class=\"n\">child</span>\n   <span class=\"n\">return</span> <span class=\"n\">r</span>\n</code></pre></div>",
        "id": 275258119,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647273924
    }
]
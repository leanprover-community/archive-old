[
    {
        "content": "<p>Background:</p>\n<p>I am writing a Lean4 DSL for my modeling language, the Ontological Modeling Language, which I would like to define as a subset of the OWL2-DL description logic: <a href=\"https://github.com/opencaesar/oml\">https://github.com/opencaesar/oml</a></p>\n<p>Unlike a programming language DSL where it would be sensible to embed the DSL as Lean expressions, this is a different kind of DSL problem in that the semantics of the language is a kind of logic, not executable program. So, what matters here is computing logical consistency, entailments, subsumption, ...</p>\n<p>I have made baby steps using a monadic style -- thanks so much for the books/doc in progress; it's been hugely helpful!</p>\n<p>My problem:</p>\n<p>I have several monads that I wrote to resolve OML syntax into an intermediate representations (logical axioms).<br>\nFor details, see: <a href=\"https://github.com/NicolasRouquette/oml.lean4\">https://github.com/NicolasRouquette/oml.lean4</a></p>\n<p>I have these definitions of context (input OML syntax) &amp; state (logical axioms)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">MCore</span> <span class=\"o\">:=</span> <span class=\"n\">EStateM</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">M</span>     <span class=\"o\">:=</span> <span class=\"n\">ReaderT</span> <span class=\"n\">Context</span> <span class=\"n\">MCore</span>\n</code></pre></div>\n<p>In <a href=\"https://github.com/NicolasRouquette/oml.lean4/blob/master/src/Oml/Resolver.lean\">https://github.com/NicolasRouquette/oml.lean4/blob/master/src/Oml/Resolver.lean</a>, there are a few toplevel resolvers to analyze the input OML syntax from the context and update the state of logical axioms:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularyDeclarations</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vocabularies.foldlM</span> <span class=\"n\">validateVocabularyDeclaration</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">validateVocabularyStatementDeclarations</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vocabularies.foldlM</span> <span class=\"n\">validateStatementDeclarationsIn</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vocabularies.foldlM</span> <span class=\"n\">validateVocabularySpecializationsIn</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I wrote tests to exercise these resolver monads in <a href=\"https://github.com/NicolasRouquette/oml.lean4/blob/master/src/Oml/testResolver.lean\">https://github.com/NicolasRouquette/oml.lean4/blob/master/src/Oml/testResolver.lean</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">c1</span> <span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">vocabularies</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">testSyntax.rdfs</span><span class=\"o\">,</span> <span class=\"n\">testSyntax.xsd</span><span class=\"o\">,</span> <span class=\"n\">testSyntax.base</span><span class=\"o\">,</span> <span class=\"n\">testSyntax.mission</span> <span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">s0</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">r1a</span> <span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">validateVocabularyDeclarations</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c1</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s0</span>\n</code></pre></div>\n<p>Next, I need to get the result of the above and run <code>validateVocabularyStatementDeclarations</code>.</p>\n<p>This is where things get a wee bit ugly:</p>\n<p>One way is to extract the result, assuming it is OK and run the next resolver.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">s1</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">r1a</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">EStateM.Result.ok</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{}</span>\n<span class=\"kd\">def</span> <span class=\"n\">r1b</span> <span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">validateVocabularyStatementDeclarations</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c1</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s2</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">r1b</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">EStateM.Result.ok</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{}</span>\n<span class=\"kd\">def</span> <span class=\"n\">r1c</span> <span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">validateVocabularySpecializations</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c1</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s2</span>\n</code></pre></div>\n<p>Surely, there must be better way to compose these monads; though it is unclear to me how to do this.</p>\n<p>I managed to two monads successfully, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularyStatementDeclarations'</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"bp\">←</span> <span class=\"n\">read</span>\n  <span class=\"n\">validateVocabularyDeclarations</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">c.vocabularies.foldlM</span> <span class=\"n\">validateStatementDeclarationsIn</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This allows me to write instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">r1b'</span> <span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">validateVocabularyStatementDeclarations'</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c1</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s0</span>\n</code></pre></div>\n<p>But this does not to work for composing 3 monads:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations'</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"bp\">←</span> <span class=\"n\">read</span>\n  <span class=\"n\">validateVocabularyDeclarations</span>\n  <span class=\"bp\">&gt;&gt;=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">c.vocabularies.foldlM</span> <span class=\"n\">validateStatementDeclarationsIn</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"bp\">&gt;&gt;=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">c.vocabularies.foldlM</span> <span class=\"n\">validateVocabularySpecializationsIn</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It seems that it is running the 1st and 3rd, skipping the 2nd.</p>\n<p>What would be a better way to write this?</p>",
        "id": 318528473,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672379347
    },
    {
        "content": "<blockquote>\n<p>Unlike a programming language DSL where it would be sensible to embed the DSL as Lean expressions, this is a different kind of DSL problem in that the semantics of the language is a kind of logic, not executable program. So, what matters here is computing logical consistency, entailments, subsumption, ...</p>\n</blockquote>\n<p>Just regarding this point: it doesn't really matter what your DSL represents, since it's basically going to facilitate turning expressions into syntax that you can do whatever with. There isn't any special attention paid to syntax that represents executable programs when we are talking about a custom DSL - it all just turns into an AST</p>",
        "id": 318529098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672380027
    },
    {
        "content": "<p>As a terminological point, you aren't composing monads, you are composing monadic operations (using bind). Composing monads is stuff like <code>ReaderT r (StateT s (Except e m))</code></p>",
        "id": 318529261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672380209
    },
    {
        "content": "<p>The usual way to write your example is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations'</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"bp\">←</span> <span class=\"n\">read</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">s</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">validateVocabularyDeclarations</span>\n  <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">c.vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">s</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">validateStatementDeclarationsIn</span> <span class=\"n\">s</span> <span class=\"n\">x</span>\n  <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">c.vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">s</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">validateVocabularySpecializationsIn</span> <span class=\"n\">s</span> <span class=\"n\">x</span>\n  <span class=\"n\">pure</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>(I think - untested since there is no <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>)</p>",
        "id": 318529379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672380332
    },
    {
        "content": "<p>But this is a bit fishy, because you have <code>State</code> appearing twice: it is in the monad <code>M</code> (which wraps <code>MCore</code> which wraps a state monad over <code>State</code>) and it is also the return value of the function. This is most likely where the missing state is going</p>",
        "id": 318529468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672380398
    },
    {
        "content": "<p>If you want the state to be part of the monad, then you shouldn't be returning <code>M State</code>, it should be <code>M Unit</code> and you don't need to get <code>s</code> all the time</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations'</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">validateVocabularyDeclarations</span>\n  <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">c.vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">validateStatementDeclarationsIn</span> <span class=\"n\">x</span>\n  <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">c.vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">validateVocabularySpecializationsIn</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 318529510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672380461
    },
    {
        "content": "<p>Thanks for the terminology correction and the suggestions, which worked very well.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations'</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"bp\">←</span> <span class=\"n\">read</span>\n  <span class=\"n\">validateVocabularyDeclarations</span>\n  <span class=\"n\">for</span> <span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"n\">c.vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">validateStatementDeclarationsIn</span> <span class=\"n\">v</span>\n  <span class=\"n\">for</span> <span class=\"n\">v</span> <span class=\"k\">in</span> <span class=\"n\">c.vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">validateVocabularySpecializationsIn</span> <span class=\"n\">v</span>\n</code></pre></div>\n<p>Applying your suggestion to other functions, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularyDeclarations</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vocabularies</span> <span class=\"k\">do</span>\n    <span class=\"n\">validateVocabularyDeclaration</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I can further simplify it to just:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations''</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">validateVocabularyDeclarations</span>\n  <span class=\"n\">validateVocabularyStatementDeclarations</span>\n  <span class=\"n\">validateVocabularySpecializations</span>\n</code></pre></div>\n<p>This is really nice!</p>\n<p>For testing purposes, I am wondering what is the proper way to extract the monad's state outside of a<code>do</code>?</p>\n<p>With the above, I get nothing: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">r1c''</span><span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">validateVocabularySpecializations''</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c1</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">r1c''</span>\n</code></pre></div>\n<p>I know that I can write a simple accessor like this so that I can check the resulting state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">resolverGet</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">validateVocabularySpecializations''Get</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">validateVocabularySpecializations''</span>\n  <span class=\"n\">resolverGet</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">r1c2</span> <span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">validateVocabularySpecializations''Get</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c1</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">r1c2</span>\n</code></pre></div>\n<p>Is there a way to write the equivalent of <code>validateVocabularySpecializations''Get</code>without defining <code>resolverGet</code>?</p>",
        "id": 318650966,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672432101
    },
    {
        "content": "<p>I'm not sure what you mean by \"I get nothing\" there</p>",
        "id": 318651149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672432214
    },
    {
        "content": "<p>That result object should contain the final state; you can pattern match on it to get at it</p>",
        "id": 318651186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672432254
    },
    {
        "content": "<p>Oh right! I was a bit confused with the output:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">r1c''</span><span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">Exception</span> <span class=\"n\">State</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">validateVocabularySpecializations''</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">c1</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"n\">s0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">r1c''</span>\n<span class=\"c1\">-- EStateM.Result.ok ()</span>\n</code></pre></div>\n<p>Indeed, with pattern matching I can extract the state from the result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">s1c''</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">r1c''</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">EStateM.Result.ok</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{}</span>\n<span class=\"k\">#eval</span> <span class=\"n\">s1c''</span>\n<span class=\"c1\">-- { .... }</span>\n</code></pre></div>\n<p>Thanks!</p>",
        "id": 318653288,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1672433406
    }
]
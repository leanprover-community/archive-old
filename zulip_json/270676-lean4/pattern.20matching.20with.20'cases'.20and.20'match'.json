[
    {
        "content": "<p>Consider the following nine proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">case₁</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n              <span class=\"n\">exact</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">case₂</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n                  <span class=\"n\">exact</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">case₃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n           <span class=\"n\">exact</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">match₁</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n              <span class=\"n\">exact</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">match₂</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n                  <span class=\"n\">exact</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">match₃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n           <span class=\"n\">exact</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">term₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">term₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">term₃</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Of these, <code>case₁</code>, <code>match₂</code>, <code>match₃</code>, <code>term₂</code> and <code>term₃</code> are successful. <code>case₂</code>, <code>case₃</code>, <code>match₁</code> and <code>term₁</code> fail.</p>\n<p>If I precede the proofs with <code>open Nat</code> then <code>match₁</code> and <code>term₁</code> succeed. I can see why this would be the case, by opening <code>Nat</code> you get access to the unqualified names. But if that is the case, why does <code>case₁</code> succeed without <code>open Nat</code>.</p>\n<p>Also, why can I pattern match on <code>0</code> and <code>+1</code> in <code>match₃</code> and <code>term₃</code> but not in <code>case₃</code>.</p>",
        "id": 301189029,
        "sender_full_name": "Paul  Chisholm",
        "timestamp": 1664356939
    },
    {
        "content": "<p><code>cases</code> does not take a term, it takes an identifier followed by a list of names. The identifier refers to the bare constructor name (without the namespace) because it's actually coming from the name of one of the binders in the <code>T.recOn</code> recursor</p>",
        "id": 301201418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664361561
    },
    {
        "content": "<p>That's why you have to write <code>zero</code>, not <code>Nat.zero</code> or <code>0</code> (the latter is a syntax error because it's not an identifier, and the former just doesn't match the expected name which is unqualified <code>zero</code>).</p>",
        "id": 301201645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664361633
    },
    {
        "content": "<p>I agree that this syntax is a bit inconsistent with pattern matching elsewhere</p>",
        "id": 301201793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664361694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/pattern.20matching.20with.20'cases'.20and.20'match'/near/301201793\">said</a>:</p>\n<blockquote>\n<p>I agree that this syntax is a bit inconsistent with pattern matching elsewhere</p>\n</blockquote>\n<p>I had this discussion with <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> quite early. Leo's stance is that <code>cases</code> should be internally consistent with and without <code>using</code>. I tend to agree with you that external consistency with regular pattern matching is more important, especially since using <code>using</code> is not all that common.</p>",
        "id": 301202520,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664362007
    },
    {
        "content": "<p>Note that it gets more complicated if we also consider <code>induction</code>, which adds induction hypotheses on top of the constructor parameters, so it really isn't a regular pattern anymore. One proposal I had was to introduce the IH for a parameter <code>x</code> unhygienically as <code>x.ih</code>. But again this begs the question what it should look like with <code>using</code>. It could be resolved using a naming convention, e.g. if your custom recursor has parameters <code>x</code> and <code>x_ih</code> and only bind the former as <code>y</code>, the latter will be auto-introduced as <code>y.ih</code>. We didn't continue the discussion after that I believe though. If someone is motivated to resolve this, a comprehensive RFC would be great I'd say.</p>",
        "id": 301203310,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664362375
    },
    {
        "content": "<p>Thanks for the info. That makes sense. For tactical proofs, from a style perspective is one of <code>match</code> or <code>cases</code> preferred over the other?</p>",
        "id": 301205922,
        "sender_full_name": "Paul  Chisholm",
        "timestamp": 1664363319
    },
    {
        "content": "<p>Whichever fits your use case better. <code>match</code> can do nested pattern matching. <code>cases</code> can do case analysis without listing all constructors.</p>",
        "id": 301206222,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664363445
    },
    {
        "content": "<blockquote>\n<p>One proposal I had was to introduce the IH for a parameter x unhygienically as x.ih</p>\n</blockquote>\n<p>This is what I'm currently using in my poc of 'autocomplete cases/induction statements'. Why would that be unhygienic?</p>",
        "id": 301207741,
        "sender_full_name": "Reinier van der Gronden",
        "timestamp": 1664364085
    },
    {
        "content": "<p>If you can access a name that you didn't literally introduce as such, that's unhygienic according to the usual definition for macro systems</p>",
        "id": 301208023,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664364181
    },
    {
        "content": "<p>But you're talking about synthesizing syntax, right? Then that doesn't apply.</p>",
        "id": 301208140,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664364239
    },
    {
        "content": "<p>Yeah I was talking about syntax. While I'm still a little new, I would think that if you had</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">n.ih</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>that you have literally introduced it right? Or did you mean what to name those hypotheses if you only use <code>induction n</code> as a tactic?</p>",
        "id": 301208377,
        "sender_full_name": "Reinier van der Gronden",
        "timestamp": 1664364338
    },
    {
        "content": "<p>Yes, if you insert that on the user's behalf, everything is fine</p>",
        "id": 301208504,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664364386
    },
    {
        "content": "<p>The hygiene-bending implementation would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">n.ih</span><span class=\"bp\">;</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 301208587,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664364428
    }
]
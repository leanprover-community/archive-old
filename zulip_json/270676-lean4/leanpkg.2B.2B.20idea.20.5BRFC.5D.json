[
    {
        "content": "<p>One of the big planned steps forward for Lean is a fully feature package mean (a <code>leanpkg++</code>). Currently, the <a href=\"https://github.com/leanprover/lean4/issues/397\">idea</a> seems to be to model Rust's <a href=\"https://github.com/rust-lang/cargo\">Cargo</a>, hence the current similar TOML manifests. </p>\n<p>However, unlike Rust, Lean is both a bootstrapped <em>and interpretable</em> language. So, I propose we instead follow the model of other interpreted languages (like Ruby) and dispense with the TOML manifests and have a project's build/packaging scripts written in Lean (like Ruby's <code>Rakefile</code>/<code>Gemfile</code>).</p>\n<p>For example, a simple build script based off the manifest currently produced by <code>leanpkg init</code> could look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Leanpkg</span>\n<span class=\"kn\">open</span> <span class=\"n\">Leanpkg</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">manifest</span> <span class=\"o\">:</span> <span class=\"n\">Manifest</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Leanstrap\"</span>\n  <span class=\"n\">version</span> <span class=\"o\">:=</span> <span class=\"s2\">\"0.1\"</span>\n  <span class=\"n\">leanVersion</span> <span class=\"o\">:=</span> <span class=\"s2\">\"leanprover/lean4:nightly-2021-05-18\"</span><span class=\"o\">,</span>\n  <span class=\"n\">dependencies</span> <span class=\"o\">:=</span> <span class=\"o\">[</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"s2\">\"mathlib4\"</span><span class=\"o\">,</span>\n      <span class=\"n\">src</span> <span class=\"o\">:=</span> <span class=\"n\">Source.git</span>\n        <span class=\"o\">(</span><span class=\"n\">url</span> <span class=\"o\">:=</span> <span class=\"s2\">\"https://github.com/leanprover-community/mathlib4.git\"</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">rev</span> <span class=\"o\">:=</span> <span class=\"s2\">\"e5cd871f3d59d344521f01821a3e48b744c756d9\"</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">branch</span> <span class=\"o\">:=</span> <span class=\"s2\">\"master\"</span><span class=\"o\">)</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">]</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">build</span> <span class=\"n\">manifest</span>\n</code></pre></div>\n<p>For synergy with the <code>leanpkg</code> command, this could be done more intelligently by tagging various <code>def</code>s with attributes that <code>leanpkg</code> picks up on and uses. For example, say we had the following <code>Leanpkg.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[manifest]</span>\n<span class=\"kd\">def</span> <span class=\"n\">manifest</span> <span class=\"o\">:</span> <span class=\"n\">Manifest</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Leanstrap\"</span>\n    <span class=\"n\">version</span> <span class=\"o\">:=</span> <span class=\"s2\">\"0.1\"</span>\n    <span class=\"n\">leanVersion</span> <span class=\"o\">:=</span> <span class=\"s2\">\"leanprover/lean4:nightly-2021-05-18\"</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>The <code>leanpkg</code> command could read this file and build the project using the tagged <code>@[manifest]</code> definition as the manifest. Ideally, it would also support things like custom build, configure, and test hooks, and even support for running custom commands.</p>\n<p><strong>What do people think of this idea?</strong></p>",
        "id": 239484267,
        "sender_full_name": "Mac",
        "timestamp": 1621453229
    },
    {
        "content": "<p>reminds me an awful lot of FAKE F# make. It works there really well there, but you need quite a lot of library for it to be delightful. PSake (PowerShell make) is not a great example of the same idea.</p>",
        "id": 239486123,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621454048
    },
    {
        "content": "<p>I think the main risk of using a build script rather than a file is essentially tied to the \"expression problem\".</p>\n<p>There are potentially many things want to leverage in a build system beyond just build the software.  Even for building, you want information about dependencies so you can compute dependencies up front, resolve version constraints, create \"freeze\" files, etc.  There's also non-build tasks like building documentation, running tests, etc, creating descriptions and license information for a package library such as <code>crates.io</code>.</p>\n<p>There is no reason all this couldn't be done with  a build script, but I think a declarative model that describes data rather than code is more easily extensible to support these other uses of build information.</p>",
        "id": 239487802,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1621454702
    },
    {
        "content": "<p>I should add I'm currently looking into how to modify <code>cargo</code> itself to build non-rust packages.  Making this robust will be a lot of work, but would have the long term benefit of not requiring continued maintenance of a package system and would make it easier to depend on Rust packages in Lean (and vice-versa).</p>",
        "id": 239488151,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1621454851
    },
    {
        "content": "<p>I'm a fan of this approach. Not all packages are simple to build, and even cargo supports this kind of scripting with <code>build.rs</code>. I'm sympathetic to the idea of having a declarative manifest like a toml file, but I would like to know more specifically what the value proposition is, and in particular whether it would suffice to have a manifest object in the lean file like the one pictured, which leanpkg can print out as TOML or JSON if desired by some external tool.</p>",
        "id": 239488588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621455060
    },
    {
        "content": "<p>that's what FAKE does, they use F# types to describe data and then F# code to implement it. It work there... but the moment you need to call a shell, you really need a decent base class library or it gets painful.</p>",
        "id": 239488629,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621455081
    },
    {
        "content": "<p>I think whatever library we need to make this work should exist anyway, so I don't consider that a major issue</p>",
        "id": 239488680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621455117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239487802\">said</a>:</p>\n<blockquote>\n<p>There are potentially many things want to leverage in a build system beyond just build the software.  Even for building, you want information about dependencies so you can compute dependencies up front, resolve version constraints, create \"freeze\" files, etc.  There's also non-build tasks like building documentation, running tests, etc, creating descriptions and license information for a package library such as <code>crates.io</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239486123\">said</a>:</p>\n<blockquote>\n<p>reminds me an awful lot of FAKE F# make. It works there really well there, but you need quite a lot of library for it to be delightful.</p>\n</blockquote>\n<p>I think these both two points tie together quite nicely, in order for this approach to work smoothly your will need a robust library and packaging tool (<code>leanpkg</code>). The library needs to provide ways to neatly express a lot of declarative things (like a manifest, or more modularly, dependencies, version constraints etc.) and <code>leanpkg</code> needs to be able to read the script and present this information in manner that is easily consumed by humans and other tools. With the current tiny <code>leanpkg</code> this could be something like a <code>print-manifest</code> command that prints the Lean manifest as a TOML file (which I think is quite feasible). As more hooks and such are added, this will of course need to grow to become more complex.</p>\n<p>However, I think in the long run this offers a lot flexible, and, if done well, can as <span class=\"user-mention\" data-user-id=\"235513\">@Daniel Fabian</span> put it \"be delightful\". and I think Lean's extensive metaprogramming facilities make this a feasible goal. I would also certainly advise following existing examples of this (like Ruby's <code>rake</code> and F*'s <code>fake</code>) along with features from state-of-art package managers (like <code>cargo</code> and <code>npm</code>).</p>",
        "id": 239489548,
        "sender_full_name": "Mac",
        "timestamp": 1621455545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239488588\">said</a>:</p>\n<blockquote>\n<p>and in particular whether it would suffice to have a manifest object in the lean file like the one pictured, which leanpkg can print out as TOML or JSON if desired by some external tool.</p>\n</blockquote>\n<p>It appears you beat me to the typing!</p>",
        "id": 239489623,
        "sender_full_name": "Mac",
        "timestamp": 1621455595
    },
    {
        "content": "<blockquote>\n<p>There is no reason all this couldn't be done with a build script, but I think a declarative model that describes data rather than code is more easily extensible to support these other uses of build information.</p>\n</blockquote>\n<p>What if the <code>Manifest</code> type contained a bunch of thunks for getting the dependencies, running the build, enumerating the tests and so on, and different invocations of leanpkg will compute the manifest, run the thunks relevant to the current operation, and then perform the operation?</p>",
        "id": 239489628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621455600
    },
    {
        "content": "<p>In general, I think, what the languages like F# or lean have that can make this potentially work, is a strong type system. I.e. you could use a library, <code>leanpackage</code> to provide all the necessary functionality, and types, such that a build script has a minimal amount of structure to it. In case of FAKE they are tasks with dependencies. In the lean case it would probably be that plus some package metadata, etc. Then <code>leanpackage</code> would execute the script and be allowed to assume something about the structure. Almost like having an interface for the build scripts.</p>\n<p>What definitely does work really well in the FAKE case is the library of helpers built for FAKE is quite impressive, from <code>zip</code> over <code>ftp</code> to <code>nuget</code>, etc. everything is around.</p>\n<p>It's a radically different approach than trying to adopt <code>cargo</code> to lean.  <span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span>  how does that resonate with you?</p>",
        "id": 239493033,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621457138
    },
    {
        "content": "<p>msbuild, the c# project file format is technically also a build script, just that it's in xml and painful.</p>",
        "id": 239493137,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621457186
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"235513\">@Daniel Fabian</span> I'm still a bit partial to the Cargo approach still but that's mostly because I like the idea of reusing the work invested in another package manager or build system.</p>\n<p>If <code>leanpkg</code> can just take this and print out a <code>Cargo.toml</code> file (or some other format), then this sounds more like a EDSL for building TOML/JSON files for other build systems.   I'm not opposed to it, but hope the files are small enough for this not be necessary.</p>",
        "id": 239494074,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1621457700
    },
    {
        "content": "<p>Fair enough</p>",
        "id": 239494301,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621457799
    },
    {
        "content": "<p>Also for the record fake is really a build system and not a package manager.</p>",
        "id": 239494417,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621457873
    },
    {
        "content": "<p>Incidentally, I just mentioned the idea of adding Lean support to cargo to the cargo developers, and gotten some push back but also some buy in to the concept.<br>\nI don't have a strong technical preference , but am exploring cargo integration for a couple questions:</p>\n<ol>\n<li>I think integration with another package management tool may make it easier for people to try out Lean.</li>\n<li>I think this could reduce the maintenance involved so folks in the Lean community can focus on other problems.</li>\n</ol>",
        "id": 239494658,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1621458002
    },
    {
        "content": "<p>I wonder if we need to separate our building from versioning. Whilst they are related, they are not the same. And cargo is really about the latter afaict whereas fake is about the former.</p>",
        "id": 239495351,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621458249
    },
    {
        "content": "<p>FWIW, Zig language has a very interesting build system, e.g. <a href=\"https://github.com/ziglang/zig/blob/master/build.zig\">https://github.com/ziglang/zig/blob/master/build.zig</a> where you can write in Zig itself with some build API which works pretty fine for more complex projects</p>",
        "id": 239496006,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1621458522
    },
    {
        "content": "<p>BTW, is there a good reason to not consider to just use <code>nix</code> as a backend and have whatever nice frontend behind <code>leanpkg</code> so that the advanced / power user might switch to the full expressiveness of <code>nix</code> whenever needed?</p>",
        "id": 239496248,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1621458612
    },
    {
        "content": "<p>Nix doesn't work on windows</p>",
        "id": 239496287,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1621458625
    },
    {
        "content": "<p>Good point</p>",
        "id": 239496324,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1621458641
    },
    {
        "content": "<p>if you want an industrial strength cross-language reproducible build system, the next best is Bazel</p>",
        "id": 239496360,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1621458660
    },
    {
        "content": "<p>Isn't Bazel being phased out at Google?</p>",
        "id": 239496390,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1621458681
    },
    {
        "content": "<p>Re: separating build from versioning - when the build system is separate from the versioning system you get dependency management using <code>git submodule</code> and <code>curl https://www.github.com/thezipfile.zip</code>.</p>",
        "id": 239496396,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1621458683
    },
    {
        "content": "<p>Bazel is being phased out? I didn't hear that</p>",
        "id": 239496539,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1621458748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110025\">Andrew Ashworth</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239496539\">said</a>:</p>\n<blockquote>\n<p>Bazel is being phased out? I didn't hear that</p>\n</blockquote>\n<p>I surinterpreted <a href=\"https://github.com/kubernetes/kubernetes/issues/88553\">https://github.com/kubernetes/kubernetes/issues/88553</a></p>",
        "id": 239496741,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1621458797
    },
    {
        "content": "<p>Ah, well, reading that, it looks like just k8s is moving, because they have to maintain two build systems in parallel, and the go package builder is finally supporting remote build and build artifact caching natively</p>",
        "id": 239497020,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1621458894
    },
    {
        "content": "<p>Python's package-distribution problems are mostly caused by having a dynamic, interpreted setup.py rather than a static file format with manifest files specifying fixed-output deps. Cargo and Poetry is the right model, not custom dynamic files.</p>",
        "id": 239501452,
        "sender_full_name": "Iocta",
        "timestamp": 1621461409
    },
    {
        "content": "<p>Nix can use those formats via naersk and poetry2nix. I tried to get nix to handle lean manifests a while ago and I think it mostly worked, but I don't remember the details atm.</p>",
        "id": 239501721,
        "sender_full_name": "Iocta",
        "timestamp": 1621461568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262143\">Ryan Lahfa</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239496006\">said</a>:</p>\n<blockquote>\n<p>FWIW, Zig language has a very interesting build system, e.g. <a href=\"https://github.com/ziglang/zig/blob/master/build.zig\">https://github.com/ziglang/zig/blob/master/build.zig</a> where you can write in Zig itself with some build API which works pretty fine for more complex projects</p>\n</blockquote>\n<p>yeah, at a first glance, that's more or less what FAKE does: <a href=\"https://github.com/fsharp/FAKE/blob/release/next/build.fsx\">https://github.com/fsharp/FAKE/blob/release/next/build.fsx</a></p>",
        "id": 239509299,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621466018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253355\">Iocta</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239501452\">said</a>:</p>\n<blockquote>\n<p>Python's package-distribution problems are mostly caused by having a dynamic, interpreted setup.py rather than a static file format with manifest files specifying fixed-output deps. Cargo and Poetry is the right model, not custom dynamic files.</p>\n</blockquote>\n<p>I think Lean is expressive enough that you can support both though. For most simple configurations there can be a one-to-one matching with a static file format, but for more complex use cases (where, for example, custom run tasks are desired) the more powerful features can be used as well.</p>",
        "id": 239519414,
        "sender_full_name": "Mac",
        "timestamp": 1621473005
    },
    {
        "content": "<p>After some feasibility investigations and conversations with some other open-source package managers, we'd like to give the FAKE-style package manager a chance (see: <a href=\"https://github.com/fsharp/FAKE\">https://github.com/fsharp/FAKE</a>). Here's some of the reasoning:</p>\n<ul>\n<li>built in lean: this makes outside contributions quite a lot easier</li>\n<li>small core: at the core, we only need notions of manifest, task and dependency. </li>\n<li>community friendly: everything outside of the core is extremely hackable, and the small core is very stable.</li>\n<li>extremely expressive: given that the building DSL is embedded in Lean as opposed to being external, you can always fall back to the full expressivity of lean. So you should never get stuck with the language not being expressive enough for your project.</li>\n<li>it's a fine starting point for production use of lean 4: Since this is programming a programming project, it should be fairly pain-free to code up, since we won't find missing tactics or similar blocking progress. And also, since lean 4 itself is written in lean 4 on the programming side, I think, we are in a good place to start building software.</li>\n</ul>\n<p>I'd like for this project to be mostly community-driven. The way how it works for FAKE, and it work really well in that community, is that beyond the core, there are tons of helpers for various things you might want to do. They are things like:</p>\n<ul>\n<li>execute the compiler</li>\n<li>build documentation</li>\n<li>create a nuget package</li>\n<li>upload to nuget</li>\n<li>download from nuget</li>\n<li>create a zip file</li>\n<li>upload to ftp</li>\n<li>and many more</li>\n</ul>\n<p>The helpers are fairly volatile and very actively developed and it's easy to accept contributions so the build system can evolve quickly.</p>",
        "id": 239710769,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621583763
    },
    {
        "content": "<p>Thank you very much for working on this!</p>",
        "id": 239722921,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1621589962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"235513\">@Daniel Fabian</span> I'm curious, could you describe how FAKE, and/or your plans for a Lean version of it, figure into the build system dimensions presented in <a href=\"https://www.cambridge.org/core/journals/journal-of-functional-programming/article/build-systems-a-la-carte-theory-and-practice/097CE52C750E69BD16B78C318754C7A4\">https://www.cambridge.org/core/journals/journal-of-functional-programming/article/build-systems-a-la-carte-theory-and-practice/097CE52C750E69BD16B78C318754C7A4</a>, esp. tables 1 &amp; 2?</p>",
        "id": 239723412,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621590243
    },
    {
        "content": "<p>(The paper is very well worth a read in general for anyone interested in the topic)</p>",
        "id": 239723465,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621590259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I know that paper, it's really nice. Basically the idea is to have just the bare minimum built-in to be able to execute code in dependency order. A task or target is a pure side-effect (<code>MetaM Unit</code>) or something.</p>\n<p>Then you have a notion of dependencies. Finally you run one target and the system will eval in dependency order.</p>",
        "id": 239723762,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621590425
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"F#\"><pre><span></span><code><span class=\"o\">#</span><span class=\"n\">r</span> <span class=\"s\">\"paket:</span>\n<span class=\"s\">nuget Fake.IO.FileSystem</span>\n<span class=\"s\">nuget Fake.Core.Target //\"</span>\n<span class=\"o\">#</span><span class=\"n\">load</span> <span class=\"s\">\"./.fake/build.fsx/intellisense.fsx\"</span>\n\n<span class=\"k\">open</span> <span class=\"nn\">Fake.Core</span>\n<span class=\"k\">open</span> <span class=\"nn\">Fake.IO</span>\n\n<span class=\"c1\">// Properties</span>\n<span class=\"k\">let</span> <span class=\"nv\">buildDir</span> <span class=\"o\">=</span> <span class=\"s\">\"./build/\"</span>\n\n<span class=\"c1\">// Targets</span>\n<span class=\"nn\">Target</span><span class=\"p\">.</span><span class=\"n\">create</span> <span class=\"s\">\"Clean\"</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">_</span> <span class=\"o\">-&gt;</span>\n    <span class=\"nn\">Shell</span><span class=\"p\">.</span><span class=\"n\">cleanDir</span> <span class=\"n\">buildDir</span>\n<span class=\"o\">)</span>\n\n<span class=\"nn\">Target</span><span class=\"p\">.</span><span class=\"n\">create</span> <span class=\"s\">\"Default\"</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">_</span> <span class=\"o\">-&gt;</span>\n    <span class=\"nn\">Trace</span><span class=\"p\">.</span><span class=\"n\">trace</span> <span class=\"s\">\"Hello World from FAKE\"</span>\n<span class=\"o\">)</span>\n\n<span class=\"c1\">// Dependencies</span>\n<span class=\"k\">open</span> <span class=\"nn\">Fake.Core.TargetOperators</span>\n\n<span class=\"s\">\"Clean\"</span>\n    <span class=\"o\">==&gt;</span> <span class=\"s\">\"Default\"</span>\n\n<span class=\"c1\">// start build</span>\n<span class=\"nn\">Target</span><span class=\"p\">.</span><span class=\"n\">runOrDefault</span> <span class=\"s\">\"Default\"</span>\n</code></pre></div>",
        "id": 239723828,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621590455
    },
    {
        "content": "<p>this would be an example. Your <code>Target.create</code> creates the pure side-effects. Then the <code>\"Clean\" ==&gt; \"Default\"</code> is a really simple DSL for defining the dependencies between targets. And finally you <code>runOrDefault</code> the final target.</p>",
        "id": 239723967,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621590535
    },
    {
        "content": "<p>Then how will we prevent rebuilds? Is it every task's own responsibility to do so?</p>",
        "id": 239724559,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621590870
    },
    {
        "content": "<p>It's the helper's responsibility. In FAKE, you might just call <code>msbuild</code> which has a notion of not rebuilding everything every time. We might have a <code>nix</code> task to get it off the ground quickly, at a later point in time, we could have one that calls the compiler directly.</p>",
        "id": 239724802,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621590997
    },
    {
        "content": "<p>btw, as you saw in this particular script, they explicitly <code>cleanDir</code> so as to rebuild everything.</p>",
        "id": 239725044,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621591117
    },
    {
        "content": "<p>If you want it incremental, we can have a different helper for that kind of workflow.</p>",
        "id": 239725066,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621591135
    },
    {
        "content": "<p>Ok, then I got the wrong idea :) . I assumed building the actual .lean files would be its prime and initial task.</p>",
        "id": 239725699,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621591438
    },
    {
        "content": "<p>I'm looking at the examples at <a href=\"https://fake.build/\">https://fake.build/</a>, and they are triggering painful memories of me trying and failing to learn how to use tools like <code>sbt</code> and <code>grunt</code> in the past. (I get the impression that FAKE has a similar philosophy to those tools.)</p>\n<p>I'm worried that if we had a FAKE-like manifest DSL then every project would end up developing its own little dialect of the DSL, and that developers would be burdened with the need to learn these dialects.</p>",
        "id": 239742218,
        "sender_full_name": "David Renshaw",
        "timestamp": 1621600378
    },
    {
        "content": "<p>I think there was some plan to have a <code>toml -&gt; manifest</code> tool, so that 95% of the packages would just use a <code>.toml</code> file.</p>",
        "id": 239743099,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621600777
    },
    {
        "content": "<p><code>sbt</code> was (is?) a nightmare. So flexible that every project could do its own little interpretative dance about what a build process should do.</p>",
        "id": 239743466,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621600927
    },
    {
        "content": "<p>In my experience, sbt is completely ok as long you as you don't do anything fancy.  IMHO its biggest shortcoming is that it tries to use magic to make things look simpler instead of using normal Scala code.  (E.g you have top-level settings in addition to settings(), you have the whole key horror instead of using function arguments, etc.  And since it's all custom-made you can't just use the REPL or println to debug it.)</p>\n<p>I believe mill is the modern replacement. <a href=\"https://com-lihaoyi.github.io/mill/mill/\">https://com-lihaoyi.github.io/mill/mill/</a></p>",
        "id": 239745433,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621601838
    },
    {
        "content": "<p>From my experience, we didn't need to do anything beyond what the helpers could do for 95% of tasks and we would have 2-3 project specific functions.</p>",
        "id": 239748524,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621603121
    },
    {
        "content": "<p>I would caution against NIH. My impression is that all these language-specific build systems inevitably blossom into a major time sink and possibly a pile of hacks. By a quick count, FAKE has some 60kloc, Cabal (for Haskell) 40kloc, sbt 70kloc (including tests). Not saying it can't be done, but if an off-the-shelf build system and package manager would do, what would we lose?</p>",
        "id": 239758842,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1621607002
    },
    {
        "content": "<p>We wouldn't. In fact we'd love that, but so far we haven't found one. I'd love nix for instance, but giving up on windows entirely feels like a bad trade off. Do you have an off the shelf one in mind?</p>",
        "id": 239761740,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621608048
    },
    {
        "content": "<p>I don't have a great overview. I would have considered, off the top of my hat, make, Bazel and Shake. For package management, Opam. But I can see downsides to any of these options (mostly that they would rope other languages into the toolchain).</p>",
        "id": 239767674,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1621610426
    },
    {
        "content": "<p>OMG, isn't opam the PSPACE-complete package manager?  That doesn't really scream well designed to me.</p>",
        "id": 239767785,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621610470
    },
    {
        "content": "<p>I'd second looking at shake.  It's only 6kLOC, which should be easy enough to RIIL.</p>",
        "id": 239768176,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621610639
    },
    {
        "content": "<ul>\n<li>make: what we do right now, almost as bad as Nix on Windows</li>\n<li>Bazel: no support for dynamic dependencies, so not usable for building individual .lean files</li>\n</ul>",
        "id": 239768366,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621610701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239767785\">said</a>:</p>\n<blockquote>\n<p>OMG, isn't opam the PSPACE-complete package manager?  That doesn't really scream well designed to me.</p>\n</blockquote>\n<p>Afaik dependency resolution is a hard problem if you do it in sufficient generality. In any case, I've never had problems with Opam's performance (quite the opposite). Coq uses it as well.</p>",
        "id": 239768425,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1621610724
    },
    {
        "content": "<p>Shake is also the main focus of the a la carte paper :)</p>",
        "id": 239768632,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621610799
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> and <span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span>  I wouldn't worry about 60kloc that much, to be honest. The core and the DSL are small. It pretty much is the notion of tasks, dependencies and pretty-printing.</p>\n<p>The 60kloc would be coming mostly from the various helpers I'd consider them more of a sign that the library is very hackable and it's easy to upstream rather than that it is complicated.</p>\n<p>It did have a level of features, that most of the stuff one might typically want to do was available as helpers and you didn't go and implement them.</p>\n<p>And as for using off-the-shelf systems there is also the requirement that it ideally doesn't take with itself a huge external dependency. So anything .net or jvm based for instance isn't ideal (unless we'd be targetting those VMs and have that dependency anyway). </p>\n<p>From a quick look it looks like shake might take haskell with it... For me, that'd almost be enough of a reason to rewrite it in lean.</p>",
        "id": 239777798,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621614406
    },
    {
        "content": "<p>oh an opam also doesn't officially support windows.</p>",
        "id": 239777919,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621614467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239777919\">said</a>:</p>\n<blockquote>\n<p>oh an opam also doesn't officially support windows.</p>\n</blockquote>\n<p>Right. They're planning to add support soon (TM) at least. In any case, I don't want to advocate for any particular solution; I don't have strong opinions on available build systems or package managers. I just wanted to point out that it might be prudent to spend some time thoroughly researching the available options before embarking on a large project.</p>\n<blockquote>\n<p>The 60kloc would be coming mostly from the various helpers I'd consider them more of a sign that the library is very hackable and it's easy to upstream rather than that it is complicated.</p>\n</blockquote>\n<p>If you're planning to implement only a small core, say 10kloc, that just means other people have to implement the other 50kloc (or perhaps 30kloc; maybe some of these helpers are very special-purpose). There's a bunch of inescapable complexity here and I suspect many details of the design will not be immediately clear. There's also the question of documentation, both internal and user-facing. Existing tools have solved a lot of little problems that, imo, we shouldn't solve again if it can be avoided. But I'm only speaking in generalities here; I don't have any privileged information to offer, so I'll shut up for now. (FWIW, reimplementing Shake in Lean sounds reasonable to me, then you at least have a nice design good to go.)</p>",
        "id": 239784965,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1621617701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239768366\">said</a>:</p>\n<blockquote>\n<ul>\n<li>make: what we do right now, almost as bad as Nix on Windows</li>\n<li>Bazel: no support for dynamic dependencies, so not usable for building individual .lean files</li>\n</ul>\n</blockquote>\n<p>I have no idea how far along it is, but some people from the nix community including Eelco Dolstra are developing a build/config language called nickel. It might be worth a look.</p>",
        "id": 239796918,
        "sender_full_name": "Chris B",
        "timestamp": 1621623323
    },
    {
        "content": "<p>I'm studying the paper right now - last I saw it was the non-extended version. Maybe there's a quick win for us from it.</p>",
        "id": 239798272,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621623856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/239742218\">said</a>:</p>\n<blockquote>\n<p>I'm worried that if we had a FAKE-like manifest DSL then every project would end up developing its own little dialect of the DSL, and that developers would be burdened with the need to learn these dialects.</p>\n</blockquote>\n<p>I mean this already going to be part of the the buy-in of Lean. Large packages in Lean are likely to define all kinds of DSLs using leans metaprogramming features to represent concepts within them. So I think getting a feel for the DSLs of a given larger project/package is inevitable part of using Lean.</p>\n<p>However, for many smaller, les complex packages, I imagine the <code>.lean</code> packaging file will be much the same as an ordinary <code>.toml</code> config file, just written in Lean. I would think this would be much easier on new comers as instead of having two learn the intricacies of two languages (i.e., the build system language and Lean), you just have to learn one --- Lean.</p>",
        "id": 239801260,
        "sender_full_name": "Mac",
        "timestamp": 1621625222
    },
    {
        "content": "<p>we can also generate a <code>.toml</code> or <code>.json</code> for machine reading purposes. If we want to upload to github or something. JSON or TOML are much less of a dependency than lean if all you care about is for it to be machine-readable manifests. But having lean be the source of truth is fine.</p>",
        "id": 239895154,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1621712194
    },
    {
        "content": "<p>Fyi, I am currently working on prototyping a new Leanpkg with this design over at <a href=\"https://github.com/tydeu/lean4-leanpkg2\">https://github.com/tydeu/lean4-leanpkg2</a>. If anyone is interested in how things are going, take a look! Note that it is in early, early development so expect everything to not always be functional. Also, feel free to shoot me any suggestions, comments, or criticisms you may have.</p>",
        "id": 240701574,
        "sender_full_name": "Mac",
        "timestamp": 1622293985
    },
    {
        "content": "<p>As someone who just discovered Lean yesterday, and mostly familiar with Cargo, I have to say the build-file-in-lean-itself approach absolutely terrifies me. It's less so about Lean syntax, and more about the declarative vs imperative paradigm. The thing I like about Cargo is that you define <em>the project</em>, and not <em>how to build the project</em> - Cargo just figures that out for you. Seeing functions named <code>configure</code> and <code>build</code> feels very wrong (unless in the rare case I need to do something fancy, then sure, allow for custom build scripts).</p>",
        "id": 240704004,
        "sender_full_name": "Max",
        "timestamp": 1622297083
    },
    {
        "content": "<p>The strong conventions making most configuration implicit and hide-able in Cargo is also a big plus. I would never want to specify where my source files are (<code>src/*</code> just being implicit), or where my binaries should go (<code>bin/*</code>). That should be the responsibility cargo/leanpkg. I just want to code lean, not have to worry about how to structure my project and how to build it.</p>",
        "id": 240704097,
        "sender_full_name": "Max",
        "timestamp": 1622297231
    },
    {
        "content": "<p>Having <em>less</em> configuration options can be a good thing. It means less things you have to consider, less things to do wrong, and most importantly: All the projects you find on github have the same structure, so picking them up is very easy, and you don't have to investigate where the main.c file is (no, not this one, the <em>real</em> main file, which is specified somewhere in the 500 loc Makefile), which dependencies go where, etc. It has a... normative effect, I would say?<br>\nBut also, take everything I say with a grain of salt, since I am a newcomer and a dummy :).</p>",
        "id": 240704241,
        "sender_full_name": "Max",
        "timestamp": 1622297436
    },
    {
        "content": "<p>But either way I very much appreciate any effort into making a delightful package/build system. Glad it's seeing focus :)</p>",
        "id": 240704965,
        "sender_full_name": "Max",
        "timestamp": 1622298630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/240704004\">said</a>:</p>\n<blockquote>\n<p>The thing I like about Cargo is that you define <em>the project</em>, and not <em>how to build the project</em> - Cargo just figures that out for you. Seeing functions named <code>configure</code> and <code>build</code> feels very wrong (unless in the rare case I need to do something fancy, then sure, allow for custom build scripts).</p>\n</blockquote>\n<p>You should be happy to learn that that is the goal! As this evolves basic projects should only need to have a declarative manifest and nothing else. Only when custom build scripts are needed will functions like <code>build</code> and <code>configure</code> be used.</p>",
        "id": 240705297,
        "sender_full_name": "Mac",
        "timestamp": 1622299099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/240704241\">said</a>:</p>\n<blockquote>\n<p>Having <em>less</em> configuration options can be a good thing.</p>\n</blockquote>\n<p>I think this is one of the great schism in computer science. Some people like opinionated systems because it enables uniformity in interaction. Others like highly unopinionated systems because it allows to follow their own style (which they may themselves be highly opinionated about). I fall in the later camp. I want the tools I use to allow my to structure things how I want and express things how I want. I would note that this not an uncommon desire in computer science and can be seen to tie into <a href=\"https://lawsofux.com/postels-law/\">Postel's Law</a> of UX -- i.e., being flexible in what a tool accepts.</p>\n<p>On the other hand, the planned simple defaults I mentioned, should make most setups rather the same unless users go out of there way to change things. So, hopefully, there won't be to too much diversity in eventual setups. After all, nothing in C's build system requires source folders to be named <code>src</code> or header folders to be named <code>include</code> and yet the community has mostly come around to that practice.</p>",
        "id": 240705557,
        "sender_full_name": "Mac",
        "timestamp": 1622299526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/240705297\">said</a>:</p>\n<blockquote>\n<p>As this evolves basic projects should only need to have a declarative manifest and nothing else. Only when custom build scripts are needed will functions like <code>build</code> and <code>configure</code> be used.</p>\n</blockquote>\n<p>I would also like to re-emphasize this point: this stage of the prototype is simply meant to get a functional examples of Lean packages building through Lean file. <strong>It is not meant to be example of the final API / intended structure of said build / configuration files.</strong></p>",
        "id": 240705782,
        "sender_full_name": "Mac",
        "timestamp": 1622299812
    },
    {
        "content": "<p>We certainly hope that most projects will need only a the default setup. But we already know we'll have at least one huge project with a tricky setup (mathlib).</p>",
        "id": 240705802,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1622299855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, I'm actually hoping 2... Over time, having the lean compiler use the new system would be a nice goal as it would drive requirements and validate the design.</p>",
        "id": 240706843,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622301455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/240705802\">said</a>:</p>\n<blockquote>\n<p>We certainly hope that most projects will need only a the default setup. But we already know we'll have at least one huge project with a tricky setup (mathlib).</p>\n</blockquote>\n<p>Wouldn't the goal be to have each theory of the mathlib be a separate package, so to avoid an enormous mono-package? When I need something from the mathlib, my intuition says that I would add a dependency a la <code>vector_fields = { version = \"1.0\", in = \"mathlib/linalg\" }</code>, with <code>in</code> being some way to navigate around a directory of packages.<br>\nEither way, I'm probably way underqualified for this. All I can offer is the newcomer perspective. If that stops being helpful, do tell me.</p>",
        "id": 240708168,
        "sender_full_name": "Max",
        "timestamp": 1622303440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416280\">@Max</span> the splitting of mathlib into a lot of small packages is something that has been discussed multiple times. I think, so far, there hasn't been a clear path how to achieve it, though. From what I understand (<span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> understands the problem space much more deeply than I do), mathlib seems to have such a complex dependency graph, that taking even a small part of mathematics transitively pulls in a huge part of mathlib.</p>",
        "id": 240709093,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622304695
    },
    {
        "content": "<p>For context, here is the entire mathlib import graph as it stands today. <a href=\"/user_uploads/3121/XEMGCSN_zE9aUZtV6cWenbhp/mathlib-import-graph.pdf\">mathlib-import-graph.pdf</a> </p>\n<p>It is unreadably dense, but gives some sense. If anyone is interested in seeing subsets (e.g. the imports required for any particular piece of mathematics) just ping me and I'll generate the graph.</p>\n<p>It is _extremely_ crosslinked, despite quite a bit of effort of the years in paring things down.</p>",
        "id": 240729960,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622335161
    },
    {
        "content": "<p>Alternatively if anyone has a proposal for a particular subset of mathematics that could be split into a separate repo, I'm very happy to go through it in detail with them to see what is possible and what work would be required.</p>",
        "id": 240730017,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622335274
    },
    {
        "content": "<p>(import graphs in machine readable formats if anyone wants to explore: <a href=\"/user_uploads/3121/vp620plRKyLbhpjLeeOxu2JB/mathlib-import-graph.dot\">mathlib-import-graph.dot</a> <a href=\"/user_uploads/3121/9QvwwcjHTEZBEe1IMchStRG5/mathlib-import-graph.gml\">mathlib-import-graph.gml</a>)</p>",
        "id": 240730344,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622335859
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Could you do the same graph with all nodes of the same top-level directory (e.g. <code>linear_algebra</code>) contracted into one node?</p>",
        "id": 240744606,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1622361934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>: <a href=\"/user_uploads/3121/sLs1z5a7HlfloM2BCBiwSizl/Screen-Shot-2021-05-30-at-8.24.55-pm.png\">Screen-Shot-2021-05-30-at-8.24.55-pm.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/sLs1z5a7HlfloM2BCBiwSizl/Screen-Shot-2021-05-30-at-8.24.55-pm.png\" title=\"Screen-Shot-2021-05-30-at-8.24.55-pm.png\"><img src=\"/user_uploads/3121/sLs1z5a7HlfloM2BCBiwSizl/Screen-Shot-2021-05-30-at-8.24.55-pm.png\"></a></div>",
        "id": 240749232,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622370327
    },
    {
        "content": "<p>It is far from a DAG after this contraction, so I'm having trouble thinking of a way to draw it usefully!</p>",
        "id": 240749282,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622370377
    },
    {
        "content": "<p>Maybe this is slightly better: <a href=\"/user_uploads/3121/PPnCwKSgneurMfoOOCJYHGF9/Screen-Shot-2021-05-30-at-8.27.11-pm.png\">Screen-Shot-2021-05-30-at-8.27.11-pm.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/PPnCwKSgneurMfoOOCJYHGF9/Screen-Shot-2021-05-30-at-8.27.11-pm.png\" title=\"Screen-Shot-2021-05-30-at-8.27.11-pm.png\"><img src=\"/user_uploads/3121/PPnCwKSgneurMfoOOCJYHGF9/Screen-Shot-2021-05-30-at-8.27.11-pm.png\"></a></div><p>Nevertheless there are many double-headed arrows. <code>linear_algebra</code>, <code>ring_theory</code>, and <code>algebra</code> are, I guess, quite badly intermixed by now.</p>",
        "id": 240749344,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622370490
    },
    {
        "content": "<p>Nice :) . I think this graph gives a much better picture for how (in)feasible partitioning (current) mathlib into packages is</p>",
        "id": 240749418,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1622370640
    },
    {
        "content": "<p>Could you post the dot file as well so I can throw it into xdot?</p>",
        "id": 240749427,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1622370674
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/d27BVjp-0JthoB9wXOlEW2NO/tl.dot\">tl.dot</a></p>",
        "id": 240749479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622370742
    },
    {
        "content": "<p>(I did the graph munging in mathematica, so I can only hope that is a correctly formed .dot file.)</p>",
        "id": 240749482,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622370764
    },
    {
        "content": "<p>I think it would not be insane to aim for a bit more layering, with data/logic/order/tactic as a low level layer (i.e., not importing stuff from higher layers), then to have algebra/topology/category_theory above that, then everything else...</p>",
        "id": 240749547,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622370870
    },
    {
        "content": "<p>It's not very sensible that all the theory about multivariable polynomials is in <code>data</code>...</p>",
        "id": 240749566,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622370913
    },
    {
        "content": "<p>I would suggest basically emptying <code>data</code> of anything that a mathematician would recognise. :-) Probably there shouldn't be anything in there that a mathematician would recognise as \"needing proof\".</p>",
        "id": 240749627,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622371020
    },
    {
        "content": "<p>If anyone is interested / game to review PRs that do this, perhaps we should start a topic in another stream to do some planning.</p>",
        "id": 240749657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622371082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/240705802\">said</a>:</p>\n<blockquote>\n<p>But we already know we'll have at least one huge project with a tricky setup (mathlib).</p>\n</blockquote>\n<p>Could you say a bit more about how mathlib setup is tricky?  i recognize it is big and binary downloads are important.  Are there other particularly tricky things that come to mind?</p>",
        "id": 240762146,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1622390729
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span> one of the issues is the problem of needing tactics to be compiled before use in mathlib proper for efficiency (but of course the tactics depend on some math), see some of the comments in the mathlib4 thread, there were different solutions proposed:<br>\n<span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Mathlib.204/near/237986680\">said</a>:</p>\n<blockquote>\n<p>Additionally, as I've mentioned before, there is a second mathlib spinoff project, that I'm calling the mathlib prelude. This will collect all the tactics used by mathlib proper such as <code>ring</code>, <code>linarith</code> and the myriad small tactics. Due to lean 4's architecture, it is necessary for these tactics to exist in a separate compilation unit so that they can be available in their compiled form in mathlib. (You can use a tactic immediately after its definition but this uses the interpreter and so doesn't benefit from the tremendous work done on the lean 4 compiler.)</p>\n<p>Which brings me to the issue: should these two be separate repositories or not? I think that having all of mathlib in one monorepo reduces the maintenance cost of adding features to lean significantly, and I think most would agree that making even a comparatively simple change in lean core today is higher friction than adding to mathlib, since at the very least a new version of lean containing the modification has to be released and mathlib updated for the new version, both things that mathlib changes don't have to worry about.</p>\n<p>A natural solution would be to have mathlib and the prelude in two folders of one repo. But I don't know if lean 4 (or more accurately leanpkg) can currently handle packages that exist in subfolders of a repo.</p>\n</blockquote>",
        "id": 240768142,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1622399489
    },
    {
        "content": "<p>I think it's important to gather requirements as these, i.e. subfolder as packages. Since the requirements need to drive our development of the new leanpkg.</p>",
        "id": 240768391,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622399862
    },
    {
        "content": "<p>Hey, I'm back again to give a status report. The leanpkg++ project has been renamed Lake (aka Lean Make) with the repository for the prototype now located here: <a href=\"https://github.com/tydeu/lean4-lake\">https://github.com/tydeu/lean4-lake</a>. It <em>should</em> now be at feature parity with the existing leanpkg, so feel free to take it for a spin. If you find something is broken/missing, please let me know!</p>",
        "id": 241753946,
        "sender_full_name": "Mac",
        "timestamp": 1623060472
    },
    {
        "content": "<p>I like the name! <del>And then call package repositories oceans or something</del></p>",
        "id": 241754947,
        "sender_full_name": "Max",
        "timestamp": 1623061153
    },
    {
        "content": "<p>Hm, do you need to specify <code>lake build bin</code>? Why not just let it be inferred from whether we have a <code>src/Main.lean</code> or a <code>src/Lib.lean</code> by convention?</p>",
        "id": 241755095,
        "sender_full_name": "Max",
        "timestamp": 1623061233
    },
    {
        "content": "<p>I'm getting this from <code>lake build</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>package.lean:1:0: error: unknown package 'Init'\nYou might need to open '/home/jannis/uni/aesop' as a workspace in your editor\npackage.lean:3:14: error: unknown identifier 'Lake.PackageConfig'\npackage.lean:3:14: error: unknown constant 'sorryAx'\n</code></pre></div>\n<p>Code: <a href=\"https://github.com/JLimperg/aesop/tree/lake-experiment\">https://github.com/JLimperg/aesop/tree/lake-experiment</a>. My <code>lake</code> executable is built with the same Lean4 nightly specified in <code>leanpkg.toml</code> and <code>package.lean</code>. I use <code>elan</code> to execute that Lean version.</p>\n<p>What am I doing wrong?</p>",
        "id": 241756573,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1623062239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> </p>\n<p>Oh, sorry. Yeah, I should have probably added some build and run instructions. You need to build Lake with <code>leanpkg build bin LINK_OPTs=-rdynamic</code> on Unix platforms or <code>leanpkg build bin LINK_OPTS=\"-Wl,--export-all\"</code> on Windows. When running the executable, you need to include the build directory of Lake and lib directory of lean (ex. <code>&lt;lean-home&gt;/lib/lean</code>) in <code>LEAN_PATH</code>. Alternatively, you can run it interpreted as the examples do.</p>\n<p>I'll update the README soon.</p>",
        "id": 241834759,
        "sender_full_name": "Mac",
        "timestamp": 1623097158
    },
    {
        "content": "<p>Yep, that worked and <code>lake build lib</code> successfully built my library.</p>",
        "id": 241845270,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1623102236
    },
    {
        "content": "<p>It's very exciting to find the powerful Lake package manager! Can you provides some examples on how to use custom build scripts (or Makefile like Leanpkg)? In my case, I want to build my Lean code with external Rust HTTP library.</p>",
        "id": 246430883,
        "sender_full_name": "Xubai Wang",
        "timestamp": 1626684963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"414345\">@Xubai Wang</span> How exactly do you want to interact with the library? Have you written some C Lean bindings for the Rust library that you want to link to your Lean code that is using <code>extern</code>? Or do you have something else in mind? It would be easier to provide an example if I have some information about your use case. However, if you do already have C bindings, you should just be able add <code>path/to/libBindings.a</code> to the <code>linkArgs</code> for the package (if you are using the latest Lake master).</p>",
        "id": 246539404,
        "sender_full_name": "Mac",
        "timestamp": 1626749285
    },
    {
        "content": "<p>Also, since this topic has ben resuscitated, I should mention that development on Lake has progressed to the point where Lean packages (oleans, static libraries, and binaries) are now built entirely within Lake (no more Makefiles required). The next step is largely UX -- improving Lake's CLI and API to the point where it is as useful as can be to the Lean 4 community. </p>\n<p>This means that if anyone has a project with a somewhat complex build setup they want try Lake with, I am more than willing to assist in getting things working (and tweaking Lake as needed). However, do be warned that Lake is very bleeding edge, and has only been minimally tested, so things may blow up from time-to-time. So only experiment with it if you are okay with such dangers.</p>",
        "id": 246554450,
        "sender_full_name": "Mac",
        "timestamp": 1626767103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Thanks! I managed to build and link external C/C++ code with my Lean code using the <code>Lake.Packager</code> API and <code>linkArgs</code> field. My <code>package.lean</code> file is like this (a simple add function from C):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lake.Package</span>\n<span class=\"kn\">open</span> <span class=\"n\">System</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">package</span> <span class=\"o\">:</span> <span class=\"n\">Lake.Packager</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">path</span> <span class=\"n\">args</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- compile c code</span>\n  <span class=\"k\">let</span> <span class=\"n\">gccOut</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">IO.Process.output</span> <span class=\"o\">{</span>\n    <span class=\"n\">cmd</span> <span class=\"o\">:=</span> <span class=\"s2\">\"gcc\"</span>\n    <span class=\"n\">args</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"-c\"</span><span class=\"o\">,</span> <span class=\"s2\">\"-o\"</span><span class=\"o\">,</span> <span class=\"s2\">\"add.o\"</span><span class=\"o\">,</span> <span class=\"s2\">\"add.c\"</span><span class=\"o\">]</span>\n  <span class=\"o\">}</span>\n  <span class=\"c1\">-- create static lib</span>\n  <span class=\"k\">let</span> <span class=\"n\">arOut</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">IO.Process.output</span> <span class=\"o\">{</span>\n    <span class=\"n\">cmd</span> <span class=\"o\">:=</span> <span class=\"s2\">\"ar\"</span>\n    <span class=\"n\">args</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"rcs\"</span><span class=\"o\">,</span> <span class=\"s2\">\"libadd.a\"</span><span class=\"o\">,</span> <span class=\"s2\">\"add.o\"</span><span class=\"o\">]</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">return</span> <span class=\"o\">{</span>\n    <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"s2\">\"simpleAdd\"</span>\n    <span class=\"n\">version</span> <span class=\"o\">:=</span> <span class=\"s2\">\"0.1\"</span>\n    <span class=\"c1\">-- specify path to the lib</span>\n    <span class=\"n\">linkArgs</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"libadd.a\"</span><span class=\"o\">]</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>I also write some other demos including using a C++ HTTP lib, which can be found <a href=\"https://github.com/xubaiw/lean-lake-build-script-demo\">here</a>.</p>",
        "id": 246702504,
        "sender_full_name": "Xubai Wang",
        "timestamp": 1626863897
    },
    {
        "content": "<p>By the way, currently Lake works badly with VSCode (unknown package 'Lake'). I also tried adding my <code>LAKE_HOME</code> to the <code>Server Env</code> and <code>Server Env Paths</code> fields of the <code>vscode-lean4</code> extension, but still no effect.<br>\nIs there any current solutions? Or shall we patch the <code>vscode-lean4</code> extension to fix the problem?</p>",
        "id": 246703139,
        "sender_full_name": "Xubai Wang",
        "timestamp": 1626864440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"414345\">Xubai Wang</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/246703139\">said</a>:</p>\n<blockquote>\n<p>By the way, currently Lake works badly with VSCode (unknown package 'Lake'). I also tried adding my <code>LAKE_HOME</code> to the <code>Server Env</code> and <code>Server Env Paths</code> fields of the <code>vscode-lean4</code> extension, but still no effect.</p>\n</blockquote>\n<p>You need to add the build directory of Lake to the <code>LEAN_PATH</code> environemt variable (ex. via 'Server Env'). For example, adding the following field to your VSCode <code>settings.json</code> should work:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"nt\">\"lean4.serverEnv\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n  <span class=\"nt\">\"LEAN_PATH\"</span><span class=\"p\">:</span> <span class=\"s2\">\"path/to/lake/build\"</span>\n <span class=\"p\">}</span>\n</code></pre></div>",
        "id": 246705251,
        "sender_full_name": "Mac",
        "timestamp": 1626866076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"414345\">Xubai Wang</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/246702504\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> Thanks! I managed to build and link external C/C++ code with my Lean code using the <code>Lake.Packager</code> API and <code>linkArgs</code> field. I also write some other demos including using a C++ HTTP lib, which can be found <a href=\"https://github.com/xubaiw/lean-lake-build-script-demo\">here</a>.</p>\n</blockquote>\n<p>Cool! I am happy you got Lake to work for you. Would it be okay if I adapt some of your demos for inclusion in Lake''s <code>examples</code> folder?</p>",
        "id": 246707492,
        "sender_full_name": "Mac",
        "timestamp": 1626867700
    },
    {
        "content": "<p>On another note, I feel I should mention that Lake's API is still in the prototyping stages and is liable to change at anytime. I hinted at this before (when I described Lake as \"bleeding edge\"), but I feel I should reiterate this to make sure no one plans on relying on the API in  Lake's <code>master</code> branch to remain stable in any significant way.</p>",
        "id": 246707902,
        "sender_full_name": "Mac",
        "timestamp": 1626867975
    },
    {
        "content": "<p>If one is looking for some level of stability, I would suggest waiting until a stable Lake v2 is released.</p>",
        "id": 246708865,
        "sender_full_name": "Mac",
        "timestamp": 1626868654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/leanpkg.2B.2B.20idea.20.5BRFC.5D/near/246707492\">said</a>:</p>\n<blockquote>\n<p>Cool! I am happy you got Lake to work for you. Would it be okay if I adapt some of your demos for inclusion in Lake''s <code>examples</code> folder?</p>\n</blockquote>\n<p>Sure! Really looking forward to the stable release.</p>",
        "id": 246711345,
        "sender_full_name": "Xubai Wang",
        "timestamp": 1626870286
    },
    {
        "content": "<p>FWIW, I am wondering if this could be another point in the design space : Unison definitions are identified by content (<a href=\"https://www.unisonweb.org/docs/tour#%F0%9F%A7%A0-the-big-technical-idea\">https://www.unisonweb.org/docs/tour#%F0%9F%A7%A0-the-big-technical-idea</a>)</p>",
        "id": 264480016,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1639157405
    }
]
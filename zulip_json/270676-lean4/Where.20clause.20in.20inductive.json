[
    {
        "content": "<p>Is it possible to use a <code>where</code> clause in an inductive definition?<br>\nI'm defining some propositions inductively, where the types of the constructors' parameters are somewhat long propositions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">partialExec</span> <span class=\"o\">(</span><span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"n\">ι</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">remIn</span> <span class=\"n\">remOut</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">small</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n        <span class=\"n\">remIn</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"n\">remOut</span> <span class=\"bp\">∧</span>\n        <span class=\"n\">σ₁</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span><span class=\"bp\">→</span> <span class=\"n\">σ₂</span>\n    <span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">big</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">σₘ</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"n\">ι</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">PrecGraph</span> <span class=\"n\">σₘ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n        <span class=\"n\">σ₁</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"n\">remIn</span><span class=\"o\">]</span><span class=\"bp\">→</span> <span class=\"n\">σₘ</span> <span class=\"bp\">∧</span>\n        <span class=\"n\">π.isAcyclic</span> <span class=\"bp\">∧</span>\n        <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"n\">remOut</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isCompleteTopoOver</span> <span class=\"n\">π</span> <span class=\"bp\">∧</span>\n        <span class=\"n\">σₘ</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span><span class=\"bp\">→</span> <span class=\"n\">σ₂</span>\n    <span class=\"o\">)</span>\n</code></pre></div>\n<p>Can I use a <code>where</code> clause as to write something like: ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">partialExec</span> <span class=\"o\">(</span><span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"n\">ι</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">remIn</span> <span class=\"n\">remOut</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">small</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">small</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"n\">remIn</span> <span class=\"n\">remOut</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">big</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">big</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"n\">remIn</span> <span class=\"n\">remOut</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">small</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"n\">ι</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">remIn</span> <span class=\"n\">remOut</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n  <span class=\"n\">big</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"n\">ι</span> <span class=\"n\">υ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">remIn</span> <span class=\"n\">remOut</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<hr>\n<p>I don't want to extract <code>small</code> and <code>big</code> into their own definitions. The whole reason I'm using an inductive definition, is to get a disjunction with named cases.</p>",
        "id": 255534772,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1632989947
    },
    {
        "content": "<blockquote>\n<p>I don't want to extract small and big into their own definitions. The whole reason I'm using an inductive definition, is to get a disjunction with named cases.</p>\n</blockquote>\n<p>I'm confused, because with that <code>where</code> you have essentially done exactly that</p>",
        "id": 255538656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632991938
    },
    {
        "content": "<p>Although, if the main declaration was a <code>def</code>, the name of the auxiliaries created by <code>where</code> would be <code>partialExec.small</code> and <code>partialExec.big</code>, and in this case that will collide with the names of the constructors</p>",
        "id": 255538917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632992075
    },
    {
        "content": "<p>What do you expect the final, compiled type of <code>partialExec.small</code> (the constructor) to look like?</p>",
        "id": 255538951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632992102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Where.20clause.20in.20inductive/near/255538656\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't want to extract small and big into their own definitions. The whole reason I'm using an inductive definition, is to get a disjunction with named cases.</p>\n</blockquote>\n<p>I'm confused, because with that <code>where</code> you have essentially done exactly that</p>\n</blockquote>\n<p>True. I guess what's bothering me is purely the aesthetic look of the constructors. I find them quite awkward, so I was hoping to be able to adjust the syntax.</p>",
        "id": 255546283,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1632995753
    },
    {
        "content": "<p>Any reason you don't break up those arguments into three/seven separate fields for the constructors?</p>",
        "id": 255605845,
        "sender_full_name": "Reid Barton",
        "timestamp": 1633020031
    }
]
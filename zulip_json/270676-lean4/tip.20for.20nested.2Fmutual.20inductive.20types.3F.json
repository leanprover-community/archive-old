[
    {
        "content": "<p>We're trying to work with a datatype that looks roughly like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">LLVMType</span>\n<span class=\"bp\">|</span> <span class=\"n\">alias</span> <span class=\"o\">(</span><span class=\"n\">nm</span><span class=\"o\">:</span><span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">array</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">elt</span><span class=\"o\">:</span><span class=\"n\">LLVMType</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">struct</span> <span class=\"o\">(</span><span class=\"n\">packed</span><span class=\"o\">:</span><span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span><span class=\"o\">:</span><span class=\"n\">List</span> <span class=\"n\">LLVMType</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However performing computation with such a type currently forces you to liberally apply <code>partial</code> or similar:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">hasAlias</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LLVMType</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LLVMType.alias</span> <span class=\"n\">nm'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nm</span> <span class=\"bp\">==</span> <span class=\"n\">nm'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LLVMType.array</span> <span class=\"n\">sz</span> <span class=\"n\">elemTy</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">hasAlias</span> <span class=\"n\">nm</span> <span class=\"n\">elemTy</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LLVMType.struct</span> <span class=\"n\">packed</span> <span class=\"n\">fields</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n<span class=\"c1\">-- fail to show termination for</span>\n<span class=\"c1\">--  hasAlias</span>\n<span class=\"c1\">-- with errors</span>\n<span class=\"c1\">-- structural recursion cannot be used</span>\n\n<span class=\"c1\">-- well founded recursion has not been implemented yet</span>\n</code></pre></div>\n<p>Any tips or tricks for how we might work with such a datatype in the near term that gives us the ability to reason about it at times? (i.e., we  find ourselves occasionally wanting small propositions about computations with such a datatype and that is where the things get ugly and we're trying to decide what would be best/easiest for now).</p>\n<p>Longer term, is this something we're hoping automation and well-founded recursion will make smoother or dare I say, pleasant? Or, will users more likely want to go the route of defining a monomorphic mutually dependent list datatype when they want to combine such types? (I do see in some of the <a href=\"https://github.com/leanprover/lean4/blob/7c8e27b04496c5518da935efe40049076ec049fa/tests/playground/sizeof3.lean\">Lean 4 tests</a> at least manual/low level support seems to exist for the mutually recursive route, though we haven't tried that just yet).</p>\n<p>Thanks!</p>",
        "id": 233569320,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1617832493
    },
    {
        "content": "<p>Ah, I guess there is one other hacky workaround we could use for practical short-term purposes I can think of: just manually \"unroll\" our recursive functions if we really want to reason about them. While in theory an LLVM type can be arbitrarily complex... in our uses cases over the next six months, we can probably manually carve out  non-recursive computations for all the LLVM types we'll see in practice.</p>",
        "id": 233572094,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1617833947
    },
    {
        "content": "<p>In lean 3, these kinds of lemmas are almost always proved using well founded recursion. Nested/mutual structural recursion was not supported by the  lean 3 compilation strategy. In lean 4, correct nested/mutual recursors are generated by the kernel, but the equation compiler doesn't know how to detect that a mutual recursive definition can be compiled using mutual recursors, so it still falls back on well founded recursion.</p>\n<p>I don't think that implementing well founded recursion in the same way as lean 3 should be especially difficult, especially if the <code>has_well_founded</code> clause is required. There is potentially room for bikeshedding the syntax though, lean 3's syntax is somewhat cumbersome. Supporting the default <code>has_well_founded</code> instance using the <code>sizeof</code> function is possible but complex, and will probably have to wait until at least some of the basic nat lemmas are available. It seems better suited to be outside the core.</p>",
        "id": 233573124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617834596
    },
    {
        "content": "<p>The strategy I always recommend in lean 3 is to avoid nested and mutual inductives and replace them with plain inductives. The reasons to do this in lean 4 are a bit different but I think the advice is still applicable, at least until all the unimplemented bits are filled in</p>",
        "id": 233573277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617834707
    },
    {
        "content": "<p>Since the kernel supports this recursion but not the equation compiler, it's also possible to compile the equations manually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">LLVMType</span>\n<span class=\"bp\">|</span> <span class=\"n\">alias</span> <span class=\"o\">(</span><span class=\"n\">nm</span><span class=\"o\">:</span><span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">array</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">elt</span><span class=\"o\">:</span><span class=\"n\">LLVMType</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">struct</span> <span class=\"o\">(</span><span class=\"n\">packed</span><span class=\"o\">:</span><span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span><span class=\"o\">:</span><span class=\"n\">List</span> <span class=\"n\">LLVMType</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hasAlias</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">LLVMType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LLVMType.rec</span> <span class=\"o\">(</span><span class=\"n\">motive_1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive_2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">nm'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nm</span> <span class=\"bp\">==</span> <span class=\"n\">nm'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">sz</span> <span class=\"n\">elemTy</span> <span class=\"n\">ih_elemTy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih_elemTy</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">packed</span> <span class=\"n\">fields</span> <span class=\"n\">ih_fields</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"n\">false</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih_hd</span> <span class=\"n\">ih_tl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih_hd</span> <span class=\"bp\">||</span> <span class=\"n\">ih_tl</span><span class=\"o\">)</span>\n    <span class=\"n\">ty</span>\n</code></pre></div>\n<p>Unfortunately this seems to hit yet another todo in the code, because this definition fails with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">code</span> <span class=\"n\">generator</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">support</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">LLVMType.rec'</span> <span class=\"n\">yet</span><span class=\"o\">,</span> <span class=\"n\">consider</span> <span class=\"n\">using</span> <span class=\"bp\">'</span><span class=\"k\">match</span> <span class=\"bp\">...</span> <span class=\"k\">with</span><span class=\"bp\">'</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n</code></pre></div>\n<p>which is wonderfully circular. I guess you can get the best of both worlds by writing both versions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">hasAlias_impl</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LLVMType</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LLVMType.alias</span> <span class=\"n\">nm'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nm</span> <span class=\"bp\">==</span> <span class=\"n\">nm'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LLVMType.array</span> <span class=\"n\">sz</span> <span class=\"n\">elemTy</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">hasAlias_impl</span> <span class=\"n\">nm</span> <span class=\"n\">elemTy</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LLVMType.struct</span> <span class=\"n\">packed</span> <span class=\"n\">fields</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">@[implementedBy hasAlias_impl]</span>\n<span class=\"kd\">def</span> <span class=\"n\">hasAlias</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">LLVMType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LLVMType.rec</span> <span class=\"o\">(</span><span class=\"n\">motive_1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive_2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">nm'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nm</span> <span class=\"bp\">==</span> <span class=\"n\">nm'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">sz</span> <span class=\"n\">elemTy</span> <span class=\"n\">ih_elemTy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih_elemTy</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">packed</span> <span class=\"n\">fields</span> <span class=\"n\">ih_fields</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"n\">false</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih_hd</span> <span class=\"n\">ih_tl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih_hd</span> <span class=\"bp\">||</span> <span class=\"n\">ih_tl</span><span class=\"o\">)</span>\n    <span class=\"n\">ty</span>\n</code></pre></div>\n<p>which works, although it doesn't seem to suppress the code generation error</p>",
        "id": 233574433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617835339
    },
    {
        "content": "<p>Ah - I searched Zulip but did not peruse the Github issues. My bad.</p>\n<p>It looks like at least the \"long term\" part of my question (i.e., how would this smoothly work generally in the future) has been answered quite clearly here in case anyone is curious: <a href=\"https://github.com/leanprover/lean4/issues/262\">https://github.com/leanprover/lean4/issues/262</a></p>\n<p>TL;DR \"The plan is to support mutual and nested inductive datatypes using well-founded recursion only.\" -- <a href=\"https://github.com/leanprover/lean4/issues/262#issuecomment-761203937\">leodemoura</a></p>",
        "id": 233725822,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1617915049
    }
]
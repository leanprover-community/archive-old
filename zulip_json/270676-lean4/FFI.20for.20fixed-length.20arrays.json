[
    {
        "content": "<p>Okay, I got something working:</p>\n<p>Lean: <a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Array.lean\">https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Array.lean</a><br>\nC: <a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c\">https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c</a></p>\n<p>Still need to implement the FFI interface for a few things, but I'm pretty happy it works at all <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>\n<p>That said, not sure if what I'm doing is the right approach. If someone has a moment to take a quick look, I'd greatly appreciate it!</p>",
        "id": 277842952,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649147240
    },
    {
        "content": "<p>I think it would be better to have this be a wrapper around <code>Array</code> instead of <code>List</code></p>",
        "id": 277843437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147512
    },
    {
        "content": "<p>are there zero cost conversions to and from <code>LeanColls.Array</code>?</p>",
        "id": 277843510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277843437\">said</a>:</p>\n<blockquote>\n<p>I think it would be better to have this be a wrapper around <code>Array</code> instead of <code>List</code></p>\n</blockquote>\n<p>Part of me agrees, but part of me wants to completely replace the built-in array (see <code>ArrayBuffer</code> for UBA built on top of this <code>Array</code>), which I think means it is more reasonable to have a list representation. Unsure.</p>",
        "id": 277843760,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649147714
    },
    {
        "content": "<p>That implementation seems like you would have no way to actually get the length</p>",
        "id": 277843819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147736
    },
    {
        "content": "<p>I expect you will need the garbage collection functionalities of the original implementation even if it's basically a plain C array</p>",
        "id": 277843913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277843510\">said</a>:</p>\n<blockquote>\n<p>are there zero cost conversions to and from <code>LeanColls.Array</code>?</p>\n</blockquote>\n<p>to/from <code>LeanColls.Array</code> and <code>List</code>? No, I'm not sure that's even possible (might be wrong?)</p>",
        "id": 277843958,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649147825
    },
    {
        "content": "<p>but I assume that the existing Array implementation supports something that is essentially a single contiguous array, so you would just copy into a contiguous array when converting <code>Array -&gt; LeanColls.Array</code> and then both conversions become zero cost after that</p>",
        "id": 277844001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147857
    },
    {
        "content": "<p>no, zero cost between <code>Array</code> and <code>LeanColls.Array</code></p>",
        "id": 277844028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147876
    },
    {
        "content": "<p>that's why I suggested that <code>LeanColls.Array</code> wraps <code>Array</code> instead of <code>List</code></p>",
        "id": 277844097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277843819\">said</a>:</p>\n<blockquote>\n<p>That implementation seems like you would have no way to actually get the length</p>\n</blockquote>\n<p>Yeah, the length (where relevant) gets passed in to functions like it does in C world (because it has to be a parameter of the function). I'm still trying to figure out how to get Lean to erase it where irrelevant, though with aggressive enough inlining by the compiler it shouldn't matter</p>",
        "id": 277844147,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649147924
    },
    {
        "content": "<p>wouldn't <code>LC.Array</code> need to be a dependent type for that?</p>",
        "id": 277844209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147967
    },
    {
        "content": "<p>you declared it as just <code>LC.Array A</code> and not <code>LC.Array A n</code></p>",
        "id": 277844235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649147985
    },
    {
        "content": "<p>oh whoops nvm</p>",
        "id": 277844327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148016
    },
    {
        "content": "<p>you need a bounds check in <code>leancolls_array_get</code>, it can safely be called out of bounds but that yields UB in your implementation</p>",
        "id": 277844506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277844001\">said</a>:</p>\n<blockquote>\n<p>but I assume that the existing Array implementation supports something that is essentially a single contiguous array, so you would just copy into a contiguous array when converting <code>Array -&gt; LeanColls.Array</code> and then both conversions become zero cost after that</p>\n</blockquote>\n<p>Ah, yeah, I could implement conversions between Array and this one. Lean's built-in seems to have specializations for small types and I'm not entirely sure how that works yet, which is what discourages me atm...</p>",
        "id": 277844507,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649148109
    },
    {
        "content": "<p>I think the only way to call <code>leancolls_array_get</code> from Lean is by passing a <code>Fin n</code> which should ensure it's always within bounds, no?</p>",
        "id": 277844690,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649148193
    },
    {
        "content": "<p>oh I see, you have some misleadingly named functions</p>",
        "id": 277844957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148339
    },
    {
        "content": "<p>why does <code>getExternal</code> have a definition at all? It's a lie</p>",
        "id": 277845024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148369
    },
    {
        "content": "<p>those functions shouldn't be private in any case</p>",
        "id": 277845064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148404
    },
    {
        "content": "<p>you should just slap the <code>extern</code> directly on <code>get</code></p>",
        "id": 277845093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148424
    },
    {
        "content": "<p>One thing I'm particularly unsure about is <a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c#L35\">this function</a> for ensuring all mutations are safe to perform in place. It seems like there's kind of two cases where you aren't allowed to modify in place:<br>\n1) The object is shared. Here I want the implementation to just panic, because using these Arrays persistently should be eagerly caught.<br>\n2) The object is persistent. It seems like constants in a program just get compiled to always be marked as persistent even when they're only used once? Which I'm not sure how to avoid</p>",
        "id": 277845095,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649148424
    },
    {
        "content": "<p>persistent objects can't be modified, because they are shared with the whole program</p>",
        "id": 277845147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148469
    },
    {
        "content": "<p>it would not be sound to do so even if they are \"unshared\" because the next time you call the function you will get that constant again but its value is different</p>",
        "id": 277845238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845093\">said</a>:</p>\n<blockquote>\n<p>you should just slap the <code>extern</code> directly on <code>get</code></p>\n</blockquote>\n<p>Okay, so that was my first thought as well -- but there's kinda two steps happening here?</p>\n<p>First step is to erase index/length parameters from <code>Nat</code> to <code>USize</code> (which is safe because of memory constraints). Second step is to call the extern'd function.</p>\n<p>I wanted the <code>getExternal</code> to be a <code>constant</code> rather than a definition, but it can't automatically generate an <code>Inhabited</code> instance which made everything sad.</p>",
        "id": 277845420,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649148622
    },
    {
        "content": "<p>you can just change the signature of the extern function to match <code>get</code></p>",
        "id": 277845483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845238\">said</a>:</p>\n<blockquote>\n<p>it would not be sound to do so even if they are \"unshared\" because the next time you call the function you will get that constant again but its value is different</p>\n</blockquote>\n<p>What determines whether an expression is compiled to a persistent object? It seems kinda arbitrary</p>",
        "id": 277845541,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649148714
    },
    {
        "content": "<p>Lean will automatically lift any subexpression with no free variables to a constant</p>",
        "id": 277845664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148763
    },
    {
        "content": "<p>which basically means that <code>Array.mk</code> will probably be a copy from a global instead of a constructor</p>",
        "id": 277845740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845483\">said</a>:</p>\n<blockquote>\n<p>you can just change the signature of the extern function to match <code>get</code></p>\n</blockquote>\n<p>Yeah. I'll try this out and see what it would look like.</p>",
        "id": 277845840,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649148867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845664\">said</a>:</p>\n<blockquote>\n<p>Lean will automatically lift any subexpression with no free variables to a constant</p>\n</blockquote>\n<p>Huh, okay. What if I don't want it to do that..? I could see a use-case here where you don't want to have, say, an extra copy of a very large array floating around just because it's technically a closed expression...</p>",
        "id": 277845958,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649148947
    },
    {
        "content": "<p>there is some trick here involving <code>Unit -&gt; A</code> functions that I forget</p>",
        "id": 277846049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649148991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> will know if there is a way to disable constant lifting in a function</p>",
        "id": 277846184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149076
    },
    {
        "content": "<p>It just seems like not what I'd expect/want as a programmer. If I want an expression to not be recomputed every call, I'll lift it manually.</p>",
        "id": 277846304,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649149125
    },
    {
        "content": "<p>It's one of the advantages of pure functional programming. lots of subexpressions can be cached or precomputed</p>",
        "id": 277846347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149163
    },
    {
        "content": "<p>I don't think you would want to lift it manually considering that there are a huge number of such liftings in the average lean program</p>",
        "id": 277846470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149211
    },
    {
        "content": "<p>Most imperative languages lift constants if they can as well (C / C++ / Rust all do this)</p>",
        "id": 277846567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149250
    },
    {
        "content": "<p>Fair enough! Maybe the solution is to just be less aggressive with marking things persistent, maybe by making sure that the things which are marked are actually used twice</p>",
        "id": 277846728,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649149326
    },
    {
        "content": "<p>Anyways --  I'll try to get benchmarks down soon to see how the performance looks, before I even try to optimize the emitted bytecode</p>",
        "id": 277846802,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649149372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277846184\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> will know if there is a way to disable constant lifting in a function</p>\n</blockquote>\n<p>That's <code>set_option compiler.extract_closed false</code></p>",
        "id": 277846928,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649149439
    },
    {
        "content": "<p>Have you considered using a variation on <code>Fin n</code> that uses <code>USize</code> instead of <code>Nat</code>?</p>",
        "id": 277846961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149442
    },
    {
        "content": "<p>that would avoid the boxing overhead</p>",
        "id": 277846983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149451
    },
    {
        "content": "<p>and might actually be enough to get something that looks like a C loop over an array after enough inlining</p>",
        "id": 277847075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149498
    },
    {
        "content": "<p>although I guess <code>set</code> is still hard to optimize</p>",
        "id": 277847136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277803454\">said</a>:</p>\n<blockquote>\n<p>I believe it should be possible to bind to those functions directly, but it doesn't seem to be working:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"c1\">-- could not find native implementation of external declaration 'Nat.toUSize!' (symbols 'l_Nat_toUSize_x21___boxed' or 'l_Nat_toUSize_x21')</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The interpreter only speaks the always-boxed subset of the Lean ABI, so <code>extern</code>s must always be compiled first before evaluation</p>",
        "id": 277847275,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649149596
    },
    {
        "content": "<p>I tried putting it in a separate file but it didn't make a difference</p>",
        "id": 277847333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149639
    },
    {
        "content": "<p>how does lean do it?</p>",
        "id": 277847363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149650
    },
    {
        "content": "<p>maybe the interpreter is just ignoring those extern declarations on things like <code>USize.add</code></p>",
        "id": 277847460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149692
    },
    {
        "content": "<p>By compiling it first, into a binary named <code>lean</code> :)</p>",
        "id": 277847478,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649149700
    },
    {
        "content": "<p>That is, you would need <a href=\"https://github.com/leanprover/lake/pull/47\">https://github.com/leanprover/lake/pull/47</a> to make it work in a different module</p>",
        "id": 277847535,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649149740
    },
    {
        "content": "<p>BTW <span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> I'm also wondering whether these functions can instead be exposed as regular functions on <code>Array</code> instead of a new type</p>",
        "id": 277847709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649149831
    },
    {
        "content": "<p>oh definitely -- the goal here was to sidestep <code>Array</code>entirely, and reimplement dynamic arrays in Lean</p>",
        "id": 277898525,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649173301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277846961\">said</a>:</p>\n<blockquote>\n<p>Have you considered using a variation on <code>Fin n</code> that uses <code>USize</code> instead of <code>Nat</code>?</p>\n</blockquote>\n<p>That's a good idea. <code>{u : USize // u &lt; n}</code>. I'll think about it.</p>",
        "id": 277898931,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649173438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277845420\">said</a>:</p>\n<blockquote>\n<p>I wanted the <code>getExternal</code> to be a <code>constant</code> rather than a definition, but it can't automatically generate an <code>Inhabited</code> instance which made everything sad.</p>\n</blockquote>\n<p>Bumping this -- is there a way to give Lean an inhabitant without calling that inhabitant the definition?</p>",
        "id": 277900648,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649174021
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">getExternal</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>If you have an arbitrary type <code>α</code>, that's the only way to ensure inhabitation. But I think your primitive should rather take a proof that the index is in bounds and then you can give a reference implementation (in terms of lists) that doesn't need an <code>Inhabited</code> constraint.</p>",
        "id": 277903889,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1649175173
    },
    {
        "content": "<p>Yeah, that makes sense. I guess this is the tradeoff we make to avoid soundness issues :/</p>",
        "id": 277905967,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649176078
    },
    {
        "content": "<p>It just feels .. slightly not ideal that, in Lean world, it \"looks\" super cheap to go from the list representation to the array representation, when in reality that is a very expensive operation</p>",
        "id": 277906146,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649176146
    },
    {
        "content": "<p>I thought you didn't need <code>Inhabited</code> if the constant is <code>unsafe</code></p>",
        "id": 277906184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649176161
    },
    {
        "content": "<p>go figure.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[extern \"foo\"]</span> <span class=\"n\">unsafe</span> <span class=\"kd\">constant</span> <span class=\"n\">something</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"c1\">-- failed to synthesize</span>\n<span class=\"c1\">--   Inhabited α</span>\n\n<span class=\"kd\">@[extern \"foo\"]</span> <span class=\"n\">unsafe</span> <span class=\"kd\">constant</span> <span class=\"n\">loop</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">loop</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 277906980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649176454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/277906980\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[extern \"foo\"]</span> <span class=\"n\">unsafe</span> <span class=\"kd\">constant</span> <span class=\"n\">something</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"c1\">-- failed to synthesize</span>\n<span class=\"c1\">--   Inhabited α</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think that's a small bug</p>",
        "id": 277913016,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1649178956
    },
    {
        "content": "<p>Yes, we can clearly skip the <code>Inhabitant</code> synthesis code for <code>unsafe</code>. The current implementation always executes the synthesis code.</p>",
        "id": 277923723,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649183396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> Sorry for the delay. I had to take the day off yesterday.</p>\n<blockquote>\n<p>Right now the behaviors just don't match up, which seems like a recipe for issues</p>\n</blockquote>\n<p>The C and Lean behavior should match. Are you observing a mismatch in a particular example?</p>\n<blockquote>\n<p>Maybe this does actually mod?</p>\n</blockquote>\n<p>It should. We may have a bug in the current implementation, but our intention was to \"mod\" in C too.</p>",
        "id": 277927918,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649185042
    },
    {
        "content": "<p>Ah, no, I was reading the wrong thing there, sorry! It looks like it has the mod behavior in both C and Lean</p>",
        "id": 277929036,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649185500
    },
    {
        "content": "<p>What would be the best way to implement <code>Fin n</code> with <code>USize</code>? My main concern is: should <code>n : USize</code> or <code>n : Nat</code> or it does not matter?</p>\n<p>My attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">UFin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">USize</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">@[export ufin_add]</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"n\">y.1</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">@[export ufin_sub]</span>\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">))</span> <span class=\"bp\">%</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">@[export ufin_mul]</span>\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">y.1</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">@[export ufin_div]</span>\n<span class=\"kd\">def</span> <span class=\"n\">div</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">x.1</span> <span class=\"bp\">/</span> <span class=\"n\">y.1</span><span class=\"o\">),</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"o\">(</span><span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">add</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Sub</span> <span class=\"o\">(</span><span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">sub</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mul</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Div</span> <span class=\"o\">(</span><span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">div</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">UFin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">n.1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">UFin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Nat.toUSize</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">UFin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Example of the generated C code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">LEAN_EXPORT</span> <span class=\"n\">size_t</span> <span class=\"n\">ufin_sub</span><span class=\"o\">(</span><span class=\"n\">size_t</span> <span class=\"n\">x_1</span><span class=\"o\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">x_2</span><span class=\"o\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">x_3</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n<span class=\"n\">_start</span><span class=\"o\">:</span>\n<span class=\"o\">{</span>\n<span class=\"n\">size_t</span> <span class=\"n\">x_4</span><span class=\"bp\">;</span> <span class=\"n\">size_t</span> <span class=\"n\">x_5</span><span class=\"bp\">;</span> <span class=\"n\">size_t</span> <span class=\"n\">x_6</span><span class=\"bp\">;</span>\n<span class=\"n\">x_4</span> <span class=\"bp\">=</span> <span class=\"n\">lean_usize_sub</span><span class=\"o\">(</span><span class=\"n\">x_1</span><span class=\"o\">,</span> <span class=\"n\">x_3</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">x_5</span> <span class=\"bp\">=</span> <span class=\"n\">lean_usize_add</span><span class=\"o\">(</span><span class=\"n\">x_2</span><span class=\"o\">,</span> <span class=\"n\">x_4</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">x_6</span> <span class=\"bp\">=</span> <span class=\"n\">lean_usize_mod</span><span class=\"o\">(</span><span class=\"n\">x_5</span><span class=\"o\">,</span> <span class=\"n\">x_1</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">return</span> <span class=\"n\">x_6</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>With <code>n : Nat</code> the generated code is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">LEAN_EXPORT</span> <span class=\"n\">size_t</span> <span class=\"n\">ufin_sub</span><span class=\"o\">(</span><span class=\"n\">lean_object</span><span class=\"bp\">*</span> <span class=\"n\">x_1</span><span class=\"o\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">x_2</span><span class=\"o\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">x_3</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n<span class=\"n\">_start</span><span class=\"o\">:</span>\n<span class=\"o\">{</span>\n<span class=\"n\">size_t</span> <span class=\"n\">x_4</span><span class=\"bp\">;</span> <span class=\"n\">size_t</span> <span class=\"n\">x_5</span><span class=\"bp\">;</span> <span class=\"n\">size_t</span> <span class=\"n\">x_6</span><span class=\"bp\">;</span> <span class=\"n\">size_t</span> <span class=\"n\">x_7</span><span class=\"bp\">;</span>\n<span class=\"n\">x_4</span> <span class=\"bp\">=</span> <span class=\"n\">lean_usize_of_nat</span><span class=\"o\">(</span><span class=\"n\">x_1</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">x_5</span> <span class=\"bp\">=</span> <span class=\"n\">lean_usize_sub</span><span class=\"o\">(</span><span class=\"n\">x_4</span><span class=\"o\">,</span> <span class=\"n\">x_3</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">x_6</span> <span class=\"bp\">=</span> <span class=\"n\">lean_usize_add</span><span class=\"o\">(</span><span class=\"n\">x_2</span><span class=\"o\">,</span> <span class=\"n\">x_5</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">x_7</span> <span class=\"bp\">=</span> <span class=\"n\">lean_usize_modn</span><span class=\"o\">(</span><span class=\"n\">x_6</span><span class=\"o\">,</span> <span class=\"n\">x_1</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">lean_dec</span><span class=\"o\">(</span><span class=\"n\">x_1</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"n\">return</span> <span class=\"n\">x_7</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>You probably want to avoid the reference counting <code>lean_dec(x_1)</code> and <code>lean_usize_modn</code> that unboxes <code>Nat</code> inside.</p>",
        "id": 277935357,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1649188737
    },
    {
        "content": "<p>Also not sure if I got those operations right for <code>n &gt; sqrt(USize.size)</code>.</p>",
        "id": 277935467,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1649188785
    },
    {
        "content": "<p>If you care about performance, you definitely want to avoid that modulo (by directly proving <code>val &lt; n</code> for each index access, most probably)</p>",
        "id": 277936241,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649189098
    },
    {
        "content": "<p>Right, so having <code>x y : UFin n</code> you would not write <code>x + y</code> but <code>⟨x.1 + y.1, ...⟩</code> where you provide a custom proof.</p>",
        "id": 277936655,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1649189283
    },
    {
        "content": "<p>it doesn't make much sense to add two array indexes anyway</p>",
        "id": 277938027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649189965
    },
    {
        "content": "<p>I would imagine that in user code you wouldn't have a <code>UFin n</code> in the first place if you are doing anything other than handling this index opaquely; you would just have a <code>USize</code> and combine this with the proof of <code>val &lt; n</code> at the last minute when calling <code>get</code></p>",
        "id": 277938232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649190086
    },
    {
        "content": "<p>I'm quite often writing code like <code>λ i =&gt; if (i=0) ∨ (i=(n-1)) then 0 else u[i+1] - u[i-1]</code> where the type is automatically deduced to <code>Fin n</code> where <code>n</code> is the size of array <code>u</code>.</p>",
        "id": 277939534,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1649190835
    },
    {
        "content": "<p>there are redundant bounds checks in that expression though</p>",
        "id": 277940260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649191222
    },
    {
        "content": "<p>I think that the built-in Array in Lean does the right thing here, where arrays use <code>Nat</code> for indexing (because it's way easier that way), but behind the scenes we are making (technically unsafe) assumptions that everything fits in USize because otherwise you'd have already hit an out-of-memory error</p>",
        "id": 278058026,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649266052
    },
    {
        "content": "<p>the problem is that it impacts the ABI of the function if you use <code>Nat</code> - you don't get unboxed values anymore. This applies to both extern functions like <code>get</code> and also lean functions that just call each other normally: in addition to the cost of boxing and unboxing this is an optimization barrier, and you need a whole lot of things to go right for lean loops to look like C loops and trigger LLVM loop optimizations</p>",
        "id": 278105698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649292834
    },
    {
        "content": "<p>Yeah. Maybe instead I implement the interface directly on USize and then provide a separate interface for using <code>Nat</code>s with it</p>",
        "id": 278205012,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649355282
    },
    {
        "content": "<p>So, I'm revamping my implementation to work around some boxing costs with ArrayBuffer as defined.</p>\n<p>I need a type whose ABI representation could be any arbitrary value (not just <code>leanbox(0)</code>). Does something like <code>True</code> serve that purpose? Its value per the ABI would be <code>leanbox(0)</code>, but does it <em>have</em> to be? or can it be any arbitrary value of the right width?</p>",
        "id": 278291079,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649417717
    },
    {
        "content": "<p>If not -- is there a way to mark a recursor noncomputable?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Uninit</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">uninit</span> <span class=\"o\">:</span> <span class=\"n\">Uninit</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Uninit</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">noncomputable</span><span class=\"o\">]</span> <span class=\"n\">Uninit.rec</span>\n</code></pre></div>\n<p>This doesn't work because noncomputable is not an attribute. But it would definitely suffice my use-case, since it is not possible to distinguish the two constructors in any produced program.</p>",
        "id": 278291434,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649417911
    },
    {
        "content": "<p>I could also go the extern route, but if I conjecture an Uninit type by <code>constant</code> then I can't conjecture values of that type since it can't prove the type is inhabited...</p>",
        "id": 278291686,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649418056
    },
    {
        "content": "<p>Having an Uninit type would be useful for other FFIs as well; it's nice to say at the type-level that some value is junk, instead of having to ensure everything is known everywhere</p>",
        "id": 278292367,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649418440
    },
    {
        "content": "<p>Also, should allocations for external objects go through <code>lean_alloc</code> or directly call <code>malloc</code>? And if I do use <code>lean_alloc</code> I assume the finalize function should just call<code>lean_dealloc</code>?</p>",
        "id": 278409511,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649509781
    },
    {
        "content": "<p>After poking around the codebase, I think my real question is why the small object allocator exists</p>",
        "id": 278410102,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649510713
    },
    {
        "content": "<p>To make Lean go fast</p>",
        "id": 278410216,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649510875
    },
    {
        "content": "<p>I kinda assumed most malloc implementations already had paging for small allocations but that must be a wrong assumption</p>",
        "id": 278410276,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649510940
    },
    {
        "content": "<p>mimalloc would not have been so successful then. The Lean allocator is very similar to it.</p>",
        "id": 278410450,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649511189
    },
    {
        "content": "<p>So yes, Lean objects should always allocated with <code>lean_alloc</code> so that Lean uses the correct deallocator on them.</p>",
        "id": 278410459,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649511217
    },
    {
        "content": "<p>Actually, I think I am not able to use the lean allocator right now because I need a <code>realloc</code>. For now I'll just use malloc, might try my hand at implementing a realloc on Lean's allocator later</p>",
        "id": 278411426,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649512583
    },
    {
        "content": "<p>I assume you are not talking about the <code>lean_external_object</code> itself then, those should have a fixed size I believe</p>",
        "id": 278411866,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649513171
    },
    {
        "content": "<p>Oh, yeah -- I'm using <code>lean_alloc_external</code> for the external object itself. But I wasn't sure if I should also use lean_alloc for the array allocation</p>",
        "id": 278414457,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649516967
    },
    {
        "content": "<p>It's just a <code>void *</code> to Lean, you are responsible for it</p>",
        "id": 278419346,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649523373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20for.20fixed-length.20arrays/near/278291079\">said</a>:</p>\n<blockquote>\n<p>I need a type whose ABI representation could be any arbitrary value (not just <code>leanbox(0)</code>). Does something like <code>()</code> serve that purpose? Its value per the ABI would be <code>leanbox(0)</code>, but does it <em>have</em> to be?</p>\n</blockquote>\n<p>RE: this, I think it just depends on whether Unit.rec actually checks its value, no? I know the compiler optimizes away matches with only one live branch, so I assume that's true here as well and Unit.rec doesn't check the value?</p>",
        "id": 278424827,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649530339
    }
]
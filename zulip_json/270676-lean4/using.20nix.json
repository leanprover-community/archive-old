[
    {
        "content": "<p>Hi I just wanted to report my experience using nix.<br>\nI followed this link <a href=\"https://leanprover.github.io/lean4/doc/setup.html#nix-setup\">https://leanprover.github.io/lean4/doc/setup.html#nix-setup</a></p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>curl -L https://nixos.org/nix/install <span class=\"p\">|</span> sh\nnix-shell https://github.com/leanprover/lean4/archive/master.tar.gz -A nix\nnix flake new my-first-lean4-package -t github:leanprover/lean4\n<span class=\"nb\">cd</span> my-first-lean4-package\nnix build\n</code></pre></div>\n<p>It took about 30 mins to build.<br>\nThe build procedure seems to be building a load of CXX code.<br>\nI got loads of warnings, I am not sure if I should be concerned.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">warning</span><span class=\"o\">:</span> <span class=\"c1\">--- Invalid path signature ------------------------------------------------------------------ nix</span>\n<span class=\"n\">substituter</span> <span class=\"bp\">'</span><span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">lean4.cachix.org'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">a</span> <span class=\"n\">valid</span> <span class=\"n\">signature</span> <span class=\"n\">for</span> <span class=\"n\">path</span> <span class=\"bp\">'/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">bjnk91prlnvzhsvbk2sbsp5f1484bkbh</span><span class=\"bp\">-</span><span class=\"n\">Lean.ReducibilityAttrs'</span>\n</code></pre></div>",
        "id": 221657305,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1609859656
    },
    {
        "content": "<p>This fails for me: what am I missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">nix</span><span class=\"bp\">-</span><span class=\"n\">shell</span><span class=\"o\">:</span><span class=\"bp\">~/</span><span class=\"n\">mylean4pkg</span><span class=\"o\">]</span><span class=\"bp\">$</span> <span class=\"n\">nix</span> <span class=\"n\">build</span> <span class=\"bp\">.#</span><span class=\"n\">executable</span>\n<span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"c1\">--- Error --------------------- nix</span>\n<span class=\"n\">flake</span> <span class=\"n\">output</span> <span class=\"kn\">attribute</span> <span class=\"bp\">'</span><span class=\"n\">packages.x86_64</span><span class=\"bp\">-</span><span class=\"n\">linux.executable'</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"n\">derivation</span>\n</code></pre></div>",
        "id": 221658141,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1609860030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121918\">Edward Ayers</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/221657305\">said</a>:</p>\n<blockquote>\n<p>I got loads of warnings, I am not sure if I should be concerned.</p>\n</blockquote>\n<p>This is definitely the reason it built from source. Did you also do the <code>/etc/nix/nix.conf</code> steps? (Perhaps \"recommended\" is not strong enough there)</p>",
        "id": 221658369,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609860146
    },
    {
        "content": "<p>It's probably the biggest weakness in the current setup. It looks like Nix will soon allow setting these options per project (\"flake\"), but that hasn't landed on master yet. And it will probably require using an unstable Nix <em>daemon</em> (and not just a client like opening that <code>nix-shell</code> does), so not exactly easier to set up either...</p>",
        "id": 221658601,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609860270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121918\">Edward Ayers</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/221658141\">said</a>:</p>\n<blockquote>\n<p>This fails for me: what am I missing?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">nix</span><span class=\"bp\">-</span><span class=\"n\">shell</span><span class=\"o\">:</span><span class=\"bp\">~/</span><span class=\"n\">mylean4pkg</span><span class=\"o\">]</span><span class=\"bp\">$</span> <span class=\"n\">nix</span> <span class=\"n\">build</span> <span class=\"bp\">.#</span><span class=\"n\">executable</span>\n<span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"c1\">--- Error --------------------- nix</span>\n<span class=\"n\">flake</span> <span class=\"n\">output</span> <span class=\"kn\">attribute</span> <span class=\"bp\">'</span><span class=\"n\">packages.x86_64</span><span class=\"bp\">-</span><span class=\"n\">linux.executable'</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"n\">derivation</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Oh, I guess I didn't actually test that step... <code>executable</code> actually is a function right now that takes the filename to produce since I wanted the <code>Leanpkg</code> package to produce a <code>leanpkg</code> executable. Looks like there is in fact a <code>lib.toLower</code> function, so maybe I should just use that one (as a default).</p>",
        "id": 221659091,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609860499
    },
    {
        "content": "<p>Nice I added the config and it's downloading woop</p>",
        "id": 221659827,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1609860867
    },
    {
        "content": "<p>Changed <code>executable</code>, thanks for giving it a try!</p>",
        "id": 221660436,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609861154
    },
    {
        "content": "<p>And now it seems to actually work</p>",
        "id": 221661672,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609861716
    },
    {
        "content": "<p>When I try to execute the resulting binary I get the <code>--help</code> output of Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">nix</span><span class=\"bp\">-</span><span class=\"n\">shell</span><span class=\"o\">:</span><span class=\"bp\">~/</span><span class=\"n\">my</span><span class=\"bp\">-</span><span class=\"n\">first</span><span class=\"bp\">-</span><span class=\"n\">lean4</span><span class=\"bp\">-</span><span class=\"n\">package</span><span class=\"bp\">/</span><span class=\"n\">result</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"o\">]</span><span class=\"bp\">$</span> <span class=\"bp\">./</span><span class=\"n\">mypackage</span>\n<span class=\"n\">Expected</span> <span class=\"n\">exactly</span> <span class=\"n\">one</span> <span class=\"n\">file</span> <span class=\"n\">name</span>\n<span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">version</span> <span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Release</span><span class=\"o\">)</span>\n<span class=\"n\">Miscellaneous</span><span class=\"o\">:</span>\n  <span class=\"c1\">--help -h          display this message</span>\n  <span class=\"c1\">--version -v       display version number</span>\n  <span class=\"c1\">--githash          display the git commit hash number used to build this binary</span>\n  <span class=\"c1\">--run              executes the 'main' definition</span>\n  <span class=\"c1\">--o=oname -o        create olean file</span>\n  <span class=\"c1\">--c=fname -c       name of the C output file</span>\n  <span class=\"c1\">--stdin            take input from stdin</span>\n  <span class=\"c1\">--root=dir         set package root directory from which the module name of the input file is calculated</span>\n                     <span class=\"o\">(</span><span class=\"n\">default</span><span class=\"o\">:</span> <span class=\"n\">current</span> <span class=\"n\">working</span> <span class=\"n\">directory</span><span class=\"o\">)</span>\n  <span class=\"c1\">--trust=num -t     trust level (default: max) 0 means do not trust any macro,</span>\n                     <span class=\"n\">and</span> <span class=\"n\">type</span> <span class=\"n\">check</span> <span class=\"n\">all</span> <span class=\"n\">imported</span> <span class=\"n\">modules</span>\n  <span class=\"c1\">--quiet -q         do not print verbose messages</span>\n  <span class=\"c1\">--memory=num -M    maximum amount of memory that should be used by Lean</span>\n                     <span class=\"o\">(</span><span class=\"k\">in</span> <span class=\"n\">megabytes</span><span class=\"o\">)</span>\n  <span class=\"c1\">--timeout=num -T   maximum number of memory allocations per task</span>\n                     <span class=\"n\">this</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">deterministic</span> <span class=\"n\">way</span> <span class=\"n\">of</span> <span class=\"n\">interrupting</span> <span class=\"n\">long</span> <span class=\"n\">running</span> <span class=\"n\">tasks</span>\n  <span class=\"c1\">--threads=num -j   number of threads used to process lean files</span>\n  <span class=\"c1\">--tstack=num -s    thread stack size in Kb</span>\n  <span class=\"c1\">--plugin=file      load and initialize shared library for registering linters etc.</span>\n  <span class=\"c1\">--deps             just print dependencies of a Lean input</span>\n  <span class=\"c1\">--json             print JSON-formatted structured error messages</span>\n  <span class=\"c1\">--server           start lean in server mode</span>\n  <span class=\"c1\">--worker           start lean in server-worker mode</span>\n  <span class=\"c1\">--profile          display elaboration/type checking time for each definition/theorem</span>\n  <span class=\"c1\">--stats            display environment statistics</span>\n  <span class=\"bp\">-</span><span class=\"n\">D</span> <span class=\"n\">name</span><span class=\"bp\">=</span><span class=\"n\">value</span>      <span class=\"n\">set</span> <span class=\"n\">a</span> <span class=\"n\">configuration</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">see</span> <span class=\"kd\">set_option</span> <span class=\"n\">command</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 221669892,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609865163
    },
    {
        "content": "<p>that's what <code>lean</code> does!</p>",
        "id": 221670024,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609865232
    },
    {
        "content": "<p>unlike lean 3</p>",
        "id": 221670064,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609865258
    },
    {
        "content": "<p>But I compile a <code>.lean</code> file that does <code>#eval \"hello world\"</code></p>",
        "id": 221670104,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609865276
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">nix</span><span class=\"bp\">-</span><span class=\"n\">shell</span><span class=\"o\">:</span><span class=\"bp\">~/</span><span class=\"n\">my</span><span class=\"bp\">-</span><span class=\"n\">first</span><span class=\"bp\">-</span><span class=\"n\">lean4</span><span class=\"bp\">-</span><span class=\"n\">package</span><span class=\"o\">]</span><span class=\"bp\">$</span> <span class=\"n\">cat</span> <span class=\"n\">MyPackage.lean</span>\n<span class=\"k\">#eval</span> <span class=\"s2\">\"Hello, world!\"</span>\n</code></pre></div>",
        "id": 221670207,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609865312
    },
    {
        "content": "<p>oh I see, I don't know anything about Nix, but it looks like you managed to produce a Lean executable instead</p>",
        "id": 221670209,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609865312
    },
    {
        "content": "<p>You're missing a <code>main</code> function</p>",
        "id": 221670252,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609865337
    },
    {
        "content": "<p>You're right that fixes it</p>",
        "id": 221670420,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609865404
    },
    {
        "content": "<p>I don't understand what the behavior of the compiler is supposed to be when it tries to produce a binary but doesn't find a <code>main</code> function</p>",
        "id": 221670493,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609865436
    },
    {
        "content": "<p>Well, there's another <code>main</code> function in <code>leancpp.so</code> :) . This is just a hack in the Nix setup so I don't have to \"switch\" between C++ and Lean multiple times.</p>",
        "id": 221671591,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609865934
    },
    {
        "content": "<p>Oh! Does the binary always have the whole Lean prover compiled in with the rest of its functions?</p>",
        "id": 221671811,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609866021
    },
    {
        "content": "<p>Hopefully your binary is not in fact as big as <code>lean</code> after adding a <code>main</code> function</p>",
        "id": 221672546,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609866349
    },
    {
        "content": "<p>Hi,<br>\ndoes the nix configuration currently support linking lean packages against static library dependencies? E.g. if I have a package</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[extern \"test_impl\"]</span>\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>and a static library exporting a symbol <code>test_impl</code>, can I just pass it as a dep to <code>leanPkgs.buildLeanPackage</code>?</p>",
        "id": 221811402,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609961484
    },
    {
        "content": "<p>Not yet because no-one has tried that even without Nix so far! We should probably add an argument injected here: <a href=\"https://github.com/leanprover/lean4/blob/master/nix/buildLeanPackage.nix#L136\">https://github.com/leanprover/lean4/blob/master/nix/buildLeanPackage.nix#L136</a></p>",
        "id": 221811857,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609961702
    },
    {
        "content": "<p>I'm not sure what the proper Nix way here is though. For example, if a Lean library declares an external dependency, any executable depending on the library should inherit the dependency.</p>",
        "id": 221812247,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609961868
    },
    {
        "content": "<p>thanks, I’ll take a look later tonight. I also tried to write a custom deriver by reverse-engineering what the compiler does, and also got stuck in the linking stage, probably because of the same issue</p>",
        "id": 221812426,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609961972
    },
    {
        "content": "<p>It doesn't help that there is no real Nix infrastructure for C, probably because they assume you're already using some other build system like CMake that will take care of assembling the linker flags etc.</p>",
        "id": 221812502,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609962004
    },
    {
        "content": "<p>Are you guys open to PRs in infrastructure code like this, or should I just post stuff here if I find something I believe is useful?</p>",
        "id": 221813872,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609962723
    },
    {
        "content": "<p>(btw, here's one small patch I'm using to make the <code>lean</code> binary available when in the nix shell:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">diff</span> <span class=\"c1\">--git a/shell.nix b/shell.nix</span>\n<span class=\"n\">index</span> <span class=\"n\">a0ecd9eeae..18cd9ea056</span> <span class=\"mi\">100644</span>\n<span class=\"c1\">--- a/shell.nix</span>\n<span class=\"bp\">+++</span> <span class=\"n\">b</span><span class=\"bp\">/</span><span class=\"n\">shell.nix</span>\n<span class=\"bp\">@@</span> <span class=\"bp\">-</span><span class=\"mi\">16</span><span class=\"o\">,</span><span class=\"mi\">6</span> <span class=\"bp\">+</span><span class=\"mi\">16</span><span class=\"o\">,</span><span class=\"mi\">6</span> <span class=\"bp\">@@</span> <span class=\"k\">in</span> <span class=\"o\">{</span> <span class=\"n\">pkgs</span> <span class=\"bp\">?</span> <span class=\"n\">flakePkgs.nixpkgs</span><span class=\"o\">,</span> <span class=\"n\">llvmPackages</span> <span class=\"bp\">?</span> <span class=\"n\">null</span> <span class=\"o\">}:</span>\n     <span class=\"n\">CTEST_OUTPUT_ON_FAILURE</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">;</span>\n   <span class=\"o\">}</span><span class=\"bp\">;</span>\n   <span class=\"n\">nix</span> <span class=\"bp\">=</span> <span class=\"n\">pkgs.mkShell</span> <span class=\"o\">{</span>\n<span class=\"bp\">-</span>    <span class=\"n\">buildInputs</span> <span class=\"bp\">=</span> <span class=\"o\">[</span> <span class=\"n\">flakePkgs.nix</span> <span class=\"o\">]</span><span class=\"bp\">;</span>\n<span class=\"bp\">+</span>    <span class=\"n\">buildInputs</span> <span class=\"bp\">=</span> <span class=\"o\">[</span> <span class=\"n\">flakePkgs.nix</span> <span class=\"n\">flakePkgs.lean</span> <span class=\"o\">]</span><span class=\"bp\">;</span>\n   <span class=\"o\">}</span><span class=\"bp\">;</span>\n <span class=\"o\">}</span>\n</code></pre></div>\n<p>this, together with <a href=\"https://marketplace.visualstudio.com/items?itemName=arrterian.nix-env-selector\">https://marketplace.visualstudio.com/items?itemName=arrterian.nix-env-selector</a> , makes it easier to run my own version of vscode with a modified lean4 extension)</p>",
        "id": 221814183,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609962880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130439\">@Zygimantas Straznickas</span> Can you elaborate on what this does? If I wanted to use it with emacs, can I use the same thing?</p>",
        "id": 221814379,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609962972
    },
    {
        "content": "<p>IIUC it does some magic symlinking to , effectively, add <code>/nix/store/randomchanginghash-lean/bin</code> to PATH within the nix shell so <code>lean</code> can be used from the terminal as <code>lean</code>.  I assume this will also work with emacs if you start it from a nix shell or use something like <code>https://github.com/nix-community/nix-direnv</code>.</p>\n<p>(this addresses the problem of having a way to refer to the <code>lean</code> binary. I'm not sure how the emacs mode works, this might not even be a problem in the first place :) )</p>\n<p>Though I'm still stuck at making VSCode+ext+lean_server to recognize custom lean package dependencies defined through nix: e.g., in <code>MyPackage2</code> it succeeds at <code>import Lean.&lt;...&gt;</code>, but errors out on <code>import MyPackage1</code>, even though <code>nix build</code> successfully builds MyPackage2</p>",
        "id": 221815779,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609963547
    },
    {
        "content": "<p>Thanks for the pointer! That's actually the issue I'm trying to solve now. I'm going to do some reading and play around a bit with this.</p>",
        "id": 221816308,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609963782
    },
    {
        "content": "<p>I hope your project works out. It sounds like the kind of stuff I'd like to use</p>",
        "id": 221816385,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609963803
    },
    {
        "content": "<p>Right, for the editor you'll want to have <code>.#lean-dev</code> (output of a flake using the template) in the path, which is a <code>lean</code> wrapper that does the automatic compilation and importing of package-local depdencencies</p>",
        "id": 221816675,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609963927
    },
    {
        "content": "<p>The bare <code>lean</code>, as you've observed, only knows its stdlib</p>",
        "id": 221816734,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609963962
    },
    {
        "content": "<p>So <code>flakePkgs.lean-dev</code> should work, I think</p>",
        "id": 221816769,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609963980
    },
    {
        "content": "<p>Thanks for pointing it out. How do I find out what the path of <code>.#lean-dev</code> is?</p>",
        "id": 221816807,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609963994
    },
    {
        "content": "<p>In the Nix store?</p>",
        "id": 221816850,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609964013
    },
    {
        "content": "<p>I'm not familiar enough with Nix to know what that means</p>",
        "id": 221816904,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609964035
    },
    {
        "content": "<p>Then I don't know what your question is :) . If you do not want to go the nix-env-selector way, you can create a link to the executable using <code>nix build .#lean-dev -o ./lean-dev</code>. But that way you'll have to remember updating that link when the package's Lean version has changed yourself.</p>",
        "id": 221817222,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609964185
    },
    {
        "content": "<p>Basically, at the point where I am with setting up emacs, I need to set up the <code>PATH</code> environment variables and the <code>lean4-rootdir</code> Emacs variable so that <code>lean4</code> (the binary) and its libraries can be found by the language server</p>",
        "id": 221817786,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609964443
    },
    {
        "content": "<p>Yes, that should get you there. With the mentioned caveat.</p>",
        "id": 221817983,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609964523
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 221818354,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609964721
    },
    {
        "content": "<p>Where can I find out how <code>nix-env-selector</code> works?</p>",
        "id": 221818407,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609964743
    },
    {
        "content": "<p>(Note that the <code>lean-dev</code> setup might change soon)</p>",
        "id": 221818416,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609964747
    },
    {
        "content": "<p>aha, <code>lean-dev</code> works, thanks! IDE setup complete <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></p>",
        "id": 221820310,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609965639
    },
    {
        "content": "<p>I can't help reading <code>.#foo</code> as an emacs backup file and I want to delete it <span aria-label=\"trash can\" class=\"emoji emoji-1f5d1\" role=\"img\" title=\"trash can\">:trash_can:</span></p>",
        "id": 221820550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1609965743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130439\">@Zygimantas Straznickas</span> Super! Would you mind walking me through what you did? In particular, how do you install the version of Lean where you patched <code>shell.nix</code>?</p>",
        "id": 221820789,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609965854
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  I had to specifically patch the <code>sh</code> highlighter used in the docs to not interpret <code>#</code> without leading whitespace as a comment... <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 221821136,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1609966051
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> </p>\n<p>Sure, so,<br>\n1) since you want to patch <code>shell.nix</code>, you'll probably want to clone the lean4 code somewhere on your machine<br>\n2) update <code>shell.nix</code> to expose <code>lean-dev</code>: in line 19, add  <code>flakePkgs.lean-dev</code> to the array<br>\n3) enter the nix shell: <code>nix-shell &lt;lean4_dir&gt; -A nix</code><br>\n4) type <code>lean</code> into the shell and confirm that you get lean's help output<br>\n5) type <code>which lean</code> into the shell and confirm the first line starts with <code>/nix/store/</code></p>\n<p>(I don't fully understand how nix and flakes interplay, so sometimes I get a problem with nix complaining about mismatching dependency hashes, and fix it by a dumb sledgehammer approach of deleting all of my <code>flake.lock</code> files and rebuilding everything. I should really learn more about what that problem actually means :) )</p>\n<p>6) Now we're in emacs territory so I haven't tested that but my guess would be to either <br>\n6.1) Just start your global emacs from the nix shell command line and see if lean support works out of the box, without specifying a custom lean4-executable-name or lean4-rootdir <br>\n6.2) If that doesn't work, emacs doesn't inherit PATH and does something smarter, and I don't know anything about that :) The same applies if you want to start emacs from a desktop shortcut, or if you run an emacs daemon.</p>",
        "id": 221823690,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609967209
    },
    {
        "content": "<p>btw, for context, one reason I'm going through all this trouble for VSCode is that I'm using WSL, and I can't use the nix-built vscode version because that would try to open a graphical app in WSL and fail. Instead, Microsoft has this convenient bridge that connects my Windows VSCode with a backend running in WSL.</p>",
        "id": 221823912,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1609967341
    },
    {
        "content": "<p>Thank you so much for the detailed instructions! I need to run but I'll test them later tonight</p>",
        "id": 221824366,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1609967600
    },
    {
        "content": "<p>FYI, I just looked up the closures sizes of Lean itself/+ Emacs/+ VS Code using Nix, meaning the cumulative size of all dependencies down to glibc. In other words, what you would have to download if those exact versions are not already in your Nix store.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$ nix path-info -Sh .#lean\n/nix/store/s1cmjry080s7ilv3h8axj9rl4jra7jl8-lean       <span class=\"m\">1</span>.5G\n$ nix path-info -Sh .#emacs-package\n/nix/store/bj514l0pag981zbs75xflc11i2c797q2-emacs-package      <span class=\"m\">2</span>.6G\n$ nix path-info -Sh .#vscode-package\n/nix/store/cknca6rnm2z2p6j4q593p3fdk80dgf0m-vscode-package     <span class=\"m\">2</span>.2G\n</code></pre></div>\n<p>A full <code>1.0GB</code> of that is <code>clang</code>, which ideally we would only download when someone actually wants to compile a Lean package into a binary. /cc <span class=\"user-mention\" data-user-id=\"375364\">@Makarius Wenzel</span></p>",
        "id": 221955895,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1610033605
    },
    {
        "content": "<p>Alright, I now have static libraries linking successfully. My next goal: set up nix  so that <code>initialize test_symbol : IO.Ref (String) ← IO.mkRef \"Asdf\"</code>defined in external package A would be visible in external package B.</p>",
        "id": 222028868,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1610074100
    },
    {
        "content": "<p>I'm trying to set up nix on my machine. For the <code>/etc/nix/nix.conf</code> step that <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> mentioned above, is it necessary to put the config file in <code>/etc</code> or can I use a non-privileged folder (e.g. some file in <code>$HOME/.nix-profile/</code>)?</p>",
        "id": 222081856,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610118116
    },
    {
        "content": "<p>Actually it seems that <code>$HOME/.config/nix/nix.conf</code> might work?</p>",
        "id": 222082224,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610118282
    },
    {
        "content": "<p>There's another silly issue that I came across, just in case someone else has this issue: I had a problem where the backspace key in the nix-shell would create a space instead of deleting the character. Has anyone else come across this? </p>\n<p>This seems like a terminal specific issue, since setting <code>$TERM</code>to be e.g. <code>xterm</code> before running <code>nix-shell</code> fixes the problem (whereas my default <code>$TERM</code> is <code>rxvt-unicode-256color</code>).</p>",
        "id": 222086659,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610120472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/222081856\">said</a>:</p>\n<blockquote>\n<p>I'm trying to set up nix on my machine. For the <code>/etc/nix/nix.conf</code> step that <span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> mentioned above, is it necessary to put the config file in <code>/etc</code> or can I use a non-privileged folder (e.g. some file in <code>$HOME/.nix-profile/</code>)?</p>\n</blockquote>\n<p>If you're using a multi-user installation of Nix (the default), your Nix daemon will run as <code>root</code> and as such accept privileged options like <code>trusted-substituters</code> only from privileged locations</p>",
        "id": 222091068,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1610122426
    },
    {
        "content": "<p>I see. Thanks.</p>",
        "id": 222091659,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610122646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/221955895\">said</a>:</p>\n<blockquote>\n<p>A full <code>1.0GB</code> of that is <code>clang</code>, which ideally we would only download when someone actually wants to compile a Lean package into a binary. /cc <span class=\"user-mention silent\" data-user-id=\"375364\">Makarius Wenzel</span></p>\n</blockquote>\n<p>This is now the case with <a href=\"https://github.com/leanprover/lean4/pull/256\">https://github.com/leanprover/lean4/pull/256</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">nix</span> <span class=\"n\">path</span><span class=\"bp\">-</span><span class=\"n\">info</span> <span class=\"bp\">-</span><span class=\"n\">Sh</span> <span class=\"bp\">.</span>\n<span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">zyzyfm2c8n1rj7mh8f8x2kn32668q389</span><span class=\"bp\">-</span><span class=\"n\">lean</span>     <span class=\"mi\">362</span><span class=\"bp\">.</span><span class=\"mi\">6</span><span class=\"n\">M</span>\n</code></pre></div>",
        "id": 222192198,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1610230205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/221671591\">said</a>:</p>\n<blockquote>\n<p>Well, there's another <code>main</code> function in <code>leancpp.so</code> :) . This is just a hack in the Nix setup so I don't have to \"switch\" between C++ and Lean multiple times.</p>\n</blockquote>\n<p>fixed</p>",
        "id": 222232829,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1610301243
    },
    {
        "content": "<p>I had to deactivate flakes this week cf <a href=\"https://discourse.nixos.org/t/nix-shell-assertion-request-expectedetag-res-etag-failed/11119/9\">https://discourse.nixos.org/t/nix-shell-assertion-request-expectedetag-res-etag-failed/11119/9</a> <br>\nIs it  still possible for me to run  lean4 on nix?</p>",
        "id": 224061586,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1611677345
    },
    {
        "content": "<p>I didn't encounter this issue inside the Lean-Nix shell yet (only outside with my system Nix that is on another version), but now that a fixed version of Nix should be on Hydra, I can update the shell. Assuming that this issue is client-side, not daemon-side.</p>",
        "id": 224062678,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1611677734
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> Re-reading your question, <em>are</em> you using a Lean shell as in <a href=\"https://leanprover.github.io/lean4/doc/setup.html#nix-setup\">https://leanprover.github.io/lean4/doc/setup.html#nix-setup</a>? You do not have to enable flakes system-wide to use the Lean Nix setup.</p>",
        "id": 224065349,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1611678794
    },
    {
        "content": "<p>Oh thanks, since I had flakes until yesterday, I did not even notice you had a compatibiliy layer with legacy shells. Thanks</p>",
        "id": 224066751,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1611679373
    },
    {
        "content": "<p>I updated our pinned Nix version just to be safe</p>",
        "id": 224069598,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1611680529
    },
    {
        "content": "<p>The good news is that I hope to simplify the setup on Linux soon :) <a href=\"https://twitter.com/derKha/status/1354013281812410369\">https://twitter.com/derKha/status/1354013281812410369</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/derKha/status/1354013281812410369\"><img class=\"twitter-avatar\" src=\"https://pbs.twimg.com/profile_images/1291333830113206273/Owxrf3il_normal.jpg\"></a><p>Looks like we could drastically simplify the Lean 4 Nix setup now <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span> <a href=\"https://t.co/9qWMDudA9z\">https://twitter.com/derKha/status/1354013281812410369/photo/1</a></p><span>- Sebastian Ullrich (@derKha)</span><div class=\"twitter-image\"><a href=\"https://t.co/9qWMDudA9z\"><img src=\"https://pbs.twimg.com/media/EsprvHNWMAEerFD.png:small\"></a></div></div></div>",
        "id": 224069857,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1611680626
    },
    {
        "content": "<p>Alright, I finally implemented building static libraries/plugins on Nix (in my fork of Lean4). Not sure if the change is PR-ready, it's not the most elegant -- but at least it works :)</p>\n<p>The change: <a href=\"https://github.com/zygi/lean4/commit/9fb8aad8f5d38b3383c0698c1b857f744e8f1465\">https://github.com/zygi/lean4/commit/9fb8aad8f5d38b3383c0698c1b857f744e8f1465</a><br>\nExample of the ergonomics it provides: <br>\n<a href=\"https://github.com/zygi/leannixstatic1\">https://github.com/zygi/leannixstatic1</a><br>\n<a href=\"https://github.com/zygi/leannixstatic2\">https://github.com/zygi/leannixstatic2</a></p>",
        "id": 228029211,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1614396644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span></p>",
        "id": 228029214,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1614396650
    },
    {
        "content": "<p>nvm, this somehow broke go-to-definition</p>",
        "id": 228032490,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1614400632
    },
    {
        "content": "<p>or did go-to-definition ever work with nix?</p>",
        "id": 228032494,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1614400655
    },
    {
        "content": "<p>It should work, yes, with the caveats that for go-to-def into Lean sources <code>LEAN_SRC_PATH</code> needs to be set (but I think <code>emacs/vscode-dev</code> both set it). And for go-to-def into imported packages <code>leanpkg print-paths</code> needs to report sensible paths which for <code>leanpkg.toml</code> it should. I'm not sure what the story is with <code>flake.nix</code>.</p>",
        "id": 228035698,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1614404555
    },
    {
        "content": "<p>Thanks! It works within the same file so it must be the leanpkg thing</p>",
        "id": 228036164,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1614405179
    },
    {
        "content": "<p>Looks good to me at first glance!</p>",
        "id": 228056038,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1614429593
    },
    {
        "content": "<p>Would be interesting to check if -fpic actually has a performance impact using clang <a href=\"https://stackoverflow.com/a/51611087/161659\">https://stackoverflow.com/a/51611087/161659</a></p>",
        "id": 228056691,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1614430440
    },
    {
        "content": "<p>sg, will try to beautify it a little bit and do a PR</p>",
        "id": 228072467,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1614448111
    },
    {
        "content": "<p>also, added support for Nix go-to-definition. Instead of <code>leanpkg print-paths</code>, Nix will build a combined-dependency-source-dir and pass it in <code>LEAN_SRC_PATH</code>.</p>",
        "id": 228072586,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1614448255
    },
    {
        "content": "<p>I have to say I'm very much satisfied with Nix local and remote caching when working on Lean. Both no-op rebuilds after switching branches and automatically fetching the latest CI build after a pull just feel great. However, I acknowledge that for <em>users</em> of Lean 4 there are a few issues with this approach:</p>\n<ul>\n<li>Fetching Lean from the binary cache should be much faster (~2min) than building it from scratch, but that's still awfully slow compared to downloading a single ~100MB nightly build archive. This is both because the \"build plan\" has to be computed first by parsing the header of every .lean file (via import-from-derivation, which is not exactly fast) and then all ~400 .olean files are downloaded individually.</li>\n<li>Even with the very generously sized free Cachix cache, commits are cached only for about a month, while there is no time limit with our binary releases on GitHub. Per-commit caching is very useful for developers, but less so for users, for which nightly releases should usually be sufficient.</li>\n<li>There is no direct way to map <code>leanpkg.toml</code> <code>lean_version</code> specifiers such as <code>\"leanprover/lean4:nightly-2021-04-20\"</code> to cache entries.</li>\n<li>The cache has to be configured as a trusted substituter.</li>\n</ul>\n<p>Thus, if we want the Nix setup to be at least as fast and convenient as, and potentially also more compatible with, the <code>elan</code> setup, it seems like for <em>users</em> of Lean it should fetch it from the GitHub releases, not from Cachix. Downloading and Nix-patching binary releases is nothing unheard of in nixpkgs, so I feel we would be in good company.</p>\n<p>Specifically, what I'm imagining is that we have CI generate and commit a new configuration file, say <code>releases.json</code> on a branch <code>releases</code> in <code>leanprover/lean4-nightly</code> with the following content:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n  <span class=\"nt\">\"releases\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"nightly-2021-04-21\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"x86_64-linux\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"url\"</span><span class=\"p\">:</span> <span class=\"s2\">\"https://github.com/leanprover/lean4-nightly/releases/download/nightly-2021-04-21/lean-4.0.0-nightly-2021-04-21-linux.tar.gz\"</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"sha256\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span>\n      <span class=\"p\">},</span> <span class=\"err\">...</span>\n    <span class=\"p\">},</span> <span class=\"err\">...</span>\n  <span class=\"p\">},</span>\n  <span class=\"nt\">\"latest\"</span><span class=\"p\">:</span> <span class=\"s2\">\"nightly-2021-04-21\"</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>With this and a corresponding (static) <code>flake.nix</code> that implements the downloading and patching, we could add that branch as an input to any flake and either access a version directly with something like <code>releases.${system}.latest</code>, or parse a leanpkg.toml and use the version from there. The only limitation in the latter case is that the locked flake input must be at least as recent as the <code>lean_version</code> in <code>leanpkg.toml</code>, so Nix users might sometimes need to do an extra <code>nix flake update</code> when someone else has updated the Lean version.</p>\n<p>It's not quite clear to me yet where our custom Nix functions such as <code>buildLeanPackage</code> should come from in this setup, but if we want to keep them version-specific, we should probably include them in the binary releases (negligible storage overhead) and import-from-derivation them from in there, i.e. it would look something like <code>releases.${system}.latest.buildLeanPackage</code>.</p>\n<p>Ok, that's all I can think of so far. Thoughts?</p>",
        "id": 235491385,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619003505
    },
    {
        "content": "<p>Note that the same configuration file could be used by <code>elan</code> so it can stop having to parse the GitHub release page's HTML <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 235491492,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619003567
    },
    {
        "content": "<p>presumably you could build a binary using <code>nix</code> too for users?</p>",
        "id": 235491643,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1619003661
    },
    {
        "content": "<p>Yes, you could have Nix build a big tarball as well and put it in the binary cache if you meant that. But the build plan would still have to be computed in order to compute the hash of the tarball, so this would not solve any of the above issues.</p>",
        "id": 235497988,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619006768
    },
    {
        "content": "<p>Ideally it should be possible to work on a leanpkg.toml-based package using the Nix setup without any <code>flake.nix</code> being present. This could either be done using a temporary flake (Eelco Dolstra has some experiments in that direction I think) or perhaps using an old-style <code>nix-build -E ...</code>.</p>",
        "id": 235498916,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619007252
    },
    {
        "content": "<p>I mean more like a <code>nix</code> way of creating the nightly builds. But maybe that's already a solved problem anyway.</p>",
        "id": 235516537,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1619014237
    },
    {
        "content": "<p>Putting a Nix build result directly in a tarball and publishing it usually doesn't make sense because it will contain many broken references to the libc and other dependencies elsewhere in the Nix store. In fact the nightlies are already built inside a <code>nix-shell</code> (but using cmake) and we patch the build results in the end to work on generic Linux/macOS machines. So I think the only two ways of distribution are 1) using a \"proper\" binary cache that automatically fetches dependencies, as we do right now, and 2) downloading a generic-Linux/macOS binary and patching it on the fly for Nix, as proposed above.</p>",
        "id": 235525170,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619017261
    },
    {
        "content": "<p>did you consider the FHS wrapper to make it more generic? (Though I have to admit, I don't know if it's used in this way). At least you might not have to patch in the end.</p>",
        "id": 235537007,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1619021021
    },
    {
        "content": "<p>Binary patching is very much established in the Nix ecosystem, it's definitely cleaner than the FHS wrapper :)</p>",
        "id": 235543639,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619023601
    },
    {
        "content": "<p>It's just a bit funny that we will un-Nix-patch the release before uploading it and then re-patch it on the (Nix) user's machine, but the first part is basically an implementation detail of how the releases are created</p>",
        "id": 235543902,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619023699
    },
    {
        "content": "<p>After mulling over the above issues for a while, let's consider if we could <em>possibly</em> solve them using Nix alone:</p>\n<ul>\n<li>\n<p>I'm not aware of any currently available way to skip/significantly optimize the \"build plan\" evaluation, but in theory it is very much possible: Nix already uses an evaluation cache locally that skips this step if the flake contents are unchanged. Doing the same remotely is listed under \"Future Improvements\" in <a href=\"https://www.tweag.io/blog/2020-06-25-eval-cache/\">https://www.tweag.io/blog/2020-06-25-eval-cache/</a>, though I'm not aware of any work or even a GitHub issue on this feature. With it, Nix would download a Lean release's commit (over HTTP, not clone the whole repo), hash its contents, and then immediately skip to downloading binaries from the cache.<br>\nRegarding downloading 400 .olean files, this could trivially be optimized today by adding a new derivation that copies all .olean files of a package into a single directory tree and pushing that to the cache. The biggest downside of doing that is that every commit would take up much more cache space. However, here the Nix setup could also easily <em>improve</em> on the standard setup: using Nix's laziness, there is no need to even download the whole <code>Lean</code> package, or its compiled static library, until users actually import it. These two alone make up 60% of a release's size! The only reason this isn't already the case today is that we try to emulate the standard setup's directory layout, which contains all these dependencies in <code>lib/</code>, so that we can run Lean's test suite with minimal changes. But there is no reason to use this \"all-inclusive\" derivation in the pure-Nix <code>buildLeanPackage</code> as well.</p>\n</li>\n<li>\n<p>There is no magic bullet for fitting more commits in the binary cache, but perhaps there are workarounds. For example, we could use a separate cache for nightly and/or stable builds. That would still not give us unbounded cached releases like GitHub graciously does, but probably a sufficient number. If you really need an old release, maybe building it from source is tolerable since with Nix we can at least guarantee it will be painless and eventually succeed.</p>\n</li>\n<li>If we auto-generate a <code>flake.nix</code> from a <code>leanpkg.toml</code>, we can certainly map <code>lean_version = \"leanprover/lean4:nightly-2021-04-20\"</code> to <code>inputs.lean = github:leanprover/lean4-nightly/2021-04-20;</code>. If a project has both files, we could have a tool for keeping them in sync.</li>\n<li>Speaking of tools, I'm now committed to building a custom wrapper around a statically built Nix for Lean, which will resolve the global installation and configuration issues... on Linux (because using a local Nix store depends on mount namespaces)</li>\n</ul>\n<p>In summary, while the Nix setup is unlikely to beat the standard setup on <em>time</em> for downloading a Lean release in the near future, we could reasonably already do so on <em>download size</em> for most use cases (which on a slow connection could of course translate into less time as well).</p>\n<p>Here's hoping someone interested will actually read this :) .</p>",
        "id": 238645005,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620923233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/238645005\">said</a>:</p>\n<blockquote>\n<p>After mulling over the above issues for a while, let's consider if we could <em>possibly</em> solve them using Nix alone:</p>\n<ul>\n<li>\n<p>I'm not aware of any currently available way to skip/significantly optimize the \"build plan\" evaluation, but in theory it is very much possible: Nix already uses an evaluation cache locally that skips this step if the flake contents are unchanged. Doing the same remotely is listed under \"Future Improvements\" in <a href=\"https://www.tweag.io/blog/2020-06-25-eval-cache/\">https://www.tweag.io/blog/2020-06-25-eval-cache/</a>, though I'm not aware of any work or even a GitHub issue on this feature. With it, Nix would download a Lean release's commit (over HTTP, not clone the whole repo), hash its contents, and then immediately skip to downloading binaries from the cache.<br>\nRegarding downloading 400 .olean files, this could trivially be optimized today by adding a new derivation that copies all .olean files of a package into a single directory tree and pushing that to the cache. The biggest downside of doing that is that every commit would take up much more cache space. However, here the Nix setup could also easily <em>improve</em> on the standard setup: using Nix's laziness, there is no need to even download the whole <code>Lean</code> package, or its compiled static library, until users actually import it. These two alone make up 60% of a release's size! The only reason this isn't already the case today is that we try to emulate the standard setup's directory layout, which contains all these dependencies in <code>lib/</code>, so that we can run Lean's test suite with minimal changes. But there is no reason to use this \"all-inclusive\" derivation in the pure-Nix <code>buildLeanPackage</code> as well.</p>\n</li>\n<li>\n<p>There is no magic bullet for fitting more commits in the binary cache, but perhaps there are workarounds. For example, we could use a separate cache for nightly and/or stable builds. That would still not give us unbounded cached releases like GitHub graciously does, but probably a sufficient number. If you really need an old release, maybe building it from source is tolerable since with Nix we can at least guarantee it will be painless and eventually succeed.</p>\n</li>\n<li>If we auto-generate a <code>flake.nix</code> from a <code>leanpkg.toml</code>, we can certainly map <code>lean_version = \"leanprover/lean4:nightly-2021-04-20\"</code> to <code>inputs.lean = github:leanprover/lean4-nightly/2021-04-20;</code>. If a project has both files, we could have a tool for keeping them in sync.</li>\n<li>Speaking of tools, I'm now committed to building a custom wrapper around a statically built Nix for Lean, which will resolve the global installation and configuration issues... on Linux (because using a local Nix store depends on mount namespaces)</li>\n</ul>\n<p>In summary, while the Nix setup is unlikely to beat the standard setup on <em>time</em> for downloading a Lean release in the near future, we could reasonably already do so on <em>download size</em> for most use cases (which on a slow connection could of course translate into less time as well).</p>\n<p>Here's hoping someone interested will actually read this :) .</p>\n</blockquote>\n<blockquote>\n<p>If we auto-generate a flake.nix from a leanpkg.toml, we can certainly map lean_version = \"leanprover/lean4:nightly-2021-04-20\" to inputs.lean = github:leanprover/lean4-nightly/2021-04-20;. If a project has both files, we could have a tool for keeping them in sync.</p>\n</blockquote>\n<p>Actually, <code>leanpkg.toml</code> can work with a <code>Nix</code> setup and read the data directly from the Flakes file, lockfile, etc. Right?</p>",
        "id": 238654866,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1620927803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/238645005\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Speaking of tools, I'm now committed to building a custom wrapper around a statically built Nix for Lean, which will resolve the global installation and configuration issues... on Linux (because using a local Nix store depends on mount namespaces)</li>\n</ul>\n</blockquote>\n<p>FWIW, there is <a href=\"https://github.com/DavHau/nix-portable\">https://github.com/DavHau/nix-portable</a></p>",
        "id": 238654981,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1620927866
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 238658371,
        "sender_full_name": "Sam Stites",
        "timestamp": 1620929432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262143\">Ryan Lahfa</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/238654981\">said</a>:</p>\n<blockquote>\n<p>FWIW, there is <a href=\"https://github.com/DavHau/nix-portable\">https://github.com/DavHau/nix-portable</a></p>\n</blockquote>\n<p>DavHau's mach-nix is also worth checking out as a flake-compatible build tool for python (with a command line wrapper as well): <a href=\"https://github.com/DavHau/mach-nix\">https://github.com/DavHau/mach-nix</a></p>",
        "id": 238658856,
        "sender_full_name": "Sam Stites",
        "timestamp": 1620929689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262143\">Ryan Lahfa</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/238654866\">said</a>:</p>\n<blockquote>\n<p>Actually, <code>leanpkg.toml</code> can work with a <code>Nix</code> setup and read the data directly from the Flakes file, lockfile, etc. Right?</p>\n</blockquote>\n<p>You can't really make sense of a <code>flake.nix</code> without a Nix interpreter, so using the restricted <code>leanpkg.toml</code> format as the common ground is way easier. At one point I considered separate flake.nix and leanpkg.toml files with a common lock file, but I really don't want to teach <code>leanpkg</code> how to calculate <code>narHash</code>es...</p>",
        "id": 238659622,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620930039
    },
    {
        "content": "<p>You don't have to quote my entire message btw :)</p>",
        "id": 238659655,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620930054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262143\">Ryan Lahfa</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/238654981\">said</a>:</p>\n<blockquote>\n<p>FWIW, there is <a href=\"https://github.com/DavHau/nix-portable\">https://github.com/DavHau/nix-portable</a></p>\n</blockquote>\n<p>I know about the project, but it's not clear to me if there are relevant systems for Lean where this would work but not mount namespaces. In particular, even Debian has activated namespaces for non-root users by now afaik. And the big missing platform, macOS, is not supported by nix-portable either.</p>",
        "id": 238660250,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1620930362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/using.20nix/near/238645005\">said</a>:</p>\n<blockquote>\n<p>However, here the Nix setup could also easily <em>improve</em> on the standard setup: using Nix's laziness, there is no need to even download the whole <code>Lean</code> package, or its compiled static library, until users actually import it. These two alone make up 60% of a release's size! The only reason this isn't already the case today is that we try to emulate the standard setup's directory layout, which contains all these dependencies in <code>lib/</code>, so that we can run Lean's test suite with minimal changes. But there is no reason to use this \"all-inclusive\" derivation in the pure-Nix <code>buildLeanPackage</code> as well.</p>\n</blockquote>\n<p>This is now implemented: the (uncompressed) closure size of the <code>lean</code> derivation shrunk from 806 derivations totaling 434MB to just 6 derivations totaling 89MB (a good chunk of which is glibc, which you might already have from a different Lean revision).</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$ nix path-info -Sh .#lean-all\n/nix/store/9s2bcmdr8035dkfx9vgfh5jxcibqnxaw-lean     <span class=\"m\">434</span>.1M\n$ nix path-info -rsSh .#lean\n/nix/store/1yvpgm763b3hvg8q4fzpzmflr5674x4j-glibc-2.32-10         <span class=\"m\">29</span>.7M   <span class=\"m\">31</span>.4M\n/nix/store/c13jjm75vr23fv15wr1gqvlkkf6s1m7g-libidn2-2.3.0        <span class=\"m\">217</span>.5K    <span class=\"m\">1</span>.8M\n/nix/store/gk72n6pafkh603q9syxgj0i3pwp4fqf4-gmp-6.2.1            <span class=\"m\">734</span>.3K   <span class=\"m\">38</span>.1M\n/nix/store/isy60my0ijjzh49rscgdb1i2457nf7lp-gcc-9.3.0-lib          <span class=\"m\">6</span>.0M   <span class=\"m\">37</span>.4M\n/nix/store/ngc68ngmymx2vmbj6gih07n7z2024ffj-libunistring-0.9.10    <span class=\"m\">1</span>.6M    <span class=\"m\">1</span>.6M\n/nix/store/p64iq0dhanyzzf2l0g0bkiw252l40z6c-lean                  <span class=\"m\">51</span>.5M   <span class=\"m\">89</span>.7M\n</code></pre></div>\n<p>When building a Lean package using Nix, this executable will be used to parse all import paths, which will then be fetched lazily. In other words, if you use <code>prelude</code>, not even the <code>Init</code> .oleans will be downloaded onto your PC.</p>",
        "id": 239747389,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621602602
    },
    {
        "content": "<p>I really need to check out this nix integration more.  Is it a full leanmake replacement, i.e. does the server use it as well?  Can you use your own editor?  How hard is it e.g. to add nix support to mathlib4?</p>",
        "id": 239749929,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1621603716
    },
    {
        "content": "<p>I was hoping you would eventually find time to check it out <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> . Well, the problem right now is that I don't have to work on it either, except for this super low-hanging fruit.</p>\n<blockquote>\n<p>Is it a full leanmake replacement, i.e. does the server use it as well?</p>\n</blockquote>\n<p>Yes, the server is pointed at a fake <code>leanpkg</code> that on <code>print-paths</code> builds and returns the .olean store paths on the fly. It even works for stage 0, where the \"proper\" <code>leanpkg</code> doesn't exist yet. The editor can't tell the difference between the two setups.</p>\n<blockquote>\n<p>How hard is it e.g. to add nix support to mathlib4?</p>\n</blockquote>\n<p>Until we can consume <code>leanpkg.toml</code>s directly, it looks like this: <a href=\"https://github.com/Kha/testpkg2/blob/master/flake.nix\">https://github.com/Kha/testpkg2/blob/master/flake.nix</a>. The only onerous part is keeping the two Lean versions in leanpkg.toml and flake.lock in sync.</p>",
        "id": 239752851,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1621604872
    }
]
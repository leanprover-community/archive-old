[
    {
        "content": "<p>I'm having a problem with <code>simp</code> tactic, it is not applying a theorem about <code>f a</code> to an expression <code>f a b</code>. </p>\n<p>Here is MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">zero</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">true</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo'</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">zero</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">done</span>    <span class=\"c1\">-- Error: unsolved goals</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo''</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">zero</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">zero</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>The trace reveals that <code>simp</code> does not even attempt to unify  <code>?f zero</code> with <code>f zero</code> . Why is that?</p>",
        "id": 260546692,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1636248136
    },
    {
        "content": "<p>This problem is very similar to the one I had <a href=\"#narrow/stream/270676-lean4/topic/simp.20is.20not.20picking.20up.20a.20theorem\">earlier</a>, however this time <code>f</code> is a parameter of the simplification theorem <code>foo</code>.</p>",
        "id": 260547168,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1636249025
    },
    {
        "content": "<p>Because the head symbol of the LHS of the simp lemma is a variable (<code>f</code>), Lean can not match on it. This is a fundamental limitation of the simplifier.</p>",
        "id": 260547672,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636249809
    },
    {
        "content": "<p>See, for example, in mathlib3, how we use bundled morphisms (e.g. <code>ring_hom</code> and all its friends) to get around this.</p>",
        "id": 260547687,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636249834
    },
    {
        "content": "<p>Right, when you use morphism then the head of the expression would be coercion and simplifier has no longer problem with it.<br>\nInterestingly enough, I have encountered this problem exactly when working with unbundled morphisms, i.e. when the property of a function is automatically fetched by the type class system.</p>",
        "id": 260561580,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1636273458
    },
    {
        "content": "<p>I went through some lengths to be able to work with unbundled morphisms, so I do not want to revert back to bundled ones just yet where I had tons of other problems.</p>\n<p>Couldn't the simplifier exploit the fact that the argument, <code>zero</code>, is fixed in the simplification theorem? Or is it fundamentally important that the matching is based on the head of the expression?</p>",
        "id": 260564275,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1636277795
    },
    {
        "content": "<p>Removal of the <code>b</code> argument shows that the mvar head is not the problem</p>",
        "id": 260567744,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1636283149
    },
    {
        "content": "<p>Or that it is at least connected with the partial application issue, I haven't looked at the implementation yet</p>",
        "id": 260567836,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1636283254
    },
    {
        "content": "<p>Basically, with a constant head, <code>simp</code> knows how many arguments to match, but not with a variable head</p>",
        "id": 260568379,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1636284106
    },
    {
        "content": "<p>Ok this makes sense that <code>simp</code> should not do all of these unifications if variable head would be allowed.</p>",
        "id": 260584698,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1636304615
    },
    {
        "content": "<p>However, I'm still unsure how am I supposed to deal with the simplification of the fact that \"linear map of zero is zero\" and keep on working with unbundled morphisms. I probably need to write a tactic that looks at a zero and test all functions applied to it for linearity.</p>",
        "id": 260584873,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1636304775
    },
    {
        "content": "<p>There's something I've wanted to experiment with, which is having \"semibundled\" morphisms.  You can attach an instance to an unbundled morphism using a custom identity function -- using the example below, <code>map_zero f</code> still is <code>f</code>, but now it's carrying around a <code>has_map_zero</code> instance that theorems can make use of without needing to do typeclass inference again.  It also lets you apply simp lemmas when the function is the head symbol, since there's a <code>map_zero</code> there.  I imagine you'd want some tactic to automatically wrap everything in <code>map_zero</code> for this to not be annoying to work with.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">zero</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_map_zero</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">zero</span>\n\n<span class=\"sd\">/-- Attach a proof that `f` implements `has_map_zero` to the expression. -/</span>\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">map_zero</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">has_map_zero</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n\n<span class=\"sd\">/-- Use `rw [attach_map_zero f]` to insert the `has_map_zero` instance</span>\n<span class=\"sd\">into the expression.</span>\n<span class=\"sd\">(Caveat: this unfortunately can be recursively applied...) -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">attach_map_zero</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">has_map_zero</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">map_zero</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- `h` is an implicit argument so you don't need to do typeclass inference for it to use the theorem.</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">map_zero_apply_zero</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">has_map_zero</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">map_zero</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">h.map_zero</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_map_zero</span> <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_zero</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">const_zero</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">zero</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">const_zero_apply</span> <span class=\"o\">:</span> <span class=\"n\">const_zero</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">attach_map_zero</span> <span class=\"n\">const_zero</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 260586665,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636306807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Interesting idea, I would need to experiment with it a bit to understand what exactly is going on there, but I might get inspired by your approach.</p>",
        "id": 260630424,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1636362606
    }
]
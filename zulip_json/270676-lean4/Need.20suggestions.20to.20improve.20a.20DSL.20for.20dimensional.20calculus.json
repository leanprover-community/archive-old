[
    {
        "content": "<p>This is my first real lean4 program: <a href=\"https://github.com/NicolasRouquette/dimensional-calculus.lean4\">https://github.com/NicolasRouquette/dimensional-calculus.lean4</a></p>\n<p>I would like to document my journey in progressing from unproved object-oriented programming to proven functional programming style. I equate the former to the kind of lean4 code someone familiar with Java might write (well, perhaps a wee bit more than Java, perhaps oo-style Scala programming) and the latter to the kind of lean4 code that comes with verified proofs of useful properties.</p>\n<p>This DSL domain, dimensional analysis, is mathematically very simple: equations involving variables combined using multiplications, divisions and rational powers of such. Using the CADE 2021 paper and the BoolExpr from the doc, I managed to make a basic DSL for this domain.</p>\n<p>My questions are the following:</p>\n<p>1) The DSL is not very pretty (look at Main.lean); it is unclear to me how to make it more elegant where I could parse a file of dimensional calculus formulas.</p>\n<p>2) How should I organize my code w.r.t convenience functions like these below.</p>\n<p>At some point, it does not make sense to bloat the standard library with such convenience functions.<br>\nYet, these may be useful in a particular application. Where should I put these in a way that a reasonable reader might find them instead of adding them where I need them?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- TODO: Where should these HashSet extensions be defined?</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ofList</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">l.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">HashSet.empty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m.insert</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">union</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h1.fold</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">h2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h.insert</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">containsAll</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sub.fold</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">sup.contains</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>3) I have seen in the standard library comments like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- TODO: remove `partial` using well-founded recursion</span>\n</code></pre></div>\n<p>I also have 3 similar cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">applyMul</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">applyDiv</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">substitute</span> <span class=\"o\">(</span><span class=\"n\">ctx</span><span class=\"o\">:</span> <span class=\"n\">Context</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span>\n</code></pre></div>\n<p>How do we go about making these recursive functions 'well-founded' so that they would be total recursive functions?</p>\n<p>I suspect that the answer depends, in part, in choosing the right kind of data structure that makes it easier for lean4 to reason about structural recursion.</p>\n<p>4) Proving some properties about the program.</p>\n<p>Is (3) necessary to prove properties about some data structures like <code>DCalcFactors</code>?</p>\n<p>I have been looking for examples in the lean4 source code and found something interesting in <code>HashSet.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">WellFormed</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HashSetImp</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkWff</span>     <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span>                  <span class=\"n\">WellFormed</span> <span class=\"o\">(</span><span class=\"n\">mkHashSetImp</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">insertWff</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">WellFormed</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">eraseWff</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">WellFormed</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">WellFormed</span> <span class=\"o\">(</span><span class=\"n\">erase</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">HashSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">HashSetImp</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">m.WellFormed</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>As the name suggests, it seems that <code>HashSetImpl</code> is the implementation of <code>HashSet</code>.<br>\nI am not entirely sure that I understand the elegance of formalizing well-formedness for hashsets.<br>\nCan someone explain this construction and proof?</p>\n<ul>\n<li>Nicolas.</li>\n</ul>",
        "id": 269899594,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1643504131
    },
    {
        "content": "<blockquote>\n<p>How do we go about making these recursive functions 'well-founded' so that they would be total recursive functions?</p>\n</blockquote>\n<p>You haven't shown the definition of the function. The way to prove a definition well founded depends primarily on the ways in which you make recursive calls, and the structure of the domain type (here <code>DCalcFactors</code>). It's pretty difficult to give advice without this</p>",
        "id": 269903834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643509317
    },
    {
        "content": "<p>Oh, you left a link. To prove a function is well founded, you need a \"variant\" that decreases on every recursive call. In the case of <code>applyMul</code>, a suitable variant is <code>fs2.size</code>. You would have to prove that <code>fs2.size != 0 -&gt; (HashMap.ofList fs2.toList.tail!).size &lt; fs2.size</code>, which in theory should be combining some lemmas from the standard library</p>",
        "id": 269904088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643509632
    },
    {
        "content": "<p>The other two functions have exactly the same recursion structure, so you could use the same proof</p>",
        "id": 269904148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643509688
    },
    {
        "content": "<blockquote>\n<p>Is (3) necessary to prove properties about some data structures like <code>DCalcFactors</code>?</p>\n</blockquote>\n<p>Yes, more or less. As far as the logic is concerned, any <code>partial</code> function can have any behavior consistent with the type given to it. So for example there is no way you can prove that <code>applyMul</code> is not the same as <code>def applyMul (fs1 fs2 : DCalcFactors) := fs1</code></p>",
        "id": 269904259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643509840
    },
    {
        "content": "<p>Note that Lean 4 core is not overly concerned with proving correctness of its data structures. You are better off looking at <a href=\"https://github.com/leanprover-community/mathlib4/\">mathlib4</a> if you are interested in that sort of thing</p>",
        "id": 269904293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643509912
    },
    {
        "content": "<p>For example, see <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/BinaryHeap.lean\">BinaryHeap.lean</a> which is a binary heap implementation which does not use <code>partial</code> by using <code>termination_by</code> where necessary</p>",
        "id": 269904372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643510037
    },
    {
        "content": "<p>For (2) your best bet is to put the functions in mathlib4. Most of us also have a <code>for_mathlib</code> file or directory in our projects containing definitions and lemmas that aren't really project specific and really ought to be PR'd to mathlib but we haven't got around to it yet</p>",
        "id": 269904504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643510226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Need.20suggestions.20to.20improve.20a.20DSL.20for.20dimensional.20calculus/near/269904088\">said</a>:</p>\n<blockquote>\n<p>Oh, you left a link. To prove a function is well founded, you need a \"variant\" that decreases on every recursive call. In the case of <code>applyMul</code>, a suitable variant is <code>fs2.size</code>. You would have to prove that <code>fs2.size != 0 -&gt; (HashMap.ofList fs2.toList.tail!).size &lt; fs2.size</code>, which in theory should be combining some lemmas from the standard library</p>\n</blockquote>\n<p>Thanks for the suggestion, I understand the idea:</p>\n<p>show that the recursive calls are monotonically decreasing as a function of the size of the 2nd argument. </p>\n<p>What I do not understand is how to express this in lean4; I tried your suggestion after refactoring<br>\nthe code to make sure that both recursive calls use the same monotonically decreasing subset of the 2nd argument.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">applyMul</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">DCalcFactor</span> <span class=\"o\">:=</span> <span class=\"n\">fs2.toList</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2</span> <span class=\"o\">:=</span> <span class=\"n\">l2.head</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2tail</span> <span class=\"o\">:=</span> <span class=\"n\">HashMap.ofList</span> <span class=\"n\">l2.tail</span><span class=\"bp\">!</span>\n  <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">==</span> <span class=\"n\">fs2.size</span> <span class=\"k\">then</span>\n    <span class=\"n\">fs1</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">match</span> <span class=\"n\">fs1.getOp</span> <span class=\"n\">f2.fst</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.insert</span> <span class=\"n\">f2.fst</span> <span class=\"n\">f2.snd</span>\n      <span class=\"n\">applyMul</span> <span class=\"n\">fs1b</span> <span class=\"n\">f2tail</span>  <span class=\"c1\">-- tactic 'assumption' failed</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f1a</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Rat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">f12</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactor</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">f2.fst</span><span class=\"o\">,</span> <span class=\"n\">f1a</span> <span class=\"bp\">+</span> <span class=\"n\">f2.snd</span> <span class=\"o\">⟩</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1a</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.erase</span> <span class=\"n\">f2.fst</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">==</span> <span class=\"n\">f12.snd.num</span> <span class=\"k\">then</span> <span class=\"n\">fs1a</span> <span class=\"k\">else</span> <span class=\"n\">fs1a.insert</span> <span class=\"n\">f12.fst</span> <span class=\"n\">f12.snd</span>\n      <span class=\"n\">applyMul</span> <span class=\"n\">fs1b</span> <span class=\"n\">f2tail</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fs2.size</span> <span class=\"bp\">!=</span> <span class=\"mi\">0</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">HashMap.ofList</span> <span class=\"n\">fs2.toList.tail</span><span class=\"bp\">!</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fs2.size</span>\n</code></pre></div>\n<p>That there is no error on the 2nd match clause seems to be a consequence that the type checker stops at the 1st error.<br>\nIndeed, if I switch the order of the clauses, I get a similar error.</p>\n<p>I wanted to write the termination criteria by referring to one of the let bindings, similar to what I've seen in Lean's <br>\nInit/Data/Array/Basic.lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span>   <span class=\"o\">:=</span> <span class=\"n\">as.size</span>\n  <span class=\"k\">let</span> <span class=\"n\">mid</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">rev</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mid</span> <span class=\"k\">then</span>\n      <span class=\"n\">rev</span> <span class=\"o\">(</span><span class=\"n\">as.swap</span><span class=\"bp\">!</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">as</span>\n  <span class=\"n\">rev</span> <span class=\"n\">as</span> <span class=\"mi\">0</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mid</span> <span class=\"bp\">-</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>How is it that Lean4 in the above accepts a reference to a let binding, i.e., <code>mid</code>, but in my case it does not:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">applyMul</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">DCalcFactor</span> <span class=\"o\">:=</span> <span class=\"n\">fs2.toList</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2</span> <span class=\"o\">:=</span> <span class=\"n\">l2.head</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2tail</span> <span class=\"o\">:=</span> <span class=\"n\">HashMap.ofList</span> <span class=\"n\">l2.tail</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2tailsize</span> <span class=\"o\">:=</span> <span class=\"n\">f2tail.size</span>\n  <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">==</span> <span class=\"n\">fs2.size</span> <span class=\"k\">then</span>\n    <span class=\"n\">fs1</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">match</span> <span class=\"n\">fs1.getOp</span> <span class=\"n\">f2.fst</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f1a</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Rat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">f12</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactor</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">f2.fst</span><span class=\"o\">,</span> <span class=\"n\">f1a</span> <span class=\"bp\">+</span> <span class=\"n\">f2.snd</span> <span class=\"o\">⟩</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1a</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.erase</span> <span class=\"n\">f2.fst</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">==</span> <span class=\"n\">f12.snd.num</span> <span class=\"k\">then</span> <span class=\"n\">fs1a</span> <span class=\"k\">else</span> <span class=\"n\">fs1a.insert</span> <span class=\"n\">f12.fst</span> <span class=\"n\">f12.snd</span>\n      <span class=\"n\">applyMul</span> <span class=\"n\">fs1b</span> <span class=\"n\">f2tail</span> <span class=\"c1\">-- tactic 'assumption' failed</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.insert</span> <span class=\"n\">f2.fst</span> <span class=\"n\">f2.snd</span>\n      <span class=\"n\">applyMul</span> <span class=\"n\">fs1b</span> <span class=\"n\">f2tail</span>  <span class=\"c1\">-- tactic 'assumption' failed</span>\n<span class=\"c1\">--termination_by _ =&gt; fs2.size != 0 -&gt; (HashMap.ofList fs2.toList.tail!).size &lt; fs2.size</span>\n<span class=\"c1\">--termination_by _ =&gt; fs2.size != 0 -&gt; f2tail.size &lt; fs2.size -- unknown identifier 'f2tail.size'</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fs2.size</span> <span class=\"bp\">!=</span> <span class=\"mi\">0</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f2tailsize</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fs2.size</span> <span class=\"c1\">-- unknown identifier 'f2tailsize'</span>\n</code></pre></div>\n<p>I tried to minic the pattern used in <code>reverse</code> without success.</p>\n<p>On the other hand, I managed to make this variant work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">applyMulAux</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l2</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">DCalcFactor</span><span class=\"o\">):</span> <span class=\"n\">DCalcFactors</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l2</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">List.nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">fs1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">List.cons</span> <span class=\"n\">f2</span> <span class=\"n\">t2</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">fs1.getOp</span> <span class=\"n\">f2.fst</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f1a</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Rat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">f12</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactor</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">f2.fst</span><span class=\"o\">,</span> <span class=\"n\">f1a</span> <span class=\"bp\">+</span> <span class=\"n\">f2.snd</span> <span class=\"o\">⟩</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1a</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.erase</span> <span class=\"n\">f2.fst</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">==</span> <span class=\"n\">f12.snd.num</span> <span class=\"k\">then</span> <span class=\"n\">fs1a</span> <span class=\"k\">else</span> <span class=\"n\">fs1a.insert</span> <span class=\"n\">f12.fst</span> <span class=\"n\">f12.snd</span>\n      <span class=\"n\">applyMulAux</span> <span class=\"n\">fs1b</span> <span class=\"n\">t2</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.insert</span> <span class=\"n\">f2.fst</span> <span class=\"n\">f2.snd</span>\n      <span class=\"n\">applyMulAux</span> <span class=\"n\">fs1b</span> <span class=\"n\">t2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">applyMul</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span> <span class=\"o\">:=</span>\n  <span class=\"n\">applyMulAux</span> <span class=\"n\">fs1</span> <span class=\"n\">fs2.toList</span>\n</code></pre></div>\n<p>I would like to know what would it take to make the original version w/ a HashMap work as a well-founded recursion.</p>\n<ul>\n<li>Nicolas.</li>\n</ul>",
        "id": 269950004,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1643569736
    },
    {
        "content": "<p>The syntax is a bit off in your first snippet. What I was suggesting was something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">applyMul</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">DCalcFactor</span> <span class=\"o\">:=</span> <span class=\"n\">fs2.toList</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2</span> <span class=\"o\">:=</span> <span class=\"n\">l2.head</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2tail</span> <span class=\"o\">:=</span> <span class=\"n\">HashMap.ofList</span> <span class=\"n\">l2.tail</span><span class=\"bp\">!</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fs2.size</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">fs1</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f2tail.size</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fs2.size</span> <span class=\"o\">:=</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">fs2.size</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">HashMap.ofList</span> <span class=\"n\">fs2.toList.tail</span><span class=\"bp\">!</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fs2.size</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"n\">this</span> <span class=\"n\">h</span>\n    <span class=\"k\">match</span> <span class=\"n\">fs1.getOp</span> <span class=\"n\">f2.fst</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.insert</span> <span class=\"n\">f2.fst</span> <span class=\"n\">f2.snd</span>\n      <span class=\"n\">applyMul</span> <span class=\"n\">fs1b</span> <span class=\"n\">f2tail</span>  <span class=\"c1\">-- tactic 'assumption' failed</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f1a</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Rat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">f12</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactor</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">f2.fst</span><span class=\"o\">,</span> <span class=\"n\">f1a</span> <span class=\"bp\">+</span> <span class=\"n\">f2.snd</span> <span class=\"o\">⟩</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1a</span> <span class=\"o\">:=</span> <span class=\"n\">fs1.erase</span> <span class=\"n\">f2.fst</span>\n      <span class=\"k\">let</span> <span class=\"n\">fs1b</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">==</span> <span class=\"n\">f12.snd.num</span> <span class=\"k\">then</span> <span class=\"n\">fs1a</span> <span class=\"k\">else</span> <span class=\"n\">fs1a.insert</span> <span class=\"n\">f12.fst</span> <span class=\"n\">f12.snd</span>\n      <span class=\"n\">applyMul</span> <span class=\"n\">fs1b</span> <span class=\"n\">f2tail</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">fs1</span> <span class=\"n\">fs2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fs2.size</span>\n</code></pre></div>",
        "id": 269956181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643575445
    },
    {
        "content": "<p>that is, <code>fs2.size ≠ 0 → (HashMap.ofList fs2.toList.tail!).size &lt; fs2.size</code> is what you need to prove to make this termination argument work</p>",
        "id": 269956196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643575464
    },
    {
        "content": "<p>This code is somewhat inefficient in repeatedly converting a hashmap into a list and back again on every iteration, so I would expect your second approach to be more efficient in addition to being much easier to prove termination</p>",
        "id": 269956242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643575528
    },
    {
        "content": "<p>By the way, I see you use <code>if 0 == value</code> a lot. I guess you learned to use these \"yoda conditionals\" in java land, but in lean there really isn't any need to do this at all, because assignment doesn't use <code>=</code> and isn't an expression anyway - there is no way you could write an assignment inside an if conditional even if you wanted to</p>",
        "id": 269956444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643575793
    },
    {
        "content": "<p>It's also useful when capturing hypotheses about if-statements to write them idiomatically for the lemmas they will be used with. I changed the first if statement to <code>if h : fs2.size = 0</code> so that the else branch gets an assumption <code>fs2.size ≠ 0</code>, which is necessary for the proof of the <code>sorry</code></p>",
        "id": 269956537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643575893
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"362579\">@Nicolas Rouquette</span></p>",
        "id": 269956600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643575948
    },
    {
        "content": "<p>You should only use yoda comparisons like <code>0 &lt; value</code> :)</p>",
        "id": 269957730,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1643577029
    },
    {
        "content": "<p>We should rename <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/lint/misc.lean#L96\">linter.ge_or_gt</a> to <code>linter.yoda</code>.</p>",
        "id": 269958025,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1643577379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Need.20suggestions.20to.20improve.20a.20DSL.20for.20dimensional.20calculus/near/269956181\">said</a>:</p>\n<blockquote>\n<p>The syntax is a bit off in your first snippet. What I was suggesting was something like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">applyMul</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span> <span class=\"o\">:=</span>\n<span class=\"bp\">...</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">fs1</span> <span class=\"n\">fs2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fs2.size</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Hum, based on what I see in mathlib4, I get the feeling that there are at least two ways to prove properties of functions (recursive or not):</p>\n<p>1) Add the <code>termination_by _ &lt;arguments&gt; =&gt; ....</code> clause<br>\n2) Use an auxiliary function where the return carries a proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">applyMulAux</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">fs2'</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span> <span class=\"bp\">//</span> <span class=\"c1\">-- invariant property about fs2 and fs2' } :=</span>\n<span class=\"bp\">...</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">applyMul</span> <span class=\"o\">(</span><span class=\"n\">fs1</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs2</span><span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DCalcFactors</span> <span class=\"o\">:=</span>\n  <span class=\"n\">applyMulAux</span> <span class=\"n\">fs1</span> <span class=\"n\">fs2</span>\n</code></pre></div>\n<p>If this is more or less correct, is this strategy explained in the lean4 doc somewhere?</p>",
        "id": 269966654,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1643587819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Need.20suggestions.20to.20improve.20a.20DSL.20for.20dimensional.20calculus/near/269904504\">said</a>:</p>\n<blockquote>\n<p>For (2) your best bet is to put the functions in mathlib4. Most of us also have a <code>for_mathlib</code> file or directory in our projects containing definitions and lemmas that aren't really project specific and really ought to be PR'd to mathlib but we haven't got around to it yet</p>\n</blockquote>\n<p>Interesting, where can I find an example of a <code>for_mathlib</code> folder?</p>\n<p>I understand that proving properties of functions depends a great deal on the proofs already available about the data structures involved in such functions. In my case, <code>HashMap</code> seems very thin w.r.t proofs in lean4 compared to <code>has_map</code> in Lean3's mathlib. <br>\nWith Lean4, I am exploring using <code>BinaryHeap</code>; however, I probably will need some extensions like <code>contains</code>.<br>\nI would like to follow your suggestion and test such extensions in my application before suggesting a PR.</p>\n<ul>\n<li>Nicolas.</li>\n</ul>",
        "id": 269968020,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1643589661
    },
    {
        "content": "<p>The two mechanisms you mention are not mutually exclusive. You often need (2) in order to actually do the proof of (1)</p>",
        "id": 269971350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643594002
    },
    {
        "content": "<p>In this case you don't need it, but conceivably the way you recurse depends on the value you get back, in which case you have to know some property of the value. For example in <code>heapifyDown</code> we need to know that the returned heap has the same size as the original so that subsequent accesses to the heap don't go out of bounds</p>",
        "id": 269971594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643594331
    },
    {
        "content": "<blockquote>\n<p>I understand that proving properties of functions depends a great deal on the proofs already available about the data structures involved in such functions. In my case, HashMap seems very thin w.r.t proofs in lean4 compared to has_map in Lean3's mathlib. </p>\n</blockquote>\n<p>Yes, I started looking into this and it is more than a few hours of work to add all the missing lemmas for hashmaps, so I decided not to get into it today. Some things might not even be provable, because of the use of <code>constant</code>s like <code>UInt32.toUSize</code> in the implementation</p>",
        "id": 269971784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643594491
    },
    {
        "content": "<blockquote>\n<p>With Lean4, I am exploring using BinaryHeap; however, I probably will need some extensions like contains.<br>\nI would like to follow your suggestion and test such extensions in my application before suggesting a PR.</p>\n</blockquote>\n<p>Contains? Binary heaps don't really support membership queries faster than linear search. If you want to do linear search you can do so by using <code>heap.1</code> to access the underlying array</p>",
        "id": 269971863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643594591
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/tree/master/src/for_mathlib\">https://github.com/leanprover-community/lean-perfectoid-spaces/tree/master/src/for_mathlib</a> is a for_mathlib directory FWIW</p>",
        "id": 269990260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643614815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Need.20suggestions.20to.20improve.20a.20DSL.20for.20dimensional.20calculus/near/269990260\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/tree/master/src/for_mathlib\">https://github.com/leanprover-community/lean-perfectoid-spaces/tree/master/src/for_mathlib</a> is a for_mathlib directory FWIW</p>\n</blockquote>\n<p>Ah yes, though this is based on the lean3 code organization. For lean4, I am looking for lake-based configurations; I think I found two interesting examples for potential additions to mathlib4 and to lean4's library respectively:</p>\n<p><a href=\"https://github.com/lecopivo/SciLean/tree/master/SciLean/Mathlib\">https://github.com/lecopivo/SciLean/tree/master/SciLean/Mathlib</a><br>\n<a href=\"https://github.com/gebner/quote4/tree/master/Qq/ForLean\">https://github.com/gebner/quote4/tree/master/Qq/ForLean</a></p>",
        "id": 270147531,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1643687342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Need.20suggestions.20to.20improve.20a.20DSL.20for.20dimensional.20calculus/near/269971863\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>With Lean4, I am exploring using BinaryHeap; however, I probably will need some extensions like contains.<br>\nI would like to follow your suggestion and test such extensions in my application before suggesting a PR.</p>\n</blockquote>\n<p>Contains? Binary heaps don't really support membership queries faster than linear search. If you want to do linear search you can do so by using <code>heap.1</code> to access the underlying array</p>\n</blockquote>\n<p>Right, I think you meant something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.BinaryHeap</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">BinaryHeap</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">contains</span> <span class=\"o\">{</span><span class=\"n\">lt</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">BinaryHeap</span> <span class=\"n\">α</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">self.arr.contains</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">BinaryHeap</span>\n</code></pre></div>",
        "id": 270154854,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1643692692
    },
    {
        "content": "<p>Right. (FYI you can use <code>self.1</code> in place of <code>self.arr</code> there, which is what I was alluding to)</p>",
        "id": 270170384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643705252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Need.20suggestions.20to.20improve.20a.20DSL.20for.20dimensional.20calculus/near/270170384\">said</a>:</p>\n<blockquote>\n<p>Right. (FYI you can use <code>self.1</code> in place of <code>self.arr</code> there, which is what I was alluding to)</p>\n</blockquote>\n<p>Wow.. I did not realize that lean4 supports an index-based reference for class/structure fields!<br>\nI think this should be explained in the doc (<a href=\"https://leanprover.github.io/lean4/doc/struct.html\">https://leanprover.github.io/lean4/doc/struct.html</a>)<br>\nSeparately, can you explain how useful this trick has been to your lean4 programming practice?</p>",
        "id": 270336556,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1643779644
    },
    {
        "content": "<p>I use it all the time in lean 3, it saves me from having to look up the names and it's shorter too</p>",
        "id": 270337561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780620
    },
    {
        "content": "<p>Since <code>BinaryHeap</code> is a newtype it's more natural to just use indexing notation since the field name is irrelevant</p>",
        "id": 270337646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643780688
    }
]
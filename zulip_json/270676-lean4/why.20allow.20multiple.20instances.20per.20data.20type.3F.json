[
    {
        "content": "<p>What is the motivation for allowing multiple instances for a same type, in lean?<br>\nAre there some simple examples showing why its very beneficial in mathlib or elsewhere ? <br>\nHaving some Haskell experience myself, I think Haskell people would yell at this design choice.<br>\nHaskell enforces at most 1 type class instance per type, I think one good reason is that it is safer in a programming context.<br>\nFor example, if a remote programmer writes a different instance for a same type (with a higher priority) in a remote dependency, and the compiler allows this,  some instances that your program used might get unintentionnaly swapped. It sounds bad to me because undesired swaps might result in undefined program behavior, and deadly crashes, which is unacceptable for a production environnement.<br>\nI feel that in the context of mathlib and theorem proving, it is not as big of a deal, because the worst that can happen, is that someone else breaks your proof, and you have to fix it, being more explicit about which instances you need. However if lean 4 has the ambition of also being a general purpose programming language, that type class design looks questionable to me.<br>\nPlease correct me if any of my understanding is wrong, I am very new to lean.</p>",
        "id": 238164702,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620661615
    },
    {
        "content": "<p>Our library design is supposed to only allow one instance per class on a type, but how would you enforce that in general? For example in classical mathematics you absolutely need to sometimes allow having all Props decidable, so what about the ones which have a constructive instance?</p>",
        "id": 238167271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620662585
    },
    {
        "content": "<p>And of course by \"multiple instances\" you need to say what you mean for two instances to be the same...</p>",
        "id": 238167525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620662672
    },
    {
        "content": "<p>Because types are so much more sophisticated in Lean than Haskell (namely, they can contain what we think of as “values” in Haskell), it turns out that the question of when two types are equal is correspondingly more subtle. So while the “one instance per type” makes a lot of sense in the type language of Haskell, where types are very concretes/tractable, it’s much much harder to enforce in dependent type theories, to the point where the best option is really to drop that restriction. The good news is that dependent type theories also give you tools to alleviate the problems: types can now depend on instances, and you can make use of proofs that two instances are equal if it really comes down to that. But mostly it’s just up to good engineering/useful conventions to make sure that instances don’t conflict in the common scenarios.</p>",
        "id": 238168199,
        "sender_full_name": "Nick Scheel",
        "timestamp": 1620662942
    },
    {
        "content": "<p>To be more specific: the most commonly cited example of why canonicity matters in Haskell is with the use of <code>Set a</code>, a datatype which tabulates its elements in order and thus depends on having the same <code>Ord a</code> instance every time to ensure that insertions and other operations make sense. However, in dependent type theories, you can formulate <code>Set</code> in a way that the _type_ depends on the instance: that is, it has the shape <code>Set : forall a, Ord a -&gt; Type</code>, and usages look like <code>Set Nat OrderingOnNat</code> (although the instance <code>OrderingOnNat</code> is usually implicit). So when the consistency of the instance matters, you can actually enforce that restriction at the type level.</p>",
        "id": 238169096,
        "sender_full_name": "Nick Scheel",
        "timestamp": 1620663245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"403214\">Michael Jam</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238164702\">said</a>:</p>\n<blockquote>\n<p>I feel that in the context of mathlib and theorem proving, it is not as big of a deal, because the worst that can happen, is that someone else breaks your proof, and you have to fix it, being more explicit about which instances you need.</p>\n</blockquote>\n<p>It's a big deal for mathlib. We are constantly trying to make sure that there is at most one instance.<br>\nBecause diamonds = headaches</p>",
        "id": 238169133,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620663257
    },
    {
        "content": "<p>(For the mathematicians: of course <code>Set</code> means finite set.)</p>\n<p>Note that having different instances inferred should not compromise the strength of any proofs, or any safely-written code. The worst that happens is that the instances genuinely don’t line up and the compiler complains. But sometimes the instances should line up, but the compiler can’t see why! So it’s mostly an annoyance, not a security hole.</p>",
        "id": 238169788,
        "sender_full_name": "Nick Scheel",
        "timestamp": 1620663478
    },
    {
        "content": "<p>OK thanks all for clarifying the situation</p>",
        "id": 238173880,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620665051
    },
    {
        "content": "<p>So if I write this :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">Nat</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">i.n</span>\n<span class=\"k\">#eval</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>f is able to fetch a Nat instance, so the type checker has to somehow know which instances satisfy the constraint...<br>\nSo why cannot it figure out that there are two such instances for Nat and report it?</p>",
        "id": 238177145,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620666370
    },
    {
        "content": "<p>Because it stops when it finds the first one, which is an arbitrary one because you have written unidiomatic code</p>",
        "id": 238178208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620666808
    },
    {
        "content": "<p>I really don't want my type checker saying \"ok let's check that there are no more instances\" not least because in the algebra heirarchy there might be literally hundreds of other ways of constructing the same instance</p>",
        "id": 238178435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620666895
    },
    {
        "content": "<p>The classes we use in mathlib are classes where \"clearly\" there are, under normal circumstances, at most one instance. There are times when we do actually need more than one instance of a class and we do this using type aliases(eg <code>dual X := X</code> but with the opposite order), which is going to cause real problems for a system attempting to check that there's at most one instance per class up to definitional equality</p>",
        "id": 238178847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620667046
    },
    {
        "content": "<p>so if you use instance priorities, is it much slower because it will check everything?</p>",
        "id": 238179322,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620667219
    },
    {
        "content": "<p>Instance priorities are used in mathlib. I don't really understand the question. For example we sometimes switch on \"mathematician mode\" by adding an instance saying that every Prop is decidable, with low priority; that way if the system wants to check that equality on Nat is decidable, it will find the constructive instance first, but if it wants to check that equality on a random type X is decidable it will end up finding the classical one.</p>",
        "id": 238180169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620667559
    },
    {
        "content": "<p>well if I use priorities on my two instances, I mean the checker has to have knowledge of both to compare their priorities and use the one that's highest. So it has a way to understand there are two instances of that Nat type, if i'm not mistaken</p>",
        "id": 238180451,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620667669
    },
    {
        "content": "<p>I thought you guys were kind of saying it's not feasible to enforce at most one instance per type. I was just trying to understand better if its for performance reasons or other reasons. But I guess now I need to get more experience with the language</p>",
        "id": 238180967,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620667852
    },
    {
        "content": "<p>Are you wanting this feature?  Multiple instances in Lean do not generate incorrect code the way they potentially can in Haskell.</p>",
        "id": 238181117,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1620667917
    },
    {
        "content": "<p>If the meaning of your program is 100% mathematically specified it should not be a problem, you're right.<br>\nI think for everyday programming, one can write underspecified, or to-be-specified-later code, and in that case it might be an issue</p>",
        "id": 238182286,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620668390
    },
    {
        "content": "<p>I like this! \"Mathlib -- not your everyday programming\". Yes, all I do is prove theorems in this software, I never run #eval or #reduce or anything like that</p>",
        "id": 238185995,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620669812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"403214\">Michael Jam</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238182286\">said</a>:</p>\n<blockquote>\n<p>If the meaning of your program is 100% mathematically specified it should not be a problem, you're right.<br>\nI think for everyday programming, one can write underspecified, or to-be-specified-later code, and in that case it might be an issue</p>\n</blockquote>\n<p>Worrying that there might be multiple nonequivalent implementations of a typeclass is somewhat similar to worrying that a class doesn't implement an interface \"lawfully\" in traditional programming. Sure, maybe the object implements <code>hashCode</code> but always returns 0, but that would be a really stupid thing to do, and generally people don't worry about it and use documentation to enforce behavioral constraints without assuming that all programmers are adversaries. In lean you have a bit more help from the compiler, meaning that if you have a mixup it's pretty likely to cause a compile error somewhere. It's not perfect, especially if you are using lean like as if it were java, but improved bug detection is already a pretty big value add.</p>",
        "id": 238186825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620670132
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403214\">@Michael Jam</span>  For context, I think being able to have multiple instances of a typeclass is a <em>feature</em> of lean and not necessarily indicative of a bug.  If one wants to ensure a typeclass is used consistently across a data structure just make the typeclass part of the datastructure type. <br>\nObviously there could be bugs where a developer doesn't do that and should have, but I don't think it's the job of the language to add checks for things that <em>might</em> be a bug.   Perhaps one could write a linter to check this sort of thing if it is really important in a specific use case.</p>",
        "id": 238196088,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1620673811
    },
    {
        "content": "<p>I had in mind a very hypothetical future where lean dominates the world like a widespread java, and many businesses having many interdependencies run on lean albeit with poorly specified code, because good programmers are hard to find and verifying software is costly. <br>\nSome malicious competitor could decide to publish an update to a library you depend on, whichs swaps one of your poorly specified instances with some other distinct behavior just to crash your business. But yeah, it's more of an issue about people producing low quality code, than about the language itself... Perhaps I worry too much...</p>",
        "id": 238198070,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620674726
    },
    {
        "content": "<p>The obvious solution to that is to put invariants in your structures to make it impossible to smuggle relevant behavioral changes. That's where Lean wins compared to the other guys: that's just not possible to do (at compile time) unless you have a really strong type system, and if you are using lean you may as well take advantage of it.</p>",
        "id": 238201845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620676511
    },
    {
        "content": "<p>Sure, but Michael was talking about underspecified or to-be-specified-later code...</p>",
        "id": 238203062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620677001
    },
    {
        "content": "<p>when you don't take precautions, sometimes you get burned</p>",
        "id": 238203124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620677034
    },
    {
        "content": "<p>The language can't make you do anything. At best it provides the means to do better, ideally such that it is easier to do right than do wrong (the \"pit of success\"). But you can be foolish in every programming language</p>",
        "id": 238203344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620677131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238178208\">said</a>:</p>\n<blockquote>\n<p>Because it stops when it finds the first one, which is an arbitrary one because you have written unidiomatic code</p>\n</blockquote>\n<p>This arbitrary selection of a satisfying instance is, in my opinion, a core feature of Lean's type classes. Type classes, in general, are suppose to enforce a abstract constraint on a type and a consumer of said type class is supposed to not care about which particular satisfying implementation of that constraint it is (when using a synthesized instance as opposed to an explicit one). A program which does care is breaking this contract and thus should be aware of the potential for undesired behavior. Obviously, this ideal is not always stuck to, but it does explain the logic of allowing multiple instances.</p>\n<p>It is also were noting that type classes in Lean and Haskell are very different mechanically. Both their runtime representations and their instance selection procedures vary wildly and heavily affect the constraints placed on them.</p>",
        "id": 238226669,
        "sender_full_name": "Mac",
        "timestamp": 1620688995
    },
    {
        "content": "<p>I agree with the consensus here but I did worry about this a while back and came up with the example here: <a href=\"#narrow/stream/113488-general/topic/multiple.20solutions.20for.20typeclass.20search/near/216002921\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/multiple.20solutions.20for.20typeclass.20search/near/216002921</a></p>\n<p>With apologies for reusing a Lean 3 example in this Lean 4 stream, you can do some mildly concerning things like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">foo.x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo_inst</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">37</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar_val</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"bp\">=</span> <span class=\"mi\">37</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">baz_val</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f.x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Just to hammer home the point: we can prove `baz` and `bar` agree:</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">bar_eq_baz</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- and yet:</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">bar</span> <span class=\"c1\">-- 37</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">baz</span> <span class=\"o\">⟨</span><span class=\"mi\">73</span><span class=\"o\">⟩</span> <span class=\"c1\">-- 73</span>\n</code></pre></div>",
        "id": 238280770,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1620727191
    },
    {
        "content": "<p>Yes I think this conversation so far lacked some examples.<br>\nHere I will give a few examples that I randomly thought of :</p>\n<p>Assume that you are a company A and you have a main program which does some complicated stuff, that requires many imports.<br>\nAssume one of these imports is from a malicious company B. Assume the main does a bunch of println.<br>\nFor the sake of simplicity say your program looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">CompanyB.lib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">companyA_main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">IO.println</span> <span class=\"mi\">5</span>\n<span class=\"k\">#eval</span> <span class=\"n\">companyA_main</span>\n</code></pre></div>\n<p>println implicitly depends on toString. The definition of ToString is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n</code></pre></div>\n<p>The informal meaning of an expression like  \"toString x\", as I understand it, is \"a string that represents x of type α in a human readable way\"<br>\n\"human readable way\" is not something that can be mathematically formalized. So the most information that can be specified in the type system about it is \"String\". Because of that I believe this function is underspecified and unsafe to use if we allow multiple instances for a data type.</p>\n<p>A malicious company B could decide to add this in CompanyB.lib  :  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">toString</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"s2\">\"0\"</span>\n</code></pre></div>\n<p>And then someday, you will update your dependencies because it's cool to stay up to date, and your program will behave badly. (in that case companyA_main  will display \"0\" instead of \"5\")</p>\n<p>Now I can even do bad things if your typeclass is completely formalized:<br>\nIf I have this class:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Double</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">double</span>  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Then I can write different instances like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Double</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">double</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Double</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">double</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.mul_succ</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_one</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>Here you think that you are safe because double is specified to always return the double, so even if you write different implementations, they should do the same thing.<br>\nWell I argue that you are not completely safe because the type information does not give any information about the computation time.<br>\nCompany B can write an instance that will compute the right result in a very very long time, for example by inserting a system sleep, or by adding a useless very long calculation on purpose.</p>\n<p>Company A's build system will not report any problem, they will say it's all correct and verified, but actually when company launches their program, it will freeze for almost ever which could result in damage.</p>\n<p>I think in Haskell this whole situation is not possible, because the compiler can detect if there are two conflicting instances in scope, so you never have to consider this risk. I don't really remember how other languages deal with that. </p>\n<p>I think those kind of security risks might have to be considered if lean is ever willing to hit a bigger, more programming focused crowd. <br>\nI'm happy to hear if you have objections with my assumptions or reasoning.</p>",
        "id": 238340054,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620751305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"403214\">Michael Jam</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238340054\">said</a>:</p>\n<blockquote>\n<p>The definition of ToString is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n</code></pre></div>\n<p>The informal meaning of an expression like  \"toString x\", as I understand it, is \"a string that represents x of type α in a human readable way\"<br>\n\"human readable way\" is not something that can be mathematically formalized. So the most information that can be specified in the type system about it is \"String\". Because of that I believe this function is underspecified and unsafe to use if we allow multiple instances for a data type.</p>\n<p>A malicious company B could decide to add this in CompanyB.lib  :  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span> <span class=\"n\">toString</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"s2\">\"0\"</span>\n</code></pre></div>\n<p>And then someday, you will update your dependencies because it's cool to stay up to date, and your program will behave badly. (in that case companyA_main  will display \"0\" instead of \"5\")</p>\n</blockquote>\n<p>Haskell at least partially solves the \"human-readable\" <code>ToString</code> by having two classes <code>Show := (show : A -&gt; String)</code> and <code>Read  := (read : String -&gt; A)</code> such that they are suppose to be inverses of each other (i.e. <code>read (show a) = a : A</code> and <code>show (read a : A) = a</code>. For many examples of <code>ToString</code>, such a specification works. However, there are some cases where producing the inverse <code>read</code> is not feasible/desirable, but then the idea of the class is very under-specified so it makes sense to me that relying on could produce nonsense results like <code>\"0\"</code> for some complex type.  To quote <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238203124\">said</a>:</p>\n<blockquote>\n<p>when you don't take precautions, sometimes you get burned</p>\n</blockquote>\n<p>Though I imagine this is a matter of preference.</p>",
        "id": 238359968,
        "sender_full_name": "Mac",
        "timestamp": 1620757664
    },
    {
        "content": "<p>Actually, I think where things go wrong is here:</p>\n<blockquote>\n<p>Assume that you are a company A and you have a main program which does some complicated stuff, that requires many imports.<br>\nAssume one of these imports is from a malicious company B.</p>\n</blockquote>\n<p>I'm sorry, but if you can't trust your dependencies you are already hosed. Lean code can do arbitrary bad things</p>",
        "id": 238360511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620757853
    },
    {
        "content": "<p>See the infamous <a href=\"https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/\">leftpad debacle</a></p>",
        "id": 238360727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620757935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"403214\">Michael Jam</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238340054\">said</a>:</p>\n<blockquote>\n<p>Well I argue that you are not completely safe because the type information does not give any information about the computation time.<br>\nCompany B can write an instance that will compute the right result in a very very long time, for example by inserting a system sleep, or by adding a useless very long calculation on purpose.</p>\n</blockquote>\n<p>This is actually kind of the point, but in the reverse. By allowing multiple instances, additional instances can be added (with higher priority) that may compute more efficiently. This does, though, in turn, mean it can be used for the reverse (forcing an more inefficient instance instead). You could further specific the instance by required  a proof that the algorithm is more efficient than some baseline -- Lean could actually potentially  do something like this -- but that seems like overkill.</p>\n<p>It is also worth noting that the same is true for most underspecified programs in general. If I am using some library which has an under-specified normal <code>def</code>,  it could maliciously change that <code>def</code> in future update to mess with my use case. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- In Lib 1.0</span>\n<span class=\"kd\">def</span> <span class=\"n\">greet</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">()</span> <span class=\"o\">:=</span> <span class=\"n\">println</span> <span class=\"s2\">\"Hello World\"</span>\n\n<span class=\"c1\">-- My Library</span>\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">()</span> <span class=\"o\">:=</span> <span class=\"n\">greet</span>\n\n<span class=\"c1\">-- In Lib 1.666</span>\n<span class=\"kd\">def</span> <span class=\"n\">greet</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">()</span> <span class=\"o\">:=</span> <span class=\"n\">launchNukes</span>\n</code></pre></div>\n<p>Now my programs launches the nukes! Oops! (In keeping with the comparisons to Haskell, <code>launchNukes</code> is a common demonstration of potential unsafety in Haskell.) Thus, I feel like the problem here is depending on malicious libraries not really Lean itself.</p>",
        "id": 238363320,
        "sender_full_name": "Mac",
        "timestamp": 1620759064
    },
    {
        "content": "<blockquote>\n<p>You could further specific the instance by required a proof that the algorithm is more efficient than some baseline -- Lean could actually potentially do something like this -- but that seems like overkill.</p>\n</blockquote>\n<p>As far as I know there is no way in lean to express the running time of an algorithm expressed directly as the inhabitant of a type. This is a fundamental and in some senses deliberate limitation of dependent type theory.</p>",
        "id": 238363922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620759357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"403214\">Michael Jam</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238340054\">said</a>:</p>\n<blockquote>\n<p>I think those kind of security risks might have to be considered if lean is ever willing to hit a bigger, more programming focused crowd. <br>\nI'm happy to hear if you have objections with my assumptions or reasoning.</p>\n</blockquote>\n<p>I think both of the examples you gave also point to the fact that you can't rely on behavior that you haven't specified, let alone proved. Yes, if a dependency unexpectedly changes the <code>ToString</code> implementation for some type I might be screwed, but if I was relying on it working a certain way because I eyeballed it once a few versions back, it's hard to say that this is an issue with Lean.</p>",
        "id": 238364064,
        "sender_full_name": "Chris B",
        "timestamp": 1620759404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238363922\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>You could further specific the instance by required a proof that the algorithm is more efficient than some baseline -- Lean could actually potentially do something like this -- but that seems like overkill.</p>\n</blockquote>\n<p>As far as I know there is no way in lean to express the running time of an algorithm expressed directly as the inhabitant of a type. This is a fundamental and in some senses deliberate limitation of dependent type theory.</p>\n</blockquote>\n<p>As the way Lean currently stands, yes. But you could prove things about the Lean code generator which could then use to prove things about type representations and functions which would then allow you prove constraints on runtime. It would require an immense undertaking though.</p>",
        "id": 238364531,
        "sender_full_name": "Mac",
        "timestamp": 1620759620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238360511\">said</a>:</p>\n<blockquote>\n<p>I'm sorry, but if you can't trust your dependencies you are already hosed. Lean code can do arbitrary bad things</p>\n</blockquote>\n<p>This is actually a much greater concern in Lean than it is in compiled languages like Haskell and C++. Lean's compiler is also an interpreter. Thus, any code can produce arbitrary effects at compile time. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- In Lib 1.666</span>\n<span class=\"k\">#eval</span> <span class=\"n\">launchNukes</span>\n</code></pre></div>\n<p>Would be perfectly valid Lean that would launch the nukes at compile time for any application that imported Lib 1.666.</p>",
        "id": 238365259,
        "sender_full_name": "Mac",
        "timestamp": 1620759894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238280770\">said</a>:</p>\n<blockquote>\n<p>I agree with the consensus here but I did worry about this a while back and came up with the example here: <a href=\"#narrow/stream/113488-general/topic/multiple.20solutions.20for.20typeclass.20search/near/216002921\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/multiple.20solutions.20for.20typeclass.20search/near/216002921</a></p>\n</blockquote>\n<p>Here is the example in Lean 4 (with addendum):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">foo.x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo_inst</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">37</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar_val</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"bp\">=</span> <span class=\"mi\">37</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">baz_val</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f.x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Just to hammer home the point: we can prove `baz` and `bar` agree:</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bar_eq_baz</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">baz</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- and yet:</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">bar</span> <span class=\"c1\">-- 37</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">baz</span> <span class=\"o\">⟨</span><span class=\"mi\">73</span><span class=\"o\">⟩</span> <span class=\"c1\">-- 73</span>\n\n<span class=\"c1\">-- but note:</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">bar_eq_baz</span> <span class=\"o\">⟨</span><span class=\"mi\">73</span><span class=\"o\">⟩</span> <span class=\"c1\">-- Eq.refl 73 -- i.e. 73 = 73</span>\n</code></pre></div>\n<p>The reason <code>bar_eq_baz</code> is provable is because <code>bar</code> is guaranteed to use the <code>foo</code> <code>f</code> provided as an argument. Thus <code>bar_eq_baz</code> really is just <code>f.x = f.x</code> (which is trivially true).</p>",
        "id": 238365905,
        "sender_full_name": "Mac",
        "timestamp": 1620760127
    },
    {
        "content": "<p>Right it's more of an assumption issue... in lean, if you don't trust your dependencies you're kind of dead anyway, because arbitrary code might run in your machine while type checking.<br>\nI agree that in general it's better to minimize dependencies as much as possible, or even better, to not have any.<br>\nIn the real world, I feel like lots of programmers like to use way too many dependencies because they are brainwashed with \"do not reinvent the wheel\" or \"there's this brand new plugin from cool guys at google\".<br>\nSo perhaps you are saying lean type class design could incentivize people to change their behavior and be extremely careful with dependencies... Interesting idea...</p>",
        "id": 238376400,
        "sender_full_name": "Michael Jam",
        "timestamp": 1620764699
    },
    {
        "content": "<p>Seeing as the paranoid crowd are in, I'm assuming that Lean 4 can still <a href=\"https://github.com/leanprover/lean/issues/1781\">clean your hard disk</a>, making most of the suggestions above look rather run-of-the-mill in comparison.</p>",
        "id": 238383227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620767701
    },
    {
        "content": "<p>My reading here of Oliver's example is that you can end up proving something for the wrong typeclass without realizing, and then when you actually use them with a different typeclass you don't have the guarantees you thought you'd proven</p>",
        "id": 238384420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620768206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238383227\">said</a>:</p>\n<blockquote>\n<p>Seeing as the paranoid crowd are in, I'm assuming that Lean 4 can still <a href=\"https://github.com/leanprover/lean/issues/1781\">clean your hard disk</a>, making most of the suggestions above look rather run-of-the-mill in comparison.</p>\n</blockquote>\n<p>For comedy's sake, I must emphatically state that I am worried that you deem launching nukes to be run-of-the-mill in comparison to cleaning your hard disk. XD</p>",
        "id": 238384805,
        "sender_full_name": "Mac",
        "timestamp": 1620768368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20allow.20multiple.20instances.20per.20data.20type.3F/near/238384420\">said</a>:</p>\n<blockquote>\n<p>My reading here of Oliver's example is that you can end up proving something for the wrong typeclass without realizing, and then when you actually use them with a different typeclass you don't have the guarantees you thought you'd proven</p>\n</blockquote>\n<p>True, though I think there are many aspects of learn that can confuse people initially. I would not say Lean has a particularly low learning curve.</p>",
        "id": 238384944,
        "sender_full_name": "Mac",
        "timestamp": 1620768469
    }
]
[
    {
        "content": "<p>In the following (somewhat minimal) mwe, the last two <code>example</code>s behave unexpectedly for me (at least, based on my lean3 understanding). Why would <code>apply</code> break but <code>refine</code> is fine? Why does the goal in the term mode example display the statement describing an unfolded set <code>Le</code> instead of a plain <code>Le</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HasMem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">PartialOrder</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">HasLessEq</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n  <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">s</span>\n  <span class=\"n\">antisymm</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n  <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">HasLessEq.LessEq.trans</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">PartialOrder.trans</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HasMem.mem</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasMem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">propext</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasLessEq</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">PartialOrder</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span>\n  <span class=\"n\">antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hst</span> <span class=\"n\">hts</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">hst</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">⟩</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"n\">hst</span> <span class=\"n\">htu</span> <span class=\"n\">x</span> <span class=\"n\">hxs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">htu</span> <span class=\"bp\">$</span> <span class=\"n\">hst</span> <span class=\"n\">hxs</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyz</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">hxy.trans</span> <span class=\"n\">hyz</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">hxy.trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hyz</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hxy.trans</span> <span class=\"c1\">-- failed to unify</span>\n  <span class=\"gr\">admit</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span> <span class=\"c1\">-- goal view has the unfolded `x✝ ∈ x → x✝ ∈ z` instead of `x ≤ y`</span>\n</code></pre></div>",
        "id": 231647441,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616597650
    },
    {
        "content": "<p>The unfolded situation at the bottom example improves when we instead say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasLessEq</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">⟩</span> <span class=\"c1\">-- notice the explicit arg</span>\n</code></pre></div>",
        "id": 231660706,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616601949
    },
    {
        "content": "<p>So it seems like it is eagerly expanding the lambda when the lambda has an implicit arg</p>",
        "id": 231660832,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616601982
    },
    {
        "content": "<p>I'm also seeing this. If <code>instance : HasLessEq (Set α) := ⟨λ s t =&gt; ∀ {a : α}, a ∈ s → a ∈ t⟩</code> with implicit <code>a</code> then goals unfold from <code>x ⊓ y  ≤ x</code>to <code>x✝ ∈ x ⊓ y → x✝ ∈ x</code> and then I can't directly apply a theorem saying <code>x ⊓ y  ≤ x</code> because I get a <code>typeclass instance problem is stuck</code> error; I have to explicitly tell <code>infLeLeft</code> that I'm talking about <code>Set α</code>. Conversely if I define <code>instance : HasLessEq (Set α) := ⟨λ s t =&gt; ∀ (a : α), a ∈ s → a ∈ t⟩</code> with explicit <code>a</code> then I get extra <code>_</code>s everywhere (but it stops <code>x ⊓ y  ≤ x</code> from unfolding).</p>",
        "id": 231875504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616706147
    },
    {
        "content": "<p>This is what <code>{{a : A}}</code> binders are for</p>",
        "id": 231876171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616706461
    },
    {
        "content": "<p>Yes, but are those a thing in lean4?</p>",
        "id": 231876481,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616706593
    },
    {
        "content": "<p>Just checked: no</p>",
        "id": 231876590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616706630
    },
    {
        "content": "<p>Yakov just pointed out this from the manual:</p>\n<blockquote>\n<p>Implicit lambdas<br>\nIn Lean 3 stdlib, we find many instances of the dreadful @+_ idiom. It is often used when we the expected type is a function type with implicit arguments, and we have a constant (reader_t.pure in the example) which also takes implicit arguments. In Lean 4, the elaborator automatically introduces lambdas for consuming implicit arguments. We are still exploring this feature and analyzing its impact, but the experience so far has been very positive. As an example, here is the example in the link above using Lean 4 implicit lambdas.</p>\n</blockquote>",
        "id": 231876963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616706827
    },
    {
        "content": "<p>OK so it's not hard to work around:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">HasMem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HasMem.mem</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasMem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasLessEq</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">⟩</span> <span class=\"c1\">-- implicit seems best</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">HasInf</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inf</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\" ⊓ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HasInf.inf</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasInf</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">infLeLeft</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊓</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">And.left</span> <span class=\"c1\">-- introducing implicits works great here</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">infLeRight</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊓</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">And.right</span> <span class=\"c1\">-- introducing implicits works great here</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inter_mem_sets_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">},</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">⊓</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">hf</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">infLeLeft</span><span class=\"o\">),</span> <span class=\"c1\">-- introducing implicits work great if you finish the job</span>\n                 <span class=\"n\">hf</span> <span class=\"n\">h</span> <span class=\"bp\">?</span><span class=\"n\">h2</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"c1\">-- but here I don't finish the job</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">    goal now not x ⊓ y ≤ y, but</span>\n<span class=\"cm\">    x✝ : α</span>\n<span class=\"cm\">    ⊢ x✝ ∈ x ⊓ y → x✝ ∈ y</span>\n<span class=\"cm\">    This surprised me, but now I see it's in the manual.</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"c1\">-- apply infLeRight; -- fails to unify</span>\n  <span class=\"n\">intro</span> <span class=\"n\">thing</span><span class=\"bp\">;</span> <span class=\"c1\">-- to make apply work</span>\n  <span class=\"n\">apply</span> <span class=\"n\">infLeRight</span> <span class=\"n\">thing</span><span class=\"bp\">;</span>\n</code></pre></div>",
        "id": 231879885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616708071
    },
    {
        "content": "<p>You can use <code>@</code> to prevent auto-lambda on goals starting with implicits, but I don't see an easy way to make it work with <code>apply</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">inter_mem_sets_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">},</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">⊓</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">hf</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">infLeLeft</span><span class=\"o\">),</span> <span class=\"n\">hf</span> <span class=\"n\">h</span> <span class=\"bp\">@?</span><span class=\"n\">h2</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- goal now x ⊓ y ≤ y</span>\n  <span class=\"c1\">-- apply infLeRight -- fails to unify</span>\n  <span class=\"c1\">-- apply @infLeRight -- fails to unify</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">infLeRight</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 231881395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616708800
    },
    {
        "content": "<p>in particular, the fact that <code>apply @infLeRight</code> doesn't work seems like the latest iteration of the apply bug</p>",
        "id": 231881527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616708864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I fixed the two problems that were creating the weird behavior. I was a bug in the <code>apply</code> tactic and the new implicit lambda feature. The examples above are working now.</p>",
        "id": 231902139,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1616722482
    },
    {
        "content": "<p>Thank you for the fixes!</p>",
        "id": 231902221,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616722557
    }
]
[
    {
        "content": "<p>{What is the, Is there a} type used for programming with finite sets in Lean 4?<br>\nI'm currently using <code>HashSet</code>, but AFAIK that's lacking certain basic operations like <code>map</code>, so I'm unsure of whether this is the type intended for (computable) finite sets in general.</p>",
        "id": 283227789,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653219386
    },
    {
        "content": "<p>My MSc student <span class=\"user-mention\" data-user-id=\"463548\">@Hubert Ostoja-Petkowski</span> has ported mathlib3's <code>finset</code> to Lean 4 -- see <a href=\"https://github.com/Hop311/M4R/blob/main/M4R/Set/Finite/Finset.lean\">https://github.com/Hop311/M4R/blob/main/M4R/Set/Finite/Finset.lean</a> . I should say that this is not in the context of mathlib4, this is an independent project.</p>",
        "id": 283228062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653219789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Finite.20Sets/near/283228062\">said</a>:</p>\n<blockquote>\n<p>My MSc student <span class=\"user-mention silent\" data-user-id=\"463548\">Hubert Ostoja-Petkowski</span> has ported mathlib3's <code>finset</code> to Lean 4 -- see <a href=\"https://github.com/Hop311/M4R/blob/main/M4R/Set/Finite/Finset.lean\">https://github.com/Hop311/M4R/blob/main/M4R/Set/Finite/Finset.lean</a> . I should say that this is not in the context of mathlib4, this is an independent project.</p>\n</blockquote>\n<p>Oh perfect, thanks! <del>And it doesn't use any quotients :)</del></p>",
        "id": 283228134,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653219873
    },
    {
        "content": "<p>That looks like a specifically noncomputable <code>Finset</code> implementation, which probably wouldn't work for a programming application.</p>\n<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> If you have a computable <code>Finset</code>, beware they have O(n) lookup, O(n) insert, and O(n^2) <code>map</code> (or O(n) if the function being mapped is injective). This is because the only operation on the underlying type they use is <code>Eq</code>.  If you want the properties of a <code>HashSet</code>, it probably would be better to use it instead and implement missing functionality.</p>",
        "id": 283240581,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653237570
    },
    {
        "content": "<p>I've thought about <code>finset</code> as a \"least common denominator\" implementation for computable finite sets -- decidable <code>Eq</code> is usually not hard to come by. But with additional operations you can make much more efficient data structures. For example, if you have a total order you can implement finite sets by using sorted lists (that's O(ln n) lookup, O(n) insert, and O(n) <code>map</code>), or if you have a hash function you can use some hash table structure (that's on average O(1) lookup, O(1) insert, and probably O(n) <code>map</code>).</p>",
        "id": 283240870,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653237969
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>: Thanks for the feedback! I did end up going with <code>HashSet</code> + add missing functionality, so your suggestion is reassuring <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span><br>\nDo you think basic functions like <code>HashSet.union</code> and <code>HashSet.map</code> would be welcome as contributions to Lean 4?</p>",
        "id": 283240871,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653237971
    },
    {
        "content": "<p>I'm not sure what contributions Lean 4 is accepting right now, so someone else should answer that question. (I myself have a small library of <code>Array</code> theorems, but I haven't looked into whether anyone would want them yet.)</p>",
        "id": 283241102,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653238358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/stream/270676-lean4/topic/Finite.20Sets/near/283240871\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>: Thanks for the feedback! I did end up going with <code>HashSet</code> + add missing functionality, so your suggestion is reassuring <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span><br>\nDo you think basic functions like <code>HashSet.union</code> and <code>HashSet.map</code> would be welcome as contributions to Lean 4?</p>\n</blockquote>\n<p>You can just stuff everything into Mathlib right now if you want to, at some point there will be a \"real\" stdlib that lives outside of the compiler.</p>",
        "id": 283242019,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653239619
    },
    {
        "content": "<p>I'm planning to add HashSet + more functionality to the collections library I'm making. Is your use case public? I'd love to try adapting it to the collections library!</p>",
        "id": 283273939,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1653284904
    },
    {
        "content": "<p>(And I'd be happy to have the code there instead of in Mathlib if it seems particularly out of place in Mathlib)</p>",
        "id": 283273966,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1653284952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Finite.20Sets/near/283273939\">said</a>:</p>\n<blockquote>\n<p>I'm planning to add HashSet + more functionality to the collections library I'm making. Is your use case public? I'd love to try adapting it to the collections library!</p>\n</blockquote>\n<p>It's just this, so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n<span class=\"kn\">open</span> <span class=\"n\">Std</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">BEq</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">beq</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">x₂</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">x₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BEq.beq</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Hashable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hash</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Hashable.hash</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Std.HashSet</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s.fold</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">res</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">res.insert</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkHashSet</span> <span class=\"n\">s.numBuckets</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s₁.fold</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">insert</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">s₂</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bUnion</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">HashSet</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s.fold</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">res</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">union</span> <span class=\"n\">res</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkHashSet</span> <span class=\"n\">s.numBuckets</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">taggedUnion</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s₂.fold</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">res</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">res.insert</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s₁.map</span> <span class=\"n\">Sum.inl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s₁.bUnion</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s₂.map</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s.fold</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">res</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">res</span> <span class=\"k\">else</span> <span class=\"n\">res.erase</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Std.HashSet</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.toHashSet</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">l.foldl</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">insert</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkHashSet</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">l.length</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"{\"</span> <span class=\"n\">elems</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\"}\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.toHashSet</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">])</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">s.toList.reverse</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"∅\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"{\"</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">l.toStringAux</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\"}\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ForIn</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">forIn</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.toList.forIn</span>\n</code></pre></div>",
        "id": 283288011,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653295835
    },
    {
        "content": "<p>The sum type instance will likely cause problems. If you have nat + nat, the values of inl 1 and inr 1 will have a collision.</p>",
        "id": 283304578,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1653305426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/270676-lean4/topic/Finite.20Sets/near/283304578\">said</a>:</p>\n<blockquote>\n<p>The sum type instance will likely cause problems. If you have nat + nat, the values of inl 1 and inr 1 will have a collision.</p>\n</blockquote>\n<p>Yeah, I wasn't sure how to fix that initially. But it shouldn't cause critical problems, should it? The only consequence I see is worse performance as a result of more hash collisions.</p>\n<p>Do you think this would fix it?:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Hashable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hash</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mixHash</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">hash</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mixHash</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">hash</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 283306849,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653306720
    },
    {
        "content": "<p>I think you're right that it's not a critical problem -- worst case you're forced to have two objects per hash bucket even with unlimited buckets. Still, it's nice knowing your hash functions don't have likely collisions.</p>\n<p>It seems using <code>mixHash</code> the way you have is the way to fix the hash function. You might want to choose numbers more interesting than <code>0</code> and <code>1</code> though to get <a href=\"https://github.com/leanprover/lean4/blob/master/src/runtime/hash.h#L24\">https://github.com/leanprover/lean4/blob/master/src/runtime/hash.h#L24</a> to mix things up more (that's the C implementation of <code>mixHash</code> I believe). I noticed these tend to be 2-4 digit numbers elsewhere in the library.</p>",
        "id": 283309250,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653307946
    },
    {
        "content": "<p>I've also seen small primes used as constants for <code>mixHash</code>, e.g. for <code>Expr</code>. But I wasn't able to find any general info on what good constants for this hash function are.</p>",
        "id": 283329417,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1653317278
    },
    {
        "content": "<p>(I can't find this particular hash function online, does anyone know what it was pulled from?)</p>",
        "id": 283331954,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1653318263
    },
    {
        "content": "<p><code>hash.cpp</code> points here: <a href=\"http://burtleburtle.net/bob/hash/doobs.html\">http://burtleburtle.net/bob/hash/doobs.html</a></p>",
        "id": 283334566,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1653319285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> I saw 11 and 13 being used by <code>Option</code>'s hashing implementation.</p>",
        "id": 283347297,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653324875
    }
]
[
    {
        "content": "<p>I'm making my own <code>int</code> type derived from the built-in <code>Nat</code> type. I believe I have made a correct subtraction function and it seems obvious to me that it should terminate, because in the recursive calls the second parameter will eventually become either <code>pos zero</code> or <code>neg zero</code> but the termination checker isn't recognizing this and says it failed to show termination. If I mark it with <code>unsafe</code> I can check that it appears to be computing as expected nonetheless. How do I convince the termination checker?<br>\nMWE : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">int</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">int</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">int.decrement</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">neg</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pos</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">int.decrement</span> <span class=\"bp\">$</span> <span class=\"n\">pos</span> <span class=\"bp\">$</span> <span class=\"mi\">0</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">int.increment</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pos</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pos</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pos</span> <span class=\"n\">b.succ</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">neg</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">int.increment</span> <span class=\"bp\">$</span> <span class=\"n\">neg</span> <span class=\"bp\">$</span> <span class=\"mi\">2</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">pos</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">pos</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">neg</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">neg</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">int.decrement</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">int.decrement</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">int.increment</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">int.increment</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- (-1) - (-2) = +1</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (-2) - 3 = -5</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 5 - 3 = +2</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 3 - (-2) = +5</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 240772147,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1622405950
    },
    {
        "content": "<p>My complete guess is that Lean might be looking at the first factor first, and here it is not at all obvious that what you write terminates, because <code>increment</code> and <code>decrement</code> can make terms more complex. Why not try a version of the definition where the first factor gets simpler? In Lean 3 you can write your own code to prove termination and get the equation compiler to use it but I don't know if this functionality is available yet in Lean 4.</p>",
        "id": 240772890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622407108
    },
    {
        "content": "<p>You can define <code>int.sub</code> by well foundness with an appropriate measure (it looks like <code>a + b</code> is obviously fine but I might be wrong when you will get to the actual implementation)</p>",
        "id": 240790549,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1622435554
    },
    {
        "content": "<p>We have structural recursion on arbitrary arguments for types and soon for predicates. This doesn't cover mutually recursive definitions for now. And we don't have well-founded recursion yet.</p>",
        "id": 240797249,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1622443389
    },
    {
        "content": "<p>The usual trick here is to have auxiliary definitions that are structural recursive, and that works in this case too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">int.sub</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n<span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">subNat</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">addNat</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">subNat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">subNat</span> <span class=\"o\">(</span><span class=\"n\">int.decrement</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span>\n  <span class=\"n\">addNat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">addNat</span> <span class=\"o\">(</span><span class=\"n\">int.increment</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">d</span>\n</code></pre></div>",
        "id": 240801245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622446547
    },
    {
        "content": "<p>Cool, I didn't know you could have nested functions</p>",
        "id": 240845296,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1622474348
    },
    {
        "content": "<p>Considering this MWE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">..</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>  <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">N</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">..</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>  <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n</code></pre></div>\n<p>On 08-27 nightly, lean fails to show termination for g but not for f which is really odd given that N is defined just like Nat. This looks like a bug to me. Thanks a lot for fixing this issue / explaining why it doesn't work.</p>",
        "id": 296143050,
        "sender_full_name": "Michael Jam",
        "timestamp": 1661872292
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403214\">@Michael Jam</span> it looks a lot like <code>Nat</code>, but it's not <code>Nat</code>. Lean has special machinery there for <code>Nat</code>, see e.g.:  <a href=\"https://github.com/leanprover/lean4/blob/78927542b7f8222887b0277d52ed433d6a5f8e30/stage0/src/Init/WF.lean#L151\">https://github.com/leanprover/lean4/blob/78927542b7f8222887b0277d52ed433d6a5f8e30/stage0/src/Init/WF.lean#L151</a></p>",
        "id": 296143581,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1661872439
    },
    {
        "content": "<p>But here, if my understanding is correct, the proof should be by structural recursion and not by WF recursion so I am not sure this is relevant</p>",
        "id": 296144137,
        "sender_full_name": "Michael Jam",
        "timestamp": 1661872600
    },
    {
        "content": "<p>It works by the way, if you replace b by a on the last line</p>",
        "id": 296144363,
        "sender_full_name": "Michael Jam",
        "timestamp": 1661872669
    },
    {
        "content": "<p>No, Lean fails to dispatch <code>f</code> via structural recursion just like for <code>g</code>. If you dig through <code>f</code>'s ultimate definition using <code>#print</code>, you can see the well-founded recursion.</p>",
        "id": 296144522,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1661872723
    },
    {
        "content": "<p>Ah so its just fortunate that it works for f because a Nat wf relation is defined behind the scenes</p>",
        "id": 296144640,
        "sender_full_name": "Michael Jam",
        "timestamp": 1661872761
    },
    {
        "content": "<p>Will structural recursion be able to handle such cases in the future?  I really think of that example structurally or am I wrong to think like that?</p>",
        "id": 296145266,
        "sender_full_name": "Michael Jam",
        "timestamp": 1661872933
    },
    {
        "content": "<p>Maybe it's not because of the currying? In a sense you're doing the recursion on <code>N -&gt; N</code>, not on <code>N</code> there. I don't know the details of the type theory behind there though, so maybe I'm totally wrong there as well</p>",
        "id": 296146046,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1661873152
    },
    {
        "content": "<p>It should be technically feasible, but implementing it could be quite tough. You could try it yourself for this example if you want, you'll need course-of-values recursion via <code>Nat.brecOn</code> to jump straight from <code>.succ b</code> to <code>.zero</code></p>",
        "id": 296146430,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1661873258
    },
    {
        "content": "<p>I think I was wrong to think it's structural because actually b changed of position as an argument sorry for wasting time.</p>",
        "id": 296154905,
        "sender_full_name": "Michael Jam",
        "timestamp": 1661875388
    }
]
[
    {
        "content": "<p>I have some code operating on terms of the <code>Expr</code> type. I would like to test this with a few examples to see if it is working as intended, but I am facing some difficulty in creating <code>Expr</code> terms.</p>\n<p>In Lean3, I could wrap a term <code>e</code> around using a back-quote with parentheses (like this - <code>`(e)</code>) to generate the <code>expr</code>ession corresponding to <code>e</code>. However, trying the same in Lean4 gives me a complicated term with the <code>Syntax</code> type.</p>\n<p>Is there an easy way to convert a term to its corresponding <code>Expr</code> in Lean4? Thanks in advance.</p>",
        "id": 276225326,
        "sender_full_name": "Anand Rao",
        "timestamp": 1647970130
    },
    {
        "content": "<p>Gabriel's quotation library is probably relevant: <a href=\"https://github.com/gebner/quote4\">https://github.com/gebner/quote4</a></p>\n<p>With builtin Lean 4 tools, use <a href=\"https://github.com/leanprover/lean4/blob/c29da66c5a27356504dc1e764b3da759faa8cd73/src/Lean/Elab/Term.lean#L1196\"><code>elabTerm</code></a> to elaborate the <code>Syntax</code> you get out of the quotation.</p>",
        "id": 276226317,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1647970506
    },
    {
        "content": "<p>Thank you.</p>\n<p>I am having a bit of trouble specifying the expected type to the <code>elabTerm</code> function, since it requires the expected type to be quoted as an expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Expr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Elab</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">If the expression is of the form</span>\n<span class=\"cm\">A₁ → A₂ → A₃ → … → Aₙ → … → B,</span>\n<span class=\"cm\">the output of `target` is `B`.</span>\n\n<span class=\"cm\">Essentially, it recovers the term at the end of a series of nested implications.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lam</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">target</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">forallE</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">target</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Term.elabTerm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">Option.some</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Specifically, I do not know how to replace the <code>sorry</code> above with <code>Nat -&gt; Nat</code> (the expected type) quoted as an expression.</p>",
        "id": 276231542,
        "sender_full_name": "Anand Rao",
        "timestamp": 1647972552
    },
    {
        "content": "<p>You can use <code>← mkArrow (mkConst ``Nat) (mkConst ``Nat)</code> to get <code>Nat -&gt; Nat</code>. You may need to <code>open Meta</code>.</p>",
        "id": 276272328,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647994762
    },
    {
        "content": "<p>There is another issue with <code>let s</code>. Here is a version with the two corrections.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.lam</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">target</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.forallE</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">target</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Term.elabTerm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span>  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">Option.some</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkArrow</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)))</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 276276765,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647996882
    },
    {
        "content": "<p>Another thing: if you are pattern matching on expressions, you should first reduce them (and often take <code>whnf</code>). For instance, you can compare with and without the additional line with <code>reduce</code> in the following.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.lam</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">target</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.forallE</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">target</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Term.elabTerm</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tst</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span>  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">Option.some</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkArrow</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)))</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span>  <span class=\"n\">reduce</span> <span class=\"n\">e</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">tst</span>\n</code></pre></div>",
        "id": 276277141,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647997209
    },
    {
        "content": "<p>Incidentally, a trick I use to test this by getting a term is to write a small elaborator. In this case it shows a bug (this is code after the above).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"tst!\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">tst</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">tst</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>However I assume this was just an exercise with syntax. If you try to compute the target this way, another issue is that you will have bound variables in the expression, which have no meaning (or the wrong meaning due to de Bruijn indexing)  outside their context and so will give an error.</p>",
        "id": 276278503,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1647998659
    },
    {
        "content": "<p>Thank you very much. It turns out that with this fix to the <code>let</code> expression, the <code>elabTerm</code>also accepts <code>Option.none</code> as its second argument (presumably because it has now managed to infer the type of the expression <code>s</code> correctly). I see why my usage of <code>:=</code> instead of <code>&lt;-</code> in that example was incorrect.</p>",
        "id": 276285761,
        "sender_full_name": "Anand Rao",
        "timestamp": 1648007790
    },
    {
        "content": "<p>Thank you for pointing out the issue with the bound variables. In my actual use case (which is to write a small tactic in Lean4), I will be trying to extract the target type (and not the target). Most of my inputs will not be dependent types, so I hope the issues with bound variables do not arise.</p>",
        "id": 276286392,
        "sender_full_name": "Anand Rao",
        "timestamp": 1648008588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao</span> <a href=\"#narrow/stream/270676-lean4/topic/Generating.20.60Expr.60.20terms.20by.20quoting/near/276286392\">said</a>:</p>\n<blockquote>\n<p>Most of my inputs will not be dependent types, so I hope the issues with bound variables do not arise.</p>\n</blockquote>\n<p>Note that even just polymorphism requires you to handle dependencies: your <code>target</code> does not work on <code>forall α, List α -&gt; List α</code>. So it's unlikely that you can avoid this complication. You should probably be using <a href=\"https://github.com/leanprover/lean4/blob/170b911a6f6f4e86ce284c5daf74e2e7d1700e19/src/Lean/Meta/Basic.lean#L778\"><code>forallTelescope</code></a> or one of its variants.</p>",
        "id": 276305948,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1648027392
    }
]
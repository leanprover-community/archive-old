[
    {
        "content": "<p>I'm experimenting with using tactic mode to assemble programs given a specification. In my case, the specification is given by an expression containing non-computable functions. In the tactic mode, I want to eliminate these non-computable functions and produce runnable code.</p>\n<p>Here is a bit silly minimal working example where I define an opaque function <code>opaque_id</code> and provide an axiom <code>opaque_id_definition</code> what the function actually does. In my real code, I have for example opaque function <code>integrate</code> with axiom defining what <code>integrate</code> does on continuous functions. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id_definition</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>  <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n          <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">impl</span>\n  <span class=\"c1\">-- In my real code, I have more constructors like adding a runtime check.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">]</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_definition</span><span class=\"o\">]</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">Impl.pure</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">id_impl.assemble</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Unfortunately, <code> (id_impl.assemble  42)</code> evaluates to <code>0</code> and not <code>42</code>.</p>\n<p>Trying to prove that <code>id_impl.assemble = id</code> produces:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">id_impl_proof</span> <span class=\"o\">:</span> <span class=\"n\">id_impl.assemble</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">id_impl</span><span class=\"o\">,</span> <span class=\"n\">Impl.assemble</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">opaque_id</span><span class=\"o\">,</span> <span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">opaque_id</span> <span class=\"bp\">=</span> <span class=\"n\">Impl</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Impl.pure</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">impl</span><span class=\"o\">,</span> <span class=\"n\">Impl.pure</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Any idea how to change the setup to make <code>(id_impl.assemble 42)</code> to evaluate to <code>42</code> ?</p>",
        "id": 256694190,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633674053
    },
    {
        "content": "<p>Maybe the <code>opaque_id</code> should be stated as an axiom to be truly non-computable. Then <code>#eval (id_impl.assemble 42)</code> is giving somewhat expected error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">compile</span> <span class=\"kd\">definition</span><span class=\"o\">,</span> <span class=\"n\">consider</span> <span class=\"n\">marking</span> <span class=\"n\">it</span> <span class=\"n\">as</span> <span class=\"bp\">'</span><span class=\"kd\">noncomputable</span><span class=\"bp\">'</span> <span class=\"n\">because</span> <span class=\"n\">it</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"bp\">'</span><span class=\"n\">opaque_id'</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">it</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">executable</span> <span class=\"n\">code</span>\n</code></pre></div>\n<p>However, I thought that by the tactic <code>rw [opaque_id_definition]</code> I have eliminated the non-computable <code>opaque_id</code> from the definition and making the code runnable.</p>",
        "id": 256694540,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633674371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> What you are doing confuses me so much and I have so many questions. </p>\n<p>First, why are you using tactic mode to write code? That really is not what it is designed to do. </p>\n<p>Second, <code>opaque_id</code> where <code>β</code> is a <code>Nat</code> is (code-wise) just <code>def opaque_id (n : Nat) := 0</code>. This is because<code>0</code> is  the <code>default</code> value for <code>Nat</code> in its <code>Inhabited</code> instance, and this is why  <code>#eval (id_impl.assemble 42)</code> returns <code>0</code>. </p>\n<p>Also note that <code>rw [opaque_id_definition]</code> just affects the type, it doesn't change anything execution wise. This is because its type is a <code>Prop</code> and is thus completely erased at runtime.</p>",
        "id": 256696680,
        "sender_full_name": "Mac",
        "timestamp": 1633676162
    },
    {
        "content": "<p>I understand that it is confusing and tactic mode is designed to prove things. However, I have an idea how to use tactic mode to write programs(at least special parts of it) and I want to try it out.</p>\n<p>I think the original question really should have had <code>axiom</code> instead of <code>constant</code> in the definition of <code>opaque_id</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>Then <code>#eval (id_impl.assemble 42)</code> does not evaluate at all, but I want it to evaluate to <code>42</code>.</p>\n<hr>\n<p>Anyway, I will try to explain my mental model about <code>Impl</code>:</p>\n<p>The  goal <code>Impl (fun x =&gt; f x)</code> means, please construct an implementation of function <code>f</code>. If <code>f</code> is already computable, you can finish the goal by <code>apply Impl.pure</code> that stores <code>f</code> into <code>Impl (fun x =&gt; f x)</code>.  If <code>f</code> is non-computable, you should first transform into computable <code>g</code> for which you know that <code>f=g</code>. Then calling <code>Impl.pure</code> will hopefully stores <code>g</code> into <code>Impl (fun x =&gt; f x)</code>. </p>\n<p>Once you have <code>Impl (fun x =&gt; f x)</code>, you can use <code>assemble</code> to extract the computable function that you can execute.</p>",
        "id": 256701036,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633679108
    },
    {
        "content": "<p>An example why I'm doing this. I'm experimenting with automatic differentiation. I have postulated gradient operator <code>∇</code> and an opaque symbol and have bunch of theorems how to eliminate it. Example of computing gradient of <code>x*x</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">square_grad</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"bp\">∇</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">gradient</span><span class=\"o\">]</span>\n  <span class=\"n\">autograd</span>\n\n  <span class=\"n\">finish_impl</span>\n</code></pre></div>\n<p>After the tactic <code>autograd</code> the goal is <code>Impl fun x =&gt; 1 * x + x * 1</code> where <code>fun x =&gt; 1 * x + x * 1</code> is nice computable function. For now,  the tactic <code>finish_impl</code> is just  does <code>apply Impl.pure</code>, in the future I want to somehow check computability of the final term.</p>",
        "id": 256701365,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633679348
    },
    {
        "content": "<p>If you want <code>opaque_id</code> to evaluate, then shouldn't you give it a definition? An axiom about a constant is not a definition, it does not have any computational content and lean has no idea how to turn it into running code</p>",
        "id": 256701368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633679350
    },
    {
        "content": "<p>that is, use <code>constant opaque_id : β → β := id</code> if you want it to <code>#eval</code></p>",
        "id": 256701388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633679369
    },
    {
        "content": "<p>The thing is that I want to write <code>∇ f</code> for any function without having to supply proof that <code>f</code> is differentiable. If <code>f</code> is not differentiable then <code>∇ f</code> is just not defined but if it is differentiable then <code>∇ f</code> expands to the standard definition.</p>\n<p>This is the reason to split <code>opaque_id</code> into two axioms, just postulating the existence of the symbol and then the actual definition.</p>",
        "id": 256701546,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633679484
    },
    {
        "content": "<p>And how should Lean know if your function is differentiable or not?</p>",
        "id": 256702045,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1633679776
    },
    {
        "content": "<p>I have definitions and proof automation for that already.</p>",
        "id": 256702091,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633679803
    },
    {
        "content": "<p>I'm using typeclass system to automatically prove that a function is differentiable. So I have bunch of instances like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsDiff</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDiff</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsDiff</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>composition of two differentiable functions is a differentiable one</p>",
        "id": 256702348,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633679957
    },
    {
        "content": "<p>I don't get it. Determining if a function is differentiable is probably undecidable algorithmically (since even determining if two reals numbers are equal is undecidable algorithmically), so you can not hope Lean to make the right decision all the time.</p>",
        "id": 256702372,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1633679978
    },
    {
        "content": "<p>What you describe is a procedure that, sometimes, will determine that the function is differentiable. But what if it is differentiable but your procedure is not able to show it?</p>",
        "id": 256702468,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1633680009
    },
    {
        "content": "<p>I'm not saying I can prove differentiability about anything. But I can do it automatically for certain class of functions.</p>",
        "id": 256702537,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633680030
    },
    {
        "content": "<blockquote>\n<p>But what if it is differentiable but your procedure is not able to show it?</p>\n</blockquote>\n<p>Then I have to prove it manually.</p>",
        "id": 256702616,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633680079
    },
    {
        "content": "<p>Or more precisely, I'm not saying I can decide differentiability of every function. But if I can prove differentiability then I also have bunch of reduction rules for the differential like the chain rule:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">dx</span> <span class=\"bp\">=</span> <span class=\"n\">δ</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">dx</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 256702813,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633680198
    },
    {
        "content": "<p>In theory, the following should work (I think it does in lean 3), but something seems to be different about the noncomputable checker and neither the second <code>def</code> nor the <code>#eval</code> works. But it doesn't evaluate the wrong thing at least</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id_definition</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">impl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">opaque_id_eq</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">opaque_id</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_definition</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">opaque_id_eq</span> <span class=\"bp\">▸</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Impl.mk</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">impl</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl'</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Impl.mk</span> <span class=\"n\">_</span> <span class=\"n\">opaque_id_eq</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">id_impl.assemble</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 256702968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680290
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I was trying a similar thing and was also confused why it wasn't working</p>",
        "id": 256703360,
        "sender_full_name": "Mac",
        "timestamp": 1633680502
    },
    {
        "content": "<p>I guess the issue is that in the signature of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Impl.mk</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">impl</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>there is nothing to indicate to the compiler that <code>impl</code> is computationally relevant but <code>a</code> isn't, so the noncomputable checker demands that the <code>a</code> input is computable too, which fails because it is instantiated to <code>opaque_id</code> in <code>id_impl'</code></p>",
        "id": 256703366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680507
    },
    {
        "content": "<p>I think you need to do something similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/erased\">docs#erased</a> to launder the value <code>a</code> through a <code>Type</code> argument</p>",
        "id": 256703416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680546
    },
    {
        "content": "<p>Here is what I was trying:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id_definition</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>  <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n          <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">impl</span>\n  <span class=\"c1\">-- In my real code, I have more constructors like adding a runtime check.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">opaque_id_eq_id</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span> <span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_definition</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_eq_id</span><span class=\"o\">])</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">id</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">id_impl.assemble</span> <span class=\"mi\">42</span> <span class=\"c1\">-- 0 (why????)</span>\n</code></pre></div>",
        "id": 256703469,
        "sender_full_name": "Mac",
        "timestamp": 1633680586
    },
    {
        "content": "<p>I really hope lean 4 gets direct support for erasure, because the lean 3 erased has a bunch of unnecessary overhead</p>",
        "id": 256703471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  The example unfortunately does not work under lean 4.</p>",
        "id": 256703593,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633680658
    },
    {
        "content": "<p>my example should work up to the last two commands, like I said</p>",
        "id": 256703625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680682
    },
    {
        "content": "<p>in particular <code>id_impl</code> works (passes the noncomputable checker)</p>",
        "id": 256703651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680699
    },
    {
        "content": "<p>but <code>Impl.assemble</code> doesn't, so the <code>#eval</code> fails</p>",
        "id": 256703738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think Lean 4 is being too smart and reducing <code>id_impl.assemble</code> to just <code>opaque_id</code>.</p>",
        "id": 256703856,
        "sender_full_name": "Mac",
        "timestamp": 1633680816
    },
    {
        "content": "<p>I don't see how that is legal under the execution semantics</p>",
        "id": 256703936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633680850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>  I don't think so, try proving <code>id_impl.assemble = (λ x : β =&gt; x)</code></p>",
        "id": 256703974,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633680878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I mean at a codegen level not a type level</p>",
        "id": 256704004,
        "sender_full_name": "Mac",
        "timestamp": 1633680906
    },
    {
        "content": "<p>Ohh, ok that might be.</p>",
        "id": 256704054,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633680938
    },
    {
        "content": "<p>Observe that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:=</span>\n  <span class=\"n\">id_impl.assemble</span> <span class=\"mi\">42</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">....</span>\n<span class=\"sd\">def test : obj :=</span>\n<span class=\"sd\">  let x_1 : obj := 0;</span>\n<span class=\"sd\">  ret x_1</span>\n<span class=\"sd\">...</span>\n</code></pre></div>",
        "id": 256704205,
        "sender_full_name": "Mac",
        "timestamp": 1633681003
    },
    {
        "content": "<p>yes, that's definitely the code of <code>opaque_id</code> you are seeing. I'm just not sure how the compiler decides to do that</p>",
        "id": 256704272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681048
    },
    {
        "content": "<p>it's not like <code>opaque_id_definition</code> is a csimp lemma</p>",
        "id": 256704296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681065
    },
    {
        "content": "<p>and the <code>cast</code> points straight to the <code>id</code> definition</p>",
        "id": 256704377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681099
    },
    {
        "content": "<p><code>Impl.assemble</code> is indeed the culprit for selecting the wrong implementation. Take a look that this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">compiler.input</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">Impl.assemble</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span><span class=\"o\">,</span> <span class=\"n\">Impl.pure</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n<span class=\"o\">[</span><span class=\"n\">compiler.eta_expand</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">Impl.assemble</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span><span class=\"o\">,</span> <span class=\"n\">Impl.pure</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n<span class=\"o\">[</span><span class=\"n\">compiler.lcnf</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">Impl.assemble</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">_x_1</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span><span class=\"bp\">;</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span><span class=\"o\">,</span> <span class=\"n\">Impl.pure</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_x_1</span> <span class=\"n\">impl</span>\n<span class=\"o\">[</span><span class=\"n\">compiler.cce</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">Impl.assemble</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">_x_1</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span><span class=\"bp\">;</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span><span class=\"o\">,</span> <span class=\"n\">Impl.pure</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_x_1</span> <span class=\"n\">impl</span>\n<span class=\"o\">[</span><span class=\"n\">compiler.inline</span><span class=\"o\">]</span> <span class=\"n\">Impl.assemble.match_1</span>\n<span class=\"o\">[</span><span class=\"n\">compiler.simp</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">Impl.assemble</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 256704840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681351
    },
    {
        "content": "<p>Even wierder:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_eq_id</span><span class=\"o\">])</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">id</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">def id_impl._elambda_1._rarg (x_1 : @&amp; obj) : obj :=</span>\n<span class=\"cm\">  inc x_1;</span>\n<span class=\"cm\">  ret x_1</span>\n<span class=\"cm\">def id_impl._elambda_1 (x_1 : ◾) : obj :=</span>\n<span class=\"cm\">  let x_2 : obj := pap id_impl._elambda_1._rarg._boxed;</span>\n<span class=\"cm\">  ret x_2</span>\n<span class=\"cm\">def id_impl (x_1 : ◾) (x_2 : @&amp; obj) : obj :=</span>\n<span class=\"cm\">  let x_3 : obj := pap id_impl._elambda_1._rarg._boxed;</span>\n<span class=\"cm\">  ret x_3</span>\n<span class=\"cm\">def id_impl._elambda_1._rarg._boxed (x_1 : obj) : obj :=</span>\n<span class=\"cm\">  let x_2 : obj := id_impl._elambda_1._rarg x_1;</span>\n<span class=\"cm\">  dec x_1;</span>\n<span class=\"cm\">  ret x_2</span>\n<span class=\"cm\">def id_impl._boxed (x_1 : obj) (x_2 : obj) : obj :=</span>\n<span class=\"cm\">  let x_3 : obj := id_impl x_1 x_2;</span>\n<span class=\"cm\">  dec x_2;</span>\n<span class=\"cm\">  ret x_3</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 256704845,
        "sender_full_name": "Mac",
        "timestamp": 1633681356
    },
    {
        "content": "<p>It is supposed to be matching on the <code>x</code> argument and passing the contents, and instead it takes the <code>a</code> argument which is the erased one</p>",
        "id": 256704891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681382
    },
    {
        "content": "<p>the match desugaring gives a hint as to why</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span><span class=\"o\">,</span> <span class=\"n\">Impl.pure</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n</code></pre></div>",
        "id": 256704940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681405
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is this a bug?</p>",
        "id": 256705748,
        "sender_full_name": "Mac",
        "timestamp": 1633681783
    },
    {
        "content": "<p>It's actually really tough to find a way to write the match to extract <code>impl</code> and not reuse <code>a</code>. Using <code>casesOn</code> directly works, though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">i.casesOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">compiler.simp</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">Impl.assemble</span>\n<span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 256705780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681800
    },
    {
        "content": "<p>Tough to say. It seems more like an unfortunate combination of features</p>",
        "id": 256705862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681820
    },
    {
        "content": "<p>The pattern matching syntax makes it impossible to distinguish <code>impl</code> from <code>a</code>, and after all why would you, they are equal</p>",
        "id": 256705954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681868
    },
    {
        "content": "<p>I think the correct way to solve problems of this sort is with a first class <code>erased</code> type</p>",
        "id": 256706099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633681926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> the computable/noncomputable distinction seems like a very good reason to distinguish them (also possibly implementation wise for constants).</p>",
        "id": 256706125,
        "sender_full_name": "Mac",
        "timestamp": 1633681945
    },
    {
        "content": "<p>also <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what version of Lean 4 are you on?</p>",
        "id": 256706228,
        "sender_full_name": "Mac",
        "timestamp": 1633682004
    },
    {
        "content": "<p>a relatively old one, why?</p>",
        "id": 256706255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682016
    },
    {
        "content": "<p>Your example does not work for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id_definition</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>  <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">impl</span>\n  <span class=\"c1\">-- In my real code, I have more constructors like adding a runtime check.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">i.casesOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">type mismatch</span>\n<span class=\"sd\">  impl</span>\n<span class=\"sd\">has type</span>\n<span class=\"sd\">  α✝ : Type ?u.210</span>\n<span class=\"sd\">but is expected to have type</span>\n<span class=\"sd\">  (fun {α_1} x x =&gt; α) impl (pure impl) : Type ?u.202</span>\n<span class=\"sd\">-/</span>\n</code></pre></div>",
        "id": 256706280,
        "sender_full_name": "Mac",
        "timestamp": 1633682030
    },
    {
        "content": "<p>oops, I changed the definition of <code>Impl</code>, look up</p>",
        "id": 256706364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682054
    },
    {
        "content": "<p>ah</p>",
        "id": 256706416,
        "sender_full_name": "Mac",
        "timestamp": 1633682083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> 's version has an unnecessary universe bump</p>",
        "id": 256706426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682089
    },
    {
        "content": "<p>turns out that where you place the colon still matters in inductives</p>",
        "id": 256706477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682117
    },
    {
        "content": "<p>Unnecessary in this definition of <code>Impl</code>. My actual definition of <code>Impl</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>  <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n          <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">impl</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">limit</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n          <span class=\"o\">(</span><span class=\"n\">lim_spec</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">lim_spec</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">spec</span> <span class=\"bp\">=</span> <span class=\"n\">limit</span> <span class=\"n\">lim_spec</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">help</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">spec</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">check</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n          <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">spec</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">help</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">spec</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">assumption</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n          <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">spec</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">help</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">spec</span>\n</code></pre></div>",
        "id": 256706578,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633682162
    },
    {
        "content": "<p>This definition does not work with <code>Impl  {α : Type _}  : (spec : α) → Type _</code></p>",
        "id": 256706635,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633682191
    },
    {
        "content": "<p>So a full functioning example, <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> , is now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id_definition</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Impl.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">spec</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">impl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">i.casesOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">impl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">impl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">opaque_id_eq_id</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_definition</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_eq_id</span><span class=\"o\">])</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">id</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">id_impl.assemble</span> <span class=\"mi\">42</span> <span class=\"c1\">-- 42 (yay!)</span>\n</code></pre></div>",
        "id": 256706643,
        "sender_full_name": "Mac",
        "timestamp": 1633682195
    },
    {
        "content": "<p>To review re: <code>erased</code>, in lean 3 <code>erased A</code> is a type that is classically isomorphic to <code>A</code>, with functions in and out, but the function out is noncomputable, and the compiler (is supposed to) have special support for this type, such that anything of type <code>erased A</code> is replaced by <code>_neutral</code>, in the same way as proofs and types</p>",
        "id": 256706673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682217
    },
    {
        "content": "<p>In this context, we would want <code>Impl.assemble</code> to have the type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Erased</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a.out</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 256706761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682271
    },
    {
        "content": "<p>Then this would allow the noncomputable checker to know that elements that are passed to the <code>a</code> argument of <code>Impl.assemble</code> are allowed to be noncomputable without tainting the computation</p>",
        "id": 256706880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682320
    },
    {
        "content": "<p>and you would get better codegen too, basically <code>fun () () i =&gt; i</code></p>",
        "id": 256706949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I don't understand why your <code>Impl</code> type is so complex. You should have no need for anything other than the first constructor, which already expresses everything that needs to be said about \"computable program that calculates a noncomputable value\"</p>",
        "id": 256707298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682563
    },
    {
        "content": "<p>Ohh I do need the others. I want to implement numerical algorithms that implement the specification only in a certain limit. e.g. I can replace derivative by limit of finite difference. Then I want to erase the limit from implementation and continue working.</p>",
        "id": 256707466,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633682663
    },
    {
        "content": "<p>Also I will not be able to prove that certain limits actually exists. Proving that certain PDE's have solution or that their finite element discretization actually converges is super hard. I want lean to help me to create implementation of such discrete solution and then list all the assumptions I took.</p>",
        "id": 256707692,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633682783
    },
    {
        "content": "<p>Another expression, less fraught because it uses a predicate for an argument (which is always trivially computable), is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pred</span> <span class=\"n\">impl</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">pred</span>\n</code></pre></div>",
        "id": 256707701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Yes, I'm typing something along similar lines now :)</p>",
        "id": 256707787,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633682849
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> fyi, <code>id_impl</code> can be generalized as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">impl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Impl.pure</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl'</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">impl</span> <span class=\"n\">opaque_id</span> <span class=\"n\">id</span> <span class=\"n\">opaque_id_eq_id</span>\n</code></pre></div>",
        "id": 256707900,
        "sender_full_name": "Mac",
        "timestamp": 1633682899
    },
    {
        "content": "<p>Then define <code>axiom Erased {α} : α → Prop</code><br>\nand the goal would be <code>Impl (Erased opaqud_id)</code></p>",
        "id": 256707904,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633682901
    },
    {
        "content": "<p>This all goes much smoother:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pred</span> <span class=\"n\">impl</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">pred</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id_definition</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">pred</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">opaque_id_eq</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_definition</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">opaque_id</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">opaque_id_eq</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">id_impl.assemble</span> <span class=\"mi\">42</span> <span class=\"c1\">-- 42</span>\n</code></pre></div>",
        "id": 256707931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633682914
    },
    {
        "content": "<p>Note that <code>Erased</code> is supposed to have the type <code>Type u -&gt; Type u</code>, and ideally it should at the logic level look just like this inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Erased</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Erased</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>except that <code>Erased.casesOn</code> is magically noncomputable</p>",
        "id": 256708353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633683152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think that <code>opaque_id</code> (and like functions) really should be a <code>noncomputable constant </code> -- that way you don't accidently add an inconsistent axiom or produce improper code</p>",
        "id": 256708356,
        "sender_full_name": "Mac",
        "timestamp": 1633683157
    },
    {
        "content": "<p>sure, this was just for the demo</p>",
        "id": 256708401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633683191
    },
    {
        "content": "<p>it wasn't a criticism XD I was more asking for conformation that the idea was reasonable :P</p>",
        "id": 256708532,
        "sender_full_name": "Mac",
        "timestamp": 1633683259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20constants/near/256708356\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> I think that <code>opaque_id</code> (and like functions) really should be a <code>noncomputable constant </code> -- that way you don't accidently add an inconsistent axiom or produce improper code</p>\n</blockquote>\n<p>Yeah, for some time I had <code>axiom invert : (α → β) → (β → α)</code> and only recently realized that it is a bad idea :)</p>",
        "id": 256708598,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633683298
    },
    {
        "content": "<p>indeed, <code>noncomputable constant opaque_id : Nat → Nat</code> works, which is different from lean 3, which knows exactly what is noncomputable and what isn't and won't take a different answer</p>",
        "id": 256708622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1633683310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20constants/near/256707931\">said</a>:</p>\n<blockquote>\n<p>This all goes much smoother:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Impl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pred</span> <span class=\"n\">impl</span> <span class=\"bp\">→</span> <span class=\"n\">Impl</span> <span class=\"n\">pred</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">opaque_id_definition</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">Impl.assemble</span> <span class=\"o\">{</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"n\">pred</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">opaque_id_eq</span> <span class=\"o\">:</span> <span class=\"n\">opaque_id</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">opaque_id_definition</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id_impl</span> <span class=\"o\">:</span> <span class=\"n\">Impl</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">opaque_id</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">opaque_id_eq</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">id_impl.assemble</span> <span class=\"mi\">42</span> <span class=\"c1\">-- 42</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Anyway, this looks great! I think I will experiment with it and see if I can achieve what I want.</p>\n<p>Thanks a bunch to both of you!</p>",
        "id": 256708798,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1633683418
    }
]
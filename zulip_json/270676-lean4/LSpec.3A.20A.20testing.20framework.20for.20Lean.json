[
    {
        "content": "<p>Hello everyone!</p>\n<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span>  and I worked together to build a specification testing framework for Lean, and we're happy to share the first version: <a href=\"https://github.com/yatima-inc/LSpec\">https://github.com/yatima-inc/LSpec</a> . Hopefully it'll be helpful to everyone as people start to build bigger projects in Lean 4. </p>\n<p>As the name suggests, it's loosely based off the similarly named \"Hspec\" for Haskell, but Lean's metaprogramming allowed for some fun design changes. Writing and evaluating specifications is hopefully relatively painless thanks to Lean's expressivity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"n\">mkspec</span> <span class=\"n\">fooSpec</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">alwaysEquals</span> <span class=\"n\">foo</span> <span class=\"mi\">4</span>\n\n<span class=\"bp\">#</span><span class=\"n\">spec</span> <span class=\"n\">Test</span> <span class=\"n\">fooSpec</span> <span class=\"k\">with</span> <span class=\"mi\">4</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"Always equals four\"</span>\n<span class=\"c1\">-- Always equals four:</span>\n<span class=\"c1\">-- ✓ Success!</span>\n\n<span class=\"bp\">#</span><span class=\"n\">spec</span> <span class=\"n\">Tests</span> <span class=\"n\">fooSpec</span> <span class=\"k\">with</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">]</span>\n<span class=\"c1\">-- × Failure!</span>\n<span class=\"c1\">-- ✓ Success!</span>\n<span class=\"c1\">-- × Failure!</span>\n</code></pre></div>\n<p>The project is still a WIP,  and some features on our radar are randomized testing/fuzzing (like Quickcheck for Haskell), and a \"test runner\" that can hook in as a Lake script to run tests on builds.</p>",
        "id": 284076744,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1653609718
    },
    {
        "content": "<p>Please let us know if you have some use cases from HSpec that you <em>really</em> like and we will think how we can integrate it in our package. As always, feedback is very much welcome!</p>",
        "id": 284076996,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1653609914
    },
    {
        "content": "<p>Do you recommend tests be put in a separate project directory (like <code>Tests</code>) or just littered around a project (i.e. in each relevant directory of the main project?)</p>",
        "id": 284091901,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1653627486
    },
    {
        "content": "<p>It's really great that someone is working on this!</p>\n<p>May I ask why do you introduce a new  keywords like <code>alwaysEquals</code>? Can't you use decidable Prop? </p>\n<p>I was thinking about testing a bit and I was thinking about something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mkspec</span> <span class=\"n\">expPositive</span> <span class=\"o\">:=</span> <span class=\"k\">forall</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">,</span> <span class=\"n\">Float.exp</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>As <code>x &gt;= 0</code> is a decidable Prop you can then generate a test by providing a sampling method for the argument <code>x</code>.</p>",
        "id": 284093682,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653630146
    },
    {
        "content": "<p>For example, I will be doing testing for equality up to rounding errors. I do not see a reason for the framework to have a special support for that if it allows me to test arbitrary decidable Prop.</p>",
        "id": 284094085,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653630642
    },
    {
        "content": "<p>In general it would be nice if going from spec -&gt; actual theorem would be as painless as possible (that includes syntax wise) so people in development can just write tests for their properties and if they decide to verify them can just swap out things quickly and start writing the proof.</p>",
        "id": 284098879,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653635533
    },
    {
        "content": "<p>What about having a specialized tactic like <code>sorry</code> but that defines a test.</p>",
        "id": 284099222,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653635821
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">expPositive</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Float.exp</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">test</span>\n     <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">uniform_interval</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"o\">]</span> <span class=\"mi\">1000</span>\n     <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">42</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This will generate two tests verifying the inequality. The first with 1000 samples <code>x</code> drawn with uniform distribution. The second test just runs it with three specific values.</p>",
        "id": 284099711,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653636245
    },
    {
        "content": "<p>Depending on your compiler/trust settings the tactic will show a similar squiggly line like <code>sorry</code>.</p>",
        "id": 284099768,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653636311
    },
    {
        "content": "<p>Similarly adding a support for asserts. I'm indexing my arrays with <code>Fin n</code> in order to eliminate all bound checks in my final code. However proving that <code>i&lt;n</code> everywhere takes too much time, so I end up with many <code>sorry</code> for these bound checks. I would like to use a tactic <code>assert</code> that would either perform the runtime check(probably panic on failure) or just turn into sorry based on the assertion level.</p>",
        "id": 284104198,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653639765
    },
    {
        "content": "<p>Doing that as a tactic does not seem possible to me, after all proofs in Lean are irrelevant so proof producing terms wont be compiled to executable code.</p>",
        "id": 284104777,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653640110
    },
    {
        "content": "<p>Ahh you are right, that is a problem. However, we can have a macro <code>theorem ... := test_by ...</code> that generates those tests and optionally the theorem with sorry.</p>",
        "id": 284105536,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653640560
    },
    {
        "content": "<p>And at some point you can just replace <code>test_by ...</code> with actual proof.</p>",
        "id": 284105929,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653640755
    },
    {
        "content": "<p>Oh doing the testing with a tactic should be possible, after all those can be executed at compile time (although we may want to move to executable time for speed), I was more referring to your wish for an <code>assert</code> that you can just use anywhere so e.g. having a <code>have : n &lt; m := by assert</code> somewhere in a <code>do</code> block would be a problem</p>\n<p>Although this can probably be solved with a macro as well.</p>",
        "id": 284106108,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653640864
    },
    {
        "content": "<p>Yes the assert is a problem. In my use cases I'm almost exclusively working with Subtype. So I can have assert function <code>X -&gt; Subtype P</code> that can run the test or just sorry it based on the assertion level.</p>",
        "id": 284106589,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653641134
    },
    {
        "content": "<p>With the runtime proof errasure, can't we use something like <code>Thunk Prop</code> to ensure the test does not get errased?</p>",
        "id": 284106995,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653641409
    },
    {
        "content": "<p>The only problem is that <code>Thunk</code> is currently defined only for <code>Type</code> and not <code>Sort</code></p>",
        "id": 284107051,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653641471
    },
    {
        "content": "<p>You can't just trick the Lean compiler into ignoring axiom K like that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">SortTunk</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">fn</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">SortTunk.mk</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">True.intro</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">SortTunk</span> <span class=\"n\">True</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fn</span> <span class=\"o\">()</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span> <span class=\"c1\">-- invalid universe level, 0 is not greater than 0</span>\n</code></pre></div>",
        "id": 284107536,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653641788
    },
    {
        "content": "<p>What you can however do is have a macro <code>assert! h : n &gt; m</code> that desugars into:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"n\">m</span><span class=\"o\">:</span>\n   <span class=\"bp\">&lt;</span><span class=\"n\">rest</span> <span class=\"n\">of</span> <span class=\"n\">code</span><span class=\"bp\">&gt;</span>\n<span class=\"k\">else</span>\n   <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>Or something like that.</p>",
        "id": 284107580,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653641828
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">assert</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"assert!\"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Lean.explicitBinders</span> <span class=\"s2\">\" =&gt; \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.expandExplicitBinders</span> <span class=\"bp\">`</span><span class=\"n\">assert</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">assert</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 2</span>\n</code></pre></div>\n<p>The <code>assert</code> function returns a <code>Type</code> and not a <code>Sort</code> to make sure the basic error of using this to create proofs doesn't occur, but it's not a perfect check.</p>",
        "id": 284109674,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653643355
    },
    {
        "content": "<p>It can take multiple hypotheses as binders:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">assert</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 0 (and \"unreachable code has been reached\")</span>\n</code></pre></div>",
        "id": 284109758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653643431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/LSpec.3A.20A.20testing.20framework.20for.20Lean/near/284091901\">said</a>:</p>\n<blockquote>\n<p>Do you recommend tests be put in a separate project directory (like <code>Tests</code>) or just littered around a project (i.e. in each relevant directory of the main project?)</p>\n</blockquote>\n<p>I think for now it shouldn't make a difference, and whichever works for your project is probably fine. Eventually when we have a test runner up and running, it'll probably look for specific files, but ideally those also can be scattered around the project.</p>",
        "id": 284126165,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1653654854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/LSpec.3A.20A.20testing.20framework.20for.20Lean/near/284093682\">said</a>:</p>\n<blockquote>\n<p>It's really great that someone is working on this!</p>\n<p>May I ask why do you introduce a new  keywords like <code>alwaysEquals</code>? Can't you use decidable Prop? </p>\n<p>I was thinking about testing a bit and I was thinking about something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mkspec</span> <span class=\"n\">expPositive</span> <span class=\"o\">:=</span> <span class=\"k\">forall</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">,</span> <span class=\"n\">Float.exp</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>As <code>x &gt;= 0</code> is a decidable Prop you can then generate a test by providing a sampling method for the argument <code>x</code>.</p>\n</blockquote>\n<p>The original version I wrote had everything in terms of <code>Prop</code>, but I found half the time writing tests I had to prove decidability and it would take a lot longer than I hoped defining specifications and examples.</p>\n<p>I think having different trust settings is an interesting idea though. It's definitely part of the goal for this to help users go from testing specifications to actually formally verifying the property, and that would help a lot.</p>",
        "id": 284127320,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1653655507
    },
    {
        "content": "<p>Oh and maybe you want to look into integrating it with slimcheck: <a href=\"https://github.com/leanprover-community/mathlib4/tree/master/Mathlib/Testing/SlimCheck\">https://github.com/leanprover-community/mathlib4/tree/master/Mathlib/Testing/SlimCheck</a> which is the Lean quickcheck port, property testing seems to be one of the preferred ways at least in Haskell to run tests.</p>",
        "id": 284127765,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1653655770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/LSpec.3A.20A.20testing.20framework.20for.20Lean/near/284091901\">said</a>:</p>\n<blockquote>\n<p>Do you recommend tests be put in a separate project directory (like <code>Tests</code>) or just littered around a project (i.e. in each relevant directory of the main project?)</p>\n</blockquote>\n<p>More on this: I was highly motivated by Rust's design of having tests spread all over the code. And the way that <code>#spec</code> works makes the <code>lake build</code> command break if a test doesn't succeed fully. The rationale is that incorrect code won't build!</p>",
        "id": 284163182,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1653673377
    },
    {
        "content": "<p>So if you see yourself forced to write a <code>partial</code> function you can't prove things about, write some tests below and proceed more tranquil. Make sure the edge cases work as expected, at least</p>",
        "id": 284163454,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1653673555
    },
    {
        "content": "<p>Sure. I think that keeping tests in a separate file in the same directory hierarchy should work fine for my use cases.</p>",
        "id": 284173833,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1653679232
    },
    {
        "content": "<p>How does LSpec interact with externs? One thing I'd really love is a spec that ensures a function matches its <code>implementedBy</code> on some provided set of inputs</p>",
        "id": 284174007,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1653679351
    },
    {
        "content": "<p>(In fact, such a spec would increase my confidence in the correctness of LeanColls by many orders of magnitude)</p>",
        "id": 284174086,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1653679412
    },
    {
        "content": "<p>We haven't tested it in many scenarios yet. I'd expect it to work if your logic can run at compilation time.<br>\nFor the things that can't be tested at compilation time, we want to provide a runner like Matej said. I'm 100% positive that we'll see the LSpec use cases expanding as we need it to do more</p>",
        "id": 284177414,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1653681207
    },
    {
        "content": "<p>We've made some changes on <a href=\"https://github.com/yatima-inc/LSpec\">LSpec</a> and now its use cases have been expanded. The README teaches you how to use it in two different ways:</p>\n<ul>\n<li>Via the <code>#lspec</code> command</li>\n<li>Via the <code>lspec</code> function, mixed with the <code>lspec</code> binary</li>\n</ul>\n<p>It also teaches you how to integrate LSpec in your CI runs like in this <a href=\"https://github.com/yatima-inc/Ipld.lean/tree/main/.github/workflows\">example</a></p>",
        "id": 284742539,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654175767
    },
    {
        "content": "<p>I'm still not really sold on it, the approach you chose makes refactoring to formal verification seem like a bigger effort to me than it should be, you are locking the user in to your test framework types etc. which makes pulling out test cases you want to verify seem like a more of a hassle than it should be.</p>\n<p>Instead of your <code>Rel</code> type why not use a <code>Decidable</code> <code>Prop</code>? That way nobody has to bother with specifically integrating their custom assertions into your thing but instead we all just implement <code>Decidable</code> instances for our things and can use them in programming, testing etc.<br>\nE.g. for your List assertions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">shouldNotBeEmpty</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span><span class=\"n\">l.isEmpty</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">shouldNotBeEmpty</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">shouldNotBeEmpty</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now that tests are living in <code>Prop</code> we can easily refactor to <code>theorem</code> instead of LSpec if we so desire, for example I might have a series of tests:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">shouldBeEmpty</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.isEmpty</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">shouldNotBeEmpty</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span><span class=\"n\">l.isEmpty</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">twoTests</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"o\">:=</span>\n  <span class=\"n\">it</span> <span class=\"s2\">\"knows list with elements should not be empty\"</span> <span class=\"o\">(</span><span class=\"n\">shouldNotBeEmpty</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span>\n  <span class=\"n\">it</span> <span class=\"s2\">\"knows list without elements should be empty\"</span> <span class=\"o\">(</span><span class=\"n\">shouldBeEmpty</span> <span class=\"o\">[])</span>\n</code></pre></div>\n<p>and now if we refactor to formal verification I would ideally imagine we can just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">List.not_empty_of_elements</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">shouldNotBeEmpty</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">isEmpty</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">List.nil_is_empty</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">shouldBeEmpty</span> <span class=\"n\">α</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">twoTests</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"o\">:=</span>\n  <span class=\"n\">it</span> <span class=\"s2\">\"knows list with elements should not be empty\"</span> <span class=\"n\">List.not_empty_of_elements</span>\n  <span class=\"n\">it</span> <span class=\"s2\">\"knows list without elements should be empty\"</span> <span class=\"n\">List.nil_is_empty</span>\n</code></pre></div>\n<p>and now LSpec will report property 1 and 2 as formally verified (maybe it will even report what property was proven but that would require meta code).</p>",
        "id": 284751019,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1654179167
    },
    {
        "content": "<p>At first, I wouldn't want to bother with theorem proving If I choose to test things with LSpec. The way I think of LSpec is more similar to traditional unit testing. You can even write tests for partial functions.</p>\n<p>Ideally, when using Lean 4, one would have theorems for the things they <em>can</em> and unit tests for the rest</p>",
        "id": 284752177,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654179691
    },
    {
        "content": "<p>You can expect the user to implement decidability instances, but I, while using LSpec, don't want to implement those. I'm usually happy with test outcomes that evaluate booleans</p>",
        "id": 284752875,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654180035
    },
    {
        "content": "<p>But this is exactly the issue, when writing big software systems it is not realistic that you will verify everything from the beginning, what will most likely happen is:</p>\n<ol>\n<li>You write the code</li>\n<li>You write some LSpec tests to see if you are at least not completely wrong</li>\n<li>You transfer the properties you wanna verify  from LSpec to theorem, this might also be a very gradual process since verification can take long.</li>\n</ol>\n<p>And if LSpec now doesn't bother to be compatible with <code>Prop</code> world you (unintentionally) discourage people from pulling tests out into theorems because they have to translate everything from your <code>Rel</code> type to <code>Prop</code> which is of course doable but rather annoying and if things are annoying people don't tend to do them.</p>\n<p>Furthermore e.g. the spec framework in Haskell is not just a unit tester, it also allows you to have property tests with <code>quickcheck</code> etc. It is a mean to write an executable specification for your code. And if you have formally verified parts of that specification you would ideally want them to appear there as well so if somebody is wondering whether a certain property is tested/verfied they can just read the (executable) specification and see that it is indeed the case.</p>",
        "id": 284752998,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1654180087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/LSpec.3A.20A.20testing.20framework.20for.20Lean/near/284752875\">said</a>:</p>\n<blockquote>\n<p>You can expect the user to implement decidability instances, but I, while using LSpec, don't want to implement those. I'm usually happy with test outcomes that evaluate booleans</p>\n</blockquote>\n<p>Well but what is the issue with extending to Decidable propeties then? All Booleans can be auto casted into Decidable Props</p>",
        "id": 284753034,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1654180109
    },
    {
        "content": "<p>I'm starting to see what you mean. That sounds like a nice next step. I suspect the challenge will be upgrading the <code>#lspec</code> command along with everything else</p>",
        "id": 284754093,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654180621
    },
    {
        "content": "<p>From my experience, I'm more and more convinced that using <code>sorry</code> should be much more encouraged and not make you feel guilty when you use it, at least for general programming. I find dependent types super powerful and useful not for proving stuff but that I can clearly state the specification of what my program is supposed to be doing.</p>\n<p>I commonly implement decidable equality by effectively writing a boolean function and just use sorry for those equality proofs.</p>\n<p>I think such practice should be encouraged and filling out those proofs is just an another way you can debug your code.</p>",
        "id": 284773019,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1654188870
    },
    {
        "content": "<p>So I agree with Henrik that tests should live in Prop and I would add that it should be encouraged to implement decidable prop just as a boolean function with sorry. Full proofs can be filled in later when things start breaking.</p>",
        "id": 284773911,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1654189254
    },
    {
        "content": "<p>I'm curious, what issues are you running into with writing decidable instances? <code>Decidable</code> is \"just\" <code>Bool</code> that also knows what it's saying is true or false.</p>\n<p>You could manipulate <code>Decidable</code> values as if they were boolean values by creating some additional functions that are already present as instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Decidable.and</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>(It's admittedly trickier to work with <code>Decidable</code> than <code>Bool</code> since you have that dependent type.)</p>",
        "id": 284777284,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654190658
    },
    {
        "content": "<p>The \"issue\" is mostly time, I believe. We were aiming at something minimal enough to serve our purposes. But of course it can be expanded/improved and more use cases can be implemented if/when needed</p>",
        "id": 284777806,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654190981
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/LSpec.3A.20A.20testing.20framework.20for.20Lean/near/284752875\">said</a>:</p>\n<blockquote>\n<p>You can expect the user to implement decidability instances, but I, while using LSpec, don't want to implement those. I'm usually happy with test outcomes that evaluate booleans</p>\n</blockquote>\n<p>I think the point is that <code>Decidable</code> lets you use <code>Prop</code> as a DSL for boolean-valued functions, so that way you/users can use familiar syntax.</p>",
        "id": 284778045,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654191109
    },
    {
        "content": "<p>Yeah, it's definitely worth a try at some point! If anything, it's always possible to offer a simpler API that just deals with Bools and another that handles <code>Prop</code></p>",
        "id": 284778759,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654191499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> Here's what it could look like using <code>Decidable</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The basic structure used to encode specifications.</span>\n<span class=\"sd\">It represents a list of tests, with each test consisting of</span>\n<span class=\"sd\">a description `descr`, some value `a`, and a test `rel` for `a`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">LSpec</span>\n  <span class=\"bp\">|</span> <span class=\"n\">done</span>\n  <span class=\"bp\">|</span> <span class=\"n\">more</span> <span class=\"o\">(</span><span class=\"n\">descr</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">DecidablePred</span> <span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">next</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`it` adds a single test to the testing suite.</span>\n<span class=\"sd\">This is the same as the projection `LSpec.more`, but extracting it out</span>\n<span class=\"sd\">allows us to set `next` with the default value `done`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">it</span> <span class=\"o\">(</span><span class=\"n\">descr</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">rel</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">next</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"o\">:=</span> <span class=\"n\">LSpec.done</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LSpec.more</span> <span class=\"n\">descr</span> <span class=\"n\">a</span> <span class=\"n\">rel</span> <span class=\"n\">inferInstance</span> <span class=\"n\">next</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Prints the result of a test.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">printMsg</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"✓ it {d}\"</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"× it {d}\"</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Runs a set of `LSpec` tests and appends the results to</span>\n<span class=\"sd\">another list of results (given as input by the caller).</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">runLSpec</span> <span class=\"o\">(</span><span class=\"n\">results</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">more</span> <span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"n\">rel</span> <span class=\"n\">h</span> <span class=\"n\">next</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">rel</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">runLSpec</span> <span class=\"n\">results</span> <span class=\"n\">next</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">done</span>                <span class=\"bp\">=&gt;</span> <span class=\"n\">results.reverse</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Generates a report for all the results in a `LSpec` test,</span>\n<span class=\"sd\">returning `true` if all tests passed and `false` otherwise.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">compileLSpecResult</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">runLSpec</span> <span class=\"o\">[]</span> <span class=\"n\">t</span>\n  <span class=\"o\">(</span><span class=\"n\">res.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">acc</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">acc</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n    <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span> <span class=\"bp\">$</span> <span class=\"n\">res.map</span> <span class=\"n\">printMsg</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Runs a `LSpec` test and pretty prints the results.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">lspec</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">UInt32</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Testing that: {s}\"</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">success</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">msg</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">compileLSpecResult</span> <span class=\"n\">t</span>\n  <span class=\"k\">if</span> <span class=\"n\">success</span><span class=\"bp\">?</span>\n    <span class=\"k\">then</span> <span class=\"n\">IO.println</span>  <span class=\"n\">msg</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"mi\">0</span>\n    <span class=\"k\">else</span> <span class=\"n\">IO.eprintln</span> <span class=\"n\">msg</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">lspecStx</span><span class=\"o\">)</span> <span class=\"s2\">\"#lspec \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span> <span class=\"n\">Term</span> <span class=\"k\">in</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Custom elaborator for the `#lspec` command.</span>\n<span class=\"sd\">Basically it runs the normal `lspec` function and outputs to the Infoview.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[commandElab lspecStx]</span> <span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">elabLSpec</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"n\">liftTermElabM</span> <span class=\"bp\">`</span><span class=\"n\">lspec</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">term</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">term</span> <span class=\"n\">none</span>\n    <span class=\"n\">synthesizeSyntheticMVarsNoPostponing</span>\n    <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">term</span>\n    <span class=\"k\">if</span> <span class=\"n\">type.isAppOf</span> <span class=\"bp\">``</span><span class=\"n\">LSpec</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">reduce</span> <span class=\"bp\">$</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">compileLSpecResult</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">term</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"n\">success</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">←</span> <span class=\"n\">evalExpr</span> <span class=\"n\">Bool</span> <span class=\"bp\">``</span><span class=\"n\">Bool</span> <span class=\"o\">(</span><span class=\"n\">res.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">msg</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">←</span> <span class=\"n\">evalExpr</span> <span class=\"n\">String</span> <span class=\"bp\">``</span><span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"n\">res.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n      <span class=\"k\">if</span> <span class=\"n\">success</span><span class=\"bp\">?</span>\n        <span class=\"k\">then</span> <span class=\"n\">logInfo</span> <span class=\"n\">msg</span>\n        <span class=\"k\">else</span> <span class=\"n\">throwError</span> <span class=\"n\">msg</span>\n    <span class=\"k\">else</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Invalid term to run '#lspec' with\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"o\">:=</span> <span class=\"n\">it</span> <span class=\"s2\">\"knows equality\"</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">lspec</span> <span class=\"n\">foo</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">twoTests</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"o\">:=</span>\n  <span class=\"n\">it</span> <span class=\"s2\">\"knows equality\"</span> <span class=\"mi\">42</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n  <span class=\"n\">it</span> <span class=\"s2\">\"knows lists\"</span> <span class=\"o\">[</span><span class=\"mi\">42</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:=</span>\n  <span class=\"n\">lspec</span> <span class=\"s2\">\"some description\"</span> <span class=\"bp\">$</span>\n    <span class=\"n\">twoTests</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">main</span> <span class=\"o\">[]</span>\n</code></pre></div>\n</div></div>\n<p>For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"o\">:=</span> <span class=\"n\">it</span> <span class=\"s2\">\"knows equality\"</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 284782423,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654193163
    },
    {
        "content": "<p>You can use boolean-valued functions too with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">LSpec</span> <span class=\"o\">:=</span> <span class=\"n\">it</span> <span class=\"s2\">\"knows equality\"</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 284782576,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654193255
    },
    {
        "content": "<p>Oh that was (a lot) smoother than I thought actually! Thanks!</p>",
        "id": 284782907,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654193404
    },
    {
        "content": "<p>Here is my idea how to write tests while using familiar <code>theorem ... := &lt;proof&gt;</code> syntax. Instead of <code>&lt;proof&gt;</code> you write <code>test_by &lt;test instructions&gt;</code>. It looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- All succeed</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test_foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- All fail</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test_bar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- One fail, two succeed</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It is just a proof of concept, the macro is super dumb.</p>\n<p>The full code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">testStx</span> <span class=\"o\">(</span><span class=\"n\">behavior</span> <span class=\"o\">:=</span> <span class=\"n\">both</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"(\"</span> <span class=\"n\">ident</span> <span class=\"s2\">\":\"</span> <span class=\"n\">term</span> <span class=\"s2\">\":=\"</span> <span class=\"n\">term</span> <span class=\"s2\">\")\"</span> <span class=\"o\">:</span> <span class=\"n\">testStx</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">declModifiers</span> <span class=\"s2\">\"theorem \"</span> <span class=\"n\">declId</span> <span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span> <span class=\"s2\">\":\"</span> <span class=\"n\">term</span> <span class=\"s2\">\":=\"</span> <span class=\"s2\">\"test_by\"</span> <span class=\"n\">testStx</span><span class=\"bp\">+</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">run_test</span> <span class=\"o\">(</span><span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">message</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">test</span> <span class=\"k\">then</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Test passed! {message}\"</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">throw</span> <span class=\"o\">(</span><span class=\"n\">IO.userError</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Test failed! {message}\"</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">mods</span><span class=\"o\">:</span><span class=\"n\">declModifiers</span> <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">params</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">thrm</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span> <span class=\"o\">(</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">)</span> <span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">xname</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.mkStrLit</span> <span class=\"n\">x.getId.toString</span>\n    <span class=\"k\">let</span> <span class=\"n\">idname</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.mkStrLit</span> <span class=\"n\">id</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId.toString</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">#eval</span> <span class=\"n\">run_test</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"bp\">;</span> <span class=\"bp\">$</span><span class=\"n\">thrm</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{$idname} with {$xname} := {$val}\"</span><span class=\"o\">)</span>\n\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">mods</span><span class=\"o\">:</span><span class=\"n\">declModifiers</span> <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">params</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">thrm</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span> <span class=\"bp\">$</span><span class=\"n\">test</span> <span class=\"bp\">$</span><span class=\"n\">tests</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">mods</span><span class=\"o\">:</span><span class=\"n\">declModifiers</span> <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">params</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">thrm</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span> <span class=\"bp\">$</span><span class=\"n\">test</span>\n      <span class=\"bp\">$</span><span class=\"n\">mods</span><span class=\"o\">:</span><span class=\"n\">declModifiers</span> <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">params</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">thrm</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span> <span class=\"bp\">$</span><span class=\"n\">tests</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- All succeed</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test_foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- All fail</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test_bar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- One fail, two succeed</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">test_by</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 284799325,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1654201239
    },
    {
        "content": "<p>This looks cool!</p>",
        "id": 284801288,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1654202216
    },
    {
        "content": "<p>Another thought, the code above generates <code>#eval</code> commands. Thus the test runs at compile time, this is undesirable for more heavy weight tests. It would be nice to alternatively generate <code>IO Unit</code> instead of <code>#eval</code> that can be executed after compilation is done.</p>",
        "id": 284857714,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1654250317
    },
    {
        "content": "<p>After great help from <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, we've upgraded LSpec to allow test statements to live in <code>Prop</code>. The evaluation was also improved, although it's still an <code>#eval</code> under the hood.</p>\n<p><a href=\"https://github.com/yatima-inc/LSpec\">https://github.com/yatima-inc/LSpec</a></p>",
        "id": 287205381,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1655997484
    },
    {
        "content": "<p>Something this is also able to do is give an explanation for why a test failed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">lspec</span> <span class=\"n\">test</span> <span class=\"s2\">\"array eq\"</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">× array eq</span>\n<span class=\"cm\">  Expected to be equal:</span>\n<span class=\"cm\">    #[1, 2, 3]</span>\n<span class=\"cm\">  and</span>\n<span class=\"cm\">    #[0, 1, 2]</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>This doesn't require any metaprogramming beyond typeclasses. The trick here is to define a custom version of <code>Decidable</code> that includes a message for why it's false: <a href=\"https://github.com/yatima-inc/LSpec/blob/main/LSpec/LSpec.lean#L7\">https://github.com/yatima-inc/LSpec/blob/main/LSpec/LSpec.lean#L7</a></p>\n<p>This particular example only depends on an instance for equality on a type that implements <code>Repr</code> and <code>DecidableEq</code>: <a href=\"https://github.com/yatima-inc/LSpec/blob/main/LSpec/Instances.lean#L6\">https://github.com/yatima-inc/LSpec/blob/main/LSpec/Instances.lean#L6</a></p>",
        "id": 287212937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656000749
    },
    {
        "content": "<p>One thing you could add to ease getting started is a <code>prio := low</code> instance for <code>TDecidable</code> that uses a <code>Decidable</code> as its basis and produces some totally generic error message. Apart from that it's looking quite nice to me now!</p>",
        "id": 287213553,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656001016
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Don't you worry, it's already there: <a href=\"https://github.com/yatima-inc/LSpec/blob/main/LSpec/LSpec.lean#L11\">https://github.com/yatima-inc/LSpec/blob/main/LSpec/LSpec.lean#L11</a></p>",
        "id": 287216190,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656002063
    },
    {
        "content": "<p>Ah, I only looked in Instances.lean</p>",
        "id": 287216268,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656002099
    },
    {
        "content": "<p>Maybe it should to go to <code>Instances.lean</code> actually. Will do in a next update. I think the next big improvement is implementing Tomas' idea of replacing the <code>#eval</code> call. But I won't be able to work on it for a while</p>",
        "id": 287218470,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656003200
    },
    {
        "content": "<p>Looks nice, I'm really glad you went for the Prop based tests!</p>\n<p>Are you also planning to add tests for tactics? All tests in my project are just testing if a tactic can solve a goal or not. It would be nice to get the same output for these kinds of tests. Currently I just check if the lean compiler successfully compiles a file with tests or not.</p>",
        "id": 287230260,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656008876
    },
    {
        "content": "<p>That's certainly a nice upgrade too. Maybe monadic testing first, then tactics? idk</p>",
        "id": 287237692,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656012789
    },
    {
        "content": "<p>Hi everyone, we've released a new version of <a href=\"https://github.com/yatima-inc/LSpec\">LSpec</a>!</p>\n<p>It's compatible with the most updated Lake release and makes use of its capabilities to run tests on properly compiled binaries rather than relying on running Lean code as script.</p>\n<p>Besides that major upgrade, we've also improved the API. We now provide two different <code>lspec</code> and a <code>lspecIO</code> functions. The former is meant for general purpose testing inside any function and the later is meant to be used as the body of a <code>main</code> function of a Lean file to be compiled by Lake.</p>",
        "id": 289325120,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1657633356
    }
]
[
    {
        "content": "<p>Hello all, a piece of code stopped working since a few days ago after I updated Lean4 to the latest nightly (2021-12-13).<br>\n<a href=\"https://github.com/tjhunter/advent_of_code_lean4_2021/blob/main/MyAdvent/AdventStd.lean#L72\">https://github.com/tjhunter/advent_of_code_lean4_2021/blob/main/MyAdvent/AdventStd.lean#L72</a></p>\n<p>The error I am getting is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">configuring</span> <span class=\"n\">tim_advent</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"bp\">&gt;</span> <span class=\"n\">LEAN_PATH</span><span class=\"bp\">=././</span><span class=\"n\">build</span> <span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">tjhunter</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly/bin/lean -o build/MyAdvent/AdventStd.olean -c build/temp/MyAdvent/AdventStd.c ./MyAdvent/AdventStd.lean</span>\n<span class=\"bp\">./</span><span class=\"n\">MyAdvent</span><span class=\"bp\">/</span><span class=\"n\">AdventStd.lean</span><span class=\"o\">:</span><span class=\"mi\">72</span><span class=\"o\">:</span><span class=\"mi\">83</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">invalid</span> <span class=\"bp\">'</span><span class=\"k\">do</span><span class=\"bp\">'</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"n\">monad</span> <span class=\"n\">application</span>\n  <span class=\"n\">Std.HashMap</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Am I missing something?</p>",
        "id": 264749014,
        "sender_full_name": "Tim Hunter",
        "timestamp": 1639419674
    },
    {
        "content": "<p>You need to prefix it with <code>Id.run </code> now.</p>",
        "id": 264749250,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1639419785
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover/lean4/issues/770\">https://github.com/leanprover/lean4/issues/770</a> for the discussion that motivated this change.</p>",
        "id": 264751062,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639420664
    },
    {
        "content": "<p>Clear, thanks. As suggested in the ticket, updating the error message with a suggestion to use <a href=\"http://Id.run\">Id.run</a> will be much appreciated by new users like me.</p>",
        "id": 264751649,
        "sender_full_name": "Tim Hunter",
        "timestamp": 1639420938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460889\">Tim Hunter</span> has marked this topic as resolved.</p>",
        "id": 264751654,
        "sender_full_name": "Notification Bot",
        "timestamp": 1639420940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460889\">Tim Hunter</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264751649\">said</a>:</p>\n<blockquote>\n<p>Clear, thanks. As suggested in the ticket, updating the error message with a suggestion to use <a href=\"http://Id.run\">Id.run</a> will be much appreciated by new users like me.</p>\n</blockquote>\n<p>Thanks for the suggestion. We will do it.</p>",
        "id": 264752517,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639421403
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> With the elimination of pure do blocks, does that mean that <code>Option</code> can become a monad again? IIRC the issue was that uses of <code>Option A</code> in do blocks were supposed to be promoted to <code>Id (Option A)</code> rather than <code>OptionM A</code>, but without pure do block promotion I think there is no ambiguity here anymore.</p>",
        "id": 264799376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639449140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> No. The problem with <code>Option</code> being a monad still exists. In fact, it would create the same problems the pure <code>do</code> caused that motivated this change.</p>",
        "id": 264799503,
        "sender_full_name": "Mac",
        "timestamp": 1639449287
    },
    {
        "content": "<p>Could you elaborate? If the context of the <code>do</code> keyword has a known monad type, then everything else inside should be interpretable unambiguously</p>",
        "id": 264799571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639449358
    },
    {
        "content": "<p>so if you want <code>Option</code> as a monad you do <code>def bla : Option A := do ...</code> and if you want it as data you do <code>def bla : Option A := Id.run do ...</code></p>",
        "id": 264799656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639449411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264799656\">said</a>:</p>\n<blockquote>\n<p>so if you want <code>Option</code> as a monad you do <code>def bla : Option A := do ...</code> and if you want it as data you do <code>def bla : Option A := Id.run do ...</code></p>\n</blockquote>\n<p>The whole point of the pure <code>do</code> change (as I understand it) is to expressly prohibit using <code>do</code> with \"data\" objects like <code>Option</code> so that users don't accidently stick a <code>do</code> on a function like <code>bla</code> expecting it to return <code>Option A</code> when it instead does  functional programming control flow magic with <code>Option</code>.</p>",
        "id": 264799926,
        "sender_full_name": "Mac",
        "timestamp": 1639449658
    },
    {
        "content": "<p>The design goal is that <code>do</code> will give you the nice error you see now for types that are meant to be data (e.g., <code>Option</code>) and work in the usual functional way with types that are supposed to be control (e.g., <code>OptionT</code>/<code>OptionM</code>).</p>",
        "id": 264800067,
        "sender_full_name": "Mac",
        "timestamp": 1639449798
    },
    {
        "content": "<p>I do, however, think it would probably be a good idea to some form of data analogue of the control flow type-classes so one can still write functions that are polymorphic over such types (without them being treated like control flow).</p>",
        "id": 264800158,
        "sender_full_name": "Mac",
        "timestamp": 1639449894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> We didn't decide yet, but we must do it before we release the first official version early next year.<br>\nOne good news is that we have already made many combinators more friendly to strict languages like Lean. Examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">OrElse</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">orElse</span>  <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Seq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">seq</span>  <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SeqLeft</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">seqLeft</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SeqRight</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">seqRight</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span>\n</code></pre></div>",
        "id": 264800271,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639449996
    },
    {
        "content": "<p>Ah, that's good to hear. (I take it that <code>OrElse</code> is triggered, including the lazy evaluation, when you write <code>a &lt;|&gt; b</code> where <code>a, b : OptionM A</code>?) I tripped on an eager evaluation issue on <code>option A</code> just a few days ago in lean 3, it's something you have to watch out for even though <code>macroInline</code> makes it mostly work</p>",
        "id": 264800611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639450315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264800611\">said</a>:</p>\n<blockquote>\n<p>Ah, that's good to hear. (I take it that <code>OrElse</code> is triggered, including the lazy evaluation, when you write <code>a &lt;|&gt; b</code> where <code>a, b : OptionM A</code>?) </p>\n</blockquote>\n<p>Yes, the <code>&lt;|&gt;</code> notation takes care of it.</p>\n<blockquote>\n<p>I tripped on an eager evaluation issue on <code>option A</code> just a few days ago in lean 3, it's something you have to watch out for even though <code>macroInline</code> makes it mostly work</p>\n</blockquote>\n<p>We also hit this issue in the past.</p>",
        "id": 264800920,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639450506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Yes, this is a valid concern. I don't have a good mental model for new users, and the kinds of mistakes they make, and how incomprehensible our error messages are to them. We have been trying to improve the error messages, but sometimes the improvement requires a considerable amount of work and extra bookkeeping.</p>",
        "id": 264801793,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639450907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264800271\">said</a>:</p>\n<blockquote>\n<p>One good news is that we have already made many combinators more friendly to strict languages like Lean.</p>\n</blockquote>\n<p>Since you brought up these signatures, I wanted to ask about the logic behind them. While I get the desire for lazy evaluation (and embedding said lazy evaluation into operators like <code>&lt;|&gt;</code>), changing the signatures of the type-classes themselves mean that a lot of already lazy monads (e.g., <code>IO</code> or <code>ReaderT</code>) become doubly lazy (and thus, I presume, less efficient).</p>\n<p>What was the rational behind not defining something like a <code>LazyT</code>/<code>LazyM</code> and just using that as the base monad for types like <code>OptionM</code>:.For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">LazyT</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">LazyT.mk</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LazyT</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">LazyT.run</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">LazyT</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"o\">(</span><span class=\"n\">LazyT</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">a</span>\n  <span class=\"n\">bind</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bind</span> <span class=\"n\">x.run</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">LazyM</span> <span class=\"o\">:=</span> <span class=\"n\">LazyT</span> <span class=\"n\">Id</span>\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">LazyM.run</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">LazyM</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OptionM</span> <span class=\"o\">:=</span> <span class=\"n\">OptionT</span> <span class=\"n\">LazyM</span>\n</code></pre></div>",
        "id": 264801941,
        "sender_full_name": "Mac",
        "timestamp": 1639450965
    },
    {
        "content": "<p>One thing that I didn't see come up in the linked issue, which I would have suggested if it had come up in a question here, is to use <code>pure</code> when constructing a <code>Nat</code>, since the goal is actually <code>Id Nat</code> which doesn't have a multiplication</p>",
        "id": 264801976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639450985
    },
    {
        "content": "<p>in general, I find automatic <code>pure</code> insertion to be a convenience feature that doesn't always work, and I would suggest to write <code>pure</code> explicitly when there are weird type errors</p>",
        "id": 264802057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639451029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264801793\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> Yes, this is a valid concern. I don't have a good mental model for new users, and the kinds of mistakes they make, and how incomprehensible our error messages are to them.</p>\n</blockquote>\n<p>I am a new user, if you need a newbie to provide feedback on error messages</p>",
        "id": 264802159,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639451063
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> the entirely problem is that it is unintuitive to new users (and as your example demonstrated even advanced users get caught up in its idiosyncrasies) who have limited understanding of monads and all that magic. They expect <code>do</code> to work just like a normal imperative language (which amazingly, in Lean, it most of the time does) and that is where all the confusion stems from.  The idea of a magic <code>Id</code> just makes the whole thing that much more complex.</p>",
        "id": 264802316,
        "sender_full_name": "Mac",
        "timestamp": 1639451150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264801941\">said</a>:</p>\n<blockquote>\n<p>changing the signatures of the type-classes themselves mean that a lot of already lazy monads (e.g., <code>IO</code> or <code>ReaderT</code>) become doubly lazy (and thus, I presume, less efficient).</p>\n</blockquote>\n<p>In my mental model of the compiler, this should not be any less efficient. It means that you have two lambdas instead of one, which means a compiled function with two arguments, one of which is a dummy argument. Lean can sometimes eliminate these dummy arguments, but they often make it to C; but LLVM definitely knows how to eliminate unused arguments, so they should not have any cost in the final compiled result.</p>",
        "id": 264802476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639451251
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> </p>\n<blockquote>\n<p>become doubly lazy (and thus, I presume, less efficient).</p>\n</blockquote>\n<p>Not really, the compiler eliminates the overhead.</p>\n<blockquote>\n<p>What was the rational behind not defining something like a LazyT/LazyM</p>\n</blockquote>\n<p>It doesn't prevent common mistakes and counterintuitive behavior. For example, in the following code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">expensive</span><span class=\"bp\">;</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p><code>expensive</code> is only executed when <code>a</code> fails. This is not true for strict languages with the usual <code>orElse</code> type.<br>\nWith the new <code>orElse</code> type, we rely on the fact the compiler will not float <code>let</code> over lambdas.</p>",
        "id": 264802611,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639451360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802476\">said</a>:</p>\n<blockquote>\n<p>but LLVM definitely knows how to eliminate unused arguments, so they should not have any cost in the final compiled result.</p>\n</blockquote>\n<p>While it is true that LLVM/clang will generally be smart to inline these, the problem is that there are m any uses where this is irrelevant  For example, dynamically linked functions or functions called indirectly through pointers (the of latter which, as you might imagine, is quite common in functional programming languages).</p>",
        "id": 264802770,
        "sender_full_name": "Mac",
        "timestamp": 1639451465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802159\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264801793\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> Yes, this is a valid concern. I don't have a good mental model for new users, and the kinds of mistakes they make, and how incomprehensible our error messages are to them.</p>\n</blockquote>\n<p>I am a new user, if you need a newbie to provide feedback on error messages</p>\n</blockquote>\n<p>Thanks, that is useful. If you find weird messages please create an issue on our repo. That being said, I am not sure you qualify as a newbie anymore, I have seen you posting advanced stuff :)</p>",
        "id": 264802802,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639451499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802316\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> the entirely problem is that it is unintuitive to new users (and as your example demonstrated even advanced users get caught up in its idiosyncrasies) who have limited understanding of monads and all that magic. They expect <code>do</code> to work just like a normal imperative language (which amazingly, in Lean, it most of the time does) and that is where all the confusion stems from.  The idea of a magic <code>Id</code> just makes the whole thing that much more complex.</p>\n</blockquote>\n<p>If you want to make all actions \"apparent\", I think that means you have to give up the haskell style do notation <code>do act1; act2</code> in which <code>act1</code> can have monadic effects, and instead replace it with something like <code>do &lt;- act1; act2</code> which, like Rust's <code>?</code> operator, makes the fancy control flow explicit. I'm not actually proposing this, but it is worth considering since this seems like a conflict between the imperative and haskell-style traditions for how <code>do</code> should work.</p>",
        "id": 264802951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639451606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> One clarification, in the message above \"compiler\" is referencing to the transformations performed by Lean, not LLVM.</p>",
        "id": 264802955,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639451610
    },
    {
        "content": "<p>Personally, (having experience with haskell <code>do</code>,) I find <code>do act1; act2</code> to be clear enough for the case where <code>act1</code> and <code>act2</code> have effects, and requiring <code>do pure act1; pure act2</code> if you want to opt out of that behavior. Automatic <code>pure</code> insertion makes this syntax slightly ambiguous, which can be problematic when you want to return an <code>Option</code>, but I think asking the user to write <code>pure</code> explicitly in these cases is a reasonable compromise. (Note that it's usually a type error if you screw this up anyway, so lean still has your back in this scenario.)</p>",
        "id": 264803296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639451832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264802611\">said</a>:</p>\n<blockquote>\n<p>It doesn't prevent common mistakes and counterintuitive behavior. For example, in the following code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">expensive</span><span class=\"bp\">;</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p><code>expensive</code> is only executed when <code>a</code> fails. This is not true for strict languages with the usual <code>orElse</code> type.<br>\nWith the new <code>orElse</code> type, we rely on the fact the compiler will not float <code>let</code> over lambdas.</p>\n</blockquote>\n<p>Couldn't that still be handled by the macro/elaborator? Just using <code>LazyT</code> instead of changing the typeclass? For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">SeqRight</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">seqRight</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"s2\">\" *&gt; \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"mi\">61</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">LazyT.run</span> <span class=\"o\">(</span><span class=\"n\">SeqRight.seqRight</span> <span class=\"o\">(</span><span class=\"n\">LazyT.mk</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">LazyT.mk</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>or for heterogenous operators like <code>HOrElse</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HOrElse</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">hOrElse</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">HOrElse</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HOrElse</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">LazyM</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">γ</span> <span class=\"n\">where</span>\n  <span class=\"n\">hOrElse</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">HOrElse.hOrElse</span> <span class=\"n\">a</span> <span class=\"n\">b.run</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"mi\">21</span> <span class=\"s2\">\" &lt;|&gt; \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">HOrElse.hOrElse</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">LazyM.mk</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 264804088,
        "sender_full_name": "Mac",
        "timestamp": 1639452480
    },
    {
        "content": "<p>The <code>LazyT</code> idiom also enables the creation of a nice <code>lazy</code> macro for writing lazily evaluated code, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"s2\">\"lazy \"</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LazyM.mk</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"lazy_do \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">doSeq</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">LazyT.mk</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 264804473,
        "sender_full_name": "Mac",
        "timestamp": 1639452671
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Your <code>&lt;|&gt;</code> macro seems to be assuming that the monad was built using <code>LazyT</code>. I have to go, but happy to explore the next time we meet online. Zulip is too inefficient to brainstorm this kind of encoding.</p>",
        "id": 264804641,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639452824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>Ah, makes sense. Have a good night! Talk to you later! <span aria-label=\"goodnight\" class=\"emoji emoji-1f31b\" role=\"img\" title=\"goodnight\">:goodnight:</span></p>",
        "id": 264804815,
        "sender_full_name": "Mac",
        "timestamp": 1639452940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264803296\">said</a>:</p>\n<blockquote>\n<p>Personally, (having experience with haskell <code>do</code>,) I find <code>do act1; act2</code> to be clear enough for the case where <code>act1</code> and <code>act2</code> have effects, and requiring <code>do pure act1; pure act2</code> if you want to opt out of that behavior.</p>\n</blockquote>\n<p>I'm sorry, but I am not sure I understand what you are getting at here. How does this relate to the discussion?</p>",
        "id": 264805583,
        "sender_full_name": "Mac",
        "timestamp": 1639453444
    },
    {
        "content": "<p>You didn't spell out the issue you had with <code>Option</code> being a monad, but as I understand it the problem is that <code>do opt1; opt2</code> and <code>do pure opt1; opt2</code> do different things if <code>Option</code> is a monad (and <code>opt1, opt2 : Option A</code> and the expected type is <code>Option A</code>). The example in the issue is a variation on this where <code>do a</code> infers the type <code>Id Nat</code> for <code>a</code> when the <code>do</code> is in the <code>Id</code> monad, while the user was expecting it to have the type <code>Nat</code> (which it would have in <code>do pure a</code>).</p>",
        "id": 264806075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639453746
    },
    {
        "content": "<p>(I'm responding to <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264799926\">your previous message</a> here, not the stuff about <code>&lt;|&gt;</code> laziness and <code>LazyT</code>, about which I have no opinion.)</p>",
        "id": 264806383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639453961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264806075\">said</a>:</p>\n<blockquote>\n<p>You didn't spell out the issue you had with <code>Option</code> being a monad, but as I understand it the problem is that <code>do opt1; opt2</code> and <code>do pure opt1; opt2</code> do different things if <code>Option</code> is a monad (and <code>opt1, opt2 : Option A</code> and the expected type is <code>Option A</code>).</p>\n</blockquote>\n<p>That is certainly one of the problems, though it is not one I had in mind. An example closer to what I was thinking is that things like <code>return none</code> would break in ways that would very much confuse users. However, you are right, that fact that <code>(do opt1; opt2) : Option a</code> could be accepted when the user is intending to treating <code>Option</code> as data but <code>opt1</code> is being interpreted as control is another issue.</p>\n<p>On the <code>pure</code> front, I would probably advocate against <code>pure</code> auto-insertion altogether in <code>do</code> notation (and instead lead users to <code>return</code> as that is familiar to imperative programmers and avoids some of the more magical type errors that can arise due to <code>pure</code> auto-insertion).</p>",
        "id": 264809639,
        "sender_full_name": "Mac",
        "timestamp": 1639456176
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264804641\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> Your <code>&lt;|&gt;</code> macro seems to be assuming that the monad was built using <code>LazyT</code>.</p>\n</blockquote>\n<p>When you see this, fyi, you are correct, my macro is wrong. The laziness needs to be nested deeper than I was adding it to provide the desired effect, so I will have to think a bit more about this.</p>",
        "id": 264809934,
        "sender_full_name": "Mac",
        "timestamp": 1639456400
    },
    {
        "content": "<blockquote>\n<p>An example closer to what I was thinking is that things like <code>return none</code> would break in ways that would very much confuse users.</p>\n</blockquote>\n<p>Could you define what it means to \"break\" here? What is the expected result? As I understand it, in an <code>Option</code> monad do block <code>return none</code> would not work (unless you are producing an <code>Option (Option A)</code>), and the correct way to \"throw\" in a do block is instead simply <code>none</code> (or <code>&lt;- none</code>).</p>",
        "id": 264811788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639457804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> exactly, that is my point. One way to think of <code>do</code> notation is simple as a way to switch to imperative programming mode (like <code>by</code> switches to tactic mode). It is the way many new to Lean would think of it and I personally think that this is a fine conceptual model. Thus, I, as such a user, would see that my function returns \"Option Nat\" so would expect to <code>return none</code> from within my <code>do</code> block when I want to produce <code>none</code>. </p>\n<p>Such a user may have no conception of monads or that <code>Option</code> is a monad, they simple see <code>do</code> as imperative block and see things like <code>OptionM</code> and <code>ExceptM</code> as ways of augmenting there function so that it can do things like fail or throw errors. They don't necessarily need to bridge the gap between <code>OptionM</code> the control flow tool and <code>Option</code> the data type. The goal of things like the <code>do</code> notation error is to help such users bridge the gap without need to understand all the monad magic.</p>",
        "id": 264812727,
        "sender_full_name": "Mac",
        "timestamp": 1639458474
    },
    {
        "content": "<p>That sounds like an issue with the <code>return</code> command, not <code>Option</code></p>",
        "id": 264812909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639458603
    },
    {
        "content": "<p>It sounds like you want <code>return</code> to mean something different than it does</p>",
        "id": 264812955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639458620
    },
    {
        "content": "<p>The semantics you want can easily be expressed as <code>return &lt;- act</code>, maybe you want this to be a separate keyword?</p>",
        "id": 264813024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639458676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> this isn't just about return, the same holds true for example with <code>do opt1; opt2</code> vs <code>do discard opt1; opt2</code></p>",
        "id": 264813029,
        "sender_full_name": "Mac",
        "timestamp": 1639458681
    },
    {
        "content": "<p>I'm kind of lost as to what you think this is supposed to mean</p>",
        "id": 264813132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639458751
    },
    {
        "content": "<p>I know what haskell do notation does but you have some conflicting model and I don't know all the implications</p>",
        "id": 264813149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639458772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Sorry, I think I am sadly not making myself clear. My example was suppose to illustrate that such a user has a distinct separation between 'control' and 'data' -- thus they would be extremely confused that a data type is also control flow primitive.</p>",
        "id": 264813193,
        "sender_full_name": "Mac",
        "timestamp": 1639458825
    },
    {
        "content": "<p>it's not a control flow primitive, <code>do</code> and the syntactic constructs therein are the control flow primitives</p>",
        "id": 264813274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639458873
    },
    {
        "content": "<p>It really stretches my comprehension to imagine that someone is writing lean <code>do</code> notation code without any idea of what a monad is, when the structure is lifted so directly from the haskell lineage</p>",
        "id": 264813498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459007
    },
    {
        "content": "<p>I'm sure you can muddle through it but the moment you need to understand anything about what's going on you have to address the monad stuff</p>",
        "id": 264813562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I don't agree. Lean's <code>do</code> notation looks just like modern imperative code. The only real oddity is the use of <code>&lt;-</code> for functions with side effects. Furthermore, monads can be thought of in two ways -- as control flow primitives or as properties of data types. Lean tends towards the former, Haskell tends towards the later. For example, Lean has no parallel to the <code>List</code> monad, because lists does not intuitive translate into a control flow structure (even though one can define a <code>Monad</code> instance for it).</p>",
        "id": 264813917,
        "sender_full_name": "Mac",
        "timestamp": 1639459262
    },
    {
        "content": "<p>?? <code>List</code> can be made a monad in lean just as well as haskell</p>",
        "id": 264813997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459312
    },
    {
        "content": "<p>Call it <code>ListM</code> if it makes you feel better</p>",
        "id": 264814065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459327
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what control flow paradigm does <code>List</code> model in your view?</p>",
        "id": 264814149,
        "sender_full_name": "Mac",
        "timestamp": 1639459401
    },
    {
        "content": "<p>nondeterminism?</p>",
        "id": 264814160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459408
    },
    {
        "content": "<p>same as in haskell</p>",
        "id": 264814170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459416
    },
    {
        "content": "<p>well, not quite the same since haskell lists are maybe infinite</p>",
        "id": 264814197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what is the natural connection between the concept of a list and the concept of nondeterminism???</p>",
        "id": 264814319,
        "sender_full_name": "Mac",
        "timestamp": 1639459489
    },
    {
        "content": "<p>FYI, I have used the monad instance on <code>List</code> many times in lean 3 for e.g. proptest stuff</p>",
        "id": 264814361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459509
    },
    {
        "content": "<p>the list is the list of results of the computation, and you compose functions through foldMap</p>",
        "id": 264814442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459561
    },
    {
        "content": "<p>proptest meaning <code>do let a &lt;- [1:20]; let b &lt;- [1:20]; guard (a + b == b + a)</code></p>",
        "id": 264814562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459614
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Yes, obviously, the monad that can be defined using a list is useful; however, it is not intuitive related to the concept of a list. That is my point. It may have become that way to you do to your familiarity with functional programming, but someone without that expertise I highly doubt would ever draw that connection (without putting a lot of time in studying it).</p>",
        "id": 264814575,
        "sender_full_name": "Mac",
        "timestamp": 1639459632
    },
    {
        "content": "<p>After you read a monad tutorial this example will not seem that foreign, because it's usually one of the headliners</p>",
        "id": 264814627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459686
    },
    {
        "content": "<p>And yes, I think that users should read a monad tutorial in order to understand lean <code>do</code> notation</p>",
        "id": 264814643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I have used monads extensively  and done a lot of functional programming (and yes I have used the <code>List</code> monad). I still do not find it remotely intuitive. Useful, yes, intuitive no.</p>",
        "id": 264814655,
        "sender_full_name": "Mac",
        "timestamp": 1639459745
    },
    {
        "content": "<p>And given the general perception of Haskell code in the larger programming crowd, I do not think I am alone there.</p>",
        "id": 264814670,
        "sender_full_name": "Mac",
        "timestamp": 1639459779
    },
    {
        "content": "<p>Some monads aren't as crazy as that one, but if you really want to understand how things work you (the generic new lean user) should probably read up on monads</p>",
        "id": 264814732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459828
    },
    {
        "content": "<p>For the most part if you stick to <code>Option</code> and <code>Except</code> it's just error handling</p>",
        "id": 264814766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459892
    },
    {
        "content": "<p>so you learn the patterns for calling a function and throwing or catching</p>",
        "id": 264814773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459917
    },
    {
        "content": "<p>and <code>do act1; act2</code> is one of the patterns</p>",
        "id": 264814815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639459929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I feel like you are rating the simplicity of these concepts much higher than they general are to most people.</p>",
        "id": 264814881,
        "sender_full_name": "Mac",
        "timestamp": 1639460037
    },
    {
        "content": "<p>I'm not saying it's simple, I'm saying that you should front load at least a cursory understanding of monads when learning about lean do notation</p>",
        "id": 264814938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460095
    },
    {
        "content": "<p>You are expecting users to acquire a very high level of understanding of the language before doing serious work. That is just not common in general use.</p>",
        "id": 264814966,
        "sender_full_name": "Mac",
        "timestamp": 1639460134
    },
    {
        "content": "<p>The alternative is to just get by with \"it looks kind of like imperative code\" and \"Option/Except means failure\", and then live with the fact that you might get errors you don't understand (and maybe this will be the trigger to learn more)</p>",
        "id": 264815047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264814938\">said</a>:</p>\n<blockquote>\n<p>I'm saying that you should front load at least a cursory understanding of monads when learning about lean do notation</p>\n</blockquote>\n<p>And I'm saying the great thing about Lean is that you usually don't need to do that. I also saying there is much simpler understanding one can have of monads -- where one treats them just like control flow restrictions -- that requires virtually no understand of the formal concept of a monad at all. That is, use <code>OptionM</code> if your <code>do</code> code can fail, use <code>ExceptM</code> if your do code can <code>throw</code> excpetions, use <code>StateM</code> if there is some state you wish to keep track of, etc.</p>",
        "id": 264815133,
        "sender_full_name": "Mac",
        "timestamp": 1639460345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264815047\">said</a>:</p>\n<blockquote>\n<p>The alternative is to just get by with \"it looks kind of like imperative code\" and \"Option/Except means failure\", and then live with the fact that you might get errors you don't understand (and maybe this will be the trigger to learn more)</p>\n</blockquote>\n<p>The other alternative, which I am advocating (and which Lean currently does), is split the data from the control and then you will never get confusing errors and you can still do serious work without needing to fully understanding the theory behind everything.</p>",
        "id": 264815162,
        "sender_full_name": "Mac",
        "timestamp": 1639460403
    },
    {
        "content": "<p>I keep thinking about the Rust analogue here. <code>Option&lt;T&gt;</code> is just data, and it works with <code>?</code> (the control). I don't understand this \"split the control from the data\" thing since all types classify data. <code>OptionM A</code> is still just data</p>",
        "id": 264815238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264815238\">said</a>:</p>\n<blockquote>\n<p>I keep thinking about the Rust analogue here. <code>Option&lt;T&gt;</code> is just data, and it works with <code>?</code> (the control).</p>\n</blockquote>\n<p><code>?</code> is essentially <code>liftOption</code>/<code>liftExcept</code> in Rust (i.e., it lifts data into control).</p>",
        "id": 264815317,
        "sender_full_name": "Mac",
        "timestamp": 1639460603
    },
    {
        "content": "<p><code>?</code> is lean's <code>&lt;- act</code></p>",
        "id": 264815323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460620
    },
    {
        "content": "<p>There is no lifting involved, it is performing a control flow operation</p>",
        "id": 264815370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264815323\">said</a>:</p>\n<blockquote>\n<p><code>?</code> is lean's <code>&lt;- act</code></p>\n</blockquote>\n<p>How so? In my view, the closest analog to <code>&lt;- act</code> in Lean is <code>act()</code> in Rust.</p>",
        "id": 264815377,
        "sender_full_name": "Mac",
        "timestamp": 1639460699
    },
    {
        "content": "<p>I would say <code>act()</code> is like <code>act</code> and <code>act()?</code> is like <code>&lt;- act</code> or <code>do ... act; ...</code></p>",
        "id": 264815405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460743
    },
    {
        "content": "<p><code>act()</code> in rust doesn't throw</p>",
        "id": 264815455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> How? A function call <code>act()</code> in Rust evaluates to a value and is side-effecting. That is exactly what <code>&lt;- act</code> does in Lean. <code>x?</code> in Rust either evaluates to <code>x</code>'s value or throws its error. Just like <code>&lt;- liftExcept x</code> does in Lean.</p>",
        "id": 264815544,
        "sender_full_name": "Mac",
        "timestamp": 1639460919
    },
    {
        "content": "<p>I'm focusing on the error propagation case in rust, ignoring things like global state and panics so that <code>act()</code> with no arguments is a pure function</p>",
        "id": 264815566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639460966
    },
    {
        "content": "<p>i.e. rust computations that map to <code>Option</code> or <code>Expect</code>, not <code>StateM</code></p>",
        "id": 264815665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639461052
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm not. The whole point is that Rust's functions are <em>im</em>pure (and thus would translate to monadic actions or functions of monadic actions), reducing them to such things would, in my view, be a degenerate case (similar to the ring where <code>0 = 1</code>).</p>",
        "id": 264815677,
        "sender_full_name": "Mac",
        "timestamp": 1639461077
    },
    {
        "content": "<p>Typical lean computations consist mainly of pure functions; those functions would still be pure if transliterated to rust</p>",
        "id": 264815739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639461130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> have you seen the Lean or Lake codebase?</p>",
        "id": 264815755,
        "sender_full_name": "Mac",
        "timestamp": 1639461153
    },
    {
        "content": "<p><span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 264815765,
        "sender_full_name": "Mac",
        "timestamp": 1639461171
    },
    {
        "content": "<p>We are talking about the <code>Option</code> monad here</p>",
        "id": 264815776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639461192
    },
    {
        "content": "<p>yes there are more complicated monads</p>",
        "id": 264815781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639461208
    },
    {
        "content": "<p>I was talking generally about monads and <code>do</code> notation. <code>Option</code> was just an example.</p>",
        "id": 264815783,
        "sender_full_name": "Mac",
        "timestamp": 1639461214
    },
    {
        "content": "<p>For complex monads auto-<code>pure</code> promotion isn't usually a problem</p>",
        "id": 264815838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639461248
    },
    {
        "content": "<p><code>Option</code> is not just an example, it is the primary instance of \"confusing control with data\" that was your original issue</p>",
        "id": 264815852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639461299
    },
    {
        "content": "<p>I don't think there are similar issues with <code>MetaM</code></p>",
        "id": 264815865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639461313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I feel like we are talking at cross paths and have completely different mental models of the topic. I think there should be a separate between control and data and I see monads primary as a control structure that operate on data types. Yes, these controls structures are implemented using the data versions, but they are conceptually distinct. I see <code>do</code> notation as means of writing imperative code which is then translated to its corresponding control structures (i.e., monads). </p>\n<p>I think these concepts should be treated distinctly and not overlap. While data and control can be converted between one another, this should happen explicitly (e.g., through functions <code>mk</code>, <code>run</code>, etc.) not implicitly (through things like pure <code>do</code> notation, merging data and control, or the auto insertion of pure). </p>\n<p>I also believe, and have the experience dealing with students (both when I was an undergrad and now as a teacher) that suggests this  creates less confusion, reduces errors, makes the ones that occur easier to diagnose, and simplifies the concepts for new learners.</p>",
        "id": 264816288,
        "sender_full_name": "Mac",
        "timestamp": 1639461806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Also, I hope I am not coming off as too antagonistic or argumentative. If I do, please alert me so I can tone it down.  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 264816472,
        "sender_full_name": "Mac",
        "timestamp": 1639462043
    },
    {
        "content": "<p>Any convenience feature like coercion is bound to be a tradeoff between ease of learning and ease of use. You mention \"pure do notation, merging data and control, or the auto insertion of pure\" but to me these are in different categories:</p>\n<ul>\n<li>\"merging data and control\", in the sense <code>Option = OptionM</code>, is not a problem in the absence of other coercion features. There are no syntactic or semantic problems that arise, and haskell (and lean 3) show that it is quite feasible to make this work.</li>\n<li>\"pure do notation\" is an instance of coercion, that is, changing one type to another in the face of a type error. Personally I think this is a feature of marginal convenience which can be used to write misleading code (e.g. using pure <code>do</code> to create an <code>Option A</code>), so I'm not sad to see it go.</li>\n<li>\"auto insertion of pure\" is also an instance of coercion, but it's usually not too problematic. But I can imagine code style guides of the future advising to avoid it, and I would avoid it first when diagnosing a type error.</li>\n</ul>\n<p>I can see that it's possible to have none of \"my favorite types\" have monad instances and instead just have dedicated types for everything, but I also don't see any reason to do so. <code>Option</code> and <code>OptionM</code> are the same thing and treating them the same is not misleading, it's a strength of type theory. To beat a rusty horse, why is it that Rust can get away with only one <code>Option&lt;T&gt;</code> type instead of <code>Option</code> and <code>OptionM</code>? It's used for both data (people put <code>Option</code> in data structures) and control (in functions returning <code>Option</code> using the <code>?</code> operator).</p>",
        "id": 264817280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639462991
    },
    {
        "content": "<p>Re: argumentative, I'm fine with it but I think we're nearing saturation here, and we've already generated too much discussion for Leo to make use of. We'll probably just need to agree to disagree.</p>",
        "id": 264817660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639463425
    },
    {
        "content": "<p>Can someone point me to a longer writeup that differentiates data from control? As far as I work, based on what data I have, I choose to do different things, often via casing. Having something like Option Int just tells me that, in python speak, I have a <code>int | None</code> so I better case on it. Similarly with <code>List</code> or <code>Set</code>.</p>",
        "id": 264817686,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639463469
    },
    {
        "content": "<p>I think that's the \"data\" viewpoint</p>",
        "id": 264817703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639463497
    },
    {
        "content": "<p>The \"control\" viewpoint is that <code>OptionM</code> is a monad where you can throw a <code>none</code>-error</p>",
        "id": 264817725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639463519
    },
    {
        "content": "<p>I see, and the <code>none</code> has no value of its own, just as a sentinel value of some sort of behavior that isn't tagged with any additional information. And it's up to the receiver of this <code>none</code> to choose what to do with it?</p>",
        "id": 264817805,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639463600
    },
    {
        "content": "<p>Alternatively, the \"data\" viewpoint is what you get from the constructors and recursor, and the \"control\" viewpoint is what you get from the monad instance</p>",
        "id": 264817808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639463603
    },
    {
        "content": "<p>You wouldn't normally case on a <code>OptionM</code></p>",
        "id": 264817828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639463636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264817725\">said</a>:</p>\n<blockquote>\n<p>The \"control\" viewpoint is that <code>OptionM</code> is a monad where you can throw a <code>none</code>-error</p>\n</blockquote>\n<p>I would say its a type where you  can fail (via <code>failure</code>)</p>",
        "id": 264817896,
        "sender_full_name": "Mac",
        "timestamp": 1639463690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264817280\">said</a>:</p>\n<blockquote>\n<p>I can see that it's possible to have none of \"my favorite types\" have monad instances and instead just have dedicated types for everything, but I also don't see any reason to do so. <code>Option</code> and <code>OptionM</code> are the same thing and treating them the same is not misleading, it's a strength of type theory. To beat a rusty horse, why is it that Rust can get away with only one <code>Option&lt;T&gt;</code> type instead of <code>Option</code> and <code>OptionM</code>? It's used for both data (people put <code>Option</code> in data structures) and control (in functions returning <code>Option</code> using the <code>?</code> operator).</p>\n</blockquote>\n<ol>\n<li>\n<p>\"<code>Option</code> and <code>OptionM</code> are the same thing .\" Not in my in my view. I see <code>Option</code> <code>OptionM</code> as distinct concepts, just as I see a natural number, an integer, and a bitfield as different concepts (even if they can all be represented as a string of bits).</p>\n</li>\n<li>\n<p>On type thoery: its a strength of type theory because type theory is a not a paraconsistent logic and thus wants to keep its number of primitives limited so that it can more easily ensure consistency. This is not a problem in downstream abstractions (like programming) where having a large number of conceptual different (though implementation-equivalent types) is an asset. In fact, having a small number of distinguishable data types is often considered a disadvantage  in programming.</p>\n</li>\n<li>\n<p>On Rust, as stated earlier, I disagree that Rust gets away with both. There is no conceptual distinction between data types used for control and data types used for data in Rust because the former doesn't exist. Control flow is not a first-order concept, it is part of the language. Control flow as data  (e.g., monads) is a concept largely unique to functional programming. Other languages just have data. Such data can include functions (or more precisely, procedures), as a function, by itself, is not control flow -- it is the invoking of the function (and generating its corresponding side effects) that constitutes control flow.</p>\n</li>\n</ol>\n<p>But this is where I guess we have to agree to disagree -- we have kind of got into a bit repetitive back and forth at this point.  <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 264818767,
        "sender_full_name": "Mac",
        "timestamp": 1639464685
    },
    {
        "content": "<p>A practical question related to this - coming from scala, I was a bit puzzled that <code>Option</code> had <code>bind</code> but <code>do</code> did not work. Whatever the deeper reasons, is there any reason to prefer <code>Option</code> to <code>OptionM</code>, or would it be fine to just use <code>OptionM</code> where I would use <code>Option</code> in scala.</p>",
        "id": 264827058,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1639471935
    },
    {
        "content": "<p>I suppose the theorems one would like to use are proved for <code>List</code>, <code>Option</code> etc rather than their mondaic counterparts.</p>",
        "id": 264827254,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1639472047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> <code>OptionM</code> should work fine wherever you want a monad. The Lean core also already has some theorems for monads in <a href=\"https://github.com/leanprover/lean4/blob/26a225e230e41de4c227bd2b51ee2fed304ccf25/src/Init/Control/Lawful.lean\"><code>Init.Control.Lawful</code></a> and one can use <code>simp</code> to easily convert to and from the monadic counterparts, so it shouldn't create too much of hurdle for theorem proving.</p>",
        "id": 264828848,
        "sender_full_name": "Mac",
        "timestamp": 1639472972
    },
    {
        "content": "<p>To chime in with my experience as mainly C++ programmer with a limited experience with functional languages.<br>\nFor a long time I treated <code>do</code> blocks exactly as a way to do imperative programming. I think is an amazing feature that you can write familiar for loops with mutable variables. Only when I started messing with meta programming I was forced to read up on monads a bit more carefully.</p>",
        "id": 264830327,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1639473832
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> Do you feel this is still true with this newest change? I'd say that any introduction to <code>do</code> that does not talk about what the <code>Id.run</code> in <code>Id.run do ...</code> actually <em>means</em> is... questionable. Though even if it just tells you to \"always use <code>Id.run do</code> until we get to the monad chapter\", that <em>still</em> avoids any confusion with a potential <code>Option</code> monad.</p>",
        "id": 264832942,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639475308
    },
    {
        "content": "<p>Ultimately the issue here (to me) seems to come down to two conflicting views of <code>do</code>, one being that it \"should just work like imperative code up to a certain complexity\" and the other that \"users should have to know about what a monad is and what it does to use it properly\"? And both views sound perfectly valid from my point of view, the first one would make writing Lean for newbies easier and force them to take a look at the details later like e.g. <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> described and the second one would force this threshold upon new users but once you get it everything past that is easy. So I'd say it essentially comes down to how the learning curve for Lean 4 should look?</p>",
        "id": 264833873,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639475879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I still do not know how I feel about this change. I didn't switch to the latest version because of this reason(and because some problems with lake).<br>\nI agree that introducing <code>Id.run do</code> without talking what <code>Id.run</code> is really bad. However, the necessity of adding <code>do</code> when you want to just have <code>let mut ...</code> was already a bit hard to swallow and feels a bit like java's <code>public static void main</code>. Being forced to write <code>Id run do</code> is definitely going in the java direction.</p>",
        "id": 264834257,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1639476099
    },
    {
        "content": "<p>For example, I'm still do not fully understand how for loop with mutable variables work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">10</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">i</span>\n  <span class=\"n\">s</span>\n</code></pre></div>\n<p>Inside of the for loop you are in a state monad holding <code>s</code>, right? Why do you need to spell out <code>Id</code> monad explicitly but not the monad in the for loop. Due to my lack of understanding of the inner workings I find this a bit confusing.</p>",
        "id": 264836039,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1639477212
    },
    {
        "content": "<p>Ah, that is a good example. There is nothing \"natural\" about using imperative programming inside a purely functional language, so you should think of (the first) <code>do</code> as entering a \"domain-specific language\". At the second <code>do</code> you are already inside the DSL, so no need to re-specify the monad; it's just part of the <code>for</code> syntax.</p>",
        "id": 264836331,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639477415
    },
    {
        "content": "<p>Good way to think about it! Maybe switching to the python's <code>for i in [0:10]:</code> would remove this confusion. Not sure if I like the look of <code>[0:10]:</code> though. Is it actually necessary to have a trailing symbol like <code>do</code> or <code>:</code> in <code>for</code> notation?</p>",
        "id": 264836789,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1639477651
    },
    {
        "content": "<p>What would the one line version look like?</p>",
        "id": 264863074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639491334
    },
    {
        "content": "<blockquote>\n<p>What would the one line version look like?</p>\n</blockquote>\n<p>What is wrong with: <code>for i in [0:10]  (f i)</code> ?</p>",
        "id": 264864999,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1639492170
    },
    {
        "content": "<p>That won't work without a delimiter. You don't want to apply <code>(f i)</code> to <code>[0:10]</code>.</p>",
        "id": 264865566,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639492367
    },
    {
        "content": "<p>How does it know what the assignment is? The one liner is a strange example because you can just express it purely as a fold, no need for a mut var</p>",
        "id": 264865628,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639492391
    },
    {
        "content": "<p>I'd agree that the <code>do</code> delimiter in the <code>for</code> loop is a bit confusing if you don't already know how to interpret it but a delimiter like <code>:</code> would (to me) feel  out of place as well compared to the rest of the Lean syntax</p>",
        "id": 264866913,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639492847
    },
    {
        "content": "<p>The do in for is not that confusing if you know the other confusing use of do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">7</span>\n  <span class=\"k\">do</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n     <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">3</span>\n  <span class=\"n\">pure</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 264869005,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639493643
    },
    {
        "content": "<p>Note that <code>do x</code> is of course completely different than <code>(do x)</code>. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 264869084,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639493675
    },
    {
        "content": "<p>Hm, I had absolutely no idea that <code>do</code>'s could have different semantics. And I suspect this is not very good from a standpoint of programming languages design (taking the fact that I was surprised by it, for instance).<br>\nI was approaching <code>do</code>'s with the same spirit that Tomas pointed out: telling Lean that I wanted to use mutable variables in a more imperative style. Would it be too radical to propose different keywords for such usages of <code>do</code>?</p>",
        "id": 264869111,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639493688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264869005\">said</a>:</p>\n<blockquote>\n<p>The do in for is not that confusing if you know the other confusing use of do:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">7</span>\n  <span class=\"k\">do</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n     <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">3</span>\n  <span class=\"n\">pure</span> <span class=\"n\">x</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>isn't the do here just a noop?</p>",
        "id": 264869260,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639493754
    },
    {
        "content": "<p>At least the result is just 24 as I would expect if the do wasnt there...</p>",
        "id": 264869396,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639493803
    },
    {
        "content": "<p>Yes, it doesn't do anything.  The interesting thing is that is expanded into the parent do, so you can assign variables etc., which you couldn't do if that do was a term.</p>",
        "id": 264869400,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639493804
    },
    {
        "content": "<p>I approached <code>do</code> like Haskell <code>do</code> but with <code>mut</code> and <code>for</code> + a bit more implicit stuff and that has worked quite well so far.</p>",
        "id": 264869643,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639493886
    },
    {
        "content": "<p>it's not completely a no-op, right? I would expect that it is a scope, so that <code>let y := 37</code> inside the inner <code>do</code> is no longer valid outside it</p>",
        "id": 264870066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639494028
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">7</span>\n  <span class=\"k\">do</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n     <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">3</span>\n     <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><span aria-label=\"smirk\" class=\"emoji emoji-1f60f\" role=\"img\" title=\"smirk\">:smirk:</span></p>",
        "id": 264870199,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639494080
    },
    {
        "content": "<p>A noop indeed, the wonders of <code>do</code>.</p>",
        "id": 264870228,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639494091
    },
    {
        "content": "<p>maybe it should be called <code>don't</code></p>",
        "id": 264870297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639494115
    },
    {
        "content": "<p>Maybe we could make the distinction between monadic <code>do</code> and pure <code>do</code> notation both more apparent and easy to understand if we have something like an <code>imp</code> (as in imperative) keyword that desugars to <code>Id.run do</code>. That way the new users don't have to care about <code>Id.run do</code> but the pure and impure do blocks are still clearly different.</p>",
        "id": 264870724,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639494265
    },
    {
        "content": "<p>that was already proposed in the GH issue under the name <code>puredo</code></p>",
        "id": 264870813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639494301
    },
    {
        "content": "<p>(In case anybody with commit access is reading this: please don't remove or neuter the nested do, it's useful when you're writing doElem-macros.  Though renaming it might reduce the confusion.)</p>",
        "id": 264870857,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639494318
    },
    {
        "content": "<p>For macro use it could be renamed to <code>do%</code> or something</p>",
        "id": 264870990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639494373
    },
    {
        "content": "<p>but I'm in no hurry to change anything here. It's mostly just a useless oddity</p>",
        "id": 264871063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639494411
    },
    {
        "content": "<p>On weird error messages, this one used to say something along the lines of \"can't use &lt;- outside of a do\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myFun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>Now it underlines the <code>←</code> in red and says <code>expected '|'</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 264871227,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639494484
    },
    {
        "content": "<p>That error message is technically correct, although it should probably say \"... <code>or ':='</code>\"</p>",
        "id": 264871451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639494574
    },
    {
        "content": "<p><code>:=</code> indeed works, but <code>|</code> seems to require a bit more gymnastic (which I still couldn't figure out)</p>",
        "id": 264871862,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639494731
    },
    {
        "content": "<p>it's talking about definitions like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">q</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"n\">q</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 264871952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639494775
    },
    {
        "content": "<p>Taking a different direction to understand the use of <code>monoids</code>, <code>do</code> and such. </p>\n<p>Is there a way to just draw the Abstract Syntax Tree with the type annotations so that it could be understood that way?</p>",
        "id": 264872353,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1639494952
    },
    {
        "content": "<p>Ah, then Lean was expecting me to define a function <code>q</code>? That's way off of what I wanted to do. I just wanted to point out that I preferred the previous message talking about the impossibility of using <code>←</code></p>",
        "id": 264872436,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639494972
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366057\">@Eric Taucher</span>  The easiest way to get a sense for how do compilation works is to <code>#print</code> the examples</p>",
        "id": 264872637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639495072
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> Yes, it would make sense to add <code>let x &lt;- t; e</code> to the grammar just for the purpose of better error messages</p>",
        "id": 264872816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639495130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span>  The error message hasn't changed, you're mixing this up with <code>let q := ← 10</code> which did and still gives the helpful error message.</p>",
        "id": 264872832,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639495139
    },
    {
        "content": "<p>Oh, thanks!</p>",
        "id": 264873174,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639495268
    },
    {
        "content": "<p>I've created <a href=\"https://github.com/leanprover/lean4/issues/874\">this issue</a> as proposed by Leo</p>",
        "id": 264876317,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639496463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264872637\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"366057\">Eric Taucher</span>  The easiest way to get a sense for how do compilation works is to <code>#print</code> the examples</p>\n</blockquote>\n<p>Yes it works quite well, but it failed me when I tried to figure out what is the inferred monad in <code>ForIn</code> when you write the simple for loop with a mutable variable.</p>\n<p>I still do not know what that monad is and I want to find out :)</p>",
        "id": 264876359,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1639496482
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> The monad doesn't actually change. Instead, the body of the for loop is compiled to something like <code>a -&gt; m a</code> and passed to the <code>ForIn</code> function</p>",
        "id": 264876736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639496650
    },
    {
        "content": "<p>Haskell Wiki's type class o pedia goes into some nice detail about the type classes that are around in Lean (and also some that arent yet) <a href=\"https://wiki.haskell.org/Typeclassopedia\">https://wiki.haskell.org/Typeclassopedia</a></p>\n<p>The quick explanation is  that it's \"just\" a type with two operations (<code>pure</code> aka <code>return</code> and <code>bind</code> aka <code>&gt;&gt;=</code> plus a resulting sequence operation aka <code>&gt;&gt;</code>) which you can compose to get lots of interesting behaviour</p>\n<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span></p>",
        "id": 264876759,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639496660
    },
    {
        "content": "<p>(it's a little more complicated than that because you can also early return from a for loop and the monad result reflects this)</p>",
        "id": 264876814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639496687
    },
    {
        "content": "<p>The type <code>a</code> in the <code>forIn</code> depends on what <code>let mut</code> are in scope and changed in the loop</p>",
        "id": 264876918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639496744
    },
    {
        "content": "<p>It looks like I was thinking about <code>ForIn</code> with mutable variables in an incorrect way. My expectation was that it creates <code>StateM</code> with mutable variables as the state.</p>",
        "id": 264877255,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1639496868
    },
    {
        "content": "<p>There are some parts of the inner function of a <code>forIn</code> that could be represented with a monad transformer, but it would mess up type inference inside the block to actually change the monad, because it is an implementation detail, the user still wants to be in whatever monad they were in to begin with</p>",
        "id": 264877638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639497036
    },
    {
        "content": "<p>Plus, it is more flexible for the compiler to just thread the arguments around rather than using some <code>getRef</code> and <code>setRef</code> stuff</p>",
        "id": 264877908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639497137
    },
    {
        "content": "<p>(this is roughly analogous to how LLVM prefers all its variables to be in SSA registers rather than memory)</p>",
        "id": 264878005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639497184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264871227\">said</a>:</p>\n<blockquote>\n<p>On weird error messages, this one used to say something along the lines of \"can't use &lt;- outside of a do\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myFun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>Now it underlines the <code>←</code> in red and says <code>expected '|'</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>Pushed a fix for this issue. It now produces <code>expected ':=' or '|'</code>.</p>",
        "id": 264888800,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639501161
    },
    {
        "content": "<p>I've closed <a href=\"https://github.com/leanprover/lean4/issues/874\">this issue</a> then</p>",
        "id": 264891923,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639502163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264891923\">said</a>:</p>\n<blockquote>\n<p>I've closed <a href=\"https://github.com/leanprover/lean4/issues/874\">this issue</a> then</p>\n</blockquote>\n<p>Thanks.</p>",
        "id": 264892329,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1639502290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264834257\">said</a>:</p>\n<blockquote>\n<p>I agree that introducing <code>Id.run do</code> without talking what <code>Id.run</code> is really bad. However, the necessity of adding <code>do</code> when you want to just have <code>let mut ...</code> was already a bit hard to swallow and feels a bit like java's <code>public static void main</code>. </p>\n</blockquote>\n<p>I like to think of <code>Id.run do ...</code> as run the following imperative code in a pure context (no external state / no side effects). <code>OptionM.run do ...</code> then adds the ability to fail as a side effect, <code>StateM.run s do ....</code> adds some state, etc. I do think name <code>Id</code> is a little opaque to new users -- I would prefer something like <code>PureM</code> instead. A keyword like <code>pure_do</code> could also work, though I think special case syntax sugar just makes it hard to intuit how to swap in other monads like <code>OptionM</code> when you want a less than pure context. </p>\n<p>On the <code>let mut ...</code> note, I agree that it is very verbose. I would suggest using <code>var</code> as the keyword instead.</p>",
        "id": 264901055,
        "sender_full_name": "Mac",
        "timestamp": 1639505504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264814319\">said</a>:</p>\n<blockquote>\n<p>what is the natural connection between the concept of a list and the concept of nondeterminism???</p>\n</blockquote>\n<p>A small digression: When I was learning Haskell, at some point I thought it would be interesting to try and implement some concepts from SICP. One project is the <code>amb</code> (\"ambivalence\") operator, which lets you do backtracking search, and after a couple hours of experimentation writing a monad for this and then simplifying what I had, I realized after all that the algebraic data type I got was just List with a crudely written bind operator.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">data</span> <span class=\"n\">Amb</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Choose</span> <span class=\"o\">{</span> <span class=\"n\">choice</span> <span class=\"o\">::</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">failure</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">Amb</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"bp\">|</span> <span class=\"n\">Failed</span>\n</code></pre></div>\n<p>This in some way relies on laziness, though, and it's probably better to think of it as being a <em>co</em>inductive type (well, unless you want to make sure an <code>Amb</code> computation does indeed eventually end in <code>Failed</code> if you keep backtracking).  The <code>failure</code> case is not supposed to be evaluated unless you need it -- it's meant to be the continuation for backtracking.</p>\n<p>I wasn't originally sharing this to make any particular point, but I guess I hadn't really appreciated how Lean's list monad is more eager than you'd want for this application, so it's not so useful for nondeterminism when you want <em>some</em> answer instead of <em>all</em> answers.  (The list monad is still great for list comprehensions, though.)</p>",
        "id": 264914896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1639511069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Has.20the.20do.20notation.20changed.20recently.3F/near/264901055\">said</a>:</p>\n<blockquote>\n<p>On the <code>let mut ...</code> note, I agree that it is very verbose. I would suggest using <code>var</code> as the keyword instead.</p>\n</blockquote>\n<p>I second that. Or simply <code>mut</code> instead of <code>let mut</code></p>",
        "id": 264926776,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1639516675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> just to clarify, my point wasn't that the connection didn't exist, but that the connection is not intuitive and it is largely just a result of the fact that they happen to share the same structure / representation than there being any real  conceptually connection. </p>\n<p>It is kind of like Frege's distinction between \"sense\" and \"reference\". Just because two concepts have the same representation (the same \"referent\" in the analogy) doesn't mean they are the same concept (are used in the same \"sense\"). </p>\n<p>One example of this in Lean already is the distinction between <code>Sum</code> and <code>Except</code>. In Haskell, these are both <code>Either</code> but in Lean they are distinct because <code>Sum</code> does not come with  a strict connotation of one side being an error and the other side being a value whereas <code>Except</code> does impose that distinction.</p>",
        "id": 264944449,
        "sender_full_name": "Mac",
        "timestamp": 1639524688
    }
]
[
    {
        "content": "<p>Hey everyone,</p>\n<p>I'm currently trying to typecheck inputs of a heterogeneous nested list (eventually I want to extend it to more than just Nat and Char). The goal is that the following typechecks:<br>\n[['A', 2, 5, 'T'],<br>\n['B', 100, 7, 'X']]<br>\nand not the following:<br>\n[['A' 2, 5, 'T'],<br>\n[100, 'B', 7]]<br>\nConsidering the sequence of the types and the length of the sublists.</p>\n<p>The typechecking works when providing a proof h with Or and simp can solve the goal.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">NTup</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">NTup</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">αs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">NTup</span> <span class=\"n\">αs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">Char</span> <span class=\"bp\">∨</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NTup</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">::</span> <span class=\"n\">αs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">NTup</span> <span class=\"o\">[</span><span class=\"n\">Char</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">NTup.cons</span> <span class=\"sc\">'a'</span> <span class=\"n\">NTup.nil</span>\n</code></pre></div>\n<p>according to the simp trace the theorems \"eq_self\" and \"true_or\" are used for the goal.</p>\n<p>In order to match and extract the values of the hypothesis I wanted to use PSum:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsValidSqlType</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"bp\">⊕'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myCast</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsValidSqlType</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A.char</span> <span class=\"bp\">$</span> <span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A.nat</span> <span class=\"bp\">$</span> <span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>When changing NTup to use PSum instead of Or, simp is not able to solve it. Even when giving it the theorems: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">true_psum</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"bp\">⊕'</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">True.intro</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">psum_true</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">⊕'</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">True.intro</span>\n</code></pre></div>\n<p>(eq_self remains in scope)<br>\nsimp cannot solve it anymore. <br>\nIs simp applying any other theorems in the background that I don't see via \"set_option trace.Meta.Tactic.simp true\"?<br>\nAnd also is there a better approach for typechecking a list of unique types?</p>",
        "id": 276888895,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1648480681
    },
    {
        "content": "<p>For a nice implementation of heterogeneous lists, you can look at: <a href=\"https://github.com/crabbo-rave/Soup\">https://github.com/crabbo-rave/Soup</a> made by <span class=\"user-mention\" data-user-id=\"467926\">@Joseph O</span> which seems to be using essentialy the same approach you are going for (except for the <code>Nat</code> or <code>Char</code> restriction)</p>",
        "id": 276895646,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1648483655
    },
    {
        "content": "<p>Also, I think it's not clear what <code>A</code> is in your second example, thus people may have a harder time helping you. I guess it's a form of a sum between <code>Nat</code> and <code>Char</code>?</p>",
        "id": 276896822,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1648484190
    },
    {
        "content": "<p>Thank you for your answer Horatiu. <br>\nYes indeed. A would be something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">Char</span> <span class=\"bp\">→</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>and is only included to show my need of getting actual values from NTup. And my question is considering the  Nat or Char restriction that I want to eventually extend to Nat or Char or ...<br>\nSo my usecase is different from <a href=\"https://github.com/crabbo-rave/Soup\">https://github.com/crabbo-rave/Soup</a>.</p>",
        "id": 276899516,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1648485333
    },
    {
        "content": "<p>If you are only interested in some types, couldn't you simply use <code>List (Nat ⊕ Char)</code>? Maybe with other types the sum, or even your own inductive type for all the possible values if there are many of them (like you did with <code>A</code>)?</p>",
        "id": 276900383,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1648485659
    },
    {
        "content": "<p>Bit of an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> but whenever you want to consider a specific subset ('universe') of types, I would make a syntactic representation of this subset and work with that (which is also basically what Horatiu suggests):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Univ</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">char</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Univ.interp</span> <span class=\"o\">:</span> <span class=\"n\">Univ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">char</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Char</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Tuple</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Univ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">u.interp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"n\">us</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">::</span> <span class=\"n\">us</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tuple.uncons</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">::</span> <span class=\"n\">us</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">u.interp</span> <span class=\"bp\">×</span> <span class=\"n\">Tuple</span> <span class=\"n\">us</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Tuple.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Prepare for universe issues, btw, if you ever need to go higher than <code>Type</code>.</p>",
        "id": 276900758,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1648485820
    },
    {
        "content": "<p>The main issue is that equality between types doesn't behave as you expect. There is no real guarantee that Nat and Char are not the same! In fact, in the cardinal model, two types are equal iff they have the same cardinality.</p>",
        "id": 276900966,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1648485911
    },
    {
        "content": "<p>In the CPDT book, Adam Chlipala uses heterogeneous lists that are still general and relevant to this discussion. We have recently translated some of his examples to Lean 4. Here is one of the examples.<br>\n<a href=\"https://leanprover.github.io/lean4/doc/examples/deBruijn.lean.html\">https://leanprover.github.io/lean4/doc/examples/deBruijn.lean.html</a></p>",
        "id": 276908185,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648489284
    },
    {
        "content": "<p>In the standard <code>HList</code> definition, we have the \"universe bump\" that has been mentioned in many threads.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">HList</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- &lt;&lt; we need the \"+1\" here because Lean does not have pseudo parameters</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"n\">αs</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">::</span><span class=\"n\">αs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Chlipala's version does not have this bump.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">HList</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"n\">β</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"n\">β</span> <span class=\"n\">is</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">::</span><span class=\"n\">is</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The <code>Tuple</code> example above is just <code>HList Univ.interp</code>, and we can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">Tuple</span> <span class=\"o\">:=</span> <span class=\"n\">HList</span> <span class=\"n\">Univ.interp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tuple.uncons</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">::</span> <span class=\"n\">us</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">u.interp</span> <span class=\"bp\">×</span> <span class=\"n\">Tuple</span> <span class=\"n\">us</span>\n  <span class=\"bp\">|</span> <span class=\"n\">HList.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 276909378,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648489977
    },
    {
        "content": "<p>Are there advantages of this definition over the other? So of leaving out the universe bump in exchange for this approach?</p>",
        "id": 276910444,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1648490533
    },
    {
        "content": "<p>Yes, it avoids the universe bump. It also has the benefits that <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> suggested above. We can view Chlipala's <code>HList</code> as a generic version of Jannis' <code>Tuple</code>example where he used elements of type <code>Univ</code> to index the <code>Tuple</code> instead of <code>Type</code>. Another plus is that we can pattern match on <code>Univ</code>, but we cannot on <code>Type</code>.</p>",
        "id": 276911405,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648491037
    },
    {
        "content": "<p>Thank you for your answers! This was indeed what I was looking for and helped me a lot to understand more about HLists. When experimenting I found that in this instance Lean cannot infer types here and thus they have to be specified:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">[</span><span class=\"n\">Univ.char</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Tuple.cons</span> <span class=\"sc\">'c'</span> <span class=\"n\">Tuple.nil</span>\n</code></pre></div>\n<p>I tried to work around that by creating a macro (very similar to the one List uses) and can provide the types with pattern matching.</p>\n<p>For testing I hardcoded the base case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">sqlType</span>\n<span class=\"n\">syntax</span> <span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">sqlType</span>\n<span class=\"n\">syntax</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">sqlType</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"tuple(\"</span> <span class=\"n\">sqlType</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\")\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tuple</span><span class=\"o\">(</span> <span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">expandListLit</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">skip</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">result</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lean.MacroM</span> <span class=\"n\">Lean.Syntax</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n      <span class=\"k\">match</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">skip</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span>   <span class=\"n\">_</span>     <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">result</span>\n      <span class=\"bp\">|</span> <span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">true</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">expandListLit</span> <span class=\"n\">i</span> <span class=\"n\">false</span> <span class=\"n\">result</span>\n      <span class=\"bp\">|</span> <span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">elems.elemsAndSeps</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">sqlType</span><span class=\"bp\">|$</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">charLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">expandListLit</span> <span class=\"n\">i</span> <span class=\"n\">true</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">``</span><span class=\"o\">((</span><span class=\"n\">Tuple.cons</span> <span class=\"bp\">$</span><span class=\"n\">c</span> <span class=\"bp\">$</span><span class=\"n\">result</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">[</span><span class=\"n\">Univ.char</span><span class=\"o\">])))</span> <span class=\"c1\">-- Hardcoded for char</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">sqlType</span><span class=\"bp\">|$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">numLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">expandListLit</span> <span class=\"n\">i</span> <span class=\"n\">true</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">``</span><span class=\"o\">((</span><span class=\"n\">Tuple.cons</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">result</span> <span class=\"o\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">[</span><span class=\"n\">Univ.nat</span><span class=\"o\">])))</span> <span class=\"c1\">-- Hardcoded for nat</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">expandListLit</span> <span class=\"n\">i</span> <span class=\"n\">true</span>  <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">Tuple.cons</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">elems.elemsAndSeps</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span> <span class=\"bp\">$</span><span class=\"n\">result</span><span class=\"o\">))</span>\n    <span class=\"k\">if</span> <span class=\"n\">elems.elemsAndSeps.size</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">64</span> <span class=\"k\">then</span>\n      <span class=\"n\">expandListLit</span> <span class=\"n\">elems.elemsAndSeps.size</span> <span class=\"n\">false</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">Tuple.nil</span><span class=\"o\">))</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">%</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">Tuple.nil</span> <span class=\"o\">])</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">tuple</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- Has correct type</span>\n<span class=\"k\">#check</span> <span class=\"n\">tuple</span><span class=\"o\">(</span><span class=\"sc\">'c'</span><span class=\"o\">)</span> <span class=\"c1\">-- Has correct type</span>\n<span class=\"k\">#check</span> <span class=\"n\">tuple</span><span class=\"o\">(</span><span class=\"sc\">'c'</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- Not case provided yet</span>\n</code></pre></div>\n<p>However for the n+1 case I'm struggling to read and extend the the type of the \"$results\" macro.</p>\n<p>Now I'm wondering if there's a way for Lean to infer the type in the first place (whether or not this is reasonable for HLists) and/or if the macro can be extended to determine the type for n+1 elements.</p>",
        "id": 278359555,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1649450510
    }
]
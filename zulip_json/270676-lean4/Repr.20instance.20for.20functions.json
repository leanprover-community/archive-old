[
    {
        "content": "<p>I have an inductive type for programs with algebraic effects. I'd like to define a <code>Repr</code> instance for it that would more or less print it verbatim like <code>#reduce</code> does, and allow me to use the type with <code>#eval</code>. I have some tests that make <code>whnf</code> timeout and I'd like to study them with <code>#eval</code>, which apparently is a much faster VM.</p>\n<p>The type looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Program</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Return</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">):</span> <span class=\"n\">Program</span> <span class=\"n\">E</span> <span class=\"n\">R</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Effect</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Program</span> <span class=\"n\">E</span> <span class=\"n\">R</span><span class=\"o\">):</span> <span class=\"n\">Program</span> <span class=\"n\">E</span> <span class=\"n\">R</span>\n</code></pre></div>\n<p>I've been trying (unsuccessfully) to take as parameter a <code>Repr</code> instance on <code>E</code> (more specifically on <code>E T</code> for any <code>T</code>), and to have the continuation function printed as a Lean term. I can write <code>[∀ T, Repr (E T)]</code> as parameter, but I don't know how fragile it is nor how to actually define such an instance.</p>\n<p>What would be the proper way to approach this problem? I'm not even sure I can print functions at all, which has me slightly worried.</p>",
        "id": 276480271,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1648130932
    },
    {
        "content": "<p>You probably want to just write a separate <code>Repr</code>/<code>ToString</code> instance instead of trying to put instance parameters on the inductive itself. There's no technical limitation that prevents you from printing functions, but I think in general it's going to be up to you to figure out how to display your function as a string in a way that makes sense. A function on lists might make sense in some context when displayed as <code>f []</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{f []}\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So it looks like you would need to figure that out for <code>T -&gt; Program E R</code>.</p>",
        "id": 276497156,
        "sender_full_name": "Chris B",
        "timestamp": 1648137568
    },
    {
        "content": "<p>Ah yeah, you do have a little bit of a problem with that <code>T</code> constructor arg though.</p>",
        "id": 276498697,
        "sender_full_name": "Chris B",
        "timestamp": 1648138100
    },
    {
        "content": "<p>Thank you. The functions in <code>Effect</code> are quite arbitrary, and I wish to print the underlying term. I'm not sure how much introspection is needed for this, although I suspect a VM might compile/simplify the term for performance reasons and get rid of what I want to print (?).</p>",
        "id": 276498918,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1648138199
    },
    {
        "content": "<p>Some inspiration maybe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Program</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Return</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">):</span> <span class=\"n\">Program</span> <span class=\"n\">E</span> <span class=\"n\">R</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Effect</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Program</span> <span class=\"n\">E</span> <span class=\"n\">R</span><span class=\"o\">):</span> <span class=\"n\">Program</span> <span class=\"n\">E</span> <span class=\"n\">R</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">showProgram</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">T</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Program</span> <span class=\"n\">E</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"n\">Program.Return</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">Program.Effect</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">T</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">k'</span> <span class=\"o\">:=</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Inhabited.default</span> <span class=\"n\">T</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"o\">:=</span> <span class=\"n\">showProgram</span> <span class=\"n\">k'</span>\n  <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{e}, {p'}\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"n\">o</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">o</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"none\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"some\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Program</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Program.Return</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Program</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Program.Effect</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"sc\">'a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"n\">showProgram</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 276500221,
        "sender_full_name": "Chris B",
        "timestamp": 1648138676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484617\">Sébastien Michelland</span> <a href=\"#narrow/stream/270676-lean4/topic/Repr.20instance.20for.20functions/near/276498918\">said</a>:</p>\n<blockquote>\n<p>Thank you. The functions in <code>Effect</code> are quite arbitrary, and I wish to print the underlying term. I'm not sure how much introspection is needed for this, although I suspect a VM might compile/simplify the term for performance reasons and get rid of what I want to print (?).</p>\n</blockquote>\n<p>Yes, the original term is gone at run time</p>",
        "id": 276500387,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1648138738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/270676-lean4/topic/Repr.20instance.20for.20functions/near/276500221\">said</a>:</p>\n<blockquote>\n<p>Some inspiration maybe</p>\n</blockquote>\n<p>Thanks. It's not a bad compromise, but since most of the program logic is in the functions, an evaluation is probably not going to be enough for debugging.</p>\n<p>I guess there is some XY going on there. Since the terms are gone at runtime and I want to print them, I don't really have a choice but to test with the kernel with <code>#reduce</code>. So maybe I should look first at why it timeouts. I tracked it down to a mutual definition (one that <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/nestedInductiveRecType.lean#L77-L88\">wrote for me the other day</a>) and according to <a href=\"#narrow/stream/270676-lean4/topic/Strange.20stack.20overflow.20.2F.20timeout\">this post</a> reducing anything with proofs inside is likely to lead to such problems (the proofs being some subterms related to the well-founded definition, I understand). Is there a way to work around this?</p>",
        "id": 276502121,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1648139414
    },
    {
        "content": "<p>You likely want the following TODO implemented so you can turn on <code>skipProofs</code> <a href=\"https://github.com/leanprover/lean4/blob/be7c71d1c8037a3a9aaa03b0f7d81259bb856712/src/Lean/Elab/BuiltinCommand.lean#L238-L240\">https://github.com/leanprover/lean4/blob/be7c71d1c8037a3a9aaa03b0f7d81259bb856712/src/Lean/Elab/BuiltinCommand.lean#L238-L240</a></p>",
        "id": 276502667,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1648139621
    },
    {
        "content": "<p>Customizing such smaller commands is relatively simple in Lean 4, here is a quick sketch that you can give a try:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Command</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Meta</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#reduce \"</span> <span class=\"n\">skipProofs</span><span class=\"o\">:</span><span class=\"n\">group</span><span class=\"o\">(</span><span class=\"n\">atomic</span><span class=\"o\">(</span><span class=\"s2\">\"(\"</span> <span class=\"bp\">&amp;</span><span class=\"s2\">\"skipProofs\"</span><span class=\"o\">)</span> <span class=\"s2\">\" := \"</span> <span class=\"o\">(</span><span class=\"n\">trueVal</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">falseVal</span><span class=\"o\">)</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">skipProofs</span> <span class=\"o\">:=</span> <span class=\"n\">skipProofs</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span> <span class=\"bp\">``</span><span class=\"n\">trueVal</span>\n  <span class=\"n\">withoutModifyingEnv</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">runTermElabM</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">`</span><span class=\"n\">_check</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"n\">term</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">term</span> <span class=\"n\">none</span>\n    <span class=\"n\">Term.synthesizeSyntheticMVarsNoPostponing</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Term.levelMVarToParam</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- TODO: add options or notation for setting the following parameters</span>\n    <span class=\"n\">withTheReader</span> <span class=\"n\">Core.Context</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ctx</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">ctx</span> <span class=\"k\">with</span> <span class=\"n\">options</span> <span class=\"o\">:=</span> <span class=\"n\">ctx.options.setBool</span> <span class=\"bp\">`</span><span class=\"n\">smartUnfolding</span> <span class=\"n\">false</span> <span class=\"o\">})</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">withTransparency</span> <span class=\"o\">(</span><span class=\"n\">mode</span> <span class=\"o\">:=</span> <span class=\"n\">TransparencyMode.all</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">reduce</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">skipProofs</span> <span class=\"o\">:=</span> <span class=\"n\">skipProofs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">skipTypes</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">e</span>\n\n<span class=\"k\">#reduce</span> <span class=\"o\">(</span><span class=\"n\">skipProofs</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">id</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 276504682,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1648140320
    },
    {
        "content": "<p>Excellent! I was setting up a Lean build to give it a try, but it's just as easy like this. Thanks again ^^</p>\n<p>My terms can reduce properly now (fairly quickly too), so these proofs were indeed the problem. The result doesn't look nearly as clean as I expected (800 lines for a trivial program xD), I suspect there are some non-computable/non-reducible stuff left in my theory. Sounds like a different problem though!</p>",
        "id": 276505949,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1648140798
    }
]
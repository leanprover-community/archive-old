[
    {
        "content": "<p>I was writing some code that tried to map on a list haskell style like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">7</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>and my Lean complains that List has no Functor instance? Is this correct? If so why doesn't it have one it seems like a rather trivial instance to me.</p>",
        "id": 261700339,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1637093665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>  The <code>Functor</code>/<code>Applicative</code>/<code>Monad</code> classes in Lean are considered control flow classes for control types like <code>OptionM</code>/<code>ExceptM</code>/etc. Data types (like <code>Option</code>/<code>Except</code>/<code>List</code>) do not implement them (to prevent them two from being confused). This allows for much better type inference and predictable behavior in the <code>do</code> notation.</p>",
        "id": 261736966,
        "sender_full_name": "Mac",
        "timestamp": 1637116505
    },
    {
        "content": "<p>There is a decent argument, though, that <code>Functor</code> should not be included in this (or there should be a data version), since <code>map</code> is  used quote often in pure programming..</p>",
        "id": 261737063,
        "sender_full_name": "Mac",
        "timestamp": 1637116612
    },
    {
        "content": "<p>The regular <code>Option</code> type does already seem to implement <code>Functor</code>: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44\">https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44</a> so I guess it would be valid to just do it for <code>List</code> as well in this case?</p>",
        "id": 261751027,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1637134211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/261736966\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span>  The <code>Functor</code>/<code>Applicative</code>/<code>Monad</code> classes in Lean are considered control flow classes for control types like <code>OptionM</code>/<code>ExceptM</code>/etc. Data types (like <code>Option</code>/<code>Except</code>/<code>List</code>) do not implement them (to prevent the two from being confused). This allows for much better type inference and predictable behavior in the <code>do</code> notation.</p>\n</blockquote>\n<p>My 2c: <code>List Option</code> is a great model for a continuation-passing-style computation.</p>\n<p>One of the bigger \"patterns\" in ML-style FP is the pattern of describing a computation in one place (and in composable manner) and running it in another. List is a great, albeit a little bit primitive, way to describe computations.</p>",
        "id": 290365781,
        "sender_full_name": "cognivore",
        "timestamp": 1658404574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/261751027\">said</a>:</p>\n<blockquote>\n<p>The regular <code>Option</code> type does already seem to implement <code>Functor</code>: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44\">https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44</a> so I guess it would be valid to just do it for <code>List</code> as well in this case?</p>\n</blockquote>\n<p>Yes, <code>Option</code> implements <code>Monad</code> at master. <code>OptionM</code> is gone. See discussion at <a href=\"#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084</a><br>\nRegarding <code>Monad List</code>, it would be great to have more feedback from our user base because Lean is a strict language.</p>",
        "id": 290368765,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1658406545
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Regarding <code>Functor List</code>, please feel free to submit a PR.</p>",
        "id": 290369129,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1658406767
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/1338/files\">https://github.com/leanprover/lean4/pull/1338/files</a></p>",
        "id": 290370886,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658407755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/290368765\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/261751027\">said</a>:</p>\n<blockquote>\n<p>The regular <code>Option</code> type does already seem to implement <code>Functor</code>: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44\">https://github.com/leanprover/lean4/blob/master/src/Init/Data/Option/Basic.lean#L43-L44</a> so I guess it would be valid to just do it for <code>List</code> as well in this case?</p>\n</blockquote>\n<p>Yes, <code>Option</code> implements <code>Monad</code> at master. <code>OptionM</code> is gone. See discussion at <a href=\"#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Do.20we.20still.20need.20OptionM.3F/near/279761084</a><br>\nRegarding <code>Monad List</code>, it would be great to have more feedback from our user base because Lean is a strict language.</p>\n</blockquote>\n<p>The one advantage of having <code>Monad List</code> (as with <code>Monad Option</code>) is that this is a familiar type and gives a very good example of Monads for a mathematical audience for whom meta-programming examples may be too complex (and encoding effects may seem artificial).</p>\n<p>I am just saying this as an argument in one direction -- arguments the other way may be stronger.</p>",
        "id": 290373368,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1658409153
    },
    {
        "content": "<p>The issue with <code>Monad List</code> is not that <code>List</code> isn't a monad / acts as an example monad, but rather that it has completely different strictness behavior than it does in e.g. Haskell which makes it unsuitable for use as a \"nondeterminism\" monad</p>",
        "id": 290383219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658413980
    },
    {
        "content": "<p>and giving it a monad structure could result in unexpected results for folks expecting the haskell behavior</p>",
        "id": 290383301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658414029
    },
    {
        "content": "<blockquote>\n<p>rather that it has completely different strictness behavior than it does in e.g. Haskell</p>\n</blockquote>\n<p>I'm not sure I understand this part.  The only time the strictness differs is if you only look at, say, the first element (<code>head (do { x &lt;- [1..10^10]; pure (x+1) })</code>).  That doesn't work in Lean because the resulting list is evaluated strictly, <em>like every other list in Lean</em>.  If you do <code>println do ...</code> then both Haskell and Lean behave the same AFAICT.</p>",
        "id": 290392474,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1658417972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/290383219\">said</a>:</p>\n<blockquote>\n<p>The issue with <code>Monad List</code> is not that <code>List</code> isn't a monad / acts as an example monad, but rather that it has completely different strictness behavior than it does in e.g. Haskell which makes it unsuitable for use as a \"nondeterminism\" monad</p>\n</blockquote>\n<p>One can safely assume that those who \"expect Haskell behaviour\" are rather skilled. On the other hand mathematicians knowing not much programming can use a simple example of a Monad.</p>",
        "id": 290398682,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1658420524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I think the order of evaluation of the bind functions is also different, although possibly this is not observable since we would only be able to use non-monadic functions in this situation</p>",
        "id": 290399266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658420780
    },
    {
        "content": "<p>Okay, that seems plausible.  But \"does the same pure computations only in an unexpected order\" is a rather weak argument against <code>Monad List</code> though.</p>",
        "id": 290399602,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1658420909
    },
    {
        "content": "<p>In my eyes, the only good argument against <code>Monad List</code> and <code>Monad Array</code> is that they have subpar performance (compared to <code>Monad DList</code> and <code>Monad DArray</code>).  But that is also true of the Haskell version if you don't have stream fusion.</p>",
        "id": 290401788,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1658421896
    },
    {
        "content": "<p>One reason for <code>Monad List</code> is that it's the basis for list comprehensions, which many strict languages (like Python) have. Python for example also has generator comprehensions for the lazy version, so it's possible for practitioners to be able to handle strictness issues.</p>",
        "id": 290413991,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658427683
    },
    {
        "content": "<p>It uses separate syntax for both cases though. So that's not an argument for <code>List</code> satisfying a generic abstraction.</p>",
        "id": 290415708,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1658428506
    },
    {
        "content": "<p>That's true, but what I meant is that you could choose to use <code>Monad LazyList</code> when you want a lazy version, which is vaguely similar to choosing to use square brackets or parentheses in Python.</p>",
        "id": 290416036,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658428676
    },
    {
        "content": "<p>It'd fair having a separate class for comprehensions (and specialized syntax to go with it) instead of using <code>Monad</code>.</p>",
        "id": 290416189,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658428744
    },
    {
        "content": "<p>To move the discussion forward, it would probably help to provide specific use cases where <code>Monad List</code> would be useful</p>",
        "id": 290416717,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1658428959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/290392474\">said</a>:</p>\n<blockquote>\n<p>If you do <code>println do ...</code> then both Haskell and Lean behave the same AFAICT.</p>\n</blockquote>\n<p>From my experience, it's not exactly out of order evaluation, but rather that intermediate lists will be computed and stored in memory prior to invoking <code>println</code>.   I remember at one point naively translating some Haskell List monad code to Lean and immediately hitting out-of-memory issues.</p>\n<p>That said, I think <code>Monad List</code> is a good idea in Lean.  I don't have a particular use case in mind at the moment, but it's just nice to be able to generate and transform lists using <code>do</code> notation.</p>",
        "id": 290431128,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1658435997
    },
    {
        "content": "<p>I have made use of <code>Monad List</code> for unit tests. (<code>Monad Array</code> is essentially the same but I feel like the strict semantics are more expected in that context.) I think that the \"unusual\" evaluation order may be a paper cut, but I think it's worthwhile to have despite this, and we should just teach people to use <code>LazyList</code> if they want the haskell style nondeterminism monad</p>",
        "id": 290433574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658437256
    },
    {
        "content": "<p>Stuff like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">list.range</span> <span class=\"mi\">5</span><span class=\"o\">,</span>\n  <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">list.range</span> <span class=\"mi\">5</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">int.nat_abs</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"c1\">-- [(0, 0), (1, 0), (2, 0)]</span>\n</code></pre></div>",
        "id": 290433849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658437430
    },
    {
        "content": "<p>One confusion I have always had with <code>Monad List</code> is that there are actually a variety of monad-like operations (not all of which are lawful) that can be defined on aggregate types like <code>List</code> -- list comprehension is just one of them. So having there be a specific <code>Monad List</code> instance strikes me as off.</p>",
        "id": 290440285,
        "sender_full_name": "Mac",
        "timestamp": 1658441258
    },
    {
        "content": "<p>For instance, one can define the monad function <code>seq : (fs : List (a -&gt; b)) -&gt; (as : List a) -&gt; List b</code> to be such that <code>bs[i] = fs[i] a[i]</code>.</p>",
        "id": 290440644,
        "sender_full_name": "Mac",
        "timestamp": 1658441496
    },
    {
        "content": "<p>I think list comprehension is the instance most people want most of the time, which is why it's become a common language feature elsewhere</p>\n<p>Also, isn't there a slick way to specify a monad instance at the call site? List comprehension can be the typeclass instance, and I don't think that severely inhibits people using other monad instances on lists</p>",
        "id": 290450593,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1658449073
    },
    {
        "content": "<p>Personally, I have found most list comprehension code I have seen to be completely incomprehensible. The special syntax most languages have for it  doesn't help readability (as it tends to aim for conciseness rather intuitiveness). And this coming from someone who likes the functional paradigm (and, in some places, considers it more intuitive than its imperative equivalent), which is already stigmatized in CS as been difficulty to understand.</p>\n<p>For instance, it took me a number of re-reads of Mario's example to figure out what it was doing and how it got the answer it got.</p>",
        "id": 290451305,
        "sender_full_name": "Mac",
        "timestamp": 1658449794
    },
    {
        "content": "<p>However, I guess that is all just matter of taste and not really a relevant objective criticism of <code>Monad List</code>.</p>",
        "id": 290451459,
        "sender_full_name": "Mac",
        "timestamp": 1658449926
    },
    {
        "content": "<p>I agree to some extent... scala's <code>for</code> syntax always felt more comprehensible to my brain because it triggered my \"iteration is happening\" senses <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 290451848,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1658450316
    },
    {
        "content": "<p>I don't know about Haskell or Scala, but list comprehension in python is wonderful and very readable. I'd love to have that in Lean.</p>",
        "id": 290452386,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1658450856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/290452386\">said</a>:</p>\n<blockquote>\n<p>but list comprehension in python is wonderful and very readable. </p>\n</blockquote>\n<p>Sadly, I disagree. I am acclimatized to the CS <code>for</code> were the order is <code>for x in iterable do expression</code> and Python putting the expression first in its list comprehensions always throws me off. However, the ordering in Python is more like math where <code>{x i in S s.t. expression}</code> is the natural order so I can understand why others (especially mathematicians) would find it intuitive.</p>",
        "id": 290454279,
        "sender_full_name": "Mac",
        "timestamp": 1658453064
    },
    {
        "content": "<p>I know you disagree, this is why I wrote my message bringing a different perspective.</p>",
        "id": 290454310,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1658453109
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Oh, sorry! How did you know that? I did not mention Python in my original critique?</p>",
        "id": 290454373,
        "sender_full_name": "Mac",
        "timestamp": 1658453164
    },
    {
        "content": "<p>I've noticed for a very long time that your programming taste is orthogonal to python and mathematics <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 290454503,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1658453324
    },
    {
        "content": "<p>Ah, fair enough. <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>  That may be a bit extreme though, I did originally find Lean by looking for a theorem prover to  try some mathematical proofs. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 290454687,
        "sender_full_name": "Mac",
        "timestamp": 1658453550
    },
    {
        "content": "<p>Though, I guess that could count as the point/line were the two orthogonal lines/planes cross.</p>",
        "id": 290454721,
        "sender_full_name": "Mac",
        "timestamp": 1658453614
    },
    {
        "content": "<p>Right now I'm writing Lean 4 code where I really wish I could use a python list comprehension</p>",
        "id": 290455044,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1658454047
    },
    {
        "content": "<p>I believe you can get away with some macro expansion for that</p>",
        "id": 290455415,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1658454567
    },
    {
        "content": "<p>Indeed you can:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">compClause</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"for \"</span> <span class=\"n\">term</span> <span class=\"s2\">\" in \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">compClause</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"if \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">compClause</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">compClause</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"k\">else</span> <span class=\"o\">[])</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.join</span> <span class=\"o\">[[</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">])</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]]</span>\n<span class=\"c1\">-- [2, 3, 4]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">4</span> <span class=\"bp\">|</span> <span class=\"k\">if</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"c1\">-- []</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">4</span> <span class=\"bp\">|</span> <span class=\"k\">if</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [4]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">List.range</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"n\">for</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">List.range</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)]</span>\n</code></pre></div>",
        "id": 290456697,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658456141
    },
    {
        "content": "<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\" for \"</span> <span class=\"n\">term</span> <span class=\"s2\">\" in \"</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"s2\">\" if \"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"n\">for</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">xs</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">map</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"n\">for</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">xs</span> <span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">xs</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">filterMap</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">List.range</span> <span class=\"mi\">5</span><span class=\"o\">]</span> <span class=\"c1\">-- [0, 2, 4, 6, 8]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">]</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"c1\">-- #[1, 3]</span>\n</code></pre></div>",
        "id": 290456701,
        "sender_full_name": "Mac",
        "timestamp": 1658456153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> you literally posted that while I was pasting my example into the comment box. <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 290456750,
        "sender_full_name": "Mac",
        "timestamp": 1658456181
    },
    {
        "content": "<p>I learned from yours that if you use <code>term</code> instead of <code>ident</code> that you can do pattern matching in the <code>for</code> clause. That's neat</p>",
        "id": 290456913,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658456402
    },
    {
        "content": "<p>For sake of example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.prod</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">for</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">ys</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">List.prod</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)]</span>\n<span class=\"c1\">-- [0, 0, 0, 0, 1, 2, 0, 2, 4]</span>\n</code></pre></div>",
        "id": 290457008,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658456493
    },
    {
        "content": "<p>Or, using the already defined <code>List.zip</code> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">[(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">List.zip</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)]</span>\n<span class=\"c1\">-- [0, 0, 0, 0, 1, 2, 0, 2, 4]; edit: actually [0, 1, 4]</span>\n</code></pre></div>",
        "id": 290457100,
        "sender_full_name": "Mac",
        "timestamp": 1658456639
    },
    {
        "content": "<p>I'm getting different output with <code>List.zip</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">List.zip</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)]</span>\n<span class=\"c1\">-- [0, 1, 4]</span>\n</code></pre></div>\n<p>That's using the \"diagonal monad\" you mentioned earlier.</p>",
        "id": 290457205,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658456743
    },
    {
        "content": "<p>You are correct, sorry.</p>",
        "id": 290457267,
        "sender_full_name": "Mac",
        "timestamp": 1658456802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Still, that got me thinking, why not make list comprehension even more baffling and allow it to do zips too?</p>\n<p>For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.zip'</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">Δ</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">for</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">ys</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- Delta temporarily switches to using the diagonal monad instead of the usual list monad</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">List.zip'</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">7</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [(1, 4), (2, 5), (3, 6)]</span>\n</code></pre></div>\n<p>Code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">compClause</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"for \"</span> <span class=\"n\">term</span> <span class=\"s2\">\" in \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">compClause</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"if \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">compClause</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"Δ\"</span> <span class=\"n\">compClause</span> <span class=\"o\">:</span> <span class=\"n\">compClause</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">compClause</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.diag</span> <span class=\"o\">(</span><span class=\"n\">xss</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xss</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]::</span><span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">)::</span><span class=\"n\">xss</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">List.diag</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">tailD</span> <span class=\"o\">[])</span> <span class=\"n\">xss</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xss.length</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"k\">else</span> <span class=\"o\">[])</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">Δ</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.diag</span> <span class=\"o\">[[</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">])</span> <span class=\"c1\">-- warning, inefficient</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.join</span> <span class=\"o\">[[</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">])</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]]</span>\n<span class=\"c1\">-- [2, 3, 4]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">4</span> <span class=\"bp\">|</span> <span class=\"k\">if</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"c1\">-- []</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">4</span> <span class=\"bp\">|</span> <span class=\"k\">if</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [4]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">List.range</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"n\">for</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">List.range</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.prod</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">for</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">ys</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">List.prod</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"mi\">3</span><span class=\"o\">)]</span>\n<span class=\"c1\">-- [0, 0, 0, 0, 1, 2, 0, 2, 4]</span>\n</code></pre></div>",
        "id": 290458221,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658457910
    },
    {
        "content": "<p>FYI lean will do zips using the notation <code>for x in xs, y in ys do</code> so I guess you could just leave off the second <code>for</code>?</p>",
        "id": 290458292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658457967
    },
    {
        "content": "<p>it's kind of evil though</p>",
        "id": 290458294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658457997
    },
    {
        "content": "<p>I missed those messages during the night, it's great!</p>",
        "id": 290544851,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1658512031
    },
    {
        "content": "<p>My 2 cents:  when more than one List/Collection is involved,  Scala's for-comprehension is much easier to read than Python's:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">for</span>\n    <span class=\"n\">x</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">List.range</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n    <span class=\"n\">y</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">List.range</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">3</span>\n  <span class=\"n\">yield</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 290627295,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1658601399
    },
    {
        "content": "<p>I still prefer python's version by far.</p>",
        "id": 290627655,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1658601870
    },
    {
        "content": "<p>Oftentimes it seems like list comprehensions could be more flexible (which is a point against the List monad). Mathematica has Reap and Sow for setting up a comprehension and collecting values. Here's a Lean 4 version of that for collecting an <code>Array</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">CollectM</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">StateM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sow</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CollectM</span> <span class=\"n\">α</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">push</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reap</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">CollectM</span> <span class=\"n\">α</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m.run</span> <span class=\"bp\">#</span><span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">reap</span> <span class=\"k\">do</span>\n  <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">5</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">5</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">3</span> <span class=\"k\">then</span>\n        <span class=\"n\">sow</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"c1\">-- #[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0)]</span>\n</code></pre></div>",
        "id": 290628864,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658603661
    },
    {
        "content": "<p>Is that just an eager special case of iterator generators with <code>yield</code>?</p>",
        "id": 290631300,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1658607380
    },
    {
        "content": "<p>Yeah, it's basically eager Python/Javascript-style (anonymous) generator functions.</p>",
        "id": 290631851,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658608234
    },
    {
        "content": "<p>The Mathematica version of this is wilder since it somehow attaches to the global continuation, so <em>any</em> function can <code>Sow</code>.</p>",
        "id": 290631941,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658608371
    },
    {
        "content": "<p>I just hope we don't use these exact names because I would not be able to use them with a straight face without thinking of <a href=\"https://twitter.com/screaminbutcalm/status/1105577845642878976?lang=en\">https://twitter.com/screaminbutcalm/status/1105577845642878976?lang=en</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/screaminbutcalm/status/1105577845642878976?lang=en\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/5db1c79ad46cef505f2719f7b38ca14a729c91cb/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313031353635373730383338373831353432352f68724532625172535f6e6f726d616c2e6a7067\"></a><p>Me sowing: Haha fuck yeah!!! Yes!! \n\nMe reaping: Well this fucking sucks. What the fuck.</p><span>- The Golden Sir (@screaminbutcalm)</span></div></div>",
        "id": 290632109,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1658608654
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> That seems like a point in favor of using those terms, no? <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 290637001,
        "sender_full_name": "Mac",
        "timestamp": 1658615538
    },
    {
        "content": "<p>I don't have a horse in this race but, if I recall correctly, <code>ListT</code> monad transformer is ill-behaved with strict lists (but the <code>List</code> monad by itself is fine with strictness).  It would be unusual if the list monad were significantly different from <code>ListT Id</code>.</p>",
        "id": 290666215,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1658660137
    },
    {
        "content": "<p>(Of course, this is not a problem if neither <code>ListM</code> nor <code>ListT</code> exist.)</p>",
        "id": 290666283,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1658660229
    },
    {
        "content": "<p>For another data point on this excellent discussion I also love Python list comprehensions, and I was looking for it the other day, until I found Kyle's awesome implementation here.  But I have also thought of these as only useful on very concise list comprehensions and I move to the more powerful \"<a href=\"https://python.plainenglish.io/python-yield-iterator-and-generator-introduction-15be182f6135\">yield pattern</a>\" (which I also love in C#) where you can write a huge function to compute what you are yielding and inject yield statements in various places to turn your entire function into an iterator.  So I've always thought of the yield iterator as a more powerful version and it's nice to have both.  So I like the <code>yield</code> keyword better than <code>sow</code> and with yield in C# you don't need to reap.  In fact, you don't want to build that Array in memory since the whole point is to be able to operate on infinite streams efficiently, like pulling transformed rows out of a database and returning them as Json over HTTP, with minimal memory footprint, etc.</p>",
        "id": 294796803,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1661224425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/290628864\">said</a>:</p>\n<blockquote>\n<p>Oftentimes it seems like list comprehensions could be more flexible (which is a point against the List monad). Mathematica has Reap and Sow for setting up a comprehension and collecting values. Here's a Lean 4 version of that for collecting an <code>Array</code>:</p>\n</blockquote>\n<p>This also can generalize nicely -- my collection library has a generalization for any collection that  can be built up one element at a time, so <code>CollectM</code> can be defined over any result collection and a nice syntax could be added.</p>\n<p>It seems like python's for comprehensions connect the two (distinct &amp; dual) notions, iterating over a collection vs building one up</p>\n<p>We already have a generalization for iterating over a collection (<code>ForIn</code>), so I think it best to add a notion for building one up (<a href=\"https://jamesgallicchio.github.io/LeanColls/docs///LeanColls/Classes.html#LeanColls.Enumerable\"><code>Enumerable</code></a>), add instances for <code>List</code> and <code>Array</code>, and add some pythonic syntax behind an import for those that want it</p>",
        "id": 294945138,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1661288181
    },
    {
        "content": "<p>Here's an implementation of the nondeterminism monad which uses continuation passing style to avoid creating lots of intermediate arrays:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ArrayM</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">κ</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">κ</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">κ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"o\">(</span><span class=\"n\">ArrayM</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"n\">a</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">k</span> <span class=\"n\">a</span>\n  <span class=\"n\">bind</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">·</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MonadLift</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ArrayM</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">monadLift</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">l.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">k</span> <span class=\"n\">a</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MonadLift</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">ArrayM</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">monadLift</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">l.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">k</span> <span class=\"n\">a</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ArrayM.run</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ArrayM</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r.push</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">ArrayM.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n  <span class=\"n\">return</span> <span class=\"mi\">10</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n<span class=\"c1\">-- #[11, 12, 13, 21, 22, 23, 31, 32, 33]</span>\n</code></pre></div>",
        "id": 295114141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661370073
    },
    {
        "content": "<p>Is there an application in Lean where you'd want an eager nondeterminism monad implementation?</p>\n<p>It would seem reasonable to me to have an explicit <code>Nondet</code> monad with a <code>choose : [ToStream α ρ] -&gt; ρ -&gt; Nondet α</code> operation, and some eliminators for it</p>",
        "id": 295128350,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1661375741
    },
    {
        "content": "<p>You mentioned you used <code>Monad List</code> in tests, is there a file that has some examples?</p>",
        "id": 295128536,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1661375823
    },
    {
        "content": "<p>Using a <code>ToStream</code> instance is a bit weird, since that introduces a dependency between the various nondet branches</p>",
        "id": 295129504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661376370
    },
    {
        "content": "<p>Yeah, I'm not sure what the right class is there. But some class that exposes external iteration.</p>",
        "id": 295129600,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1661376451
    },
    {
        "content": "<p>(or do you mean a type dependency? I'm not sure I understand what you mean)</p>",
        "id": 295129729,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1661376517
    },
    {
        "content": "<p>I mean that the various branches can't be executed independently, you need to hold on to the iterator state</p>",
        "id": 295130266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661376774
    },
    {
        "content": "<p>I ran into this using the Kyle's List Comprehension syntax extension mentioned above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span>\n<span class=\"c1\">-- filter the list to exclude negative numbers</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">vec</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [0, 2, 4]</span>\n</code></pre></div>\n<p>which errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"k\">else</span> <span class=\"o\">[])</span> <span class=\"n\">vec</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">vec</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">List</span> <span class=\"n\">Int</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>To fix it I have to coerce the 0 to an int using <code>#eval [x | for x in vec, if x &gt;= (0: Int)]</code>.</p>\n<p>So my question, is whether the Lean syntax extensions can improve how type inference happens?  I would imagine that  since <code>vec</code> is a <code>List Int</code>, then Lean should know that <code>x</code> must be an Int, therefore the 0 must be an Int also ?</p>",
        "id": 299054100,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663277069
    },
    {
        "content": "<p>Yes you can do this with a custom elaborator that forces <code>x</code> to be elaborated with <code>a</code> for <code>List a</code> but not just with a simple macro.</p>",
        "id": 299055407,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663277627
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> This is an elaboration order issue.</p>\n<p>If you define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.map'</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>then alter the <code>macro_rules</code> to instead have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.map'</span> <span class=\"bp\">$</span><span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>then your example works without the type ascription.</p>",
        "id": 299055409,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663277627
    },
    {
        "content": "<p>My understanding of what is going on is that the elaborator elaborates arguments in order, so while it elaborates the function argument to <code>List.map</code> it doesn't yet know the type of the argument to the function since it hasn't visited the list argument yet. Reversing the order of the arguments to <code>List.map</code> is sufficient in this case.</p>",
        "id": 299055648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663277735
    },
    {
        "content": "<p>wow, thanks!</p>",
        "id": 299057547,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663278692
    },
    {
        "content": "<p>Unfortunately it doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">compClause</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"for \"</span> <span class=\"n\">term</span> <span class=\"s2\">\" in \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">compClause</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"if \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">compClause</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">compClause</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.map'</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">xs</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.map'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"k\">else</span> <span class=\"o\">[])</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.join</span> <span class=\"o\">[[</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">])</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vec</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">vec</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>And it also breaks <code>def List.prod (xs : List α) (ys : List β) : List (α × β) := [(x, y) | for x in xs, for y in ys]</code></p>",
        "id": 299057822,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663278810
    },
    {
        "content": "<p>Make sure to change the order of the arguments to <code>List.map'</code> in the <code>macro_rules</code> too</p>",
        "id": 299058487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663279173
    },
    {
        "content": "<p>Doh! thanks.</p>",
        "id": 299058865,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663279341
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I turned your solution into a new Lean sample because I think it's a really great example of Lean syntax extension.  See <a href=\"https://github.com/leanprover/lean4-samples/pull/10\">https://github.com/leanprover/lean4-samples/pull/10</a>, let me know there if you have any comments or suggestions, thanks.</p>",
        "id": 299066709,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663283851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/List.20Functor/near/299055409\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"434989\">Chris Lovett</span> This is an elaboration order issue.</p>\n<p>If you define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.map'</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>then alter the <code>macro_rules</code> to instead have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"n\">for</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">List.map'</span> <span class=\"bp\">$</span><span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>then your example works without the type ascription.</p>\n</blockquote>\n<p>This has been fixed in <a href=\"https://github.com/leanprover/lean4/commit/d3b0b49c432e9e2ca7c6dd6017fbed074ff1ccb6\">https://github.com/leanprover/lean4/commit/d3b0b49c432e9e2ca7c6dd6017fbed074ff1ccb6</a></p>",
        "id": 299347388,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663436082
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I removed <code>List.map'</code> from the new sample at <a href=\"https://github.com/leanprover/lean4-samples/tree/main/ListComprehension\">https://github.com/leanprover/lean4-samples/tree/main/ListComprehension</a> and everything works.</p>",
        "id": 299691069,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663655697
    }
]
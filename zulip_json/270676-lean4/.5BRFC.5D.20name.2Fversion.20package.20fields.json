[
    {
        "content": "<p>In designing <a href=\"https://github.com/leanprover/lake\">Lake</a>, I have found the <code>name</code> and <code>version</code> properties of Lean packages to be rather superfluous. </p>\n<p>The <code>name</code> field is only really used to derive the defaults of more precise properties like the root module of a library or the name of the binary. The <code>version</code> field isn't used at all and is sort of redundant considering Lean packages are also intended to be Git repositories and the  tags/commit hashes of repositories provide much better versioning than the <code>version</code> field ever could.</p>\n<p>As such, I am proposing to <strong>remove the <code>version</code> field entirely</strong> (as it currently completely unused), and <em>considering</em> similarly <strong>removing the <code>name</code> field</strong> and just  having users to specify the more precise fields (e.g., <code>moduleRoot</code>) instead.</p>\n<p>However, as these changes would be a major departure from the way Lean packages have thus far been defined, I first wanted to field these ideas to the larger Lean 4 community to make sure they were reasonable.</p>",
        "id": 254114011,
        "sender_full_name": "Mac",
        "timestamp": 1632170196
    },
    {
        "content": "<p>Even though they are not used now it would seem useful to me to keep at least the version field. For example how are we going to enforce things like semantic versioning with libraries that are only versioned via git hashes so to speak.  With this git commit based versioning approach it would be impossible to make guarantees about API stability of libraries. Of course the library developers could start using git tags to indicate versions but then people would just end up looking up the commit id of the git tag with the proper version and add it as a dependency so I would at least propose to not drop the version field without replacement but add it optional to refer to git tags in order to make stuff like semantic versioning etc. possible. (Although this might already be possible? Never tried/looked out for that). </p>\n<p>For the name field I could imagine exactly one use case where it might become useful which is in case Lean 4 ever gets something like a <a href=\"http://crates.io\">crates.io</a> or <a href=\"http://npm.org\">npm.org</a> package repository where you can refer to packages by their name and names have to be unique (if this is realistic enough to be considered ,dropping the version field also seems like a bad idea to me, since these package repositories are usually not git repos but  merely distributions of the current state of the source code so you'd have to refer to specific versions of those as well)</p>",
        "id": 254131768,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1632179053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Thanks for sharing your thoughts! </p>\n<blockquote>\n<p>For the name field I could imagine exactly one use case where it might become useful which is in case Lean 4 ever gets something like a <a href=\"http://crates.io\">crates.io</a> or <a href=\"http://npm.org\">npm.org</a> package repository where you can refer to packages by their name and names have to be unique</p>\n</blockquote>\n<p>The name of the module root could easily double as this unique name, though. In fact, it would be more accurate, as it has to be unique between packages or it would otherwise cause import troubles. That is, a package cannot depend on two separate packages that have the same root name (e.g., <code>Foo</code>) as there is no way to distinguish which module an <code>import Foo</code> would refer too .</p>",
        "id": 254134045,
        "sender_full_name": "Mac",
        "timestamp": 1632180358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254131768\">said</a>:</p>\n<blockquote>\n<p>Even though they are not used now it would seem useful to me to keep at least the version field. For example how are we going to enforce things like semantic versioning with libraries that are only versioned via git hashes so to speak.  With this git commit based versioning approach it would be impossible to make guarantees about API stability of libraries. Of course the library developers could start using git tags to indicate versions but then people would just end up looking up the commit id of the git tag with the proper version and add it as a dependency so I would at least propose to not drop the version field without replacement but add it optional to refer to git tags in order to make stuff like semantic versioning etc. possible.</p>\n</blockquote>\n<p>I am not quite sure I understand your objection to just using Git tags for semantic versioning? I would think that would be a better solution than the <code>version</code> field.</p>",
        "id": 254134189,
        "sender_full_name": "Mac",
        "timestamp": 1632180451
    },
    {
        "content": "<p>No no, using git tags is of course perfectly fine but it should then be possible to use a git tag directly when declaring a dependency in the manifest file, but maybe that already is possible? I never tried that.</p>",
        "id": 254174518,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1632214357
    },
    {
        "content": "<p>A mere version tag would not allow for multiple packages in a single repo, though <code>$pkg-$version</code> tags could work</p>",
        "id": 254175367,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632214835
    },
    {
        "content": "<p>Removing version is a very good idea in my opinion removing the name probably not. I think the preferable thing to do is to tie versions / remote resources to a locally unique name and to not specify any version of the package / workspace itself, but instead distinguish between versions by creating archives which can be referred to by url, or by git commit hashes. </p>\n<p>As an example consider something like the boost family of libraries, there are ~30-50 of them. Or the llvm project with tons of subprojects and libraries. In Bazel you have multiple ways of bringing remote resources into your WORKSPACE, they go by <code>http_archive</code>, <code>new_http_archive</code>, <code>local_repository</code>, <code>git_repository</code>, etc. They have the role to tie a remote / local resource uniquely specified by a url and checked by a hash like sha256, to a local name <code>@resource_name</code> and refer to libraries, executables, tests defined in that workspace as <code>@resource_name//:foo, ..., @resource_name//bla/:main</code>. In particular you always depend on such named resources without any references to versions. That way there is only one place to change if you change the library version, that you depend on. I'm not necessarily suggesting copying this 1:1, but I think strictly separating versioning from naming resources is a very good idea.</p>\n<p>I'm mangling the terminology a bit, the Bazel concepts are explained here (<a href=\"https://docs.bazel.build/versions/main/build-ref.html\">https://docs.bazel.build/versions/main/build-ref.html</a>).</p>",
        "id": 254183615,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632219307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> Bazel is a build system and not a package manager, so its applicability is limited here. I believe that for a mature package ecosystem, semantic versioning is the only scalable solution discovered so far, in which case your dependency references are <em>not</em> uniquely specified after all (except in the root package where you should have a lock file).</p>",
        "id": 254187496,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632221681
    },
    {
        "content": "<p>I'd prefer if the notion of a Lean package wasn't entangled with a particular VCS in the first place. This seems like a hack that doesn't save much effort and would be hard to change later on.</p>",
        "id": 254188007,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1632221966
    },
    {
        "content": "<p>I'd tend to agree, but then you really need a registry that indexes packages by versions. With Git tags, you could list them without looking at all commits changing <code>package.lean</code>.</p>",
        "id": 254189226,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632222626
    },
    {
        "content": "<p>And even if such a registry were VCS-agnostic, the package manager could derive a version from a Git tag (or other source) and embed it during upload, so you could still have both.</p>",
        "id": 254189358,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632222710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> It was my impression that Lake was aiming to be both build system and package manager and this RFC was essentially about how to delineate the two. In that aspect the solution in Bazel is relevant I think. There the dependencies on WORKSPACE external packages is managed by binding them to names, which can be referred to within the workspace as I sketched above. This is orthogonal to semantic versioning, as the external packages can indeed be versioned semantically. However Bazel essentially only allows equality constraints or dependence on e.g. HEAD. The other feature some package manages  have, namely to solve constraints based on version ranges is in my opinion proven to <em>not</em> scale, as solving constraints can quickly blow up in your face in two ways: Either by not explicitly tracking dependency on the presence of system libraries or certain hardware features (e.g. building a library with and without CUDA support) or in the myriad of ways that cabal / npm tends to fail. Solutions that scale are to \"build the world\", like nix, spack or in fact all linux distributions do and then to deploy in a specific container which locks non-explicitly tracked system dependencies in place and then to explicitly track dependencies across packages that are under your control. The spack documentation contains many good examples, why semantic versioning is not enough (<a href=\"https://spack.readthedocs.io/en/latest/features.html\">https://spack.readthedocs.io/en/latest/features.html</a>) (<a href=\"https://tgamblin.github.io/pubs/spack-sc15.pdf\">https://tgamblin.github.io/pubs/spack-sc15.pdf</a>).</p>",
        "id": 254204831,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632230173
    },
    {
        "content": "<p>(FWIW in the broader Python community, I perceive a very slight move <em>away</em> from semantic versioning, which no one ever does properly anyhow. I don't have statistics, though I can calculate them, but in the past few years, a number of packages have adopted calver very enthusiastically.  -- <a href=\"https://calver.org/\">https://calver.org/</a> )</p>\n<p>And also in Python, we don't make declaring package versions via VCS tags the <em>only</em> way, but it's trivial to do so using hooks, specifically <a href=\"https://github.com/pypa/setuptools_scm/\">https://github.com/pypa/setuptools_scm/</a></p>",
        "id": 254204876,
        "sender_full_name": "Julian Berman",
        "timestamp": 1632230200
    },
    {
        "content": "<p>Regarding doing semantic versioning properly, in <a href=\"https://elm-lang.org/\">https://elm-lang.org/</a> exists a mechanism to automatically enforce semantic versioning (scroll down to \"Enforced Semantic Versioning\") Which basically does a diff on the type level and checks whether there are major change or not etc. Now I don't know if this is doable for lean (or how hard it would be) but if it is doable and someone actually implements this to enforce semantic versioning at compile time I'd consider the issue of \"doing semantic versioning properly\" solved for lean.</p>",
        "id": 254206873,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1632231043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254206873\">said</a>:</p>\n<blockquote>\n<p>Regarding doing semantic versioning properly, in <a href=\"https://elm-lang.org/\">https://elm-lang.org/</a> exists a mechanism to automatically enforce semantic versioning (scroll down to \"Enforced Semantic Versioning\") Which basically does a diff on the type level and checks whether there are major change or not etc. Now I don't know if this is doable for lean (or how hard it would be) but if it is doable and someone actually implements this to enforce semantic versioning at compile time I'd consider the issue of \"doing semantic versioning properly\" solved for lean.</p>\n</blockquote>\n<p>It would not in cases that the Lean library depends on the existence of certain system libraries, compiler versions and or the target architecture it is build for. If you cannot properly specify the dependence on those, the semantic version alone does not capture all necessary information. For example you would maybe like to express library A version x depends on library B version y built with CUDA support.</p>",
        "id": 254207554,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632231334
    },
    {
        "content": "<p>And also it's just impossible :) (and I'm a proponent of semver personally by the way) -- but no one ever does what you're supposed to in semver, which is define what your public API actually <em>is</em> -- and it's not just types and interfaces. For Python I put some notes here: <a href=\"https://regret.readthedocs.io/en/stable/before-you-deprecate/#document-your-public-api\">https://regret.readthedocs.io/en/stable/before-you-deprecate/#document-your-public-api</a> which are things no one I know of ever really specifies, and even those who try of course will come to some scenario where it's unclear</p>",
        "id": 254207923,
        "sender_full_name": "Julian Berman",
        "timestamp": 1632231485
    },
    {
        "content": "<p>Which is why you need to maintain a distribution of everything you depend on at specific versions (if you are deploying to something) and have automated ways of building more recent distributions. Bazel in a large organisation provides that in the form of WORKSPACE and BUILD definitions for all known good packages, which you can then just import into your current WORKSPACE. Spack allows the same by allowing to define meta-packages, which all organisation internal packages then can depend on.</p>",
        "id": 254209158,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632231998
    },
    {
        "content": "<p>Anyways, maybe in more concrete terms, right now in Lake one has </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Source</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">path</span> <span class=\"o\">(</span><span class=\"n\">dir</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Source</span>\n<span class=\"bp\">|</span> <span class=\"n\">git</span> <span class=\"o\">(</span><span class=\"n\">url</span> <span class=\"n\">rev</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">branch</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Source</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Dependency</span> <span class=\"n\">where</span>\n  <span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n  <span class=\"n\">src</span>  <span class=\"o\">:</span> <span class=\"n\">Source</span>\n  <span class=\"n\">dir</span>  <span class=\"o\">:</span> <span class=\"n\">FilePath</span> <span class=\"o\">:=</span> <span class=\"s2\">\".\"</span>\n  <span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>my comment above was that it might make sense to map everything to labels and declare the meaning of labels separately. That is if there is a <code>git_repository(name = \"A\", url=\"...\",  sha256=\"\")</code>, then everything else can refer to things in there as \"@A//...\" in Bazel without caring about that this originated from a git repository. Moreover the equivalent of the \"Source / Dependency\" type in Bazel is extensible, because everything is expressed in terms of labels, Providers and Dependency sets.</p>",
        "id": 254211962,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632233031
    },
    {
        "content": "<p>For names, my idea is to identify lean libraries / packages by there root module (e.g., <code>Lake</code> for lake,  <code>Mathlib4</code> for mathlib4, etc.), which is necessarily unique due to Lean's import resolution procedure, rather than another, potentially different <code>name</code> field.</p>",
        "id": 254231254,
        "sender_full_name": "Mac",
        "timestamp": 1632239774
    },
    {
        "content": "<p>For versions, my idea is to identify the version of the a package by its dependency configuration (i.e., its, ideally permalink, source, path within it, and configuration arguments). If the a package from the same permalink source can change versions, that is already a major problem for reproducibility.  So, I think assuming a one to one match between them is reasonable and sufficient for versioning.</p>",
        "id": 254232151,
        "sender_full_name": "Mac",
        "timestamp": 1632240067
    },
    {
        "content": "<p>For Git (i.e. probably &gt;95% of our dependencies) that's simply the commit hash, right? Have you thought more about some kind of lock file for Lake?</p>",
        "id": 254232860,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632240297
    },
    {
        "content": "<p>Yep, the commit hash / tag (plus repo URL) would be the permalink source for Git repos. I do have an idea for a lockfile, but there is currently no need for one as al dependencies are currently specified with a single version/source/revision rather than a range.</p>",
        "id": 254236497,
        "sender_full_name": "Mac",
        "timestamp": 1632241690
    },
    {
        "content": "<p>The same is true for Nix Flakes, but they still have a .json lock file - because programmatically updating that one is far easier than an arbitrary .nix/.lean file :)</p>",
        "id": 254237190,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632241958
    },
    {
        "content": "<p>Well, the more important reason may be that it also locks transitive dependencies and thus can get quite big. That way, if you have a dependency diamond with mismatched versions, the top flake can record the resolution. So even without ranges, lock files can be helpful.</p>",
        "id": 254238072,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632242286
    },
    {
        "content": "<p>I don't disagree. It just isn't very high on my priority list right now as it is not currently necessary and wouldn't really add any new capabilities to Lake.</p>",
        "id": 254238533,
        "sender_full_name": "Mac",
        "timestamp": 1632242466
    },
    {
        "content": "<p>If you want, you could add an issue about it to the Lake repo (and I could mark it as lower priority) so that we keep it in mind. It could also be used to alert others that it is a planned feature and they could upvote if they desire it for some use case I have not yet thought of.</p>",
        "id": 254238806,
        "sender_full_name": "Mac",
        "timestamp": 1632242568
    },
    {
        "content": "<blockquote>\n<p>For names, my idea is to identify lean libraries / packages by their root module (e.g., <code>Lake</code> for lake,  <code>Mathlib4</code> for mathlib4, etc.), which is necessarily unique due to Lean's import resolution procedure</p>\n</blockquote>\n<p>Is this true? Is it not possible in Lean4 to have \"namespace packages\" (to borrow a term from python) like we have in lean3?</p>",
        "id": 254267961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632254060
    },
    {
        "content": "<p>That is, have <code>MyFoo</code> provide <code>src/My/Foo.lean</code> and <code>MyBar</code> provide <code>src/My/Bar.lean</code>.</p>",
        "id": 254268177,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632254150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254231254\">said</a>:</p>\n<blockquote>\n<p>For names, my idea is to identify lean libraries / packages by their root module (e.g., <code>Lake</code> for lake,  <code>Mathlib4</code> for mathlib4, etc.), which is necessarily unique due to Lean's import resolution procedure, rather than another, potentially different <code>name</code> field.</p>\n</blockquote>\n<p>Something I was wondering: Haskell has converged on a design, where many libraries insert themselves in a common namespace e.g. Data.ByteString. If I understand you correctly this wouldn't be possible with that design.</p>",
        "id": 254425959,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632339513
    },
    {
        "content": "<p>Yes, lean 3 does the same thing and this is a point of divergence in lean 4</p>",
        "id": 254426105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632339582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130511\">Christian Pehle</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254425959\">said</a>:</p>\n<blockquote>\n<p>Something I was wondering: Haskell has converged on a design, where many libraries insert themselves in a common namespace e.g. Data.ByteString. If I understand you correctly this wouldn't be possible with that design.</p>\n</blockquote>\n<p>Technically, there is nothing preventing you from setting your module root to something like <code>Data.ByteString</code>. Though yes, this would prevent packages from sharing the same module root. Personally, however, I think this approach is very suspect. I know that Haskell has had many problems with package name clashes, and this may be part of the reason. Luckily, in Haskell, you can additionally specify the package something comes from in addition to its module in an <code>import</code> statement -- something you can not do in Lean.</p>",
        "id": 254430960,
        "sender_full_name": "Mac",
        "timestamp": 1632341386
    },
    {
        "content": "<p>Also, as  <code>.olean</code> files are located based on their module name, even if Lake supported packages sharing the module names, Lean itself would not (they would clash, whichever one was first in the LEAN_PATH would be loaded and the other one not).</p>",
        "id": 254431280,
        "sender_full_name": "Mac",
        "timestamp": 1632341494
    },
    {
        "content": "<p>I would agree that, if Lean had a more flexible module system, separating package identifiers from module identifiers would make sense. However, as that is not the case, I think, by the principle of Occam's razor, merging them into one is appropriate as it packages simpler.</p>",
        "id": 254432152,
        "sender_full_name": "Mac",
        "timestamp": 1632341841
    },
    {
        "content": "<p>It also allow means packages are then identified by a <code>Name</code> rather than a <code>String</code>, further increasing uniformity with things like declarations.</p>",
        "id": 254432453,
        "sender_full_name": "Mac",
        "timestamp": 1632341992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>  Since there is an open issue (<a href=\"https://github.com/leanprover/lean4/issues/416\">https://github.com/leanprover/lean4/issues/416</a>), I guess there might be some movement on this still. What I like about the Haskell approach is that one can in principle view the hierarchy as being arranged around semantic names and not vanity names. I have had experience with name clashes in Haskell and that indeed can be quite messy.</p>",
        "id": 254435080,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632343002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> I am personally quite found of vanity names! (If the names of my projects didn't give that away already. <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span> ) Still, as I said, there is nothing prevent you from doing the whole namespaced<code>Data.X</code>, <code>Text.X</code>, or <code>My.X</code> approach if you want (the module root does not have to be atomic)  -- that would still be supported by the proposed change.</p>",
        "id": 254435448,
        "sender_full_name": "Mac",
        "timestamp": 1632343153
    },
    {
        "content": "<p>On the issue point, the module system in development is about moving away from transitive imports to a more modern limited import system. It is not proposing to change the module resolution procedure.</p>",
        "id": 254435627,
        "sender_full_name": "Mac",
        "timestamp": 1632343229
    },
    {
        "content": "<p>Furthermore, I am not even sure what the difference between identifying a package / module by a unique module name vs a non-unique module name and a unique package name is. They can still both result in clashes -- the later just adds the hassle of another name you need to specify.</p>",
        "id": 254435926,
        "sender_full_name": "Mac",
        "timestamp": 1632343359
    },
    {
        "content": "<p>I think everyone here can attest to the confusion newcomers have with mathlib 3 putting things in <code>init</code></p>",
        "id": 254436300,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632343512
    },
    {
        "content": "<p>Also, as you said, <span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> , the common way to resolve such name clash problems is to import a given source with a name assigned by the user. In which case, any name field on the package (module or otherwise) is superfluous as the name gets overwritten and unique identifier is now the permalink to the source.</p>",
        "id": 254436321,
        "sender_full_name": "Mac",
        "timestamp": 1632343524
    },
    {
        "content": "<p>Yes, Bazel is I think a neat case study how to deal with names and dependencies in a fairly principled and language agnostic way. Those are so to speak the language external ways of dealing with dependencies. Since C++ absolutely makes no guarantees and follows no conventions, that's the only thing you get. On a slightly unrelated note, sophisticated module systems tend to only matter once a lot of code has been written. As is evidenced by the evolution of the go module system.</p>",
        "id": 254436895,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632343791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254436300\">said</a>:</p>\n<blockquote>\n<p>I think everyone here can attest to the confusion newcomers have with mathlib 3 putting things in <code>init</code></p>\n</blockquote>\n<p>But mathlib 3 doesn't put anything in <code>init</code>?</p>",
        "id": 254437134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632343878
    },
    {
        "content": "<p>It does put things in <code>data</code> though, alongside other things in <code>data</code> in lean 3 core (exactly like the haskell example)</p>",
        "id": 254437241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632343922
    },
    {
        "content": "<p>Yes, <code>data</code>, sorry :)</p>",
        "id": 254437999,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632344218
    },
    {
        "content": "<p>Does anyone know what happens when you overlap module names in java (which also lets you set the hierarchy)?</p>",
        "id": 254438314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632344333
    },
    {
        "content": "<p>Rust follows the model that prefixes everything with the crate name, but it also has lots of tools to rename things that lean doesn't have (module re-exports, <code>as</code> in imports)</p>",
        "id": 254438734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632344463
    },
    {
        "content": "<p>also the <code>crate</code> keyword, which avoids needing to write <code>import Mathlib.Foo.Bar</code> in all internal mathlib imports</p>",
        "id": 254438868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632344513
    },
    {
        "content": "<p>in fact I don't even think it is legal to use the name of the crate in place of <code>crate</code> there in rust</p>",
        "id": 254439034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632344562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> I think that is also one of the reasons why Rust has overtaken Go  for many users. Rust had clearly learned from previous programming languages many best practices about a language's infrastructure whereas Go was rather slow on the uptake.</p>",
        "id": 254439320,
        "sender_full_name": "Mac",
        "timestamp": 1632344668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I agree that rust should probably be considered the gold standard at the moment for language infrastructure.</p>",
        "id": 254439501,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632344738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254437241\">said</a>:</p>\n<blockquote>\n<p>It does put things in <code>data</code> though, alongside other things in <code>data</code> in lean 3 core (exactly like the haskell example)</p>\n</blockquote>\n<p>As <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  notes, this makes it hard for others to know that package is, in fact, that (a package) and not part of the core library, which can cause a lot consternation.</p>",
        "id": 254439594,
        "sender_full_name": "Mac",
        "timestamp": 1632344766
    },
    {
        "content": "<p>But rust also does not have a huge amount of \"add on\" material in downstream crates, while this is a totally expected outcome in lean. (This is in part because the orphan rules make such add-ons be very much second class citizens, and often you have to do some kind of conditional compilation in the original crate to support a particular downstream user, which I don't think we should be pushing for in lean.)</p>",
        "id": 254439801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632344868
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> I personally would argue for NodeJS / TypeScript / etc., but Rust is very impressive. There are some design decisions of Rust, that I do not like, though.</p>",
        "id": 254439882,
        "sender_full_name": "Mac",
        "timestamp": 1632344887
    },
    {
        "content": "<p>In OCaml it is possible to at least compose libraries out of components, the <a href=\"https://ocaml.janestreet.com/ocaml-core/latest/doc/core/\">https://ocaml.janestreet.com/ocaml-core/latest/doc/core/</a> core library of JaneStreet is a good example. It is made up of lots of components which are assembled into a whole. I would btw. be careful to argue in terms of what possible bad things can happen, a lot of that comes down to professionalism and organisation.</p>",
        "id": 254439971,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632344924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254439594\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254437241\">said</a>:</p>\n<blockquote>\n<p>It does put things in <code>data</code> though, alongside other things in <code>data</code> in lean 3 core (exactly like the haskell example)</p>\n</blockquote>\n<p>As <span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span>  notes, this makes it hard for others to know that package is, in fact, that (a package) and not part of the core library, which can cause a lot consternation.</p>\n</blockquote>\n<p>I'm still not sure whether this is a pro or con of the design though</p>",
        "id": 254440021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632344947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Well its a con in my opinion. <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 254440152,
        "sender_full_name": "Mac",
        "timestamp": 1632345012
    },
    {
        "content": "<p>But why? Can you give a concrete example of where this causes problems? \"Add on\" libraries being able to coexist with the original material without users having to worry what parts come from where seems like a good thing</p>",
        "id": 254440220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254439801\">said</a>:</p>\n<blockquote>\n<p>But rust also does not have a huge amount of \"add on\" material in downstream crates, while this is a totally expected outcome in lean.</p>\n</blockquote>\n<p>What do you mean by \"add-on\"  material?</p>",
        "id": 254440232,
        "sender_full_name": "Mac",
        "timestamp": 1632345065
    },
    {
        "content": "<p>e.g. Lean core defines <code>List.append</code>, mathlib defines <code>List.subset</code></p>",
        "id": 254440324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345115
    },
    {
        "content": "<p>and users don't have to worry about the origin of a definition to use it</p>",
        "id": 254440386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, when I am reading some libraries code to learn from it replicate it, I would kind of like know what dependencies I need to do so and not have to dig into each one of the (possibly hundreds) of the dependencies of the library to figure out which is contributing it.</p>",
        "id": 254440392,
        "sender_full_name": "Mac",
        "timestamp": 1632345140
    },
    {
        "content": "<p>For finding the source of a definition, I of course use go-to-definition anyway</p>",
        "id": 254440445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345174
    },
    {
        "content": "<p>knowing that it comes from a given library isn't that much of a help to finding it</p>",
        "id": 254440472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254440324\">said</a>:</p>\n<blockquote>\n<p>e.g. Lean core defines <code>List.append</code>, mathlib defines <code>List.subset</code></p>\n</blockquote>\n<p>And this is horrible -- if two libraries define <code>List.subset</code>, they can no longer be used together.</p>",
        "id": 254440481,
        "sender_full_name": "Mac",
        "timestamp": 1632345203
    },
    {
        "content": "<p>My guess would be that especially in mathematics if you start organising things in a hierarchy, you might want to insert personal extensions into that hierarchy without being able to modify the core library.</p>",
        "id": 254440502,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632345214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> If I am viewing a source non-interactively (i.e., on a website like GitHub or Stack overflow) that doesn't really help.</p>",
        "id": 254440538,
        "sender_full_name": "Mac",
        "timestamp": 1632345241
    },
    {
        "content": "<p>there are things you can do like searching for <code>def List.subset</code> but sure, that's hard</p>",
        "id": 254440623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345268
    },
    {
        "content": "<p>because lean is really flexible in how things can get defined</p>",
        "id": 254440659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345290
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> Yes, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>'s example is all well and dandy for monolithic standardized libraries like mathlib, but not for general programming.</p>",
        "id": 254440667,
        "sender_full_name": "Mac",
        "timestamp": 1632345296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254440623\">said</a>:</p>\n<blockquote>\n<p>there are things you can do like searching for <code>def List.subset</code> but sure, that's hard</p>\n</blockquote>\n<p>Well then, haven't I proven my case?</p>",
        "id": 254440789,
        "sender_full_name": "Mac",
        "timestamp": 1632345351
    },
    {
        "content": "<p>If you have a bring-your-own-hierarchy approach like haskell or java, you can always use a very specific namespace of your own to avoid any namespace clashes if you want</p>",
        "id": 254440794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345353
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>, but actually there are many instances where people end up doing similar (horrible) things in C++ :).</p>",
        "id": 254440803,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632345358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> was that suppose to be an argument for or against my point? XD</p>",
        "id": 254440907,
        "sender_full_name": "Mac",
        "timestamp": 1632345393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254440789\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254440623\">said</a>:</p>\n<blockquote>\n<p>there are things you can do like searching for <code>def List.subset</code> but sure, that's hard</p>\n</blockquote>\n<p>Well then, haven't I proven my case?</p>\n</blockquote>\n<p>This is hard no matter what - unless you make lean be much more explicit about how definitions are contributed you are kind of hosed regarding <code>grep</code> for finding definitions</p>",
        "id": 254440927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> the whole point of the new module system is to do just that.</p>",
        "id": 254440999,
        "sender_full_name": "Mac",
        "timestamp": 1632345458
    },
    {
        "content": "<p>commands can just make up names and add definitions there</p>",
        "id": 254441005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345461
    },
    {
        "content": "<p>no, the module system does nothing to solve this problem</p>",
        "id": 254441090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Which module system do you mean? That is, in fact, (part of) the point of <a href=\"https://github.com/leanprover/lean4/issues/416\">#416</a>.</p>",
        "id": 254441203,
        "sender_full_name": "Mac",
        "timestamp": 1632345554
    },
    {
        "content": "<p>I have had discussion with <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> and Leo about it and, from what I understood, being more explicit which definitions you are importing is a major component of the idea.</p>",
        "id": 254441679,
        "sender_full_name": "Mac",
        "timestamp": 1632345792
    },
    {
        "content": "<p>Even with module names and renaming etc, I don't see how the problem of manual go-to-definition is made any easier. If anything, you now have many steps to get from one to the other</p>",
        "id": 254441694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345797
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> well the ideal situation is that you can do powerful things but most of the time it is not necessary. It certainly shouldn't be the norm, but it would be nice to be able to compose a namespace hierarchy out of multiple libraries (the JaneStreet Core library would be a neat example). This is also common in let's say C++, for organising large amounts of code under a common namespace, but separated into several libraries (boost, folly, absl, ...)</p>",
        "id": 254441714,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632345809
    },
    {
        "content": "<p>Again, there is nothing preventing on frrom doing this with Lake or in what I have proposed. This is mostly just a discussion on style as to whether  doing so is a good idea. I think most programmers experience from C/C++ has taught them it is not (hence why Rust forbids it).</p>",
        "id": 254441930,
        "sender_full_name": "Mac",
        "timestamp": 1632345908
    },
    {
        "content": "<p>My impression was that you wanted the module system to enforce it</p>",
        "id": 254441979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632345943
    },
    {
        "content": "<p>No, I tend to be very against enforcing style.</p>",
        "id": 254442102,
        "sender_full_name": "Mac",
        "timestamp": 1632345999
    },
    {
        "content": "<p>well, not all features of C++ are equally bad :). I don't think that allowing a namespace to incorporate many libraries is an example of a bad feature, since even if all of them belonged to the same project (say LLVM), you would still want to be able to compile them separately. We might be talking past each other, though.</p>",
        "id": 254442205,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632346072
    },
    {
        "content": "<p>In  fact, I would suggest that Lean do something similar to  Ruby's refinements to all such things to be done in a manner that avoids clashes.</p>",
        "id": 254442209,
        "sender_full_name": "Mac",
        "timestamp": 1632346074
    },
    {
        "content": "<p>Doing this in the style guide is no problem at all. Small libraries can live in a namespace of their own, while monolithic libraries like mathlib will want to take many namespaces and possibly also contribute additionally to existing namespaces in its dependencies</p>",
        "id": 254442270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346091
    },
    {
        "content": "<p>One thing the build tool can do to help here is to add a package and also specify a rename map like <code>\"*\" -&gt; \"Mathlib.*\"</code> when an import name clash is imminent (or even just because the user prefers strict namespacing)</p>",
        "id": 254442747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> I have no objections to inter-organizational building of namespace or even to library that is specifically meant augment another specific library (like <code>nest_asyncio</code> to <code>asyncio</code> in Python). I have a problem with cases like mathlib where the are argument the Lean core in ways many other libraries would likely do do similarly, thereby creating conflicts. Even then, <em>if</em> Lean had some thing like Ruby's refinements and mathlib did that instead, I wouldn't object to it.</p>",
        "id": 254442884,
        "sender_full_name": "Mac",
        "timestamp": 1632346429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254442747\">said</a>:</p>\n<blockquote>\n<p>One thing the build tool can do to help here is to add a package and also specify a rename map like <code>\"*\" -&gt; \"Mathlib.*\"</code> when an import name clash is imminent (or even just because the user prefers strict namespacing)</p>\n</blockquote>\n<p>No, it can't. Lean does not permit renaming of modules.</p>",
        "id": 254443029,
        "sender_full_name": "Mac",
        "timestamp": 1632346489
    },
    {
        "content": "<p>let's say it did</p>",
        "id": 254443043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346497
    },
    {
        "content": "<p>i.e. suppose you could customize the function from \"import name -&gt; olean\" more than just a list of root paths</p>",
        "id": 254443081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346517
    },
    {
        "content": "<p>Well then, things would be different then, wouldn't they? <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 254443085,
        "sender_full_name": "Mac",
        "timestamp": 1632346520
    },
    {
        "content": "<p>I am all for customization when possible.</p>",
        "id": 254443108,
        "sender_full_name": "Mac",
        "timestamp": 1632346535
    },
    {
        "content": "<p>I think this is a fairly simple feature to add to lean 4</p>",
        "id": 254443145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346561
    },
    {
        "content": "<p>It is sadly not.</p>",
        "id": 254443195,
        "sender_full_name": "Mac",
        "timestamp": 1632346573
    },
    {
        "content": "<p>Lean current module system (and the front-end for that matter) heavily tie a module's name with its file name and its <code>.olean</code>.</p>",
        "id": 254443275,
        "sender_full_name": "Mac",
        "timestamp": 1632346624
    },
    {
        "content": "<p>in what sense?</p>",
        "id": 254443301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I'm not familiar with what ruby does, but generally speaking pointing to bad examples in programming are always a bit unconvincing to me, I think asking what good things are enabled by this is more fruitful.</p>",
        "id": 254443303,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632346641
    },
    {
        "content": "<p>especially for languages which are not meant to be programmed by 10.000 programmers on the same project.</p>",
        "id": 254443337,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632346669
    },
    {
        "content": "<p>there is a function that maps import names to oleans; if that function is modified everything else would follow</p>",
        "id": 254443354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ah, no. The module name / its file name is part of the name of the symbols generated by the compiler, two modules with clashing names would have clashing symbols.</p>",
        "id": 254443531,
        "sender_full_name": "Mac",
        "timestamp": 1632346755
    },
    {
        "content": "<p>I'm not suggesting anything about modules with clashing names</p>",
        "id": 254443718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346862
    },
    {
        "content": "<p>although it is true that module renames are problematic in that scenario</p>",
        "id": 254443754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346891
    },
    {
        "content": "<p>Huh? But:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254442747\">said</a>:</p>\n<blockquote>\n<p>One thing the build tool can do to help here is to add a package and also specify a rename map like <code>\"*\" -&gt; \"Mathlib.*\"</code> <strong><em>when an import name clash is imminent</em></strong> (or even just because the user prefers strict namespacing)</p>\n</blockquote>\n<p>(emphasis mine)</p>",
        "id": 254443777,
        "sender_full_name": "Mac",
        "timestamp": 1632346905
    },
    {
        "content": "<p>In the project after that rename, there is no import name clash</p>",
        "id": 254443855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632346940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130511\">Christian Pehle</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254443303\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> I'm not familiar with what ruby does, but generally speaking pointing to bad examples in programming are always a bit unconvincing to me, I think asking what good things are enabled by this is more fruitful.</p>\n</blockquote>\n<p>I was pointing to a good example? I was complimenting Ruby's refinements and saying Lean should copy them?</p>",
        "id": 254443897,
        "sender_full_name": "Mac",
        "timestamp": 1632346979
    },
    {
        "content": "<p>you have <code>Foo</code> and <code>Mathlib.Foo</code> modules, those are different names</p>",
        "id": 254443927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347005
    },
    {
        "content": "<p>For compiler symbols, probably it would be better to use a strict-namespaced version of the import name instead of the user facing version</p>",
        "id": 254444066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347087
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> At the Lean level yes, but the binary symbols aren't renamed (and generally, can't be), so you would get all kinds of errors at compile time.</p>",
        "id": 254444070,
        "sender_full_name": "Mac",
        "timestamp": 1632347089
    },
    {
        "content": "<p>And since Lean uses said compiled symbols interactively, it would probably even cause segfaults in the editor.</p>",
        "id": 254444146,
        "sender_full_name": "Mac",
        "timestamp": 1632347137
    },
    {
        "content": "<p>I don't think it is too much to ask for all libraries in the dependency graph to have distinct names</p>",
        "id": 254444278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347192
    },
    {
        "content": "<p>so if you stick that on the import name you will get something globally unambiguous</p>",
        "id": 254444334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347222
    },
    {
        "content": "<p>and renames are only there to affect how <code>import</code> resolution works</p>",
        "id": 254444365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347244
    },
    {
        "content": "<p>But the library name is the import name?</p>",
        "id": 254444495,
        "sender_full_name": "Mac",
        "timestamp": 1632347312
    },
    {
        "content": "<p>In the version I'm suggesting, it need not be</p>",
        "id": 254444610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347370
    },
    {
        "content": "<p>it might be, perhaps that's in the style guide for small libraries</p>",
        "id": 254444647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347396
    },
    {
        "content": "<p>If a name my module<code>Foo</code>, what am I then expected to name the library, <code>Bar</code>?</p>",
        "id": 254444718,
        "sender_full_name": "Mac",
        "timestamp": 1632347414
    },
    {
        "content": "<p>When you say module, you mean a lean/olean file, right? Those get whatever name the author wants them to have, and downstream users import the file by that name by default</p>",
        "id": 254444865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347497
    },
    {
        "content": "<p>The name of the library is not intrinsically connected to that</p>",
        "id": 254444887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254443897\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130511\">Christian Pehle</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254443303\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> I'm not familiar with what ruby does, but generally speaking pointing to bad examples in programming are always a bit unconvincing to me, I think asking what good things are enabled by this is more fruitful.</p>\n</blockquote>\n<p>I was pointing to a good example? I was complimenting Ruby's refinements and saying Lean should copy them?</p>\n</blockquote>\n<p>Ah, that was confusing. I meant pointing to Mathlib as a bad example. I will look into what ruby does ;).</p>",
        "id": 254444894,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632347521
    },
    {
        "content": "<p>I can not envision why you would name the library something different than the module. Furthermore, that would require a fundamental change to how the Lean code generator works.</p>",
        "id": 254444898,
        "sender_full_name": "Mac",
        "timestamp": 1632347522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254444865\">said</a>:</p>\n<blockquote>\n<p>When you say module, you mean a lean/olean file, right? Those get whatever name the author wants them to have, and downstream users import the file by that name by default</p>\n</blockquote>\n<p>No, I mean the module in Lean, which then adds its name as a prefix to the symbols in the binary library (i.e., the shared or static lib). The way Lean currently works this also happens to be the file path, but that would be relatively more easy to change.</p>",
        "id": 254444994,
        "sender_full_name": "Mac",
        "timestamp": 1632347567
    },
    {
        "content": "<p>For example, maybe the haskell library called <code>bytestrings</code> has a module named <code>Data.ByteString.Strict</code></p>",
        "id": 254445004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347574
    },
    {
        "content": "<p>In this example, the symbol <code>ByteString.length</code> would be something like <code>bytestrings__Data_ByteString_Strict__ByteString_length</code></p>",
        "id": 254445180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347651
    },
    {
        "content": "<p>Why not just call your module <code>ByteStrings.Data.ByteString.Strict</code> (or just <code>ByteStrings.Strict</code>) then?</p>",
        "id": 254445323,
        "sender_full_name": "Mac",
        "timestamp": 1632347732
    },
    {
        "content": "<p>because I don't want to write <code>import ByteStrings.Data.ByteString.Strict</code></p>",
        "id": 254445355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347747
    },
    {
        "content": "<p>as long as I don't have to do that, feel free to have that be the internal \"module name\"</p>",
        "id": 254445412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347763
    },
    {
        "content": "<p>as I said, why not just call it <code>ByteStrings.Strict</code> then?</p>",
        "id": 254445456,
        "sender_full_name": "Mac",
        "timestamp": 1632347790
    },
    {
        "content": "<p>because Haskell users are used to know that everything related to Data (data structures is found under Data).</p>",
        "id": 254445538,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632347838
    },
    {
        "content": "<p>in the mathematics case it would be odd to search for lemmas about rings in multiple hierarchical namespaces</p>",
        "id": 254445602,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632347870
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> sure, that's Haskell and there is tradition behind it. However, why would any new language want to copy that?</p>",
        "id": 254445617,
        "sender_full_name": "Mac",
        "timestamp": 1632347876
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> Yeah, but in the mathematics case, they are all under <code>Mathlib</code> so it doesn't matter.</p>",
        "id": 254445792,
        "sender_full_name": "Mac",
        "timestamp": 1632347946
    },
    {
        "content": "<p>only if all mathematics exists in <code>Mathlib</code></p>",
        "id": 254445829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347966
    },
    {
        "content": "<p>which isn't even true in lean 3, some lemmas are in core</p>",
        "id": 254445852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632347981
    },
    {
        "content": "<p>and there are third party libraries too</p>",
        "id": 254445897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348003
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> which seems to be the idea there. And you could re-export the lemma from core.</p>",
        "id": 254445948,
        "sender_full_name": "Mac",
        "timestamp": 1632348008
    },
    {
        "content": "<p>I think that isn't a long term scalable approach, moreover I think encouraging this kind of monolithic code base would probably not a great idea.</p>",
        "id": 254445979,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632348016
    },
    {
        "content": "<p>Mathlib modules are named <em>by topic</em></p>",
        "id": 254446010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348023
    },
    {
        "content": "<p>not by origin</p>",
        "id": 254446057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> I agree, but in said case, I think splitting them up by source package makes more sense.</p>",
        "id": 254446111,
        "sender_full_name": "Mac",
        "timestamp": 1632348065
    },
    {
        "content": "<p>Note that the topics are not neatly arranged into a dependency hierarchy</p>",
        "id": 254446184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> which makes sense in a monolithic system, not in a system where there may be multiple different variations of the same concept.</p>",
        "id": 254446213,
        "sender_full_name": "Mac",
        "timestamp": 1632348109
    },
    {
        "content": "<p>Those variations need to play well together or else need to be completely separate and never communicate</p>",
        "id": 254446331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348153
    },
    {
        "content": "<p>That's the Coq world, and I actively try to discourage that in lean</p>",
        "id": 254446404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348186
    },
    {
        "content": "<p>incompatible libraries are no fun</p>",
        "id": 254446419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Or, as is more common in programming, they don't play together at all and monkey patching / glue code is written to try to get them to function anyway.</p>",
        "id": 254446421,
        "sender_full_name": "Mac",
        "timestamp": 1632348196
    },
    {
        "content": "<p>Or both libraries get rewritten from scratch to make them work.</p>",
        "id": 254446500,
        "sender_full_name": "Mac",
        "timestamp": 1632348237
    },
    {
        "content": "<p>I consider this a key strength of mathlib</p>",
        "id": 254446519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I know. I do not. We have had this discussion before. Since it is clear we disagree, I am not sure what the point here is (especially since the proposal in question would still support both approaches).</p>",
        "id": 254446670,
        "sender_full_name": "Mac",
        "timestamp": 1632348306
    },
    {
        "content": "<p>As far as I know, lean 4's import mechanism is largely the same as lean 3's, and the fact that <code>import Foo.Bar</code> only imports things in package <code>Foo</code> is exclusively a package manager limitation. I want to lift that limitation</p>",
        "id": 254447086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and as I was previously explaining, that is not the case. It is a property of the current Lean module system. Ask Leo or Sebastian f you want it changed in the short term. I am planning on building modules directly in Lake at some point (without calling out to the Lean binary), in which case I could then maybe alter the import system to do something different (in fact, I have already laid the groundwork on the configuration side to do so), but that is not feasible right now.</p>",
        "id": 254447372,
        "sender_full_name": "Mac",
        "timestamp": 1632348677
    },
    {
        "content": "<p>Are you talking about the compiler symbol issue? Let's assume for the time being that there are no import name clashes anywhere</p>",
        "id": 254447649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348811
    },
    {
        "content": "<p>This is not actually that difficult to ensure in the near to medium term</p>",
        "id": 254447692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348842
    },
    {
        "content": "<p>The main limitation I can see at the moment is that the Data.olean file (say) is generated once and can't be amended, same for the generated c code. But in principle it should be possible to regenerate that based on a computed Data.lean file, which simply imports everything in the Data name hierarchy. This would require some distinction at the file level or in the yet to be designed module system.</p>",
        "id": 254447767,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632348876
    },
    {
        "content": "<p>No, I am talking about the way in which Lean import modules. When Lean elaborates <code>import Foo.Bar</code>, it looks for the file <code>Foo/Bar.olean</code> in a <code>LEAN_PATH</code> directory and enforces that module loaded is named <code>Foo.Bar</code>. In fact, the compiled <code>Foo/Bar.olean</code> includes that its name (and file path) is such, and that information is used for many interactivity features (afaik).</p>",
        "id": 254447893,
        "sender_full_name": "Mac",
        "timestamp": 1632348940
    },
    {
        "content": "<p>okay, that sounds fine</p>",
        "id": 254447981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348974
    },
    {
        "content": "<p>at least as long as we aren't trying to rename modules</p>",
        "id": 254448025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632348999
    },
    {
        "content": "<p>actually even then I think it's fine as long as the true names of the modules don't collide</p>",
        "id": 254448060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349024
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Okay, now I'm confused, what is it that you want then?</p>",
        "id": 254448402,
        "sender_full_name": "Mac",
        "timestamp": 1632349206
    },
    {
        "content": "<p>For the near term? <code>import Foo.Bar</code> looks for <code>Foo/Bar.olean</code> in the <code>LEAN_PATH</code>, which includes all loaded packages. Renames would be nice but let's suppose there aren't any for now. So <code>import Data.Nat.Basic</code> picks up <code>Data/Nat/Basic.olean</code> in <code>mathlib4/src</code> if it is a dependency of the current project</p>",
        "id": 254448720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349407
    },
    {
        "content": "<p>In other words: exactly what lean 3 does</p>",
        "id": 254448760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349433
    },
    {
        "content": "<p>That is what is done? (and what was done in <code>leanpkg</code>?)</p>",
        "id": 254448863,
        "sender_full_name": "Mac",
        "timestamp": 1632349474
    },
    {
        "content": "<p><code>leanpkg</code> has a requirement that everything goes under a <code>Mathlib</code> folder and there exists a <code>Mathlib.lean</code> file that imports everything</p>",
        "id": 254448918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349509
    },
    {
        "content": "<p>Lake allows for an arbitrary <code>srcDir</code>, but you still do need a file that imports everything to build from. That how the build system figures out what packages to build (and it what order).</p>",
        "id": 254449092,
        "sender_full_name": "Mac",
        "timestamp": 1632349584
    },
    {
        "content": "<p>Otherwise, you would have to manual specify each module in the package configuration.</p>",
        "id": 254449166,
        "sender_full_name": "Mac",
        "timestamp": 1632349638
    },
    {
        "content": "<p>in lean 3, you could just build everything in the <code>src/</code> directory</p>",
        "id": 254449169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349641
    },
    {
        "content": "<p>the dependency order sorts itself out because you still have to build dependents first</p>",
        "id": 254449214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349671
    },
    {
        "content": "<p>Note that mathlib4 had to add a CI check to make sure that all files in the directory are imported in the <code>Mathlib.lean</code> file, so this build file is really not doing us any favors</p>",
        "id": 254449607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254448720\">said</a>:</p>\n<blockquote>\n<p>So <code>import Data.Nat.Basic</code> picks up <code>Data/Nat/Basic.olean</code> in <code>mathlib4/src</code> if it is a dependency of the current project</p>\n</blockquote>\n<p>Oh, I missed that you said <code>Data.Nat.Basic</code> and not <code>Mathlib.Nat.Basic</code> (or the like). How is Lake suppose to know that this module is part of mathlib?</p>",
        "id": 254449643,
        "sender_full_name": "Mac",
        "timestamp": 1632349771
    },
    {
        "content": "<p>It just checks for the name in all packages</p>",
        "id": 254449730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349790
    },
    {
        "content": "<p>if the name exists in more than one package, hard error</p>",
        "id": 254449807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349813
    },
    {
        "content": "<p>What if two packages have the a file with the same name. Also that is not really a scalable solution.</p>",
        "id": 254449827,
        "sender_full_name": "Mac",
        "timestamp": 1632349823
    },
    {
        "content": "<p>Sorry, you beat me by a second.</p>",
        "id": 254449848,
        "sender_full_name": "Mac",
        "timestamp": 1632349838
    },
    {
        "content": "<p>sure it is, like I said we can make sure there are no name clashes in the short to medium term</p>",
        "id": 254449864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349847
    },
    {
        "content": "<p>java has managed this for a huge ecosystem using only a style guide (and a penchant for long package names)</p>",
        "id": 254449900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349872
    },
    {
        "content": "<p>Also, how does it know it is not in a non-dependent package (like the Lean core)?</p>",
        "id": 254449925,
        "sender_full_name": "Mac",
        "timestamp": 1632349894
    },
    {
        "content": "<p>I don't understand the question</p>",
        "id": 254449991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632349923
    },
    {
        "content": "<p>If I import <code>Lean.Data.Json</code> (or <code>Std.Data.RBMap</code>, for example, how is Lake suppose to know that said file should not be expected to be in one of the dependent packages?</p>",
        "id": 254450115,
        "sender_full_name": "Mac",
        "timestamp": 1632349996
    },
    {
        "content": "<p>If it exists in lean core, then it does not exist in any dependent packages because import names are unique</p>",
        "id": 254450186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350037
    },
    {
        "content": "<p>Yeah, but how does Lake know what modules are in Lean core (or are otherwise pre-built)?</p>",
        "id": 254450275,
        "sender_full_name": "Mac",
        "timestamp": 1632350072
    },
    {
        "content": "<p>I assume you know what packages are available and what import names they contribute?</p>",
        "id": 254450335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350113
    },
    {
        "content": "<p>No?</p>",
        "id": 254450354,
        "sender_full_name": "Mac",
        "timestamp": 1632350124
    },
    {
        "content": "<p>In any case, the build tool doesn't really have to figure this out, it just points lean at all of the packages and lets lean do the work</p>",
        "id": 254450447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350167
    },
    {
        "content": "<p>unless I misunderstand the workflow</p>",
        "id": 254450465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350182
    },
    {
        "content": "<p>The build tool needs to know what modules to build and which to already expect to be built. Currently this is done by analyzing the recursive imports of the module root and building those modules which are submodules of said root.</p>",
        "id": 254450553,
        "sender_full_name": "Mac",
        "timestamp": 1632350245
    },
    {
        "content": "<p>You could do this less intelligently by manually specifying this for each possible import, but that does not seem feasible.</p>",
        "id": 254450664,
        "sender_full_name": "Mac",
        "timestamp": 1632350305
    },
    {
        "content": "<p>the lean 3 version of that is that you build all <code>*.lean</code> files in the <code>src/</code> directory that aren't already built</p>",
        "id": 254450725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350346
    },
    {
        "content": "<p>so you can make a list of all those import names and any name appearing in a <code>import ...</code> that isn't in the list doesn't need to be built</p>",
        "id": 254450781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350382
    },
    {
        "content": "<p>That is because Lean 3 is interpreted -- it interprets its imports on the fly. Lean 4 is not, the imports need to be pre-built.</p>",
        "id": 254450789,
        "sender_full_name": "Mac",
        "timestamp": 1632350386
    },
    {
        "content": "<p>You still look at lean files to find the dependencies, though?</p>",
        "id": 254450860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350413
    },
    {
        "content": "<p>so if the <code>src/</code> directory has <code>Foo/Bar.lean</code> and <code>Foo2/Baz.lean</code> then you expect to build some subset of <code>Foo.Bar</code> and <code>Foo2.Baz</code>, and by looking at the imports of these files you learn which to build first</p>",
        "id": 254450961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350489
    },
    {
        "content": "<p>Yes, in the build tool. But the build tool is not building every module, unlike in Lean 3, where the interpreter was interpreting every module. As such, the build tool needs to know which modules to build and which to not (i.e., which to expect to have already been provided as pre-packaged <code>.olean</code>s).</p>",
        "id": 254450983,
        "sender_full_name": "Mac",
        "timestamp": 1632350508
    },
    {
        "content": "<p>if it's not on the list of things to build, then it is expected to be provided upstream</p>",
        "id": 254451188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350557
    },
    {
        "content": "<p>However, yes <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, and alternate strategy that relies entirely an what files are in the source directory would be possible.</p>",
        "id": 254451284,
        "sender_full_name": "Mac",
        "timestamp": 1632350592
    },
    {
        "content": "<p>My point earlier was that even if the build tool doesn't rely on the contents of the source directory, we will need to hack around it so that it does</p>",
        "id": 254451319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254451188\">said</a>:</p>\n<blockquote>\n<p>if it's not on the list of things to build, then it is expected to be provided upstream</p>\n</blockquote>\n<p>The question here is where to get that list from.</p>",
        "id": 254451379,
        "sender_full_name": "Mac",
        "timestamp": 1632350647
    },
    {
        "content": "<p>because this is likely to be an error from contributors</p>",
        "id": 254451402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> so, shouldn't that be a problem resolved by mathlib then (if it means a contributor made an error)?</p>",
        "id": 254451408,
        "sender_full_name": "Mac",
        "timestamp": 1632350673
    },
    {
        "content": "<p>It's not really a mathlib specific problem</p>",
        "id": 254451463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350719
    },
    {
        "content": "<p>You probably don't want a build to spuriously succeed when there are errors in unimported files</p>",
        "id": 254451485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350740
    },
    {
        "content": "<p>It seems perfectly reasonable to expect a library to provide a module that imports everything the library provides.</p>",
        "id": 254451562,
        "sender_full_name": "Mac",
        "timestamp": 1632350766
    },
    {
        "content": "<p>maybe the library can provide that if it wants, but it's not obvious to me that all libraries should be built like that</p>",
        "id": 254451596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350799
    },
    {
        "content": "<p>most of the time the library allows ways to import specific parts of interest</p>",
        "id": 254451646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632350833
    },
    {
        "content": "<p>Why not? I would expect to be able to import a library in its entirety -- the only case where this is less than desirable would be in libraries that are not, in fact, a single library, but are instead a conglomeration of multiple relevantly distinct sub libraries. In which case they should be packaged separately.</p>",
        "id": 254451764,
        "sender_full_name": "Mac",
        "timestamp": 1632350907
    },
    {
        "content": "<p>I notice my comment above about python namespace packages was ignored, so this comparison may not be helpful here; but <code>scipy</code> behaves in the way Mario describes</p>",
        "id": 254451806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632350936
    },
    {
        "content": "<p>There is no one \"import all of SciPy\" file, because that's not a sensible thing to do</p>",
        "id": 254451839,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632350965
    },
    {
        "content": "<p>You have to import the components you care about like <code>scipy.stats</code> and <code>scipy.signal</code> separately.</p>",
        "id": 254451950,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351016
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <code>scipy</code> has an <code>__init__.py</code> which is exactly that module (in Python).</p>",
        "id": 254451987,
        "sender_full_name": "Mac",
        "timestamp": 1632351037
    },
    {
        "content": "<p>No it's not</p>",
        "id": 254452000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351046
    },
    {
        "content": "<p>Because it doesn't import those submodules</p>",
        "id": 254452036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351067
    },
    {
        "content": "<p>It's the place that <em>could</em> contain that behavior, but by a conscious choice does not.</p>",
        "id": 254452074,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> well yes, but that is due to how Python's module system works, it unifies the entire directory structure into a module so you don't have to do such specification manually.</p>",
        "id": 254452091,
        "sender_full_name": "Mac",
        "timestamp": 1632351114
    },
    {
        "content": "<p>Unlike, for example, JS, where you would.</p>",
        "id": 254452214,
        "sender_full_name": "Mac",
        "timestamp": 1632351168
    },
    {
        "content": "<p>Which is exactly what lean3 does too (replacing <code>__init__.py</code> with <code>default.lean</code>), right?</p>",
        "id": 254452234,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> sort of. However, there is a major distinction. In Lean importing <code>Foo</code> for a directory  <code>Foo</code> only imports the <code>default.lean</code>. In Python, importing <code>Foo</code> would import the entire directory structure recursively.</p>",
        "id": 254452416,
        "sender_full_name": "Mac",
        "timestamp": 1632351270
    },
    {
        "content": "<p>That's also false</p>",
        "id": 254452442,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351286
    },
    {
        "content": "<p><code>import Foo</code> only runs <code>Foo/__init__.py</code> - <code>assert \"Foo.Bar\" not in sys.modules</code> proves that.</p>",
        "id": 254452492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351310
    },
    {
        "content": "<p>I may be mistaken, Python is mostly certainly not may language of choice, so I am not an expert, but I am pretty sure that after an <code>import scipy</code>, for example, you could refer to <code>scipu.odr.models.polynomial</code>.</p>",
        "id": 254452646,
        "sender_full_name": "Mac",
        "timestamp": 1632351396
    },
    {
        "content": "<p>Only if <code>__init__.py</code> contains <code>import .odr</code></p>",
        "id": 254452706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351431
    },
    {
        "content": "<p>are you sure?</p>",
        "id": 254452770,
        "sender_full_name": "Mac",
        "timestamp": 1632351481
    },
    {
        "content": "<p>Yes</p>",
        "id": 254452818,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351487
    },
    {
        "content": "<p>Welp, guess I was wrong, that was not my understanding.</p>",
        "id": 254452922,
        "sender_full_name": "Mac",
        "timestamp": 1632351547
    },
    {
        "content": "<p>(And it's very much stylistically discouraged to do this in Python -- i.e. if you're a package author, you should not import all your submodules in your <code>__init__.pys</code>) And similarly for users of modules, they should not use <code>import foo</code> and rely on <code>foo.bar</code> being imported just because <code>foo</code> happens to do so for its own reasons.</p>",
        "id": 254452964,
        "sender_full_name": "Julian Berman",
        "timestamp": 1632351578
    },
    {
        "content": "<p>It should be noted, though, that appealing to Python is not a great way to convince me of something, as it is my most hated language. XD</p>",
        "id": 254453165,
        "sender_full_name": "Mac",
        "timestamp": 1632351645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254452770\">said</a>:</p>\n<blockquote>\n<p>are you sure?</p>\n</blockquote>\n<p>this becomes really important for python libraries that bind to large c++ libraries, which take a significant amount of time to import and resolve symbols. We structure our wrapping code in the same way, the base python module certainly doesn't import all submodules.</p>",
        "id": 254453183,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632351658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> then what is the point of the base module then?</p>",
        "id": 254453376,
        "sender_full_name": "Mac",
        "timestamp": 1632351743
    },
    {
        "content": "<p>Namespacing, mainly</p>",
        "id": 254453397,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351763
    },
    {
        "content": "<p>why not just import the submodules?</p>",
        "id": 254453398,
        "sender_full_name": "Mac",
        "timestamp": 1632351763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254453376\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130511\">Christian Pehle</span> then what is the point of the base module then?</p>\n</blockquote>\n<p>In order to organise everything under a common name</p>",
        "id": 254453405,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632351768
    },
    {
        "content": "<p>like in the scipy example.</p>",
        "id": 254453488,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632351814
    },
    {
        "content": "<p>But why does that name need to be importable then?</p>",
        "id": 254453501,
        "sender_full_name": "Mac",
        "timestamp": 1632351821
    },
    {
        "content": "<blockquote>\n<p>I notice my comment above about python namespace packages was ignored, so this comparison may not be helpful here; but scipy behaves in the way Mario describes</p>\n</blockquote>\n<p>I didn't see your comment until now, and maybe this isn't relevant for Lean but IMO namespace packages would be much more popular in Python if we hadn't botched their implementation for the first 10 years they existed -- everyone was scarred by how broken they were that by the time they worked folks had learned not to use them. But for a new language I'd certainly expect namespace package-like functionality to be useful personally.</p>",
        "id": 254453510,
        "sender_full_name": "Julian Berman",
        "timestamp": 1632351824
    },
    {
        "content": "<p>Sometimes <code>mypackage/__init__.py</code> contains little more than <code>mypackage.__version__</code> and a docstring.</p>",
        "id": 254453525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Also note that I didn't answer your question directly because <span class=\"user-mention\" data-user-id=\"130511\">@Christian Pehle</span> asked a similar question right below it and I ended up responding to him.</p>",
        "id": 254453682,
        "sender_full_name": "Mac",
        "timestamp": 1632351895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>: especially since lean 3 has exactly this namespace package behavior already</p>",
        "id": 254453701,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632351903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254453501\">said</a>:</p>\n<blockquote>\n<p>But why does that name need to be importable then?</p>\n</blockquote>\n<p>well it might only import some of the functionality and not others, this would be library specific. for example you might decide to make common functionality available and not import certain other functionality by default.</p>",
        "id": 254453726,
        "sender_full_name": "Christian Pehle",
        "timestamp": 1632351912
    },
    {
        "content": "<p>I think <code>import tactic</code> is like this</p>",
        "id": 254453787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632351935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> And for the record, my response was that this proposal and Lake at the moment support such a thing already.</p>",
        "id": 254453788,
        "sender_full_name": "Mac",
        "timestamp": 1632351936
    },
    {
        "content": "<p>it imports most but not all of the things in <code>tactic.*</code></p>",
        "id": 254453809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632351947
    },
    {
        "content": "<p>But what if I <em>want</em> to import everything, it seems perfectly reasonable to ask for clean way to do this from a library.</p>",
        "id": 254453929,
        "sender_full_name": "Mac",
        "timestamp": 1632351994
    },
    {
        "content": "<p>What's the line of reasoning for wanting to import everything?</p>",
        "id": 254454011,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632352048
    },
    {
        "content": "<p>Is it because of things like simp and library_search?</p>",
        "id": 254454124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632352104
    },
    {
        "content": "<p>The build tool can handle construction of an exhaustive import, this is what <code>leanproject mk-all</code> is for</p>",
        "id": 254454259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632352198
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Yeah, those are good examples. It is also useful if is just trying to whip a quick example / test and doesn't want to go hunt down where something comes from.</p>",
        "id": 254454263,
        "sender_full_name": "Mac",
        "timestamp": 1632352200
    },
    {
        "content": "<p>but I don't think such imports should ever be used by users. The library author is responsible for providing convenient entry points to the API, which may or may not coincide with importing literally everything</p>",
        "id": 254454412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632352263
    },
    {
        "content": "<p>I mostly disagree and from the initial design of Lean 4's build system it seems like the devs did to. However, I can see the merit in a alternatively build strategy that just builds everything in the source dir. So I will put that in the TODOs.</p>",
        "id": 254454603,
        "sender_full_name": "Mac",
        "timestamp": 1632352377
    },
    {
        "content": "<p>In fact, it was already in my list of ideas, I just didn't rate it highly as it was not part of the original build system and it would require a somewhat significant overhaul.</p>",
        "id": 254454805,
        "sender_full_name": "Mac",
        "timestamp": 1632352485
    },
    {
        "content": "<p>What's the downside of building everything in the source dir?</p>",
        "id": 254454915,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632352557
    },
    {
        "content": "<p>(other than not having an implementation of it yet!)</p>",
        "id": 254454985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632352581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> you way wish to conditionally compile files based on what target you are building. For example, the binary may use some files from the source directory while the library uses others.</p>",
        "id": 254455095,
        "sender_full_name": "Mac",
        "timestamp": 1632352669
    },
    {
        "content": "<p>For example, mathport probably doesn't want its binary being shipped with its library.</p>",
        "id": 254455191,
        "sender_full_name": "Mac",
        "timestamp": 1632352716
    },
    {
        "content": "<p>Right now, the mathport binary is in a completely separate package from the library. I consider this a suboptimal solution</p>",
        "id": 254455410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632352854
    },
    {
        "content": "<p>From what understand, <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> was working on changing that (as Lake already supports an alternate binary root from the main library root).</p>",
        "id": 254455478,
        "sender_full_name": "Mac",
        "timestamp": 1632352906
    },
    {
        "content": "<p>That's what I mean, that was the change</p>",
        "id": 254455494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632352920
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 254455557,
        "sender_full_name": "Mac",
        "timestamp": 1632352945
    },
    {
        "content": "<p>It was previously in one directory, now everything is in a further <code>Lib/</code> directory and I can't open <code>mathport</code> anymore and browse around in vscode</p>",
        "id": 254455573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632352962
    },
    {
        "content": "<p>No, I was saying that he was working on merging it back into one directory (using Lake's support for alternate binary roots).</p>",
        "id": 254455607,
        "sender_full_name": "Mac",
        "timestamp": 1632352987
    },
    {
        "content": "<p>It should be fully possible to do so with the current Lake.</p>",
        "id": 254455714,
        "sender_full_name": "Mac",
        "timestamp": 1632353057
    },
    {
        "content": "<p>At the moment, the app is at <code>App/MathportApp.lean</code> and everything else is in <code>Lib/Mathport/*.lean</code></p>",
        "id": 254455727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632353069
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I tried to get your \"one-package\" solution to work for mathport but (caveat: I didn't try hard at all) wasn't able to get the imports to work cleanly, i.e. to avoid an extra layer e.g. <code>Lib.</code>. I would happily merge a mathport PR that makes it one-package if the imports stay mostly the same.</p>",
        "id": 254455742,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353078
    },
    {
        "content": "<p>that extra layer is exactly why I think tying the import name to the package name is a bad idea</p>",
        "id": 254455914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632353168
    },
    {
        "content": "<p>because now we would need <code>import MathportLib.*</code> and <code>import MathportApp.*</code></p>",
        "id": 254455933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632353192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254455933\">said</a>:</p>\n<blockquote>\n<p>because now we would need <code>import MathportLib.*</code> and <code>import MathportApp.*</code></p>\n</blockquote>\n<p>Right now \"MathportLib\" is just called <code>Mathport</code>, and the point of <code>MathportApp</code> is that it never gets imported.</p>",
        "id": 254455983,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353236
    },
    {
        "content": "<p>You use emacs so the experience might be different, but in vscode I have the issue since the refactor that opening the <code>mathport</code> directory doesn't let me browse lean files anymore, it can't resolve the imports</p>",
        "id": 254456111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632353321
    },
    {
        "content": "<p>I have to open the <code>Lib</code> directory instead</p>",
        "id": 254456132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632353333
    },
    {
        "content": "<p>While the three of us are here -- it is time for <code>Mathport</code> (the library, which uses <code>lake</code>) to depend on <code>Mathlib4</code> (which uses <code>leanpkg</code>). Should I just swap out <code>leanpkg</code> for <code>lake</code> in a fork for now, or PR the swap?</p>",
        "id": 254456135,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I imagine that is because there is not yet support for <code>lake</code> in VSCode?</p>",
        "id": 254456196,
        "sender_full_name": "Mac",
        "timestamp": 1632353380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254456132\">said</a>:</p>\n<blockquote>\n<p>I have to open the <code>Lib</code> directory instead</p>\n</blockquote>\n<p>Ah, I have not had a similar issue in Emacs. I don't know enough about VSCode to know if there is any easy fix for that.</p>",
        "id": 254456203,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> I get the following error when trying to build mathport:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">.\\.\\</span><span class=\"n\">Mathport</span><span class=\"bp\">\\</span><span class=\"n\">Prelude</span><span class=\"bp\">\\</span><span class=\"n\">Syntax.lean</span><span class=\"o\">:</span><span class=\"mi\">154</span><span class=\"o\">:</span><span class=\"mi\">35</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>Do you know why this might be?</p>",
        "id": 254456349,
        "sender_full_name": "Mac",
        "timestamp": 1632353472
    },
    {
        "content": "<p>Probably a lean4 version issue. <code>allGoals</code> was changed relatively recently to <code>all_goals</code>.</p>",
        "id": 254456453,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353532
    },
    {
        "content": "<p>ah, yep that is likely it</p>",
        "id": 254456484,
        "sender_full_name": "Mac",
        "timestamp": 1632353567
    },
    {
        "content": "<p>I forgot to update the version in the <code>lean-toolchain</code> file.</p>",
        "id": 254456513,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353590
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I just pushed a change to use the most recently nightly. I don't know how to even check that it works though -- do you mind pulling and seeing if it builds?</p>",
        "id": 254456665,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353697
    },
    {
        "content": "<p>fyi, the most recently nightly is 09-22</p>",
        "id": 254456726,
        "sender_full_name": "Mac",
        "timestamp": 1632353753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254456726\">said</a>:</p>\n<blockquote>\n<p>fyi, the most recently nightly is 09-22</p>\n</blockquote>\n<p>thanks, force-pushed</p>",
        "id": 254456966,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632353925
    },
    {
        "content": "<p>ah, I was waiting for the snake case naming change to land on nightly before updating mathport</p>",
        "id": 254457182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632354078
    },
    {
        "content": "<p>Just checking, <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> , mathport builds consistently on your machine with Lake currently?</p>",
        "id": 254458589,
        "sender_full_name": "Mac",
        "timestamp": 1632355143
    },
    {
        "content": "<p>I am encountering the errors you mentioned but, oddly, just repeating the build multiple resolves them. This makes me suspect it is some race condition (i.e., some bug in Lake build ordering).</p>",
        "id": 254458975,
        "sender_full_name": "Mac",
        "timestamp": 1632355347
    },
    {
        "content": "<p>I just downloaded <code>lake</code> and building mathport seems to work, although vscode doesn't work in the <code>Lib</code> folder either right now</p>",
        "id": 254459031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632355393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254458589\">said</a>:</p>\n<blockquote>\n<p>Just checking, <span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> , mathport builds consistently on your machine with Lake currently?</p>\n</blockquote>\n<p>Yes, mathport builds consistently on my machine. It takes a long time though due to some gnarly mutual inductives.</p>",
        "id": 254459038,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632355404
    },
    {
        "content": "<p>I haven't updated <code>lake</code> in a while though.</p>",
        "id": 254459068,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632355420
    },
    {
        "content": "<p>On the other hand, it seems like a Lean problem because it ends up with errors like \"unknown namespace Lean\" which should not be something Lake could make disappear.</p>",
        "id": 254459349,
        "sender_full_name": "Mac",
        "timestamp": 1632355591
    },
    {
        "content": "<p>does <code>lake</code> interoperate with the lean server mode at all? It seems to not know what to do at all without a <code>leanpkg.toml</code> file</p>",
        "id": 254459369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632355602
    },
    {
        "content": "<p>I haven't tested this, but you might be able to set the <code>leanpkg</code> executable for VS Code to <code>lake</code> and make it work.</p>",
        "id": 254459442,
        "sender_full_name": "Mac",
        "timestamp": 1632355652
    },
    {
        "content": "<p>The lean server / vscode extension should be able to recognize either the lake config file or a file generated by lake</p>",
        "id": 254459446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632355653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I don't think my lean4 version is exactly tonight's nightly. I forget how to find the commit hash for a given nightly -- what commit exactly are you using?</p>",
        "id": 254459547,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632355712
    },
    {
        "content": "<p>The one you pushed to the repo :)</p>",
        "id": 254459574,
        "sender_full_name": "Mac",
        "timestamp": 1632355737
    },
    {
        "content": "<p>Can you remind me how I find out what commit number that is? I don't use the nightly stuff, I build lean locally.</p>",
        "id": 254459619,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632355787
    },
    {
        "content": "<p>note that the next nightly is currently in progress (it runs at 5 PM PST)</p>",
        "id": 254459629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632355796
    },
    {
        "content": "<p>This is 09-22 nightly -&gt; <a href=\"https://github.com/leanprover/lean4/actions/runs/1259774217\">https://github.com/leanprover/lean4/actions/runs/1259774217</a></p>",
        "id": 254459675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632355811
    },
    {
        "content": "<p>Thanks, I found it. The \"CI\" action.</p>",
        "id": 254459699,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632355836
    },
    {
        "content": "<p>search for \"scheduled\" actions</p>",
        "id": 254459716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632355852
    },
    {
        "content": "<p>no, that is actually the 09-23 nightly</p>",
        "id": 254459895,
        "sender_full_name": "Mac",
        "timestamp": 1632355984
    },
    {
        "content": "<p>nightlies are named after the following day in Lean (from a US perspective)</p>",
        "id": 254459911,
        "sender_full_name": "Mac",
        "timestamp": 1632355997
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> could you try to clone and build <a href=\"https://github.com/tydeu/mathport\">https://github.com/tydeu/mathport</a> (by running <code>lake build-bin</code> in <code>Lib</code>) -- I am curious if you get the same errors I am.</p>",
        "id": 254460025,
        "sender_full_name": "Mac",
        "timestamp": 1632356077
    },
    {
        "content": "<p>Why are you building <code>bin</code> there?</p>",
        "id": 254460057,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356103
    },
    {
        "content": "<p>the action I pointed to ran yesterday</p>",
        "id": 254460061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356104
    },
    {
        "content": "<p>Here is my mathport meta-build process: <a href=\"https://github.com/leanprover/mathport/blob/master/Makefile#L3-L9\">https://github.com/leanprover/mathport/blob/master/Makefile#L3-L9</a></p>",
        "id": 254460088,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ah, sorry, my bad</p>",
        "id": 254460104,
        "sender_full_name": "Mac",
        "timestamp": 1632356138
    },
    {
        "content": "<p>Oh and I just found out a non-hacky way of dealing with the <code>cd Lib &amp;&amp;</code>. I will fix.</p>",
        "id": 254460184,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356166
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> ah, that is still equivalent to just running the build from <code>Lib</code> right?</p>",
        "id": 254460194,
        "sender_full_name": "Mac",
        "timestamp": 1632356170
    },
    {
        "content": "<p>Yes, <code>lake build-lib</code> in <code>Lib</code>.</p>",
        "id": 254460216,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356184
    },
    {
        "content": "<p>Ah I merged the bin and lib and wanted to see if it would work for you</p>",
        "id": 254460241,
        "sender_full_name": "Mac",
        "timestamp": 1632356203
    },
    {
        "content": "<p>but you still have a <code>Lib</code> folder?</p>",
        "id": 254460288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> FYI leanprover/mathport/master builds fine for me on 6a880fecc996, which I think is the nightly in the tool file.</p>",
        "id": 254460289,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356242
    },
    {
        "content": "<p>I missed the fact that there was a Makefile. XD</p>",
        "id": 254460292,
        "sender_full_name": "Mac",
        "timestamp": 1632356247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> exactly, hence why I wanted you to try build my change</p>",
        "id": 254460311,
        "sender_full_name": "Mac",
        "timestamp": 1632356270
    },
    {
        "content": "<p>I understand now, I am building your project.</p>",
        "id": 254460378,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> you should try dumping everything in your <code>Lib/</code> folder in the root and try to make it work that way</p>",
        "id": 254460386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356307
    },
    {
        "content": "<p>that was roughly what the directory hierarchy looked like a month ago</p>",
        "id": 254460410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356333
    },
    {
        "content": "<p>sure, but first I just wanted to see if <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> got the same errors I do to see if this was just a problem with my setup (which I suspect it may be).</p>",
        "id": 254460437,
        "sender_full_name": "Mac",
        "timestamp": 1632356358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Beautiful. It works. Having both lean files in the same directory is the \"trick\" I overlooked.</p>",
        "id": 254460522,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356404
    },
    {
        "content": "<p>Let me confirm that I can import the Library from another executable...</p>",
        "id": 254460564,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356449
    },
    {
        "content": "<p>Yeah, that is a requirement that is enforced by Lean.</p>",
        "id": 254460567,
        "sender_full_name": "Mac",
        "timestamp": 1632356452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254459442\">said</a>:</p>\n<blockquote>\n<p>I haven't tested this, but you might be able to set the <code>leanpkg</code> executable for VS Code to <code>lake</code> and make it work.</p>\n</blockquote>\n<p>This didn't work for me, I still get the same error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unknown</span> <span class=\"n\">package</span> <span class=\"bp\">'</span><span class=\"n\">Mathport'</span>\n<span class=\"n\">You</span> <span class=\"n\">might</span> <span class=\"n\">need</span> <span class=\"n\">to</span> <span class=\"kn\">open</span> <span class=\"bp\">'/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">mario</span><span class=\"bp\">/</span><span class=\"n\">Documents</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">mathport</span><span class=\"bp\">/</span><span class=\"n\">Lib'</span> <span class=\"n\">as</span> <span class=\"n\">a</span> <span class=\"n\">workspace</span> <span class=\"k\">in</span> <span class=\"n\">your</span> <span class=\"n\">editor</span>\n</code></pre></div>\n<p>(this is when the <code>Lib</code> folder is open as the root and opening a random mathport file that imports another one)</p>",
        "id": 254460654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254460564\">said</a>:</p>\n<blockquote>\n<p>Let me confirm that I can import the Library from another executable...</p>\n</blockquote>\n<p>It works. <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Thanks for your help! I will refactor Mathport now (as Mario suggests, with both lean files in the root dir).</p>",
        "id": 254460739,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632356565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> are you on windows?</p>",
        "id": 254460762,
        "sender_full_name": "Mac",
        "timestamp": 1632356592
    },
    {
        "content": "<p>linux</p>",
        "id": 254460772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356603
    },
    {
        "content": "<p>Oh,  I noticed you were talking about the editor -- yeah that happens to me as well.</p>",
        "id": 254460788,
        "sender_full_name": "Mac",
        "timestamp": 1632356631
    },
    {
        "content": "<p>What are the plans for making editor usage work? If possible, we should not need to require that a particular folder is open as root</p>",
        "id": 254460916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356728
    },
    {
        "content": "<p>lean 3 walked up the folder hierarchy to find a <code>leanpkg.path</code> file which determined the root, as well as import resolution</p>",
        "id": 254460999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356763
    },
    {
        "content": "<p>(needless to say, this is pretty high priority breakage for me - I can't really imagine using lean non-interactively)</p>",
        "id": 254461104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632356867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you need to point your LEAN_PATH at the build directory (i.e., <code>Lib/build/lib</code>)</p>",
        "id": 254461225,
        "sender_full_name": "Mac",
        "timestamp": 1632356964
    },
    {
        "content": "<p>This is editor usage we're talking about here, there is no manual LEAN_PATH</p>",
        "id": 254461311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you can have a setting like the following in your <code>.vscode/settings.json</code></p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n  <span class=\"nt\">\"lean4.serverEnv\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"LEAN_PATH\"</span><span class=\"p\">:</span> <span class=\"s2\">\"./Lib/build/lib\"</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 254461394,
        "sender_full_name": "Mac",
        "timestamp": 1632357073
    },
    {
        "content": "<p>is that being committed?</p>",
        "id": 254461417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357090
    },
    {
        "content": "<p>It could be?</p>",
        "id": 254461444,
        "sender_full_name": "Mac",
        "timestamp": 1632357111
    },
    {
        "content": "<p>maybe <code>lake config-vscode</code> can add this setting as appropriate?</p>",
        "id": 254461547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357171
    },
    {
        "content": "<p>The problem is that Lake is not yet following integrated with Lean, so the Lean server is still using <code>leanpkg</code>.</p>",
        "id": 254461564,
        "sender_full_name": "Mac",
        "timestamp": 1632357185
    },
    {
        "content": "<p>it still seems kind of unfortunate</p>",
        "id": 254461568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357189
    },
    {
        "content": "<p>What is the perfect world version of integration here?</p>",
        "id": 254461585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357207
    },
    {
        "content": "<p>Well the first step is this: <a href=\"https://github.com/leanprover/lean4/pull/683\">https://github.com/leanprover/lean4/pull/683</a></p>",
        "id": 254461688,
        "sender_full_name": "Mac",
        "timestamp": 1632357276
    },
    {
        "content": "<p>Lake will soon be bundled and distributed with Lean instead of leanpkg</p>",
        "id": 254461711,
        "sender_full_name": "Mac",
        "timestamp": 1632357291
    },
    {
        "content": "<p>I set the leanpkg path to <code>lake</code> but I noticed that this setting is called <code>lean.leanpkgPath</code> instead of <code>lean4.leanpkgPath</code> so probably it's not the right setting</p>",
        "id": 254461713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357293
    },
    {
        "content": "<p>oh, so that might be arriving in today's nightly?</p>",
        "id": 254461774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357342
    },
    {
        "content": "<p>You are right, in Lean 4, <code>leanpkg</code> is just currently hard coded into the server</p>",
        "id": 254461793,
        "sender_full_name": "Mac",
        "timestamp": 1632357356
    },
    {
        "content": "<p>I will try symlinking it</p>",
        "id": 254461855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357376
    },
    {
        "content": "<p>Note that the lean server uses the <code>leanpkg</code> in its direct not the one from <code>PATH</code></p>",
        "id": 254461907,
        "sender_full_name": "Mac",
        "timestamp": 1632357416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254461104\">said</a>:</p>\n<blockquote>\n<p>(needless to say, this is pretty high priority breakage for me - I can't really imagine using lean non-interactively)</p>\n</blockquote>\n<p>FYI when I use mathported packages, I just set my LEAN_PATH manually and it works for both Emacs and VSCode. Specifically, I have <code>MATHPORT_PATH</code> in my <code>.bashrc</code> and then just type <code>LEAN_PATH=$MATHPORT_PATH code &amp;</code> or whatever. I agree it would be great if this were easy &amp; automatic for normal lake projects, but the fallback needn't be using Lean non-interactively.</p>",
        "id": 254461950,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632357465
    },
    {
        "content": "<p>hm, <code>env LEAN_PATH=Lib/build/Mathport code .</code> from the project root isn't working for me</p>",
        "id": 254462328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357733
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254461774\">said</a>:</p>\n<blockquote>\n<p>oh, so that might be arriving in today's nightly?</p>\n</blockquote>\n<p>Ah no, it is a draft PR after all, but I imagine it will probably there in a week or so.</p>",
        "id": 254462333,
        "sender_full_name": "Mac",
        "timestamp": 1632357735
    },
    {
        "content": "<p>How about a patch to the extension to add the <code>leanpkgPath</code> option?</p>",
        "id": 254462360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632357761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254462328\">said</a>:</p>\n<blockquote>\n<p>hm, <code>env LEAN_PATH=Lib/build/Mathport code .</code> from the project root isn't working for me</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">LEAN_PATH</span><span class=\"bp\">=&lt;</span><span class=\"n\">package</span><span class=\"bp\">-</span><span class=\"n\">root</span><span class=\"bp\">&gt;/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"o\">:</span><span class=\"bp\">&lt;</span><span class=\"n\">other</span><span class=\"bp\">-</span><span class=\"n\">package</span><span class=\"bp\">-</span><span class=\"n\">root</span><span class=\"bp\">&gt;/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span>\n</code></pre></div>",
        "id": 254462398,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632357802
    },
    {
        "content": "<p>Also I pushed the refactor, so this should be moot for now. Can you confirm that everything works smoothly once you pull <a href=\"https://github.com/leanprover/mathport/commit/b7481b0814b53e198cdc63f6b57a9e08854c116f\">https://github.com/leanprover/mathport/commit/b7481b0814b53e198cdc63f6b57a9e08854c116f</a>?</p>",
        "id": 254462478,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632357855
    },
    {
        "content": "<p>things look good with <code>env LEAN_PATH=&lt;root&gt;/build/lib code .</code></p>",
        "id": 254462872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358160
    },
    {
        "content": "<p>although I can't open <code>package.lean</code> because of <code>import Lake.*</code></p>",
        "id": 254462928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358203
    },
    {
        "content": "<p>I guess that can't be fixed until <code>Lake</code> is packaged with the standard distribution?</p>",
        "id": 254463039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358277
    },
    {
        "content": "<p>you could add lake's build dir to the <code>LEAN_PATH</code> as well</p>",
        "id": 254463066,
        "sender_full_name": "Mac",
        "timestamp": 1632358301
    },
    {
        "content": "<p>you can always concatenate <del><code>&lt;lake-root&gt;/build/lib</code></del> <code>&lt;lake-root&gt;/build</code> to LEAN_PATH as well</p>",
        "id": 254463078,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1632358314
    },
    {
        "content": "<p>actually it would just be <code>&lt;lake-root&gt;/build</code> (as Lake is built with <code>leanmake</code>)</p>",
        "id": 254463153,
        "sender_full_name": "Mac",
        "timestamp": 1632358348
    },
    {
        "content": "<p>Just to give an idea of what this RFC was originally about, the idea is that instead of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">package</span> <span class=\"o\">:</span> <span class=\"n\">Lake.PackageConfig</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Mathport\"</span>\n  <span class=\"n\">version</span> <span class=\"o\">:=</span> <span class=\"s2\">\"0.1\"</span>\n  <span class=\"n\">binRoot</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">MathportApp</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>you would just have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">package</span> <span class=\"o\">:</span> <span class=\"n\">Lake.PackageConfig</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">moduleRoot</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Mathport</span>\n  <span class=\"n\">binRoot</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">MathportApp</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 254463205,
        "sender_full_name": "Mac",
        "timestamp": 1632358407
    },
    {
        "content": "<p>what if that was <code>moduleRoots</code> and took a list of module names?</p>",
        "id": 254463359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358542
    },
    {
        "content": "<p>or a glob</p>",
        "id": 254463373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> multiple module roots is certainly feasible. In fact, the single root is actually a special case of a multi root function.</p>",
        "id": 254463518,
        "sender_full_name": "Mac",
        "timestamp": 1632358656
    },
    {
        "content": "<p>with a glob you can get the \"build everything in the directory\" behavior</p>",
        "id": 254463541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358678
    },
    {
        "content": "<p>yeah, but that would require some support in Lean for globs XD</p>",
        "id": 254463593,
        "sender_full_name": "Mac",
        "timestamp": 1632358700
    },
    {
        "content": "<p>no, I'm thinking that you interpret the glob yourself</p>",
        "id": 254463602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358713
    },
    {
        "content": "<p>also, the idea is that is suppose to be a module <code>Name</code>, not a <code>String</code>.</p>",
        "id": 254463614,
        "sender_full_name": "Mac",
        "timestamp": 1632358723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> sure, of course, I could do that</p>",
        "id": 254463652,
        "sender_full_name": "Mac",
        "timestamp": 1632358750
    },
    {
        "content": "<p>Having built in lean support for <code>import tactic.*</code> would be interesting, but probably isn't needed in the short term</p>",
        "id": 254463691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358795
    },
    {
        "content": "<p>oh, I didn't mean globs in imports, I meant globs in a string (i.e., in <code>IO</code> to find files).</p>",
        "id": 254463834,
        "sender_full_name": "Mac",
        "timestamp": 1632358855
    },
    {
        "content": "<p>Having to write one of my own makes such a request considerably more work</p>",
        "id": 254463879,
        "sender_full_name": "Mac",
        "timestamp": 1632358904
    },
    {
        "content": "<p>That is, you would have <code>moduleRoots := [`Mathport.*]</code> and it would get everything in the mathport directory</p>",
        "id": 254463916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358922
    },
    {
        "content": "<p>maybe that doesn't work because <code>*</code> is not an identifier char</p>",
        "id": 254463961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358967
    },
    {
        "content": "<p>but it would work with strings</p>",
        "id": 254463973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632358982
    },
    {
        "content": "<p>That would require either that name literals support globs or the creation of my own new <code>Name</code> type and syntax -- again more work that I am not sure I would like to invest in at the moment</p>",
        "id": 254463989,
        "sender_full_name": "Mac",
        "timestamp": 1632359001
    },
    {
        "content": "<p>or you could have an inductive type <code>NameOrGlob</code> with a coercion for <code>Name</code> and a function <code>glob `Mathport</code>  to mean <code>Mathport.*</code></p>",
        "id": 254464054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359053
    },
    {
        "content": "<p>Anyway, the point of this RFC is just whether removing the version field and potentially merging name with module root are okay ideas.</p>",
        "id": 254464060,
        "sender_full_name": "Mac",
        "timestamp": 1632359058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  again, very true</p>",
        "id": 254464076,
        "sender_full_name": "Mac",
        "timestamp": 1632359086
    },
    {
        "content": "<p>though at that point it would not be a list of module roots, but rather a list of modules</p>",
        "id": 254464098,
        "sender_full_name": "Mac",
        "timestamp": 1632359112
    },
    {
        "content": "<p>yeah <code>moduleRoots</code> is a misnomer</p>",
        "id": 254464113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359131
    },
    {
        "content": "<p>maybe <code>builds</code> is better</p>",
        "id": 254464122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359140
    },
    {
        "content": "<p>well, its not a misnomer at the moment</p>",
        "id": 254464137,
        "sender_full_name": "Mac",
        "timestamp": 1632359152
    },
    {
        "content": "<p>it seems to be equivocating between whether it refers to the module to build or the root module</p>",
        "id": 254464204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359189
    },
    {
        "content": "<p>it is the root the module -- all submodules of this root are built during the build and it is the first one built.</p>",
        "id": 254464268,
        "sender_full_name": "Mac",
        "timestamp": 1632359250
    },
    {
        "content": "<p>it is also the root of the resulting import DAG</p>",
        "id": 254464284,
        "sender_full_name": "Mac",
        "timestamp": 1632359266
    },
    {
        "content": "<p><code>binRoot</code> seems not to be the root of the module hierarchy it depends on</p>",
        "id": 254464296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359279
    },
    {
        "content": "<p>e.g. <code>MathportApp</code> depends on <code>Mathport.Foo.Bar</code></p>",
        "id": 254464343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359294
    },
    {
        "content": "<p>bin root is the root of its import DAG, it is however not of the modules to build</p>",
        "id": 254464364,
        "sender_full_name": "Mac",
        "timestamp": 1632359314
    },
    {
        "content": "<p><code>builds</code> is the root(s) of the import DAG too</p>",
        "id": 254464390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359338
    },
    {
        "content": "<p>yes, <code>moduleRoots := [`Foo, `Bar, ...]</code> would still be a list of roots</p>",
        "id": 254464499,
        "sender_full_name": "Mac",
        "timestamp": 1632359410
    },
    {
        "content": "<p>However, <code>modules := [glob `Foo]</code> would no longer be.</p>",
        "id": 254464526,
        "sender_full_name": "Mac",
        "timestamp": 1632359430
    },
    {
        "content": "<p>sure</p>",
        "id": 254464575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359468
    },
    {
        "content": "<p>The type could actually be <code>IO (List Name)</code>, using coercions to make <code>glob</code> work</p>",
        "id": 254464602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359497
    },
    {
        "content": "<p>well, there are lots of less fancy ways to make it work</p>",
        "id": 254464714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359574
    },
    {
        "content": "<p>a package config can already use <code>IO</code> with an <code>IOPackager</code>, so you could determine the set of modules at configuration time instead of build time, yes.</p>",
        "id": 254464788,
        "sender_full_name": "Mac",
        "timestamp": 1632359629
    },
    {
        "content": "<p>remind me how those are distinguished in the present architecture?</p>",
        "id": 254464872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359694
    },
    {
        "content": "<p>you just change the return type of <code>package</code> ;)</p>",
        "id": 254464904,
        "sender_full_name": "Mac",
        "timestamp": 1632359721
    },
    {
        "content": "<p>I mean, what is the difference between config time and build time</p>",
        "id": 254464992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359778
    },
    {
        "content": "<p>AFAIK you just call <code>lake build-lib</code> and it does everything</p>",
        "id": 254465008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359794
    },
    {
        "content": "<p>My next two planned changes are a nice little DSL for configurations and renaming <code>package.lean</code> to <code>lakefile.lean</code> (to generalize it beyond package building)</p>",
        "id": 254465011,
        "sender_full_name": "Mac",
        "timestamp": 1632359796
    },
    {
        "content": "<p>I think that in the specific case of <code>glob</code> it is worth keeping that \"declarative\" i.e. not an <code>IOPackager</code></p>",
        "id": 254465043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632359825
    },
    {
        "content": "<p>I mostly agree -- the question is simply where it ends up on my priority list</p>",
        "id": 254465309,
        "sender_full_name": "Mac",
        "timestamp": 1632360034
    },
    {
        "content": "<p>Furthermore, Lake is open source, if you want to propose some change feel free to PR it</p>",
        "id": 254465348,
        "sender_full_name": "Mac",
        "timestamp": 1632360074
    },
    {
        "content": "<p>I'm looking into that now</p>",
        "id": 254465357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632360085
    },
    {
        "content": "<p>Honestly, if you can write the glob code (i.e., the type + the translation to a list of modules), I will do the rest.</p>",
        "id": 254465451,
        "sender_full_name": "Mac",
        "timestamp": 1632360146
    },
    {
        "content": "<p>I think the \"mathematicians'\" perspective on namespacing (in the sense of identifiers) used inside the language and package names (in the sense of specifying dependencies between projects) will uniformly be that these should be completely independent.</p>",
        "id": 254646705,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632455757
    },
    {
        "content": "<p>For a mathematician, I think that it is natural to think about namespaces as \"mathematical topics\" and packages as \"books/articles\". Certainly one wants to be able to continue to develop a single topic across several books.</p>",
        "id": 254646760,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632455779
    },
    {
        "content": "<p>As we transition to Lean4 we're hopefully going to see multiple libraries. Initially there will just be mathlib4, but hopefully soon afterwards a programming standard library (possibly with additional packages) will separate out, and mathlib4 will have to continuously adapt as these begin to evolve independently.</p>",
        "id": 254646767,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632455789
    },
    {
        "content": "<p>I think there will be continuous tension that mathlib4 will want \"more theorems per definition\" relative to a more programming oriented standard library. This is just meant as an illustration that it will remain essential that we can \"retrofit\" additional theorems onto a definition made in a dependency. Dot notation has been very helpful in allowing readable mathematical notation, and I hope we'll be able to continue doing this. The combination of these two observations is I think a strong argument that a \"later\" package should be able to create declarations in the exact same namespace as an \"earlier\" package.</p>",
        "id": 254646776,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632455796
    },
    {
        "content": "<p>We've debated over the last few years about whether or not mathematics should be done in a monolithic repository. (My summary: yes, at least all the \"standard material\", i.e. everything you might ever see in a \"standard\" course, should be in one library. Research level maths deserves seperate packages.) Interoperability is hugely important, and this encourages monolithic libraries. (We would be completely justified in arguing that Lean's math ecosystem is strictly superior in terms of interoperability to any other language's.) Nevertheless I think it's important that as Lean4 comes (and as mathlib aims for saturation of masters-level mathematics!) that we make it viable and attractive to have multiple packages. I would say that technical obstacles to sharing namespaces between packages could be a significant obstacle to this (speaking to the mathematics applications).</p>",
        "id": 254646779,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632455798
    },
    {
        "content": "<p>Keep in mind that there are two kinds of namespaces being talked about here, that I will call \"import namespaces\" and \"declaration namespaces\". The first kind is the namespacing in <code>Data.Nat.Basic</code>, and the second is <code>List.append</code>.</p>\n<p>We did talk about doing strict package based declaration namespacing early on, but I think that the design of dot-notation resolution makes this a non-starter. I get the sense that this is what <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> is worried about. But the discussion in this topic has been primarily about import namespacing, i.e. whether it is okay for lean core to have <code>data.vector</code> and mathlib to have <code>data.vector2</code> (which has since been renamed to <code>data.vector.basic</code>).</p>\n<p>The design of lean 4 <code>leanpkg</code> specifically disallows overlapping import namespaces, because every import namespace gets prefixed with the name of the package. I think that Scott's argument still applies to import namespaces, at least the way mathlib uses them, because mathlib's import namespaces are essentially topical in nature, like <code>topology.basic</code>, and so it is natural for such namespaces to be used across multiple projects.</p>\n<p>My present goal is to get <code>lake</code> to be non-opinionated about whether import namespaces are used as in lean 3 / mathlib or the current lean 4 / leanpkg design, so that we can defer the decision to a style guide and CS / Math communities can make independent choices about what works best.</p>",
        "id": 254647705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632456579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254646779\">said</a>:</p>\n<blockquote>\n<p>I would say that technical obstacles to sharing namespaces between packages could be a significant obstacle to this (speaking to the mathematics applications).</p>\n</blockquote>\n<p>What I think is important to note here is that this is considered REALLY, REALLY bad practice in the CS community. Thus, this is anathema to any CS-facing tools. While I do understand that mathematicians want this, and Lean 4 wishes to cater to them as well as can be, and as such wish to do design Lake to be flexible enough to support this, it should not be the default approach (though it should be  relatively easy to change this). </p>\n<p>This should also be a minimal problem for mathematics, as  such packages are likely to be few in number, but monolithic, so  a little setup cost for package configuration is reasonable. CS packages, on the hand, are likely to be large in number and only rarely monolithic. Thus, having the defaults geared towards said application makes it so there is not tons of boiler-plate customization across  the vast majority packages.</p>",
        "id": 254647827,
        "sender_full_name": "Mac",
        "timestamp": 1632456680
    },
    {
        "content": "<p>I was conflating \"import namespaces\" and \"declaration namespaces\". If they are completely separate, what possible significance do \"import\" namespaces have? Isn't it effectively just a filename?</p>",
        "id": 254648037,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632456847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254647705\">said</a>:</p>\n<blockquote>\n<p>We did talk about doing strict package based declaration namespacing early on, but I think that the design of dot-notation resolution makes this a non-starter.</p>\n</blockquote>\n<p>I know I must sound like a broken record by now, but I still think that copying Ruby's refinements would be great way to be able to please both crowds when it comes to declaration namespacing.</p>",
        "id": 254648073,
        "sender_full_name": "Mac",
        "timestamp": 1632456897
    },
    {
        "content": "<p>I have been ignoring this comment because I don't know what Ruby refinements are. Could you elaborate?</p>",
        "id": 254648109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632456934
    },
    {
        "content": "<p>In Ruby, you can define scoped 'refinements` to add fields to namespace (called modules there), classes, etc. that are only enable when the scope in question is opened. For Lean and mathlib this would something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Mathlib</span>\n<span class=\"n\">refine</span> <span class=\"kn\">namespace</span> <span class=\"n\">List</span>\n<span class=\"c1\">-- declarations to be added to the global `List` namespace</span>\n<span class=\"kd\">def</span> <span class=\"n\">List.subset</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">end</span> <span class=\"n\">List</span>\n<span class=\"kd\">end</span> <span class=\"n\">Mathlib</span>\n<span class=\"c1\">-- `List.subset` does not exist</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">subset</span> <span class=\"c1\">--- error</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib</span>\n<span class=\"c1\">-- subset is now part of the root `List` namespace</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">subset</span>  <span class=\"bp\">...</span> <span class=\"c1\">--  dot notation works</span>\n</code></pre></div>",
        "id": 254648357,
        "sender_full_name": "Mac",
        "timestamp": 1632457125
    },
    {
        "content": "<p>In what sense are you still in the <code>Mathlib</code> namespace after the <code>refine</code> command?</p>",
        "id": 254648397,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457169
    },
    {
        "content": "<p>What is the \"true name\" of <code>List.subset</code> in this example? Is it <code>Mathlib.List.subset</code>?</p>",
        "id": 254648411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457184
    },
    {
        "content": "<p>What does that gain you over just not having <code>namespace Mathlib</code> there at all?</p>",
        "id": 254648421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457194
    },
    {
        "content": "<p>oh -- I see, the <code>open Mathlib</code> is required for the final #check to work.</p>",
        "id": 254648493,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457225
    },
    {
        "content": "<p>or is this like a macro that adds a bunch of definitions later</p>",
        "id": 254648497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <br>\n<span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254648411\">said</a>:</p>\n<blockquote>\n<p>What is the \"true name\" of <code>List.subset</code> in this example? Is it <code>Mathlib.List.subset</code>?</p>\n</blockquote>\n<p>Implementation-wise, it would probably be something like <code>Mathlib._refine.List.subset</code> (i.e., some name magic like private and macro scopes).</p>",
        "id": 254648588,
        "sender_full_name": "Mac",
        "timestamp": 1632457316
    },
    {
        "content": "<p>Just to make sure I am on the right page regarding \"import\" namespaces, is the question about whether <code>import A.B.C</code> should mean:</p>\n<ol>\n<li>please look in package <code>A</code> for a file <code>B/C.lean</code> or</li>\n<li>please look in all dependent packages for a file <code>A/B/C.lean</code> (possibly giving a helpful error message if there is more than one)</li>\n</ol>",
        "id": 254648665,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457359
    },
    {
        "content": "<p>yes, that's right</p>",
        "id": 254648674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457373
    },
    {
        "content": "<p>Lean's \"raw\" behavior is (2), but the build tool has the power to make it essentially do (1)</p>",
        "id": 254648701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457403
    },
    {
        "content": "<p>In lean 3 / mathlib we use (2) without restraint, and Sebastian and Mac think that's a bad idea</p>",
        "id": 254648779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457456
    },
    {
        "content": "<p>I see. There's <span aria-label=\"bike\" class=\"emoji emoji-1f6b2\" role=\"img\" title=\"bike\">:bike:</span>, but no emoji for \"shed\"... :-(</p>",
        "id": 254648784,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457460
    },
    {
        "content": "<p>If that's the only distinction I don't think \"mathematicans\" will care either way.</p>",
        "id": 254648853,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457518
    },
    {
        "content": "<p>To the extent that it only affects what you write after <code>import</code>, I don't really care that much, but I do think that we should be able to control the directory structure</p>",
        "id": 254648953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254648701\">said</a>:</p>\n<blockquote>\n<p>Lean's \"raw\" behavior is (2), but the build tool has the power to make it essentially do (1)</p>\n</blockquote>\n<p>Lean's raw behavior is neither? It demands that the source already be in a compiled <code>.olean</code> file in <code>LEAN_PATH</code> called <code>A/B/C.olean</code>.</p>",
        "id": 254649018,
        "sender_full_name": "Mac",
        "timestamp": 1632457666
    },
    {
        "content": "<p>Also, since you can't rename modules after the fact (unlike rust), you can sometimes end up with implementation details leaking through the package structure</p>",
        "id": 254649030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457681
    },
    {
        "content": "<blockquote>\n<p>we should be able to control the directory structure</p>\n</blockquote>\n<p>You mean inside a git repository called <code>MyPackage</code>, whether the <code>.lean</code> files must live in a <code>MyPackage</code> subdirectory or can flexibly be in <code>src</code> or <code>MyPackage</code> or ...?</p>",
        "id": 254649086,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254649018\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/254648701\">said</a>:</p>\n<blockquote>\n<p>Lean's \"raw\" behavior is (2), but the build tool has the power to make it essentially do (1)</p>\n</blockquote>\n<p>Lean's raw behavior is neither? It demands that the source already be in a compiled <code>.olean</code> file in <code>LEAN_PATH</code> called <code>A/B/C.olean</code>.</p>\n</blockquote>\n<p>Replace \"all dependent packages\" with \"everything in the <code>LEAN_PATH</code>\" in Scott's description and that's literally what lean does</p>",
        "id": 254649127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> there is a significant distinction between <code>.olean</code> files and <code>.lean</code> files.</p>",
        "id": 254649159,
        "sender_full_name": "Mac",
        "timestamp": 1632457766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> yes</p>",
        "id": 254649163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457772
    },
    {
        "content": "<p>I don't care where <code>olean</code> files go</p>",
        "id": 254649173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457787
    },
    {
        "content": "<p>They go in a central content-addressed cache that is automatically shared between all users of Lean, no? :-)</p>",
        "id": 254649248,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632457825
    },
    {
        "content": "<p>If reorganizing the olean files differently from the lean files to make things easy for the build tool helps, please go for it</p>",
        "id": 254649336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632457912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what exactly is it above and beyond what I just implemented that you want now?</p>",
        "id": 254649538,
        "sender_full_name": "Mac",
        "timestamp": 1632458065
    },
    {
        "content": "<p>I think what we have now is fine (although I suggested something about module roots in the Glob PR that would help with mathlib style import namespaces)</p>",
        "id": 254649631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632458158
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> which I just noted (in said PR) is what is currently being done.</p>",
        "id": 254649702,
        "sender_full_name": "Mac",
        "timestamp": 1632458190
    },
    {
        "content": "<p>ah okay then</p>",
        "id": 254649726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632458214
    },
    {
        "content": "<p>What would happen if a package claims <code>Glob.all</code> with the current implementation then?</p>",
        "id": 254649777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632458276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> the only somewhat relevant difference is that if you declare you own <code>Data</code> you will own all <code>Data.*</code> imports  (it won't smartly exclude those for the  Lean core or some other upstream package).</p>",
        "id": 254649877,
        "sender_full_name": "Mac",
        "timestamp": 1632458339
    },
    {
        "content": "<p>ah, and I guess the same for if you own <code>*</code>, you won't be able to <code>import Lean</code> or anything like that</p>",
        "id": 254649915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632458385
    },
    {
        "content": "<p>exactly</p>",
        "id": 254649983,
        "sender_full_name": "Mac",
        "timestamp": 1632458420
    },
    {
        "content": "<p>Yeah I think we can work with this. I'm thinking that mathlib4 will be mostly in <code>Mathlib</code> namespace, but there might be some <code>more_std</code> style parts of the library (in mathlib or in a co-located dependency) which will carve out bits of <code>Lean</code> or <code>Std</code></p>",
        "id": 254650158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632458584
    },
    {
        "content": "<p>I could add a <code>libExcludeRoots</code> field to so that you could exclude certain modules/roots from your package (e.g., <code>Lean</code>), but I think in most cases that would be just as cumbersome as specifying the modules you are adding. That is, in the current approach, you would have to specify the modules/roots you added when injecting into a not (purely) local root. With exclusion, you would instead have to specify the ones you didn't . I suspect the later will usually be larger (or at the very least comparable in size).</p>",
        "id": 254650432,
        "sender_full_name": "Mac",
        "timestamp": 1632458799
    },
    {
        "content": "<p>Yeah I agree. It's not an obvious win, so I would keep it as a potential improvement and investigate later if a compelling use case comes up</p>",
        "id": 254650772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632459108
    },
    {
        "content": "<blockquote>\n<p>you can have a setting like the following in your .vscode/settings.json<br>\n[vscode configuration manually setting the LEAN_PATH environment variable]</p>\n</blockquote>\n<p>I would like to strongly urge you to avoid this style of configuration.  Project configuration should not be stored in vscode settings; this excludes other editors (emacs, neovim, ...), and other tools like continuous integration.  Setting environment variables manually (before starting the editor) is not a particularly user-friendly option either.</p>\n<p>Let me suggest some integration requirements that I would expect as an editor dev / user.  It should be possible to:</p>\n<ol>\n<li>Figure out the project root without calling lake or lean or elan.  This is important to start LSP servers in the right directory, configure various editor's \"project search\" modes, and lean version detection.  Lake is already doing great here: you just look for the closest <code>lakefile.lean</code> file and that's the root.</li>\n<li>Start an LSP server for a project root in a uniform way.  Right now this is <code>lean --server</code>.  (We could change this to <code>lake server</code> if a lakefile is detected, but all else equal I'd rather stick with <code>lean --server</code> to avoid two separate legacy/lake code paths.)  Either way, the important part is: this needs to be uniform and not require any project-specific configuration.  We want people to open projects and have them <em>work out of the box</em>.</li>\n<li>Figure out the source directories containing the project and its dependencies.  In Lean 3 this was easy with <code>lean -p</code>.  In Lean 4 with leanpkg this is more complicated and slow with <code>leanpkg print-paths</code>.  This is important to implement \"full-text search in project sources\" in editors.</li>\n<li>Run lean on a file manually, with the correct dependencies and plugins set.  This worked great in Lean 3, but is not available in Lean 4 / leanpkg.</li>\n<li>Do of all this in the <code>lean4/src</code> and <code>lean4/tests</code> directories as well.</li>\n</ol>\n<p>In other words, dependency paths, plugins, etc. should be managed by a single authority (= lake).  Then other tools can just call lake and figure out the project settings.</p>",
        "id": 255515656,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632976017
    },
    {
        "content": "<p>(Also please make all of these available in a machine-readable format (= json).  Some tools just print some markdown and you have to play \"does the regex cover all corner cases\".  I'm looking at you, elan...)</p>",
        "id": 255515931,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632976271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> yes, this is the goal -- that was merely a stop gap measure for the time being</p>",
        "id": 255515946,
        "sender_full_name": "Mac",
        "timestamp": 1632976284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255515656\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Start an LSP server for a project root in a uniform way.  Right now this is <code>lean --server</code>.  (We could change this to <code>lake server</code> if a lakefile is detected, but all else equal I'd rather stick with <code>lean --server</code> to avoid two separate legacy/lake code paths.)  Either way, the important part is: this needs to be uniform and not require any project-specific configuration.  We want people to open projects and have them <em>work out of the box</em>.</li>\n</ol>\n</blockquote>\n<p>I do intend to have a <code>lake server</code> (it is actually in my TODO  next list already). The reason is that lake file configurations may wish to specify additional options to pass to the server (that may even need building -- e.g., plugins), thus it makes sense for lake to simplify that with a <code>lake server</code> in the root directory.</p>",
        "id": 255516087,
        "sender_full_name": "Mac",
        "timestamp": 1632976432
    },
    {
        "content": "<p>I think, to satisfy Gabriel's list of requirements, if <code>lake server</code> exists it also has to handle the case where the project is set up with a <code>leanpkg.toml</code> or any other \"approved\" setup (including whatever the lean 4 source directory does)</p>",
        "id": 255516261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632976568
    },
    {
        "content": "<p>Also, for all intents in purposes, all Lean projects need some kind of Lean configuration file in order for interactivity to work (and <code>lake</code> is meant to be that new standard), so the VSCode extension can probably just replace <code>lean --server</code> with <code>lake server</code> (after maybe a short interim period of legacy support).</p>",
        "id": 255516265,
        "sender_full_name": "Mac",
        "timestamp": 1632976577
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you make a good point about the Lean source directory. <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> do you know whether the Lean server is doing some special magic with <code>--print-paths</code> to make the Lean source directory work despite lacking a <code>leanpkg.toml</code>?</p>",
        "id": 255516425,
        "sender_full_name": "Mac",
        "timestamp": 1632976732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255516261\">said</a>:</p>\n<blockquote>\n<p>I think, to satisfy Gabriel's list of requirements, if <code>lake server</code> exists it also has to handle the case where the project is set up with a <code>leanpkg.toml</code></p>\n</blockquote>\n<p>Yes, but I think it would be kind of okay to have a \"flag day\" where <code>leanpkg.toml</code> support is removed at the same time that <code>lake</code> support is made mandatory.  Either way there is going to be a bit of migration nightmare.</p>\n<blockquote>\n<p>or any other \"approved\" setup (including whatever the lean 4 source directory does)</p>\n</blockquote>\n<p>This is a really important point, I'll add it to the list.</p>",
        "id": 255516430,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632976739
    },
    {
        "content": "<p>Indeed, one way to remove <code>leanpkg.toml</code> support is to make it not \"approved\" anymore. That's an acceptable solution to me</p>",
        "id": 255516463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632976783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255516430\">said</a>:</p>\n<blockquote>\n<p>Either way there is going to be a bit of migration nightmare.</p>\n</blockquote>\n<p>I mean Lean itself has major breaking changes quite often, so I hope there is not to many people who are expecting to be able to update their Lean toolchain without doing any migration work.</p>",
        "id": 255516588,
        "sender_full_name": "Mac",
        "timestamp": 1632976904
    },
    {
        "content": "<p>Maybe it is possible to get the lean 4 source directory to contain a <code>lakefile.lean</code> that contains some special \"I am core\" flag?</p>",
        "id": 255516641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632976931
    },
    {
        "content": "<p>It's a migration nightmare for the <em>editor developers</em>.  Editors need to support old Lean versions for the forseeable future.</p>",
        "id": 255516646,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632976936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> that confuses me a bit. Why do future versions of the Lean 4 VSCode extension need to support old pre-release Lean nightlies?</p>",
        "id": 255516704,
        "sender_full_name": "Mac",
        "timestamp": 1632977020
    },
    {
        "content": "<p>Because old versions of mathlib require old nightlies.  And people need to open old versions of mathlib (or other projects) to port them to new Lean versions.</p>",
        "id": 255516768,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255516641\">said</a>:</p>\n<blockquote>\n<p>Maybe it is possible to get the lean 4 source directory to contain a <code>lakefile.lean</code> that contains some special \"I am core\" flag?</p>\n</blockquote>\n<p>The simplest solution is to just to default <code>lake server</code> to <code>lean --server</code> if the is no package configuration.</p>",
        "id": 255516779,
        "sender_full_name": "Mac",
        "timestamp": 1632977070
    },
    {
        "content": "<p>(Or just for historical curiosity.)</p>",
        "id": 255516782,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977073
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> That doesn't solve the \"find the root\" problem though</p>",
        "id": 255516796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I think it's okay to have breaking changes here, although it will certainly be painful. There aren't that many lean 4 projects out there yet, and the new system will hopefully be somewhat backward compatible, although you might need to add a dummy lakefile</p>",
        "id": 255516965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> if someone is running a much older Lean, can't they just use an older version of the extension?</p>",
        "id": 255517045,
        "sender_full_name": "Mac",
        "timestamp": 1632977291
    },
    {
        "content": "<p>What I would <em>really</em> like is some way to be backward compatible <em>with lean 3</em>, so that the editor can reliably turn on the right extension</p>",
        "id": 255517056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977303
    },
    {
        "content": "<p>It's really not okay, at least for a short while some projects will be pre-lake and some post-lake.  And I want to open both of them.  Without changing editors, downgrading extensions, etc.</p>",
        "id": 255517063,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977310
    },
    {
        "content": "<blockquote>\n<p>some way to be backward compatible with lean 3,</p>\n</blockquote>\n<p>It doesn't need to be compatible, the detection code just has to support both.  (E.g. if leanpkg.toml is there look at the version field, if lakefile.lean is there then it's Lean 4.)</p>",
        "id": 255517130,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977371
    },
    {
        "content": "<p>I'm still using \"workspace enable\" for the lean 4 extension, because it still manages to screw things up and I don't blame it at all since there is no external indication of whether the code is lean 3 or lean 4</p>",
        "id": 255517135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977380
    },
    {
        "content": "<p>While I must say I respect your commitment to backwards computability <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> , I feel that you may be fighting a losing battle with the speed of changes in Lean.</p>",
        "id": 255517152,
        "sender_full_name": "Mac",
        "timestamp": 1632977399
    },
    {
        "content": "<p>I think it is possible to be backward compatible in the short term (for pre-lake and post-lake)</p>",
        "id": 255517223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977439
    },
    {
        "content": "<p>I agree there, I meant on a more general note.</p>",
        "id": 255517244,
        "sender_full_name": "Mac",
        "timestamp": 1632977459
    },
    {
        "content": "<p>and I think that extends to lean 3 / lean 4, although I fail to understand why lean 4 <code>leanpkg.toml</code>s don't say anything about the lean version</p>",
        "id": 255517275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977494
    },
    {
        "content": "<p>But they do?</p>",
        "id": 255517288,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977517
    },
    {
        "content": "<p>This did enlighten me on what the <code>old</code> folder in the <code>vscode4-lean</code> folder is for now, though.</p>",
        "id": 255517326,
        "sender_full_name": "Mac",
        "timestamp": 1632977523
    },
    {
        "content": "<p>The <code>old</code> folder is a red herring.  We should probably remove it.  It's not used.</p>",
        "id": 255517342,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977542
    },
    {
        "content": "<p>last I checked the default leanpkg.toml looked like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">package</span><span class=\"o\">]</span>\n<span class=\"n\">name</span> <span class=\"bp\">=</span> <span class=\"s2\">\"test\"</span>\n<span class=\"n\">version</span> <span class=\"bp\">=</span> <span class=\"s2\">\"0.1\"</span>\n</code></pre></div>",
        "id": 255517353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977550
    },
    {
        "content": "<p>Ah, then I am simply impressed on how you managed to integrate the RPC changes without breaking backwards compatibility.</p>",
        "id": 255517383,
        "sender_full_name": "Mac",
        "timestamp": 1632977584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  you can add a <code>lean_version</code> field to that.</p>",
        "id": 255517400,
        "sender_full_name": "Mac",
        "timestamp": 1632977601
    },
    {
        "content": "<p>And I think the newer <code>leanpkg</code> (i.e., from the last couple of months) does that by default.</p>",
        "id": 255517419,
        "sender_full_name": "Mac",
        "timestamp": 1632977627
    },
    {
        "content": "<blockquote>\n<p>how you managed to integrate the RPC changes without breaking backwards compatibility.</p>\n</blockquote>\n<p>This is pretty easy, you just fall back to the old protocol if the new one fails. :-)  I believe the Lean 3 extension now has backwards compatibility reaching a few years back.</p>",
        "id": 255517487,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977670
    },
    {
        "content": "<p>I think <code>lake</code> will have to maintain backward compatibility with lean 3 <code>leanpkg.toml</code> files for a very long time (in the sense that it should at least be able to find the root and determine that it's not a lean 4 project)</p>",
        "id": 255517621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977803
    },
    {
        "content": "<p><code>elan</code> will also have to maintain this kind of backward compatibility.</p>",
        "id": 255517686,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632977877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what do you mean by that? In what scenario would <code>lake</code> care?</p>",
        "id": 255517762,
        "sender_full_name": "Mac",
        "timestamp": 1632977926
    },
    {
        "content": "<p>it would be nice if it called <code>leanpkg</code> or <code>leanproject</code> in those cases</p>",
        "id": 255517786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632977951
    },
    {
        "content": "<p>If the editor is set up to just always call <code>lake server</code> then <code>lake</code> has to handle deferring to lean 3 tools</p>",
        "id": 255517874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632978006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255515656\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>Figure out the source directories containing the project and its dependencies.  In Lean 3 this was easy with <code>lean -p</code>.  In Lean 4 with leanpkg this is more complicated and slow with <code>leanpkg print-paths</code>.  This is important to implement \"full-text search in project sources\" in editors.</li>\n</ol>\n</blockquote>\n<p>Also, what do you mean by this? What would you like <code>lake</code> to do? I might be a good for us to have a heart-to-heart some time so that you can share what you want from lake and vice versa.</p>",
        "id": 255518019,
        "sender_full_name": "Mac",
        "timestamp": 1632978091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> as far as I am aware the <code>lean4</code> extension is not compatible with Lean 3, is it?</p>",
        "id": 255518098,
        "sender_full_name": "Mac",
        "timestamp": 1632978138
    },
    {
        "content": "<p>If it is, I imagine it is doing some magic to figure that out, in which case I think it should case on which version it is using.</p>",
        "id": 255518133,
        "sender_full_name": "Mac",
        "timestamp": 1632978170
    },
    {
        "content": "<p>The scenario here is that a user opens a random lean file when both extensions are installed</p>",
        "id": 255518139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632978175
    },
    {
        "content": "<p>I do not intend to make Lake backwards compatible with Lean 3 (as Lean 4 is not either).</p>",
        "id": 255518163,
        "sender_full_name": "Mac",
        "timestamp": 1632978199
    },
    {
        "content": "<p>someone has to figure out who is supposed to run the show</p>",
        "id": 255518169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632978208
    },
    {
        "content": "<p>It's not literally about backwards compatibility in that sense, it's more like figuring out that it is lean 3 and backing off in a way that doesn't interfere with the lean 3 extension</p>",
        "id": 255518241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632978256
    },
    {
        "content": "<p>For <code>lake server</code> I see two options: (1) have <code>lake</code> bail if it can't find a <code>lakefile.lean</code> (and the project is not Lean 4 compatible) or  (2) have it run <code>lean --server</code> (which may be compatible with both?).</p>",
        "id": 255518367,
        "sender_full_name": "Mac",
        "timestamp": 1632978361
    },
    {
        "content": "<blockquote>\n<p>[3. figure out directories] What would you like lake to do?</p>\n</blockquote>\n<p>I want a <code>lake path</code> command that prints something like this:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span> <span class=\"nt\">\"dependencies\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Init\"</span><span class=\"p\">,</span> <span class=\"nt\">\"core\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span> <span class=\"p\">},</span>\n <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Std\"</span><span class=\"p\">,</span> <span class=\"nt\">\"core\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span> <span class=\"p\">},</span>\n  <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"A\"</span><span class=\"p\">,</span> <span class=\"nt\">\"dependency\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"some/path\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"build/...\"</span> <span class=\"p\">},</span>\n  <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"B\"</span><span class=\"p\">,</span> <span class=\"nt\">\"dependency\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"some/path\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"build/...\"</span> <span class=\"p\">},</span>\n <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"MyProject\"</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"./MyProject\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"./build\"</span> <span class=\"p\">}</span>\n<span class=\"p\">]</span> <span class=\"p\">}</span>\n</code></pre></div>",
        "id": 255518413,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978374
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  currently <code>print-paths</code> also builds dependencies and modules (as <code>leanpkg print-paths</code> does), do you still want this new command to do that?</p>",
        "id": 255518469,
        "sender_full_name": "Mac",
        "timestamp": 1632978443
    },
    {
        "content": "<p>Note that I'm speaking from a user perspective; I'm not sure exactly what IO behavior <code>lake server</code> needs to have such that the lean 4 and lean 3 extensions can work out their differences</p>",
        "id": 255518486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632978461
    },
    {
        "content": "<blockquote>\n<p>If the editor is set up to just always call lake server then lake has to handle deferring to lean 3 tools</p>\n</blockquote>\n<p>Since lake will obviously be distributed together with lean (right?), this wont be possible.  Not for Lean 3, and not for old Lean 4 versions either.  (Since we can't retroactively add lake to those releases.)</p>",
        "id": 255518494,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Unfortunately, neither do I. <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 255518541,
        "sender_full_name": "Mac",
        "timestamp": 1632978487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255518469\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span>  currently <code>print-paths</code> also builds dependencies and modules (as <code>leanpkg print-paths</code> does), do you still want this new command to do that?</p>\n</blockquote>\n<p>Decidedly <em>not</em>.</p>",
        "id": 255518542,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978489
    },
    {
        "content": "<p>There will obviously be a <code>lake build</code> command that does this.</p>",
        "id": 255518567,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> The reason this was done this is that the the Lean server currently uses <code>leanpkg print-paths</code> to build oleans for imports.</p>",
        "id": 255518600,
        "sender_full_name": "Mac",
        "timestamp": 1632978552
    },
    {
        "content": "<p>Yes, I'm well aware of that (and why I said it's a <em>slow</em> replacement for <code>lean -p</code>).</p>",
        "id": 255518619,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978574
    },
    {
        "content": "<p><code>print-paths</code> is a weird name for \"build dependencies\"</p>",
        "id": 255518627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632978584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  it <em>also</em> prints paths.</p>",
        "id": 255518643,
        "sender_full_name": "Mac",
        "timestamp": 1632978600
    },
    {
        "content": "<p>It prints <em>some</em> paths.  For example it doesn't print the paths to the core library.</p>",
        "id": 255518710,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978637
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> is <code>print-paths</code> just a hodge podge of stuff the editor needed and stuff the server needed? Like should <code>print-paths</code> and <code>build-imports</code> parts be split up?</p>",
        "id": 255518728,
        "sender_full_name": "Mac",
        "timestamp": 1632978663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Unforunately, <code>lake</code> has no way of knowing which libraries are \"core\" libaries (at least no more so than the editor does).</p>",
        "id": 255518768,
        "sender_full_name": "Mac",
        "timestamp": 1632978717
    },
    {
        "content": "<p>Yes, I believe it's just the interface between server and leanpkg and not really intended for outside use.</p>",
        "id": 255518770,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978718
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 255518831,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255518768\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> Unforunately, <code>lake</code> has no way of knowing which libraries are \"core\" libaries (at least no more so than the editor does).</p>\n</blockquote>\n<p>It's not so important to know whether a dependency is a core library or not (but you can guess pretty easily: Init, Std, Lean -&gt; core, others -&gt; not).  The important part is that it is listed, and that you get the source directory.</p>",
        "id": 255518890,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255518413\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>[3. figure out directories] What would you like lake to do?</p>\n</blockquote>\n<p>I want a <code>lake path</code> command that prints something like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span> <span class=\"nt\">\"dependencies\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Init\"</span><span class=\"p\">,</span> <span class=\"nt\">\"core\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span> <span class=\"p\">},</span>\n  <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"A\"</span><span class=\"p\">,</span> <span class=\"nt\">\"dependency\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"some/path\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"build/...\"</span> <span class=\"p\">},</span>\n <span class=\"p\">{</span> <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"MyProject\"</span><span class=\"p\">,</span> <span class=\"nt\">\"src\"</span><span class=\"p\">:</span> <span class=\"s2\">\"./MyProject\"</span><span class=\"p\">,</span> <span class=\"nt\">\"binary\"</span><span class=\"p\">:</span> <span class=\"s2\">\"./build\"</span> <span class=\"p\">}</span>\n<span class=\"p\">]</span> <span class=\"p\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I assume by <code>binary</code> you mean the path to the oleans (not the binary executable or static library). Also what is <code>name</code> in this example? The root module name, the name of the package, the name of the folder, something else?</p>",
        "id": 255518960,
        "sender_full_name": "Mac",
        "timestamp": 1632978878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255518486\">said</a>:</p>\n<blockquote>\n<p>Note that I'm speaking from a user perspective; I'm not sure exactly what IO behavior <code>lake server</code> needs to have such that the lean 4 and lean 3 extensions can work out their differences</p>\n</blockquote>\n<p>How plausible is it to just have one extension which encompasses both lean 3 and lean 4? Has this been discussed / considered? I realize it's basically two extensions folded in one, but I would like the switching logic at least to have somewhere to live</p>",
        "id": 255518980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632978902
    },
    {
        "content": "<p>The package name (which should be identical to the module name).  If they're not identical -&gt; two fields.</p>",
        "id": 255518985,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978909
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> , <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> already demanded (and his demand was met) that they not be.</p>",
        "id": 255519023,
        "sender_full_name": "Mac",
        "timestamp": 1632978944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255518980\">said</a>:</p>\n<blockquote>\n<p>How plausible is it to just have one extension which encompasses both lean 3 and lean 4? Has this been discussed / considered? I realize it's basically two extensions folded in one, but I would like the switching logic at least to have somewhere to live</p>\n</blockquote>\n<p>The neovim extension is structured in this way, but it uses the <code>lean-language-server</code> project to wrap Lean 3 in a LSP server so that it looks more like Lean 4.</p>",
        "id": 255519088,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632978976
    },
    {
        "content": "<p>In fact, due to <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>'s demand, there is not necessarily any such thing as the root module of a package anymore.</p>",
        "id": 255519094,
        "sender_full_name": "Mac",
        "timestamp": 1632978981
    },
    {
        "content": "<p>Oh great, didn't read through everything!</p>",
        "id": 255519116,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632979007
    },
    {
        "content": "<p>The important part is that there is a list of dependent packages, together with their source location and whatever names we know.</p>",
        "id": 255519198,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632979082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I'm curious, what is this used for?</p>",
        "id": 255519247,
        "sender_full_name": "Mac",
        "timestamp": 1632979117
    },
    {
        "content": "<p>That sounds like the information a third party would need to resolve <code>import Foo.Bar</code></p>",
        "id": 255519267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632979147
    },
    {
        "content": "<p>For one, knowing that might better help me know what information to offer.</p>",
        "id": 255519280,
        "sender_full_name": "Mac",
        "timestamp": 1632979152
    },
    {
        "content": "<p>The name is not particularly important to me.  It just seemed obvious to include.  (For example you can tell the core modules by their name.)</p>",
        "id": 255519327,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632979196
    },
    {
        "content": "<p>It also allows the editor to know what constitutes the \"source directorie(s)\"</p>",
        "id": 255519328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632979196
    },
    {
        "content": "<p>If <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> guess is right, would a <code>lake where &lt;module(s)&gt;</code> be more useful instead?</p>",
        "id": 255519407,
        "sender_full_name": "Mac",
        "timestamp": 1632979232
    },
    {
        "content": "<p>Right.  In neovim we have a command to search in all source directories.  This requires a list of source directories.</p>",
        "id": 255519408,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632979233
    },
    {
        "content": "<p>It's also useful for debugging purposes (this is what lean thinks your project structure is like).</p>",
        "id": 255519437,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632979276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Rather than <code>lake where</code> (which might also be useful for some things), I think you want some finite amount of data that uniquely determines the result of <code>lake where M</code> for all <code>M</code></p>",
        "id": 255519543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632979354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> see <em>this</em> is why you don't want to specify arbitrary source files for modules. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 255519659,
        "sender_full_name": "Mac",
        "timestamp": 1632979459
    },
    {
        "content": "<p>admittedly, this was not really a case I had thought of either.</p>",
        "id": 255519728,
        "sender_full_name": "Mac",
        "timestamp": 1632979538
    },
    {
        "content": "<p>IIUC, the finite data I refer to is exactly the <code>LEAN_PATH</code></p>",
        "id": 255519733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632979542
    },
    {
        "content": "<p>Well no, because you also need the locations of the source files (<code>LEAN_PATH</code> is just oleans).</p>",
        "id": 255519790,
        "sender_full_name": "Mac",
        "timestamp": 1632979571
    },
    {
        "content": "<p>A complication is that in Lean 4, LEAN_PATH contains the binary files, while I also want the source files.</p>",
        "id": 255519796,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632979581
    },
    {
        "content": "<p>how does go-to-definition handle this today? Do the oleans reference the lean file locations?</p>",
        "id": 255519839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632979661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <code>leanpkg print-paths</code> also prints source directories.</p>",
        "id": 255519905,
        "sender_full_name": "Mac",
        "timestamp": 1632979711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> so the basic idea is to print source and olean directories for the package and its dependencies, source and olean directors for lean (and lake), and then whatever other extra olean directories exists (e.g., those in <code>LEAN_PATH</code>)?</p>",
        "id": 255520415,
        "sender_full_name": "Mac",
        "timestamp": 1632980196
    },
    {
        "content": "<p>Is <code>lake</code> influenced by the <code>LEAN_PATH</code> environment variable passed to it?</p>",
        "id": 255520520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980283
    },
    {
        "content": "<p>I'd really rather that env var get killed with fire</p>",
        "id": 255520537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> most certainly that's how <code>lake</code> itself knows where to look for imports used in the <code>lakefile.lean</code>  (though it currently isn't used in building)</p>",
        "id": 255520601,
        "sender_full_name": "Mac",
        "timestamp": 1632980380
    },
    {
        "content": "<p>I would hope that the only imports available in <code>lakefile.lean</code> are lean and lake (and maybe the current directory? That seems shaky)</p>",
        "id": 255520720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980464
    },
    {
        "content": "<p>if you need more than that you will need a lakefile for your lakefile</p>",
        "id": 255520748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980494
    },
    {
        "content": "<p>The idea that Sebastian and I where floating is that there would also be globally installed packages that could be used .</p>",
        "id": 255520814,
        "sender_full_name": "Mac",
        "timestamp": 1632980536
    },
    {
        "content": "<p>That sounds bad for reproducibility</p>",
        "id": 255520832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980555
    },
    {
        "content": "<p>And, if we want to support test libraries or custom build target libraries, something of the sort will need to exist.</p>",
        "id": 255520849,
        "sender_full_name": "Mac",
        "timestamp": 1632980572
    },
    {
        "content": "<p>Such packages will hopefully be specified in the eventual lake lockfile, so it shouldn't break reporducibility.</p>",
        "id": 255520965,
        "sender_full_name": "Mac",
        "timestamp": 1632980667
    },
    {
        "content": "<p>I think \"lakefile for your lakefile\" should actually be considered. Perhaps the outer lakefile needs only core imports, but there is a section of the file (using a macro to make effectively a nice looking multiline string) that contains the real lakefile, and the outer lakefile tells you how to acquire the dependencies for the inner lakefile</p>",
        "id": 255521037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980725
    },
    {
        "content": "<p>but I hope that this is some ways off</p>",
        "id": 255521054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980749
    },
    {
        "content": "<p>It does mean that lake will have to ship with a kind of \"standard build library\" for common features that shouldn't need the complexity</p>",
        "id": 255521143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980806
    },
    {
        "content": "<p>or maybe that's a separate package that nevertheless ships with lean + lake</p>",
        "id": 255521165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980836
    },
    {
        "content": "<p>Now that, I think is  too complexity. I am pretty confident the lockfile approach (i.e., <code>watershed.json</code>) will be sufficient</p>",
        "id": 255521182,
        "sender_full_name": "Mac",
        "timestamp": 1632980856
    },
    {
        "content": "<p>I don't understand how the lockfile helps. You should always be able to get a build working if someone deletes the lockfile</p>",
        "id": 255521243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980891
    },
    {
        "content": "<p>(modulo upgrade bugs)</p>",
        "id": 255521258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980915
    },
    {
        "content": "<p>The lockfile I'm describing would be more of a used packages manifest.</p>",
        "id": 255521294,
        "sender_full_name": "Mac",
        "timestamp": 1632980952
    },
    {
        "content": "<p>I thought <code>lakefile.lean</code> <em>was</em> the package manifest</p>",
        "id": 255521317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632980981
    },
    {
        "content": "<p>no, <code>lakefile.lean</code> is the package/workspace configuration / configurer (i.e., akin to an old <code>configure</code> script or a cmake lists)</p>",
        "id": 255521383,
        "sender_full_name": "Mac",
        "timestamp": 1632981025
    },
    {
        "content": "<p>The manifest would be a partial by-product of the configuration (for some of its packages)</p>",
        "id": 255521435,
        "sender_full_name": "Mac",
        "timestamp": 1632981084
    },
    {
        "content": "<p>why are those separate concepts?</p>",
        "id": 255521442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981090
    },
    {
        "content": "<p>I'm hoping we can have just one file that solves all our lean packaging needs</p>",
        "id": 255521517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981146
    },
    {
        "content": "<p>back in the day, this was a plain toml file. Now it's a lean file for added flexibility, but it should still be a particularly simple kind of lean code, and I see no reasons why most users should need imports besides <code>Lake</code></p>",
        "id": 255521565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981227
    },
    {
        "content": "<p>For common build operations, they should just work with <code>import Lake</code> or perhaps <code>import Lake; import LakeTools</code></p>",
        "id": 255521661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981303
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> if your lake file is building multiple C packages (and or things from other languages) you will probably want to do more complex stuff. Also test drivers will likely be included in the <code>lakefule</code>.</p>",
        "id": 255521675,
        "sender_full_name": "Mac",
        "timestamp": 1632981318
    },
    {
        "content": "<p>Ideally, the <code>lakefile.lean</code> would be used for any and all CLI (and potentially, GUI) operations you wish to perform within a  Lean workspace.</p>",
        "id": 255521791,
        "sender_full_name": "Mac",
        "timestamp": 1632981417
    },
    {
        "content": "<p>Calling external commands is already covered by \"lean + lake\" though, so unless you are importing a package for simplifying C&lt;-&gt;lean integration you should be able to get by with the basics</p>",
        "id": 255521811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981441
    },
    {
        "content": "<p>and any such package would for me be a candidate for inclusion in <code>LakeTools</code></p>",
        "id": 255521831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981463
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> have you used NPM for complex web development?</p>",
        "id": 255521894,
        "sender_full_name": "Mac",
        "timestamp": 1632981509
    },
    {
        "content": "<p>I have...</p>",
        "id": 255521919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981540
    },
    {
        "content": "<p>There are a whole lot of additional tools and dependencies specified in a <code>package.json</code> that are  used just for administration.</p>",
        "id": 255521927,
        "sender_full_name": "Mac",
        "timestamp": 1632981545
    },
    {
        "content": "<p>this sounds a lot like the <code>build.rs</code> style though</p>",
        "id": 255521955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981577
    },
    {
        "content": "<p>i.e. \"lakefile in a lakefile\"</p>",
        "id": 255521964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981585
    },
    {
        "content": "<p>For example, features like those provided by <code>lerna</code>, <code>@vue/cli</code>, <code>mocha</code>, <code>webpack</code> would all be things what would hopefully be included in a <code>lakefile.lean</code>.</p>",
        "id": 255522054,
        "sender_full_name": "Mac",
        "timestamp": 1632981617
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> yeah, this could all be \"lakefile in a lakefile\" stuff, but I would like to avoid that complexity if possible.</p>",
        "id": 255522278,
        "sender_full_name": "Mac",
        "timestamp": 1632981796
    },
    {
        "content": "<p>I would like to avoid the complexity of having <code>lake build</code> not work when the only thing in the project is a <code>lakefile.lean</code> in the root</p>",
        "id": 255522470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981959
    },
    {
        "content": "<p>I think that all that webpack mocha stuff is complexity that should be deferred</p>",
        "id": 255522539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632981993
    },
    {
        "content": "<p>For some projects, the needed build tools can be added to the core distribution. For some projects, the build tools are written inline in the <code>lakefile.lean</code>. I would like to defer the existence of a third category as long as possible</p>",
        "id": 255522624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632982067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255522470\">said</a>:</p>\n<blockquote>\n<p>I would like to avoid the complexity of having <code>lake build</code> not work when the only thing in the project is a <code>lakefile.lean</code> in the root</p>\n</blockquote>\n<p>Even in my scenario, It would only not work in cases where the lakefile needs more packages than just <code>Lake</code> and <code>Lean</code> (which would be just as true now).</p>",
        "id": 255524423,
        "sender_full_name": "Mac",
        "timestamp": 1632983402
    },
    {
        "content": "<p>Fwiw, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, the whole point of the lock file was so that you can use standard tools to read it.</p>\n<p>A lean file is a bad thing to read by anything but lean. And even then it's problematic because it allows you to write more or less arbitrary code.</p>\n<p>The machine readable manifest is generated off of it into json for compatibility.</p>\n<p>The only real consideration, imo, is whether lake spits it out to stdout when passed a flag or whether it sits in a lock file on the file system</p>",
        "id": 255530632,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632987448
    },
    {
        "content": "<p>I don't disagree with that, but it's orthogonal to my point. Users cannot be expected to maintain a lockfile, and it should always be possible to delete and regenerate it with the only loss of information being the exact versions of dependents as of the last run of the tool</p>",
        "id": 255530839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632987571
    },
    {
        "content": "<p>It's also orthogonal to my point.  Lockfiles can only contain system-independent information, but I want <code>lake path</code> to print system-specific information (such as the location of the core library).</p>",
        "id": 255530950,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632987628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255524423\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255522470\">said</a>:</p>\n<blockquote>\n<p>I would like to avoid the complexity of having <code>lake build</code> not work when the only thing in the project is a <code>lakefile.lean</code> in the root</p>\n</blockquote>\n<p>Even in my scenario, It would only not work in cases where the lakefile needs more packages than just <code>Lake</code> and <code>Lean</code> (which would be just as true now).</p>\n</blockquote>\n<p>Right. My hope is to make \"needs more packages than just <code>Lake</code> and <code>Lean</code>\" be a distant future, and when that distant future arrives I want a <code>build.rs</code> styled solution. Certainly none of the lean 4 projects I am aware of (including in particular mathlib4) require more than lean + lake at the build stage</p>",
        "id": 255531456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632988004
    },
    {
        "content": "<p>fair points. And regarding lean + lake. That's kind of the idea of the modular design no? We can always add support for a bunch of helpers, like ftp, 7zip, gzip, etc.</p>",
        "id": 255531633,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632988122
    },
    {
        "content": "<p>Can we not ship those helpers with lean + lake, so that users don't need to deal with a multi-stage build?</p>",
        "id": 255531720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632988200
    },
    {
        "content": "<p>what I meant: lake can ship with a large library of useful helpers that no one single lake script will need all of.</p>",
        "id": 255531792,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632988239
    },
    {
        "content": "<p>I do think that lean 4 can make describing a multi stage build relatively painless, but for most uses I think that a library of helpers will suffice</p>",
        "id": 255531831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632988267
    },
    {
        "content": "<p>basically what's project-specific should be so little, that there really shouldn't be a need for multi-stage builds</p>",
        "id": 255531859,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632988296
    },
    {
        "content": "<p>one thing we probably would like to have though, is be able to depend on another lean file from within a lake file. Not sure, if that's possible today. But not supporting it =&gt; you create potentially unmaintainably large build files and supporting it =&gt; the need for a multi-stage build becomes even much less important.</p>",
        "id": 255532050,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632988406
    },
    {
        "content": "<p>One way to accomplish that would be to use a fixed folder like <code>lakefile/</code> that gets added to the <code>LEAN_PATH</code> when reading <code>lakefile.lean</code></p>",
        "id": 255532201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632988505
    },
    {
        "content": "<p>(sorry, very laggy message sending), yes, something like that. In case normal <code>import</code> statements don't work.</p>",
        "id": 255532248,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632988545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255516646\">said</a>:</p>\n<blockquote>\n<p>It's a migration nightmare for the <em>editor developers</em>.  Editors need to support old Lean versions for the forseeable future.</p>\n</blockquote>\n<p>If only we a tool that could specify &amp; set up exact, compatible versions of the compiler, editor, <em>and</em> editor extension <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> . But that tool would likely have to be so general that it would come with its own set of issues and likely not work across all interesting platforms...</p>",
        "id": 255534465,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632989767
    },
    {
        "content": "<p>Indeed it is hard to conceive that such a tool might struggle with old versions of editors. <a href=\"https://github.com/NixOS/nixpkgs/issues/97443\">ehm</a> <a href=\"https://github.com/NixOS/nixpkgs/issues/95808\">mmh</a></p>",
        "id": 255536072,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632990596
    },
    {
        "content": "<p>I hadn't realised until recently that nix has been around for a long time. I'd thought it was new and that windows and good macos support were plausible things to hope for. :-)</p>",
        "id": 255536131,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632990607
    },
    {
        "content": "<p>I believe we also had a bug where new gtk plugins made old applications crash, but I can't find it right now.</p>",
        "id": 255536183,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632990633
    },
    {
        "content": "<p>Ahaha. It may take a few more decades until we figure out reproducibility for GUIs.</p>",
        "id": 255536300,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632990703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20name.2Fversion.20package.20fields/near/255536300\">said</a>:</p>\n<blockquote>\n<p>Ahaha. It may take a few more decades until we figure out reproducibility for GUIs.</p>\n</blockquote>\n<p>maybe when AI is good enough to get a video stream of the your screen and also 100% trustworthy...</p>",
        "id": 255536679,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632990924
    },
    {
        "content": "<p>This one was also fun: <a href=\"https://github.com/NixOS/nixpkgs/pull/132937\">https://github.com/NixOS/nixpkgs/pull/132937</a>. It's almost like some upstreams <em>want</em> to break reproducibility.</p>",
        "id": 255536975,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632991086
    },
    {
        "content": "<p>honestly, git submodules are the only realistic way of hoping for a sense of reproducibility :D</p>",
        "id": 255537173,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632991211
    },
    {
        "content": "<p>and they are pain to work with.</p>",
        "id": 255537198,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632991226
    },
    {
        "content": "<p>Reminds me of texlive a few years back: you can only download the release tarball today, hurry because tomorrow we'll push new versions and remove the old ones!  (I think there's an official mirror for the release tarballs now.)</p>",
        "id": 255537200,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1632991227
    },
    {
        "content": "<p>at least texlive is pretty good these days... When I started my math in the early 2000s or so, there was no texlive for windows afaik. So you were stuck with miktex that definitely worked for <em>some</em> packages. Oh joy...</p>",
        "id": 255537321,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632991315
    },
    {
        "content": "<p>and a linux-y setup on windows was not for the faint of heart.</p>",
        "id": 255537448,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632991359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> as far as I am aware that is same thought process is still the default state of  affairs for MSYS2. Last I checked, it is incredibly difficult to install anything but the latest version of a package.</p>",
        "id": 255546570,
        "sender_full_name": "Mac",
        "timestamp": 1632995881
    },
    {
        "content": "<p>They have stable archive URLs you can install with <code>pacman -U</code> at least (<span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span> taught me that). But just like with Arch Linux, anything but a full upgrade is probably unsupported.</p>",
        "id": 255547093,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632996114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> but what happen when said package also depends on on older version of other packages <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 255547253,
        "sender_full_name": "Mac",
        "timestamp": 1632996198
    },
    {
        "content": "<p>Welcome to dependency hell</p>",
        "id": 255547318,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632996228
    },
    {
        "content": "<p>But that is true for almost all system package managers</p>",
        "id": 255547413,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632996264
    },
    {
        "content": "<p>Not <code>brew</code> as far as I am aware.</p>",
        "id": 255547460,
        "sender_full_name": "Mac",
        "timestamp": 1632996289
    },
    {
        "content": "<p>You can install multiple versions of the same package, and use them in dependency diamonds?</p>",
        "id": 255547640,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632996370
    },
    {
        "content": "<p>I guess you meant that while it cannot solve dependency hell, it can at least resolve correct versions of dependencies given a specific version and given that none of them have been installed in different versions. In that case, yes, most package managers that are not pacman can do that afaik.</p>",
        "id": 255552215,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1632998949
    }
]
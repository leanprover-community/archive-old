[
    {
        "content": "<p>I have encountered a problem with high order unification that I would like to understand properly.</p>\n<p>It looks like that <code>λ x =&gt; ?m x (f x)</code> <strong>can</strong> be unified with <code>λ x =&gt; (f x * g x)</code></p>\n<p>but <code>λ f x =&gt; ?m x (f x)</code> <strong>can't</strong> be unified with <code>λ f x =&gt; (f x * g x)</code></p>\n<p>To test this I have this mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Test to unify `λ x =&gt; ?m x (f x)` with `λ x =&gt; (f x * g x)`</span>\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n<span class=\"kd\">instance</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">bar</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- Test to unify `λ f x =&gt; ?m x (f x)` with `λ f x =&gt; (f x * g x)`</span>\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">))</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<hr>\n<p>I would like to test the unification directly i.e. create an expression with and without metavariables and test if they can be equal.</p>\n<p>Here is my attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">TermElabM</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"n\">none</span>\n  <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but it I have few questions about it:</p>\n<ol>\n<li>How can I turn on <code>set_option trace.Meta.isDefEq true in</code> only for <code>(← isDefEq a b)</code>? If I turn on the tracing for the whole <code>#eval</code> command I get tons of messages I do not care about.</li>\n<li>The unification does not seem to work the same as in the <code>apply</code> tactic. If I change <code>a</code> to <code>elabTerm (← </code>(λ (f : Nat → Nat) (x : Nat) =&gt; (x + <code>) * f x)) none</code> the <code>(← isDefEq a b)</code> returns false. However, that corresponds to the working example with <code>g = (· + 1)</code></li>\n</ol>",
        "id": 295388101,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1661507558
    },
    {
        "content": "<p>1 is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">withOptions</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">insert</span> <span class=\"bp\">`</span><span class=\"n\">trace.Meta.isDefEq</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 295396342,
        "sender_full_name": "pcpthm",
        "timestamp": 1661510872
    },
    {
        "content": "<p>Thanks! Now the answer to 2. is that the hole translates to <code>?m f x</code> instead of just <code>?m</code>, that is why there is a difference.</p>\n<p>Thus I'm doing unification <code>fun f x =&gt; x * f x =?= fun f x =&gt; ?m f x x (f x)</code> instead of <code>fun f x =&gt; x * f x =?= fun f x =&gt; ?m x (f x)</code>.</p>\n<p>The question is how do I create expression for <code>fun f x =&gt; ?m x (f x)</code> i.e. alternative to <code>let b ← elabTerm (← `(λ (f : Nat → Nat) (x : Nat) =&gt; (_ : Nat → Nat → Nat) x (f x))) none</code></p>",
        "id": 295440977,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1661525426
    },
    {
        "content": "<p>One way of creating <code>fun f x =&gt; ?m x (f x)</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">mId</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshMVarId</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarWithId</span> <span class=\"n\">mId</span>\n  <span class=\"k\">let</span> <span class=\"n\">natToNat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">mkLambda</span> <span class=\"bp\">`</span><span class=\"n\">f</span> <span class=\"n\">BinderInfo.default</span> <span class=\"o\">(</span><span class=\"n\">mkForall</span> <span class=\"n\">Name.anonymous</span> <span class=\"n\">BinderInfo.default</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"bp\">$</span>\n           <span class=\"n\">mkLambda</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"n\">BinderInfo.default</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n           <span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">mkBVar</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkBVar</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkBVar</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Which is quite ugly. I guess one way to do it would be to use Gabriel's quote4 library. What is the best way without any library?</p>",
        "id": 295449795,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1661527170
    }
]
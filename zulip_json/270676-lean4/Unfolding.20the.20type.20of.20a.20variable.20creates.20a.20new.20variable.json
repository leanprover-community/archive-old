[
    {
        "content": "<p>I'm working on a proof that requires me to unfold the type of some variable <code>x</code>, so that I can do a cases on the internal definition.<br>\nHowever, when doing this unfold, lean adds a new variable to the context, of the required unfolded type, but all other occurences of <code>x</code> still refer to the now inaccessible original variable.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Wrapper</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">some_property</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"o\">:=</span> <span class=\"n\">True</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Wrapper</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">some_property</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">    n : Nat</span>\n<span class=\"cm\">    x : (Wrapper n).fst</span>\n<span class=\"cm\">    h : some_property x</span>\n<span class=\"cm\">    ⊢ True</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Wrapper</span> <span class=\"n\">at</span> <span class=\"n\">x</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">    n : Nat</span>\n<span class=\"cm\">    x✝ : (Wrapper n).fst</span>\n<span class=\"cm\">    h : some_property x✝</span>\n<span class=\"cm\">    x : (Fin n, Fin n).fst</span>\n<span class=\"cm\">    ⊢ True</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">rename_i</span> <span class=\"n\">x'</span><span class=\"bp\">;</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I've tried to prove that <code>x</code> and <code> x✝</code> are equal, without much success.</p>\n<p>I want to do this unfold because I need to a <code>cases</code> on something that uses <code>x</code>, which fails with the error <code>tactic 'generalize' failed, result is not type correct</code> unless I unfold the type of <code>x</code>. Sadly have not managed to find a MWE that has this behaviour.</p>",
        "id": 278552443,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1649683412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span> Thanks for raising this issue. We will improve the <code>unfold</code> tactic. It is currently using the <code>simp</code> infrastructure which creates auxiliary declarations instead of replacing them when there are dependencies. It the meantime, here are two possible workarounds.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Wrapper</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">some_property</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"o\">:=</span> <span class=\"n\">True</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Wrapper</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">some_property</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">delta</span> <span class=\"n\">Wrapper</span> <span class=\"n\">at</span> <span class=\"n\">x</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Wrapper</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">some_property</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Wrapper</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>BTW, the <code>delta</code> tactic preserves definitional equality, and it will expose the internal encoding used to justify the termination of recursive functions. It is not an issue in the example above because <code>Wrapper</code> is not recursive.</p>",
        "id": 278553913,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649684079
    },
    {
        "content": "<p>BTW, the second workaround only works if the <code>unfold</code> is preserving definitional equality. This is the case for your example, but it is not true in the following one.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">NatTuple</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">NatTuple</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NatTuple.property</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">NatTuple</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">True</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">NatTuple</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x.property</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">NatTuple</span> <span class=\"c1\">-- Did not unfold `NatTuple`.</span>\n</code></pre></div>",
        "id": 278555075,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649684612
    },
    {
        "content": "<p>Thanks, I hadn't heard of <code>delta</code> before, but it seems to do exactly what I need!<br>\nMy more complicated unfold does preserve definition equality as well (at least, the types can be proven equal with a <code>rfl</code>), hence my surprise with <code>unfold</code>s behaviour.</p>\n<p>Turns out my actual issue was something else, as soon as I used <code>delta</code>, the <code>tactic 'generalize' failed</code> error popped up again.<br>\nManaged to fix it by introducing a new variable with a <code>let</code>-binding, rather than doing <code>cases</code> directly on an expression.</p>",
        "id": 278555905,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1649684953
    },
    {
        "content": "<blockquote>\n<p>Turns out my actual issue was something else, as soon as I used delta, the tactic 'generalize' failed error popped up again.</p>\n</blockquote>\n<p>Could you please send us the example that triggered the problem?</p>",
        "id": 278556406,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649685187
    },
    {
        "content": "<p>It's in this file: <a href=\"https://github.com/alexkeizer/qpf4/blob/master/Qpf/PFunctor/Multivariate/M.lean\">https://github.com/alexkeizer/qpf4/blob/master/Qpf/PFunctor/Multivariate/M.lean</a><br>\nThe working code is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">M.bisim_lemma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">TypeVec</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n                      <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Mp</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"o\">}</span>\n                      <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Mp</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">B</span> <span class=\"n\">a₁</span> <span class=\"bp\">⟹</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n                      <span class=\"o\">{</span><span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">P.A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P.B</span> <span class=\"n\">a'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">drop</span> <span class=\"bp\">⟹</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n                      <span class=\"o\">{</span><span class=\"n\">f₁'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P.B</span> <span class=\"n\">a'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n                      <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"o\">:</span> <span class=\"n\">M.dest</span> <span class=\"n\">P</span> <span class=\"o\">⟨</span><span class=\"n\">a₁</span><span class=\"o\">,</span> <span class=\"n\">f₁</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">splitFun</span> <span class=\"n\">f'</span> <span class=\"n\">f₁'</span><span class=\"o\">⟩)</span>\n                    <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g₁'</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e₁'</span> <span class=\"o\">:</span> <span class=\"n\">PFunctor.M.dest</span> <span class=\"n\">a₁</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">g₁'</span><span class=\"o\">⟩),</span>\n      <span class=\"n\">f'</span> <span class=\"bp\">=</span> <span class=\"n\">M.pathDestLeft</span> <span class=\"n\">P</span> <span class=\"n\">e₁'</span> <span class=\"n\">f₁</span>\n      <span class=\"bp\">∧</span> <span class=\"n\">f₁'</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">B</span> <span class=\"n\">a'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">g₁'</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">M.pathDestRight</span> <span class=\"n\">P</span> <span class=\"n\">e₁'</span> <span class=\"n\">f₁</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">e₁</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">ef</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">splitFun</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">append1</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"n\">f'</span> <span class=\"n\">f₁'</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span> <span class=\"bp\">;</span>\n  <span class=\"n\">intro</span> <span class=\"n\">e₁</span><span class=\"bp\">;</span>\n  <span class=\"c1\">-- \\/ HERE</span>\n  <span class=\"k\">let</span> <span class=\"n\">he₁'</span> <span class=\"o\">:=</span> <span class=\"n\">PFunctor.M.dest</span> <span class=\"n\">a₁</span><span class=\"bp\">;</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">e₁'</span> <span class=\"o\">:</span> <span class=\"n\">he₁'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a₁'</span><span class=\"o\">,</span> <span class=\"n\">g₁'</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n  <span class=\"c1\">-- /\\ HERE</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">M.dest_eq_dest'</span> <span class=\"n\">P</span> <span class=\"n\">e₁'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e₁</span>\n  <span class=\"n\">cases</span> <span class=\"n\">e₁</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">e₁'</span><span class=\"o\">,</span> <span class=\"n\">split_fun_inj</span> <span class=\"n\">ef</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I originally used </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rcases</span> <span class=\"n\">e₁'</span> <span class=\"o\">:</span> <span class=\"n\">PFunctor.M.dest</span> <span class=\"n\">a₁</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a₁'</span><span class=\"o\">,</span> <span class=\"n\">g₁'</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>Which triggered the error</p>\n<p>This is on nightly-2022-03-17, btw. I tried to update to the most recent nightly but that broke some other stuff.</p>\n<p>I was trying to unfold <code>Mp</code> at variable <code>a1</code>, but it seems that wasn't even necessary after I introduced the <code>let</code>-binding</p>",
        "id": 278563579,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1649688065
    },
    {
        "content": "<p>I pushed a fix for <code>unfold</code> and <code>simp</code>. They do not create the auxiliary declaration anymore when the result is definitionally equal. <br>\nThanks for posting the full example above. It would be great if we could create a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for it. It would help us to diagnose the problem. <br>\nDoes the issue also happen when you use <code>match</code>-tactic? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">e₁'</span> <span class=\"o\">:</span> <span class=\"n\">PFunctor.M.dest</span> <span class=\"n\">a₁</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a₁'</span><span class=\"o\">,</span> <span class=\"n\">g₁'</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div>",
        "id": 278567121,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649689434
    },
    {
        "content": "<p>The <code>match</code> fails also, but with a more descriptive error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">pathDestLeft</span> <span class=\"n\">P</span> <span class=\"n\">e₁'</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">e₁'</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">{</span> <span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"n\">a₁'</span><span class=\"o\">,</span> <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"n\">g₁'</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"n\">g₁'</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">PFunctor.M.dest</span> <span class=\"n\">a₁</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"n\">g₁'</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Marking <code>PFunctor.M.dest</code> as an <code>abbrev</code> rather than a <code>def</code> makes the error go away.<br>\nInterestingly, with the <code>abbrev</code> version of M.dest the original <code>rcases</code> also works</p>",
        "id": 278568947,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1649690046
    }
]
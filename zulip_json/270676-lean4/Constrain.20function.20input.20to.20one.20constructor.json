[
    {
        "content": "<p>Say I have the following inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Var</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Dup</span> <span class=\"o\">(</span><span class=\"n\">nam0</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">name1</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">body</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Let</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">body</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Lam</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">body</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">App</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">argm</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ctr</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">U32</span> <span class=\"o\">(</span><span class=\"n\">numb</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Op2</span> <span class=\"o\">(</span><span class=\"n\">oper</span> <span class=\"o\">:</span> <span class=\"n\">Operation</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val0</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val1</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I would like to define a function that only accepts <code>Ctr</code> terms as an input.</p>\n<p>I know this can be done with something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">flatten</span> <span class=\"o\">:</span> <span class=\"n\">Rule</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Rule</span>\n<span class=\"bp\">|</span> <span class=\"n\">Ctr</span> <span class=\"n\">name</span> <span class=\"n\">args</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fatal</span><span class=\"bp\">!</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>But instead of handling this in the function at runtime, I would like to make sure this function is never called with anything other than with a <code>Ctr</code>. Is there a way to achieve that at compile time?</p>\n<p>The first thing that comes to mind is to use a phantom type to discriminate the cases I am interested, but I am wondering if there are other ways.</p>",
        "id": 275166904,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647194479
    },
    {
        "content": "<p>I also understand that depending on the application, this may just shift the burden of pattern matching to the client and that may be counter productive.</p>",
        "id": 275166979,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647194579
    },
    {
        "content": "<p>In my case, I believe this question is coming from the fact that the left-hand-side of Rule can only be a constructor in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Rule</span> <span class=\"n\">where</span>\n  <span class=\"n\">lhs</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n  <span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n</code></pre></div>\n<p>Maybe <code>lhs</code> should be a separate type.</p>",
        "id": 275167315,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647195017
    },
    {
        "content": "<p>A typical piece of advice here is to accept that <code>flatten</code> can be called on arbitrary expressions and write your theorems with the side condition that the term is a <code>Ctr</code>.</p>\n<p>You can also create a Type just for representing a <code>Ctr</code> and provide functions <code>Term -&gt; Option Ctr</code> and <code>Ctr -&gt; Term</code>. Then you can make <code>flatten</code> take a <code>Ctr</code> as a parameter.</p>",
        "id": 275167518,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647195330
    },
    {
        "content": "<p>The function <code>flatten</code> seems to have type <code>Term -&gt; Term</code> in this example? In any case, you could define a predicate <code>isCtr</code> only satisfied by those <code>Term</code> which are applications of <code>Ctr</code>, and require a proof of that in the type of <code>flatten</code>. (Is this what you mean by a phantom type?)</p>",
        "id": 275167583,
        "sender_full_name": "Horatiu Cheval",
        "timestamp": 1647195381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/270676-lean4/topic/Constrain.20function.20input.20to.20one.20constructor/near/275167583\">said</a>:</p>\n<blockquote>\n<p>The function <code>flatten</code> seems to have type <code>Term -&gt; Term</code> in this example?</p>\n</blockquote>\n<p>Sorry, I tried to simplify the example and made it incorrect.</p>\n<p>The real flatten function takes a <code>List Rule</code> and needs to group them by LHS Ctr name (note this is a work in progress and does not compile ...)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">RuleGroup</span> <span class=\"o\">:=</span> <span class=\"n\">Std.HashMap</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Rule</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">groupBy</span> <span class=\"o\">(</span><span class=\"n\">rules</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Rule</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RuleGroup</span> <span class=\"o\">:=</span>\n  <span class=\"n\">return</span> <span class=\"n\">rules.foldl</span> <span class=\"n\">groupByName</span> <span class=\"n\">Inhabited.default</span>\n  <span class=\"n\">where</span>\n    <span class=\"n\">groupByName</span> <span class=\"o\">:</span> <span class=\"n\">RuleGroup</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Rule</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">RuleGroup</span>\n    <span class=\"bp\">|</span> <span class=\"n\">rg</span><span class=\"o\">,</span> <span class=\"o\">⟨</span> <span class=\"o\">(</span><span class=\"n\">Term.Ctr</span> <span class=\"n\">name</span> <span class=\"n\">args</span><span class=\"o\">),</span> <span class=\"n\">rhs</span> <span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">rg.find</span><span class=\"bp\">?</span> <span class=\"n\">name</span> <span class=\"k\">with</span>\n              <span class=\"bp\">|</span> <span class=\"n\">none</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">rg.insert</span> <span class=\"n\">name</span> <span class=\"o\">[</span><span class=\"n\">rule</span><span class=\"o\">]</span>\n              <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">rs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rs.push</span> <span class=\"n\">rule</span>\n</code></pre></div>\n<p>(btw, it turns out List.groupBy has an unexpected type/impl to me, at least)</p>",
        "id": 275167706,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647195568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/270676-lean4/topic/Constrain.20function.20input.20to.20one.20constructor/near/275167583\">said</a>:</p>\n<blockquote>\n<p>(Is this what you mean by a phantom type?)</p>\n</blockquote>\n<p>I mean something along the lines of (does not compile):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">IsCtr</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">yes</span>\n  <span class=\"bp\">|</span> <span class=\"n\">no</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">IsCtr</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ctr</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"n\">IsCtr.yes</span>\n</code></pre></div>\n<p>So that I could, for instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"n\">IsCtr.yes</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span>\n</code></pre></div>",
        "id": 275168043,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647195993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110026\">Simon Hudon</span> <a href=\"#narrow/stream/270676-lean4/topic/Constrain.20function.20input.20to.20one.20constructor/near/275167518\">said</a>:</p>\n<blockquote>\n<p>A typical piece of advice here is to accept that <code>flatten</code> can be called on arbitrary expressions and write your theorems with the side condition that the term is a <code>Ctr</code>.</p>\n</blockquote>\n<p>Could you provide a simple example of how this could be done?</p>",
        "id": 275168071,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647196068
    },
    {
        "content": "<p>Your definition with <code>panic!</code> is the definition I was thinking of. For a theorem, I'd need an example of the kind of theorem you're working on</p>",
        "id": 275168146,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647196172
    },
    {
        "content": "<p>If you're trying to statically know which constructor you're working with, you can also go this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Var</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Lam</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">body</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">App</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">argm</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ctr</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TermCase</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Var</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Lam</span>\n  <span class=\"bp\">|</span> <span class=\"n\">App</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ctr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IsTermCase</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"n\">TermCase</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Var</span> <span class=\"o\">:</span> <span class=\"n\">IsTermCase</span> <span class=\"o\">(</span><span class=\"n\">Var</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">TermCase.Var</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Lam</span> <span class=\"o\">:</span> <span class=\"n\">IsTermCase</span> <span class=\"o\">(</span><span class=\"n\">Lam</span> <span class=\"n\">v</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">TermCase.Lam</span>\n  <span class=\"bp\">|</span> <span class=\"n\">App</span> <span class=\"o\">:</span> <span class=\"n\">IsTermCase</span> <span class=\"o\">(</span><span class=\"n\">App</span> <span class=\"n\">t₀</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"n\">TermCase.App</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ctr</span> <span class=\"o\">:</span> <span class=\"n\">IsTermCase</span> <span class=\"o\">(</span><span class=\"n\">Ctr</span> <span class=\"n\">c</span> <span class=\"n\">ls</span><span class=\"o\">)</span> <span class=\"n\">TermCase.Ctr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SpecificTerm</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">TermCase</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">t</span> <span class=\"bp\">//</span> <span class=\"n\">IsTermCase</span> <span class=\"n\">t</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Term.check</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">SpecificTerm</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">Term.ofSpecific</span> <span class=\"o\">:</span> <span class=\"n\">SpecificTerm</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span> <span class=\"n\">Subtype.val</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">useVar</span> <span class=\"o\">:</span> <span class=\"n\">SpecificTerm</span> <span class=\"n\">TermCase.Var</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">specialize</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsTermCase</span> <span class=\"n\">t</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">constructor</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">SpecificTerm</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">useVar</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">Var</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">useVar</span> <span class=\"o\">(</span><span class=\"n\">specialize</span> <span class=\"o\">(</span><span class=\"n\">Var</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">varName</span> <span class=\"o\">:</span> <span class=\"n\">SpecificTerm</span> <span class=\"n\">TermCase.Var</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span> <span class=\"n\">Var</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p><code>useVar?</code> shows how easy it is (using <code>specialize</code>) to create a <code>SpecificTerm</code> when you have local information about which constructor you're faced with. <code>varName</code> shows you can the equation compiler can dismiss all the impossible  cases.</p>",
        "id": 275168601,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647196839
    },
    {
        "content": "<p>The boilerplate seems easy enough to generate automatically.</p>",
        "id": 275168607,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647196860
    },
    {
        "content": "<p>The design can also work by replacing <code>IsTermCase</code> with a function <code>Term -&gt; TermCase</code> and that can make it easier to derive a <code>Decidable</code> instance for the corresponding propositions, if that matters</p>",
        "id": 275169592,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647198196
    },
    {
        "content": "<p>In the past I've used this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">flatten</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Rule</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">name</span> <span class=\"n\">args</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">Ctr</span> <span class=\"n\">name</span> <span class=\"n\">args</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Rule</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>You'll have to write the decidable instance, but with the optional/auto arg by decide, you can usually pretend it's not there. If you use it a lot you can extract the existential hypothesis into a predicate <code>isCtr</code> or whatever.</p>",
        "id": 275170040,
        "sender_full_name": "Chris B",
        "timestamp": 1647198819
    },
    {
        "content": "<p>The downside of not wrapping that proof into a subtype <span class=\"user-mention\" data-user-id=\"228466\">@Chris B</span> is that now, when writing a theorem about flatten, you have proof term floating around making rewriting more awkward. By moving that proof term to a function that done nothing but wrap the subtype, you can write separate theorems about the wrapping and the <code>flatten</code> function.</p>",
        "id": 275170594,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647199508
    },
    {
        "content": "<p>This formulation for <code>h</code> also seems hard to use by the equation compiler when trying to find unreachable cases</p>",
        "id": 275170912,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647199920
    },
    {
        "content": "<p>Touche, I agree that the explicit existential is more ad-hoc. My use case has been just \"this function should only work for this constructor\" without the need for a lot of subsequent proving.</p>",
        "id": 275171004,
        "sender_full_name": "Chris B",
        "timestamp": 1647200038
    },
    {
        "content": "<p>That's fair. I think we can generalize both approaches btw. For generally decidable predicates, we can define decidable subtypes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">DecSubtype</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">t</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Term.caseOf</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"n\">TermCase</span>\n<span class=\"bp\">|</span> <span class=\"n\">Var</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermCase.Var</span>\n<span class=\"bp\">|</span> <span class=\"n\">App</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermCase.App</span>\n<span class=\"bp\">|</span> <span class=\"n\">Lam</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermCase.Lam</span>\n<span class=\"bp\">|</span> <span class=\"n\">Ctr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TermCase.Ctr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">VarTerm</span> <span class=\"o\">:=</span>\n<span class=\"n\">DecSubtype</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.caseOf</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">TermCase.Var</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">VarOrLamTerm</span> <span class=\"o\">:=</span>\n<span class=\"n\">DecSubtype</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.caseOf</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">TermCase.Var</span> <span class=\"bp\">∨</span> <span class=\"n\">Term.caseOf</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">TermCase.Lam</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">specialize</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">DecSubtype</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">varName</span> <span class=\"o\">:</span> <span class=\"n\">VarTerm</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span> <span class=\"n\">Var</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">boundVarName</span> <span class=\"o\">:</span> <span class=\"n\">VarOrLamTerm</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span> <span class=\"n\">Var</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span> <span class=\"n\">Lam</span> <span class=\"n\">s</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 275171290,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647200409
    },
    {
        "content": "<p>(This is a really cool problem btw. Thanks <span class=\"user-mention\" data-user-id=\"463095\">@Yuri de Wit</span>! You've convinced me I want that in my library)</p>",
        "id": 275171459,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1647200664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110026\">Simon Hudon</span> <a href=\"#narrow/stream/270676-lean4/topic/Constrain.20function.20input.20to.20one.20constructor/near/275171459\">said</a>:</p>\n<blockquote>\n<p>(This is a really cool problem btw. Thanks <span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span>! You've convinced me I want that in my library)</p>\n</blockquote>\n<p>I am glad my ignorance was useful! Now I need to digest all this!</p>",
        "id": 275184197,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647218794
    },
    {
        "content": "<p>No one mentioned the simplest solution, which is to not accept <code>Term</code> at all and instead pass arguments <code>(name : String) (args: List Term)</code> to the function</p>",
        "id": 275188390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647225142
    },
    {
        "content": "<p>it's kind of an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> solution but it is usually easier to use than the other suggestions</p>",
        "id": 275188424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647225189
    },
    {
        "content": "<p>True, except that the real flatten (my fault, since I did not provided it in its full glory) is <code>def flatten : List Rule -&gt; RuleGroup</code> (RuleGroup is an <code>HashMap String (Array Rule)</code>).</p>\n<p>So I need to process a list of Rules (<code>structure Rule (lhs: Term) (rhs: Term)</code>) containing Term's, instead of a single Term.</p>",
        "id": 275192723,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647231519
    },
    {
        "content": "<p>Another solution would be to simply create a dedicated type for the left hand side at the expense of some duplication of the Ctr definition, as far as I can see.</p>",
        "id": 275192799,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1647231671
    },
    {
        "content": "<p>If you are just writing lean 4 code and are not fussed about proofs, you can just use <code>if let</code> and skip the elements that are not of the required form</p>",
        "id": 275192994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647231951
    },
    {
        "content": "<p>or <code>panic!</code> if you find them</p>",
        "id": 275193003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647231962
    }
]
[
    {
        "content": "<p>Comparing numbers like <code>a &lt; b &amp;&amp; c &lt;= d</code> seems to result in a <code>Bool</code>, but after implementing <code>LT</code>, <code>LE</code> and <code>Ord</code> for a structure, lean complains that <code>a &lt; b</code> is a <code>Prop</code> and not a <code>Bool</code>.  However, there don't seem to be <code>BLe</code> or <code>BLt</code> classes like with <code>BEq</code>. When does this automatic conversion between <code>Prop</code> and <code>Bool</code> work?</p>",
        "id": 265361238,
        "sender_full_name": "Joscha Mennicken",
        "timestamp": 1639775624
    },
    {
        "content": "<p>There are two coercions, one from <a href=\"https://github.com/leanprover/lean4/blob/d0d7799a7be936008adecd04d4701b9623aa5ff9/src/Init/Coe.lean#L108\">Bool to Prop</a> and one from <a href=\"https://github.com/leanprover/lean4/blob/d0d7799a7be936008adecd04d4701b9623aa5ff9/src/Init/Coe.lean#L117\">Decidable Props to Bool</a></p>",
        "id": 265362424,
        "sender_full_name": "Chris B",
        "timestamp": 1639776209
    },
    {
        "content": "<p>So I would need an <code>instance (a b : MyStructure) : Decidable (a &lt; b)</code> (and the same for <code>&lt;=</code>) in addition to my <code>LT</code> and <code>LE</code> instances to be able to use these comparisons in code</p>",
        "id": 265362881,
        "sender_full_name": "Joscha Mennicken",
        "timestamp": 1639776453
    },
    {
        "content": "<p>Yes, in general if then else statement can do a decision based on any proposition that implements the <code>Decidable</code> type class (either directly or through TC synthesis)</p>",
        "id": 265363234,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1639776645
    },
    {
        "content": "<p>If you're working with a structure and the fields implement <code>DecidableEq</code> and <code>Ord</code>, you can derive them for your new structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Ord</span>\n</code></pre></div>\n<p>And <code>Ord</code> gets you instances of LT and LE.</p>",
        "id": 265363409,
        "sender_full_name": "Chris B",
        "timestamp": 1639776757
    },
    {
        "content": "<p>Ah, <code>ltOfOrd</code> and <code>leOfOrd</code> give me the appropriate <code>Decidable</code> instances as a bonus</p>",
        "id": 265364104,
        "sender_full_name": "Joscha Mennicken",
        "timestamp": 1639777149
    },
    {
        "content": "<p>I have a related question: how do I require an instance of <code>Decidable</code> for a comparison?</p>\n<p>Here is a simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.HashSet</span>\n<span class=\"kn\">open</span> <span class=\"n\">Std</span>\n\n<span class=\"c1\">-- Question: Can this be generalized to a HashSet of α if there is LT.lt α?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">hs.toArray.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"n\">as.toList.toString</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">comp</span><span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">comp.lt</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">hs</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">hs.toArray.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"n\">as.toList.toString</span>\n</code></pre></div>\n<p>This has two errors:</p>\n<ul>\n<li><code>[Decidable comp.lt]</code> seems the wrong syntax to require a decidable comparison.</li>\n<li>The sort predicate is a <code>Prop</code>, not a <code>Bool</code></li>\n</ul>\n<p>How do I fix this?</p>",
        "id": 291468054,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1659240770
    },
    {
        "content": "<p>There's a couple of common patterns: </p>\n<ul>\n<li><code>[LT α] [DecidableRel (α:=α) (.&lt;.)]</code></li>\n<li><code>[LT α] [DecidableRel (.&lt;. : α → α → Prop)]</code></li>\n<li><code>[LT α] [DecidableRel (@LT.lt α)]</code></li>\n</ul>\n<p>Also consider using <code>[Ord α]</code> instead.</p>",
        "id": 291469414,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1659242675
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> !</p>\n<p>I managed to make this work with all the patterns you suggested!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.HashSet</span>\n<span class=\"kn\">open</span> <span class=\"n\">Std</span>\n\n<span class=\"c1\">-- Question: Can this be generalized to a HashSet of α if there is LT.lt α?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">hs.toArray.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"n\">as.toList.toString</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:=</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.&lt;.</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">hs.toArray.qsort</span> <span class=\"o\">(</span><span class=\"bp\">.&lt;.</span><span class=\"o\">)</span>\n    <span class=\"n\">as.toList.toString</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"bp\">.&lt;.</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">hs.toArray.qsort</span> <span class=\"o\">(</span><span class=\"bp\">.&lt;.</span><span class=\"o\">)</span>\n    <span class=\"n\">as.toList.toString</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">lt.lt</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">hs.toArray.qsort</span> <span class=\"o\">(</span><span class=\"bp\">.&lt;.</span><span class=\"o\">)</span>\n    <span class=\"n\">as.toList.toString</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ord</span><span class=\"o\">:</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">hs</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">hs.toArray.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ord.compare</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">==</span> <span class=\"n\">Ordering.lt</span><span class=\"o\">)</span>\n    <span class=\"n\">as.toList.toString</span>\n</code></pre></div>\n<p>The last one above seems to me like a TC bad smell since<code>(fun a b =&gt; ord.compare a b == Ordering.lt)</code> is clearly a duplication of Lean's TC instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT.lt</span> <span class=\"n\">α</span> <span class=\"n\">ltOfOrd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">compare</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">==</span> <span class=\"n\">Ordering.lt</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Is there a TC instantiation trick that would help avoid this unnecessary duplication?</p>",
        "id": 291505124,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1659292141
    }
]
[
    {
        "content": "<p>A common pattern in Coq to rewrite over custom relations is to prove congruence for certain functions with the <code>Proper</code> typeclass, and then use <code>rewrite</code> to rewrite their arguments.</p>\n<p>I've been digging around for a similar mechanism in Lean 4, but I couldn't come up with anything substantial. The notion of <code>Setoid</code> looks related but it only really works for equivalence relations. I saw that <code>simp</code> has a notion of \"congruence lemmas\" mentioned a few times in the code, but most of the info went back to Lean 3.</p>\n<p>Is this kind of rewriting possible? If so how would one go about it?</p>",
        "id": 302284881,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664896739
    },
    {
        "content": "<p>No, \"generalised rewriting\" is not implemented in Lean. You can sometimes achieve a similar effect by quotienting with an equivalence relation and then rewriting with propositional equality, but this is far from a full replacement.</p>\n<p>Several people have expressed interest in this mechanism recently, but it's a significant amount of coding effort. More than one good master thesis, I would guesstimate.</p>",
        "id": 302289571,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1664897926
    },
    {
        "content": "<p>I see. The project I'm working on only uses a few such relations, so I'm wondering whether a proof-of-concept for it could work out.</p>\n<p>But I guess the hard part is handling all the context... and it can't be as simple as looking up a congruence proof for each function call on the way up.</p>",
        "id": 302299190,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664900652
    },
    {
        "content": "<p>Conceptually, I don't think there's anything particularly difficult about it. If anyone wants to work on this, I'd be happy to help. A minimum viable version could be restricted to equivalence relations and respectful morphisms. Coq's design generalises in multiple directions, but these generalisations could be added later (and are more niche anyway).</p>",
        "id": 302301571,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1664901399
    },
    {
        "content": "<p>Alright, maybe I can give this a try in a limited setting. I've worked on extensions to Coq's <code>congruence</code> tactic at some point so I should be able to make some basic cases work t least... the harder part for me is doing the Lean metaprogramming side I think.</p>",
        "id": 302302306,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664901627
    },
    {
        "content": "<p>That sounds pretty interesting, I'd be happy to help on the Lean metaprogramming side <span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> (and I've been wanting to test some of the rewrite stuff on that particular project anyway)</p>",
        "id": 302323622,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1664908678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations/near/302301571\">said</a>:</p>\n<blockquote>\n<p>A minimum viable version could be restricted to equivalence relations and respectful morphisms.</p>\n</blockquote>\n<p>Quick note: equivalence relations are not closed under the respectful morphism construction so we actually have to start at PERs. It's mostly the same, fortunately.</p>",
        "id": 302334813,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664912770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations/near/302323622\">said</a>:</p>\n<blockquote>\n<p>That sounds pretty interesting, I'd be happy to help on the Lean metaprogramming side <span class=\"user-mention silent\" data-user-id=\"484617\">Sébastien Michelland</span> (and I've been wanting to test some of the rewrite stuff on that particular project anyway)</p>\n</blockquote>\n<p>Your help is more than welcome! Even on the theoretical side, where I have broad ideas about how to tackle the problem but no real expert knowledge to back it up.</p>",
        "id": 302335096,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664912891
    },
    {
        "content": "<p>I <a href=\"https://github.com/lephe/lean4-rewriting/blob/main/Rewriting.lean\">pushed some basic definitions</a> along with a trivial example where the goal is only applications. This should at least show what general process I have in mind.</p>\n<p>There are already difficult questions in terms of finding <code>Proper</code> instances. I'm not sure if I can make the typeclass engine find <em>all</em> solutions for a query. I'm tempted to just ask <code>Proper ?R f</code> for some function <code>f</code> at hand, and then check what <code>?R</code>s are found by making it an <code>outParam</code>. I'm not anticipating to have a large number of instances for a specific function, so it could work out for a start.</p>",
        "id": 302348037,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664918005
    },
    {
        "content": "<p>that's a cool start (makes it more concrete and easier to understand)! I'm a bit confused by the example though, you can't prove <code>Rβ (fαβ a) x</code> for that arbitrary <code>x</code>. Did you mean to prove <code>Rβ (fαβ a) x ↔ Rβ (fαβ a') x</code>, i.e. your <code>h₂</code>, where ideally the whole proof would go with a simple <code>by [h]</code>?</p>",
        "id": 302400014,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1664954576
    },
    {
        "content": "<p>or I don't really understand the example <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> what is the idea behind it  <span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> ?</p>",
        "id": 302400211,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1664954654
    },
    {
        "content": "<p>Oh the goal is indeed not provable. I made it this way to avoid Lean proving it automatically with a hypothesis or something. The \"demo\" ends after the rewrite.</p>",
        "id": 302400496,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664954784
    },
    {
        "content": "<p>I <a href=\"https://github.com/lephe/lean4-rewriting/commit/5affa315f10e9142b93425bfbb1dda53f30f51bd\">added some tests handling subrelations</a>, which is often necessary because non-rewritten arguments get an <code>Eq</code> in the respectful relation while in general <code>Proper</code> instances will be declared with more general types.</p>\n<p>Unsurprisingly, encoding the subrelation rules in this naive way already blows up TC resolution, even without the transitivity rule for <code>Subrel</code>. I'm guessing the proper way to do this would be to solve with a specialized algorithm or to write the typeclasses in a smart way to avoid the engine branching so much. Any insight here?</p>",
        "id": 302412632,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664959582
    },
    {
        "content": "<p><a href=\"https://jfr.unibo.it/article/view/1574\">This</a> seems to be the relevant paper.</p>",
        "id": 302416403,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1664961053
    },
    {
        "content": "<p>Thanks for digging it up. I've started to look at it, and I'm hopeful I can grasp it well enough. Writing the Lean code is another matter, but I'm sure I can get plenty of help here. :) </p>\n<p>Anyway, just to answer my previous question: handling subrelations is done in the main algorithm which is not typeclass driven; they eliminate it early to avoid searching and keep recursing on syntax (§2.3.2); and they assume the set of instances is transitive to never chain such rules. So that all checks out. I shall try and imitate that.</p>",
        "id": 302727816,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665085430
    },
    {
        "content": "<p>Quick update: I've started <a href=\"https://github.com/lephe/lean4-rewriting/blob/main/Rewriting/Algorithm.lean\">implementing the first algorithm</a> which traverses the goal and generates a set of intermediate relations, Proper instances and subrelation instances as metavariables. This is going pretty well, although I'm not quite sure if and how the context gets updated during the monadic code compared to what the paper expects.</p>\n<p>After that, it's all typeclass inference in the paper, but I don't know whether we can just solve a <em>set</em> of typeclass queries that share metavariables.</p>",
        "id": 303025592,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665239056
    },
    {
        "content": "<p>Reading the Coq source code, it also turns out that a fair amount of typeclass resolution is customized by using the fact that the typeclass resolution engine is a variant of <code>eauto</code>. By using hints that call into custom tactics, a number of instances are applied selectively and not put into the instance database, to avoid combinatorial explosions.</p>",
        "id": 303041983,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665247980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> I'm ending up with this kind of typeclass problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">Constraints</span> <span class=\"n\">to</span> <span class=\"n\">solve</span><span class=\"o\">:</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.455</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.459</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"n\">Rα</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.462</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.478</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.462</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.480</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.484</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.480</span> <span class=\"n\">x</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.486</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.496</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.462</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.480</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.486</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.508</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.486</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How can I solve/work towards solving this set of queries?</p>",
        "id": 303049143,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665252724
    },
    {
        "content": "<p>I've never looked into typeclass resolution much, but I'm not aware of any use of typeclasses in Lean 4 where we synthesise a set of interdependent instances all at once. So this may be difficult. We could try to solve each constraint in turn (in some sensible order) with backtracking, but (a) Lean's typeclass inference does not assign metavariables (except those it generates itself) and (b) I don't think we can get typeclass inference to give us multiple possible solutions. I don't really have another idea at the moment, short of implementing a custom search algorithm for this sort of problem. <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, as our resident typeclass tsar, do you maybe have an idea? (This is Lean 4, but the fundamentals are hopefully similar enough.)</p>\n<p>We definitely don't have support for extending typeclass inference with custom tactics, which, as you say, seems to be necessary to constrain the search. I've seen comments in the Lean 4 source code indicating that this feature is on the roadmap, but probably not any time soon.</p>",
        "id": 303242935,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665401920
    },
    {
        "content": "<p>So the part about extending typeclass search with tactics is probably fine - I can write custom tactics that call into the typeclass engine manually instead. For the instances that I've seen it almost feels straightforward.</p>\n<p>For the set of instances, one approach maybe is to see that all the dependencies are on <code>relation</code>s, so once these are chosen all of the instances can be solved for individually and in any order. I'm considering some kind of \"informed bruteforcing\" on that front, although I'm not quite sure how to discover the relations to use apart from enumerating <code>Proper</code>s and <code>Subrel</code>s - which, apparently, is not possible either. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 303247675,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665403686
    },
    {
        "content": "<p>Do you have an example where in-order, no-backtracking solving is not sufficient?</p>",
        "id": 303247907,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665403801
    },
    {
        "content": "<p>Yes. Consider a rewrite of <code>Rα a a'</code> into the goal <code>Pα a : Prop</code>. This gives you the following constraints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">Constraints</span> <span class=\"n\">to</span> <span class=\"n\">solve</span><span class=\"o\">:</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.449</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.453</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.449</span> <span class=\"n\">Pα</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.455</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.465</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.449</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.477</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Commonly, you will do this when <code>Pα</code> is proper for <code>Rα ==&gt; iff</code>, and thus you're aiming for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">?</span><span class=\"n\">m.449</span> <span class=\"o\">:=</span> <span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.453</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"n\">Pα</span> <span class=\"c1\">-- the main instance at play</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"o\">:=</span> <span class=\"n\">iff</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.465</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"c1\">-- trivial</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.477</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"c1\">-- standard</span>\n</code></pre></div>\n<p>Now assume you solve in the listing order. There is a valid instance of <code>?m.453</code> in <code>Proper Eq Pα</code>, which will cause <code>?m.465</code> to fail because the respectful relation is not reflexive. You need to guess the correct relation <code>?m.449</code> for that to succeed. Not only do you have to solve both queries that involve <code>?m.449</code>, but really the entire set because the first <code>Subrel</code> ties it to <code>?m.455</code>, the other relation that you have to guess.</p>\n<p>The core problem is that you need to guess a relation for every codomain of an application in the goal, so someone has to explore.</p>",
        "id": 303252354,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665405485
    },
    {
        "content": "<p>I suppose it might be possible to combine all contraints into a single instance problem by basically building a tree instead of a set, but I'm not sure if typeclasses are really the best solution here in Lean</p>",
        "id": 303254585,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665406380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484617\">Sébastien Michelland</span> <a href=\"#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations/near/303247675\">said</a>:</p>\n<blockquote>\n<p>So the part about extending typeclass search with tactics is probably fine - I can write custom tactics that call into the typeclass engine manually instead. For the instances that I've seen it almost feels straightforward.</p>\n</blockquote>\n<p>Only if the custom logic is at the top level. If you need custom logic every time an instance is considered during typeclass search, this is not currently possible afaik. (I haven't looked at the paper carefully enough to see whether we need this.)</p>\n<blockquote>\n<p>For the set of instances, one approach maybe is to see that all the dependencies are on <code>relation</code>s, so once these are chosen all of the instances can be solved for individually and in any order. I'm considering some kind of \"informed bruteforcing\" on that front, although I'm not quite sure how to discover the relations to use apart from enumerating <code>Proper</code>s and <code>Subrel</code>s - which, apparently, is not possible either. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>I would frame it like this: discovering the relations by enumerating <code>Proper</code>s and <code>Subrel</code>s is exactly what Coq's typeclass inference does, using unification.</p>\n<p>Maybe the solution really is to implement an approximation of <code>typeclasses eauto</code>. In principle, this should be no problem; we have nice backtrackable data structures. But I suspect the devil is very much in the details.</p>",
        "id": 303271289,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665412367
    },
    {
        "content": "<p>I agree with Jannis' assessment that this is going to be difficult with the standard synthesis algorithm. The only thing I can figure out right now is to bundle everything together into one huge class (with judicious use of <code>out_param</code>s?) and hope this is expressive enough to capture what you're looking for. But indeed a custom synthesis algorithm seems more practical at this point.</p>",
        "id": 303279171,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1665415126
    },
    {
        "content": "<p>Thanks for the input! After some consideration I shall try to write a custom algorithm. I'm afraid contorting the standard typeclass search for this would just result in a wild hack, and the generalized rewriting approach so far seems clean enough that I can imagine it being polished and merged in the future. I would like to keep it that way.</p>\n<p>I <a href=\"https://github.com/lephe/lean4-rewriting/blob/728491db5347b9f641a0d917128e8421eae0ecbc/GeneralizedRewriting/Eauto.lean\">pushed some outline</a>, but essentially my idea is to make a naive imitation of eauto, in the sense that:</p>\n<ul>\n<li>It would solve multiple goals by trying different hints (let's say theorems/instances for now), recursively, with backtracking.</li>\n<li>It would unify metavariables and, if needed, allow introducing new ones as temporaries.</li>\n</ul>\n<p>I believe I can make it work nicely by first focusing on getting instances from context (hypotheses) rather than typeclass search. This will both help me split debugging efforts, and act as a fallback to keep the tactic usable whenever the custom typeclass search inevitably fails to find relevant instances.</p>",
        "id": 303461043,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665501560
    },
    {
        "content": "<p>Some practical questions straight away:</p>\n<ul>\n<li>\n<p>How can I obtain a goal with a metavariable in an interactive proof? For instance <code>Proper ?R fαβ</code>. I tried <code>exists R, Proper R fαβ</code> then <code>refine ⟨?R, ?_⟩</code> but then the goal is just some <code>?m.806 ?R</code> and it doesn't unify with eg. <code>Proper (Rα ==&gt; Rβ) fαβ</code>. (Edit: the goal also no longer contains <code>Proper</code>. How does this work? Is <code>?m.806</code> delayed-assigned?)</p>\n</li>\n<li>\n<p>Attempting to unify instances with the goal will assign metavariables. How do I save/split the context so that I can roll back the assignment in case the current instance is not satisfactory?</p>\n</li>\n</ul>",
        "id": 303461987,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665501810
    },
    {
        "content": "<p>For the second question, look at <a href=\"https://github.com/arthurpaulino/lean4-metaprogramming-book/blob/master/md/main/metam.md#backtracking\">this chapter</a> of the metaprogramming book.</p>",
        "id": 303469348,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665503971
    },
    {
        "content": "<p>Basically, you can use the <code>MonadBacktrack</code> interface to store the current <code>MetavarContext</code> and roll back to it.</p>",
        "id": 303469504,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665504011
    },
    {
        "content": "<p>By the way, the current lack of generalized rewriting in Lean also was an issue for the Iris port, which Lars fixed via an ad-hoc implementation <a href=\"https://github.com/larsk21/iris-lean/blob/master/src/Iris/Std/Rewrite.lean\">https://github.com/larsk21/iris-lean/blob/master/src/Iris/Std/Rewrite.lean</a>. But crucially, there was no need for backtracking in this specific case.</p>",
        "id": 303471542,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665504697
    },
    {
        "content": "<p>Progress on this is <a href=\"https://github.com/lephe/lean4-rewriting/commit/81dc3cfb2bf0f9864e48b5b9032afcb6489e4371\">coming along</a>. With some help for Jannis, I now have a basic imitation of eauto that can close <a href=\"https://github.com/lephe/lean4-rewriting/blob/81dc3cfb2bf0f9864e48b5b9032afcb6489e4371/GeneralizedRewriting/TestsEauto.lean\">goals with backtracking</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P₁</span> <span class=\"n\">P₂</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P₂</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha'₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha'₂</span><span class=\"o\">:</span> <span class=\"n\">P₂</span> <span class=\"n\">a'</span><span class=\"o\">):</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">eauto</span>\n</code></pre></div>\n<p>The search for this one looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.eauto</span><span class=\"o\">]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">β</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P₂</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n  <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P₂</span> <span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">α</span>\n  <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">P₁</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">ha₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span>\n    <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">P₂</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[]</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">close</span> <span class=\"n\">the</span> <span class=\"n\">goal</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">ha'₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a'</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span>\n    <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">P₂</span> <span class=\"n\">a'</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">ha'₂</span><span class=\"o\">:</span> <span class=\"n\">P₂</span> <span class=\"n\">a'</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span>\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.eauto</span><span class=\"o\">]</span> <span class=\"n\">final</span> <span class=\"n\">proof</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a'</span> <span class=\"n\">ha'₁</span> <span class=\"n\">ha'₂</span>\n</code></pre></div>\n<p>The fact that several goals of depth 1 are nested might look counter-intuitive, but since the witness for <code>P₁ ?a</code> unifies away <code>?a</code> this also affects the other goal <code>P₂ ?a</code>, so the nesting is in fact correct.</p>\n<p>This is all very basic but that should be enough resolution power to get started on the typeclass problems for generalized rewriting. Next is trying these problems with local hypotheses, then wiring up lower-level routines of the typeclass synthesizer to query instances that unify with the goal.</p>",
        "id": 304239178,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665864037
    },
    {
        "content": "<p>That sort of example is handled by <code>solve_by_elim</code> in mathlib3. I'm a bit confused as to why the minimal <code>solve_by_elim</code> in mathlib4 is failing on it, actually!</p>",
        "id": 304270000,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665897707
    },
    {
        "content": "<p>I haven't tried, because I didn't know about this tactic! Thanks for bringing it up. Considering it was not recommended to me before, I'm suspecting it would not be able to handle the other two aspects of Coq's <code>typeclasses eauto</code> that I want/need to approximate : (1) querying typeclasses without synthesizing instances, instead leaving them as subgoals (apply in Lean4 does not support it currently), and (2) external hints in the form of using custom tactics when certain types of goals appear.</p>",
        "id": 304275757,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665904152
    },
    {
        "content": "<p>It doesn't do (1), but the mathlib3 version does have a <code>discharger</code> option which will run a custom tactic on each subgoal.</p>",
        "id": 304276342,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665904701
    },
    {
        "content": "<p>I've made some good progress on this.</p>\n<ul>\n<li>I added <a href=\"https://github.com/lephe/lean4-rewriting/blob/afd05d356b839f227613a5a0eb97ab2fb64871e8/GeneralizedRewriting/Eauto.lean#L79\">a variant of <code>apply</code></a> that does not synthesize implicit instance arguments. It seems to me that it could be an option of the original <code>apply</code>, let me know if that's worth discussing. <code>typeclasses_eauto</code> uses it.</li>\n<li>This allowed me to start using <a href=\"https://github.com/lephe/lean4-rewriting/blob/afd05d356b839f227613a5a0eb97ab2fb64871e8/GeneralizedRewriting/TestsEauto.lean#L61-L72\">normal instance declarations during the search</a> (provided they're in context), and thus solve some basic generalized-rewriting queries.</li>\n<li>I added <a href=\"https://github.com/lephe/lean4-rewriting/blob/afd05d356b839f227613a5a0eb97ab2fb64871e8/GeneralizedRewriting/Eauto.lean#L116-L126\">basic infrastructure to register hints</a>, which should work across different files. Hint databases can be specified in the command, which allows me do to things like:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">eauto_hint</span> <span class=\"n\">Subrel_respectful</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n<span class=\"n\">eauto_hint</span> <span class=\"n\">Reflexive.refl</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n<span class=\"n\">eauto_hint</span> <span class=\"n\">Reflexive_Subrel</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n<span class=\"n\">eauto_hint</span> <span class=\"n\">Subrel_Iff_flip_impl</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Rα</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Pα</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"n\">Pα</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">goal</span><span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">R₁</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">R₂</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n     <span class=\"n\">Proper</span> <span class=\"n\">R₁</span> <span class=\"n\">Pα</span> <span class=\"bp\">→</span>\n     <span class=\"n\">Subrel</span> <span class=\"n\">R₁</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n     <span class=\"n\">Subrel</span> <span class=\"n\">R₂</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">typeclasses_eauto</span> <span class=\"k\">with</span> <span class=\"n\">test_eauto</span>\n</code></pre></div>\n<p>which is an actual typeclass query for the simplest generalized rewriting instance.</p>",
        "id": 304321447,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665934824
    },
    {
        "content": "<p>I imagine that hints could be better integrated with the rest of Lean by using attributes. But there's still the question of extern hints that apply \"tactic expressions\" based on some pattern match. They didn't seem to fit, so I did the basic Coq imitation for now. Suggestions are welcome.</p>",
        "id": 304321674,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665934956
    },
    {
        "content": "<p>I got the <a href=\"https://github.com/lephe/lean4-rewriting/blob/main/GeneralizedRewriting/TestsGrewrite.lean#L20-L24\">simplest generalized rewrite</a> to work! It looks underwhelming, but it was a long way in the making. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>In the context, we have <code>Pα: α → Prop</code> which is <code>Proper (Rα ==&gt; Iff)</code>, allowing us to rewrite:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Rα</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"c1\">-- turns into Pα a'</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The full log is as follows. First, the generalized rewriting algorithm traverses the term to find occurrences and generate <code>Proper</code> and <code>Subrel</code> instances to apply along the way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">skeleton</span><span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"n\">type_f</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"o\">[]</span> <span class=\"n\">using</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">APP</span>\n  <span class=\"o\">[]</span> <span class=\"n\">skeleton</span><span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"n\">using</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">ATOM</span>\n  <span class=\"o\">[]</span> <span class=\"n\">skeleton</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"n\">using</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">UNIFY</span>\n</code></pre></div>\n<p>This generates a set of constraints involving intermediate relations that needs to be guessed (here <code>?m.438: relation (α → Prop)</code> and <code>?m.457: relation Prop</code>). The <code>flip impl</code> comes from the top-level, it is the relation that we can apply on the goal to make progress. (We could similarly rewrite on hypotheses by targeting <code>impl</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">constraints</span> <span class=\"n\">to</span> <span class=\"n\">solve</span><span class=\"o\">:</span>\n      <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.438</span> <span class=\"n\">Pα</span>\n      <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.438</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.457</span><span class=\"o\">)</span>\n      <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.457</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then the problem gets solved using <code>typeclasses_eauto with grewrite</code>. This runs the basic <code>eauto</code> imitation, with hints from the <code>grewrite</code> theorems (for all applicable theorems that are not typeclass instances), and also uses instances that the typeclass engine says unifies with the goal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.eauto</span><span class=\"o\">]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.438</span> <span class=\"n\">Pα</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">Proper_Rα</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"n\">Pα</span>\n  <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">Subrel</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.457</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">grewrite</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hint</span><span class=\"o\">:</span> <span class=\"n\">Reflexive.refl</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Reflexive</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span> <span class=\"n\">Reflexive</span> <span class=\"n\">Subrel</span>\n    <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">Reflexive</span> <span class=\"n\">Subrel</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Equiv.toReflexive</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Equiv</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">Reflexive</span> <span class=\"n\">R</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span> <span class=\"n\">Equiv</span> <span class=\"n\">Subrel</span>\n      <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]:</span> <span class=\"n\">Equiv</span> <span class=\"n\">Subrel</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[]</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">close</span> <span class=\"n\">the</span> <span class=\"n\">goal</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Reflexive_Subrel</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Reflexive</span> <span class=\"n\">Subrel</span>\n      <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">Subrel</span> <span class=\"n\">Iff</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"n\">Subrel_Iff_flip_impl</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"n\">Iff</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Note how we apply hypotheses (<code>Proper_Rα</code>), database hints (<code>Reflexive.refl</code>), and instances from the typeclass engine (<code>@Reflexive_Subrel</code>) all for this problem. There is also a bit of backtracking because the first instance we get is a false lead.</p>\n<p>There's still a bunch of bugs and none of the other tests work yet, but I'm happy with this first result. <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 304358705,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665961357
    },
    {
        "content": "<p>I fixed a couple of bugs this morning, then followed up with <a href=\"https://github.com/lephe/lean4-rewriting/commit/8302b922adfc81d81eafb80677018847f05f9eee\">performance tweaks</a> which mean that we have reasonable examples starting to work now!</p>\n<p>For instance, assuming we have <code>f: α → β</code> which is <code>Proper (Rα ==&gt; Rβ)</code> where <code>Rβ</code> is a PER, then we can rewrite this goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Rα</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finish</span><span class=\"o\">:</span> <span class=\"n\">Rβ</span> <span class=\"o\">(</span><span class=\"n\">fαβ</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"n\">Rβ</span> <span class=\"o\">(</span><span class=\"n\">fαβ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">finish</span>\n</code></pre></div>\n<p>The set of instances and hints behind the constraint solving is still very unpolished, but the infrastructure is clearly getting there!</p>",
        "id": 304519448,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666028474
    },
    {
        "content": "<p>As you scale up to bigger hint databases, probably the biggest performance improvement will be to put the hints in a <code>DiscrTree</code>. However, this also means that hints will be applied with <code>reducible</code> rather than <code>default</code> transparency (which is probably fine, but is an observable change).</p>",
        "id": 304523520,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666029616
    },
    {
        "content": "<p>So far I've only been looking at the search tree, and for that I think the lowest-hanging fruit is avoiding super-general instances and prioritizing hints properly.</p>\n<p>But I do have some concerns about the pattern of <code>commitIfNoEx</code> followed by applying a hypothesis which doesn't unify, then a rollback. In my examples I have ~15 elements in my local context + hint databases, so that's basically 15 rollbacks for every goal and subgoal, which surely can't be ideal. I considered doing that only for hints that unify, but unification already has side effects so it doesn't work; I guess that's why Coq's version is also based on the root symbol.</p>\n<p>So maybe <code>DiscrTree</code> is gonna help with that! I had no idea where to go for such a structure but it seems to be mostly cooked already so that's cool.</p>",
        "id": 304539876,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666034401
    },
    {
        "content": "<p>Yes, <code>DiscrTree</code> is precisely the data structure you need. It's essentially an expression trie which enables efficient lookup of expressions that may unify with the goal, up to reducible transparency. Afaict from the docs, Coq uses the same approach when you create your hint database with the <code>discriminated</code> option, which would be the default if not for compatibility concerns. Lean 4 also uses <code>DiscrTree</code>s for simp lemmas and typeclasses.</p>",
        "id": 304639665,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666084658
    },
    {
        "content": "<p>Btw, I just came across <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.sanitizeName#doc\">docs4#Lean.sanitizeName</a>, which you could use to prettify the tracing of local hints.</p>",
        "id": 304643342,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666086112
    },
    {
        "content": "<p>Ah never mind, this function is for making hygienic names, not for displaying them.</p>",
        "id": 304643550,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666086209
    },
    {
        "content": "<p>Thanks, I can look at that in the future. For now, I'm trying to implement occurrence selection (which essentially already works) and scaling things up.</p>\n<p>One problem I'm having is that the backtracking code catches all exceptions, and I failed to realize that I was hitting the heartbeat limit on some uncontrolled instance searches. I already have an easily-catchable internal exception for eauto failures, but there are also exceptions in <code>apply</code> that I don't control. So far I \"fixed\" the problem by pre-testing unification to throw my internal exception instead of just a message, and thus every message exception is bubbled back to the top-level. Is there a better way of achieving that?</p>",
        "id": 304666932,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666095865
    },
    {
        "content": "<p>I don't see a good solution. Maybe  the redundant <code>isDefEq</code> is least bad, though it's obviously not ideal.</p>\n<p>Does anyone else have opinions on this? (Tl;dr of the question: how do we distinguish whether an <code>apply</code> call failed because the types do not unify or because of a fatal error, e.g. hitting the heartbeat limit?) Now that I think about it, I'm sure I have similar problems in Aesop.</p>",
        "id": 304760529,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666108005
    },
    {
        "content": "<p>I'll stick to that for now, as in the worst case I can always internalize <code>apply</code> - it would just be some 40 more lines of code since I already have a variation of it.</p>",
        "id": 304805176,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666115175
    },
    {
        "content": "<p>Following deeper reflections on constraint ordering I realized the natural order was best if <a href=\"https://github.com/lephe/lean4-rewriting/commit/7b1f68a90a9e4891525b4016bb38eb78dbf5ae2e\">arguments are solved before functions</a>. This allowed me to scale my <a href=\"https://github.com/lephe/lean4-rewriting/commit/b4b1729089e880588bd280a3007fe76026f2c1ae\">occurrence selection</a>, and now under <code>Proper (Rα ==&gt; Prop) Pα</code> we have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Rα</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finish</span><span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"n\">a'</span><span class=\"o\">):</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Iff</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"n\">And</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">]⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Eq</span><span class=\"o\">)</span> <span class=\"n\">Pα</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]⟩</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">5</span> <span class=\"c1\">-- Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">5</span> <span class=\"c1\">-- Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Pα a' ∧ Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">3</span> <span class=\"c1\">-- Pα a' ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Pα a' ∧ Pα a' ∧ Pα a  ∧ Pα a' ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Pα a' ∧ Pα a' ∧ Pα a' ∧ Pα a' ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>For the extra <code>have</code>: the instance of <code>And</code> is just not registered yet, and I'm lacking properties on extensional equality so I had to provide that <code>Proper (Eq ==&gt; Eq)</code> which is always true. Using <code>have</code> is always a safety as well as an option to guide the search since it tries local declarations early.</p>",
        "id": 304806012,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666115456
    },
    {
        "content": "<p>I'm slowly running out of time to spend on this, so I'll be trying to wrap up and polish these basic use cases, with documentation and everything. Hopefully this can be expanded on in the future...</p>",
        "id": 304806144,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666115493
    }
]
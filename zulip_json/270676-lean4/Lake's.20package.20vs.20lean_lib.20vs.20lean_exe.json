[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> , first of all, I am impressed with limited experience with Lake so far. Well done!</p>\n<p>Now, I just updated to the latest Lake release and I am a bit confused by the meaning of <code>package</code>, <code>lean_lib</code> and <code>lean_exe</code>. I can´t claim I knew Lake before this change so this may not have anything to do with the latest update per-se.</p>\n<p>Here is a little stroll ... </p>\n<p>A <code>lake build</code> with an empty lakefile.lean (I explicitly removed its contents after running <code>lake new t</code>) gives me: <code>error: configuration file is missing a </code>package<code> declaration</code>, which is expected.</p>\n<p>So I added a package declaration (from the initial lakefile.lean created by lake):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">package</span> <span class=\"n\">t</span> <span class=\"o\">{</span>\n  <span class=\"c1\">-- add package configuration options here</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Now <code>lake build</code> gives me the following warning:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">warning</span><span class=\"o\">:</span> <span class=\"n\">Package</span> <span class=\"n\">targets</span> <span class=\"n\">are</span> <span class=\"n\">deprecated.</span> <span class=\"n\">Add</span> <span class=\"n\">a</span> <span class=\"bp\">`</span><span class=\"n\">lean_exe</span><span class=\"bp\">`</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"bp\">`</span><span class=\"n\">lean_lib</span><span class=\"bp\">`</span> <span class=\"n\">default</span> <span class=\"n\">target</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"n\">package</span> <span class=\"n\">instead.</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>So I added a <code>lean_exe</code> (again from the original lakefile.lean content):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[defaultTarget]</span>\n<span class=\"n\">lean_exe</span> <span class=\"n\">t</span> <span class=\"o\">{</span>\n  <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Main</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>And it builds fine, but the <code>package warning</code> is no longer there: is it deprecated or not? And if I removed the package and kept the lean_exe, I get the following error: <code>error: configuration file is missing a </code>package<code> declaration</code>. So it may not be deprecated after all?</p>\n<p>Now, if I add <code>lean_lib</code>back and have the original lakefile.lean created by the <code>new</code> command, it also builds fine. However, I see no difference in the generated files. Should <code>lean_lib</code> produce a .so or something like that?</p>\n<p>I also see that changing the package name in <code>package t</code> breaks the build, so it seems that <code>t</code> maps to a folder named T containing nested .lean files or a T.lean file (or both?). So I guess that gives me the meaning of <code>package</code>!</p>\n<p>Next, how do <code>package</code>'s are mapped to <code>lean_exe</code>/<code>lean_lib</code>.  Do all <code>package</code>'s in a lakefile.lean contribute to generated exes/libs? Or is there a way to mix and match?</p>\n<p>For now, sorry for the length of this message.</p>",
        "id": 286854521,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655775178
    },
    {
        "content": "<p>Btw, after renaming <code>package</code> to an inexistent (say t2 instead of t), I get an error that T is an unknown package, which makes sense. But shouldnt there be at least a warning that the t2 package does not exist?</p>",
        "id": 286854921,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655775531
    },
    {
        "content": "<p>Finally, should I instead open an issue in the repo?</p>",
        "id": 286854977,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655775590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286854521\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> , first of all, I am impressed with limited experience with Lake so far. Well done!</p>\n</blockquote>\n<p>Thanks! <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> </p>\n<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286854521\">said</a>:</p>\n<blockquote>\n<p>I can´t claim I knew Lake before this change so this may not have anything to do with the latest update per-se.</p>\n</blockquote>\n<p>Ah, yeah, this may be the pain point here. All the deprecation warnings were designed to make migration easy, but I can definitely see that they may be confusing if you aren't already familiar with the feature being deprecated.</p>\n<p>Basically, before v3.1, each package  could only have the equivalent of exactly  1 <code>lean_lib</code> and  1 <code>lean_exe</code> . The settings for these two targets were (and still technically are) embedded into the package configuration. Lake intelligently (maybe a bit too intelligently) deduced the initial configuration of these two targets from the package name (e.g., the <code>lean_lib</code> target is the upper camel case version of the name and the <code>lean_exe</code> target was package name's exactly with a root of <code>Main</code>).</p>\n<p>Now, in v3.1, these embedded targets have been deprecated (hence the \"Package targets\" warning) and the user is expected to separately specify the <code>lean_lib</code> and <code>lean_exe</code> targets they wish to include. However, to make migration less painful (and too try and not break every lakefile previously in existence immediately), Lake will still fall back onto the embedded package targets if no other targets have been specified.  This results in all the weird behavior you are observing with files with just a <code>package</code> and without a <code>@[defaultTarget]</code>.</p>\n<p>Now, to your question:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286854521\">said</a>:</p>\n<blockquote>\n<p>And it builds fine, but the <code>package warning</code> is no longer there: is it deprecated or not? And if I removed the package and kept the lean_exe, I get the following error: <code>error: configuration file is missing a </code>package<code> declaration</code>. So it may not be deprecated after all?</p>\n</blockquote>\n<p>The <code>package</code> declaration itself has not been deprecated only the previous feature of an embedded <code>lean_lib</code> / <code>lean_exe</code> <em>within</em> the declaration has been.  A better warning would probably have been \"warning: Configuration has a <code>package</code> declaration but no targets. Defining targets within the <code>package</code> declaration has been deprecated. You now need to specify separate <code>lean_exe</code> and/or <code>lean_lib</code> targets to build.\"</p>",
        "id": 286855829,
        "sender_full_name": "Mac",
        "timestamp": 1655776490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286854521\">said</a>:</p>\n<blockquote>\n<p>Now, if I add <code>lean_lib</code>back and have the original lakefile.lean created by the <code>new</code> command, it also builds fine. However, I see no difference in the generated files. Should <code>lean_lib</code> produce a .so or something like that?</p>\n</blockquote>\n<p>How are you building the target? Are you using <code>lake build</code>? If so, it will only build by default if you have marked it as a <code>@[defaultTarget]</code>. Furthemore, <code>lean_lib</code>, by default, just builds Lean binary files for its modules (i.e., their <code>.olean</code> and <code>*.ilean</code>). To build a static or shared library for the target you can do <code>lake build &lt;target-name&gt;:static</code> or <code>lake build &lt;target-name&gt;:shared</code>. (See <code>lake help build</code> for more information.)</p>",
        "id": 286856193,
        "sender_full_name": "Mac",
        "timestamp": 1655776868
    },
    {
        "content": "<p>one thing that I found difficult was how to do the equivalent of <code>packageFacet := .oleans</code> or whatever it was called</p>",
        "id": 286860462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655781576
    },
    {
        "content": "<p>I see there is a syntax for selecting facets in <code>lake build &lt;stuff&gt;</code> but the syntax is rather impenetrable</p>",
        "id": 286860533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655781629
    },
    {
        "content": "<p>for example, how can I build mathlib <code>*.c</code> files? It isn't normally set up to do this, it's a olean library only, but I used to modify the default facet to make this work</p>",
        "id": 286860591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655781713
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>lake build c   <span class=\"c1\"># error: unknown target `c`</span>\nlake build +c   <span class=\"c1\"># error: unknown module `c`</span>\nlake build :c   <span class=\"c1\"># error: unknown package facet `c`</span>\nlake build Mathlib:c   <span class=\"c1\"># error: unknown library facet `c`</span>\nlake build Mathlib+:c   <span class=\"c1\"># error: unknown target `Mathlib+`</span>\n</code></pre></div>",
        "id": 286860799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655781926
    },
    {
        "content": "<p>it doesn't help that I don't really understand what module / library / package facets are</p>",
        "id": 286860959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655782086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> there is a direct way to build the <code>.c</code> files of a library target. You can use <code>lake build mathlib:static</code> to build a static library which will, to do so, produce the <code>.c</code> files of the library.</p>",
        "id": 286862082,
        "sender_full_name": "Mac",
        "timestamp": 1655783218
    },
    {
        "content": "<p>I see in the documentation a something facet called <code>c</code>. How do I use it?</p>",
        "id": 286862108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783261
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">MODULE</span> <span class=\"n\">FACETS</span><span class=\"o\">:</span>\n  <span class=\"o\">[</span><span class=\"n\">default</span><span class=\"o\">]</span>             <span class=\"n\">build</span> <span class=\"n\">the</span> <span class=\"n\">module's</span> <span class=\"bp\">*.</span><span class=\"n\">olean</span> <span class=\"n\">and</span> <span class=\"bp\">*.</span><span class=\"n\">ilean</span> <span class=\"n\">files</span>\n  <span class=\"n\">c</span>                     <span class=\"n\">build</span> <span class=\"n\">the</span> <span class=\"n\">module's</span> <span class=\"bp\">*.</span><span class=\"n\">c</span> <span class=\"n\">file</span>           <span class=\"bp\">&lt;</span><span class=\"c1\">--</span>\n  <span class=\"n\">o</span>                     <span class=\"n\">build</span> <span class=\"n\">the</span> <span class=\"n\">module's</span> <span class=\"bp\">*.</span><span class=\"n\">o</span> <span class=\"n\">file</span>\n</code></pre></div>",
        "id": 286862156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286860462\">said</a>:</p>\n<blockquote>\n<p>one thing that I found difficult was how to do the equivalent of <code>packageFacet := .oleans</code> or whatever it was called</p>\n</blockquote>\n<p>A library target (i.e., <code>lean_lib</code>), by default, only builds the Lean binary (i.e., <code>.olean</code> / <code>.ilean</code>) files. So no extra setting is needed.</p>",
        "id": 286862157,
        "sender_full_name": "Mac",
        "timestamp": 1655783297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286862108\">said</a>:</p>\n<blockquote>\n<p>I see in the documentation a something facet called <code>c</code>. How do I use it?</p>\n</blockquote>\n<p><code>lake build My.Module:c</code> or, unambiguously, <code>lake build +My.Module:c</code></p>",
        "id": 286862200,
        "sender_full_name": "Mac",
        "timestamp": 1655783344
    },
    {
        "content": "<p>so what if I want to temporarily modify it so that it also produces c files?</p>",
        "id": 286862209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783348
    },
    {
        "content": "<p>That didn't work above, <code>Mathlib:c</code> says unknown library facet</p>",
        "id": 286862223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286862209\">said</a>:</p>\n<blockquote>\n<p>so what if I want to temporarily modify it so that it also produces c files?</p>\n</blockquote>\n<p>build a target that requires them (i.e., the static or shared library or an exe using the library).</p>",
        "id": 286862224,
        "sender_full_name": "Mac",
        "timestamp": 1655783394
    },
    {
        "content": "<p><code>+Mathlib:c</code> works</p>",
        "id": 286862279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783433
    },
    {
        "content": "<p>what is it ambiguous with?</p>",
        "id": 286862283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286862283\">said</a>:</p>\n<blockquote>\n<p>what is it ambiguous with?</p>\n</blockquote>\n<p>The whole library. That is, <code>Mathlib</code> refers to the <code>lean_lib</code> target whereas <code>+Mathlib</code> refers to the module <code>Mathlib</code> (of the <code>Mathlib</code> library).</p>",
        "id": 286862324,
        "sender_full_name": "Mac",
        "timestamp": 1655783499
    },
    {
        "content": "<p>My suggestion would be to have <code>c</code> and <code>o</code> also be library facets, which act like the corresponding module facet for the root module</p>",
        "id": 286862378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783560
    },
    {
        "content": "<p>Yeah, seems like a fine idea. I'll add it to the TODO list.</p>",
        "id": 286862409,
        "sender_full_name": "Mac",
        "timestamp": 1655783589
    },
    {
        "content": "<p>in the other direction, <code>lean</code> could be a module facet (a synonym for the default), and possibly also <code>static</code> and <code>shared</code> (build whatever it would normally build but only for the selected module)</p>",
        "id": 286862529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783742
    },
    {
        "content": "<p>if all of the different kind of facets could be unified I think it would make things a lot clearer</p>",
        "id": 286862577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655783777
    },
    {
        "content": "<blockquote>\n<p>How are you building the target? Are you using lake build? If so, it will only build by default if you have marked it as a @[defaultTarget]. Furthemore, lean_lib, by default, just builds Lean binary files for its modules (i.e., their .olean and *.ilean). To build a static or shared library for the target you can do lake build &lt;target-name&gt;:static or lake build &lt;target-name&gt;:shared. (See lake help build for more information.)</p>\n</blockquote>\n<p>I see: RTFM! :-)</p>",
        "id": 286898968,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655810909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286860959\">said</a>:</p>\n<blockquote>\n<p>it doesn't help that I don't really understand what module / library / package facets are</p>\n</blockquote>\n<p>I think this is part of my difficulties too, compounded by my own baggage.</p>\n<p>From Lake's README:</p>\n<blockquote>\n<p>To create a new package, either run lake init &lt;package-name&gt; to setup the package in the current directory or lake new &lt;package-name&gt; to create it in a new directory.</p>\n</blockquote>\n<p>I initially thought that the &lt;package-name&gt; folder and the contained lakefile.lean were one package containing multiple .lean modules (some of the README content seems to corroborate). The 3.1 changes made it clear that neiter the &lt;package-name&gt; folder nor the lakefile.lean contained there represents one package, but potentially more than one. The lakefile.lean contains the description of one or more packages. I guess this raises other questions related to importing/sourcing specific packages.</p>\n<blockquote>\n<p>A Lean library target defines a set of Lean modules available to import and how to build them.</p>\n</blockquote>\n<p>So is lean_lib what is really a collection of .lean modules instead of the package? If so, how are packages related to libraries?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">require</span> <span class=\"n\">mathlib</span> <span class=\"k\">from</span> <span class=\"n\">git</span>\n  <span class=\"s2\">\"https://github.com/leanprover-community/mathlib4.git\"</span><span class=\"bp\">@</span><span class=\"s2\">\"master\"</span>\n</code></pre></div>\n<p>I am not sure what <code>require</code> here means. Is this sourcing the lakefile.lean from mathlib4.git including all package's, lean_lib's and lean_exe's included there? Or I misundertood and <code>https://github.com/leanprover-community/mathlib4.git\"@\"master</code> here always means the same set of .lean modules?</p>\n<p>Note that I am assuming that a module here means one .lean file that is independent of its Lean namespace.</p>",
        "id": 286906337,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655815121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286906337\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286860959\">said</a>:</p>\n<blockquote>\n<p>it doesn't help that I don't really understand what module / library / package facets are</p>\n</blockquote>\n<p>I think this is part of my difficulties too, compounded by my own baggage.</p>\n</blockquote>\n<p>It seems like it may be useful to have a glossary of some terms in the README (e.g., workspace, package, facet, library, module, etc.).</p>",
        "id": 286931949,
        "sender_full_name": "Mac",
        "timestamp": 1655825744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286906337\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286860959\">said</a>:</p>\n<blockquote>\n<p>it doesn't help that I don't really understand what module / library / package facets are</p>\n</blockquote>\n<p>I initially thought that the &lt;package-name&gt; folder and the contained lakefile.lean were one package containing multiple .lean modules (some of the README content seems to corroborate). The lakefile.lean contains the description of one or more packages.</p>\n</blockquote>\n<p>At lakefile <em>is</em> meant to represent the configuration of a single <em>package</em>.  However, the package can contain dependencies (i.e., through <code>require</code>). Collectively, the root package and its transitive dependencies make up the <strong>workspace</strong>.</p>\n<p>A <strong>package</strong> itself is a set of build targets (i.e., things one cand <code>lake build &lt;target&gt;</code>) and other configuration options. In addition to Lean modules, the package can contain information on how to configure the server and build external libraries, executables, and more (to come).  </p>\n<p>To answer your question:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286906337\">said</a>:</p>\n<blockquote>\n<p>I am not sure what <code>require</code> here means. Is this sourcing the lakefile.lean from mathlib4.git including all package's, lean_lib's and lean_exe's included there?</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 286933597,
        "sender_full_name": "Mac",
        "timestamp": 1655826268
    },
    {
        "content": "<blockquote>\n<p>At lakefile is meant to represent the configuration of a single package</p>\n</blockquote>\n<p>I am assuming that there can be only one <code>package</code> directive in a lakefile.lean then, right?</p>",
        "id": 286934504,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655826607
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286860959\">said</a>:</p>\n<blockquote>\n<p>it doesn't help that I don't really understand what module / library / package facets are<br>\n</p>\n</blockquote>\n</blockquote>\n<p>To give a quick explanation, a <strong>facet</strong> is a part of an otherwise configured target (e.g., module / library / executable) that can be independently built (i.e., through <code>lake build &lt;target&gt;:&lt;facet&gt;</code>). </p>\n<p>There is thus some potential confusion between a package facet and a target. After all, targets could simply be considered a facet of some package. This is largely true, and  the notion of a package facet is simply a left over of pre-v3.1 where it was not possible to separately configure multiple targets for a package. From v3.1 onwards, the notion of a package facet has been deprecated (and replaced with configurable targets of said package).</p>",
        "id": 286935016,
        "sender_full_name": "Mac",
        "timestamp": 1655826790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/286934504\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>At lakefile is meant to represent the configuration of a single package</p>\n</blockquote>\n<p>I am assuming that there can be only one <code>package</code> directive in a lakefile.lean then, right?</p>\n</blockquote>\n<p>Yep. Doing otherwise will give you and error. :)</p>",
        "id": 286935123,
        "sender_full_name": "Mac",
        "timestamp": 1655826832
    },
    {
        "content": "<p>I should have tried before asking ... in any case, why do I need to specify a name in the <code>package</code> directive?</p>\n<p>In any case, I think Lake model is much closer than what I thought initially. Thanks for the explanations.</p>",
        "id": 286935332,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655826902
    },
    {
        "content": "<p>I also found this very educational, would be great to capture some of this info in some helpful VSCode commands to help users manage Lake their packages...  if you have ideas on how to do that please add vscode-lean4 issue suggestions.</p>",
        "id": 286970081,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1655843150
    },
    {
        "content": "<p>I guess, <span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> , some ideas may follow naturally from this and other discussions. I, at least, am in the understand phase trying to keep my \"opinionated\" hat far away.</p>",
        "id": 286972179,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655844268
    },
    {
        "content": "<p>Found a <a href=\"https://blog.racket-lang.org/2015/08/modules-packages-and-collections.html\">https://blog.racket-lang.org/2015/08/modules-packages-and-collections.html</a> of how Racket organizes code and I hope it can give some references on how other languages describe these concepts. At least, this is a point of comparison.</p>\n<p>A <strong>module</strong> is the basic unit of functionality for code. Once the code grows we split them over multiple modules. This allows us to organize the source code better, enables separate compilation, etc. Note that a module in Racket dont necessarily mean, afaik, a single <code>.rkt</code> file because you could have more than one file contributing to the same module (using the <code>(module+ ...)</code> form) or even multiple modules within the same <code>.rkt</code> file. Racket does support submodules, afaiu.</p>\n<p>A <strong>package</strong> is a group of modules that you can install together, and that usually provide one piece of functionality. <a href=\"https://pkgs.racket-lang.org/package/pict3d\">Here</a> is an example of a package in Racket with its collection of modules. I.e packages are <strong>units of code distribution</strong>.</p>\n<p>A <strong>collection</strong> is a group of modules whose functionality is related to the same topic, for example data structures (the data collection). That is why modules in racket are referenced as <code>&lt;collection&gt;/&lt;module&gt;</code>: e.g. <code>racket/class</code> - the class module from the racket collection. Note that modules from a collection may come from any package (e.g. the <code>hamt</code> package provide a <code>data/hamt</code> containing data structures to the <code>data</code> collection). So, to sum up, collections are <strong>units of code</strong> classification.</p>\n<p>And finally, the term <strong>library</strong> does not have a technical meaning in Racket. This usually use refers to a package, or to a set of packages that are developed together. E.g. the Rackunit library is split across multiple packages: rackunit, rackunit-lib, rackunit-gui, etc, and you can only depend on individual packages from the Rackunit library.</p>",
        "id": 287090297,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655920610
    },
    {
        "content": "<p>Here are my own observations (please, take it with a grain of salt).</p>\n<p>The notion of <strong>collection</strong> is novel to me, at least. It puts front and center the module classification (metadata) as part of the module reference. I see something similar taking place in Haskell, for instance, when same modules use the <code>Data.</code> prefix in namespaces, etc.</p>\n<p>One notable difference between Racket and Lean is that all code and forms are always contained in a module: nothing happens without a module name (and corresponding language for the module). In Lean, it seems that code may or may not reside in namespaces.</p>\n<p>We tend to use the more low level notion of an exe vs lib (necessary since we do want to produce executables and system libraries), but it seems that for Racket this is just an secondary fact: whether the module(s) have a main function (granted Racket is a dynamic language).</p>",
        "id": 287092200,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1655921531
    },
    {
        "content": "<blockquote>\n<p>One notable difference between Racket and Lean is that all code and forms are always contained in a module: nothing happens without a module name (and corresponding language for the module). In Lean, it seems that code may or may not reside in namespaces. This seems to be a problem for Racket because of their language or languages approach: bootstrapping the language to be used starts with a named module.</p>\n</blockquote>\n<p>In lean, all code resides in a module. A lean module is just a file; it has a name that derives primarily from its location on the filesystem (although I think lake can customize that to some extent).</p>",
        "id": 287098512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655924535
    },
    {
        "content": "<p>\"namespaces\" are not a unit of code organization at all, they are a unit of API organization</p>",
        "id": 287098579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1655924576
    },
    {
        "content": "<p>AFAIK C++ namespaces work more or less the same way as Lean namespaces (although they may not be used the same way in practice); that might be a more fruitful comparison</p>",
        "id": 287109553,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655930088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/287090297\">said</a>:</p>\n<blockquote>\n<p>Found a <a href=\"https://blog.racket-lang.org/2015/08/modules-packages-and-collections.html\">https://blog.racket-lang.org/2015/08/modules-packages-and-collections.html</a> of how Racket organizes code and I hope it can give some references on how other languages describe these concepts. At least, this is a point of comparison.</p>\n</blockquote>\n<p>Here is how I would map the concepts from Racket to Lean based on what you've said: </p>\n<ul>\n<li>A <strong>Racket module</strong> is cross between a <strong>Lean namespace</strong> and a <strong>Lean module</strong>. It can be split across multiple files (like a Lean namespace) but has a single global hierarchy which all code must  be a part of (like a Lean module).</li>\n<li>A <strong>Racket package</strong> is essentially the same as a <strong>Lean package</strong> -- both are units of code distribution.</li>\n<li>A <strong>Racket collection</strong> is cross between the notion of a <strong>Lake library</strong> and a <strong>Lean module root</strong>.  The difference is that a Lake library is package specific, so in your Racket example of Rackunit, the <code>rackunit-lib</code>, <code>rackunit-gui</code>, etc. would be separate libraries. However, they could all contribute to the same root (i.e., <code>Rackunit</code>) to form a single collection of modules (e.g., <code>rackunit-gui</code> could contribute the modules under <code>Rackunit.Gui</code>).</li>\n</ul>",
        "id": 287117055,
        "sender_full_name": "Mac",
        "timestamp": 1655933766
    },
    {
        "content": "<p>My understanding of Racket's module system was a bit off:</p>\n<ul>\n<li>\n<p>there is no concept of a multi-file module: each file is a single module and it can be declared using a short form <code>#lang &lt;language&gt;</code>, which expands to the <code>(module ...)</code> form using the file name as the module name (no paths, just the filename). So a .lean file corresponds to a .rkt module with an implicit <code>#lang lean</code>).</p>\n</li>\n<li>\n<p>Importing other modules can be done using a file path (relative or absolute): e.g. <code>(require \"../a.rkt\")</code>. In this case, there is no search involved, just a direct file reference. Using relative paths seem to allow for invoking individual modules, but best practices is to avoid relative paths. Lean relies on the full module path, which is nice: a single way of importing whether intra- or extra-package at the small expense of having to fix a root.</p>\n</li>\n<li>\n<p>Or a module can be imported using the package name e.g. <code>(require data)</code>, which means that the <code>main.rkt</code> module will be imported, or `(require data/queue) which will import queue.rkt from the data collection. This involves searching the installed packages.</p>\n</li>\n<li>\n<p>The only out-of-the-box way to contribute bindings to another package, is to use collections and only by adding additional modules to the collection not extending/changing existing modules.</p>\n</li>\n</ul>",
        "id": 287260745,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1656019694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/287098579\">said</a>:</p>\n<blockquote>\n<p>\"namespaces\" are not a unit of code organization at all, they are a unit of API organization</p>\n</blockquote>\n<p>You helped me understand how namespaces are important in Lean. It is a key difference between Racket and Lean since Racket does not support namespaces, only modules, packages and collections, afaiu. Anything like Lean's namespace extensibility would have to be custom coded into an extension protocol.</p>",
        "id": 287261221,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1656019959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/287109553\">said</a>:</p>\n<blockquote>\n<p>AFAIK C++ namespaces work more or less the same way as Lean namespaces (although they may not be used the same way in practice); that might be a more fruitful comparison</p>\n</blockquote>\n<p>Thanks. I will take a look at it. But I think I will explore rust's  module system and package management first.</p>",
        "id": 287261347,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1656020026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/287117055\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">*</span> <span class=\"n\">A</span> <span class=\"bp\">**</span><span class=\"n\">Racket</span> <span class=\"n\">module</span><span class=\"bp\">**</span> <span class=\"n\">is</span> <span class=\"n\">cross</span> <span class=\"n\">between</span> <span class=\"n\">a</span> <span class=\"bp\">**</span><span class=\"n\">Lean</span> <span class=\"kn\">namespace</span><span class=\"bp\">**</span> <span class=\"n\">and</span> <span class=\"n\">a</span> <span class=\"bp\">**</span><span class=\"n\">Lean</span> <span class=\"n\">module</span><span class=\"bp\">**.</span> <span class=\"n\">It</span> <span class=\"n\">can</span> <span class=\"n\">be</span> <span class=\"n\">split</span> <span class=\"n\">across</span> <span class=\"n\">multiple</span> <span class=\"n\">files</span> <span class=\"o\">(</span><span class=\"n\">like</span> <span class=\"n\">a</span> <span class=\"n\">Lean</span> <span class=\"kn\">namespace</span><span class=\"o\">)</span> <span class=\"n\">but</span> <span class=\"n\">has</span> <span class=\"n\">a</span> <span class=\"n\">single</span> <span class=\"n\">global</span> <span class=\"n\">hierarchy</span> <span class=\"n\">which</span> <span class=\"n\">all</span> <span class=\"n\">code</span> <span class=\"n\">must</span>  <span class=\"n\">be</span> <span class=\"n\">a</span> <span class=\"n\">part</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">like</span> <span class=\"n\">a</span> <span class=\"n\">Lean</span> <span class=\"n\">module</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Right, the only thing is that Racket does not support extending namespaces like Lean does.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">*</span> <span class=\"n\">A</span> <span class=\"bp\">**</span><span class=\"n\">Racket</span> <span class=\"n\">package</span><span class=\"bp\">**</span> <span class=\"n\">is</span> <span class=\"n\">essentially</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">as</span> <span class=\"n\">a</span> <span class=\"bp\">**</span><span class=\"n\">Lean</span> <span class=\"n\">package</span><span class=\"bp\">**</span> <span class=\"c1\">-- both are units of code distribution.</span>\n</code></pre></div>\n<p>Right.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">*</span> <span class=\"n\">A</span> <span class=\"bp\">**</span><span class=\"n\">Racket</span> <span class=\"n\">collection</span><span class=\"bp\">**</span> <span class=\"n\">is</span> <span class=\"n\">cross</span> <span class=\"n\">between</span> <span class=\"n\">the</span> <span class=\"n\">notion</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"bp\">**</span><span class=\"n\">Lake</span> <span class=\"n\">library</span><span class=\"bp\">**</span> <span class=\"n\">and</span> <span class=\"n\">a</span> <span class=\"bp\">**</span><span class=\"n\">Lean</span> <span class=\"n\">module</span> <span class=\"n\">root</span><span class=\"bp\">**.</span>  <span class=\"n\">The</span> <span class=\"n\">difference</span> <span class=\"n\">is</span> <span class=\"n\">that</span> <span class=\"n\">a</span> <span class=\"n\">Lake</span> <span class=\"n\">library</span> <span class=\"n\">is</span> <span class=\"n\">package</span> <span class=\"n\">specific</span><span class=\"o\">,</span> <span class=\"n\">so</span> <span class=\"k\">in</span> <span class=\"n\">your</span> <span class=\"n\">Racket</span> <span class=\"kd\">example</span> <span class=\"n\">of</span> <span class=\"n\">Rackunit</span><span class=\"o\">,</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">rackunit</span><span class=\"bp\">-</span><span class=\"n\">lib</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">rackunit</span><span class=\"bp\">-</span><span class=\"n\">gui</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">etc.</span> <span class=\"n\">would</span> <span class=\"n\">be</span> <span class=\"n\">separate</span> <span class=\"n\">libraries.</span> <span class=\"n\">However</span><span class=\"o\">,</span> <span class=\"n\">they</span> <span class=\"n\">could</span> <span class=\"n\">all</span> <span class=\"n\">contribute</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">root</span> <span class=\"o\">(</span><span class=\"n\">i.e.</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">Rackunit</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"n\">to</span> <span class=\"n\">form</span> <span class=\"n\">a</span> <span class=\"n\">single</span> <span class=\"n\">collection</span> <span class=\"n\">of</span> <span class=\"n\">modules</span> <span class=\"o\">(</span><span class=\"n\">e.g.</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">rackunit</span><span class=\"bp\">-</span><span class=\"n\">gui</span><span class=\"bp\">`</span> <span class=\"n\">could</span> <span class=\"n\">contribute</span> <span class=\"n\">the</span> <span class=\"n\">modules</span> <span class=\"n\">under</span> <span class=\"bp\">`</span><span class=\"n\">Rackunit.Gui</span><span class=\"bp\">`</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Do you have an example of a single Lean package that produces more than one library or exe? I am likely missing something here.</p>",
        "id": 287262001,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1656020429
    },
    {
        "content": "<p>And here is an example of a Racket package:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">.</span>\n<span class=\"bp\">├──</span> <span class=\"n\">info.rkt</span>\n<span class=\"bp\">├──</span> <span class=\"n\">main.rkt</span>\n<span class=\"bp\">├──</span> <span class=\"n\">scribblings</span>\n<span class=\"bp\">│</span>   <span class=\"bp\">├──</span> <span class=\"n\">base.rkt</span>\n<span class=\"bp\">│</span>   <span class=\"bp\">└──</span> <span class=\"n\">bestfit.scrbl</span>\n</code></pre></div>\n<p>Info.rkt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">lang</span> <span class=\"n\">setup</span><span class=\"bp\">/</span><span class=\"n\">infotab</span>\n\n<span class=\"o\">(</span><span class=\"n\">define</span> <span class=\"n\">version</span> <span class=\"s2\">\"0.2\"</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">define</span> <span class=\"n\">collection</span> <span class=\"s2\">\"bestfit\"</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">define</span> <span class=\"n\">name</span> <span class=\"s2\">\"bestfit\"</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">define</span> <span class=\"n\">deps</span> <span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"s2\">\"base\"</span> <span class=\"s2\">\"typed-racket-lib\"</span> <span class=\"s2\">\"plot-lib\"</span> <span class=\"s2\">\"plot-gui-lib\"</span> <span class=\"s2\">\"math-lib\"</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">define</span> <span class=\"n\">build</span><span class=\"bp\">-</span><span class=\"n\">deps</span> <span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"s2\">\"racket-doc\"</span> <span class=\"s2\">\"typed-racket-doc\"</span> <span class=\"s2\">\"scribble-lib\"</span> <span class=\"s2\">\"math-doc\"</span> <span class=\"s2\">\"plot-doc\"</span><span class=\"o\">))</span>\n\n<span class=\"o\">(</span><span class=\"n\">define</span> <span class=\"n\">scribblings</span> <span class=\"bp\">'</span><span class=\"o\">((</span><span class=\"s2\">\"scribblings/bestfit.scrbl\"</span> <span class=\"o\">())))</span>\n</code></pre></div>\n<p>(Note how <code>#lang</code> here allows for specifying the specific custom language/DSL being used, which is orthogonal to modules, but a selling point in Racket that could also be explored by Lean considering how it can be used to create custom DSLs with custom syntax/notation).</p>\n<p>Notice that <code>(define collection \"bestfit\")</code> defines the collection for the package (fyi: this is a single-collection package). A module can <code>(require bestfit)</code> and import the <code>main.rkt</code> module from the bestfit package or it can <code>(require bestfit/scribblings/base)</code> import the base.rkt module directly.</p>\n<p>From Package concepts:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">The</span> <span class=\"n\">package</span> <span class=\"n\">name</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">mentioned</span> <span class=\"k\">with</span> <span class=\"n\">require</span><span class=\"o\">,</span> <span class=\"n\">because</span> <span class=\"n\">packages</span> <span class=\"n\">are</span> <span class=\"n\">a</span> <span class=\"n\">way</span> <span class=\"n\">of</span> <span class=\"n\">managing</span> <span class=\"n\">library</span> <span class=\"n\">collections</span><span class=\"o\">,</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"n\">way</span> <span class=\"n\">of</span> <span class=\"n\">referencing</span> <span class=\"n\">them.</span> <span class=\"n\">It</span> <span class=\"n\">is</span> <span class=\"n\">common</span><span class=\"o\">,</span> <span class=\"n\">however</span><span class=\"o\">,</span> <span class=\"n\">for</span> <span class=\"n\">a</span> <span class=\"n\">package</span> <span class=\"n\">to</span> <span class=\"n\">implement</span> <span class=\"n\">a</span> <span class=\"n\">collection</span> <span class=\"n\">whose</span> <span class=\"n\">name</span> <span class=\"n\">is</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">as</span> <span class=\"n\">the</span> <span class=\"n\">package</span> <span class=\"n\">name</span><span class=\"bp\">—</span><span class=\"k\">in</span> <span class=\"n\">which</span> <span class=\"n\">case</span> <span class=\"n\">a</span> <span class=\"n\">require</span> <span class=\"n\">might</span> <span class=\"n\">appear</span> <span class=\"n\">to</span> <span class=\"n\">be</span> <span class=\"n\">referencing</span> <span class=\"n\">a</span> <span class=\"n\">package</span><span class=\"o\">,</span> <span class=\"n\">but</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">actually</span> <span class=\"n\">referencing</span> <span class=\"n\">a</span> <span class=\"n\">collection</span> <span class=\"n\">provided</span> <span class=\"kd\">by</span> <span class=\"n\">the</span> <span class=\"n\">package</span>\n</code></pre></div>",
        "id": 287263318,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1656021216
    },
    {
        "content": "<p>Multi-collection vs single-collection packages:</p>\n<blockquote>\n<p>A <strong>single-collection</strong> package’s directory doubles as a collection directory. By default, the package name also doubles as the collection name, but if the package has an \"info.rkt\" file that defines collection to a string, then the string is used as the name of the package’s collection.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>multi-collection</strong> package’s directory contains subdirectories, each of which is a collection that is provided by the package (where the directory name is used as the collection name). A multi-collection package must have an \"info.rkt\" file that defines collection as 'multi.</p>\n</blockquote>",
        "id": 287266945,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1656023374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/270676-lean4/topic/Lake's.20package.20vs.20lean_lib.20vs.20lean_exe/near/287262001\">said</a>:</p>\n<blockquote>\n<p>Do you have an example of a single Lean package that produces more than one library or exe? I am likely missing something here.</p>\n</blockquote>\n<p>The <a href=\"https://github.com/leanprover/lake/blob/master/examples/targets/lakefile.lean\"><code>targets</code> example</a> in the Lake repository is a good toy demonstration. I don't have any practical examples on hand, though.</p>",
        "id": 287392774,
        "sender_full_name": "Mac",
        "timestamp": 1656109986
    }
]
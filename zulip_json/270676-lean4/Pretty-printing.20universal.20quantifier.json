[
    {
        "content": "<p>Hello,</p>\n<p>I am trying to write macros for denoting universal/existential quantification in a custom logical syntax, and would like to reuse the ∀/∃ notations for that purpose. Here is a reduced version of what I have so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Syntax</span> <span class=\"n\">where</span>\n  <span class=\"n\">WFF</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n  <span class=\"n\">alwaysFalseWFF</span> <span class=\"o\">:</span> <span class=\"n\">WFF</span>\n  <span class=\"n\">universal</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">WFF</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">WFF</span>\n  <span class=\"n\">existential</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">WFF</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">WFF</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Syntax</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⊥\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">alwaysFalseWFF</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"∃ \"</span> <span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">Lean.explicitBinders</span> <span class=\"s2\">\", \"</span> <span class=\"bp\">Φ</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.expandExplicitBinders</span> <span class=\"bp\">``</span><span class=\"n\">existential</span> <span class=\"n\">xs</span> <span class=\"bp\">Φ</span>\n\n<span class=\"kd\">@[appUnexpander existential]</span> <span class=\"kd\">def</span> <span class=\"n\">unexpandExistential</span> <span class=\"o\">:</span>\n  <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">binderIdent</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">binderIdent</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">,</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"∀ \"</span> <span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">Lean.explicitBinders</span> <span class=\"s2\">\", \"</span> <span class=\"bp\">Φ</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.expandExplicitBinders</span> <span class=\"bp\">``</span><span class=\"n\">universal</span> <span class=\"n\">xs</span> <span class=\"bp\">Φ</span>\n\n<span class=\"kd\">@[appUnexpander universal]</span> <span class=\"kd\">def</span> <span class=\"n\">unexpandUniversal</span> <span class=\"o\">:</span>\n  <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">binderIdent</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">binderIdent</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">,</span> <span class=\"bp\">$Φ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">[</span><span class=\"n\">Syntax</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">⊥</span>\n<span class=\"c1\">-- fun [Syntax] =&gt; ∃ x y, ⊥ : [inst : Syntax] → WFF</span>\n<span class=\"c1\">-- as expected</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">[</span><span class=\"n\">Syntax</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">⊥</span>\n<span class=\"c1\">-- fun [Syntax] =&gt; ∀ x, ∀ y, ⊥ : [inst : Syntax] → WFF</span>\n<span class=\"c1\">-- not as expected:</span>\n<span class=\"c1\">-- I would have liked to see</span>\n<span class=\"c1\">-- fun [Syntax] =&gt; ∀ x y, ⊥ : [inst : Syntax] → WFF</span>\n<span class=\"c1\">-- as in the existential case</span>\n</code></pre></div>\n<p>The problem arises when pretty-printing universally quantified WFFs with multiple variables; while it works fine for the existential case, it doesn't for the universal case. Do you know why that is?</p>\n<p>Thanks</p>\n<p>Martin</p>",
        "id": 279538818,
        "sender_full_name": "Martin C",
        "timestamp": 1650459216
    },
    {
        "content": "<p>It looks like this is due to overloading the built-in syntax, which sounds like a bad idea to do. You should either choose a different symbol/variant or, if your embedded syntax is otherwise independent of <code>term</code>, use a separate syntax category as in <a href=\"https://leanprover.github.io/lean4/doc/metaprogramming-arith.html\">https://leanprover.github.io/lean4/doc/metaprogramming-arith.html</a></p>",
        "id": 279573831,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1650474600
    }
]
[
    {
        "content": "<p>Hi All, I've been playing around with Lean and can happily prove stuff of the form <code>a → b</code> and <code>a → (¬b)</code> where <code>a</code>and <code>b</code> are of type <code>Prop</code><br>\nWhat I'm struggling to work out is how to prove something of the form <code>(¬a) → b</code> or <code>(¬a) → (¬b)</code><br>\nIs there some tactic/eliminator/syntax I can use?<br>\nI should add that I'm using classical logic, so I have dne and things.<br>\nThanks!</p>",
        "id": 283872785,
        "sender_full_name": "Rosie Baish",
        "timestamp": 1653480223
    },
    {
        "content": "<p>Do you have a concrete example?</p>",
        "id": 283877543,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653483049
    },
    {
        "content": "<p><code>theorem not_forall_implies_exists_not {p : α → Prop} : ¬(∀ x , p x) → (∃ x , ¬ p x) := by </code> is what I'm trying to prove</p>",
        "id": 283887907,
        "sender_full_name": "Rosie Baish",
        "timestamp": 1653487917
    },
    {
        "content": "<p>Although I'm now getting an error about \"tactic rewrite failed, pattern is a metavariable\" which implies that I'm missing something here</p>",
        "id": 283888005,
        "sender_full_name": "Rosie Baish",
        "timestamp": 1653487951
    },
    {
        "content": "<p>Things like <code>¬A → ¬B</code> can be constructed from <code>B → A</code> even without classical axioms (since <code>¬A</code> is defined as <code>A → False</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">contrapos</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">g</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>So you may prove <code>¬A → B</code> from <code>¬B → A</code> with DNE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">inverse</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Classical.byContradiction</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">contrapos</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>But it’s probably not very helpful. In general you should construct <code>¬A → B</code> as any other function: assume some <code>f : A → Empty</code> and somehow provide an element of <code>B</code>.</p>\n<p>Also you should know that classically <code>A → B</code> is equal to <code>¬A ∨ B</code>; so <code>¬A ∨ B</code> implies <code>A → B</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">implIfOr</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">contradiction</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Now we can construct <code>¬A → B</code> from <code>A ∨ B</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dnegIntro</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"bp\">¬¬</span><span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">implIfOr</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span>\n     <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">dnegIntro</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span>\n     <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>In your case you may use what I called <code>inverse</code>, because it’s easier to deal here with ∀ in codomain:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">not_forall_implies_exists_not</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">inverse</span><span class=\"bp\">;</span> <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">Classical.em</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"bp\">;</span>\n     <span class=\"n\">apply</span> <span class=\"n\">False.elim</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 283888884,
        "sender_full_name": "Uranus Testing",
        "timestamp": 1653488372
    },
    {
        "content": "<p>Thanks so much!<br>\nBased on that lot I both solved my original problem and streamlined a load of the proofs I was doing.</p>",
        "id": 283948762,
        "sender_full_name": "Rosie Baish",
        "timestamp": 1653518101
    }
]
[
    {
        "content": "<p>Hi, I'm trying to learn more about category theory with Lean. I'm a software devloper. I learned a little of Haskell and I'm learning Lean 4 now. So, my question is in this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">class</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span>\n    <span class=\"n\">mapConst</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">fb</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">fb</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorOption</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"n\">Option</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">fa</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">fa</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"n\">mapConst</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorList</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"n\">List</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">List.map</span>\n    <span class=\"n\">mapConst</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorProd</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">g</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">fga</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">fga</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">ga</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Functor.map</span> <span class=\"n\">f</span> <span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">Functor.map</span> <span class=\"n\">f</span> <span class=\"n\">ga</span><span class=\"o\">)</span>\n\n  <span class=\"k\">#eval</span> <span class=\"n\">FunctorProd.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">some</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n  <span class=\"k\">#eval</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">some</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><strong>Why the first eval works but the second eval is not working?</strong> I'm getting this error on second eval:</p>\n<p>x : Option Nat<br>\nfailed to synthesize instance<br>\n  Functor (Prod (List ?m.1074))Lean 4<br>\nfailed to synthesize instance<br>\n  HAdd (Option ?m.1080) Nat ?m.1001Lean 4</p>",
        "id": 322755563,
        "sender_full_name": "Gabriel gomez",
        "timestamp": 1674320357
    },
    {
        "content": "<p>Looking at the typeclass trace Lean is not even trying to apply the prod instance because it is not understanding that the type on the right hand side can be interpreted as <code>(fun α =&gt; List α × Option α)</code> but instead ends up interpreting it as <code>(Prod (List Nat))</code> where the rhs of the <code>Prod</code> type is the generic parameter of the functor.</p>\n<p>But I'm not an expert on the implementation of this part of Lean so I cannot tell you whether we want this to work out in the way you expect. <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> is this something the type inference should be able to detect correctly?</p>",
        "id": 322758579,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1674321779
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 322758830,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674321897
    },
    {
        "content": "<p>If you give it a unification nudge it compiles:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">#eval</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">some</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But yeah, can't give more insight into which syntactic forms do/don't get explored</p>",
        "id": 322758868,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674321914
    },
    {
        "content": "<p>We can see what you had in mind but Lean tries to guess what <code>f</code> should be before it looks at what instances there are--so it's not that likely to get it right, as there is little for it to go on.</p>",
        "id": 322759032,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674321991
    },
    {
        "content": "<p>This is a \"higher-order unification problem\": Lean needs to guess <code>f</code> but all it knows is <code>f Nat</code> (in fact, it doesn't even know yet that the argument should be <code>Nat</code>).</p>",
        "id": 322759356,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674322187
    },
    {
        "content": "<p>Another potentially interesting alternative formulation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">class</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span>\n    <span class=\"n\">mapConst</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">fb</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">fb</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorOption</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"n\">Option</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">fa</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">fa</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"n\">mapConst</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorList</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"n\">List</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">List.map</span>\n    <span class=\"n\">mapConst</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">FProd</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">g</span> <span class=\"n\">α</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">FProd.mk</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ga</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FProd</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">fa</span><span class=\"o\">,</span><span class=\"n\">ga</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorFProd</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">FProd</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">fga</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">fga</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">ga</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Functor.map</span> <span class=\"n\">f</span> <span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">Functor.map</span> <span class=\"n\">f</span> <span class=\"n\">ga</span><span class=\"o\">)</span>\n\n  <span class=\"k\">#eval</span> <span class=\"n\">FunctorProd.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">some</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n  <span class=\"k\">#eval</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">FProd.mk</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">4</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>this is much more reflective of how typeclass inference is \"\"intended\"\" to be used, where your types have a nice head term (here <code>FProd</code>)</p>",
        "id": 322759468,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674322222
    },
    {
        "content": "<p>Note that e.g. <code>f a = List a \\x Option Nat</code> is also a functor, that will have a different result for <code>Functor.map (fun x =&gt; x + 1)</code>.</p>",
        "id": 322759767,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674322415
    },
    {
        "content": "<p>(You don't have that instance yet, but you could.)</p>",
        "id": 322759795,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674322438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/inference.20of.20conditional.20conformance.20with.20type.20classes/near/322759468\">said</a>:</p>\n<blockquote>\n<p>Another potentially interesting alternative formulation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">class</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span>\n    <span class=\"n\">mapConst</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">fb</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">fb</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorOption</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"n\">Option</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">fa</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">fa</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"n\">mapConst</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorList</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"n\">List</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">List.map</span>\n    <span class=\"n\">mapConst</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">FProd</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">g</span> <span class=\"n\">α</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">FProd.mk</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ga</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FProd</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">fa</span><span class=\"o\">,</span><span class=\"n\">ga</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">FunctorFProd</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">FProd</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">fga</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">fga</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">ga</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Functor.map</span> <span class=\"n\">f</span> <span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">Functor.map</span> <span class=\"n\">f</span> <span class=\"n\">ga</span><span class=\"o\">)</span>\n\n  <span class=\"k\">#eval</span> <span class=\"n\">FunctorProd.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"n\">some</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n  <span class=\"k\">#eval</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">FProd.mk</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">4</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>this is much more reflective of how typeclass inference is \"\"intended\"\" to be used, where your types have a nice head term (here <code>FProd</code>)</p>\n</blockquote>\n<p>So, I need that additional indirection level. The nice head term (like FProd) is nice because... it doesn't have a type lambda as parameter on the instance?</p>\n<p>P.D. Thanks you, it worked!</p>",
        "id": 322760514,
        "sender_full_name": "Gabriel gomez",
        "timestamp": 1674322786
    },
    {
        "content": "<p>Yeah -- it's an application <code>FProd List Option</code> instead of a lambda abstraction (even though it reduces to a lambda) so typeclass search will look for an FProd instance instead of having to solve a higher order unification problem :)</p>",
        "id": 322761681,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674323430
    },
    {
        "content": "<p><code>?f ?A =?= FProd List Option Nat</code> is still a HO unification problem, like the original <code>?f ?A =?= Prod (List Nat) (Option Nat)</code> (note that there are no lambdas yet at this point, as we don't even get to the instance). As these problems are outside of the HO pattern fragment, Lean falls back to first-order unification <code>?f =?= FProd List Option, ?A =?= Nat</code> and <code>?f =?= Prod (List Nat), ?A =?= Option Nat</code>. So basically for functors you want to make sure that the type parameter occurs exactly once as the last argument.</p>",
        "id": 322765588,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674325679
    }
]
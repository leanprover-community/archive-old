[
    {
        "content": "<p>So I was defining a <code>Sort</code>-polymorphic instead of <code>Type</code>-polymorphic nat lit and ran into the following weird error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">OfNatLit</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ofNatLit</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">@[defaultInstance low]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNatLit</span> <span class=\"n\">A</span> <span class=\"n\">n</span>\n  <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">ofNatLit</span> <span class=\"o\">:=</span> <span class=\"n\">K.ofNat</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">OfNatLit</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">A</span> <span class=\"n\">n</span>\n  <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">K.ofNatLit</span><span class=\"o\">}</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">OfNatLit</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">natLit</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Before Syntax ovveride: Works as expected on Type</span>\n<span class=\"kd\">def</span> <span class=\"n\">fooT</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- Before Syntax ovveride: Errors as expected on Sort</span>\n<span class=\"kd\">def</span> <span class=\"n\">fooS</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  invalid universe level, ?u.136 is not greater than 0</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">sortNumLit</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">default</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">macro_rules</span> <span class=\"o\">[</span><span class=\"n\">sortNumLit</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">numLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNatLit.ofNatLit</span> <span class=\"o\">(</span><span class=\"n\">natLit</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- After syntax override: Errors unexpectedly w/o type scription</span>\n<span class=\"kd\">def</span> <span class=\"n\">fooS'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  invalid universe level, ?u.525 is not greater than 0</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- After syntax override: But works as expected w/ type ascription</span>\n<span class=\"kd\">def</span> <span class=\"n\">fooS''</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Why does <code>0</code> with a type ascription work, but <code>0</code> without one error? This seems like a bug in Lean.</p>",
        "id": 235110541,
        "sender_full_name": "Mac",
        "timestamp": 1618789063
    },
    {
        "content": "<p>btw <code>natLit!</code> has been renamed to <code>nat_lit</code></p>",
        "id": 235115702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618794693
    },
    {
        "content": "<p>It seems like the updated syntax macro is not triggering. I tried this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Syntax</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"n\">liftMacroM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">expandMacros</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"c1\">-- unknown parser term</span>\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Syntax</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"n\">liftMacroM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">expandMacros</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"c1\">-- (Term.app `f._@._hyg.1 [(numLit \"0\")])</span>\n</code></pre></div>\n<p>which seems like there isn't any macro expansion happening, but I think I'm not doing it right. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> help!</p>",
        "id": 235116473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618795632
    },
    {
        "content": "<p>So as you see in Mario's output (or, even better in general, using <code>pp.raw</code> and <code>trace.Elab</code> options), there is no <code>sortNumLit</code> syntax node to begin with, i.e. the problem is the parser and not the macro. So why would <code>0</code> be parsed differently in <code>f 0</code> and in <code>f (0 : A)</code>? The only sensible answer is precedences: <code>syntax</code> will default to a precedence of <code>lead</code> (which is lower than the \"acceptable as an argument\" precedence <code>arg</code>) unless the syntax is \"atomic-like\", which is <a href=\"https://github.com/leanprover/lean4/blob/1dca9d18d4b303b4fc6c57ff1c44444d92870f5f/src/Lean/Elab/Syntax.lean#L265-L272\">necessarily an incomplete heuristic</a>.</p>",
        "id": 235140521,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618818348
    },
    {
        "content": "<p>We could add all <code>*Lit</code> kinds to that heuristic, sure. On the other hand, there isn't really a point in introducing a syntax that is equivalent to an existing one, instead we can add a new macro for the existing syntax. Now, not sure if you already tried that, but it does turn out that there are some limitations with <code>macro_rules</code> that currently make that harder than it should be.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- fails</span>\n<span class=\"n\">macro_rules</span> <span class=\"o\">[</span><span class=\"n\">numLit</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">numLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNatLit.ofNatLit</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- succeeds, but registers macro for the wrong syntax kind</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">numLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNatLit.ofNatLit</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- the hard way, then</span>\n<span class=\"kd\">@[macro numLit]</span> <span class=\"kd\">def</span> <span class=\"n\">expandNumLit'</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Macro</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">numLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNatLit.ofNatLit</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>            <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Macro.throwUnsupported</span>\n</code></pre></div>",
        "id": 235141493,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618818998
    },
    {
        "content": "<p>Do you know why the <code>`(term| ...)</code> syntax doesn't work <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> ?</p>",
        "id": 235143027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618819841
    },
    {
        "content": "<p>What syntax category is <code>f 0</code> in if not <code>term</code>?</p>",
        "id": 235143057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618819866
    },
    {
        "content": "<p>The named quotations are currently hard-coded. There isn't one for <code>term</code> since it would be redundant.</p>",
        "id": 235148600,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618822866
    },
    {
        "content": "<p>Generalizing the syntax yields some \"interesting\" implementation issues with cyclically dependent subsystems</p>",
        "id": 235148646,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618822894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/235141493\">said</a>:</p>\n<blockquote>\n<p>On the other hand, there isn't really a point in introducing a syntax that is equivalent to an existing one, instead we can add a new macro for the existing syntax.</p>\n</blockquote>\n<p>Unfortunately, I did not know you could add macros to existing syntax kinds like that. However, looking at it now, there was a reason why I made it a separate syntax. Namely, as far as I am aware, you can't scope macro rules. I really wanted the following (I just eliminated the namespaces in my original example to make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Test</span>\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">sortNumLit</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">default</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">macro_rules</span> <span class=\"o\">[</span><span class=\"n\">sortNumLit</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">numLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNatLit.ofNatLit</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"kd\">end</span> <span class=\"n\">Test</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Test</span>\n</code></pre></div>\n<p>However, the following does also work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Test</span>\n<span class=\"kd\">@[scoped macro numLit]</span> <span class=\"kd\">def</span> <span class=\"n\">expandNumLit</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Macro</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">numLit</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNatLit.ofNatLit</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>            <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Macro.throwUnsupported</span>\n<span class=\"kd\">end</span> <span class=\"n\">Test</span>\n\n<span class=\"c1\">-- Does not work as expected</span>\n<span class=\"kd\">def</span> <span class=\"n\">fooS</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Test</span>\n\n<span class=\"c1\">-- Works as expected</span>\n<span class=\"kd\">def</span> <span class=\"n\">fooS'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>So, <strong>thanks!</strong></p>",
        "id": 235225771,
        "sender_full_name": "Mac",
        "timestamp": 1618856540
    },
    {
        "content": "<p>Yes, if we want to go that way, we should add <code>local/scoped macro(_rules)</code></p>",
        "id": 235233244,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618859602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/235141493\">said</a>:</p>\n<blockquote>\n<p>On the other hand, there isn't really a point in introducing a syntax that is equivalent to an existing one, instead we can add a new macro for the existing syntax.</p>\n</blockquote>\n<p>I have discovered another good reason to make it new syntax. Overriding <code>numLit</code> breaks the <code>syntax</code> command:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">newNumLit</span><span class=\"o\">)</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"kd\">@[macro newNumLit]</span>\n<span class=\"kd\">def</span> <span class=\"n\">expandNewNumLit</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Macro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- Works fine</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[macro numLit]</span>\n<span class=\"kd\">def</span> <span class=\"n\">expandNumLit</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Macro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- Now breaks</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"bar\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">maximum recursion depth has been reached (use `set_option maxRecDepth &lt;num&gt;` to increase limit)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 235918682,
        "sender_full_name": "Mac",
        "timestamp": 1619217156
    },
    {
        "content": "<p>Though I suspect this may be a bug that needs fixing.</p>",
        "id": 235929087,
        "sender_full_name": "Mac",
        "timestamp": 1619226116
    },
    {
        "content": "<p>The macro </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[macro numLit]</span>\n<span class=\"kd\">def</span> <span class=\"n\">expandNumLit</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Macro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>triggers nontermination in any term containing a numeral. The elaborator interrupts the \"infinite loop\" using the maximum recursion depth threshold.<br>\nFor example, suppose Lean tries to elaborate the numeral <code>2</code>. Your macro expands it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">2</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but <code>2</code> is a subterm of this term, and your macro is applied again, and so on.</p>",
        "id": 236005014,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1619297715
    },
    {
        "content": "<p><code>#check 2</code> works for me, which makes sense because <code>2</code> is not a <code>term</code> in <code>nat_lit 2</code>. The issue seems to be the attribute argument <code>@[termParser 1024]</code>, because we eagerly unfold attribute arguments using <code>expandMacros</code>.</p>",
        "id": 236009877,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619300588
    },
    {
        "content": "<p>Thus a simple workaround would be to make the macro an elaborator... but then <code>Lean</code> has to be imported</p>",
        "id": 236010314,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619300952
    },
    {
        "content": "<p>Yes, the macro only causes non-termination if another elaborator or macro invokes <code>expandMacros</code><br>\nFor example, the <code>match</code>-elaborator uses <code>expandMacros</code> on patterns</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[macro numLit]</span> <span class=\"kd\">def</span> <span class=\"n\">expandNumLit</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Macro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>   <span class=\"c1\">-- non-termination</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>Here is a minimal example that triggers.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"tst\"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.expandMacros</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[macro numLit]</span> <span class=\"kd\">def</span> <span class=\"n\">expandNumLit</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Macro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">tst</span> <span class=\"mi\">2</span>  <span class=\"c1\">-- non-termination</span>\n</code></pre></div>\n<p>That being said, the problem is the <code>expandNumLit</code> macro that produces a term containing the input term.</p>",
        "id": 236014465,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1619304458
    },
    {
        "content": "<blockquote>\n<p>#check 2 works for me, which makes sense because 2 is not a term in nat_lit 2</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  <code>2</code> is a subterm of <code>nat_lit 2</code>. <code>#check 2</code> doesn't loop because the <code>nat_lit</code> elaborator does not invoke <code>elabTerm</code> or <code>expandMacros</code> on the subterm <code>2</code>. </p>\n<p>The <code>nat_lit</code> elaborator is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[builtinTermElab rawNatLit]</span> <span class=\"kd\">def</span> <span class=\"n\">elabRawNatLit</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span> <span class=\"o\">:=</span>  <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">isNatLit</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">mkNatLit</span> <span class=\"n\">val</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span>     <span class=\"bp\">=&gt;</span> <span class=\"n\">throwIllFormedSyntax</span>\n</code></pre></div>",
        "id": 236015302,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1619305198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236010314\">said</a>:</p>\n<blockquote>\n<p>Thus a simple workaround would be to make the macro an elaborator... but then <code>Lean</code> has to be imported</p>\n</blockquote>\n<p>What is the reason that <code>import Lean</code> should be avoided? Back in lean 3 days this would basically always be true, and I've just been doing that whenever it is needed. Is there some hidden performance cost of this?</p>",
        "id": 236032581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619320476
    },
    {
        "content": "<p>There is no hidden cost, but <code>Lean</code> is simply very big compared to <code>Init</code>, so we are at least concerned about importing performance (and maybe performance of other declaration search parts like completion). Right now <code>import Lean</code> increases import time from 38ms to 380ms for me, which is insignificant for a single file... though keep in mind that all downstream modules will inherit that overhead. All of that would be resolved with <a href=\"https://github.com/leanprover/lean4/issues/416\">https://github.com/leanprover/lean4/issues/416</a>... if we can in fact pull it off.</p>",
        "id": 236047817,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619337944
    },
    {
        "content": "<p>I assume that in files where you actually care about the cost to downstream file imports, you can use a more selective import like <code>import Lean.Elab</code> or what have you? Or is everything mutually dependent enough that this has little advantage?</p>",
        "id": 236048251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619338509
    },
    {
        "content": "<p>(Coming from lean 3 where import times of 5-10 seconds are not unusual, I'm not particularly put off by a 380ms import time :P )</p>",
        "id": 236048326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619338585
    },
    {
        "content": "<p>In my experience, there is significant noticeable lag when adding a <code>Lean</code> import when editing in VS Code. I also feel like the response time of the editor decreases somewhat (though not significantly). Though I suspect if most complex metaprogramming requires the whole of Lean to be imported, I imagine most libraries will end up doing so. Thus, I doubt we can really get away from it unless some form of noncumulative/selective importing is introduced (such as the aforementioned module system).</p>",
        "id": 236049061,
        "sender_full_name": "Mac",
        "timestamp": 1619339496
    },
    {
        "content": "<p>If you register your complex tactics as <em>built-in</em> tactics and compile them down to shared libraries (which you might want to do anyway), you can load them as plugins without actually importing their code, or their dependencies. This is the one way we imagined for \"escaping\" from <code>import Lean</code> without the module system.</p>",
        "id": 236049718,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619340193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236048251\">said</a>:</p>\n<blockquote>\n<p>I assume that in files where you actually care about the cost to downstream file imports, you can use a more selective import like <code>import Lean.Elab</code> or what have you? Or is everything mutually dependent enough that this has little advantage?</p>\n</blockquote>\n<p>There aren't too many mutual dependencies between subsystems, but at least with <code>Lean.Elab</code> you do get almost everything (but the language server implementation).</p>",
        "id": 236049808,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619340312
    },
    {
        "content": "<p>IOW, <code>import Lean.Elab</code> is ~310ms</p>",
        "id": 236049885,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619340381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236049718\">said</a>:</p>\n<blockquote>\n<p>If you register your complex tactics as <em>built-in</em> tactics and compile them down to shared libraries (which you might want to do anyway), you can load them as plugins without actually importing their code, or their dependencies. This is the one way we imagined for \"escaping\" from <code>import Lean</code> without the module system.</p>\n</blockquote>\n<p>I guess that mathlib will not be able to escape <code>import Lean</code> then, because even with the mathlib prelude handling the majority of tactics we will still want to write small interactive tactics (that we don't mind being interpreted) inside mathlib itself. What about some kind of \"header only\" way to import files? I guess you could say that lean 3 did that since most substantial tactics were written in C++ and exposed as <code>constant</code> to lean.</p>",
        "id": 236050400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619341034
    },
    {
        "content": "<p>I see now that the linked module system issue is also trying to solve this problem, although I want to point out that the requirements of improving <code>import BigDependency</code> inside the server mode, say for proof authoring, are slightly different from separate compilation, and perhaps some problems that arise in the pursuit of separate compilation aren't as big of a deal when simply making it possible to write interpreted tactics calling lean builtins.</p>",
        "id": 236050809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619341492
    },
    {
        "content": "<p><code>builtinTactic</code> <em>is</em> such a header system in absence of a true module system. It allows you to use builtin tactics in macros without importing them. If you need a procedural tactic, you have to import at least <code>Lean.Elab.Tactic.Basic</code> anyway (which currently clocks in at ~170ms), in which case you can use <code>evalTactic</code> together with a syntax quotation of the builtin tactic to call it, still without actually importing it.</p>",
        "id": 236067560,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619359155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Weird.20Error.20with.20Custom.20Nat.20Lits/near/236050809\">said</a>:</p>\n<blockquote>\n<p>although I want to point out that the requirements of improving <code>import BigDependency</code> inside the server mode</p>\n</blockquote>\n<p>I should probably clarify that I don't see improving server mode as a concern for the module system, since imports are fast enough for that anyway as we said above. In fact, I could imagine that we would want to lift some import restriction in server mode so that we can still <code>#eval</code> arbitrary things and e.g. show completion items that would automatically insert necessary additional imports (though ideally in a way that code outside from <code>#eval</code> would still only be accepted if it was also accepted in batch mode; that part might be a bit tricky).  <em>If</em> libraries like mathlib want to embrace the module system, the main benefit would still be separate compilation: rebuilding as few files of it as possible on (most) changes.</p>",
        "id": 236068193,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619359788
    }
]
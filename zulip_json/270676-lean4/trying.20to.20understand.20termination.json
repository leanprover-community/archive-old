[
    {
        "content": "<p>So, i really want to understand how termination work, so i writed this function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>    <span class=\"o\">,</span> <span class=\"n\">m</span>  <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>My natural language proof of this terminating is something like </p>\n<p>let's prove that for all n m, <code>blah n m</code> terminate and is equal 0, by induction on n<br>\nif n equal 0 , then <code>blah 0 m</code> equal 0, so <code>blah 0 m</code> terminate and is equal 0<br>\nLet's assume <code>blah n m</code> terminate and is equal 0 for all m<br>\nSo <code>blah n (n + 1)</code> terminate and is equal 0 and so does <code>blah n (m + 1)</code><br>\nSo <code>blah (n + 1) m</code> is equal to  <code>blah 0 0</code> which terminate and is equal 0<br>\nBy induction, for all n m <code>blah n m</code> terminate and is equal 0</p>\n<p>But i dn't know how to put this in lean, or if it it's how it's done to begin with</p>",
        "id": 269224201,
        "sender_full_name": "Alice Laroche",
        "timestamp": 1643100018
    },
    {
        "content": "<p>Your definition is especially tricky because in proving that a function with that definition exists (i.e. that it terminates). In the process of proving termination however, we do know that all the expressions involved are well-typed and this is something we can work with. </p>\n<p>Instead of returning a natural number we're going to return a subtype: a natural number with the proof that it is always equal to zero:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">JustZero</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">JustZero.property</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">JustZero</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">Subtype.property</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>then your function definition becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">JustZero</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>    <span class=\"o\">,</span> <span class=\"n\">m</span>  <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>but Lean still needs a bit of help with proving that this actually decreases so we add:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">JustZero.property</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">first</span>\n  <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.zero_lt_succ</span>\n  <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_succ_self</span>\n</code></pre></div>",
        "id": 269261239,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1643119707
    },
    {
        "content": "<p>My <code>decreasing_by</code> is not as polished as I'd like but I'm still getting familiar with the construct. Any comments on improving it would be welcome</p>",
        "id": 269261376,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1643119782
    },
    {
        "content": "<p>A common pattern is to use <code>decreasing_by assumption</code> (or leave it out entirely).  You then write the termination proof directly next to the recursive call:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">...</span>\n<span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 269266290,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1643121910
    },
    {
        "content": "<p>Nice thanks! For some reason I didn't think of trying the Lean 3 approach. </p>\n<p>The definition now becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">JustZero</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>    <span class=\"o\">,</span> <span class=\"n\">m</span>  <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">JustZero.property</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_lt_succ</span><span class=\"o\">]</span>\n  <span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 269268493,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1643122798
    },
    {
        "content": "<p>Doesn't this defeat the purpose of the recursive function?</p>\n<blockquote>\n<p><code>def JustZero := { i : Nat // i = 0 }</code></p>\n</blockquote>\n<p>You could just write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span>  <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>What if you can't simplify the function? I think the proper way would be to use <code>termination_by</code> to prove that it terminates for any <code>m</code> when <code>n = 0</code> and then prove that if it terminates for some <code>n</code>, then it terminates for <code>n + 1</code>.</p>\n<p>I don't know how it is supposed to be done in Lean 4, but in Isabelle/HOL you can prove termination partially and then use induction to prove termination for the rest of the cases. Maybe Lean 4 can implement a similar mechanism.</p>",
        "id": 269276249,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1643125788
    },
    {
        "content": "<p>Well this function has no purpose anyway, it's just a tool for learning.<br>\nThis construction is actually useful for me, but you're right I would like to do it the way you present</p>",
        "id": 269277672,
        "sender_full_name": "Alice Laroche",
        "timestamp": 1643126308
    },
    {
        "content": "<p>You can make that work with mathlib's <code>roption</code> type actually. </p>\n<p>As for defeating the purpose, I think you need to take a step back and see that this is a minimized example. You can make it work with <code>JustZero</code> or with any other subtype you like.</p>",
        "id": 269277767,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1643126355
    },
    {
        "content": "<p>BTW, <code>roption</code> is called <code>part</code> now.</p>",
        "id": 269278827,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643126711
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 269278833,
        "sender_full_name": "Alice Laroche",
        "timestamp": 1643126715
    },
    {
        "content": "<p>Thanks! That's a better name, I'm glad the change was made</p>",
        "id": 269278915,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1643126749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/270676-lean4/topic/trying.20to.20understand.20termination/near/269276249\">said</a>:</p>\n<blockquote>\n<p>I don't know how it is supposed to be done in Lean 4, but in Isabelle/HOL you can prove termination partially and then use induction to prove termination for the rest of the cases. Maybe Lean 4 can implement a similar mechanism.</p>\n</blockquote>\n<p>Can you point me to some Isabelle code to see how this looks?</p>",
        "id": 269279323,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643126917
    },
    {
        "content": "<blockquote>\n<p>Can you point me to some Isabelle code to see how this looks?</p>\n</blockquote>\n<p>See section 8.1 of <a href=\"https://isabelle.in.tum.de/dist/Isabelle2021-1/doc/functions.pdf\">https://isabelle.in.tum.de/dist/Isabelle2021-1/doc/functions.pdf</a>. After defining equations, but before proving termination, Isabelle automatically defines a partial function constrained to the domain where the actual function terminates. We can then inductively build the domain of the function, eventually proving that the domain covers all valid inputs.</p>\n<p>It is much harder to do in Lean. Consider this function (in Lean 3):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>How would you prove that it terminates, without modifying the type of the function or defining new functions? In Isabelle, you can simply prove that <code>(m, 0)</code> is in the domain for all <code>m</code> and prove that if <code>(m, n)</code> is in the domain, then <code>(n, m)</code> is also in the domain, and then you can prove that <code>n &lt; n + 1</code> to finish the termination proof.</p>",
        "id": 269286415,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1643129664
    },
    {
        "content": "<p>Actually this one is easy, because (n + m) reduce every step<br>\nSo you can do (in Lean 4)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">helper1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n   <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">succ_add</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n   <span class=\"n\">apply</span> <span class=\"n\">Nat.succ_le_succ</span>\n   <span class=\"n\">apply</span> <span class=\"n\">Nat.le_refl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"o\">,</span> <span class=\"mi\">0</span>       <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">helper1</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n                 <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span>\n</code></pre></div>",
        "id": 269288105,
        "sender_full_name": "Alice Laroche",
        "timestamp": 1643130214
    },
    {
        "content": "<p>Fair enough. But my point was that Lean 4 should have a mechanism to inductively build the domain of a function and also allow users to use partial function until they prove it's total.</p>",
        "id": 269296063,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1643133242
    },
    {
        "content": "<p>Oh you're completely right, I just wanted to train actually</p>",
        "id": 269296828,
        "sender_full_name": "Alice Laroche",
        "timestamp": 1643133542
    },
    {
        "content": "<p>Somewhat unrelated, I was trying to think of where I've seen that before and then it hit me. There's a 'standard' example  of a function that alternates elements of two sequences,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">alternate</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">h₂</span> <span class=\"o\">::</span> <span class=\"n\">t₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h₂</span> <span class=\"o\">::</span> <span class=\"n\">alternate</span> <span class=\"n\">t₂</span> <span class=\"n\">l₁</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l₁</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">alternate</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l₁.length</span> <span class=\"bp\">+</span> <span class=\"n\">l₂.length</span>\n<span class=\"n\">decreasing_by</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>where this 'argument swap' has semantics beyond 'f', which I reckon makes it much clearer what the termination criterion is. (This of course is besides the point in more than one way.)</p>",
        "id": 269297336,
        "sender_full_name": "František Silváši",
        "timestamp": 1643133713
    },
    {
        "content": "<p>I had a related question: I had a function that makes three recursive calls to itself. Is there a good way to use <code>termination_by</code> for such a situation. I used an auxiliary bound. For concreteness, I mean something similar to the below definitions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">gcd0</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">gcd</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">%</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">gcd1</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)(</span><span class=\"n\">wa</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)(</span><span class=\"n\">wb</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- the total definition with some work</span>\n</code></pre></div>",
        "id": 269357790,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1643167460
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> In that case, you could use <code>a + b</code> as a termination measure</p>",
        "id": 269365000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643174256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456794\">@Patrick Johnson</span> I proposed something along those lines early in lean 4, and the response I got was that <code>partial</code> is a MVP to make writing general recursive functions possible, and making something more suitable for proofs was a low priority. We have since gained <code>termination_by</code> which helps with a lot of these types of proofs, but I still think that an automatic domain predicate is possible (I have a general idea of how to do the desugaring, although dependent types complicate matters), and there are some kinds of functions that can't be proven to terminate using only <code>termination_by</code> (like Alice's original <code>blah</code> function before Simon changed the codomain to <code>JustZero</code>) but can be proven with an external domain predicate.</p>",
        "id": 269365275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643174565
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> . <br>\nMy actual case is more complicated - the recursive calls are to the tail of a list and the two pieces of a list strictly before and strictly after some element in the list. All can be proved shorter than the original list, so the auxiliary bound method works. I was wondering if there is some <code>termination_by</code> approach for this.</p>",
        "id": 269365299,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1643174612
    },
    {
        "content": "<p>You should not need to add another argument</p>",
        "id": 269365313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643174637
    },
    {
        "content": "<p>in fact I would advise against it since this affects code generation</p>",
        "id": 269365355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643174660
    },
    {
        "content": "<p>could you give an example?</p>",
        "id": 269365365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643174676
    },
    {
        "content": "<p>The code with <code>partial def</code> is at <a href=\"https://github.com/siddhartha-gadgil/Polylean/blob/main/Polylean/LengthBound.lean\">https://github.com/siddhartha-gadgil/Polylean/blob/main/Polylean/LengthBound.lean</a>.</p>",
        "id": 269365385,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1643174697
    },
    {
        "content": "<p>It sounds like you want to use <code>l.length</code> as the termination measure</p>",
        "id": 269365394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643174711
    },
    {
        "content": "<p>It is short enough that I can paste it here (eliminating some extraneous measure).</p>",
        "id": 269365408,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1643174729
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Letter</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Letter</span>\n  <span class=\"bp\">|</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Letter</span>\n  <span class=\"bp\">|</span> <span class=\"n\">α</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">Letter</span>\n  <span class=\"bp\">|</span> <span class=\"n\">β</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">Letter</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">Hashable</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Letter.inv</span> <span class=\"o\">:</span> <span class=\"n\">Letter</span> <span class=\"bp\">→</span> <span class=\"n\">Letter</span>\n  <span class=\"bp\">|</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"bp\">!</span>\n  <span class=\"bp\">|</span> <span class=\"n\">β</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">β</span><span class=\"bp\">!</span>\n  <span class=\"bp\">|</span> <span class=\"n\">α</span><span class=\"bp\">!</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">β</span><span class=\"bp\">!</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⁻¹\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Letter.inv</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Word</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">Letter</span>\n\n<span class=\"c1\">-- split a word into parts before and after each occurrence of a letter `l`</span>\n<span class=\"kd\">def</span> <span class=\"n\">splits</span><span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Letter</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Word</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Word</span> <span class=\"bp\">×</span> <span class=\"n\">Word</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">tailSplits</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">splits</span> <span class=\"n\">l</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">))</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"k\">then</span> <span class=\"o\">([],</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">tailSplits</span> <span class=\"k\">else</span> <span class=\"n\">tailSplits</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">:</span> <span class=\"n\">Word</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">derived</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">splits</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">length</span> <span class=\"n\">fst</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">snd</span><span class=\"o\">)</span>\n    <span class=\"n\">derived.foldl</span> <span class=\"n\">min</span> <span class=\"n\">base</span> <span class=\"c1\">-- minimum of base and elements of derived</span>\n</code></pre></div>",
        "id": 269365468,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1643174771
    },
    {
        "content": "<p>I think I understand. when I paste <code>termination_by length l =&gt; l.length</code> I get an error that assumption failed to prove <code>List.length fst &lt; Nat.succ (List.length ys)</code>. But following the idea mentioned by <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I should give proofs <code>have ...</code> with bounds for these just before <code>termination_by</code>.</p>\n<p>I have to prove the bounds anyway, so I use them this way instead of with an auxiliary parameter. I will work on this.</p>",
        "id": 269365835,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1643175193
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- split a word into parts before and after each occurrence of a letter `l`</span>\n<span class=\"kd\">def</span> <span class=\"n\">splits</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Letter</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Word</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Word</span> <span class=\"bp\">×</span> <span class=\"n\">Word</span> <span class=\"bp\">//</span> <span class=\"n\">p.1.length</span> <span class=\"bp\">+</span> <span class=\"n\">p.2.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">w.length</span><span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">tailSplits</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">splits</span> <span class=\"n\">l</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"k\">fun</span> <span class=\"o\">⟨(</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">⟨(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_add</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_lt_succ</span> <span class=\"n\">h</span><span class=\"o\">]⟩</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"k\">then</span> <span class=\"o\">⟨([],</span> <span class=\"n\">ys</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.lt_succ_self</span><span class=\"o\">]⟩</span> <span class=\"o\">::</span> <span class=\"n\">tailSplits</span> <span class=\"k\">else</span> <span class=\"n\">tailSplits</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">:</span> <span class=\"n\">Word</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">derived</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">splits</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"k\">fun</span> <span class=\"o\">⟨(</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">),</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_trans</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_succ_self</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_add_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_add_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n      <span class=\"n\">length</span> <span class=\"n\">fst</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">snd</span>\n    <span class=\"n\">derived.foldl</span> <span class=\"n\">min</span> <span class=\"n\">base</span> <span class=\"c1\">-- minimum of base and elements of derived</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.length</span>\n</code></pre></div>",
        "id": 269366115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643175507
    },
    {
        "content": "<p>That's very nice. Thanks a lot. it shows me how to use sub-types effectively too (instead of custom types I have been using).</p>",
        "id": 269367035,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1643176507
    },
    {
        "content": "<p>So, i was trying to apply my new knowledge about subtypes on more intricated functions, and the i got into this : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Inf</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">n'</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Inf</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>      <span class=\"o\">,</span> <span class=\"n\">m</span>       <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"mi\">0</span>       <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Nat.le.refl</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n                        <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n                           <span class=\"n\">apply</span> <span class=\"n\">Nat.le_trans</span> <span class=\"n\">h</span>\n                           <span class=\"n\">apply</span> <span class=\"n\">Nat.le_succ</span>\n                      <span class=\"o\">⟩</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">blah</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here the subtypes say that <code>blah n (n + 1)</code> is inferior or equal to (n + 1)<br>\nBut lean can't infer that  ((blah n (n + 1).val , m) &lt; (n + 1, m + 1)</p>",
        "id": 269381427,
        "sender_full_name": "Alice Laroche",
        "timestamp": 1643188720
    },
    {
        "content": "<p>It works if you parametrize <code>Inf</code> with the first argument instead of the second:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Inf</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">n'</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">blah</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Inf</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>      <span class=\"o\">,</span> <span class=\"n\">m</span>       <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"mi\">0</span>       <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n                        <span class=\"n\">cases</span> <span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                        <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_succ_of_le</span>\n                        <span class=\"n\">assumption</span>\n                      <span class=\"o\">⟨(</span><span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n                        <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"o\">(</span><span class=\"n\">blah</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n                           <span class=\"n\">apply</span> <span class=\"n\">Nat.le_trans</span> <span class=\"n\">h</span>\n                           <span class=\"n\">apply</span> <span class=\"n\">Nat.le_of_lt</span>\n                           <span class=\"n\">assumption</span> <span class=\"o\">⟩</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">blah</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 269481507,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1643230850
    }
]
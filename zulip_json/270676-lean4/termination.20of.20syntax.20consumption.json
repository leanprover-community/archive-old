[
    {
        "content": "<p>Hello everyone!<br>\nSomething got me thinking: is there a way to infer the termination of <code>Syntax → ...</code> functions when every recursive call uses a fragment of the entire syntax we're matching on?<br>\nI'm asking this because a piece of code that I'm writing has multiple <code>partial</code> definitions that I believe should always terminate. And <a href=\"https://github.com/arthurpaulino/LeanMySQL/blob/803d171225406ca516d5d5f7709a3c9ced97f486/lib/SQLSyntax.lean#L72-L156\">this is not the first time</a> that I end up with many partial functions like this</p>",
        "id": 277404860,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648813885
    },
    {
        "content": "<p>I'm definitely not an expert on <code>Syntax</code> but I think the issue with this might be the following: <code>Syntax</code> itself is actually a very trivial datatype: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Syntax#doc\">docs4#Lean.Syntax</a> however the notation we have allows to match on fairly elaborate (elaborate to denote with a pattern on <code>Syntax</code>)  Syntax tree nodes so maybe the information about being a \"subtree\" just gets lost along the way?</p>",
        "id": 277405517,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1648814227
    },
    {
        "content": "<p>The way syntax matches are currently desugared, it would not be easy. You can use a well founded measure to determine that the array accesses are at smaller members, but it doesn't seem like it is worth complicating the desugaring</p>",
        "id": 277405561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648814268
    },
    {
        "content": "<p>Regarding this topic, I also have a similar question regarding <code>Expr</code> transformers, I wrote this function here: <br>\n<a href=\"https://github.com/hargoniX/mathlib4/blob/slim_check/Mathlib/Testing/SlimCheck/Testable.lean#L463-L472\">https://github.com/hargoniX/mathlib4/blob/slim_check/Mathlib/Testing/SlimCheck/Testable.lean#L463-L472</a><br>\nbut due to recursing into <code>addDecorations</code> again inside the argument to <code>replace</code> It cannot be trivially shown to terminate, do we have tricks to do this as well ?</p>",
        "id": 277406033,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1648814497
    },
    {
        "content": "<p>nope, that one is even harder because changing the type of <code>replace</code> would interfere with the (very important!) caching optimization</p>",
        "id": 277424178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648822409
    },
    {
        "content": "<p>The test file <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/syntaxWF.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/syntaxWF.lean</a> contains the necessary \"plumbing\" for writing functions such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">visit</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"k\">else</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">visit</span> <span class=\"n\">c</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"bp\">;</span> <span class=\"k\">if</span> <span class=\"bp\">$</span><span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"k\">else</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">visit</span> <span class=\"n\">c</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">stx</span>\n</code></pre></div>\n<p>without <code>partial</code>.<br>\nFor the <code>addDecorations</code> example, we can define a <code>refine'</code> function with type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">replace'</span> <span class=\"o\">(</span><span class=\"n\">e0</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">sizeOf</span> <span class=\"n\">e</span> <span class=\"bp\">≤</span> <span class=\"n\">sizeOf</span> <span class=\"n\">e0</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>It is the same trick we use for other combinators. Then, we can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">addDecorations</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"n\">e.replace'</span> <span class=\"k\">fun</span> <span class=\"n\">expr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">expr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Expr.forallE</span> <span class=\"n\">name</span> <span class=\"n\">type</span> <span class=\"n\">body</span> <span class=\"n\">data</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">name.toString</span>\n      <span class=\"k\">let</span> <span class=\"n\">newType</span> <span class=\"o\">:=</span> <span class=\"n\">addDecorations</span> <span class=\"n\">type</span>\n      <span class=\"k\">let</span> <span class=\"n\">newBody</span> <span class=\"o\">:=</span> <span class=\"n\">addDecorations</span> <span class=\"n\">body</span>\n      <span class=\"k\">let</span> <span class=\"n\">rest</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.forallE</span> <span class=\"n\">name</span> <span class=\"n\">newType</span> <span class=\"n\">newBody</span> <span class=\"n\">data</span>\n      <span class=\"n\">some</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">`</span><span class=\"n\">SlimCheck.NamedBinder</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkStrLit</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">rest</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n<span class=\"n\">decreasing_by</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.le_trans</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp_arith</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>The complete example is here: <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/addDecorationsWithoutPartial.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/addDecorationsWithoutPartial.lean</a><br>\nWe are saving all these examples in our test suite because we want all of them to go through without any extra annotation even if the user uses <code>Expr.replace</code>. Our goal is to allow users to register replacements such as <code>Expr.replace</code> =&gt; <code>Expr.replace'</code> that are applied when we try to prove termination. We have some notes here:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/combinatorsAndWF.lean#L37\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/combinatorsAndWF.lean#L37</a></p>",
        "id": 277564767,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648952488
    },
    {
        "content": "<p>Starred the message so I can come back to it later <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n<p>I forgot to mention another motivation for my question. Sebastian mentioned the <code>builtin syntax</code> which will help us build powerful parsers without the gymnastics that were implemented in my repo. Then, if writing recursive functions that consume syntax terms is easier and possible without <code>partial</code>, then we'll be able to reason about them more easily</p>",
        "id": 277575789,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648962917
    }
]
[
    {
        "content": "<p>This will be long, I am sorry for the wall of text.  I started tonight trying to figure out how to use <code>List.head</code>.  After some searching, this is what I wrote (Note that I'm aware of the other versions of <code>head*</code>, this is just for learning purposes) </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">!=</span> <span class=\"o\">[]</span> <span class=\"k\">then</span>\n    <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">xs.head</span> <span class=\"n\">h1</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">none</span>\n</code></pre></div>\n<p>However, this doesn't work because <code>!=</code> is expecting a <code>BEq</code> instance.   I searched the Lean code and came across the typeclass.  So I did</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">!=</span> <span class=\"o\">[]</span> <span class=\"k\">then</span>\n    <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">xs.head</span> <span class=\"n\">h1</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">none</span>\n</code></pre></div>\n<p>However, now the error is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">h1</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">!=</span> <span class=\"o\">[])</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">xs</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Now, this made me think that <code>BEq</code> is not the right typeclass here; so I tried using <code>DecidableEq</code> instead but still no luck.  The error actually stays the same.  Then I noticed that the error is not using <code>!=</code> but <code>≠</code> (<code>\\ne</code>).  Switching to that, I was able to get the function to typecheck and #eval. </p>\n<p>I've been scouring the documentation for <code>DecidableEq</code> and <code>BEq</code> and the two operators (<code>!=</code> vs <code>≠</code>) but have had no luck.  So my first question is:  Could someone please shed some light on the differences?  Looking at <code>BEq</code> it just seems like it's for supporting boolean equality.  But the few examples here on Zulip and in the documentation I was able to find do both</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"bp\">...</span>\n<span class=\"n\">deriving</span> <span class=\"n\">BEq</span><span class=\"bp\">/</span><span class=\"n\">DecidableEq</span>\n</code></pre></div>\n<p>and I can't see any reason to use one over the other.  <br>\nUpon reflection, it seems that <code>DecidableEq</code> is for creating <code>Prop</code>s (with <code>=</code> and <code>\\ne</code>), while <code>BEq</code> is for creating (runtime) Bool comparisons using <code>==</code> and <code>!=</code> but I'm not sure.  However, it also seems that <code>DecidableEq</code> works for all my examples instead of <code>BEq</code>; any examples for picking on over the other?</p>\n<p>Thank you.</p>",
        "id": 300939913,
        "sender_full_name": "Tom",
        "timestamp": 1664256371
    },
    {
        "content": "<p>Yeah, this isn't super straightforward...</p>\n<ul>\n<li>If a prop <code>P</code> is decidable (e.g. there is an instance of the typeclass <code>Decidable P</code>) then we can <code>decide P</code> to get a boolean value for P's truthiness</li>\n<li><code>DecidableEq A</code> basically means <code>Decidable (a = b)</code> for any <code>a b : A</code>. So, given two elements of the type, we can decide whether they are equal or not</li>\n<li>Lean will coerce decidable <code>Prop</code>s to <code>Bool</code>s if the expected type is a bool. So, here, you write the proposition <code>xs \\ne []</code>, but since it expects a <code>Bool</code> it rewrites the if condition as <code>decide (xs \\ne [])</code>, which is fine since <code>DecidableEq (List α)</code></li>\n</ul>",
        "id": 300941397,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664257548
    },
    {
        "content": "<p>You can just use <code>head?</code> which is defined like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">head</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 300941550,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1664257671
    },
    {
        "content": "<p>As for <code>BEq A</code>, this class seems to mean \"there is a function <code>A -&gt; A -&gt; Bool</code>that we call boolean equality\" in the same way that <code>Mul A</code> means \"there is a function <code>A -&gt; A -&gt; A</code> that we call multiplication\" i.e. there's no propositional meaning to it.</p>\n<p>I'm not really sure when you'd want to use <code>BEq</code> over decidable equality (which, for most types is equivalent to the <code>BEq</code> instance, just with some propositional content). I think there might be built-in types that have <code>BEq</code> instances but not <code>DecidableEq</code> instances on purpose (i.e. floats? i think?)</p>",
        "id": 300941806,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664257870
    },
    {
        "content": "<p>But this is definitely something that should be addressed in beginner tutorials, because most programmers automatically reach for <code>==</code> and <code>!=</code> when learning a new language, even though it's rarely what you want to use in Lean.</p>",
        "id": 300941913,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664257956
    },
    {
        "content": "<p>Oh, and as a general note in line with what Chris said, pattern matching is almost always the way to go in Lean, even more so than non-dependently-typed functional languages. <code>Eq</code> terms can lead to messy type dependencies that Lean doesn't know how to solve, whereas pattern matching rarely makes a mess :)</p>",
        "id": 300942172,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664258156
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> !</p>\n<p>What does the \"Decidable Prop\" refer to here?  Is it decidable as in the \"theory of computation/Turing Machine\" decidable?  For basic computations, when would something not be decidable?  Since lean's functions (at least those which are not partial) are total and hence terminating... right?</p>\n<p>Or is it \"decidable\" in the sense that I have a <code>Prop</code> and I don't have a proof  (or have a proof that it's not decidable, as per Goedel's incompleteness; or something like the independence of the AoC from ZF)?</p>",
        "id": 300946553,
        "sender_full_name": "Tom",
        "timestamp": 1664260926
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> </p>\n<p>This is purely a learning exercise. (I am aware of <code>head?</code>, <code>head!</code> and <code>headD</code>); I mostly trying to get to better grips with the interaction between programs with proofs and especially trying to figure out how to use <code>head</code>. </p>\n<p>For example, it doesn't seem that pattern matching provides the proof that's required to use <code>head</code> (that is to say, I don't know how to do it).  For example, modifying your example, this doesn't type check even though clearly the type in the second branch could be narrowed to <code>l \\ne []</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">l</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">List.head</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 300947191,
        "sender_full_name": "Tom",
        "timestamp": 1664261285
    },
    {
        "content": "<p>Decidable just means there's an algorithm for deciding if it's true or false. An example of an undecidable prop would be claiming that two real numbers were equal because there is no algorithm for deciding this in general.</p>",
        "id": 300951007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1664263316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/270676-lean4/topic/Beginner.20questions.20about.20equalities/near/300946553\">said</a>:</p>\n<blockquote>\n<p>Or is it \"decidable\" in the sense that I have a <code>Prop</code> and I don't have a proof </p>\n</blockquote>\n<p>Exactly this; given an arbitrary <code>P : Prop</code> you don't have a proof of <code>P</code>. But if <code>Decidable P</code> then there is some algorithm to give you a proof of <code>P</code> or a proof of <code>not P</code></p>",
        "id": 301014983,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664288097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/270676-lean4/topic/Beginner.20questions.20about.20equalities/near/300947191\">said</a>:</p>\n<blockquote>\n<p>For example, it doesn't seem that pattern matching provides the proof that's required to use <code>head</code> (that is to say, I don't know how to do it).  For example, modifying your example, this doesn't type check even though clearly the type in the second branch could be narrowed to <code>l \\ne []</code></p>\n</blockquote>\n<p>Yeah, if you use a <code>@</code> pattern I'm not sure what information Lean exposes to you about the relationship between the left and right hand sides.</p>\n<p>A more standard way to use pattern matching in this kind of situation is to pattern match on a term which appears in some proof term that you need to dispatch. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">head</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">i</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_le_succ</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">)⟩)</span>\n</code></pre></div>\n<p>Here we are pattern matching on n, which changes the proposition we need to prove from <code>0 &lt; n</code> (not provable) to <code>0 &lt; ?n + 1</code> (provable)</p>",
        "id": 301017480,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664288786
    },
    {
        "content": "<p>When you pattern match on a term, the term gets replaced <em>everywhere</em>, including in types that depend on it (e.g. in propositions you need to prove).</p>\n<p>The same is not true when you do something like <code>if h : n = 0 ...</code>; you get a proof that <code>h : n = 0</code> in the positive branch, but it doesn't <em>replace</em> <code>n</code> with zero in the positive branch's context.</p>",
        "id": 301018168,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664288998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> </p>\n<p>Cool, thanks!  I was able to make it work using pattern matching:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">he</span><span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">≠</span> <span class=\"o\">[]}</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">he</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">List.head</span> <span class=\"n\">l</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 301137252,
        "sender_full_name": "Tom",
        "timestamp": 1664323305
    }
]
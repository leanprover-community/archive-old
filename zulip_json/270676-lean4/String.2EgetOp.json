[
    {
        "content": "<p>I saw this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">String.getOp</span> <span class=\"c1\">-- String.getOp : String → String.Pos → Char</span>\n</code></pre></div>\n<p>So I wonder, is this expected?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"s2\">\"\"</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"c1\">-- 'A'</span>\n</code></pre></div>",
        "id": 287855425,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656510324
    },
    {
        "content": "<p>What is the question? Whether <code>getOp</code> should panic in that case?</p>",
        "id": 287856819,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656510849
    },
    {
        "content": "<p>Hm, I would expect <code>getOp</code> to have type <code>String → String.Pos → Option Char</code> instead</p>",
        "id": 287857136,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656510976
    },
    {
        "content": "<p>That would be inconsistent with all other <code>getOp</code> implementations</p>",
        "id": 287857278,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656511038
    },
    {
        "content": "<p>Why doesn't <code>getOp</code> return <code>Option x</code>? I fear the current API risks making programmers not seeing errors in their code in some situations</p>",
        "id": 287858170,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656511375
    },
    {
        "content": "<p>Like, if they assume some list/array/etc is not empty but in fact it is. And they don't see errors because <code>getOp</code> is returning something regardless</p>",
        "id": 287858497,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656511488
    },
    {
        "content": "<p>We have discussed this issue in the past. One of the proposals was:</p>\n<ul>\n<li><code>a[i]!</code> panics if index out of bounds</li>\n<li><code>a[i]?</code> returns <code>Option</code></li>\n<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>\n</ul>\n<p>but, we never implemented this proposal. It is a good time to revisit this issue and decide what to do here before the first official release.</p>",
        "id": 287859389,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656511877
    },
    {
        "content": "<p>(for some reason I imagined a cavalry of Python programmers spamming <code>a[i]!</code> all over their code - I am a Python programmer)</p>",
        "id": 287859803,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656512072
    },
    {
        "content": "<blockquote>\n<ul>\n<li><code>a[i]!</code> panics if index out of bounds</li>\n<li><code>a[i]?</code> returns <code>Option</code></li>\n<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>\n</ul>\n</blockquote>\n<p>That makes total sense to me</p>",
        "id": 287860059,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656512173
    },
    {
        "content": "<p>Related issue <a href=\"https://github.com/leanprover/lean4/issues/406\">https://github.com/leanprover/lean4/issues/406</a>. <span class=\"user-mention\" data-user-id=\"278501\">@Andrew Kent</span> suggested that all APIs that may panic should have a <code>!</code> suffix.</p>",
        "id": 287860123,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656512200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287860059\">said</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li><code>a[i]!</code> panics if index out of bounds</li>\n<li><code>a[i]?</code> returns <code>Option</code></li>\n<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>\n</ul>\n</blockquote>\n<p>That makes total sense to me</p>\n</blockquote>\n<p>Great. It would be great to have more feedback from the community since this is a very disruptive change.</p>\n<blockquote>\n<p>a[i]! all over their code - I am a Python programmer)</p>\n</blockquote>\n<p>I suspect you are not the only one that will have <code>a[i]!</code> all over the place.</p>",
        "id": 287860579,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656512370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287860579\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287860059\">said</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li><code>a[i]!</code> panics if index out of bounds</li>\n<li><code>a[i]?</code> returns <code>Option</code></li>\n<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>\n</ul>\n</blockquote>\n<p>That makes total sense to me</p>\n</blockquote>\n<p>Great. It would be great to have more feedback from the community since this is a very disruptive change.</p>\n<blockquote>\n<p>a[i]! all over their code - I am a Python programmer)</p>\n</blockquote>\n<p>I suspect you are not the only one that will have <code>a[i]!</code> all over the place.</p>\n</blockquote>\n<p>If we end up doing this it could be worth to add a linter that tells you to maybe add  <code>!</code> to your function name if it could panic.</p>\n<p>If this lint works recursively (that is if your function calls a function that could panic) it might end up being a little oppressive though since you could of course in theory be sure that you are not violating its invariants and it will never panic but the compiler keeps yelling at you (an option could be used to address this but people might end up being annoyed if there is too many \"most likely false positives\" they have to option away)</p>\n<p>If it does not work recursively (so only check if you directly call to panic!) it could be a little too loose as well though so I'm not 100% sure whether it's worth to go through with it, we'll likely end up with something that either annoys people too much or doesn't annoy them enough :D</p>\n<p>Just an idea^^</p>",
        "id": 287889294,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656523638
    },
    {
        "content": "<p>Sort of related to this, in a loop such as <code>for i in [0:37] do ...</code> I wonder if there could be some interface where <code>[0:37]</code> could provide some sort of membership proof if you were to write something like <code>for h : i in [0:37] do ...</code>. I would imagine in this case the proof would be of <code>0 &lt;= i /\\ i &lt; 37</code>. This would help with any sort of proposal where <code>a[i]</code> uses <code>i : Fin _</code>.</p>\n<p>There are other solutions to this, but this sort of feature might still be useful.</p>",
        "id": 287890468,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656524160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287890468\">said</a>:</p>\n<blockquote>\n<p>Sort of related to this, in a loop such as <code>for i in [0:37] do ...</code> I wonder if there could be some interface where <code>[0:37]</code> could provide some sort of membership proof if you were to write something like <code>for h : i in [0:37] do ...</code>. I would imagine in this case the proof would be of <code>0 &lt;= i /\\ i &lt; 37</code>. This would help with any sort of proposal where <code>a[i]</code> uses <code>i : Fin _</code>.</p>\n<p>There are other solutions to this, but this sort of feature might still be useful.</p>\n</blockquote>\n<p>We already have the <code>for h : i  in [0:37]</code> feature :)<br>\nSee <a href=\"https://github.com/leanprover/lean4/blob/master/RELEASES.md\">https://github.com/leanprover/lean4/blob/master/RELEASES.md</a> for an example.</p>",
        "id": 287898437,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656527647
    },
    {
        "content": "<blockquote>\n<p>If we end up doing this it could be worth to add a linter that tells you to maybe add ! to your function name if it could panic.</p>\n</blockquote>\n<p>That would be great :)</p>",
        "id": 287899839,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656528315
    },
    {
        "content": "<blockquote>\n<p>If we end up doing this it could be worth to add a linter that tells you to maybe add  <code>!</code> to your function name if it could panic.</p>\n</blockquote>\n<p>To play the devil's advocate, how would you even prove that a function never calls panic?  We have a wonderful proof language, but it cannot say anything about panics.</p>",
        "id": 287906235,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656531028
    },
    {
        "content": "<p>Maybe the panic checker could be like the Lean 3 noncomputability checker, where it makes a best-effort attempt to determine whether or not a function might panic, but it's not a proof per se.  This is more subtle, though, since you'd want to record a predicate on a function's inputs that, when true, guarantee the function will not panic.</p>",
        "id": 287907150,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656531501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287907150\">said</a>:</p>\n<blockquote>\n<p>Maybe the panic checker could be like the Lean 3 noncomputability checker, where it makes a best-effort attempt to determine whether or not a function might panic, but it's not a proof per se.  This is more subtle, though, since you'd want to record a predicate on a function's inputs that, when true, guarantee the function will not panic.</p>\n</blockquote>\n<p>I was assuming the same kind of best-effort attempt, but it seems Gabriel's point is that we will have to add <code>!</code> to a bunch of functions that depend on <code>panic</code>, but <code>panic</code> is not actually reachable.</p>",
        "id": 287908073,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656531954
    },
    {
        "content": "<p>It might still be useful to have this kind of linter if we add some kind of annotation for marking functions that should be viewed as \"panic free\"  even if they depend on it.</p>",
        "id": 287908421,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656532107
    },
    {
        "content": "<p>Maybe this panic checker is like the termination checker, where if you can add hypotheses locally to try to automatically prove that the no-panic predicate for a given function application is true?</p>",
        "id": 287908573,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656532194
    },
    {
        "content": "<p>Nontermination is actually a good comparison because it's not syntactically evident and cannot be proven in Lean.</p>",
        "id": 287909056,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656532426
    },
    {
        "content": "<p>It's certainly vexing that you can prove your program correct, but then it panics or runs into an infinite loop when you run it and there's nothing you can do to rule it out.</p>",
        "id": 287909336,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656532540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287907150\">said</a>:</p>\n<blockquote>\n<p>This is more subtle, though, since you'd want to record a predicate on a function's inputs that, when true, guarantee the function will not panic.</p>\n</blockquote>\n<p>Two more applications of this definedness predicate come to mind:</p>\n<ol>\n<li>If the predicate is satisfied for the inputs of a <code>partial def</code>, then we should have a theorem that the <code>partial def</code> is equal to its body.</li>\n<li>(Very speculatively) The predicate could also record whether all integrals, derivatives, etc., are well-defined.</li>\n</ol>",
        "id": 287910659,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656533135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287908073\">said</a>:</p>\n<blockquote>\n<p>I was assuming the same kind of best-effort attempt, but it seems Gabriel's point is that we will have to add <code>!</code> to a bunch of functions that depend on <code>panic</code>, but <code>panic</code> is not actually reachable.</p>\n</blockquote>\n<p>More pointedly, I think we would need to add <code>!</code> to most definitions since lots of low-level functions use panic.</p>",
        "id": 287911086,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656533323
    },
    {
        "content": "<p>Yes, most functions calling <code>!</code> functions are <em>supposed</em> to never panic, so an opt-out lint might be a bit bothersome; just think of all the functions indexing into arrays without conclusively proving they're doing the right thing. Instead there could be a <code>@[no_panic]</code> opt-in annotation  for people that really want to make sure.</p>",
        "id": 287914939,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656534651
    },
    {
        "content": "<p>For conditionally panicking functions as well as their <code>?D </code> variants, I still wonder if they should be captured by returning a common <code>Option</code> subtype a la <code>{ x : Option A // i &lt; as.size -&gt; x.isSome }</code>. Then all the variants can be expressed as operations on this type. But it would require unboxed unions to avoid (most of) the <code>Option</code> overhead.</p>",
        "id": 287916652,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656534958
    },
    {
        "content": "<p>Yeah the false positives part is exactly the thing I was worrying about above as well, it might end up just being bothersome to the user.</p>",
        "id": 287921551,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656535872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287914939\">said</a>:</p>\n<blockquote>\n<p>Yes, most functions calling <code>!</code> functions are <em>supposed</em> to never panic, so an opt-out lint might be a bit bothersome; just think of all the functions indexing into arrays without conclusively proving they're doing the right thing. Instead there could be a <code>@[no_panic]</code> opt-in annotation  for people that really want to make sure.</p>\n</blockquote>\n<p>Maybe a concrete version of what I was proposing is that you might have an annotation like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[no_panic idx &lt; self.size]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.getOp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">self.get</span><span class=\"bp\">!</span> <span class=\"n\">idx</span>\n</code></pre></div>\n<p>and then the panic checker could try to prove that condition automatically wherever the function is used. In simple cases the panic checker could try to synthesize this condition for functions that call conditionally-panicking functions.</p>",
        "id": 287925187,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656536580
    },
    {
        "content": "<p>If you can automatically prove this, then you can also provide the <code>Fin</code> needed for <code>Array.get</code>. I think serious software verification will always require that the code is syntactically <code>panic</code>-free (and <code>implementedBy</code>-free).</p>",
        "id": 287926859,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1656537386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287916652\">said</a>:</p>\n<blockquote>\n<p>But it would require unboxed unions to avoid (most of) the <code>Option</code> overhead.</p>\n</blockquote>\n<p>I completely forgot that I already had a solution for that... that I never wrote down until now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Conditional</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cond</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Conditional</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Conditional</span> <span class=\"n\">α</span> <span class=\"n\">cond</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">cond</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">c</span> <span class=\"n\">h</span>\n<span class=\"kd\">@[inline]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">cond</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Conditional</span> <span class=\"n\">α</span> <span class=\"n\">cond</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">cond</span> <span class=\"k\">then</span> <span class=\"n\">c.get</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"in the disco\"</span>\n<span class=\"kd\">@[inline]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">cond</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Conditional</span> <span class=\"n\">α</span> <span class=\"n\">cond</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">cond</span> <span class=\"k\">then</span> <span class=\"n\">c.get</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n<span class=\"kd\">@[inline]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">getD</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">cond</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Conditional</span> <span class=\"n\">α</span> <span class=\"n\">cond</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">cond</span> <span class=\"k\">then</span> <span class=\"n\">c.get</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">default</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Conditional</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Array.get'</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Conditional</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">as.size</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">as.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- test code generation</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir.result</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.get</span><span class=\"bp\">!'</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">as.get'</span> <span class=\"n\">i</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">get</span><span class=\"bp\">!</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.getD'</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">as.get'</span> <span class=\"n\">i</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">getD</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.get</span><span class=\"bp\">?'</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">as.get'</span> <span class=\"n\">i</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">get</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>As far as I can see, the generated code is optimal thanks to eta expansion</p>",
        "id": 287930524,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656538191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287906235\">said</a>:</p>\n<blockquote>\n<p>To play the devil's advocate, how would you even prove that a function never calls panic?  We have a wonderful proof language, but it cannot say anything about panics.</p>\n</blockquote>\n<p>I don't understand what you mean by this? If a definition has branch where it panics and a branch where it doesn't, it can be perfectly possible to prove that it does not panic for certain inputs (i.e., that the result is equal to that of the non-panicking branch). For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">does_not_panic</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">panic_if_true</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"was true\"</span> <span class=\"k\">else</span> <span class=\"n\">does_not_panic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">false_does_not_panic</span> <span class=\"o\">:</span> <span class=\"n\">panic_if_true</span><span class=\"bp\">!</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">does_not_panic</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">panic_if_true</span><span class=\"bp\">!;</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 287957985,
        "sender_full_name": "Mac",
        "timestamp": 1656547514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287859389\">said</a>:</p>\n<blockquote>\n<p>We have discussed this issue in the past. One of the proposals was:</p>\n<ul>\n<li><code>a[i]!</code> panics if index out of bounds</li>\n<li><code>a[i]?</code> returns <code>Option</code></li>\n<li><code>a[i]</code> uses proof and <code>i</code> is a <code>Fin</code>.</li>\n</ul>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287930524\">said</a>:</p>\n<blockquote>\n<p>I completely forgot that I already had a solution for that... that I never wrote down until now</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Conditional</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cond</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"c1\">-- [...]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I personally really like both of these approaches. The <code>Conditional</code> solution is much more general and flexible whereas the bracket macro solution is conveniently terse (but still clear).</p>\n<p>It might even be possible to mix the two. For example, to ease the transition, <code>getOp</code> could return a <code>Conditional</code> and <code>Coditional</code> could have a <code>Coe (Conditional a) a := (.get!)</code> instance. This would make most current uses cases still work (due to the coercion). The <code>[]?</code> and <code>[]!</code> macros could be defined on top of this as shorthand for <code>Conditional.get?/getD</code>.  Then, once users have shifted to the new approach, the <code>Conditional</code> coercion could be removed, and the <code>[]</code> could be change to <code>Fin</code> version if desired.</p>",
        "id": 287958988,
        "sender_full_name": "Mac",
        "timestamp": 1656548388
    },
    {
        "content": "<p>I'm also in favour of the notation: <code>a[i]!</code> <code>a[i]?</code>  <code>a[i]</code></p>\n<p>Personally, on my own data types I already use the <code>Fin</code> version of <code>a[i]</code>. However instead of <code>a[i]!</code>, I have defined a macro <code>!x</code> that expands to <code>⟨x, sorry⟩</code>, so I can write <code>a[!i]</code> where <code>i</code> is <code>Nat</code>.</p>",
        "id": 287963200,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656552404
    },
    {
        "content": "<p>With this change to the meaning of <code>a[i]</code>, I would also point out that it might be worth to change the type of the index <code>i</code> in <code>for i in [0:n]</code> from <code>Nat</code> to <code>Fin n</code>. Or something along those lines, like notation <code>for i in [n]</code> to produce the <code>Fin n</code> index.</p>",
        "id": 287963620,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656552781
    },
    {
        "content": "<blockquote>\n<p>If a definition has branch where it panics and a branch where it doesn't, it can be perfectly possible to prove that it does not panic for certain inputs (i.e., that the result is equal to that of the non-panicking branch).</p>\n</blockquote>\n<p>This is of course not nearly sufficient for panic-freeness:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"every time\"</span>\n  <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">a</span>  <span class=\"c1\">-- beautiful stacktrace</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">a_does_not_panic</span><span class=\"bp\">?!?</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 287998681,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656581143
    },
    {
        "content": "<p>Why <code>panic!</code> doesn't require the <code>unsafe</code> attribute on a definition?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.get</span><span class=\"bp\">!'</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">,</span>  <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">get</span><span class=\"bp\">!'</span> <span class=\"n\">as</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span>     <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"invalid index\"</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">l</span>\n<span class=\"n\">decreasing_by</span> <span class=\"n\">decreasing_tactic</span>\n</code></pre></div>\n<p>Depending on <code>lean_set_exit_on_panic</code> and <code>lean_set_panic_messages</code> flags this pure function with explicit proof of termination performs I/O and throws a runtime exception. And when these flags aren't enabled (default behavior when building a binary executable) it could silently introduce a logical bug that is ten times worse. </p>\n<p>With <code>lean_set_panic_messages(true)</code> Lean is lying about the type of this definition (<code>[Inhabited α] → List α → Nat → IO α</code>).<br>\nWith <code>lean_set_exit_on_panic(true)</code> Lean is lying about termination of this function. <br>\nAnd without these flags enabled you won't know that something is going wrong.</p>\n<p>Doesn't this compromise all static guarantees that Lean could provide?</p>",
        "id": 288012358,
        "sender_full_name": "Evgeniy Kuznetsov",
        "timestamp": 1656588519
    },
    {
        "content": "<p><code>unsafe</code> has a very precise definition: it can undermine memory safety. <code>panic!</code> can't.</p>",
        "id": 288012747,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656588732
    },
    {
        "content": "<p>And as discussed above, it is quite hard to make a non-trivial Lean program panic-free, so it definitely should not require a viral annotation</p>",
        "id": 288013020,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656588888
    },
    {
        "content": "<blockquote>\n<p><code>unsafe</code> has a very precise definition: it can undermine memory safety.</p>\n</blockquote>\n<p><code>unsafe</code> also has a second effect: it compromises logical soundness (to clarify: inside <code>unsafe</code>, that is).  <code>panic!</code> is even true constructively.</p>",
        "id": 288013096,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656588924
    },
    {
        "content": "<p>I don't insist on this exact keyword, it can be anything else if you consider <code>unsafe</code> unsuitable.<br>\n<span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288013020\">said</a>:</p>\n<blockquote>\n<p>And as discussed above, it is quite hard to make a non-trivial Lean program panic-free, so it definitely should not require a viral annotation</p>\n</blockquote>\n<p>Even <code>implementedBy</code> trick doesn't  allow to effectively use such a viral annotation when writing a non-trivial program?</p>",
        "id": 288019193,
        "sender_full_name": "Evgeniy Kuznetsov",
        "timestamp": 1656591925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/287998681\">said</a>:</p>\n<blockquote>\n<p>This is of course not nearly sufficient for panic-freeness.</p>\n</blockquote>\n<p>Admittedly, sure, this is true in the context of adversarial examples as you point out. However, it still reasonable to do so in places where <code>panic!</code> is used in a conventional manner (for unproved invariant violations) and the goal is just to prove that the relevant invariant actually does hold  and avoids the panic in a specific case. On the other hand, if the goal is oblivious zero trust panic safety, though, then no, it is not sufficient.</p>",
        "id": 288084866,
        "sender_full_name": "Mac",
        "timestamp": 1656621855
    },
    {
        "content": "<p>Pushed the proposal:</p>\n<ul>\n<li><code>a[i]!</code> panics if index out of bounds</li>\n<li><code>a[i]?</code> returns Option</li>\n<li><code>a[i]</code> uses proof and i is a Fin.</li>\n</ul>\n<p>It is quite disruptive, but it is better now than after the first official release at the end of the summer. <br>\nThe <code>Array</code> type implements the three notations.<br>\nThe <code>String</code> type currently only implements the <code>a[i]?</code>, and <code>String.get</code> still returns a default value for invalid positions. <br>\nWe also have the notation <code>a[i, h]</code> as sugar for <code>a[⟨i, h⟩]</code></p>",
        "id": 288294671,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656803449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288294671\">said</a>:</p>\n<blockquote>\n<p>We also have the notation <code>a[i, h]</code> as sugar for <code>a[⟨i, h⟩]</code></p>\n</blockquote>\n<p><strong>Design question:</strong> Would it be possible/reasonable to have <code>a[i, h]</code> expand to yet another <code>getOp</code> version that takes the index and hypothesis as separate parameters (e.g., <code>Array.uget</code>)? This could avoid the potential boxing/unboxing overhead that comes with <code>Fin</code> and remove the need for other types which have an index condition and use the syntax to have a <code>Subtype</code>-like structure (or directly use <code>Subtype</code>)? Just a thought, not sure how reasonable/worthwhile of an idea it is.</p>",
        "id": 288307808,
        "sender_full_name": "Mac",
        "timestamp": 1656824116
    },
    {
        "content": "<p>I'm not sure about the notation <code>a[i, h]</code>. What about multi dimensional arrays, I would like to have a notation <code>a[i, j]</code> for matrices. Wouldn't be there a clash?</p>",
        "id": 288313519,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656833306
    },
    {
        "content": "<p>Also at some point I would like to experiment with notation <code>a[:, j]</code> for slices i.e. j-th column of a matrix . It would be nice if the notation would not clash with that either. (Not saying it does right now but it would be nice to keep this in mind when doing further changes)</p>",
        "id": 288318150,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656840936
    },
    {
        "content": "<p>One thing I do not understand, is why is the notation <code>a[i]</code> done with <code>getOp</code> which has special requirements on argument names etc. Why it is not a simple macro/notation for <code>a.get i</code> ? My guess, is it related to Lean's bootstrapping?</p>",
        "id": 288318345,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656841217
    },
    {
        "content": "<p>Is it possible to have a <code>GetOp</code> typeclass to reuse this syntax for different index types (like <code>Nat</code>, <code>Range</code>,  <code>Nat × Nat </code>,  <code>Fin</code> and <code>Nat × Prop</code>) at the same time?</p>",
        "id": 288319767,
        "sender_full_name": "Xubai Wang",
        "timestamp": 1656843519
    },
    {
        "content": "<p>For example：</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getOp</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">GetOp</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getOp</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">For Lists</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- as[⟨n, h⟩]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">∘</span> <span class=\"n\">List.length</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">getOp</span> <span class=\"n\">as</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">as.get</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- as[n, h]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">as.length</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">getOp</span> <span class=\"n\">as</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">as.get</span> <span class=\"o\">⟨</span><span class=\"n\">x.fst</span><span class=\"o\">,</span> <span class=\"n\">x.snd</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- as[n]?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getOp</span><span class=\"bp\">?</span> <span class=\"n\">as</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">as.get</span><span class=\"bp\">?</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- as[[m:n]]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">Range</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getOp</span> <span class=\"n\">as</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Matrix m[i, j]</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 288323037,
        "sender_full_name": "Xubai Wang",
        "timestamp": 1656848387
    },
    {
        "content": "<p>I'm a bit unsure if <code>a[i, j]</code> should be a shorthand for <code>a[i][j]</code> or <code>a[(i, j)]</code>.</p>\n<p>Effectively, do you understand matrix as <code>Fin n -&gt; Fin m -&gt; Float</code> or as <code>Prod (Fin n) (Fin m) -&gt; Float</code>.</p>\n<p>The second one might be boxing those indices unnecessarily.</p>",
        "id": 288325906,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656852398
    },
    {
        "content": "<p>The detailed decision is up for who implements it. Also I think boxing (dereferencing) may not be a big overhead in the future, since we will have stack allocated value \"soon\"?</p>",
        "id": 288326519,
        "sender_full_name": "Xubai Wang",
        "timestamp": 1656853210
    },
    {
        "content": "<p>Thanks for the feedback. I will remove the <code>a[i, h]</code> for now. The issue raised by <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> was also exposed by one of our tests, and I used priorities to override the notation.<br>\n<a href=\"https://github.com/leanprover/lean4/commit/a0fdc2d05049ecbaf21f57e9cc4a997e0c6bed91\">https://github.com/leanprover/lean4/commit/a0fdc2d05049ecbaf21f57e9cc4a997e0c6bed91</a><br>\nI will post other messages discussing how the notation works and other suggestions.</p>",
        "id": 288326630,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656853412
    },
    {
        "content": "<p>We often have to decide whether we should use \"dot-notation\" (aka namespace-oriented) or \"type classes\". I am coping here a thread we had in the dev channel last year. It describes the \"pros\" and \"cons\" of each approach, and examples.</p>\n<h2>type classes pros</h2>\n<ul>\n<li>Chaining. That is, given an instance <code>ToString A</code>, we can create an instance <code>ToString (List A)</code></li>\n<li>We can write polymorphic methods </li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n   <span class=\"s2\">\"&gt;&gt; \"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">a</span>\n</code></pre></div>\n<h2>type classes cons</h2>\n<ul>\n<li>Depends heavily on unification. Moreover, it becomes quite unreliable when higher-order unification has to be used. This is often an issue when we want to make a polymorphic method as general as possible. More about this later. </li>\n<li>Universe constraints. It is part of the unification problem described in the previous item, but it is often overlooked since the universes are often implicit.</li>\n<li>We don't want type class resolution to assign metavariables occurring in input parameters. So, TC often fails in scenarios we don't have sufficient information. The new <code>defaultInstance</code> feature minimizes this problem.</li>\n</ul>\n<h2>dot-notation pros</h2>\n<ul>\n<li>Low tech and predictable. Given <code>x : C as</code>, <code>x.foo</code> is notation for <code>C.foo x</code>. The parameters <code>as</code> may contain metavariables. </li>\n<li>Allow non-uniform signatures. That is, <code>C.foo</code> and <code>D.foo</code> may have completely different types.</li>\n</ul>\n<h2>dot-notation cons</h2>\n<ul>\n<li>No support for chaining </li>\n<li>No support for writing polymorphic functions. That is, we can't write</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.toString</span>\n</code></pre></div>\n<h1>An Example: the <code>x[i]</code> notation</h1>\n<p>In the <code>master</code> branch, <code>x[i]</code> is a notation based on the dot-notation. That is, given <code>x : C as</code>, it is a notation for <code>x.getOp i</code>.<br>\nThis is flexible since the type of <code>i</code> may or may not depend on <code>x</code>, the result type may or may not depend on <code>x</code> and/or <code>i</code>, and the only information the elaborator needs is the head symbol <code>C</code>, and <code>as</code> may contain a bunch of metavariables. </p>\n<p>Now, suppose we have used a type class <code>GetElem</code> for implementing the notation <code>x[i]</code>. The first try would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>The problem here is that there isn't support for dependencies. For example, we can't implement <code>getElem</code> using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Array.get</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>since the index <code>i</code> depends on <code>a</code>.<br>\nThen, we may try to define a more general <code>GetElem</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">((</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">c</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>Then, we can add instances such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">a.get</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">RBMapDep</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">a.find</span><span class=\"bp\">?</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>Everything looks great until we try to use <code>getElem</code>. The problem is that it generates nontrivial higher-order unification problems.<br>\nNote that the type of <code>i</code> at <code>t[i]</code> is of the form <code>?m t</code>. Suppose we have <code>t : Array Nat</code>, after we resolve the TC problem, we have to solve the unification problem <code>?m t =?= Fin t.size</code>. Even a simple version where <code>t</code> is just a variable and we don't take into account reduction, we have two solutions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"n\">x.size</span>\n<span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"n\">t.size</span>\n</code></pre></div>\n<p>In this particular case, the first solution is the right one, but, in general, there is no way to decide. In Lean 2, we have tried to transform elaboration into a constraint solving problem, but the performance was bad, and error messages that are very hard to understand. <br>\nSo, I don't see how to have classes that rely on higher-order unification and are reliable in practice.</p>",
        "id": 288326880,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656853695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288307808\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288294671\">said</a>:</p>\n<blockquote>\n<p>We also have the notation <code>a[i, h]</code> as sugar for <code>a[⟨i, h⟩]</code></p>\n</blockquote>\n<p><strong>Design question:</strong> Would it be possible/reasonable to have <code>a[i, h]</code> expand to yet another <code>getOp</code> version that takes the index and hypothesis as separate parameters (e.g., <code>Array.uget</code>)? This could avoid the potential boxing/unboxing overhead that comes with <code>Fin</code> and remove the need for other types which have an index condition and use the syntax to have a <code>Subtype</code>-like structure (or directly use <code>Subtype</code>)? Just a thought, not sure how reasonable/worthwhile of an idea it is.</p>\n</blockquote>\n<p>This is an interesting suggestion, but the \"function selection process\" would have to depend on the type of the index too. The current dispatch is based only on the type of <code>a</code>. Note that, given <code>a : Array Int</code> when we type <code>a[_]</code>, the hole has type <code>Fin a.size</code>. <br>\nIf we move to type-classes, then we have the problems described in the previous comment.</p>",
        "id": 288327076,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656853937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288318345\">said</a>:</p>\n<blockquote>\n<p>One thing I do not understand, is why is the notation <code>a[i]</code> done with <code>getOp</code> which has special requirements on argument names etc. Why it is not a simple macro/notation for <code>a.get i</code> ? My guess, is it related to Lean's bootstrapping?</p>\n</blockquote>\n<p>The notation uses the \"dot notation\" (aka namespace-based) approach described above.</p>",
        "id": 288327154,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656854055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288327076\">said</a>:</p>\n<blockquote>\n<p>[T]he \"function selection process\" would have to depend on the type of the index too. [..] If we move to type-classes, then we have the problems described in the previous comment.</p>\n</blockquote>\n<p>What if we combined the two? That is, what if we used type class synthesis for the \"function selection process\" and once found, expanded it via a macro. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Meta</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">Name</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">``</span><span class=\"n\">Array.getOp</span><span class=\"o\">⟩</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">unsafeEvalExpr</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToExpr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Meta.evalExpr</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">toTypeExpr</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">@[implementedBy unsafeEvalExpr]</span>\n<span class=\"n\">opaque</span> <span class=\"n\">evalExpr</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToExpr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span>\n\n<span class=\"n\">elab</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\"]'\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">a</span> <span class=\"n\">none</span>\n  <span class=\"n\">synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">α</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">getDecLevel</span> <span class=\"n\">α</span>\n  <span class=\"k\">let</span> <span class=\"n\">inst</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">GetOp</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span>\n  <span class=\"k\">let</span> <span class=\"n\">instVal</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstance</span> <span class=\"n\">inst</span>\n  <span class=\"k\">let</span> <span class=\"n\">ope</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">GetOp.op</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">instVal</span><span class=\"o\">])</span>\n  <span class=\"k\">let</span> <span class=\"n\">op</span> <span class=\"bp\">←</span> <span class=\"n\">evalExpr</span> <span class=\"n\">Name</span> <span class=\"n\">ope</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkCIdent</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">withMacroExpansion</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getRef</span><span class=\"o\">)</span> <span class=\"n\">stx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">elabTerm</span> <span class=\"n\">stx</span> <span class=\"n\">none</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'</span> <span class=\"c1\">-- 1</span>\n</code></pre></div>\n<p>This would enable the chain benefits of type classes, while avoiding the unification problem.</p>",
        "id": 288355366,
        "sender_full_name": "Mac",
        "timestamp": 1656894325
    },
    {
        "content": "<p>My two cents: I was expecting the proof in <code>a[i]</code> to go after the brackets, as in <code>a[i] h</code>, as if it were replacing the <code>!</code> or <code>?</code></p>",
        "id": 288398232,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1656934735
    },
    {
        "content": "<p>Coincidentally that's exactly what you'd have to/could do if <code>a[i]</code> returned <code>Conditional</code></p>",
        "id": 288402134,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656937012
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> </p>\n<blockquote>\n<p>What if we combined the two? That is, what if we used type class synthesis for the \"function selection process\" and once found, expanded it via a macro. For example:</p>\n</blockquote>\n<p>One nice feature of your approach is that we can use scoped instances and instance priorities to select which function is used to implement <code>a[i]</code>. For example, we could have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Array.unsafeReads</span>\n<span class=\"n\">scoped</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">``</span><span class=\"n\">Array.get</span><span class=\"bp\">!</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span> <span class=\"n\">Array.unsafeReads</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">][⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩]</span><span class=\"bp\">'</span>  <span class=\"c1\">-- index is a Fin</span>\n<span class=\"kn\">open</span> <span class=\"n\">Array.unsafeReads</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'</span>  <span class=\"c1\">-- index is a Nat</span>\n</code></pre></div>\n<p>This is good. On the other hand, it feels like an abuse of the type class resolution feature. We would be using it to implement a mapping from type to function name. Let's see what others have to say about this.</p>",
        "id": 288418557,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656946583
    },
    {
        "content": "<p>A typeclass solution that is not parameterized over the index type (like in Rust, for prior work) to me just feels... disappointing. It's neither here nor there.</p>",
        "id": 288419501,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656947128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288419501\">said</a>:</p>\n<blockquote>\n<p>A typeclass solution that is not parameterized over the index type (like in Rust, for prior work) to me just feels... disappointing</p>\n</blockquote>\n<p>Yes, it is disappointing, but Rust does not have dependent types. So, they can avoid the higher-order unification problems introduced by a type class such as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">((</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">c</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>Because they can simply use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span> <span class=\"bp\">→</span>  <span class=\"n\">ι</span>  <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 288420023,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656947415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288402134\">said</a>:</p>\n<blockquote>\n<p>Coincidentally that's exactly what you'd have to/could do if <code>a[i]</code> returned <code>Conditional</code></p>\n</blockquote>\n<p>The <code>Conditional</code> proposal streamlines the definition of <code>get?</code>, <code>get!</code>, etc. This is good, but I have two concerns.</p>\n<ul>\n<li>If <code>i : Fin a.size</code>, we would have to write <code>a[i.val] i.isLt</code> </li>\n<li>It may impact the compilation times. The code generator is creating/eliminating joint-points as it inlines these definitions to eliminate the overhead.</li>\n</ul>",
        "id": 288421620,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656948394
    },
    {
        "content": "<p>Would this be a defensible use case for <code>[macroInline]</code>? I haven't checked the resulting IR yet, or whether it avoids the join points.</p>",
        "id": 288421848,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656948555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288421620\">said</a>:</p>\n<blockquote>\n<ul>\n<li>If <code>i : Fin a.size</code>, we would have to write <code>a[i.val] i.isLt</code> </li>\n</ul>\n</blockquote>\n<p>Yes. We can keep it as taking <code>Fin</code> and use <code>Conditional.get</code> in its implementation.</p>",
        "id": 288422559,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656949003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288421848\">said</a>:</p>\n<blockquote>\n<p>Would this be a defensible use case for <code>[macroInline]</code>? I haven't checked the resulting IR yet, or whether it avoids the join points.</p>\n</blockquote>\n<p>Not sure it would work. The code generator would still find the nested if-then-else.</p>",
        "id": 288422637,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656949075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288422559\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288421620\">said</a>:</p>\n<blockquote>\n<ul>\n<li>If <code>i : Fin a.size</code>, we would have to write <code>a[i.val] i.isLt</code> </li>\n</ul>\n</blockquote>\n<p>Yes. We can keep it as taking <code>Fin</code> and use <code>Conditional.get</code> in its implementation.</p>\n</blockquote>\n<p>Not sure whether it is worth the trouble.</p>",
        "id": 288422838,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656949200
    },
    {
        "content": "<p>I can see a substantial improvement if we can solve the higher-order unification problems generated by a type-class like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">((</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">c</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>We could try to write a custom elaboration function for <code>getElem</code> applications. We have implemented similar custom elaborators before (e.g., <code>▸</code> for <code>Eq.subst</code>). It is hard to tell how well it would work. <br>\nIf we succeed, we would be able to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">a.get</span><span class=\"bp\">!</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">a.get</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i.toNat</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">a.uget</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>We would still need <code>a[i]?</code> for the <code>Option</code> case, or use a scoped instance for it.</p>",
        "id": 288423574,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656949672
    },
    {
        "content": "<p>I was thinking along similar lines, that I would love to tell the elaborator not to bother creating the HO problem regarding <code>i : ?m c</code>, but that <code>i : ?m'</code> is enough for now until TC resolution is done. It seems like typeclasses like this will be a reoccurring issue.</p>",
        "id": 288424264,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656949988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288424264\">said</a>:</p>\n<blockquote>\n<p>I was thinking along similar lines, that I would love to tell the elaborator not to bother creating the HO problem regarding <code>i : ?m c</code>, but that <code>i : ?m'</code> is enough for now until TC resolution is done. It seems like typeclasses like this will be a reoccurring issue.</p>\n</blockquote>\n<p>It is not clear to me how your proposal would work. When using the <code>GetElem</code> type class above, we have to infer <code>ρ</code> and <code>ι</code> before we invoke the TC resolution procedure. To infer <code>ι</code>, we need higher-order unification.</p>",
        "id": 288426262,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656951075
    },
    {
        "content": "<blockquote>\n<p>It seems like typeclasses like this will be a reoccurring issue.</p>\n</blockquote>\n<p>I agree. If we solve it for <code>GetElem</code>, we can try to generalize the solution.</p>",
        "id": 288426518,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656951229
    },
    {
        "content": "<p>Oh, I falsely assumed <code>ι</code> was an outParam. I don't know if it <em>should</em> be one, but that would be the closer modelling compared to the current design I think.</p>",
        "id": 288426711,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656951357
    },
    {
        "content": "<p>If <code>ι</code> is an <code>outParam</code>, I don't see a big motivation for moving to type classes. We would be able to use scoped instances to select different implementations like in <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>'s proposal. Note that <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>'s proposal completely avoids all ho-unification issues.</p>",
        "id": 288427390,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656951775
    },
    {
        "content": "<p><code>ι</code> not being an <code>outParam</code> would be the strongest point in favor for type classes to me, to enable overloading of the index type. But I don't see how to reconcile that with the HO issues, yeah.</p>",
        "id": 288427863,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656952060
    },
    {
        "content": "<p>I have a slightly more general question regarding this, my knowledge of ho-unification is that:</p>\n<ul>\n<li>it is not decidable</li>\n<li>is related to dependent types</li>\n<li>and apparently a pretty big issue</li>\n</ul>\n<p>But i never really understood <em>what</em> it is, could someone explain to me what the issue arising with this type class would be?</p>",
        "id": 288429093,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656952842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> In the higher-order case, the metavariables can be functions. Even the simply-typed case is already a mess. Consider the following unification problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"bp\">=?=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>Here are some possible solutions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n<span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n<span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 288430236,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656953725
    },
    {
        "content": "<p>ah and thus solving the alpha parameter doesn't work out nicely, yes?</p>",
        "id": 288430343,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656953804
    },
    {
        "content": "<p>Given <code>a : Array Int</code>, <code>i : Nat</code>, If <code>a[i]</code> is a notation for <code>GetElem.getElem a i</code>, then before invoking TC, we would have to solve the constraints</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">ρ</span> <span class=\"bp\">=?=</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span> <span class=\"c1\">-- Easy case</span>\n<span class=\"bp\">?</span><span class=\"n\">ι</span> <span class=\"n\">a</span> <span class=\"bp\">=?=</span> <span class=\"n\">Nat</span> <span class=\"c1\">-- nasty case</span>\n</code></pre></div>\n<p>The \"right\" solution for the example above is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">ρ</span> <span class=\"o\">:=</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span>\n<span class=\"bp\">?</span><span class=\"n\">ι</span>  <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>We have to solve unification problems such as <code>?ι ?ρ =?= Nat</code> in other parts of the system (e.g., computing the motive for <code>induction</code>).<br>\nHowever, in each one of these cases we do not use the general <code>isDefEq</code>, but a custom heuristic that is usually based on \"waiting\" for information, and using the <code>kabstract</code> function.</p>",
        "id": 288430917,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656954202
    },
    {
        "content": "<p>And in this case, waiting would only make sense if <code>ι</code> is an <code>outParam</code>. Correct?</p>",
        "id": 288431230,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656954372
    },
    {
        "content": "<p>Waiting in the same sense as postponing execution in term elaboration I guess?</p>",
        "id": 288431522,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1656954604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/288431230\">said</a>:</p>\n<blockquote>\n<p>And in this case, waiting would only make sense if <code>ι</code> is an <code>outParam</code>. Correct?</p>\n</blockquote>\n<p>Sorry, I was vague. I was referring to the case that  it is not an <code>outParam</code>. The idea is to wait for <code>a</code> and the type of <code>i</code> to be fully \"available\" (i.e., they do not contain nested metavariables). Then, we compute <code>ι</code> by using <code>kabstract &lt;type-of-i&gt; &lt;a&gt;</code>.</p>",
        "id": 288431621,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656954686
    },
    {
        "content": "<p>I see! Ideally <code>i : Fin ?m</code> would be sufficient to trigger TC resolution, but your idea would already be quite good.</p>",
        "id": 288432414,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656955173
    },
    {
        "content": "<p>We could also put the domain as an extra argument to the type class, avoiding dependencies:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">Cont</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Elem</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Dom</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">Cont</span> <span class=\"bp\">→</span> <span class=\"n\">Idx</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Cont</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Dom</span> <span class=\"n\">xs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">getElem</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">getElem</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">GetElem</span> <span class=\"n\">Cont</span> <span class=\"n\">Idx</span> <span class=\"n\">Elem</span> <span class=\"n\">Dom</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">Elem</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Cont</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">Dom</span> <span class=\"n\">xs</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"k\">then</span> <span class=\"n\">getElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">getElem</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">GetElem</span> <span class=\"n\">Cont</span> <span class=\"n\">Idx</span> <span class=\"n\">Elem</span> <span class=\"n\">Dom</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Cont</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">Dom</span> <span class=\"n\">xs</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Elem</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">getElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"linarith\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"bp\">|</span> <span class=\"n\">trivial</span> <span class=\"bp\">|</span> <span class=\"n\">decide</span> <span class=\"bp\">|</span> <span class=\"n\">assumption</span><span class=\"o\">)</span> <span class=\"c1\">-- TODO</span>\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">getElem</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">))</span>\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\"]?\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">getElem</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\"]!\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">getElem</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">Nat</span> <span class=\"n\">α</span> <span class=\"k\">fun</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xs.size</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">xs.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">Std.Range</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">xs.extract</span> <span class=\"n\">i.start</span> <span class=\"n\">i.stop</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">][</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">][[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"o\">]]</span>\n</code></pre></div>",
        "id": 288436126,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656957753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I think this proposal is cleaner than the <code>Conditional</code> one. Perhaps, we should just accept the fact that the <code>Idx</code> cannot depend on the collection. That is, we can't write <code>instance : GetElem (Array α) (Fin ??) ...</code>. Perhaps this is acceptable. We can still write <code>instance : GetElem (Vector α n) (Fin n) ...</code></p>",
        "id": 288441833,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656962039
    },
    {
        "content": "<p>Here is a version of my proposal that allows the operation to be dependent on the index:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Meta</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">Name</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">as</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">``</span><span class=\"n\">Array.getOp</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">as</span> <span class=\"n\">USize</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">``</span><span class=\"n\">Array.uget</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetOp</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">as</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">as.size</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">``</span><span class=\"n\">Array.get</span><span class=\"o\">⟩</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">unsafeEvalExpr</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToExpr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Meta.evalExpr</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">toTypeExpr</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">@[implementedBy unsafeEvalExpr]</span>\n<span class=\"n\">opaque</span> <span class=\"n\">evalExpr</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToExpr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span>\n\n<span class=\"n\">elab</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\"]'\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ax</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">a</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">ix</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">i</span> <span class=\"n\">none</span>\n  <span class=\"n\">synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">ρ</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">ax</span>\n  <span class=\"k\">let</span> <span class=\"n\">ι</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">ix</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">getDecLevel</span> <span class=\"n\">ρ</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">getDecLevel</span> <span class=\"n\">ι</span>\n  <span class=\"k\">let</span> <span class=\"n\">inst</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">GetOp</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"n\">ax</span><span class=\"o\">,</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">instVal</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstance</span> <span class=\"n\">inst</span>\n  <span class=\"k\">let</span> <span class=\"n\">opApp</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">GetOp.op</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"n\">ax</span><span class=\"o\">,</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">instVal</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">opVal</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">opApp</span>\n  <span class=\"k\">let</span> <span class=\"n\">op</span> <span class=\"bp\">←</span> <span class=\"n\">evalExpr</span> <span class=\"n\">Name</span> <span class=\"n\">opVal</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkCIdent</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">withMacroExpansion</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getRef</span><span class=\"o\">)</span> <span class=\"n\">stx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">elabTerm</span> <span class=\"n\">stx</span> <span class=\"n\">none</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'</span> <span class=\"c1\">-- 1</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">][(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)]</span><span class=\"bp\">'</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">native_decide</span><span class=\"o\">)</span> <span class=\"c1\">-- 1</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"n\">Fin.mk</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">size</span> <span class=\"k\">from</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)]</span><span class=\"bp\">'</span> <span class=\"c1\">-- 1</span>\n</code></pre></div>",
        "id": 288442394,
        "sender_full_name": "Mac",
        "timestamp": 1656962427
    },
    {
        "content": "<p>What do you think <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>  / <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  / <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> ?</p>",
        "id": 288443169,
        "sender_full_name": "Mac",
        "timestamp": 1656962961
    },
    {
        "content": "<p>For me personally, finding out a class <code>GetOp</code> that asks for <code>Name</code> instead of the expected function would be a huge wtf moment. Might not be an issue if this becomes a common pattern or the user side interface is a bit more sane.</p>",
        "id": 288443747,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656963344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I agree with Tomas, the hack is getting too complicated, and the code above does not have support for postponing elaboration yet.  Another problem is that mechanisms such as <code>[defaultInstances]</code> will not work with your approach.</p>",
        "id": 288443925,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1656963477
    },
    {
        "content": "<p>A nice benefit of having <code>_[_]</code> default to a tactic search is that we can give a very clear error message if it fails, even explaining Lean's indexing approach to newcomers that invariably try to apply the standard indexing notation.</p>",
        "id": 288444439,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656963848
    },
    {
        "content": "<p>We can also make the search tactic do the right thing for Fins out of the box.  Then nobody will notice that <code>_[_]</code> doesn't support Fin:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">GetElem</span> <span class=\"n\">Cont</span> <span class=\"n\">Nat</span> <span class=\"n\">Elem</span> <span class=\"n\">Dom</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"n\">Cont</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">Elem</span> <span class=\"k\">fun</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Dom</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">getElem</span> <span class=\"n\">xs</span> <span class=\"n\">i.1</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin.mk</span> <span class=\"n\">a</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">linarith</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">foo</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">xs.size</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 288444781,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1656964122
    },
    {
        "content": "<p>Can't the Mac's approach be done with an attribute? I.e. tagging functions that follow certain pattern instead of using an odd type class.</p>",
        "id": 288444925,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1656964233
    },
    {
        "content": "<p>A bit tangentially related, would it be possible to get <code>a[i]</code> displayed in the goal view as <code>a[i]</code> and not as <code>Array.getOp a i</code>?</p>\n<p>mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">trace_state</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>Displays <code>Array.getOp a i = 0</code> instead of <code>a[i] = 0</code>. It makes lots of stuff I work with quite unreadable.</p>",
        "id": 288496752,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657010949
    },
    {
        "content": "<p>Specifically for Array.getOp it's possible with an appUnexpander:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter</span>\n\n<span class=\"kd\">@[appUnexpander Array.getOp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpandGet</span> <span class=\"o\">:</span> <span class=\"n\">Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Array.getOp</span> <span class=\"bp\">$</span><span class=\"n\">array</span> <span class=\"bp\">$</span><span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">index</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">trace_state</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>Traces</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>But generalizing this to all getOps (as they are currently implemented) might  require some manual work or magic in the compiler to treat getOp applications to any type specially.</p>\n<p>Depending on the implementation suggestions from above it would also be doable with varying degrees of complexity, if we end up with a pure type class it should be trivial because there is only one unexpander required, if we do it with the attribute the thing that handles the attribute would have to generate an unexpander specifically etc.</p>",
        "id": 288497558,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657011358
    },
    {
        "content": "<p>Ohh I see, this solution is good enough for me for now. I just add this bit of code to every place where I provide <code>getOp</code>.</p>",
        "id": 288498330,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657011731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>'s proposal above is now on master. Please update your projects, and thanks for your patience with these changes before the first official release. The proposal seems to be working well after a few improvements to our elaborator.</p>",
        "id": 289070431,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1657411812
    },
    {
        "content": "<p>Please see release notes for additional details: <a href=\"https://github.com/leanprover/lean4/blob/49951b87b953c7cf74f415c1dc1488ae26921cf2/RELEASES.md\">https://github.com/leanprover/lean4/blob/49951b87b953c7cf74f415c1dc1488ae26921cf2/RELEASES.md</a></p>",
        "id": 289070463,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1657411861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>  Very cool!  <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>  One suggestion, though: instead of <code>a[i]'h</code> for index-with-proof-syntax, how about just <code>a[i](h)</code>? Most of the examples that use <code>a[i]'h</code> already end up doing <code>a[i]'(h)</code> so this would be shorter and, in my view, cleaner and clearer.</p>",
        "id": 289081643,
        "sender_full_name": "Mac",
        "timestamp": 1657427792
    },
    {
        "content": "<p>I'm also not sure about the <code>a[i]'h</code> notation. What about <code>a[i|h]</code> or <code>a[i;h]</code>?</p>",
        "id": 289085947,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657435081
    },
    {
        "content": "<p>Cool works nicely! A quick test to find out if notation like <code>∑ i, b[i]</code> works correctly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"∑\"</span> <span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">Lean.explicitBinders</span> <span class=\"s2\">\", \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.expandExplicitBinders</span> <span class=\"bp\">`</span><span class=\"n\">sum</span> <span class=\"n\">xs</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NArray</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">a.size</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[defaultInstance]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">NArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">xs.1.get</span> <span class=\"o\">(</span><span class=\"n\">xs.2</span> <span class=\"bp\">▸</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">NArray</span> <span class=\"n\">Nat</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">10</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>   <span class=\"c1\">--- works as expected!</span>\n</code></pre></div>",
        "id": 289092521,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657445368
    },
    {
        "content": "<p>However I'm unable to get the unexpander working. This does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[appUnexpander GetElem.getElem]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpandGet</span> <span class=\"o\">:</span> <span class=\"n\">Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">GetElem.getElem</span> <span class=\"bp\">$</span><span class=\"n\">array</span> <span class=\"bp\">$</span><span class=\"n\">index</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">index</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>However, there is a bit ambiguity how to unexpand it, do you want <code>a[i]</code> or<code>a[i]'h</code>. I would like to apply the above unexpander only if <code>Dom = (λ _ _ =&gt; True)</code>.</p>",
        "id": 289093710,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657447211
    },
    {
        "content": "<p>For the unexpander there are two mistakes on your side, both related to how syntax works:</p>\n<ol>\n<li><code>GetElem.getElem</code> is syntactically not equivalent to <code>getElem</code> which is what the macro uses so every occurence of the macro won't match this here already</li>\n<li><code>_</code> is interpreted as a literal syntactic <code>_</code> here, you want an antiquotation <code>$_</code></li>\n</ol>\n<p>And then we get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter</span>\n\n<span class=\"kd\">@[appUnexpander GetElem.getElem]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpandGet</span> <span class=\"o\">:</span> <span class=\"n\">Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">getElem</span> <span class=\"bp\">$</span><span class=\"n\">array</span> <span class=\"bp\">$</span><span class=\"n\">index</span> <span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">index</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">trace_state</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>which traces</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 289093852,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657447440
    },
    {
        "content": "<p>Ahh thanks! I was slowly uncovering 1 but had no clue about 2.</p>",
        "id": 289093912,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657447495
    },
    {
        "content": "<p>Should it be <code>@[appUnexpander GetElem.getElem]</code> or <code>@[appUnexpander getElem]</code>? ... both work.</p>",
        "id": 289094008,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657447593
    },
    {
        "content": "<p>I guess I'd use the 2nd since it is what the unexpander in question actually cares about? But I don't know whether it makes a difference.</p>\n<p>I'm also not quite sure how to adapt the unexpander to correctly make a difference between the cases where a 'h and none was used, for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"c1\">-- Ok</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[appUnexpander GetElem.getElem]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpandGet</span> <span class=\"o\">:</span> <span class=\"n\">Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">getElem</span> <span class=\"bp\">$</span><span class=\"n\">array</span> <span class=\"bp\">$</span><span class=\"n\">index</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">index</span><span class=\"o\">]</span><span class=\"bp\">'$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>turns into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">h</span>\n</code></pre></div>\n<p>so there is virtually no difference between <code>a[i]'h</code> and <code>a[i]</code> with the <code>h</code> inferred via tactic on a syntactic level at this point.</p>",
        "id": 289094394,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657448128
    },
    {
        "content": "<p>Yeah, I'm not sure what to do about that. That is why I wanted to do the unexpander only for <code>Dom = (λ _ _ =&gt; True)</code> i.e. when the domain proof is trivial. Maybe, in all other cases unexpand to <code>a[i]'h</code> ?</p>",
        "id": 289094633,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657448451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289085947\">said</a>:</p>\n<blockquote>\n<p>I'm also not sure about the <code>a[i]'h</code> notation. What about <code>a[i|h]</code> or <code>a[i;h]</code>?</p>\n</blockquote>\n<p>The <code>a[i]' h</code> notation is based on the following suggestion from <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> </p>\n<blockquote>\n<p>My two cents: I was expecting the proof in a[i] to go after the brackets, as in a[i] h, as if it were replacing the ! or ?</p>\n</blockquote>\n<p>The only difference is the <code>'</code>.  <br>\nIt would be great to have a consensus here. I  don't have a strong preference here, but I found this variant useful when fixing the Lean 4 repo.</p>",
        "id": 289103375,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1657460002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Thanks for the feedback. I will add an abbreviation for <code>a[i] ' h</code>. Thus, we can use it in the unexpander.</p>",
        "id": 289103471,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1657460115
    },
    {
        "content": "<p>Pushed <a href=\"https://github.com/leanprover/lean4/commit/35018dbea24dd92d5f75b02a9faa8bbf57a5496d\">https://github.com/leanprover/lean4/commit/35018dbea24dd92d5f75b02a9faa8bbf57a5496d</a></p>",
        "id": 289104238,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1657460980
    },
    {
        "content": "<p>Since there doesn't seem  to be an immediately natural syntax for <code>a[i]'h</code>, I think it's worth discussing whether we need one at all. Especially if we assume that most short proofs will eventually be automated by e.g. <code>linarith</code> anyway, and for everything longer than one line any such notation seems problematic. Still, sometimes you might not want to type out the proposition for a separate <code>have</code> (though auto-generating that skeleton from a Code Action would be cool). Since we already have other such \"implicitly proof-consuming\" syntax with well-founded recursion, I'm wondering whether we should have a general syntax for discharging remaining proof obligations from terms on the command level, like with Coq's <code>Program</code>/<code>Obligation</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a.size</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">case</span> <span class=\"bp\">«</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">»</span> <span class=\"bp\">=&gt;</span>  <span class=\"c1\">-- should also accept a default like `case _`</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 289104330,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1657461058
    },
    {
        "content": "<p>For further motivation, imagine repeating the same syntax discussion for a proof-consuming division operator :) ...</p>",
        "id": 289104518,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1657461259
    },
    {
        "content": "<p>I think having a user extensible framework for proof consuming operators is a great idea <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 289104775,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657461585
    },
    {
        "content": "<p>my only concern would be that the connection between the written code and the underlying terms might get a bit further separated -- like, to me, the termination_by is a magic wand that I do not understand, but it's okay because I never have to really interact with the underlying <code>rec</code> definition, just with the equational lemmas...</p>",
        "id": 289105559,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1657462477
    },
    {
        "content": "<p>whereas I fully expect users to have to interact with <code>getElem</code> and its corresponding proof terms</p>",
        "id": 289105590,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1657462517
    },
    {
        "content": "<p>When would you interact with its proof terms?</p>",
        "id": 289105656,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1657462581
    },
    {
        "content": "<p>If you're doing any proof with a term that uses <code>getElem</code> you'd see the version with the proof term in it, if that makes sense. Lean wouldn't hide the underlying proof terms from you as it does with well-founded recursion</p>",
        "id": 289106019,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1657463063
    },
    {
        "content": "<p>I guess in the case of well-founded recursion you _can_ still end up seeing the underlying representation, but my impression is that something is wrong if you're seeing it</p>",
        "id": 289106073,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1657463144
    },
    {
        "content": "<p>We do in fact hide the proof in the <code>getElem</code> unexpander. And even if you disable <code>pp.notation</code>, you'll still only see <code>_</code> for the proof because of <code>pp.proofs</code>. But at that level the output will be the same regardless of which syntactic approach we choose anyway.</p>",
        "id": 289106214,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1657463334
    },
    {
        "content": "<p>Would it be possible / too magic to have <code>a[i]</code> look for an assumption in the context possibly supplied by <code>have</code> and otherwise fall back on the normal <code>getOp</code>? That would make for some really slick code for stuff like <code>if h : x &lt; a.size then a[i] else 37</code></p>",
        "id": 289109650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657467581
    },
    {
        "content": "<p>The choice of <code>'</code> as separator is not particularly consonant with other syntax in lean, but I don't have any better suggestions</p>",
        "id": 289109728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657467655
    },
    {
        "content": "<p>Not sure if you've been following this thread, but that's exactly what it does now (except for the falling back part).</p>",
        "id": 289109729,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1657467657
    },
    {
        "content": "<p>It uses this custom extensible tactic which among others calls to <code>assumption</code> so it can do this</p>",
        "id": 289109742,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657467679
    },
    {
        "content": "<p>oops, I guess the new one is <code>a[i]!</code> now</p>",
        "id": 289109744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657467682
    },
    {
        "content": "<p>what's the current state of the fin version?</p>",
        "id": 289109805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657467775
    },
    {
        "content": "<p>It is done through a typeclass, so you can write <code>a[i]</code> for <code>i : Nat</code> and fetch proof from context but you can also write <code>a[i]</code> for <code>i : Fin a.size</code>.</p>",
        "id": 289109904,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657467955
    },
    {
        "content": "<p>Ah, just read the release notes which clarify the situation somewhat. The <code>get_elem_tactic</code> tactic doesn't seem to have any access to information about what array or index is being proved?</p>",
        "id": 289109994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657468066
    },
    {
        "content": "<p>Oh <code>a[i]</code> for <code>i : Fin a.size</code> works because of coercion of <code>Fin a.size</code> to <code>Nat</code> instead of specialized instance of <code>GetElem</code>.</p>",
        "id": 289110145,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657468217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289109994\">said</a>:</p>\n<blockquote>\n<p>Ah, just read the release notes which clarify the situation somewhat. The <code>get_elem_tactic</code> tactic doesn't seem to have any access to information about what array or index is being proved?</p>\n</blockquote>\n<p>I guess you could extend it with a type aware tactic that fails per default if there isn't the types it expects around though right?</p>",
        "id": 289110241,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657468352
    },
    {
        "content": "<p>I mean, you can implement it as <code>assumption</code> which is presumably the intent, but I don't see what kind of extra smarts you could give it</p>",
        "id": 289110724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657468981
    },
    {
        "content": "<p>Do we also want to unify notation <code>a[i] := x</code> and <code>a[i] += x</code>? </p>\n<p>Following identical pattern I have defined two classes <code>SetElem</code> and <code>ModifyElem</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SetElem</span> <span class=\"o\">(</span><span class=\"n\">Cont</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Elem</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Dom</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">Cont</span> <span class=\"bp\">→</span> <span class=\"n\">Idx</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">setElem</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Cont</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Dom</span> <span class=\"n\">xs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Cont</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">SetElem</span> <span class=\"o\">(</span><span class=\"n\">setElem</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ModifyElem</span> <span class=\"o\">(</span><span class=\"n\">Cont</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Elem</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Dom</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">Cont</span> <span class=\"bp\">→</span> <span class=\"n\">Idx</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">modifyElem</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Cont</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"bp\">→</span> <span class=\"n\">Elem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Dom</span> <span class=\"n\">xs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Cont</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">ModifyElem</span> <span class=\"o\">(</span><span class=\"n\">modifyElem</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"n\">atomic</span><span class=\"o\">(</span><span class=\"n\">Lean.Parser.Term.ident</span><span class=\"o\">)</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">doElem</span>\n<span class=\"n\">syntax</span> <span class=\"n\">atomic</span><span class=\"o\">(</span><span class=\"n\">Lean.Parser.Term.ident</span><span class=\"o\">)</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"s2\">\" += \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">doElem</span>\n\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doElem</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">xi</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doElem</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:=</span> <span class=\"n\">setElem</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">i</span> <span class=\"bp\">$</span><span class=\"n\">xi</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">get_elem_tactic</span><span class=\"o\">))</span>\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doElem</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">]</span> <span class=\"bp\">+=</span> <span class=\"bp\">$</span><span class=\"n\">xi</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doElem</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:=</span> <span class=\"n\">modifyElem</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">val</span> <span class=\"bp\">+</span> <span class=\"bp\">$</span><span class=\"n\">xi</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">get_elem_tactic</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SetElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">Nat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xs.size</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">setElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">xs.set</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ModifyElem</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">Nat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xs.size</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">modifyElem</span> <span class=\"n\">xs</span> <span class=\"n\">i</span> <span class=\"n\">f</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">xs.modify</span> <span class=\"n\">i</span> <span class=\"n\">f</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">List.toArray</span> <span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">10</span><span class=\"o\">]</span>\n  <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span>\n  <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"bp\">+=</span> <span class=\"mi\">6</span>\n  <span class=\"n\">a</span> <span class=\"c1\">-- returns #[42, 16]</span>\n</code></pre></div>",
        "id": 289110792,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657469054
    },
    {
        "content": "<p>Didn't <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> have some implementation of general lvalues? How hard is it to incorporate arrays in that?</p>",
        "id": 289110821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657469109
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/905#issuecomment-1165768170\">https://github.com/leanprover/lean4/issues/905#issuecomment-1165768170</a>  And it supports array updates (at least with the syntax from yesterday).</p>",
        "id": 289111350,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1657469834
    },
    {
        "content": "<p>That looks really nice!</p>",
        "id": 289111654,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1657470303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289109729\">said</a>:</p>\n<blockquote>\n<p>Not sure if you've been following this thread, but that's exactly what it does now (except for the falling back part).</p>\n</blockquote>\n<p>I expanded the release notes <a href=\"https://github.com/leanprover/lean4/commit/351fc6ea04ea5aa5763d2981826acafa2ec2a617\">https://github.com/leanprover/lean4/commit/351fc6ea04ea5aa5763d2981826acafa2ec2a617</a></p>",
        "id": 289112644,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1657471575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/String.2EgetOp/near/289109805\">said</a>:</p>\n<blockquote>\n<p>what's the current state of the fin version?</p>\n</blockquote>\n<p>I covered the <code>Fin</code> case in the commit above.</p>",
        "id": 289112759,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1657471790
    },
    {
        "content": "<p>typo: <code>get_tactic_tactic</code> in the release notes</p>",
        "id": 289113935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657473173
    },
    {
        "content": "<p>I really like <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>'s proposal of having a syntax to define well-formed checks after the rest of the definition.   ACL2 and PVS both allow one to defer side condition checks like this and that might be partly born out of necessity, but I think it avoids having proofs of these sort of safety side-conditions clutter up the program.</p>",
        "id": 289253316,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1657575493
    }
]
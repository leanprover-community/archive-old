[
    {
        "content": "<p>Textbooks define discrete objects as n-tuples of sets and operations on those. This approach is prominently ported to lean4 in <code>mathlib4</code>, but I can't seem to grasp the understanding of method. I hope someone could point me to the right direction in terms of understanding how to design libraries that provide abstractions in lean4.</p>\n<p>Consider the notion of wall clock (as opposed to a logical one). My goal is to generalise it so that I could swap out IO for a simulation monad and test the actual user code under simulation rather than in the real world. It's ecological, because now, to \"wait a year and run something\", I can tell my simulation monad that I want a year to pass rather than sleeping for a year in IO.</p>\n<p>This calls for an open system, and our best hope for solving expression problem is ad hoc polymorphism.</p>\n<p>Thus I write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n  <span class=\"n\">delta</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Time</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">IO.monoMsNow</span>\n  <span class=\"n\">delta</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>But now, even if there is just one instance for a given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\"> \\sigma </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\"> m </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\"> \\alpha </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>, Lean still won't be able to resolve it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nowPlusOne</span> <span class=\"o\">:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Time.stamp</span> <span class=\"o\">()</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">@</span><span class=\"n\">Time.stamp</span> <span class=\"bp\">?</span><span class=\"n\">m.1584</span> <span class=\"bp\">?</span><span class=\"n\">m.1585</span> <span class=\"bp\">?</span><span class=\"n\">m.1586</span> <span class=\"o\">()</span>\n<span class=\"n\">argument</span>\n  <span class=\"o\">()</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Unit</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>What would you do if you were me? How would you design Time?</p>",
        "id": 289599134,
        "sender_full_name": "cognivore",
        "timestamp": 1657808857
    },
    {
        "content": "<p>Your definition of <code>nowPlusOne</code> does not fully specify the parameters of <code>Time</code>. You can see that no call to <code>stamp</code> is going to indicate what <code>δ</code> is involved, since that type isn't used. In fact, Lean picks this up and keeps it a non-implicit parameter:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Time.stamp</span>\n<span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Time</span> <span class=\"n\">m</span> <span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"n\">δ</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Lean isn't going to guess <code>δ</code> based on the instances available, because that would be too fragile - it could break by adding more instances, which is typically what you don't want when dealing with typeclasses.</p>\n<p>You can specify <code>δ</code> explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nowPlusOne</span> <span class=\"o\">:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Time.stamp</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">()</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>Or you can not specify it and instead quantify. There might be a better way to write it, but it could look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nowPlusOne</span> <span class=\"o\">[</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">Time</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">δ</span><span class=\"o\">]:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">T.stamp</span> <span class=\"n\">_</span> <span class=\"o\">()</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>Note that you will have a similar problem with <code>delta</code> since just calling <code>delta</code> leaves <code>σ</code> unspecified.</p>",
        "id": 289600748,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1657809623
    },
    {
        "content": "<p>I think you can use an <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html?highlight=outpara#output-parameters\">outParam</a> for this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n  <span class=\"n\">delta</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Time</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">IO.monoMsNow</span>\n  <span class=\"n\">delta</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nowPlusOne</span> <span class=\"o\">:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Time.stamp</span> <span class=\"o\">()</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 289601010,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1657809761
    },
    {
        "content": "<blockquote>\n<p>it could break by adding more instances, which is typically what you don't want when dealing with typeclasses</p>\n</blockquote>\n<p>Interesting, Haskell, by default, wants \"fragile\" typeclasses, to an extent it has a special syntax for \"very fragile\" typeclasses (I mean functional dependencies), which reduces parametricity. </p>\n<p>Thank you for explaining design and providing the snippets! They were most helpful, amazing insight! <span aria-label=\"bow\" class=\"emoji emoji-1f647\" role=\"img\" title=\"bow\">:bow:</span></p>",
        "id": 289601883,
        "sender_full_name": "cognivore",
        "timestamp": 1657810155
    },
    {
        "content": "<p><code>outParam</code> is a restricted form of functional dependencies</p>",
        "id": 289601952,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1657810195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/270676-lean4/topic/Multiparameter.20typeclasses.20mimicking.20textbook.20definitions/near/289601010\">said</a>:</p>\n<blockquote>\n<p>I think you can use an <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html?highlight=outpara#output-parameters\">outParam</a> for this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n  <span class=\"n\">delta</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Time</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">IO.monoMsNow</span>\n  <span class=\"n\">delta</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nowPlusOne</span> <span class=\"o\">:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Time.stamp</span> <span class=\"o\">()</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ahha, I've seen <code>outParam</code>, in lean4 docs snippets, but I couldn't find the explanation. Thank you very much for your insight too!</p>",
        "id": 289602033,
        "sender_full_name": "cognivore",
        "timestamp": 1657810214
    },
    {
        "content": "<p>If you only have one instance with a particular <code>m</code> and <code>α</code> then you could have both <code>σ</code> and <code>δ</code> be <code>outParam</code>.</p>",
        "id": 289602133,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1657810267
    },
    {
        "content": "<p>I have one final question: does this model make sense at all? Would you design a system with the requirements I have (i.e. swappable monad, simulated real world) in a similar way, or there's something I'm missing?</p>",
        "id": 289602184,
        "sender_full_name": "cognivore",
        "timestamp": 1657810299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484617\">Sébastien Michelland</span> <a href=\"#narrow/stream/270676-lean4/topic/Multiparameter.20typeclasses.20mimicking.20textbook.20definitions/near/289602133\">said</a>:</p>\n<blockquote>\n<p>If you only have one instance with a particular <code>m</code> and <code>α</code> then you could have both <code>σ</code> and <code>δ</code> be <code>outParam</code>.</p>\n</blockquote>\n<p>That's amazing! That's what I was missing actually, I have some other abstractions which have \"functional dependencies\", and outParam will be perfect for it!</p>",
        "id": 289602279,
        "sender_full_name": "cognivore",
        "timestamp": 1657810336
    },
    {
        "content": "<p>I do also believe that having both of this in one type class is bad design, the delta operation can exist completely independent of m and sigma and stamp can exist independent of δ which is the root cause of this issue here. How about splitting it up into two typeclasses instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Stamp</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Delta</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">delta</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Stamp</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">stamp</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">IO.monoMsNow</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Delta</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span> <span class=\"n\">where</span>\n  <span class=\"n\">delta</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nowPlusOne</span> <span class=\"o\">:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Stamp.stamp</span> <span class=\"o\">()</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">diff</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"n\">Delta.delta</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>where you might want to add some outParam depending on your use case. If you really need a <code>Time</code> typeclass with both in the end you can also write one that extends both <code>Delta</code> and <code>Stamp</code> to combine them.</p>",
        "id": 289602742,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1657810548
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"507516\">cognivore</span> has marked this topic as resolved.</p>",
        "id": 289603560,
        "sender_full_name": "Notification Bot",
        "timestamp": 1657810848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"507516\">cognivore</span> <a href=\"#narrow/stream/270676-lean4/topic/Multiparameter.20typeclasses.20mimicking.20textbook.20definitions/near/289602184\">said</a>:</p>\n<blockquote>\n<p>I have one final question: does this model make sense at all? Would you design a system with the requirements I have (i.e. swappable monad, simulated real world) in a similar way, or there's something I'm missing?</p>\n</blockquote>\n<p>It's not clear why you want to attach your time type/class to these methods as opposed to just writing a notion of time and then composing it with the other stuff (like IO to get system time).</p>",
        "id": 289603730,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1657810904
    },
    {
        "content": "<p>Not to self-promote, but there's WIP date/time library for lean 4 if you want a point of reference: <a href=\"https://github.com/ammkrn/timelib\">https://github.com/ammkrn/timelib</a></p>",
        "id": 289603903,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1657810972
    },
    {
        "content": "<p>The clock time stuff is in <code>NanoPrecision/ClockTime</code>.</p>",
        "id": 289604018,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1657811025
    }
]
[
    {
        "content": "<p>In principle, if we run into a goal like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n      <span class=\"n\">Std.AssocList.toList</span>\n        <span class=\"o\">(</span><span class=\"n\">addSubSup</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span>\n          <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span> <span class=\"bp\">||</span> <span class=\"n\">List.any</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span>\n          <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span><span class=\"o\">)))</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n</code></pre></div>\n<p>(for an MWE, see: <a href=\"https://github.com/NicolasRouquette/oml.lean4/blob/master/src/Oml/MWE8.lean\">https://github.com/NicolasRouquette/oml.lean4/blob/master/src/Oml/MWE8.lean</a>)</p>\n<p>I noticed that I can split the goal with either:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span>\n</code></pre></div>\n<p>or:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n</code></pre></div>\n<p>I understand the former involves an <code>Eq</code> Prop, the latter involves <code>BEq</code>.<br>\nCan someone explain the difference and how it matters?</p>\n<p>Regardless of which I choose, I get two subgoals: <code>pos</code> and <code>neg</code>.</p>\n<p>For the <code>pos</code> case,  I also get the hypothesis that <code>key == sup</code> (or <code>key = sup</code>).<br>\nI can apply that hypothesis and simplify the <code>pos</code> subgoal. Great!</p>\n<p>This seems to be a common pattern and I see that it is often written like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>For the <code>neg</code> case, I also get the hypothesis that <code>¬(key == sup) = true</code> (or <code>¬key = sup</code>).<br>\nHowever, no matter what I do, I can't get lean to simplify the <code>neg</code> subgoal!</p>\n<p>Here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">addBoth.sub_eq</span> <span class=\"o\">(</span><span class=\"n\">sub</span> <span class=\"n\">sup</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">addBoth</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span> <span class=\"n\">ss</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">sub</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ss</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">,</span> <span class=\"n\">addDecl</span><span class=\"o\">,</span> <span class=\"n\">addSubSup</span><span class=\"o\">,</span> <span class=\"n\">cond_eq_ite</span><span class=\"o\">]</span>\n    <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n  <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">,</span> <span class=\"n\">addDecl</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">pos</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addSubSup</span><span class=\"o\">,</span> <span class=\"n\">cond_eq_ite</span><span class=\"o\">]</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">sup</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">,</span> <span class=\"n\">addDecl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">tail_ih</span>\n        <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">tail_ih</span>\n        <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">h_1</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n        <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">h_2</span> <span class=\"n\">x</span> <span class=\"n\">heq</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">by_cases</span> <span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addSubSup</span><span class=\"o\">,</span> <span class=\"n\">cond_eq_ite</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">tail_ih</span>\n          <span class=\"n\">apply</span> <span class=\"n\">tail_ih</span>\n    <span class=\"bp\">.</span> <span class=\"n\">case</span> <span class=\"n\">neg</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">addBoth</span><span class=\"o\">,</span> <span class=\"n\">addDecl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">tail_ih</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The only unsolved case is the last one where the tactic state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">subsupkey</span><span class=\"o\">:</span> <span class=\"n\">String</span>\n<span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Strings</span>\n<span class=\"n\">tail</span><span class=\"o\">:</span> <span class=\"n\">Std.AssocList</span> <span class=\"n\">String</span> <span class=\"n\">Strings</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">key</span> <span class=\"bp\">=</span> <span class=\"n\">sup</span>\n<span class=\"n\">tail_ih</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n      <span class=\"n\">Std.AssocList.toList</span>\n        <span class=\"o\">(</span><span class=\"n\">addSubSup</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span>\n          <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">List.any</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tail</span>\n          <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"n\">tail</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span>\n      <span class=\"n\">Std.AssocList.toList</span>\n        <span class=\"o\">(</span><span class=\"n\">addSubSup</span> <span class=\"n\">sub</span> <span class=\"n\">sup</span>\n          <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">key</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span> <span class=\"bp\">||</span> <span class=\"n\">List.any</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.toList</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst</span> <span class=\"bp\">==</span> <span class=\"n\">sup</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span>\n          <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">sup</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">Std.AssocList.cons</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span><span class=\"o\">)))</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">x.fst</span> <span class=\"bp\">=</span> <span class=\"n\">sub</span>\n</code></pre></div>\n<p>I tried to do <code>simp [h]</code> but that makes no difference.<br>\nI also tried the version using  <code>BEq</code> (see the MWE link above) -- same problem.</p>\n<p>Any suggestions?</p>",
        "id": 323170079,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1674539743
    },
    {
        "content": "<p>I would just go for the manual approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"bp\">\\&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">tail_ih</span>\n<span class=\"n\">exists</span> <span class=\"n\">x</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and continue the proof from there by using <code>hx</code>.</p>",
        "id": 323259956,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1674569243
    }
]
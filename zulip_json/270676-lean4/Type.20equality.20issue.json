[
    {
        "content": "<p>I don't know if my question will have enough context but I'm blocking with a context of the form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n<span class=\"n\">H2</span><span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">T2</span>\n<span class=\"bp\">|-</span>  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">T2</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>I do not see how to discharge hypothesis H2 to resolve the <code>Eq.mpr</code> constraint and conclude.<br>\n(sorry if this does not make sense, I have a concrete example but it's kind of ugly)</p>",
        "id": 296708538,
        "sender_full_name": "Frederic Peschanski",
        "timestamp": 1662070660
    },
    {
        "content": "<p>Does <code>cases H2</code> help? Or <code>subst H2</code>?</p>",
        "id": 296708930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662070849
    },
    {
        "content": "<p>Oh sorry this is lean 4, I don't know if these tactics exist. A perhaps more helpful comment might be that you might have gone wrong at the point where the eq.mpr appeared.</p>",
        "id": 296709101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662070940
    },
    {
        "content": "<p>Could you give at least the types of <code>f</code>, <code>x</code> and <code>y</code>? On the first sight, I have trouble understanding how your goal even typechecks.</p>\n<p>If I try to reconstruct the type of <code>y</code> I find that <code>y</code> should have type <code>T2</code> and the <code>Eq.mpr ...</code> has T1, so how can you put both of them into the second argument of <code>f</code>?</p>\n<p>Are there any coercions between <code>T1</code> and <code>T2</code>? As far as I know, the type checker does not care about equality, only about definitional equality. So there should be a type mismatch in the goal, shouldn't it?</p>\n<p>If <code>T1</code> and <code>T2</code> are in fact definitionally equal, you can just use <code>exact H1</code> because the goal would be defeq to the assumption</p>",
        "id": 296751206,
        "sender_full_name": "Jan-Mirko Otter",
        "timestamp": 1662094729
    },
    {
        "content": "<p>Thanks for the suggestions. I should have added that the equation <code>T1 = T2</code> is more of the form <code>T u1 = T u2</code> with <code>u1 = u2</code>provable, but <em>not</em> by definitional equality.  It is not exactly the same situation but what follows maybe gives some hint.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">T</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">T.mk</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"mi\">4</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">same</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sameEq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">same</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">same</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">dummy</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">):</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H1</span>\n  <span class=\"bp\">???</span>\n</code></pre></div>\n<p>at the point <code>???</code>, the context is :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">n</span>\n<span class=\"n\">yz</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">u</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"n\">n</span>\n<span class=\"n\">H1</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>The difference here is that I have not an explicit <code>Eq.mpr</code> but still  <code>exact H1</code> will fail  (and so is e.g. <code>rw[u]</code>)</p>\n<p>Maybe the general question is how to manage  non-definitional Type-level equality (substitutions, etc.) ?<br>\n(sorry if all this does not make much sense, I'm rather new to lean4 ...)</p>",
        "id": 296784246,
        "sender_full_name": "Frederic Peschanski",
        "timestamp": 1662112271
    },
    {
        "content": "<p>I would prove it as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">dummy</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">):</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H1</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">f</span>\n  <span class=\"n\">split</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">same</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_sub_cancel</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">H1</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 296786247,
        "sender_full_name": "František Silváši",
        "timestamp": 1662112993
    },
    {
        "content": "<p>I.e. <code>unfold f</code> and use <code>split</code> to generate 'per partes' equalites for the match.</p>",
        "id": 296786590,
        "sender_full_name": "František Silváši",
        "timestamp": 1662113139
    },
    {
        "content": "<p>Thx <span class=\"user-mention\" data-user-id=\"364929\">@František Silváši</span> it's a good hint for me! I'm able to progress. One problem is that the <code>split</code> use to destruct the <code>match</code> introduces many fresh variables (e.g. <code>_fun_discr✝³</code>..., which seems to loose some information wrt. the context   although not in this particular case).  This reminds me of <code>case_eq</code> vs. <code>case/destruct</code> in Coq...</p>",
        "id": 296797931,
        "sender_full_name": "Frederic Peschanski",
        "timestamp": 1662117724
    },
    {
        "content": "<p>I am not sure exactly what your goal looks like, you can try to <code>generalize</code> the terms before you destruct them, which should preserve the equalities you care about. By the way, I've just realized that the <code>split</code> is unnecessary.<br>\nYou can do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H1</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">same</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_sub_cancel</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">H1</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Unfolding <code>f</code> gives you the match, which you can now reduce with <code>simp</code> to get rid of the dependency on <code>u</code> (i.e. you can <code>clear u</code> there, as in: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intro</span> <span class=\"n\">H1</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">f</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">clear</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>).<br>\nThe rest is independent of <code>u</code> so <code>simp only [same]; rw [add_comm 1, Nat.add_sub_cancel, ←H1]; rfl</code> closes the goal. (Worth noting you need <code>u</code> thereuntil for your conclusion depends thereon.)</p>",
        "id": 296800296,
        "sender_full_name": "František Silváši",
        "timestamp": 1662118618
    },
    {
        "content": "<p>How about the following solution?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">dummy</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">):</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H1</span>\n  <span class=\"k\">show</span> <span class=\"bp\">@</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">same</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Eq.subst</span>\n    <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"bp\">@</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">sameEq</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">H1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span> <span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's longer, but I think it explains more what is going on, and maybe helps you to adapt it to your problem.</p>\n<p>If I understand you correctly, you want to substitue <code>n</code> with <code>same n</code> in the proposition <code>@f n _ y = z</code>. You can use <code>Eq.subst</code> for that.</p>\n<p>The main problem is the proof term. That's why I substitute in the expression <code>(h : T n) → @f n h y</code> instead. Doing the substitution, you get <code>(h : T (same n)) → @f (same n) h y = z</code>. Then you just need to apply a simple proof of <code>T (same n)</code>, which is given by <code>Eq.mpr u x</code></p>",
        "id": 296894856,
        "sender_full_name": "Jan-Mirko Otter",
        "timestamp": 1662152500
    },
    {
        "content": "<p>Just to say again: in Lean 3 if I was faced with a goal which has an Eq.rec or one of its derivatives in it then I'd backtrack and find out how it appeared. This comes up when doing category theory in Lean 3 and there the standard fix is that if X = Y but the proof isn't <code>rfl</code> then we might use <code>eq_to_hom</code> to get a morphism <code>X \\hom Y</code> and apply that morphism instead. The simplifier has been trained to know what to do with <code>eq_to_hom</code> and things tend to work out smoothly. I think that blindly soldiering on with an <code>Eq.rec</code> can be quite unpleasant.</p>",
        "id": 296903447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662156849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"527227\">Jan-Mirko Otter</span> <a href=\"#narrow/stream/270676-lean4/topic/Type.20equality.20issue/near/296894856\">said</a>:</p>\n<blockquote>\n<p>How about the following solution?<br>\n...</p>\n</blockquote>\n<p>Great ! I did not have the idea to use <code>Eq.subst</code> this way <br>\n... This might adapt to my problem, I'll tell you soon thank you !</p>",
        "id": 297102305,
        "sender_full_name": "Frederic Peschanski",
        "timestamp": 1662298469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Type.20equality.20issue/near/296903447\">said</a>:</p>\n<blockquote>\n<p>(...) if X = Y but the proof isn't <code>rfl</code> then we might use <code>eq_to_hom</code> to get a morphism <code>X \\hom Y</code> and apply that morphism instead. (...)</p>\n</blockquote>\n<p>I guess Lean4 is not yet ready for let's say a higher-level approach (hopefully mathlib4 will catch up at some point).  I should add that I get such relatively strange proof contexts through very lean4-ish type-level computations  (in fact, playing with sized-types like vectors).</p>",
        "id": 297102679,
        "sender_full_name": "Frederic Peschanski",
        "timestamp": 1662298697
    },
    {
        "content": "<p>Problem solved with <code>cast_eq</code> ...</p>",
        "id": 301268695,
        "sender_full_name": "Frederic Peschanski",
        "timestamp": 1664380646
    }
]
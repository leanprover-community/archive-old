[
    {
        "content": "<p>I'm having an issue understanding how type information flows in GADTs:</p>\n<p><code>Expr</code> has two parameters: a value <code>A</code> and an environment <code>E</code>.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">done</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">Unit</span> <span class=\"n\">A</span>\n  <span class=\"bp\">|</span> <span class=\"n\">more</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">E</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">E</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Subset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">Provided</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">E</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"o\">:</span> <span class=\"n\">Subset</span> <span class=\"n\">E</span> <span class=\"n\">Provided</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">env</span><span class=\"o\">:</span> <span class=\"n\">Provided</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">current</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">done</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- `E` should be equals to `Unit` here, no?</span>\n    <span class=\"o\">()</span>\n\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">more</span> <span class=\"n\">E1</span> <span class=\"n\">_</span> <span class=\"n\">expr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- `E` should be equals to `E1` here, no?</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> ERROR: failed to synthesize instance Subset E1 Provided -/</span>\n    <span class=\"n\">eval</span> <span class=\"n\">expr</span> <span class=\"n\">env</span>\n</code></pre></div>\n<p>My assumption is that after pattern matching, on each branch the compiler has more information about specific types, for example in the <code>.done</code> case I expect that <code>E</code>  is equal to <code>Unit</code>.</p>\n<p>In the <code>.more</code> case, I expect that <code>E</code> is equal to <code>E1</code>. Clearly that's not the case, and so the implicit instance is not being picked up from the scope.</p>\n<p>Any help would be appreciated.</p>",
        "id": 298185501,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662851093
    },
    {
        "content": "<p>First things first a little terminology: we don't really use the term GADT in Lean, this is an inductive type, more specifically a family of types indexed by the two other Type parameters.</p>\n<p>Regarding your questions for equality in the branches, yes this is indeed the case and in fact you can make Lean tell you that this is the case by doing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">E</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"o\">:</span> <span class=\"n\">Subset</span> <span class=\"n\">E</span> <span class=\"n\">Provided</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">env</span><span class=\"o\">:</span> <span class=\"n\">Provided</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">current</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">done</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- `E` should be equals to `Unit` here, no?</span>\n    <span class=\"o\">()</span>\n\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">more</span> <span class=\"n\">E1</span> <span class=\"n\">_</span> <span class=\"n\">expr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- `E` should be equals to `E1` here, no?</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> ERROR: failed to synthesize instance Subset E1 Provided -/</span>\n    <span class=\"n\">eval</span> <span class=\"n\">expr</span> <span class=\"n\">env</span>\n</code></pre></div>\n<p>notice the <code>h:</code> at the match, in the <code>done</code> case this will give you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">Unit</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">current</span> <span class=\"o\">(</span><span class=\"n\">Expr.done</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and in the <code>more</code> one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">E1</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">current</span> <span class=\"o\">(</span><span class=\"n\">Expr.more</span> <span class=\"n\">E1</span> <span class=\"n\">A</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>however usually you do not need these theorems in scope since the Lean dependent pattern matcher is smart enough to apply these facts to your local context. For example had your function had another argument of type <code>E</code>, namely <code>foo</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">E</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"o\">:</span> <span class=\"n\">Subset</span> <span class=\"n\">E</span> <span class=\"n\">Provided</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">env</span><span class=\"o\">:</span> <span class=\"n\">Provided</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">current</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">done</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">more</span> <span class=\"n\">E1</span> <span class=\"n\">_</span> <span class=\"n\">expr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>you will in both branches observe that the dependent pattern matcher has intelligently changed the type of <code>foo</code> to <code>Unit</code> and <code>E1</code> respectively. </p>\n<p>Now in order to fix the error you have two choices here, one would be to use the <code>h:</code> approach to get the equivalence proof in the branch and then apply it with a <code>▸</code>, the other would be to add the <code>inst</code> parameter to your pattern matcher because that will make it apply this theorem automatically again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">E</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"o\">:</span> <span class=\"n\">Subset</span> <span class=\"n\">E</span> <span class=\"n\">Provided</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">env</span><span class=\"o\">:</span> <span class=\"n\">Provided</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">current</span><span class=\"o\">,</span> <span class=\"n\">inst</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">done</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>    <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">more</span> <span class=\"n\">E1</span> <span class=\"n\">_</span> <span class=\"n\">expr</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eval</span> <span class=\"n\">expr</span> <span class=\"n\">env</span>\n</code></pre></div>\n<p>I would personally prefer this one because it creates less burden on the user to figure out which theorem to apply where etc. but it does of course look a little magical as well since we are ignoring the result in both cases pretty much.</p>",
        "id": 298187430,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1662853123
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 298188476,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662854337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395535\">Juan Pablo Romero</span> has marked this topic as resolved.</p>",
        "id": 298188496,
        "sender_full_name": "Notification Bot",
        "timestamp": 1662854355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395535\">Juan Pablo Romero</span> has marked this topic as unresolved.</p>",
        "id": 298191713,
        "sender_full_name": "Notification Bot",
        "timestamp": 1662857847
    },
    {
        "content": "<p>Quick followup question:  Is this a good way to get hold of inaccessible  values?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">eq</span><span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">E1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Or is there a way to avoid getting into tactic mode?</p>",
        "id": 298191717,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662857862
    },
    {
        "content": "<p><code>‹E = E1›</code> (typed by <code>\\f&lt;</code> and <code>\\f&gt;</code>in vscode-lean) is a shorthand for <code>show E = E1 by assumption</code>.</p>",
        "id": 298214551,
        "sender_full_name": "pcpthm",
        "timestamp": 1662880695
    }
]
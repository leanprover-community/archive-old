[
    {
        "content": "<p>I implemented my own <code>#print prefix</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">print_prefix</span><span class=\"o\">)</span> <span class=\"s2\">\"#print prefix\"</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"n\">deriving</span> <span class=\"kd\">instance</span> <span class=\"n\">Inhabited</span> <span class=\"n\">for</span> <span class=\"n\">ConstantInfo</span> <span class=\"c1\">-- required for Array.qsort</span>\n\n<span class=\"kd\">@[commandElab print_prefix]</span> <span class=\"kd\">def</span> <span class=\"n\">elabPrintPrefix</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">#print</span> <span class=\"kd\">prefix</span><span class=\"bp\">%$</span><span class=\"n\">tk</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n    <span class=\"k\">let</span> <span class=\"n\">matches</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.fold</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">xs</span> <span class=\"n\">name</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">i.getId.isPrefixOf</span> <span class=\"n\">name</span> <span class=\"k\">then</span> <span class=\"n\">xs.push</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n    <span class=\"k\">let</span> <span class=\"n\">matches</span> <span class=\"o\">:=</span> <span class=\"n\">matches.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.1.lt</span> <span class=\"n\">q.1</span><span class=\"o\">)</span>\n    <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">matches</span> <span class=\"k\">do</span>\n      <span class=\"n\">logInfoAt</span> <span class=\"n\">tk</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{name} : {val.type}\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Bool : Type</span>\n<span class=\"cm\">Bool._sizeOf_1 : Bool → Nat</span>\n<span class=\"cm\">Bool._sizeOf_inst : SizeOf Bool</span>\n<span class=\"cm\">Bool.casesOn : {motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t</span>\n<span class=\"cm\">Bool.false : Bool</span>\n<span class=\"cm\">Bool.noConfusion : {P : Sort u} → {v1 v2 : Bool} → v1 = v2 → Bool.noConfusionType P v1 v2</span>\n<span class=\"cm\">Bool.noConfusionType : Sort u → Bool → Bool → Sort u</span>\n<span class=\"cm\">Bool.rec : {motive : Bool → Sort u} → motive false → motive true → (t : Bool) → motive t</span>\n<span class=\"cm\">Bool.recOn : {motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t</span>\n<span class=\"cm\">Bool.toLBool : Bool → LBool</span>\n<span class=\"cm\">Bool.toUInt64 : Bool → UInt64</span>\n<span class=\"cm\">Bool.true : Bool</span>\n<span class=\"cm\">Bool.false.sizeOf_spec : sizeOf false = 1</span>\n<span class=\"cm\">Bool.toLBool._cstage1 : Bool → LBool</span>\n<span class=\"cm\">Bool.toLBool._cstage2 : UInt8 → UInt8</span>\n<span class=\"cm\">Bool.toLBool.match_1 : (motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x</span>\n<span class=\"cm\">Bool.true.sizeOf_spec : sizeOf true = 1</span>\n<span class=\"cm\">Bool.toLBool.match_1._cstage1 : (motive : Bool → Sort u_1) →</span>\n<span class=\"cm\">  (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x</span>\n<span class=\"cm\">Bool.toLBool.match_1._cstage2 : _neutral → _obj</span>\n<span class=\"cm\">Bool.toLBool.match_1._rarg._cstage2 : UInt8 → _obj → _obj → _obj</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 225049959,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612373389
    },
    {
        "content": "<p>looks like a great addition to the prelude library that doesn't exist yet <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 225050891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612373710
    },
    {
        "content": "<p>How about a more general <code>#search</code> command modeled after <a href=\"https://coq.inria.fr/refman/proof-engine/vernacular-commands.html#coq:cmd.Search\">https://coq.inria.fr/refman/proof-engine/vernacular-commands.html#coq:cmd.Search</a> ?</p>",
        "id": 225051799,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612374096
    },
    {
        "content": "<p>An efficient search command would be <em>great</em></p>",
        "id": 225051837,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1612374120
    },
    {
        "content": "<p>This is clearly something that people coming from Coq miss a lot when using Lean 3.</p>",
        "id": 225051922,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1612374144
    },
    {
        "content": "<p>Not sure it makes sense to explicitly reify the search DSL as in <a href=\"https://coq.inria.fr/refman/proof-engine/vernacular-commands.html#coq:cmd.Search\">https://coq.inria.fr/refman/proof-engine/vernacular-commands.html#coq:cmd.Search</a> in light of Lean4's great meta-programming support. Here is one (somewhat clunky) starting point:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Meta</span>\n\n<span class=\"n\">deriving</span> <span class=\"kd\">instance</span> <span class=\"n\">Inhabited</span> <span class=\"n\">for</span> <span class=\"n\">ConstantInfo</span> <span class=\"c1\">-- required for Array.qsort</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">FindOptions</span> <span class=\"n\">where</span>\n  <span class=\"n\">stage1</span>       <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n  <span class=\"n\">checkPrivate</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">findCore</span> <span class=\"o\">(</span><span class=\"n\">ϕ</span> <span class=\"o\">:</span> <span class=\"n\">ConstantInfo</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">opts</span> <span class=\"o\">:</span> <span class=\"n\">FindOptions</span> <span class=\"o\">:=</span> <span class=\"o\">{})</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">ConstantInfo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">matches</span> <span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"n\">opts.stage1</span> <span class=\"k\">then</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kd\">constants</span><span class=\"bp\">.</span><span class=\"n\">map₁.foldM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[])</span> <span class=\"n\">check</span>\n  <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kd\">constants</span><span class=\"bp\">.</span><span class=\"n\">map₂.foldlM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">matches</span><span class=\"o\">)</span> <span class=\"n\">check</span>\n\n  <span class=\"n\">where</span>\n    <span class=\"n\">check</span> <span class=\"n\">matches</span> <span class=\"n\">name</span> <span class=\"n\">cinfo</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"n\">opts.checkPrivate</span> <span class=\"bp\">||</span> <span class=\"o\">(</span><span class=\"n\">not</span> <span class=\"bp\">$</span> <span class=\"n\">isPrivateName</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">ϕ</span> <span class=\"n\">cinfo</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">matches.push</span> <span class=\"n\">cinfo</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">matches</span>\n      <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">matches</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">ϕ</span> <span class=\"o\">:</span> <span class=\"n\">ConstantInfo</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">opts</span> <span class=\"o\">:</span> <span class=\"n\">FindOptions</span> <span class=\"o\">:=</span> <span class=\"o\">{})</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">cinfos</span> <span class=\"bp\">←</span> <span class=\"n\">findCore</span> <span class=\"n\">ϕ</span> <span class=\"n\">opts</span>\n  <span class=\"k\">let</span> <span class=\"n\">cinfos</span> <span class=\"o\">:=</span> <span class=\"n\">cinfos.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.name.lt</span> <span class=\"n\">q.name</span><span class=\"o\">)</span>\n  <span class=\"n\">for</span> <span class=\"n\">cinfo</span> <span class=\"k\">in</span> <span class=\"n\">cinfos</span> <span class=\"k\">do</span>\n    <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"{cinfo.name} : {← Meta.ppExpr cinfo.type}\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">All declarations with bool in prefix:</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">find</span> <span class=\"bp\">λ</span> <span class=\"n\">cinfo</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isPrefixOf</span> <span class=\"n\">cinfo.name</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">All declarations whose type is `Less _ _ _ _`:</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">find</span> <span class=\"bp\">λ</span> <span class=\"n\">cinfo</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cinfo.type.isAppOfArity</span> <span class=\"bp\">`</span><span class=\"n\">HasLess.Less</span> <span class=\"mi\">4</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">occursInValue</span> <span class=\"o\">(</span><span class=\"n\">ϕ</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cinfo</span> <span class=\"o\">:</span> <span class=\"n\">ConstantInfo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">cinfo.value</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span>     <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">val.find</span><span class=\"bp\">?</span> <span class=\"n\">ϕ</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">isSome</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">All declarations whose value contain `Decidable.byContradiction`:</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">find</span> <span class=\"bp\">λ</span> <span class=\"n\">cinfo</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">occursInValue</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e.isConstOf</span> <span class=\"bp\">`</span><span class=\"n\">Decidable.byContradiction</span><span class=\"o\">)</span> <span class=\"n\">cinfo</span>\n</code></pre></div>",
        "id": 226862546,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613675082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/270676-lean4/topic/.23print.20prefix/near/225049959\">said</a>:</p>\n<blockquote>\n<p>I implemented my own <code>#print prefix</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">print_prefix</span><span class=\"o\">)</span> <span class=\"s2\">\"#print prefix\"</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"n\">deriving</span> <span class=\"kd\">instance</span> <span class=\"n\">Inhabited</span> <span class=\"n\">for</span> <span class=\"n\">ConstantInfo</span> <span class=\"c1\">-- required for Array.qsort</span>\n\n<span class=\"kd\">@[commandElab print_prefix]</span> <span class=\"kd\">def</span> <span class=\"n\">elabPrintPrefix</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">#print</span> <span class=\"kd\">prefix</span><span class=\"bp\">%$</span><span class=\"n\">tk</span> <span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n    <span class=\"k\">let</span> <span class=\"n\">matches</span> <span class=\"o\">:=</span> <span class=\"n\">env.constants.fold</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">xs</span> <span class=\"n\">name</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">i.getId.isPrefixOf</span> <span class=\"n\">name</span> <span class=\"k\">then</span> <span class=\"n\">xs.push</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n    <span class=\"k\">let</span> <span class=\"n\">matches</span> <span class=\"o\">:=</span> <span class=\"n\">matches.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.1.lt</span> <span class=\"n\">q.1</span><span class=\"o\">)</span>\n    <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">matches</span> <span class=\"k\">do</span>\n      <span class=\"n\">logInfoAt</span> <span class=\"n\">tk</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{name} : {val.type}\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Bool : Type</span>\n<span class=\"cm\">Bool._sizeOf_1 : Bool → Nat</span>\n<span class=\"cm\">Bool._sizeOf_inst : SizeOf Bool</span>\n<span class=\"cm\">Bool.casesOn : {motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t</span>\n<span class=\"cm\">Bool.false : Bool</span>\n<span class=\"cm\">Bool.noConfusion : {P : Sort u} → {v1 v2 : Bool} → v1 = v2 → Bool.noConfusionType P v1 v2</span>\n<span class=\"cm\">Bool.noConfusionType : Sort u → Bool → Bool → Sort u</span>\n<span class=\"cm\">Bool.rec : {motive : Bool → Sort u} → motive false → motive true → (t : Bool) → motive t</span>\n<span class=\"cm\">Bool.recOn : {motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t</span>\n<span class=\"cm\">Bool.toLBool : Bool → LBool</span>\n<span class=\"cm\">Bool.toUInt64 : Bool → UInt64</span>\n<span class=\"cm\">Bool.true : Bool</span>\n<span class=\"cm\">Bool.false.sizeOf_spec : sizeOf false = 1</span>\n<span class=\"cm\">Bool.toLBool._cstage1 : Bool → LBool</span>\n<span class=\"cm\">Bool.toLBool._cstage2 : UInt8 → UInt8</span>\n<span class=\"cm\">Bool.toLBool.match_1 : (motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x</span>\n<span class=\"cm\">Bool.true.sizeOf_spec : sizeOf true = 1</span>\n<span class=\"cm\">Bool.toLBool.match_1._cstage1 : (motive : Bool → Sort u_1) →</span>\n<span class=\"cm\">  (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x</span>\n<span class=\"cm\">Bool.toLBool.match_1._cstage2 : _neutral → _obj</span>\n<span class=\"cm\">Bool.toLBool.match_1._rarg._cstage2 : UInt8 → _obj → _obj → _obj</span>\n<span class=\"cm\">-/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I get an error on <code>let matches</code> saying <code>expected 'rec', identifier or term</code>?</p>",
        "id": 262722966,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1637856585
    },
    {
        "content": "<p>matches is now a keyword, try to replace the name by something else</p>",
        "id": 262723055,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1637856646
    },
    {
        "content": "<p>Question: Is there a way to check the equations introduced when defining a function?</p>\n<p>(something along the lines of Lean 3's <code>#print prefix ...</code>)</p>",
        "id": 296435625,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1661974400
    },
    {
        "content": "<p>Equations are defined on demand, not when defining a function</p>",
        "id": 296440609,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1661976228
    },
    {
        "content": "<p>The meta function for that is <code>Lean.Meta.Match.getEquationsFor</code>, for the sake of completeness</p>",
        "id": 296442570,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1661977062
    },
    {
        "content": "<p>thanks!</p>",
        "id": 296511327,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662001598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/.23print.20prefix/near/262723055\">said</a>:</p>\n<blockquote>\n<p>matches is now a keyword, try to replace the name by something else</p>\n</blockquote>\n<p>Also, <code>commandElab</code> is now <code>command_elab</code>.</p>",
        "id": 322026268,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674040434
    },
    {
        "content": "<p>There is a print prefix implementation in <code>Mathlib.Tactic.PrintPrefix</code></p>",
        "id": 322027199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674040679
    }
]
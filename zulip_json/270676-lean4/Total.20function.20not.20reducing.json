[
    {
        "content": "<p>Hello, everyone. I am making an algebraic effect library.</p>\n<p>Eff.lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Eff</span>\n\n<span class=\"kd\">class</span> <span class=\"kd\">inductive</span> <span class=\"n\">Has</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Has</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- any way to automate this?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Has.zero</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">prev</span><span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">a</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Has.succ</span> <span class=\"n\">prev</span>\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Union</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">_prf</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">ε</span> <span class=\"n\">εs</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Union</span> <span class=\"n\">εs</span> <span class=\"n\">α</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Union</span> <span class=\"o\">[</span><span class=\"n\">IO</span><span class=\"o\">]</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">Union.mk</span> <span class=\"o\">(</span><span class=\"n\">IO.println</span> <span class=\"s2\">\"Hello\"</span><span class=\"o\">)</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Example_Monad</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Union</span> <span class=\"o\">[</span><span class=\"n\">Example_Monad</span><span class=\"o\">,</span> <span class=\"n\">IO</span><span class=\"o\">]</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">Union.mk</span> <span class=\"o\">(</span><span class=\"n\">IO.println</span> <span class=\"s2\">\"Hello\"</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Free</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">_monad</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">_res</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bind</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Pure</span> <span class=\"o\">(</span><span class=\"n\">Free</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"n\">Free.pure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Free.recurbind</span> <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">:</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cont</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">val</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Free.pure</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cont</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Free.bind</span> <span class=\"n\">mval</span> <span class=\"n\">mcont</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Free.bind</span> <span class=\"n\">mval</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Free.recurbind</span> <span class=\"o\">(</span><span class=\"n\">mcont</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"n\">cont</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Bind</span> <span class=\"o\">(</span><span class=\"n\">Free</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"n\">Free.recurbind</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Eff</span> <span class=\"o\">(</span><span class=\"n\">es</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">_res</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Free</span> <span class=\"o\">(</span><span class=\"n\">Union</span> <span class=\"n\">es</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">Eff</span> <span class=\"o\">[</span><span class=\"n\">IO</span><span class=\"o\">]</span> <span class=\"n\">Nat</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">lift</span> <span class=\"o\">[</span><span class=\"n\">has</span><span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">ε</span> <span class=\"n\">εs</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">simple</span><span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eff</span> <span class=\"n\">εs</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">un</span> <span class=\"o\">:</span> <span class=\"n\">Union</span> <span class=\"n\">εs</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Union.mk</span> <span class=\"n\">simple</span>\n  <span class=\"n\">Free.bind</span> <span class=\"n\">un</span> <span class=\"n\">Free.pure</span>\n</code></pre></div>\n<p>However, the function <code>Eff</code> above is not reducing.</p>\n<p>Main.lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Eff</span>\n<span class=\"kn\">open</span> <span class=\"n\">Eff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main_eff</span> <span class=\"o\">:</span> <span class=\"n\">Eff</span> <span class=\"o\">[</span><span class=\"n\">IO</span><span class=\"o\">]</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">lift</span> <span class=\"bp\">$</span> <span class=\"n\">IO.println</span> <span class=\"s2\">\"hello\"</span>\n  <span class=\"n\">lift</span> <span class=\"bp\">$</span> <span class=\"n\">IO.println</span> <span class=\"s2\">\"hello\"</span>\n</code></pre></div>\n<p>error: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Main.lean</span><span class=\"o\">:</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"mi\">2</span>\n\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Bind</span> <span class=\"o\">(</span><span class=\"n\">Eff</span> <span class=\"o\">[</span><span class=\"n\">IO</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 290123675,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658247403
    },
    {
        "content": "<p>How do I make <code>Eff [IO]</code> reduce to <code>Free (Union [IO])</code>?</p>",
        "id": 290124167,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658247592
    },
    {
        "content": "<p>By declaring your definition of <code>Eff</code> as an <code>abbrev</code> or tagging it with <code>@[reducible]</code> (equivalent):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">Eff</span> <span class=\"o\">(</span><span class=\"n\">es</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">_res</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Free</span> <span class=\"o\">(</span><span class=\"n\">Union</span> <span class=\"n\">es</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Eff</span> <span class=\"o\">(</span><span class=\"n\">es</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">_res</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Free</span> <span class=\"o\">(</span><span class=\"n\">Union</span> <span class=\"n\">es</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 290124318,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658247649
    },
    {
        "content": "<p>Where can I find all the @[xxxx] \"pragma\"?</p>",
        "id": 290124357,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658247673
    },
    {
        "content": "<p>Also abbrev/lemma/def stuff</p>",
        "id": 290124391,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658247688
    },
    {
        "content": "<p>I can't find in tutorial</p>",
        "id": 290124406,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658247694
    },
    {
        "content": "<p>In an ideal world we would have a tutorial for all of this already but since we are at a very early stage the answer right now is: by reading other people's code, specifically parts of the Lean compiler and Stdlib as well as Mathlib are sources of good code.</p>\n<p>And the alternative is to just ask here.</p>\n<p>One could argue that mentioning <code>abbrev</code> in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html\">https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html</a> would definitely make sense though since its a very basic thing we do all the time.</p>",
        "id": 290124623,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658247797
    },
    {
        "content": "<p>Regarding types of declarations you have already found most though in main Lean we have</p>\n<ul>\n<li><code>def</code>, <code>abbrev</code></li>\n<li><code>axiom</code></li>\n<li><code>structure</code>, <code>class</code></li>\n<li><code>inductive</code>, <code>class inductive</code></li>\n<li><code>axiom</code></li>\n<li><code>opaque</code></li>\n<li><code>instance</code></li>\n<li><code>theorem</code></li>\n<li><code>example</code></li>\n</ul>\n<p>and that's all, <code>lemma</code> is a syntactic abbreviation for <code>theorem</code> that is added by mathlib</p>",
        "id": 290124846,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658247903
    },
    {
        "content": "<p>To clarify, <code>@[reducible]</code> marks the definition as reducible for typeclass inference specifically. By default typeclass inference avoids reducing because it would make the search very expensive.</p>",
        "id": 290124892,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1658247928
    },
    {
        "content": "<p>what's the different between <code>axiom</code> and <code>opaque</code></p>",
        "id": 290125082,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658248001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> thanks! it works.</p>",
        "id": 290125347,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658248112
    },
    {
        "content": "<p><code>opaque</code> requires you to provide a proof that the type is <code>Inhabited</code> which avoids inconsistencies. <code>axiom</code> can in theory allow you to introduce whatever you want.</p>",
        "id": 290125380,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658248137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290125380\">said</a>:</p>\n<blockquote>\n<p><code>opaque</code> requires you to provide a proof that the type is <code>Inhabited</code></p>\n</blockquote>\n<p>Technically, it now just requires <code>Nonempty</code>, not <code>Inhabited</code> (with caveats):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">@[instance]</span> <span class=\"kd\">axiom</span> <span class=\"n\">Foo.nonempty</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">Foo</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">unsafeFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">unsafeCast</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">unimplFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- errors, noncomputable</span>\n<span class=\"kd\">noncomputable</span> <span class=\"n\">opaque</span> <span class=\"n\">noncomputableFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">@[implementedBy unsafeFoo]</span> <span class=\"n\">opaque</span> <span class=\"n\">implFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">@[extern c inline \"0\"]</span> <span class=\"n\">opaque</span> <span class=\"n\">externFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 290129789,
        "sender_full_name": "Mac",
        "timestamp": 1658249962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290129789\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290125380\">said</a>:</p>\n<blockquote>\n<p><code>opaque</code> requires you to provide a proof that the type is <code>Inhabited</code></p>\n</blockquote>\n<p>Technically, it now just requires <code>Nonempty</code>, not <code>Inhabited</code> (with caveats):</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">@[instance]</span> <span class=\"kd\">axiom</span> <span class=\"n\">Foo.nonempty</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">Foo</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">unsafeFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">unsafeCast</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">unimplFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- errors, noncomputable</span>\n<span class=\"kd\">noncomputable</span> <span class=\"n\">opaque</span> <span class=\"n\">noncomputableFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">@[implementedBy unsafeFoo]</span> <span class=\"n\">opaque</span> <span class=\"n\">implFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">@[extern c inline \"0\"]</span> <span class=\"n\">opaque</span> <span class=\"n\">externFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- works</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I'm new to Lean. I have to remember all these keywords? <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 290141466,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658255477
    },
    {
        "content": "<p>It gets easier over time :p and most of what he showed isn't relevant to everyday Lean don't worry</p>",
        "id": 290142619,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658256010
    },
    {
        "content": "<p>what the different between <code>def</code> and <code>theorem</code>?</p>",
        "id": 290142659,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256029
    },
    {
        "content": "<p>Also, is there something like <code>go</code> or <code>let ([a 1] [b 2]) body</code> in lisp for inline recursion?</p>",
        "id": 290142806,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256106
    },
    {
        "content": "<p>a <code>theorem</code> is always of type <code>P</code> where <code>P : Prop</code>, a <code>def</code> can be whatever.</p>\n<p>inline recursion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">iotaTR</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">go</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r.reverse</span>\n    <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">::</span><span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"n\">go</span> <span class=\"n\">n</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>like this?</p>",
        "id": 290143084,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658256232
    },
    {
        "content": "<p>yes</p>",
        "id": 290143245,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256307
    },
    {
        "content": "<p>How do I turn anything into a string</p>",
        "id": 290143301,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256336
    },
    {
        "content": "<p><code>Sort</code> and <code>Type</code> has any difference?</p>",
        "id": 290143443,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256396
    },
    {
        "content": "<p>we have the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ToString#doc\">docs4#ToString</a> typeclass to turn stuff into strings, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Repr#doc\">docs4#Repr</a> for \"debug representation\" of data structure basically and we have format strings like: <code>s!\"Lalalala {variable} lalalalala\"</code></p>\n<p>There is an infinite hierarchy of types, we have</p>\n<ol>\n<li><code>Prop</code> at the bottom where <code>Prop</code> is equivalent to <code>Sort 0</code></li>\n<li><code>Type</code> which is equivalent to <code>Sort 1</code></li>\n<li><code>Type 1</code> which is equivalent to <code>Sort 2</code><br>\nand so on until infinity. The hierarchy exists in order to avoid self reference paradoxa</li>\n</ol>",
        "id": 290143639,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658256490
    },
    {
        "content": "<p>Prop is Sort 0?</p>",
        "id": 290143771,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256566
    },
    {
        "content": "<p>I don't quite understand</p>",
        "id": 290143786,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256572
    },
    {
        "content": "<p>Yes, they are aliases for each other</p>",
        "id": 290143844,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658256595
    },
    {
        "content": "<p>you can even ask Lean about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 290144012,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658256663
    },
    {
        "content": "<p>What exactly is <code>Prop</code>?</p>",
        "id": 290144133,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256729
    },
    {
        "content": "<p>There is also the difference between computable subset of <code>Type 0</code> and \"incomputable\" <code>Type 0</code></p>",
        "id": 290144224,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256775
    },
    {
        "content": "<p>What exactly is <code>Prop</code>?</p>",
        "id": 290144284,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658256803
    },
    {
        "content": "<p>If <code>x : p</code>, <code>y : p</code>, and <code>p : Prop</code>, then <code>x = y</code> is true by <code>rfl</code> (\"proof irrelevance\") and there are also some special rules for universe levels when <code>Prop</code> is involved (\"impredicativity\" I believe?). It's meant to represent the universe of mathematical Propositions.</p>",
        "id": 290144325,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658256823
    },
    {
        "content": "<p>It is the type of mathematical <code>Prop</code>erties. So everything that we want to express as a logical statement in Lean has type <code>Prop</code>, equalities, inequalities, statements about correctness of certain functions etc.</p>",
        "id": 290144337,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658256827
    },
    {
        "content": "<p>In general if you have some statement <code>p</code> where <code>p : Prop</code> and you provide a value <code>h : p</code> what you have done is create a proof that <code>p</code> does indeed hold, this is the principle of how proofs work in Lean. What Kyle is describing above is a certain special property of <code>Prop</code> in Lean which says that if we have two proofs of the same statement we can always consider those proofs equivalent (it helps with code generation efficiency)</p>",
        "id": 290144560,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658256921
    },
    {
        "content": "<p>I suppose <code>Prop</code>'s special properties were originally motivated by codegen, but it seems to be important for doing classical mathematics (like it's possible to define <code>Subtype</code> with the correct cardinality).</p>",
        "id": 290144887,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658257052
    },
    {
        "content": "<p>There's another thing about <code>Prop</code> that's special, which is its elimination rules -- in contrast to <code>Type</code>, they prevent you from getting data out of a proposition.</p>",
        "id": 290145024,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658257111
    },
    {
        "content": "<p>(It seems people have found <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723\">this diagram</a> to be useful, so here's a link.)</p>",
        "id": 290145077,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658257137
    },
    {
        "content": "<p><a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">This page about foundations</a> mentions everything I've mentioned about <code>Prop</code>.</p>",
        "id": 290145537,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658257318
    },
    {
        "content": "<p>What's the constructor for Prop?<br>\nOnly <code>_=_</code>?</p>",
        "id": 290146447,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658257714
    },
    {
        "content": "<p>No there are lots of ways to construct propositions, just like there are lots of ways to construct types.</p>",
        "id": 290146543,
        "sender_full_name": "Reid Barton",
        "timestamp": 1658257782
    },
    {
        "content": "<p>No you are mis understanding, just like you can declare your own things in <code>Type</code> (<code>Nat</code>, <code>String</code> etc.) you can also declare your own things in <code>Prop</code> via inductive and structure, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc\">docs4#Eq</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le#doc\">docs4#Nat.le</a> etc.</p>",
        "id": 290146551,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658257786
    },
    {
        "content": "<p>So it's a black box?</p>",
        "id": 290146758,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658257876
    },
    {
        "content": "<p>I use Idris more and there is no such thing as <code>Prop</code> in Idris. The equality type <code>Equal a</code> is like <code>inductive</code> in Lean</p>",
        "id": 290146818,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658257914
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Main</span><span class=\"bp\">&gt;</span> <span class=\"o\">:</span><span class=\"n\">doc</span> <span class=\"n\">Equal</span>\n<span class=\"n\">Prelude.Equal</span> <span class=\"o\">:</span> <span class=\"n\">Prec</span>\n<span class=\"n\">data</span> <span class=\"n\">Builtin.Equal</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n  <span class=\"n\">Totality</span><span class=\"o\">:</span> <span class=\"n\">total</span>\n  <span class=\"n\">Visibility</span><span class=\"o\">:</span> <span class=\"n\">public</span> <span class=\"kn\">export</span>\n  <span class=\"n\">Constructor</span><span class=\"o\">:</span> <span class=\"n\">Refl</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">Hints</span><span class=\"o\">:</span>\n    <span class=\"n\">Equivalence</span> <span class=\"n\">ty</span> <span class=\"n\">Equal</span>\n    <span class=\"n\">Euclidean</span> <span class=\"n\">ty</span> <span class=\"n\">Equal</span>\n    <span class=\"n\">PartialEquivalence</span> <span class=\"n\">ty</span> <span class=\"n\">Equal</span>\n    <span class=\"n\">Reflexive</span> <span class=\"n\">ty</span> <span class=\"n\">Equal</span>\n    <span class=\"n\">Symmetric</span> <span class=\"n\">ty</span> <span class=\"n\">Equal</span>\n    <span class=\"n\">Tolerance</span> <span class=\"n\">ty</span> <span class=\"n\">Equal</span>\n    <span class=\"n\">Transitive</span> <span class=\"n\">ty</span> <span class=\"n\">Equal</span>\n</code></pre></div>",
        "id": 290146889,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658257928
    },
    {
        "content": "<p>Our equality type is also an inductive in Lean as I linked above: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc\">docs4#Eq</a> it is just that we gave our mathematical propositions a special place to live in for the reasons outlined above</p>",
        "id": 290147010,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1658257996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290145024\">said</a>:</p>\n<blockquote>\n<p>There's another thing about <code>Prop</code> that's special, which is its elimination rules -- in contrast to <code>Type</code>, they prevent you from getting data out of a proposition.</p>\n</blockquote>\n<p>So <code>Prop</code> don't increase the universe level by one?</p>",
        "id": 290147355,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658258156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515610\">Locria Cyber</span> <a href=\"#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290123675\">said</a>:</p>\n<blockquote>\n<p>Eff.lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Eff</span>\n\n<span class=\"kd\">class</span> <span class=\"kd\">inductive</span> <span class=\"n\">Has</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Has</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- any way to automate this?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Has.zero</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">prev</span><span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">a</span> <span class=\"n\">xs</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Has.succ</span> <span class=\"n\">prev</span>\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Union</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">_prf</span> <span class=\"o\">:</span> <span class=\"n\">Has</span> <span class=\"n\">ε</span> <span class=\"n\">εs</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Union</span> <span class=\"n\">εs</span> <span class=\"n\">α</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Union</span> <span class=\"o\">[</span><span class=\"n\">IO</span><span class=\"o\">]</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">Union.mk</span> <span class=\"o\">(</span><span class=\"n\">IO.println</span> <span class=\"s2\">\"Hello\"</span><span class=\"o\">)</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Example_Monad</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Union</span> <span class=\"o\">[</span><span class=\"n\">Example_Monad</span><span class=\"o\">,</span> <span class=\"n\">IO</span><span class=\"o\">]</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">Union.mk</span> <span class=\"o\">(</span><span class=\"n\">IO.println</span> <span class=\"s2\">\"Hello\"</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Free</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">_monad</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">_res</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bind</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Pure</span> <span class=\"o\">(</span><span class=\"n\">Free</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"n\">Free.pure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Free.recurbind</span> <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">:</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cont</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Free</span> <span class=\"n\">ε</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">val</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Free.pure</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cont</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Free.bind</span> <span class=\"n\">mval</span> <span class=\"n\">mcont</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Free.bind</span> <span class=\"n\">mval</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Free.recurbind</span> <span class=\"o\">(</span><span class=\"n\">mcont</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"n\">cont</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Bind</span> <span class=\"o\">(</span><span class=\"n\">Free</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"n\">Free.recurbind</span>\n</code></pre></div>\n</blockquote>\n<p>In this case, I do need to take data out of <code>Has e es</code> though.</p>\n<p>I need to take stacked monad apart to handle algebraic effects, and <code>_prf</code> in <code>Union.mk</code> is the position that I need to use.</p>\n<p>In a sense, I need to pattern match <code>Has e es</code>, but it's never shown to the user.</p>",
        "id": 290147824,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1658258391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Total.20function.20not.20reducing/near/290143084\">said</a>:</p>\n<blockquote>\n<p>a <code>theorem</code> is always of type <code>P</code> where <code>P : Prop</code>, a <code>def</code> can be whatever.</p>\n</blockquote>\n<p>Technically,  a <code>theorem</code> can be of any type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>\n<p>I believe a <code>theorem</code> is essentially a <code>noncomputable def</code> (just with some syntactic sugar on top) :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span>\n<span class=\"kd\">def</span> <span class=\"n\">addFoo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">error:</span>\n<span class=\"cm\">failed to compile definition, consider marking it as 'noncomputable'</span>\n<span class=\"cm\">because it depends on 'foo', and it does not have executable code</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">foo</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>\n<p>However, Henrik is right in spirit. We generally use a <code>theorem</code> for proposition we want to prove and a <code>def</code> for encoding concepts and generating code. I just enjoy demonstrating edge cases. <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 290191076,
        "sender_full_name": "Mac",
        "timestamp": 1658289406
    },
    {
        "content": "<p>Actually I think it's a <code>noncomputable opaque</code></p>",
        "id": 290191480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1658289867
    }
]
[
    {
        "content": "<p>I'm having some trouble to show a unique typing property of some typed expressions I defined and can't seem to prove it. In the end it boils down to this little theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>it holds just fine propositionally, when <code>{P Q R : Sort 0}</code>. Any ideas?</p>",
        "id": 254329484,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632297639
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 254329853,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632297803
    },
    {
        "content": "<p>Just saw that you assume <code>P</code> to be nonempty, sorry...</p>",
        "id": 254329954,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632297849
    },
    {
        "content": "<p>what was your option without that assumption?</p>",
        "id": 254330036,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632297917
    },
    {
        "content": "<p>It's wrong without the assumption, with <code>P = Empty</code>, <code>Q = PUnit</code> and <code>R = PBool</code></p>",
        "id": 254330195,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632297998
    },
    {
        "content": "<p>ah great, thx.</p>",
        "id": 254330213,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632298015
    },
    {
        "content": "<p>I see. I think that is the crux then. Most likely I'm trying to prove something too strong. thx.</p>",
        "id": 254330569,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632298233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> has marked this topic as resolved.</p>",
        "id": 254330652,
        "sender_full_name": "Notification Bot",
        "timestamp": 1632298305
    },
    {
        "content": "<p>It's definitely not provable without UIP</p>",
        "id": 254330939,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632298447
    },
    {
        "content": "<p>I don't think UIP is relevant, you just can't prove interesting theorems about equality of types, like this kind of type former injectivity. It should be true as a metatheorem, that if you can prove <code>(A -&gt; B) = (C -&gt; D)</code> (with B, D types), then you could also prove <code>A = C</code> and <code>B = D</code>, but I think you can't \"internalise\" this</p>",
        "id": 254333795,
        "sender_full_name": "David Wärn",
        "timestamp": 1632300043
    },
    {
        "content": "<p>Oh, you definitely have to fix either the domain, or the codomain. The set model justifies <code>(1 → 4) = (2 → 2)</code>.</p>",
        "id": 254334808,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632300600
    },
    {
        "content": "<p>Right, but the point is you can't prove it in Lean</p>",
        "id": 254335976,
        "sender_full_name": "David Wärn",
        "timestamp": 1632301153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254333795\">said</a>:</p>\n<blockquote>\n<p>It should be true as a metatheorem, that if you can prove <code>(A -&gt; B) = (C -&gt; D)</code> (with B, D types), then you could also prove <code>A = C</code> and <code>B = D</code>, but I think you can't \"internalise\" this</p>\n</blockquote>\n<p>What do you mean by this? First, in Lean, equality is homogenous, so you can't even write  <code>(A -&gt; B) = (C -&gt; D)</code> where A and C or B and D are distinct types. You would get a type error. Second,  I'm not even sure what it means for functions of heterogenous types to be the equal. Does it mean the have same definition? For example, consider the following functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">botInt</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">botNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>I would think it  could be reasonable to say that <code>botInt = botNat</code>, but that certainly wouldn't imply <code>Int = Nat</code>. So I am just very confused as to what you are getting at.</p>",
        "id": 254397141,
        "sender_full_name": "Mac",
        "timestamp": 1632328466
    },
    {
        "content": "<p>Surely the statement is only a type error if <code>ABCD</code> have incompatible universes?</p>",
        "id": 254415729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632335552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Weel <code>Int</code>, <code>Nat</code>, and <code>Bool</code> are all in <code>Type</code> (i.e., the same universe) and the statement <code>botInt = botNat</code> produces a type error, so I don't think so?</p>",
        "id": 254418781,
        "sender_full_name": "Mac",
        "timestamp": 1632336692
    },
    {
        "content": "<p>Though I guess I should be looking at <code>(Int -&gt; Bool) = (Nat -&gt; Bool)</code>, which does not, in fact, produce a type error.</p>",
        "id": 254419025,
        "sender_full_name": "Mac",
        "timestamp": 1632336784
    },
    {
        "content": "<p>Though, in that case, I am still very confused as to what <code>(Int -&gt; Bool) = (Nat -&gt; Bool)</code> (or any statement of the form <code>(A-&gt; B) = (C -&gt; D)</code>) would even mean. Equality doesn't seem intuitively meaningful for arrows.</p>",
        "id": 254419302,
        "sender_full_name": "Mac",
        "timestamp": 1632336885
    },
    {
        "content": "<p>Outside, I guess, <em>maybe</em> bare-bones syntactic equality, but equality in Lean is generally a richer concept than that.</p>",
        "id": 254419935,
        "sender_full_name": "Mac",
        "timestamp": 1632337131
    },
    {
        "content": "<p>The cardinality model violates the theorem when <code>P = Nat</code>, <code>Q = Nat</code> and <code>R = Nat -&gt; Nat</code></p>",
        "id": 254420326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632337272
    },
    {
        "content": "<p>Also, as somewhat expected, Lean makes no attempt to make such equalities meaningful even simple examples like the following aren't provable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">=</span> <span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- Error</span>\n</code></pre></div>",
        "id": 254420331,
        "sender_full_name": "Mac",
        "timestamp": 1632337275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> , you have the precedence wrong</p>",
        "id": 254420365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632337293
    },
    {
        "content": "<p>Ah</p>",
        "id": 254420403,
        "sender_full_name": "Mac",
        "timestamp": 1632337311
    },
    {
        "content": "<p>Yep that does fix it -- Lean happily proves it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 254420524,
        "sender_full_name": "Mac",
        "timestamp": 1632337353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> is correct, this theorem is independent of lean. The standard model of lean validates it, and the cardinality model falsifies it</p>",
        "id": 254421158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632337640
    },
    {
        "content": "<p>But maybe a better question <span class=\"user-mention\" data-user-id=\"235513\">@Daniel Fabian</span> is how did you get here? What are those typed expressions you defined? It's usually possible to modify the inductive type to avoid this impasse</p>",
        "id": 254421452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632337769
    },
    {
        "content": "<p>ok, here's the full context: I was trying to generalize Leo's technique to use <code>rfl</code> to prove permutations of AC operators are indeed equal.</p>\n<p><a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/ac_expr.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/ac_expr.lean</a></p>\n<p>In this technique, he uses a single type and a single operator. I was trying to generalize it to multiple operators.</p>\n<p>What you do is define an expression type on which you can define some sort order and then you use a <code>denote</code> function to link the expression back to a real value.</p>\n<p>This works quite easily when you only have a single type, because the <code>denote</code> function can be typed as <code>denote : Expr -&gt; a</code>. </p>\n<p>However, if you allow for expressions that are closer to the kinds of expressions, we'd like to use it with, <code>denote</code> would become different. Something like <code>denote : (e : Expr) -&gt;  exprType e</code>. But even defining <code>exprType</code> becomes value-dependent, just one universe higher.</p>\n<p>I've managed to define <code>denote</code> as an inductive predicate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">comm</span>\n    <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">assoc_comm</span>\n    <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Denote</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">{</span><span class=\"n\">value</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Denote</span> <span class=\"o\">(</span><span class=\"n\">Expr.var</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">value</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Denote</span> <span class=\"n\">f₁</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Denote</span> <span class=\"n\">x₁</span> <span class=\"n\">α</span> <span class=\"n\">x₂</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">Denote</span> <span class=\"o\">(</span><span class=\"n\">Expr.app</span> <span class=\"n\">f₁</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">x₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">comm</span> <span class=\"o\">{</span><span class=\"n\">op</span> <span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Denote</span> <span class=\"o\">(</span><span class=\"n\">Expr.comm</span> <span class=\"n\">op</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">op</span>\n  <span class=\"bp\">|</span> <span class=\"n\">assoc_comm</span> <span class=\"o\">{</span><span class=\"n\">op</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"n\">Denote</span> <span class=\"o\">(</span><span class=\"n\">Expr.assoc_comm</span> <span class=\"n\">op</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">op</span>\n</code></pre></div>\n<p>but then I can't really prove anything interesting about it.</p>\n<p>Maybe there's a better way of doing it... Crucially, in order to write down a <code>denote</code> function to turn an <code>Expr</code> into a value, we need to restrict the <code>Expr</code> to such <code>Expr</code> objects that are well-typed. This is obviously trivially true, if your expr is always of one type.</p>\n<p>From an even bigger distance, in order to work on the AC rewrites I'm looking into, I need to normalize terms modulo AC. The paper has a bunch of inference rules but they go under the assumption, that the terms are in <em>canonical form</em>. This entails sorting and flattening all operators before the algorithm can be applied.</p>",
        "id": 254500863,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632386267
    },
    {
        "content": "<p>You could try to put the actual operator functions into the <code>Context</code> (from Leo's file) and represent them with 'operator names' (indexes into the <code>Context</code>'s list of operators) in the <code>Expr</code> tree.</p>\n<p>More generally, though, I think you're right that this technique (proof by reflection) becomes much harder to implement once your expression language is typed (i.e. not all <code>Expr</code>s denote a value of the same type). Then you have two options:</p>\n<ol>\n<li>Bite the bullet and make <code>Expr</code> a typed language. If it is at least simply-typed, you can get away with intrinsic typing: <code>Expr: Ty -&gt; Type</code> where <code>Ty</code> is a syntactic representation of the types you care about (possibly as indexes into the <code>Context</code> again). If <code>Expr</code> is not simply-typed, you can define a typing judgment <code>HasTy : Expr -&gt; Ty -&gt; Prop</code> with <code>denote : (e : Expr) -&gt; HasTy e t -&gt; denoteTy t</code> or something. But none of this is exactly pleasant.</li>\n<li>Make <code>denote</code> partial: <code>denote : (t : Ty) -&gt; Expr -&gt; Option (denoteTy t)</code>. Then <code>denote</code> basically acts as a type checker as well. It's not clear to me whether this is simpler than the first option or whether it just shuffles the complexity around.</li>\n</ol>\n<p>I once gave up on a reflective prover for a very small fragment of category theory, where <code>Expr</code> becomes dependently typed once you want to talk about functors. So if you manage to get somewhere, I'd be very interested.</p>",
        "id": 254506114,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1632389113
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span>, I was trying to do the option 1, where I had a typing judgement. However, I ran into trouble, that your types are effectively also expressions, just one universe higher up. In other words, now I can't type the function's  type. So this technique could at best work for a subset of Lean's type system, I think.</p>\n<p>As for putting things into the <code>Context</code>, I'm not so sure it helps much. That was my initial approach, but now you need to enforce some well-typedness rule about the expression anyway, otherwise you can't look up the operator in the context and it has the correct type.</p>\n<p>When I tried putting it into the <code>Context</code>, the list of operators became a heterogeneous list because each operator has a different type. So you look up the operator by index and you need to make sure that the operator is compatible with the operand. And that's only type correct if the expression is type correct, i.e. you need a well-formedness predicate. Didn't seem to help much, so I made it intrinsic for a while.</p>\n<p>As for the partial function approach, I was thinking about it. But Couldn't imagine how to do that? You more or less want to write something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"n\">f.typeOf</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"n\">and</span> <span class=\"n\">x.typeOf</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f.denote</span> <span class=\"n\">x.denote</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>But obviously you can't ask a type if it's equal. So now types themselves have to become some kind of type expression objects. And if we're not careful, we just end up shifting the problem one universe up...</p>",
        "id": 254507856,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390014
    },
    {
        "content": "<p>Wouldn't it helpf if you didn't use <code>Type</code> but some inductive type <code>Ty</code>?</p>",
        "id": 254508356,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632390281
    },
    {
        "content": "<p>The question then becomes how do you denote Ty into an actual Lean type. Because mind you, you need the return type of the <code>denote</code> function be something like <code>denoteTy Ty</code>. But obviously in Lean, <code>Ty</code> itself can be arbitrarily complex.</p>",
        "id": 254508685,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390481
    },
    {
        "content": "<p>one crazy approach might be to try and <code>denote</code> the actual lean <code>Expr</code> type.</p>",
        "id": 254508915,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390599
    },
    {
        "content": "<p>Could also be <code>{Int, Nat} : set (Type u)</code>, that's got decidable equality?</p>",
        "id": 254508977,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632390610
    },
    {
        "content": "<p>Ah yes, that one. Then your types involved in the context are <code>List Type u</code> and equality = index into the set.</p>",
        "id": 254509084,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390682
    },
    {
        "content": "<p>Tried that one as well. At least we can lift all the types into some universe that's higher than any one concrete expression.</p>",
        "id": 254509121,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254507856\">said</a>:</p>\n<blockquote>\n<p>However, I ran into trouble, that your types are effectively also expressions, just one universe higher up. In other words, now I can't type the function's  type. So this technique could at best work for a subset of Lean's type system, I think.</p>\n</blockquote>\n<p>Yes, you need the types to be represented syntactically, i.e. with their own <code>Ty</code> inductive like Jakob says. Otherwise you're inevitably running into the problem that started this thread, namely that you can't prove anything about <code>Type</code>. You're also right that supporting all Lean types this way is extremely hard; then your <code>Expr</code> language becomes dependently-typed and you run into all the issues associated with that. This is why I think if you need  dependent types, proof by reflection is just bad. If you can restrict to a simple subset of Lean, that should work.</p>\n<blockquote>\n<p>When I tried putting it into the <code>Context</code>, the list of operators became a heterogeneous list because each operator has a different type. So you look up the operator by index and you need to make sure that the operator is compatible with the operand. And that's only type correct if the expression is type correct, i.e. you need a well-formedness predicate. Didn't seem to help much, so I made it intrinsic for a while.</p>\n</blockquote>\n<p>Yes, you need to make sure that the context has objects of the right types for the expression. I think this is inevitable, but not sure.</p>\n<p>Btw, if you need to handle types at different universes, that's a whole other can of worms.</p>",
        "id": 254509189,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1632390737
    },
    {
        "content": "<p>different universe levels don't bother me <em>that</em> much, because I think we can at least lift them  into max u.</p>",
        "id": 254509306,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390826
    },
    {
        "content": "<p>Possibly. I had major trouble with this when I tried it, but I don't remember exactly what the issue was.</p>",
        "id": 254509427,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1632390899
    },
    {
        "content": "<p>So let's take a step back and think for a moment what we'd like to do...</p>",
        "id": 254509459,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390917
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exists</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">or</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 254509566,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390972
    },
    {
        "content": "<p>say this is the goal.</p>",
        "id": 254509575,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390978
    },
    {
        "content": "<p>the normal form would ideally be e.g.</p>",
        "id": 254509588,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632390988
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exists</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">or</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 254509627,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391024
    },
    {
        "content": "<p>i.e. I think it'd be really nice to see through binders.</p>",
        "id": 254509649,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391035
    },
    {
        "content": "<p>and function applications, etc.</p>",
        "id": 254509691,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391073
    },
    {
        "content": "<p>in the presence of binders it gets dependently typed pretty quickly, doesn't it?</p>",
        "id": 254509809,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391130
    },
    {
        "content": "<p>I wonder if you could just ignore the typing completely?</p>",
        "id": 254510135,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632391302
    },
    {
        "content": "<p>intriguing. You probably can for purposes of sorting.</p>",
        "id": 254510223,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391341
    },
    {
        "content": "<p>but I have no idea, how we'd turn an expression into a value in the term language.</p>",
        "id": 254510253,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391362
    },
    {
        "content": "<p>The new term still has the broad structure of the input term, that could help</p>",
        "id": 254510428,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1632391466
    },
    {
        "content": "<p>also, I just had an idea...</p>",
        "id": 254510459,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391490
    },
    {
        "content": "<p>what if we had something like <code>Expr u</code> where <code>u</code> is the max universe of subexpressions.</p>",
        "id": 254510508,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391511
    },
    {
        "content": "<p>then <code>exprTy : Expr u -&gt; Sort (u + 1)</code> and <code>denote : (e : Expr u) -&gt; exprTy e</code></p>",
        "id": 254510645,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391567
    },
    {
        "content": "<p>or something like that anyway</p>",
        "id": 254510654,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391577
    },
    {
        "content": "<p>If you just want to go under binders etc, I would do that with a metaprogram. You have to write one anyway, to convert Lean <code>Expr</code> into your <code>Expr</code>. This metaprogram can easily(TM) construct the necessary boilerplate to go from <code>2 + z = z + 2</code> and <code>1 + z + 1 = z + 1 + 1</code>,  which are the outputs of your reflective solver, to your original goal.</p>",
        "id": 254511129,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1632391844
    },
    {
        "content": "<p>yeah, we would combine it with the simplifier to go through binders.</p>",
        "id": 254511236,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391916
    },
    {
        "content": "<p>so what? a quantifier-free subset of lean?</p>",
        "id": 254511306,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632391944
    },
    {
        "content": "<p>otoh, function symbols in lean surely can be dependently typed.</p>",
        "id": 254511454,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632392035
    },
    {
        "content": "<p>but then again AC operators aren't.</p>",
        "id": 254511574,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632392090
    },
    {
        "content": "<p>If you want only AC reasoning, I would restrict to:</p>\n<ul>\n<li>a finite collection of types <code>α, β, ...</code></li>\n<li>a finite collection of operators <code>f : α -&gt; α -&gt; α, g : γ -&gt; γ -&gt; γ, ...</code></li>\n<li>a finite collection of values <code>x : α, y : γ, ...</code></li>\n</ul>\n<p>Then your expressions are simply-typed. Setting this up is still not trivial because you have typed expressions and a typed context. But that should be doable.</p>",
        "id": 254511928,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1632392319
    },
    {
        "content": "<p>ok, cool, I'll try to do that. It'd make the proof certificates much shorter and more elegant!</p>",
        "id": 254512001,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632392388
    },
    {
        "content": "<p>just a question, though <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> if you say types <code>\\alpha, \\beta, ...</code>what do you want to do with them? If you allow arbitrary types, then function application would still be dependently typed. If you only allow applying the operators, how would you move from <code>\\alpha</code> to <code>\\gamma</code>? What am I missing?</p>",
        "id": 254513449,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632393212
    },
    {
        "content": "<p>or are you proposing that you allow functions which are closed under (non-dependent) arrows?</p>",
        "id": 254513656,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632393314
    },
    {
        "content": "<p>I think this can be done, but I'm unclear on what you actually want to do. AC reasoning is inherently unityped, unless you have a family of related operators with rules like <code>f x (g y z) = i (h x y) z</code></p>",
        "id": 254516133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632394712
    },
    {
        "content": "<p>What is the \"type signature\" of the problem statement?</p>",
        "id": 254516333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632394815
    },
    {
        "content": "<p>But I also think that this is a bad idea and a metaprogram will be faster to build a proof, faster to check, and simpler to understand.</p>",
        "id": 254516444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632394866
    },
    {
        "content": "<p>the big goal is to integrate reasoning modulo AC with the Lean simplifier.</p>",
        "id": 254516589,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632394943
    },
    {
        "content": "<p>the problem statement is really anything we want it to be. As we are successful if <code>simp</code> can handle AC rewriting. We could build the entire proof completely from scratch by manually applying the AC lemmas. But that would make the proof substantially bigger.</p>",
        "id": 254516738,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632395036
    },
    {
        "content": "<p>this whole rfl-based proof certificate is just one bit of the bigger picture. If we can prove that the canonical form is equal to the one that is in the context, that's useful. Since constructing the proof for the permutation using reflection is easy.</p>",
        "id": 254516923,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632395118
    },
    {
        "content": "<p>But ultimately it's not a hard requirement.</p>",
        "id": 254516936,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632395128
    },
    {
        "content": "<p>I think you should just sort the atoms and defer the proof until you know you need to produce it</p>",
        "id": 254516980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395155
    },
    {
        "content": "<p>A heavy <code>rfl</code> is not a short proof</p>",
        "id": 254517078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395196
    },
    {
        "content": "<p>it just prints like one</p>",
        "id": 254517086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395206
    },
    {
        "content": "<p>and you'd keep carrying around exactly what operations you did to the expr whilst sorting so you can reconstruct a proof?</p>",
        "id": 254517146,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632395245
    },
    {
        "content": "<p>You can, but you don't need to, if you know they are permutations (and you can quickly work out what the permutation is) you can reconstruct the proof</p>",
        "id": 254517265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395294
    },
    {
        "content": "<p>If the atoms are almost-defeq then determining the permutation might be expensive, so you probably want to make that part symbolic</p>",
        "id": 254517323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395340
    },
    {
        "content": "<p>but that's all in the internal workings of the tactic, it's something like a <code>List (Nat x Expr)</code> to represent the permutation</p>",
        "id": 254517395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395392
    },
    {
        "content": "<p>or I guess <code>List Nat</code> with a <code>List Expr</code> on the side</p>",
        "id": 254517440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395403
    },
    {
        "content": "<p>the AC axioms only let us swap 2 operands at a time, right? So you effectively have to do a bubble sort.</p>",
        "id": 254517460,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632395408
    },
    {
        "content": "<p>Incidentally, I <a href=\"https://cs.stackexchange.com/questions/105250/minimum-number-of-tree-operations-to-normalize-a-labeled-tree\">asked a question</a> about this some time ago, with exactly this application in mind. It can be done in O(n log n)</p>",
        "id": 254517513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395447
    },
    {
        "content": "<p>interesting</p>",
        "id": 254517925,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632395692
    },
    {
        "content": "<p>But more importantly, you want to make sure that the cost for small n (say n = 3 to 5) is small, and here the proof directly from AC axioms is shorter than reflection, even if you consider <code>rfl</code> a short proof</p>",
        "id": 254517952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632395711
    },
    {
        "content": "<p>for 3-5 bubble sort is probably close to as good as the algorithm in the example, no?</p>",
        "id": 254518460,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632396061
    },
    {
        "content": "<p>In general, the tree of course wouldn't be a perfect tree, but rather something inbalanced</p>",
        "id": 254518500,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632396090
    },
    {
        "content": "<p>for matching purposes, we could also define an internal representation to find an appropriate AC substitution and then try to prove equivalence.</p>",
        "id": 254518664,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632396193
    },
    {
        "content": "<p>if we did that, the sorting would be just done on top of that data structure.</p>",
        "id": 254518684,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632396218
    },
    {
        "content": "<p>Essentially a multi-set per AC operator, or something similar.</p>",
        "id": 254518706,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1632396234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254513449\">said</a>:</p>\n<blockquote>\n<p>just a question, though <span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> if you say types <code>\\alpha, \\beta, ...</code>what do you want to do with them? If you allow arbitrary types, then function application would still be dependently typed. If you only allow applying the operators, how would you move from <code>\\alpha</code> to <code>\\gamma</code>? What am I missing?</p>\n</blockquote>\n<p>Oh right, the whole thing is actually unityped. Then everything is very simple. (This is what they always show in proof by reflection tutorials. :))</p>",
        "id": 254519275,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1632396567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235513\">Daniel Fabian</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Proving.20equality.20from.20arrow.20equality/near/254518460\">said</a>:</p>\n<blockquote>\n<p>for 3-5 bubble sort is probably close to as good as the algorithm in the example, no?</p>\n</blockquote>\n<p>I think that bubble sort / any obvious sort is fine for the near term. It's a relatively self contained thing and the issues only come in extreme examples, so improvements over a baseline implementation are a low priority</p>",
        "id": 254519506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632396719
    },
    {
        "content": "<p>IIRC lean 3 simp does it just by doing ordered rewrite with <code>add_comm, add_assoc, add_left_comm</code></p>",
        "id": 254519764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632396862
    },
    {
        "content": "<p>which I think results in insertion sort</p>",
        "id": 254519807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632396901
    }
]
[
    {
        "content": "<p>I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">KrivineInstruction</span>\n<span class=\"bp\">|</span> <span class=\"n\">Access</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Grab</span> <span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Push</span> <span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">continuation</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span>\n\n<span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">KrivineClosure</span>\n<span class=\"bp\">|</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">KrivineEnv</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">KrivineEnv</span>\n<span class=\"bp\">|</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">closures</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The adhoc definition of <code>KrivineXXX.term</code> looks a bit strange, but I'm not sure if it's related to missing features or if I'm not aware of a better way to do this kind of these definitions.</p>\n<p>I would just like to have <code>KrivineClosure := KrivineInstruction × KrivineEnv</code> and <code>KrivineEnv := List KrivineClosure</code> if that's possible.</p>",
        "id": 236907622,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1619818601
    },
    {
        "content": "<p>I would make one inductive type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">KrivineClosure</span>\n<span class=\"bp\">|</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then <code>def KrivineEnv := List KrivineClosure</code>. That way <code>KrivineClosure.term</code> has the type <code>KrivineInstruction -&gt; KrivineEnv -&gt; KrivineClosure</code></p>",
        "id": 236913500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619822585
    },
    {
        "content": "<p>They can't both be defs because that would be an infinitely large type</p>",
        "id": 236913526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619822615
    },
    {
        "content": "<p>Makes sense <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I have gone with your definition, but that might be a <a class=\"stream\" data-stream-id=\"236449\" href=\"/#narrow/stream/236449-Program-verification\">#Program verification</a> question, if I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">KrivineInstruction</span>\n<span class=\"bp\">|</span> <span class=\"n\">Access</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Grab</span> <span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Push</span> <span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">continuation</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">KrivineClosure</span>\n<span class=\"bp\">|</span> <span class=\"n\">pair</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">KrivineEnv</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span>\n<span class=\"kd\">def</span> <span class=\"n\">KrivineStack</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">KrivineEnv.depth</span><span class=\"o\">:</span> <span class=\"n\">KrivineEnv</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">KrivineClosure.pair</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"o\">::</span> <span class=\"n\">closures</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.max</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">depth</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"n\">closures</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I do understand that <code>depth</code> cannot be defined because structural recursion uses the recursive type and do not care about what is really in.<br>\nAt the same time, I do not have the feeling I can solve this by well-founded recursion, as this is the predicate I would like to use to define wf-recursion for other similar functions.</p>\n<p>Also, <code>e</code> looks \"smaller\" than the argument, as it is syntaxically smaller.</p>\n<p>In that case, how are these functions even definable?</p>",
        "id": 236955611,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1619864262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"262143\">Ryan Lahfa</span> <a href=\"#narrow/stream/270676-lean4/topic/nice.20way.20to.20define.20mutually.20inductive.20types/near/236955611\">said</a>:</p>\n<blockquote>\n<p>Makes sense <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> I have gone with your definition, but that might be a <a class=\"stream\" data-stream-id=\"236449\" href=\"/#narrow/stream/236449-Program-verification\">#Program verification</a> question, if I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">KrivineInstruction</span>\n<span class=\"bp\">|</span> <span class=\"n\">Access</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Grab</span> <span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Push</span> <span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">continuation</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">KrivineClosure</span>\n<span class=\"bp\">|</span> <span class=\"n\">pair</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">KrivineInstruction</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">KrivineEnv</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span>\n<span class=\"kd\">def</span> <span class=\"n\">KrivineStack</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">KrivineClosure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">KrivineEnv.depth</span><span class=\"o\">:</span> <span class=\"n\">KrivineEnv</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">KrivineClosure.pair</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"o\">::</span> <span class=\"n\">closures</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.max</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">depth</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"n\">closures</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I do understand that <code>depth</code> cannot be defined because structural recursion uses the recursive type and do not care about what is really in.<br>\nAt the same time, I do not have the feeling I can solve this by well-founded recursion, as this is the predicate I would like to use to define wf-recursion for other similar functions.</p>\n<p>Also, <code>e</code> looks \"smaller\" than the argument, as it is syntaxically smaller.</p>\n<p>In that case, how are these functions even definable?</p>\n</blockquote>\n<p>So I answer myself, it's possible to use <code>rec</code>/<code>induction</code> to define the data:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">codegen</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">KrivineClosure.depth</span><span class=\"o\">:</span> <span class=\"n\">KrivineClosure</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">closure</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">closure</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">pair</span> <span class=\"n\">i</span> <span class=\"n\">env</span> <span class=\"n\">depth_env</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">depth_env</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span> <span class=\"n\">head_depth</span> <span class=\"n\">tail_depth</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Nat.max</span> <span class=\"n\">head_depth</span> <span class=\"n\">tail_depth</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>My question are now:</p>\n<p>(a) is there an issue related to the lack of codegen for recursors?<br>\n(b) is there a better way to do this or a more \"proper\" way?<br>\n(c) where can I read more about recursors and such things?</p>",
        "id": 237469152,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1620208658
    },
    {
        "content": "<p>I haven't looked closely at how v4 handles the recursors for nested inductives, but if you can use the new generated one to define a Prop-valued less than relation on KrivineEnv you should be able to define recursive functions using Acc.rec. That's how the non-structural recursion in core is defined.<br>\nMario's paper obviously has information on the formation of recursors for regular inductive types. For nested inductives the only source is probably the kernel code.</p>",
        "id": 237633607,
        "sender_full_name": "Chris B",
        "timestamp": 1620295292
    },
    {
        "content": "<p>False alarm, I just tried it and didn't realize you can't even use the Acc recursor yet. It returns an error about not yet generating code for Acc.rec</p>",
        "id": 237726064,
        "sender_full_name": "Chris B",
        "timestamp": 1620334199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/270676-lean4/topic/nice.20way.20to.20define.20mutually.20inductive.20types/near/237726064\">said</a>:</p>\n<blockquote>\n<p>False alarm, I just tried it and didn't realize you can't even use the Acc recursor yet. It returns an error about not yet generating code for Acc.rec</p>\n</blockquote>\n<p>You can do <code>set_option codegen false in …</code> and provide an unsafe definition in fact.</p>",
        "id": 237726235,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1620334260
    },
    {
        "content": "<p>Which is what I have done to define <code>depth</code> and I fled to WF definitions.</p>",
        "id": 237726273,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1620334279
    },
    {
        "content": "<p>I saw that in your earlier attempts, I thought this might provide an escape hatch since Acc was already implemented and wellFounded.fix is used in core without any annotations.</p>",
        "id": 237726820,
        "sender_full_name": "Chris B",
        "timestamp": 1620334505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/270676-lean4/topic/nice.20way.20to.20define.20mutually.20inductive.20types/near/237633607\">said</a>:</p>\n<blockquote>\n<p>Mario's paper obviously has information on the formation of recursors for regular inductive types. For nested inductives the only source is probably the kernel code.</p>\n</blockquote>\n<p>Actually my paper borrows heavily from Dybjer, <a href=\"http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf\">Inductive Families</a>, which was also the official source for the lean implementation. That paper covers nested and mutual inductives as well, although mine doesn't. (However my paper covers universes and large elimination, unlike Dybjer, who was working in a generic dependent type theory without universes.)</p>",
        "id": 237750900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620347555
    },
    {
        "content": "<p>Nice, I didn't know that paper also covered nested inductives.</p>",
        "id": 237850983,
        "sender_full_name": "Chris B",
        "timestamp": 1620404706
    },
    {
        "content": "<p>Actually I lied, it covers mutual inductives but not nested inductives. (There are also entire \"Omitted.\" sections in the definition of mutual inductives.) From looking at the kernel terms produced by a nested inductive, it's clearly just doing the same as the analogous mutual inductive where you mutually define all the inductives and nested versions; the only technically interesting thing that happens is that if you have <code>| mk : list T -&gt; T</code> then you don't just get <code>list_T</code> and <code>T</code> defined mutually, you actually get a recursor that talks about <code>list T</code> and <code>list_T</code> is not created. So we are adding new axioms on an existing inductive type which is just slightly questionable. (It can still be modeled by using less nominal types.)</p>",
        "id": 237865080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1620410302
    }
]
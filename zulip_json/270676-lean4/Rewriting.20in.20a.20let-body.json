[
    {
        "content": "<p>Is it possible to rewrite in the <em>value</em> (not the type) of a <code>let</code> binding in the local context? I couldn't get this to work in Lean 3 either. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">1</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> tactic 'rewrite' failed, did not find instance of the pattern in the target expression</span>\n<span class=\"cm\">    f 1</span>\n<span class=\"cm\">  x : ℕ → ℕ := f 1</span>\n<span class=\"cm\">  this : f 1 = fun x =&gt; 1 + x</span>\n<span class=\"cm\">  ⊢ f 1 2 = f 2 1 -/</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 286851485,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655771864
    },
    {
        "content": "<p>Could you elaborate on your use case a bit more (i.e., what your goal is)? Is there a reason why a solution like the following is insufficient?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">1</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  x : Nat → Nat := f 1</span>\n<span class=\"cm\">  h : x = fun x =&gt; 1 + x</span>\n<span class=\"cm\">  this : f 1 = fun x =&gt; 1 + x</span>\n<span class=\"cm\">  ⊢ f 1 2 = f 2 1</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 286852106,
        "sender_full_name": "Mac",
        "timestamp": 1655772610
    },
    {
        "content": "<p>I am using let-bindings in the context to represent auxiliary functions in a tactic which will then be encoded by a further tactic. However I want to control how this encoding goes by rewriting the the bodies of these auxiliaries. Basically I can go with the let-equals solution you propose or even a custom data structure, it's just that using the let-bodies was very convenient, which is why I wondered if I can rewrite in them.</p>",
        "id": 286854441,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1655775112
    },
    {
        "content": "<p>I would be also quite interested in doing the rewrites directly in the let bindings. My application would be to do source code transformation in the tactic mode.</p>\n<p>Currently I'm doing something vaguely similar and to do the rewriting I encode the value in the type.<br>\nDefine an auxiliary type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Then you can have the value <code>f 1</code> in the type <code>Aux (f 1)</code> and do the rewrites.</p>\n<p>An example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"kd\">def</span> <span class=\"n\">aux</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Aux</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">enter</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span>      <span class=\"c1\">-- desired rewrite</span>\n    <span class=\"n\">apply</span> <span class=\"n\">aux</span> <span class=\"n\">_</span> <span class=\"c1\">-- finish definition of Aux</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">test_rewrite</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"gr\">admit</span>\n</code></pre></div>\n<p>So the general idea is to instead of writing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;</span><span class=\"n\">x</span> <span class=\"kd\">definition</span><span class=\"bp\">&gt;</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;</span><span class=\"n\">x</span> <span class=\"n\">rewrite</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Aux</span> <span class=\"bp\">&lt;</span><span class=\"n\">x</span> <span class=\"kd\">definition</span><span class=\"bp\">&gt;</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;</span><span class=\"n\">x</span> <span class=\"n\">rewrite</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">aux</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>That is ugly though. We can define a macro of the form <code>term \"rewrite_by\" convSeq</code> and write <code>((f 1) rewrite_by rw[h])</code> instead.</p>\n<p>Full code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean.Parser.Tactic.Conv</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">term</span> <span class=\"s2\">\"rewrite_by\"</span> <span class=\"n\">convSeq</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"n\">rewrite_by</span> <span class=\"bp\">$</span><span class=\"n\">rw</span><span class=\"o\">:</span><span class=\"n\">convSeq</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"o\">(</span><span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">enter</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"bp\">$</span><span class=\"n\">rw</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">apply</span> <span class=\"n\">aux</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Aux</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">f'</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">f'</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f'</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">enter</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">f'</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">rewrite_by</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">test_rewrite</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"gr\">admit</span>\n</code></pre></div>",
        "id": 286892649,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1655806592
    },
    {
        "content": "<p>(I have modified the statement from <code>f 1 = fun x =&gt; 1 + x</code> to <code>f 1 = fun x =&gt; x + 1</code> such that it is not solvable by <code>rfl</code> and the <code>test_rewrite</code> fails if the rewrite <code>rw[h]</code>is not done)</p>",
        "id": 286892897,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1655806772
    },
    {
        "content": "<p>The unfortunate thing is that the resulting definition of <code>x</code> looks rather ugly in the goal view:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Aux</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aux</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Not sure what to do about it. To make sense of this definition I would suggest looking at the intermediate stages of(paste it to the code above)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">test_rewrite</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Eq.mpr</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">aux</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 286893416,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1655807149
    },
    {
        "content": "<p>Perhaps we should default <code>pp.proofs.withType</code> to false in the info view, assuming hover gives the same information</p>",
        "id": 286894516,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655807880
    },
    {
        "content": "<p>I do not have a strong opinion about that and I do not think this is a strong case for or against. For example, if you make the <code>a</code> argument in <code>aux</code> implicit then the the goal view shows <code>x : Aux (f 1) := Eq.mpr _ aux</code>. You completely loose the information about the actual definition <code>fun x =&gt; x + 1</code>.</p>\n<p>I think this case needs a custom tailored solution to force Lean to show something nice an useful.</p>",
        "id": 286895587,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1655808592
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I cannot reproduce your error, but I will create a Dockerfile that runs the entire pipeline to preempt this kind of issue.</p>",
        "id": 224462996,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1611923042
    },
    {
        "content": "<p>Already started working on a Nix build and filling a binary cache at <a href=\"https://app.cachix.org/cache/port34\">https://app.cachix.org/cache/port34</a></p>",
        "id": 224467503,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1611925726
    },
    {
        "content": "<p>I am curious how far we can push heuristic delaboration. Suppose we are able to delaborate into:</p>\n<ul>\n<li>terms (when reasonably small)</li>\n<li>have/let</li>\n<li>calc</li>\n<li>induction</li>\n<li>cases</li>\n<li>rewrite</li>\n<li>apply</li>\n<li>simp</li>\n<li>decision procedures (e.g. ring)</li>\n<li>...?</li>\n</ul>\n<p>Might these proofs be inspectable/maintainable enough to obviate the need for manual proof-porting? How many other tactics provide significant compression of the proof terms? Note: even this level of delaboration may be hard for various reasons, and may require a lot of search.</p>",
        "id": 224827952,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612240346
    },
    {
        "content": "<p>There could be advantages to automatically producing structured proofs. I personally find it difficult to maintain/port proofs that use e.g. <code>refine</code> or <code>apply</code> without braces around the subgoals.</p>",
        "id": 224828381,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612240918
    },
    {
        "content": "<p>we have a style guide about that, so it shouldn't come up often</p>",
        "id": 224828981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612241697
    },
    {
        "content": "<p>One way to get tactic proofs to delaborate is to have the tactic put a tag in the theorem saying the tactic's name and arguments. This is a little tricky in lean 3 though because the natural language for that is to put <code>name</code> and <code>expr</code> in the term, in identity-function annotations, but <code>expr</code> at least is <code>meta</code> and so can't appear in most proof terms</p>",
        "id": 224829179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612241889
    },
    {
        "content": "<p>Yeah, I think focusing on subgoals is probably the least of the worries here. Not that all of mathlib does it perfectly, but it's one of the stricter style rules we have because of the obvious maintenance benefits</p>",
        "id": 224851016,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612260823
    },
    {
        "content": "<p>The tagging tactics idea is interesting, but it sounds like it would end up a weird hybrid of porting proof terms and porting surface syntax. Would it be easier to hack the Lean 3 parser to output Lean 4-ish proof scripts?</p>",
        "id": 224851170,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612260899
    },
    {
        "content": "<p>I guess delaboration would work best at the type level, ignoring proofs. What are the prospects of generating file skeletons automatically with this? For a manual porting effort it would still be really useful to have an outline of what you need to update.</p>",
        "id": 224851359,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612260997
    },
    {
        "content": "<p>Automatic delaboration of proofs (= converting proof terms into readable tactic scripts) is definitely an interesting topic that deserves research, and it would also be useful independently of the mathlib porting process.<br>\nThat said, I believe you can divide mathlib proofs into roughly two camps: 1) one-line term mode proofs, 2) long tactic proofs.  Even the Lean 3 delaborator is good enough for (1) typically.  But (2) uses a large number of fragile tactics: I would expect the Lean 4 versions of <code>ring</code>, etc. to have slightly different behavior.  Their behavior has changed often enough already.  There will always be a boundary on which proofs can be automatically ported, and I don't think we can shift this boundary very far.<br>\nI'm not sure how desirable it is to delaborate Lean 3 code for a whole module (what Rob suggested I believe), given how much of mathlib is automatically generated: there's automatically generated lemmas (equation lemmas, simps), automatic copy&amp;paste (to_additive), and more (alias, ...).  Not to speak of comments, etc.</p>",
        "id": 224853958,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612262466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/224853958\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how desirable it is to delaborate Lean 3 code for a whole module (what Rob suggested I believe), given how much of mathlib is automatically generated: there's automatically generated lemmas (equation lemmas, simps), automatic copy&amp;paste (to_additive), and more (alias, ...).  Not to speak of comments, etc.</p>\n</blockquote>\n<p>I'm thinking of this as a first pass before manual effort. Suppose you use mathport to make a Lean 4 <code>target.olean</code> from a Lean 3 <code>source.olean</code>. The goal is now to write a Lean 4 <code>target.lean</code> with the same interface as the olean. Delaborating the definitions and theorem statements gives you this, so you know exactly what you need to fill in. You're right that a lot of stuff is created automatically and we'd have to detect this and look for overlaps, but that doesn't sound unreasonable. Things like <code>simps</code> and <code>to_additive</code> leave behind trails that we can automatically detect (or we can add tags if necessary).</p>",
        "id": 224905069,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612286590
    },
    {
        "content": "<p>Semantic comments (doc strings) should be part of the delaboration, but yeah, other comments can't be. It would also be hard to capture sections, namespaces, variables, etc.</p>",
        "id": 224905281,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612286659
    },
    {
        "content": "<p>So this doesn't let you ignore <code>source.lean</code> completely.</p>",
        "id": 224905337,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612286685
    },
    {
        "content": "<p>Actually, namespaces could get in the way here. If things get delaborated in the root namespace I guess all names will be fully specified, which would be ugly.</p>",
        "id": 224905577,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1612286769
    },
    {
        "content": "<p>Now that we can access imported Lean 3 notations in Lean 4, I believe that parsing mathlib as-is in Lean 4 is definitely feasible. Even if it's just 95% of mathlib that can be parsed, that should give you a much better base to build on (i.e. getting the file to actually <em>elaborate</em>) than a delaborated skeleton I think.</p>",
        "id": 224905993,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1612286937
    },
    {
        "content": "<p>Of course this should then be translated to \"actual\" Lean 4 syntax so mathlib doesn't end up with some weird Lean 4 accent. This part is not quite as clear to me yet because we haven't built enough tooling in the direction of refactorings so far, but it sounds at least as feasible as any delaboration approach to me.</p>",
        "id": 224906549,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1612287146
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> What do think is the best way to do that?  Can we just add macros for the Lean 3 syntax?  Is there anything that would be hard to do this way?</p>",
        "id": 224906620,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612287175
    },
    {
        "content": "<p>As far as refactoring goes, I hope that the Lean 4 server gets \"quickfix\" support at some point.  Getting rid of the compat layer should just be a question of hitting ctrl-. maniacally then.</p>",
        "id": 224906822,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612287253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/224906620\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> What do think is the best way to do that?  Can we just add macros for the Lean 3 syntax?  Is there anything that would be hard to do this way?</p>\n</blockquote>\n<p>For notations the exporter can't handle, user-defined parsers, and tactics (at least their syntax), it really should be as easy as that, yeah. That leaves built-in syntax that is different from Lean 4 as the hardest part. It might be necessary/easier to use the internal <code>Lean.Parser</code> there in favor of the simpler <code>syntax</code> command.</p>",
        "id": 224907571,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1612287569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/224906822\">said</a>:</p>\n<blockquote>\n<p>As far as refactoring goes, I hope that the Lean 4 server gets \"quickfix\" support at some point.  Getting rid of the compat layer should just be a question of hitting ctrl-. maniacally then.</p>\n</blockquote>\n<p>I do hope we get there one day :) . But apart from editor integration, the part I wasn't sure about yet is that you either need good tooling for translating syntax while preserving/adapting formatting, or you need a great code formatter you can just run on the unformatted result. We have some initial work on both parts, but there's still lots of work to be done.</p>",
        "id": 224908096,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1612287834
    },
    {
        "content": "<p>I don't think you need to worry about formatting for an MVP.  Just having the editor integration set up is enough to be very useful.  People are ecstatic about \"Try this:\" in Lean 3, and that's way less sophisticated.</p>",
        "id": 224908694,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612288103
    },
    {
        "content": "<p>Yeah. I definitely want to avoid a \"parse Lean 3 syntax now, translate to Lean 4 syntax later\" scenario where the \"later\" never happens. But if we translate &amp; pretty-print immediately, then fix up the formatting while doing the actual porting, the current pretty printer might not be too far from being usable for that.</p>",
        "id": 224913289,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1612290038
    },
    {
        "content": "<p>To give an idea of what the output currently looks like, this is a pretty-printed part of <code>Prelude.lean</code>: <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/Reformat.lean.expected.out\">https://github.com/leanprover/lean4/blob/master/tests/lean/Reformat.lean.expected.out</a><br>\nOnly comments are preserved, all indentation &amp; line breaks are from the pretty printer</p>",
        "id": 224914166,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1612290405
    },
    {
        "content": "<p>FYI I have been collecting issues at <a href=\"https://github.com/dselsam/mathport/issues\">https://github.com/dselsam/mathport/issues</a>. Currently there are three open requests for backports:</p>\n<ul>\n<li><a href=\"https://github.com/dselsam/mathport/issues/3\">https://github.com/dselsam/mathport/issues/3</a> don't rely on inductive result types getting unfolded<ul>\n<li>after this, we will be able to build the porting tool using <code>lean4:master</code></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dselsam/mathport/issues/7\">https://github.com/dselsam/mathport/issues/7</a> don't toggle reducibility after-the-fact<ul>\n<li>this is the source of many TC failures and also many perf problems (e.g. unfolding <code>real.pi</code> for no reason)</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dselsam/mathport/issues/4\">https://github.com/dselsam/mathport/issues/4</a> make sure all classes are structures (or abbreviations of structures), not definitions<ul>\n<li>this causes many TC failures</li>\n</ul>\n</li>\n</ul>\n<p>Are these backports acceptable? Progress on the porting is mostly bottlenecked on the backports, and also on general rising-tide-lifts-all-ships Lean4 features/tactics/ergonomics.</p>",
        "id": 224953268,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612309114
    },
    {
        "content": "<p>I'm on the fence about <a href=\"https://github.com/leanprover-community/mathlib/issues/3\">#3</a>. I think there are at least a few examples where we want the constants to have the stated types, and it sounds like Leo's suggestion will make the terms have the wrong type, which will cause issues with typeclass search down the line</p>",
        "id": 224953538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612309289
    },
    {
        "content": "<p>Are there any <code>@[class] def</code> in the lean 3 core library?</p>",
        "id": 224953674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612309360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/224953674\">said</a>:</p>\n<blockquote>\n<p>Are there any <code>@[class] def</code> in the lean 3 core library?</p>\n</blockquote>\n<p>Not according to grep.</p>",
        "id": 224953846,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612309461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/224953538\">said</a>:</p>\n<blockquote>\n<p>I'm on the fence about <a href=\"https://github.com/leanprover-community/mathlib/issues/3\">#3</a>. I think there are at least a few examples where we want the constants to have the stated types, and it sounds like Leo's suggestion will make the terms have the wrong type, which will cause issues with typeclass search down the line</p>\n</blockquote>\n<p>The example that Daniel posted on the github thread can be \"fixed\" by hand. <br>\nNote that we only need to unfold definitions  in an inductive declaration <code>C</code> in the following two cases :<br>\n1- The header is not producing a <code>Type/Prop</code><br>\n2- The constructor type contains an application of the form <code>f ... (C ...) ...</code> and <code>f</code> is a definition.  </p>\n<p>How often this happens in mathlib? Case 1 seems quite rare. I can see Case 2 occurring in mathlib inductive predicates, but how many do you have?</p>\n<p>This feature requires kernel modifications, including support for nested inductives, and paching code that makes assumptions that will not be true anymore after we change the kernel. Daniel already mentioned that many modules broke after he tried to patch the kernel.</p>\n<p>We have to prioritize, I have zillions of things to do, and I will not merge kernel hacks to support this.</p>",
        "id": 224955777,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612310709
    },
    {
        "content": "<p>In case 1, shouldn't it be a typechecking error? If it's literally not a Type/Prop even after unfolding then it shouldn't be accepted by the kernel. Case 2 does happen, although I'm not sure about the frequency - perhaps Daniel has statistics on this, because my grep skills aren't up to the task atm. Of course we use lots of inductive types (I get 700 hits in mathlib) but most of these are not problematic because they are manifestly pi types targeting Prop/Type. I had an example of this in mind from the QPF project but I don't think it survived the PR process.</p>\n<p>A related situation that might come up in less contrived situations is constructors that don't manifestly target the right type, because they have a <code>let</code> in them, for example. I have definitely written code like that in software verification settings, where you have large and complex inductive types, although when it comes time to actually prove properties about the inductive type I usually find it better to have explicit equality assumptions in the constructors.</p>\n<p>One way to support this without kernel hacks would be to make the kernel inductive behind the scenes with these things unfolded, and then redeclare the type and constructors with the given types and prove them by defeq. That said, I guess part of the point of adding nested / mutual inductives to the kernel was to avoid this kind of facade pattern, and I agree that this isn't a big priority. I'll do a once-over of mathlib to see if the existing uses can be fixed, and report back if something really critical depends on it.</p>",
        "id": 224960394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612314098
    },
    {
        "content": "<blockquote>\n<p>In case 1, shouldn't it be a typechecking error? If it's literally not a Type/Prop even after unfolding then it shouldn't be accepted by the kernel.</p>\n</blockquote>\n<p>In case 1, I meant the type after elaboration is not of the form <code>... -&gt; Sort u</code> for some <code>u</code>.<br>\nIn Daniel's example, the type was <code>set (set a)</code> after elaboration. After unfolding the first <code>set</code>, we have <code>set a -&gt; Prop</code>.</p>",
        "id": 224960779,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612314386
    },
    {
        "content": "<blockquote>\n<p>I have definitely written code like that in software verification settings</p>\n</blockquote>\n<p>We have to prioritize. Let's focus on mathlib only.</p>",
        "id": 224960950,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612314515
    },
    {
        "content": "<blockquote>\n<p>One way to support this without kernel hacks would be to make the kernel inductive </p>\n</blockquote>\n<p>I know what has to be done. However knowing and doing are two completely different things ;)</p>",
        "id": 224961017,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612314575
    },
    {
        "content": "<p>Regarding Daniel's <code>set (set A)</code> example specifically, this is exploiting definitional equality of <code>set A</code>, which is bad style in mathlib anyway (because it messes up the use of <code>\\in</code> and <code>{x | p}</code>). So I don't think there will be any problem removing that use.</p>",
        "id": 224961441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612314887
    },
    {
        "content": "<p>What about this one?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">presieve</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"n\">Y</span><span class=\"o\">⦄,</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"c1\">-- ...</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">singleton</span> <span class=\"o\">:</span> <span class=\"n\">presieve</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">singleton</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 224961602,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1612314983
    },
    {
        "content": "<p>cc: <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> , how important is the definitional equality of <code>presieve X</code> here?</p>",
        "id": 224961931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612315211
    },
    {
        "content": "<p>I don't work with the category theory library much</p>",
        "id": 224961966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612315245
    },
    {
        "content": "<p>I think I'll just try the facade pattern manually for that one</p>",
        "id": 224962277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612315446
    },
    {
        "content": "<p>I haven't been following this discussion so I don't really understand the suggested change, but I think as long as there's a coe or other nice notation for presieves and the definition of singleton is via some form of inductive, it should all be fine</p>",
        "id": 224962329,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1612315503
    },
    {
        "content": "<p>I'll defer to Bhavik <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 224975088,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1612330254
    },
    {
        "content": "<p>About <a href=\"https://github.com/dselsam/mathport/issues/7\">https://github.com/dselsam/mathport/issues/7</a>, can this be simulated by introducing a new constant and an axiom that it is provably equal to the object we have constructed? Setting the <code>irreducible</code> attribute after the construction is something we use in mathlib for several complicated objects (like the reals, the integral, and so on) whose construction is involved but for which the construction can be forgotten once a basic API has been established. This is something that we will still need to do in Lean4.</p>",
        "id": 224984671,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1612339669
    },
    {
        "content": "<p>I think the proposal is to have something like that: <code>real</code> which is irreducible, and <code>real_implementation</code> where we set up the api.</p>",
        "id": 224985421,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1612340330
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> We can add a macro for the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">constant</span> <span class=\"n\">pi_core</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">classical.some</span> <span class=\"n\">exists_cos_eq_zero</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">pi</span> <span class=\"o\">:</span> <span class=\"n\">real</span> <span class=\"o\">:=</span> <span class=\"n\">pi_core.1</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">pi_def</span> <span class=\"o\">:</span> <span class=\"n\">pi</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">classical.some</span> <span class=\"n\">exists_cos_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">pi_core.2</span>\n</code></pre></div>",
        "id": 224985431,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612340340
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"irreducible_def\"</span> <span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" : \"</span> <span class=\"n\">type</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">decl</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n<span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">noncomputable</span> <span class=\"kd\">constant</span> <span class=\"n\">wrapped</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">type</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">decl</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">real</span> <span class=\"o\">:=</span> <span class=\"n\">wrapped.1</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdentFrom</span> <span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">name.getId</span> <span class=\"bp\">++</span> <span class=\"bp\">`</span><span class=\"n\">eqn</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"n\">wrapped.2</span><span class=\"o\">)</span>\n\n<span class=\"n\">irreducible_def</span> <span class=\"n\">pi</span> <span class=\"o\">:</span> <span class=\"n\">real</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">classical.some</span> <span class=\"n\">exists_cos_eq_zero</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">pi</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">classical.some</span> <span class=\"n\">exists_cos_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">pi.eqn</span>\n</code></pre></div>",
        "id": 224986444,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612341135
    },
    {
        "content": "<p>I still need to see how this would work to define, say, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span>. Would this lead to DTT hell when constructing the basic API?</p>",
        "id": 224998632,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1612349033
    },
    {
        "content": "<p>For ℝ it is easy, we can define <code>constant reals : (α : Type) × conditionally_complete_linear_ordered_field α</code> and then say <code>def ℝ := reals.1</code>.  There isn't even any need to expose the implementation here.</p>",
        "id": 224999026,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612349227
    },
    {
        "content": "<p>I'm more worried about wrappers such as <code>with_one</code> (or <code>opposite</code>).</p>",
        "id": 224999203,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612349348
    },
    {
        "content": "<blockquote>\n<p>Both <code>unop (op X) = X</code> and <code>op (unop X) = X</code> are definitional equalities. Notably, every object of the opposite category is definitionally of the form <code>op X</code>, which greatly simplifies the definition of the structure of the opposite category, for example.</p>\n</blockquote>",
        "id": 224999251,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612349391
    },
    {
        "content": "<p>Maybe the category theory people can chime in on this.  Would a semireducible opposite be enough?  <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 224999384,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612349479
    },
    {
        "content": "<p>We can experiment with this today in mathlib.  This is essentially the API we'll have in Lean 4 (maybe we need to write <code>irreducible_def</code> instead, but that's just syntax):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- immediately mark as irreducible</span>\n<span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"c1\">-- never use `local attribute [reducible]`, instead use `rw`/`simp`/`unfold`</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 224999742,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612349693
    },
    {
        "content": "<p>Is this different from making <code>opposite</code> a structure?</p>",
        "id": 225010008,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612356609
    },
    {
        "content": "<p>Making it irreducible (and never overriding it locally) is about the same as making it a structure.  From what I understand, that would be horrible.</p>",
        "id": 225010074,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612356663
    },
    {
        "content": "<p>The question is if it would be possible to make it semireducible instead of irreducible (i.e. just a plain <code>def</code>).</p>",
        "id": 225010092,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612356683
    },
    {
        "content": "<p>Semireducible was what we had originally and it led to lots of confusion because, if you don't have a clear distinction between <code>A B : C</code> and <code>A B : opposite C</code>, then you don't know whether <code>A \\hom B</code> is a map from <code>A</code> to <code>B</code> or a map from <code>B</code> to <code>A</code>.</p>",
        "id": 225010263,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612356796
    },
    {
        "content": "<p>I'm not entirely sure how bad it would be to use a structure; from what I remember, I found the current setup with <code>irreducible</code> provided the most definitional equalities and so we built <code>opposite</code> on top of it. There was never a time that we seriously tried using a structure instead, since there was no need to.</p>",
        "id": 225010477,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612356944
    },
    {
        "content": "<p>Now we have a lot of code  using <code>opposite</code>, so we can find out experimentally whether that comment is really correct.</p>",
        "id": 225010551,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612356990
    },
    {
        "content": "<p>For stuff like <code>with_one</code> I think we just use this irreducibility to get a few things about <code>option</code> for free, like the functor/monad instances. I don't think it's a big deal, we can just reimplement them in a few lines (for each of the relevant <code>with_*</code>) manually.</p>",
        "id": 225010825,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612357197
    },
    {
        "content": "<p>I've tried making <code>is_O</code> and friends irreducible in <a href=\"https://github.com/leanprover-community/mathlib/issues/6021\">#6021</a>.  It's not pretty but not awful either.  This was probably the easiest irreducible to remove.  <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> where would you expect the most DTT hell from making definitions irreducible immediately?</p>",
        "id": 225010990,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612357281
    },
    {
        "content": "<p><code>additive</code> and <code>multiplicative</code> are another minefield.  Maybe it's time to revive <a href=\"https://github.com/leanprover-community/mathlib/issues/2292\">#2292</a> now.</p>",
        "id": 225011414,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612357525
    },
    {
        "content": "<p>I'd be pretty scared of <code>data/real/basic.lean</code>, but maybe I'm too pessimistic.</p>",
        "id": 225013369,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1612358415
    },
    {
        "content": "<p>Related to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/additive\">docs#additive</a>, I remember a pr about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_dual\">docs#order_dual</a> where I tried to come up with an alternative proof for something to avoid relying on definitional equality, but found all the lemmas I needed were missing</p>",
        "id": 225014091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612358752
    },
    {
        "content": "<p>BTW, my general preference in these matters is to use <code>structure</code> rather than <code>irreducible</code>, since everyone knows about <code>structure</code> but I'm not sure I even really understand what <code>irreducible</code> does and doesn't do.</p>",
        "id": 225015646,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612359486
    },
    {
        "content": "<p>Yes, I also feel like I don't understand <code>irreducible</code>. I made <code>with_zero</code> and <code>with_one</code> irreducible in <a href=\"https://github.com/leanprover-community/mathlib/issues/3883\">#3883</a> because I was finding them frustrating to work with. People were abusing type equality in code and the resulting \"not strictly speaking type correct in some sense\" code would cause leaks, where I was trying to prove things about <code>0</code> or <code>1</code> but was staring at goals which talked about <code>none</code>. I would have been equally happy simply ripping out the definition <code>with_zero X := option X</code> and replacing it with a new inductive type with constructors <code>zero</code> and <code>some x</code>, but at the time people discouraged me from doing this because it would have led to a bunch of code duplication. Right now we steal a bunch of proofs from <code>option</code> when making the <code>with_zero</code> API and then mark it irreducible at the end. I should apologise in advance if this is not relevant, I do not really understand the issues of what is being talked about here.</p>",
        "id": 225019967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612361449
    },
    {
        "content": "<blockquote>\n<p>but I'm not sure I even really understand what irreducible does and doesn't do.</p>\n</blockquote>\n<p>also, there is no <code>irreducible</code> in Lean4, only <code>constant</code> which is truly opaque (even to the kernel)</p>",
        "id": 225023449,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612362989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/225013369\">said</a>:</p>\n<blockquote>\n<p>I'd be pretty scared of <code>data/real/basic.lean</code>, but maybe I'm too pessimistic.</p>\n</blockquote>\n<p>Ok this was easy: <a href=\"https://github.com/leanprover-community/mathlib/issues/6024\">#6024</a>.</p>",
        "id": 225023984,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612363213
    },
    {
        "content": "<p>The real test will be to completely remove the Cauchy reals and replace them with Bourbaki reals that we also have.</p>",
        "id": 225025895,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1612364044
    },
    {
        "content": "<p>Bourbaki = the reals are the unique complete Archimedean ordered field?</p>",
        "id": 225026505,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612364303
    },
    {
        "content": "<p>The updated definition by Gabriel is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">real</span> <span class=\"o\">:=</span> <span class=\"n\">of_cauchy</span> <span class=\"o\">::</span>\n<span class=\"o\">(</span><span class=\"n\">cauchy</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">cau_seq.completion.Cauchy</span> <span class=\"n\">ℚ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">abs</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Can someone explain what this is? What are these <code>::</code>?</p>",
        "id": 225026640,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1612364382
    },
    {
        "content": "<p>The default constructor for a structure is called <code>mk</code>.  But <code>real.mk</code> already means something different.  The <code>::</code> allows you to rename the constructor.</p>",
        "id": 225026738,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612364412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/225023984\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/225013369\">said</a>:</p>\n<blockquote>\n<p>I'd be pretty scared of <code>data/real/basic.lean</code>, but maybe I'm too pessimistic.</p>\n</blockquote>\n<p>Ok this was easy: <a href=\"https://github.com/leanprover-community/mathlib/issues/6024\">#6024</a>.</p>\n</blockquote>\n<p>Great! I still see <code>irreducible</code> though -- is it possible to wrap <code>lt</code> in a constant?</p>",
        "id": 225026850,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612364465
    },
    {
        "content": "<p>Not in Lean 3.  I don't want to add hundreds of noncomputable annotations.</p>",
        "id": 225026924,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612364499
    },
    {
        "content": "<p><code>lt</code> is a <code>Prop</code> though, why would it matter?</p>",
        "id": 225027044,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612364533
    },
    {
        "content": "<p>The idea here is to only use irreducible in such a way that we can simulate in Lean 4.  For example using the <code>irreducible_def</code> macro I posted above.</p>",
        "id": 225027053,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612364540
    },
    {
        "content": "<p>Ah then it <em>might</em> be possible.  But I don't see why it matters.  We don't want to add hacks now just to remove them again in a few months.</p>",
        "id": 225027181,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612364585
    },
    {
        "content": "<p>In which sense is this irreducible, though? If Lean sees an equality <code>x + y = z</code> and wants to check it definitionally, it will never unfold by itself the definition of addition on the fields of the structure to check if they match after this unfolding, right?</p>",
        "id": 225027297,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1612364625
    },
    {
        "content": "<p>Also, <a href=\"https://github.com/leanprover-community/mathlib/issues/6024\">#6024</a> doesn't build ;-)</p>",
        "id": 225027593,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1612364726
    },
    {
        "content": "<p>Oops, so <code>+</code> is irreducible now, and I accidentally made it semireducible.</p>",
        "id": 225027608,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612364732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/225027053\">said</a>:</p>\n<blockquote>\n<p>The idea here is to only use irreducible in such a way that we can simulate in Lean 4.  For example using the <code>irreducible_def</code> macro I posted above.</p>\n</blockquote>\n<p>If I am reading <a href=\"https://github.com/leanprover-community/mathlib/blob/f8dadb5c855646f5a96e3551737801dbafb4fbd3/src/data/real/basic.lean#L87-L98\">https://github.com/leanprover-community/mathlib/blob/f8dadb5c855646f5a96e3551737801dbafb4fbd3/src/data/real/basic.lean#L87-L98</a> correctly, it looks like you are manually unfolding <code>lt</code> after-the-fact. So if the auto-porter used your macro to define <code>lt</code>, the downstream proof would break.</p>",
        "id": 225028390,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612365008
    },
    {
        "content": "<p>I'm going to experiment with <code>opposite</code>-as-structure later today.</p>",
        "id": 225028709,
        "sender_full_name": "Reid Barton",
        "timestamp": 1612365126
    },
    {
        "content": "<p><code>simp [real.lt]</code> uses the equation lemma.  The macro also produces an equation lemma <code>real.lt.eqn</code>.</p>",
        "id": 225028716,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612365128
    },
    {
        "content": "<p>There should be no <em>definitional</em> unfolding happening.</p>",
        "id": 225028752,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612365144
    },
    {
        "content": "<p>I may be missing something obvious, but your macro doesn't seem to guarantee that the equation lemma of the <code>constant</code> and the equation lemma(s) of the original definition line up. How about this:</p>\n<ul>\n<li>when mathport reaches a definition, it looks ahead to see if it is immediately declared irreducible</li>\n<li>if so, it collects all equation lemmas, and creates a constant <code>{ x  // all equation lemmas hold }</code></li>\n<li>it then creates a def for (new constant).val and one for each of the eqn lemmas (new constant).property[...]</li>\n<li>it then aligns the old decl and equation lemmas with the new ones</li>\n</ul>",
        "id": 225031878,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612366399
    },
    {
        "content": "<p>FYI I will be offline today but back tomorrow.</p>",
        "id": 225032045,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1612366464
    },
    {
        "content": "<p>There's typically only a single equation for irreducible definitions, but yes, that sounds good.  The macro was intended as an illustration for \"this is how it will be after we've ported mathlib\", not a suggestion for the porting tool.</p>",
        "id": 225033272,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612366987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/225026505\">said</a>:</p>\n<blockquote>\n<p>Bourbaki = the reals are the unique complete Archimedean ordered field?</p>\n</blockquote>\n<p>No, that wouldn't be a construction but a characterization. Bourbaki constructs real number as the completion of the topological ring of rational number, using a <em>lot</em> of the topology library.</p>",
        "id": 225047867,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1612372576
    },
    {
        "content": "<p>Is this what Johannes originally did in mathlib?  I believe Mario removed that construction in favor of the current elementary one to reduce dependencies.</p>",
        "id": 225049300,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1612373127
    },
    {
        "content": "<p>Johannes originally did a somewhat hybrid version, not going full Bourbaki. Mario added an elementary construction because there were huge performance issues. This was before we started to mark stuff irreducible.</p>",
        "id": 225051098,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1612373804
    },
    {
        "content": "<p>I agree that it is a bit ridiculous that the definition of real numbers in Lean is understandable by freshmen students... clearly we should take inspiration from integration theory do things properly. <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>  [/trolling]</p>",
        "id": 225052566,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1612374447
    },
    {
        "content": "<p>Updates and issues:</p>\n<ul>\n<li>\n<p>I back-ported a minor adjustment to <code>dite</code> and <code>ite</code> but haven't PRed yet (not sure what the protocol is for multi-repo changes):</p>\n<ul>\n<li><a href=\"https://github.com/dselsam/lean3/tree/dite\">https://github.com/dselsam/lean3/tree/dite</a></li>\n<li><a href=\"https://github.com/dselsam/mathlib/tree/dite\">https://github.com/dselsam/mathlib/tree/dite</a></li>\n</ul>\n</li>\n<li>\n<p>Lean4's <code>&lt;</code> doesn't match lean3's <code>&lt;</code> on nats. In lean3, <code>nat.lt</code> and <code>nat.le</code> are inductive whereas <code>Nat.lt</code> and <code>Nat.le</code> are defined as the boolean versions returning true. I think this instance clash will cause big problems and needs to be fixed.</p>\n</li>\n<li>\n<p>The number-mismatch is more problematic than I realized at first. Lean3 uses <code>zero</code>, <code>one</code>, <code>bit0</code> and <code>bit1</code>, whereas Lean4 uses <code>OfNat α n</code>. It is not trivial to auto-convert during the porting. I tried making <code>OfNat</code> instances from <code>has_zero</code>, <code>has_one</code>, and <code>has_add</code>, but it relies on a recursive function with idealized type <code>Π [has_one α] [has_add α], ℕ → α</code>. For easy auto-porting, this function must permit reasonably efficient  reduction in the kernel. Thus, it cannot be well-founded or partial. But if it relies on fuel, it becomes impossibly expensive to confirm <code>2 + 2 = 4</code> in the kernel.</p>\n</li>\n<li>\n<p>To align <code>applicative</code> and <code>monad</code>, all that needs to happen is that <code>seq_left</code> and <code>seq_right</code> must require the discarded action to return <code>unit</code>. It is easy to change, but there is some theory based on <code>lawful_applicative</code> and <code>lawful_monad</code> that broke, so ideally somebody who works on that part of the library can finish propagating the change.</p>\n</li>\n<li>\n<p>The current lack of <code>string</code>-&gt;<code>String</code> alignment is not catastrophic but it is unpleasant, since e.g. <code>auto_param</code>s will show as lists of nats. A few issues are blocking this alignment.</p>\n<ol>\n<li><code>fin</code> is a def in lean3 whereas <code>Fin</code> is a structure in lean4. Note that it is important for it to be a structure in lean4 because there is special support in the system for it in various places, and so <code>Fin</code> needs to be the whnf.</li>\n<li><code>unsigned</code> is a def in lean3 whereas <code>UInt32</code> is a structure in lean4 for the same reason as <code>Fin</code></li>\n<li>The <code>nat.lt</code> issue also complicates this.</li>\n<li>The general number mismatch also complicates this.</li>\n</ol>\n</li>\n</ul>",
        "id": 226086158,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613096526
    },
    {
        "content": "<p>Are there any updates on the two open backports?</p>\n<p>- <a href=\"https://github.com/dselsam/mathport/issues/7\">https://github.com/dselsam/mathport/issues/7</a><br>\n  - <a href=\"https://github.com/dselsam/mathport/issues/4\">https://github.com/dselsam/mathport/issues/4</a></p>\n<p>Note that I switched <a href=\"https://github.com/dselsam/mathport/issues/3\">https://github.com/dselsam/mathport/issues/3</a> from <code>backport</code> to <code>blocked</code>, pending a final decision about what to support on the lean4 side.</p>",
        "id": 226086365,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613096776
    },
    {
        "content": "<p>Regarding <a href=\"https://github.com/dselsam/mathport/issues/4\">dselsam/mathport#4</a>, there were two PRs handling this; <a href=\"https://github.com/leanprover-community/mathlib/issues/6028\">#6028</a> was merged and covered most of the occurrences I could find with a quick grep, and <a href=\"https://github.com/leanprover-community/mathlib/issues/6061\">#6061</a> added a linter and removed all remaining occurrences. However <a href=\"https://github.com/leanprover-community/mathlib/issues/6061\">#6061</a> has not been merged as there is some mysterious typeclass breakage in an unrelated area</p>",
        "id": 226086627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613097057
    },
    {
        "content": "<p>As for things like <code>Nat.lt</code> vs <code>nat.lt</code>, as I mentioned to you before we have to find a way to handle non-defeq replacements, defeq is setting way too high a bar. For propositions it's feasible that we can prove an equality and simp it away in lemmas</p>",
        "id": 226086846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613097299
    },
    {
        "content": "<p>I think backporting <code>Nat.lt</code> is out of the question, that would be way too disruptive</p>",
        "id": 226086883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613097357
    },
    {
        "content": "<p>Also, <code>a &lt; b := a + 1 &lt;= b</code> is super convenient and used all the time. Could we maybe have a conversation about why these were changed and whether we need to be doing something different with decidable predicates in general?</p>",
        "id": 226087052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613097524
    },
    {
        "content": "<p>For \"multi-repo changes\", we have been first merging changes to Lean 3, then releasing a new version of Lean 3, and then finally making the necessary changes to mathlib in a PR that bumps the Lean version.</p>",
        "id": 226087091,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1613097602
    },
    {
        "content": "<p>Regarding <code>fin</code>, we changed it from a structure to a def because of some inconveniences expressed in <a href=\"https://github.com/leanprover-community/lean/issues/359\">lean#359</a>. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> can probably say more.</p>",
        "id": 226088299,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1613098816
    },
    {
        "content": "<p><code>nat.lt</code> would need to be aligned for a def-eq alignment of <code>string</code> to <code>String</code>, but otherwise wouldn't need to be. The issue is the clashing instances. Would you just want to ignore the Lean4 instance and have <code>m &lt; n</code> mean the Mathlib <code>nat.lt</code>? This may be problematic, since Lean4 may internally synthesize decidable instances of things at various times and now may end up with ones that don't use the <code>Nat</code> primitives that are builtin to the kernel, e.g. <code>Nat.blt</code>.</p>",
        "id": 226088400,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613098928
    },
    {
        "content": "<p>My first choice would be to get <code>Nat.lt</code> to have the same definition as in mathlib, with a decidable instance following the lean 4 style</p>",
        "id": 226088521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613099047
    },
    {
        "content": "<p>I suspect the current definition of <code>Nat.lt</code> was chosen because it's the easiest definition that adheres with <code>Nat.blt</code></p>",
        "id": 226088541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613099099
    },
    {
        "content": "<p>but we should be able to prove the equivalence of the two definitions and use this equivalence in the implementation of the decidable instance for <code>Nat.lt</code></p>",
        "id": 226088564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613099126
    },
    {
        "content": "<p>I don't think it matters as much whether <code>Nat.le</code> retains the lean 3 definition vs lean 4, because the underlying inductive type <code>nat.less_than_or_equal</code> is an internal implementation detail that is used extremely rarely in mathlib</p>",
        "id": 226088645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613099230
    },
    {
        "content": "<p>Re: applicative and monad, could you put your work on a branch and/or PR what you have?</p>",
        "id": 226089694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613099534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226089694\">said</a>:</p>\n<blockquote>\n<p>Re: applicative and monad, could you put your work on a branch and/or PR what you have?</p>\n</blockquote>\n<p>Here is the basic change that needs to be propagated: <a href=\"https://github.com/dselsam/lean3/commit/7e8ead2c0d371ddacef7db30e7dd68d52f4b768f\">https://github.com/dselsam/lean3/commit/7e8ead2c0d371ddacef7db30e7dd68d52f4b768f</a> Note that this change breaks within the lean3 repo.</p>",
        "id": 226093805,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613100558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226087052\">said</a>:</p>\n<blockquote>\n<p>Also, <code>a &lt; b := a + 1 &lt;= b</code> is super convenient and used all the time. Could we maybe have a conversation about why these were changed </p>\n</blockquote>\n<p><code>Nat.lt</code> is also defined that way in Lean4: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L536-L537\">https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L536-L537</a></p>",
        "id": 226095486,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613101741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>I think backporting <code>Nat.lt</code> is out of the question, that would be way too disruptive</p>\n</blockquote>\n<blockquote>\n<p>I don't think it matters as much whether <code>Nat.le</code> retains the lean 3 definition vs lean 4, because the underlying inductive type <code>nat.less_than_or_equal</code> is an internal implementation detail that is used extremely rarely in mathlib</p>\n</blockquote>\n<p>Can you please clarify, what would be way too disruptive and what doesn't matter that much?</p>",
        "id": 226095569,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613101844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226088564\">said</a>:</p>\n<blockquote>\n<p>but we should be able to prove the equivalence of the two definitions and use this equivalence in the implementation of the decidable instance for <code>Nat.lt</code></p>\n</blockquote>\n<p>Meaning something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">Nat.le2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Nat.leOfTrue</span>  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ble</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>     <span class=\"bp\">→</span> <span class=\"n\">Nat.le2</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Nat.leOfFalse</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">Nat.ble</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">Nat.le2</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">Nat.le2</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ble</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">Nat.leOfTrue</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">Nat.leOfFalse</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 226095866,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613102249
    },
    {
        "content": "<blockquote>\n<p>Can you please clarify, what would be way too disruptive and what doesn't matter that much?</p>\n</blockquote>\n<p>Changing the definition of <code>nat.lt</code> in lean 3 to make it not validate <code>a &lt; b =?= a + 1 &lt;= b</code> would break lots and lots of things. Changing the definition of <code>nat.le</code> would not break much because <code>nat.less_than_or_equal</code> is not (or should not be) used directly in proofs</p>",
        "id": 226097416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613104455
    },
    {
        "content": "<blockquote>\n<p>Meaning something like this?</p>\n</blockquote>\n<p>Yes. We should be able to slot in any convenient definition into <code>Nat.le2</code>, as long as those two theorems <code>Nat.leOfTrue</code> and <code>Nat.leOfFalse</code> are provable, and we should see no performance penalty</p>",
        "id": 226097482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613104563
    },
    {
        "content": "<p>On the assumption that lean 4 isn't doing much with proofs about <code>Nat.le</code>, it would be relatively easier to forward port <code>nat.less_than_or_equal</code> to lean 4 than backport <code>Nat.ble a b = true</code> to lean 3, which will break the foundational theorems plus the handful of mathlib theorems that use this inductive definition</p>",
        "id": 226097604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613104685
    },
    {
        "content": "<blockquote>\n<p>Changing the definition of <a href=\"http://nat.lt\">nat.lt</a> in lean 3 to make it not validate a &lt; b =?= a + 1 &lt;= b would break lots and lots of things</p>\n</blockquote>\n<p>To reiterate, that is how <code>Nat.lt</code> is defined in Lean4 as well so this would not be an issue.</p>",
        "id": 226097790,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613104933
    },
    {
        "content": "<p>right</p>",
        "id": 226097802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613104951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226097604\">said</a>:</p>\n<blockquote>\n<p>On the assumption that lean 4 isn't doing much with proofs about <code>Nat.le</code>, it would be relatively easier to forward port <code>nat.less_than_or_equal</code> to lean 4 than backport <code>Nat.ble a b = true</code> to lean 3, which will break the foundational theorems plus the handful of mathlib theorems that use this inductive definition</p>\n</blockquote>\n<p>I can't assess how hard it would be to backport, but I don't see an issue with forward-porting <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226095866\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226095866</a> Leo may not want the extra complexity though.</p>",
        "id": 226097990,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613105176
    },
    {
        "content": "<p>Regarding <code>seq_left</code>, can we just not align it? Or have a separate typeclass for the notation? It seems like it's just a pessimization. I recall <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> had a rationale for this change but I forget what it was and whether it applies to the <code>*&gt;</code> notation as separate from <code>do</code> notation</p>",
        "id": 226098010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105207
    },
    {
        "content": "<p>Plus do notation has been extended so radically in lean 4 since the change was first made that perhaps the rationale doesn't apply anymore</p>",
        "id": 226098127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226098010\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>seq_left</code></p>\n</blockquote>\n<ul>\n<li>It is not necessary to align it. The downside is that there will be two of many different classes, and the category-theoretic monad won't be connected to the lean <code>Monad</code></li>\n<li>If you wanted, you could make the constructors align but then (still in lean3) use the notation for a definition of the original type (that adds a discard). You would still need to update the <code>lawful</code> types and patch a few proofs though</li>\n</ul>",
        "id": 226098204,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613105449
    },
    {
        "content": "<p>I don't remember the rationale either :)</p>",
        "id": 226098281,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613105551
    },
    {
        "content": "<p>I'm hoping we can align <code>Monad</code> and <code>monad</code> with lean 3 <code>seq_left</code> being a separate thing</p>",
        "id": 226098310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105579
    },
    {
        "content": "<p>perhaps <code>a *&gt; b</code> is defined over applicatives as <code>Monad.seq_left (discard a) b</code></p>",
        "id": 226098345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105633
    },
    {
        "content": "<p>with <code>Monad.seq_left</code> having no particular notation</p>",
        "id": 226098394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226098345\">said</a>:</p>\n<blockquote>\n<p>perhaps <code>a *&gt; b</code> is defined over applicatives as <code>Monad.seq_left (discard a) b</code></p>\n</blockquote>\n<p>I think that is what I was suggesting above.</p>\n<blockquote>\n<ul>\n<li>If you wanted, you could make the constructors align but then (still in lean3) use the notation for a definition of the original type (that adds a discard). You would still need to update the <code>lawful</code> types and patch a few proofs though</li>\n</ul>\n</blockquote>",
        "id": 226098397,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613105675
    },
    {
        "content": "<p>aha ok</p>",
        "id": 226098416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105731
    },
    {
        "content": "<p>even though <code>seq_left</code> is a field of the <code>monad</code> structure I don't think anyone ever gives them a non-default implementation</p>",
        "id": 226098476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105787
    },
    {
        "content": "<p>Even without that trick, I think adding the <code>discard</code>s manually is just a few minutes with egrep and not a big issue. The somewhat harder part is that the lawful type needs to change and a few proofs need to be patched.</p>",
        "id": 226098493,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613105823
    },
    {
        "content": "<p>I think it's probably not hard but it's going to make mathlib worse. It's not a desirable change</p>",
        "id": 226098511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613105863
    },
    {
        "content": "<p>Hold off then until you can discuss with Sebastian.</p>",
        "id": 226098787,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613106194
    },
    {
        "content": "<p>Do you have thoughts about the number-mismatch?</p>",
        "id": 226098806,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613106229
    },
    {
        "content": "<p>I'm not sure I understand the way you set up the problem. What is this function <code>Π [has_one α] [has_add α], ℕ → α</code> that you need? That looks like <code>OfNat</code> and it's already got an efficient implementation in lean 4</p>",
        "id": 226099038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613106505
    },
    {
        "content": "<p>To interpret lean 3 numeral expressions you just need <code>bit0</code> and <code>bit1</code> and the corresponding functions <code>n + n</code> and <code>n+n+1</code> are passably fast in the lean 4 kernel</p>",
        "id": 226099062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613106566
    },
    {
        "content": "<p>I meant something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HasZero</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasOne</span>  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">HasZero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasOne</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">bit0</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">HasOne.one</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">HasOne</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">HasOne.one</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nat2bitsFuelAux</span> <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">fuel</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"bp\">=&gt;</span> <span class=\"n\">arbitrary</span>\n  <span class=\"bp\">|</span> <span class=\"n\">fuel</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">arbitrary</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">==</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"n\">HasOne.one</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">==</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">nat2bitsFuelAux</span> <span class=\"n\">fuel</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">))</span>\n    <span class=\"k\">else</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">nat2bitsFuelAux</span> <span class=\"n\">fuel</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- note: partial and wf don't compute in the kernel</span>\n<span class=\"kd\">def</span> <span class=\"n\">nat2bitsFuel</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">nat2bitsFuelAux</span> <span class=\"mi\">10</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- already takes a while, and 10 fuel is not enough for all of mathlib (real.pi has big numbers)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat2bitsFuel</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">nat2bitsFuel</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nat2bitsFuel</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 226099711,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613107529
    },
    {
        "content": "<p>I tried replacing <code>bit0</code>/<code>bit1</code> expressions with variations of <code>OfNat.ofNat &lt;type&gt; &lt;nat&gt; &lt;instNat2bitsInAlpha&gt;</code> which are definitionally equal and fine for isolated numbers, but basic arithmetic (e.g. <code>2 + 2 =?= 4</code>) is intractable for the kernel. This comes up in e.g. <code>zero_lt_four</code>.</p>",
        "id": 226099842,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613107708
    },
    {
        "content": "<p>So I'm thinking more like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HasZero</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasOne</span>  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">HasZero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasOne</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">bit0</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">HasOne.one</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instZero2Nat</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">noindex</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">HasZero.zero</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instOne2Nat</span>  <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">noindex</span><span class=\"bp\">!</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">HasOne.one</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 226099944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613107898
    },
    {
        "content": "<p>But now in Lean4, you have <code>bit0</code> and <code>bit1</code> everywhere instead of numbers.</p>",
        "id": 226099994,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613107961
    },
    {
        "content": "<p>I would like to make</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>work, but this requires instances of <code>OfNat A 2</code> and <code>OfNat A 4</code> and it's not clear to me how lean 4 expects me to build a countable infinity of typeclasses</p>",
        "id": 226100037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108004
    },
    {
        "content": "<p>I suspect this might be a design flaw re: <code>OfNat</code> instances. It's not necessarily an option to inhabit <code>OfNat A n</code> directly, if all you have to start from is a ring, say</p>",
        "id": 226100090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108087
    },
    {
        "content": "<p>If instances can be constructed by binary recursion then that might work, but what is the structure of lean 4 nat literals that can be pattern matched on?</p>",
        "id": 226100106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108129
    },
    {
        "content": "<p>This works in principle (and has kernel def-eq) but it is just too slow: <a href=\"https://github.com/dselsam/mathport/blob/strings2/Lib4/PrePort/Number.lean#L36-L50\">https://github.com/dselsam/mathport/blob/strings2/Lib4/PrePort/Number.lean#L36-L50</a></p>",
        "id": 226100118,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613108153
    },
    {
        "content": "<p>No I mean that the instance should depend on the number</p>",
        "id": 226100165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108188
    },
    {
        "content": "<p>I don't follow, but I need to sign off now. To be continued.</p>",
        "id": 226100234,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613108285
    },
    {
        "content": "<p>Thanks for your help.</p>",
        "id": 226100236,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613108294
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasOne</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instZero2Nat</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">noindex</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">HasZero.zero</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instOne2Nat</span>  <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">noindex</span><span class=\"bp\">!</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">HasOne.one</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instBit0Nat</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">bit0</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instBit1Nat</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasOne</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"mi\">37</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inferInstance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">bit1</span> <span class=\"bp\">$</span> <span class=\"n\">bit0</span> <span class=\"bp\">$</span> <span class=\"n\">bit1</span> <span class=\"bp\">$</span> <span class=\"n\">bit0</span> <span class=\"bp\">$</span> <span class=\"n\">bit0</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 226100404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108554
    },
    {
        "content": "<p>I want the <code>inferInstance</code> line to actually be constructed by typeclass inference</p>",
        "id": 226100412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108573
    },
    {
        "content": "<p>There might be a way to get unification hints to do this?</p>",
        "id": 226100425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108607
    },
    {
        "content": "<p>Well, maybe it suffices for mathport to do its own fake typeclass inference here, although using <code>OfNat</code> with such an instance is barely better than the original approach of writing <code>bit0/bit1</code>  chains</p>",
        "id": 226100512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613108752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226088299\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>fin</code>, we changed it from a structure to a def because of some inconveniences expressed in <a href=\"https://github.com/leanprover-community/lean/issues/359\">lean#359</a>. <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> can probably say more.</p>\n</blockquote>\n<p>I refactor <code>fin</code> to be a subtype because there is quite a bunch of API for subtypes and I didn't see the point in duplicating all of it for <code>fin</code>.</p>",
        "id": 226101423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613110049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226100512\">said</a>:</p>\n<blockquote>\n<p>using <code>OfNat</code> with such an instance is barely better than the original approach of writing <code>bit0/bit1</code>  chains</p>\n</blockquote>\n<p>I think it is essential that we can write e.g. <code>2</code> instead of <code>bit0 1</code>, at least when there is a natural <code>∀ n, OfNat α n</code> instance, e.g. nats, rationals, reals</p>",
        "id": 226168818,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613150980
    },
    {
        "content": "<p>It wouldn't be so bad for Mathlib4 and Lean4 to have different definitions of <code>Fin</code>. I would like to align strings though to avoid the <code>auto_param</code> garbage prints. I see two other options (besides backporting <code>Fin</code>-as-structure):</p>\n<ul>\n<li>Since <code>string</code> is almost never used in actual math, perhaps we can just create a Lean4-friendly Fin type <code>fin4</code> and have characters use that instead of the regular <code>fin</code>. </li>\n<li>Or we could just not port anything that depends on the def-eq details of characters that would be changed by auto-aligning.</li>\n</ul>",
        "id": 226170331,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613151561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226100425\">said</a>:</p>\n<blockquote>\n<p>There might be a way to get unification hints to do this?</p>\n</blockquote>\n<p>I don' think this is supported. The following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unif_hint</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=?=</span> <span class=\"n\">n</span> <span class=\"bp\">|-</span> <span class=\"n\">m</span> <span class=\"bp\">=?=</span> <span class=\"n\">bit0</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>is not accepted because <code>?m =?= bit0 (?m / 2)</code> does not hold definitionally.</p>",
        "id": 226173193,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613152593
    },
    {
        "content": "<p>Alternatively, we could get unification to somehow \"directly\" support <code>n+k</code> patterns, i.e. <code>n*2+3 =?= 17</code> matches <code>n =?= 7</code>. Without something like this, the whole idea of typeclasses reflecting on syntax interacts badly with the unstructured space of lean 4 nat literals; there's no way to write a finite set of instances that covers all natural numbers by induction</p>",
        "id": 226181379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613156644
    },
    {
        "content": "<p>If typeclass inference can call arbitrary tactics, that would be another way to support such a thing. I'm not sure where the design landed on that point. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Do you know?</p>",
        "id": 226181583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613156762
    },
    {
        "content": "<p>That unification hint isn't quite right, it needs to be specialized to numerals, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unif_hint</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"mi\">3</span> <span class=\"bp\">=?=</span> <span class=\"n\">n</span> <span class=\"bp\">|-</span> <span class=\"mi\">6</span> <span class=\"bp\">=?=</span> <span class=\"n\">bit0</span> <span class=\"n\">n</span>\n<span class=\"n\">unif_hint</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"mi\">4</span> <span class=\"bp\">=?=</span> <span class=\"n\">n</span> <span class=\"bp\">|-</span> <span class=\"mi\">8</span> <span class=\"bp\">=?=</span> <span class=\"n\">bit0</span> <span class=\"n\">n</span>\n<span class=\"n\">unif_hint</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"mi\">5</span> <span class=\"bp\">=?=</span> <span class=\"n\">n</span> <span class=\"bp\">|-</span> <span class=\"mi\">10</span> <span class=\"bp\">=?=</span> <span class=\"n\">bit0</span> <span class=\"n\">n</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>I think you can see why this needs special elaborator support. Nat literals have special kernel support and so other aspects have to be similarly lifted to compensate</p>",
        "id": 226182143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613157030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226181583\">said</a>:</p>\n<blockquote>\n<p>If typeclass inference can call arbitrary tactics, that would be another way to support such a thing. I'm not sure where the design landed on that point. <span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> Do you know?</p>\n</blockquote>\n<p>There are no plans to do that anymore. Making the two systems mutually dependent would be insanity in the implementation, both on the term and (monad) type level. Having typeclass resolution and unification be interdependent is already complex enough.</p>",
        "id": 226307338,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1613313522
    },
    {
        "content": "<p>What do you mean by mutually dependent? What I am (coming around to) suggesting is more like a dynamically created typeclass instance, which is triggered on some syntactic condition that fits into the discrimination tree like <code>prime (ofNat n)</code> and calls a procedure that determines if this \"instance\" applies or not and returns a proof if so. It interacts minimally with the rest of the system, it's not delayed but is tried in order with other instances. These extensions can also live in the same monad as whatever typeclasses normally see, it doesn't have to be a full blown TacticM.</p>",
        "id": 226330232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613343082
    },
    {
        "content": "<p>Ok, that's a pretty different proposal</p>",
        "id": 226358202,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1613379432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> are you proposing something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">InstanceGenerator</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">generate</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> maybe just `Option Expr` -/</span>\n\n<span class=\"kd\">@[instanceGenerator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">generateOfNat</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">InstanceGenerator</span> <span class=\"o\">(</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">generate</span> <span class=\"n\">goal</span> <span class=\"bp\">=</span> <span class=\"k\">do</span>\n    <span class=\"c1\">-- if n is concrete, do the recursion here to produce the instance in terms of bit0/bit1</span>\n    <span class=\"gr\">sorry</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>And then this thing is inserted into the DTree for the <code>α</code>, and tried like any other instance, except the custom <code>generate</code> code is called instead of the normal resolution step?</p>",
        "id": 226398445,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613403629
    },
    {
        "content": "<p>Uh, kind of, although as a practical matter I think that mixing the two meta-levels in one statement will cause problems (you can't call the generator code unless you have an actual compiled type alpha with one, add, n). But you can probably hide the details behind a macro. Probably something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">InstanceGenerator</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">trigger</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span>\n  <span class=\"n\">generate</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[instanceGenerator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">generateOfNat</span> <span class=\"o\">:</span> <span class=\"n\">InstanceGenerator</span> <span class=\"n\">where</span>\n  <span class=\"n\">trigger</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"o\">({</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">generate</span> <span class=\"n\">goal</span> <span class=\"bp\">=</span> <span class=\"k\">do</span>\n    <span class=\"c1\">-- if n is concrete, do the recursion here to produce the instance in terms of bit0/bit1</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think the <code>generate</code> function should be in a monad, working with exprs without the elaborator functions is pretty hard, but it's fine if the determinism is expressed as a constraint to programmers, i.e. \"we will cache the result of this instance so you might get incorrect results if your generator tactic depends on the phase of the moon\"</p>",
        "id": 226408019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613408369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226408019\">said</a>:</p>\n<blockquote>\n<p>I think the <code>generate</code> function should be in a monad, working with exprs without the elaborator functions is pretty hard</p>\n</blockquote>\n<p>I don't think <code>TermElabM</code> will be on the table -- this proposal only seems plausible in the current design if the monad can easily lift to <code>SynthM</code>, which basically means it must be <code>MetaM</code>. What operations specifically do you think you will need to perform?</p>",
        "id": 226408656,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613408724
    },
    {
        "content": "<p>I'm not entirely sure, I haven't written enough lean 4 tactic code to say. In lean 3 it was certainly the case that life is a lot easier if you can use <code>to_expr</code> to build terms</p>",
        "id": 226409382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409094
    },
    {
        "content": "<p>or <code>mk_app</code></p>",
        "id": 226409456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409128
    },
    {
        "content": "<p>Maybe MetaM is fine. (Maybe SynthM? What's in there?)</p>",
        "id": 226409549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409189
    },
    {
        "content": "<p>The app-builder is in <code>MetaM</code>. <code>SynthM</code> is just some tabled-resolution metadata on top of <code>MetaM</code> and won't be helpful for this purpose.</p>",
        "id": 226409686,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613409277
    },
    {
        "content": "<p>I mention that only because it might be useful to see that metadata to prevent looping</p>",
        "id": 226409757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409346
    },
    {
        "content": "<p>Most leaf node instances won't need it</p>",
        "id": 226409820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409370
    },
    {
        "content": "<p>Tabled resolution can still do its loop-prevention magic even with these instance generators. Tabling is orthogonal to how the \"generator\" nodes actually generate the subgoals. (aside: one of my <code>SearchT</code> extensions implements a very generic tabling algorithm)</p>",
        "id": 226409921,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613409464
    },
    {
        "content": "<p>MetaM sounds good to me then</p>",
        "id": 226410101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613409601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226408019\">said</a>:</p>\n<blockquote>\n<p>...<br>\n  trigger = `({α : Type} [One α] [Add α] (n : Nat) -&gt; OfNat α n)<br>\n ...</p>\n</blockquote>\n<p>Aside: I think it should just be the trigger itself, e.g. <code>OfNat ?α ?n</code> since that is the only thing a generator has to go on -- as long as you are in <code>MetaM</code>, you can then try synthesizing <code>One ?α</code> and <code>Add ?α</code> yourself.</p>\n<p>EDIT: actually that would be insane since it would create separate <code>SynthM</code> invocations. You would need the original <code>SynthM</code> to solve the TC subgoals, and then trigger the generator function and pass it the instances. I don't have time right now to think about it carefully.</p>",
        "id": 226410863,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613410062
    },
    {
        "content": "<p>FYI I linked to this thread from <a href=\"https://github.com/dselsam/mathport/issues/17\">https://github.com/dselsam/mathport/issues/17</a></p>",
        "id": 226411237,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613410233
    },
    {
        "content": "<p>Yeah it can just be whatever data structure the SynthM is working on</p>",
        "id": 226411693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410452
    },
    {
        "content": "<p>although the postprocessing to put this into a usable form in the discrimination tree on <code>@[instanceGenerator]</code> has room to manipulate the term before entering it; the notation <code>  `({α : Type} [One α] [Add α] (n : Nat) -&gt; OfNat α n)</code> is mostly to make it easy for users to specify the signature</p>",
        "id": 226411960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410601
    },
    {
        "content": "<p>and as I alluded to above, this can all be hidden behind a macro so that you are writing something more like your earlier version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">instanceGenerator</span> <span class=\"n\">generateOfNat</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">generate</span> <span class=\"n\">goal</span> <span class=\"bp\">=</span> <span class=\"k\">do</span>\n    <span class=\"c1\">-- if n is concrete, do the recursion here to produce the instance in terms of bit0/bit1</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 226412155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410704
    },
    {
        "content": "<p>See my EDIT above: <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226410863\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport/near/226410863</a></p>",
        "id": 226412274,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613410771
    },
    {
        "content": "<p>That's sort of what I meant by preventing loops, if you restart the instance context you can get into trouble</p>",
        "id": 226412458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410858
    },
    {
        "content": "<p>I think that means that we need a version of <code>mkAppM</code> in SynthM that does typeclass inference in that monad instead of firing up a new one</p>",
        "id": 226412517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613410896
    },
    {
        "content": "<p>Currently in TC, at each node the generated instance is constructed before the subgoals are solved, in terms of the metavariables representing the subgoals. You might need to generalize this part, so that your <code>generate</code> function is executed eagerly on these arguments instead of just being applied to them (and so can only inspect non-metavariable goals, e.g. <code>n</code> in the <code>OfNat</code> example)</p>",
        "id": 226412812,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613411053
    },
    {
        "content": "<p>In this example, the fact that the signature is <code>{α : Type} [One α] [Add α] (n : Nat) : OfNat α n</code> means that the ambient TC process is responsible for supplying values of <code>One</code> and <code>Add</code>. The generator only has to create an instance once these are known</p>",
        "id": 226413037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613411183
    },
    {
        "content": "<p>I suppose it's possible to hand these subgoals to the generator and require it to call some function to continue TC inference on those subgoals, but that seems like eliminable boilerplate unless the generator somehow wants to control the timing of this resolution</p>",
        "id": 226413149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613411269
    },
    {
        "content": "<p>Also you somehow need to signal what of the goal needs to be concrete, for example <code>n</code> has to not be a metavariable when the generator is called, or at least it needs to be considered for calling again when <code>n</code> is resolved</p>",
        "id": 226413351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613411388
    },
    {
        "content": "<p>possibly the usual rules about TC outParams and such are sufficient</p>",
        "id": 226413431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613411417
    },
    {
        "content": "<p>Maybe all you need is a way to register an <code>Expr -&gt; MetaM Expr</code> postprocessor for a regular instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instBits2Nat</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">@[postprocessFor instBits2Nat]</span> <span class=\"kd\">def</span> <span class=\"n\">expandBits2Nat</span> <span class=\"o\">(</span><span class=\"n\">instVal</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">instVal</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">instBits2Nat</span> <span class=\"n\">_</span> <span class=\"n\">one</span> <span class=\"n\">add</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"c\">/-</span><span class=\"cm\"> recurse on n, build bit0/bit1 term -/</span>\n</code></pre></div>\n<p>Then this postprocess function could be called here: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319\">https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319</a></p>",
        "id": 226414027,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613411732
    },
    {
        "content": "<p>What would go in the <code>...</code>? <code>sorry</code>?</p>",
        "id": 226414227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613411853
    },
    {
        "content": "<p>Because I'm considering in particular the case where the instance is allowed to fail for some values of its arguments, like my earlier example of <code>instance generatePrime : prime n := ...</code></p>",
        "id": 226414368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613411939
    },
    {
        "content": "<p>There should be some front-end way of not needing to provide that value at all, e.g. with your <code>InstanceGenerator</code> type that takes a target and a post-process function. The point of the comment was that it shouldn't be <code>generate</code>, it should be <code>postprocess</code> and it should see the metavariables corresponding to the TC subgoals.</p>",
        "id": 226414390,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613411952
    },
    {
        "content": "<p>It wouldn't be the end of the world to use <code>sorry</code> there, since as you say it's going to be postprocessed away</p>",
        "id": 226414518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613412016
    },
    {
        "content": "<p>although if the instance generator fails during postprocessing you might be in deep trouble</p>",
        "id": 226414594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613412053
    },
    {
        "content": "<p>Syntactically I would probably prefer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[instanceGenerator]</span>\n<span class=\"kd\">def</span> <span class=\"n\">expandBits2Nat</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">InstanceGenerator</span> <span class=\"o\">(</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">postProcess</span> <span class=\"o\">(</span><span class=\"n\">instVal</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226414740,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613412129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/mathport/near/226414594\">said</a>:</p>\n<blockquote>\n<p>although if the instance generator fails during postprocessing you might be in deep trouble</p>\n</blockquote>\n<p>I changed it to <code>MetaM (Option Expr)</code> in the example.</p>",
        "id": 226414807,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613412179
    },
    {
        "content": "<p>I suppose that can be transformed to what I mentioned, if attribute macros have that much power, but that's quite a lie of a type signature</p>",
        "id": 226414835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613412187
    },
    {
        "content": "<p>when is the postprocessor called? I meant that if it fails you still want to be able to try the next instance</p>",
        "id": 226414977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613412252
    },
    {
        "content": "<p>Here: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319\">https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/SynthInstance.lean#L319</a><br>\nYou just return <code>none</code> if it fails, and it is as if the types didn't unify in a normal TC generation step.</p>",
        "id": 226415136,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613412354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Here is a lightweight implementation of the instance-post-processor proposal: <a href=\"https://github.com/dselsam/lean4/commit/c3c74f8ac273e93dfd6340cf94bf0cfb1f867286\">https://github.com/dselsam/lean4/commit/c3c74f8ac273e93dfd6340cf94bf0cfb1f867286</a> Can you please play around with it and see if it supports all the use-cases you had in mind?</p>",
        "id": 226746425,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613606217
    },
    {
        "content": "<p>Well, I don't know how to compile lean 4 yet but I can guess based on the code. Is the <code>nat2Bits</code> function required in this implementation? I think I would rather have <code>instBits2Nat</code> be an axiom or, even better, something that doesn't type check, so that if the postprocessor fails to do its job then an error is triggered</p>",
        "id": 226747933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613607069
    },
    {
        "content": "<p>It can be a constant as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[instance]</span> <span class=\"kd\">constant</span> <span class=\"n\">instBits2Nat</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 226750981,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613609359
    },
    {
        "content": "<p>We can nail down ergonomics later though -- the more salient question is whether the capability is adequate.</p>",
        "id": 226751125,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613609458
    },
    {
        "content": "<p>I think so. What happens to the <code>\"foo\"</code> error message if it fails? It would be nice for this to show up in the instance trace, but not essential</p>",
        "id": 226754561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613612408
    },
    {
        "content": "<p>Good question. In the version I pushed, <code>synth</code> does not catch that exception, so you just see e.g. <code>/home/dselsam/omega/lean4/tests/lean/instancePostProcessor.lean:44:8: error: foo</code>. That is a programmer error though -- a post-processor can fail gracefully by returning <code>pure none</code>.</p>",
        "id": 226755256,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613613076
    },
    {
        "content": "<p>There was an example that came up recently about fin numerals which are appropriately bounded. I haven't tested this but hopefully this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Meta</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Fin2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span>  <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">isLt</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ble</span> <span class=\"n\">n</span> <span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Fin2.OfNat</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ble</span> <span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">@[instance]</span> <span class=\"kd\">axiom</span> <span class=\"n\">finOfNatFake</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">@[instancePostProcessor finOfNatFake]</span>\n<span class=\"kd\">def</span> <span class=\"n\">finOfNatPostProcessor</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Meta.InstancePostProcessor</span> <span class=\"n\">where</span>\n  <span class=\"n\">apply</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">ei</span><span class=\"o\">,</span> <span class=\"n\">en</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"n\">e.getAppArgs</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"foo\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">i</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">ei</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">natLit</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">n</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">en</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">natLit</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n    <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">`</span><span class=\"n\">Fin.OfNat</span><span class=\"o\">)</span> <span class=\"n\">ei</span> <span class=\"n\">en</span> <span class=\"bp\">$</span>\n      <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Eq.refl</span> <span class=\"o\">[</span><span class=\"n\">levelOne</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin2</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Fin2</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Fin2</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin2</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">Fin2</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>(I'm redeclaring <code>Fin</code> so that the existing instance doesn't trigger as fallback.)</p>",
        "id": 226758668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613616910
    },
    {
        "content": "<p>Your example exposes an issue :) Currently when no post-processor succeeds, the axiom <code>finOfNatFake</code> remains in the proof. Your example has a few small errors so FYI here is a version that runs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Meta</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Fin2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span>  <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">isLt</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ble</span> <span class=\"n\">n</span> <span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Fin2.OfNat</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ble</span> <span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">@[instance]</span> <span class=\"kd\">axiom</span> <span class=\"n\">finOfNatFake</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">@[instancePostProcessor finOfNatFake]</span>\n<span class=\"kd\">def</span> <span class=\"n\">finOfNatPostProcessor</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Meta.InstancePostProcessor</span> <span class=\"n\">where</span>\n  <span class=\"n\">apply</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">ei</span><span class=\"o\">,</span> <span class=\"n\">en</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">e.getAppArgs.mapM</span> <span class=\"bp\">λ</span> <span class=\"n\">arg</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">arg</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">arg</span>\n      <span class=\"k\">let</span> <span class=\"n\">arg'</span> <span class=\"bp\">←</span> <span class=\"n\">whnfD</span> <span class=\"n\">arg</span>\n      <span class=\"n\">pure</span> <span class=\"n\">arg'</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"foo\"</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">ei.natLit</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">en.natLit</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">none</span> <span class=\"k\">else</span>\n       <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">`</span><span class=\"n\">Fin2.OfNat</span><span class=\"o\">)</span> <span class=\"n\">ei</span> <span class=\"n\">en</span> <span class=\"bp\">$</span>\n         <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Eq.refl</span> <span class=\"o\">[</span><span class=\"n\">levelOne</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">other</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pure</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Fin2</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin2</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- whoops, works with `finOfNatFake`</span>\n</code></pre></div>",
        "id": 226759912,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613618267
    },
    {
        "content": "<p>Maybe <em>if</em> there are post-processors for an instance, then it is a failure if none of them work</p>",
        "id": 226759983,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613618321
    },
    {
        "content": "<p>Yeah, I don't think it's a problem if there is only one postprocessor per instance, and it overrides whatever match status you get from the original. That makes more sense with the original model anyway</p>",
        "id": 226760096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613618441
    },
    {
        "content": "<p>In fact, I think it is dangerous to allow multiple postprocessors on one instance, because if the first one modifies the expression and the second one expects it to be a constant application then you will hit that <code>throwError \"foo\"</code> line</p>",
        "id": 226760141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613618519
    },
    {
        "content": "<p>FYI the commit above just picks the first post-processor that doesn't return <code>none</code>. It doesn't iterate multiple post-processors.</p>",
        "id": 226760385,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1613618792
    }
]
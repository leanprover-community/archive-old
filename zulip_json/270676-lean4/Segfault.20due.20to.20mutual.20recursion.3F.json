[
    {
        "content": "<p>I'm on the LEAN4 nightly, and I've encountered a segfault when implementing a custom <code>Parser</code> monad to write a hand written recursive-descent parser. <a href=\"https://gist.github.com/bollu/a4badaa83659860fdc953245b85a8d1e#running\">Here's a full gist with the repro</a>. I'm on LEAN4 commit <code>f4759c9a223f</code></p>\n<p>I've pasted the program here for ease-of-use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Maybe</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">ok</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Maybe</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">err</span><span class=\"o\">:</span> <span class=\"n\">Maybe</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n   <span class=\"n\">runP</span><span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Maybe</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ppure</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">):</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">runP</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Maybe.ok</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pbind</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">pa</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a2pb</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">):</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n   <span class=\"o\">{</span> <span class=\"n\">runP</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">pa.runP</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n            <span class=\"bp\">|</span> <span class=\"n\">Maybe.ok</span> <span class=\"o\">(</span><span class=\"n\">s'</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a2pb</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">runP</span>  <span class=\"n\">s'</span>\n            <span class=\"bp\">|</span> <span class=\"n\">Maybe.err</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Maybe.err</span>\n   <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"n\">ppure</span><span class=\"o\">,</span> <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"n\">pbind</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pfail</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">runP</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">Maybe.err</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">pfail</span>\n\n<span class=\"kd\">mutual</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">pregion</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>  <span class=\"k\">do</span>\n  <span class=\"n\">pblock</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">pop</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">pregion</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">pblock</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n   <span class=\"n\">pop</span>\n<span class=\"kd\">end</span>  <span class=\"c1\">-- end mutual</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span><span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>Am I violating some contract that causes this program to crash? I currently suspect that the <code>mutual</code> block I have somehow violates something. However, it's dead code (<code>main</code> doesn't invoke it!) so I'm not sure what the actual problem is.</p>",
        "id": 255330019,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1632881005
    },
    {
        "content": "<p>I would suspect the problem is the combination of <code>mutual</code> and <code>partial</code>. You should be using one or the other, not both.</p>",
        "id": 255330248,
        "sender_full_name": "Mac",
        "timestamp": 1632881188
    },
    {
        "content": "<p>What if I do really need both? (mutually recursive functions whose termination is too complicated to prove, and are hence <code>partial</code> for practical purposes.)</p>\n<p>Also, is this a bug?</p>",
        "id": 255330328,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1632881274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> partial definitions can already be written in a mutual recursive manner but just unpacking them. The <code>partial</code> definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>\n</code></pre></div>\n<p>is essentially equivalent to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">fooImpl</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>\n<span class=\"kd\">@[implementedBy fooImpl]</span> <span class=\"kd\">constant</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">T</span>\n</code></pre></div>",
        "id": 255330516,
        "sender_full_name": "Mac",
        "timestamp": 1632881407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I don't understand how to extend this to a definition of <code>bar</code> that depends on <code>foo</code>. I naively tried:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">fooImpl</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">barImpl</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n<span class=\"kd\">@[implementedBy fooImpl]</span> <span class=\"kd\">constant</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n<span class=\"kd\">@[implementedBy barImpl]</span> <span class=\"kd\">constant</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n</code></pre></div>\n<p>which doesn't work. Could you please show me how? :)</p>",
        "id": 255330751,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1632881638
    },
    {
        "content": "<p>This should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n<span class=\"kd\">constant</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">fooImpl</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">barImpl</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">implementedBy</span> <span class=\"n\">fooImpl</span><span class=\"o\">]</span> <span class=\"n\">foo</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">implementedBy</span> <span class=\"n\">barImpl</span><span class=\"o\">]</span> <span class=\"n\">bar</span>\n</code></pre></div>",
        "id": 255330886,
        "sender_full_name": "Mac",
        "timestamp": 1632881746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130575\">Siddharth Bhat</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255330328\">said</a>:</p>\n<blockquote>\n<p>Also, is this a bug?</p>\n</blockquote>\n<p>Yes. Lean should not be segfaulting. My point was that you are doing something that is likely very unexpected (combining <code>mutual</code> and <code>partial</code>) and thus it was probably not well tested (resulting in said segfault).</p>",
        "id": 255331104,
        "sender_full_name": "Mac",
        "timestamp": 1632881928
    },
    {
        "content": "<p>Interesting, the suggested change fixes the segfault :) Thanks <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> , I'll file a bug report and use the workaround for now.</p>",
        "id": 255331266,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1632882085
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> I filed an issue: <a href=\"https://github.com/leanprover/lean4/issues/697\">https://github.com/leanprover/lean4/issues/697</a></p>",
        "id": 255331784,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1632882499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255331104\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130575\">Siddharth Bhat</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255330328\">said</a>:</p>\n<blockquote>\n<p>Also, is this a bug?</p>\n</blockquote>\n<p>Yes. Lean should not be segfaulting. My point was that you are doing something that is likely very unexpected (combining <code>mutual</code> and <code>partial</code>) and thus it was probably not well tested (resulting in said segfault).</p>\n</blockquote>\n<p>I have used partial and mutual together many times without issue. All definitions in the block must be all-<code>partial</code> or all not, but otherwise it works just as you would expect.</p>",
        "id": 255338701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632888262
    },
    {
        "content": "<p>The fact that the recursion is completely unguarded here might be an issue though (mutual functions are usually functions with at least one argument), and my guess is that it is hitting an internal evaluation limit when constructing the closed terms <code>pregion</code>, <code>pop</code>, <code>pblock</code></p>",
        "id": 255338866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632888439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255338701\">said</a>:</p>\n<blockquote>\n<p>I have used partial and mutual together many times without issue. All definitions in the block must be all-<code>partial</code> or all not, but otherwise it works just as you would expect.</p>\n</blockquote>\n<p>In that case, would it make more sense for <code>parital</code> to be a modifier to <code>mutual</code> in such cases rather than part of each <code>def</code>?</p>",
        "id": 255340888,
        "sender_full_name": "Mac",
        "timestamp": 1632890313
    },
    {
        "content": "<p>There are several features of the declarations of the mutual block that could arguably be moved to the header. That was the lean 3 design. My understanding is that the lean 4 design is intended to make mutual defs read just like regular defs, and enable more flexibility in the way the individual definitions are constructed</p>",
        "id": 255341039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890453
    },
    {
        "content": "<p>My reason for saying this is that <code>mutual</code> tends to imply a lot of complex kernel type checking  to make sure the recursion is valid. With all partial definitions, all that is skipped. The only thing the block is doing at that point is allowing for forward reference. Right?</p>",
        "id": 255341198,
        "sender_full_name": "Mac",
        "timestamp": 1632890600
    },
    {
        "content": "<p>The heavy distinction there feels like it should be clearer.</p>",
        "id": 255341260,
        "sender_full_name": "Mac",
        "timestamp": 1632890650
    },
    {
        "content": "<p>The elaboration of <code>partial</code> and non-<code>partial</code> mutual defs is the same</p>",
        "id": 255341266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What do you mean by that?</p>",
        "id": 255341299,
        "sender_full_name": "Mac",
        "timestamp": 1632890699
    },
    {
        "content": "<p>The definitions are typechecked in the same context, with the same things in scope</p>",
        "id": 255341330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890731
    },
    {
        "content": "<p>the only difference is in the backend compilation in the kernel</p>",
        "id": 255341337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890744
    },
    {
        "content": "<p>they also produce the same compiled code</p>",
        "id": 255341390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255341337\">said</a>:</p>\n<blockquote>\n<p>the only difference is in the backend compilation in the kernel</p>\n</blockquote>\n<p>which is why I defined the difference as \"complex kernel type checking\"</p>",
        "id": 255341409,
        "sender_full_name": "Mac",
        "timestamp": 1632890799
    },
    {
        "content": "<p>I'm not sure I understand your suggestion</p>",
        "id": 255341430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890830
    },
    {
        "content": "<p>Do you think that <code>unsafe</code> should be divorced from the line with the <code>def</code> as well?</p>",
        "id": 255341475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890882
    },
    {
        "content": "<p>If it's a large mutual block, it might not be obvious that the def is in a block at all, in which case the displaced <code>partial</code> could be confusing</p>",
        "id": 255341543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632890934
    },
    {
        "content": "<p>That is a weird argument, if its a large mutual block that one has forgotten is mutual, it might be just as confusing where the recursive functions come from (as one normally assume they are defined earlier in the file rather than later).</p>",
        "id": 255341667,
        "sender_full_name": "Mac",
        "timestamp": 1632891054
    },
    {
        "content": "<p>My view was simply that as the termination checking occurs w.r.t.  the entire <code>mutual</code> block and <code>partial</code> essentially means 'don't do termination checking', it seems most logica; (to me) to apply that to the <code>mutual</code> which is doing said checking as opposed to the <code>def</code> which is not.</p>",
        "id": 255341782,
        "sender_full_name": "Mac",
        "timestamp": 1632891154
    },
    {
        "content": "<p>The application of <code>partial</code>, or <code>unsafe</code>, is restricted to apply to a block at a time, which is why all defs in a block have to have the same <code>partial</code>/<code>unsafe</code> setting</p>",
        "id": 255341929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891287
    },
    {
        "content": "<p>For instance, the new <code>termination_by</code> statement for wf recursion will apply to the end of the <code>mutual</code> block instead of at each <code>def</code> -- so for consistency it makes sense to apply the <code>partial</code> (its opposite, essentially) to the block as well.</p>",
        "id": 255341930,
        "sender_full_name": "Mac",
        "timestamp": 1632891289
    },
    {
        "content": "<p>The fact that it is written on a def is only for convenience / style</p>",
        "id": 255341958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think it would be hard to argue that repeating <code>partial</code> multiple times is more 'convenient' than doing it once.</p>",
        "id": 255341989,
        "sender_full_name": "Mac",
        "timestamp": 1632891356
    },
    {
        "content": "<p>Perhaps you might not feel the same way if you have used lean 3 mutual defs</p>",
        "id": 255342044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891392
    },
    {
        "content": "<p>how so?</p>",
        "id": 255342074,
        "sender_full_name": "Mac",
        "timestamp": 1632891430
    },
    {
        "content": "<p>It also violates a common adage of CS: don't repeat yourself (DRY).</p>",
        "id": 255342164,
        "sender_full_name": "Mac",
        "timestamp": 1632891501
    },
    {
        "content": "<p>Also, Lean is already quite fond of this in other places -- i.e., DRY is what things like <code>universe</code> and <code>variable</code> are for (which also apply to the whole block).</p>",
        "id": 255342200,
        "sender_full_name": "Mac",
        "timestamp": 1632891541
    },
    {
        "content": "<p>Like I said, lean 3 mutual defs don't repeat anything: <code>meta</code>/<code>noncomputable</code> shows up only once, in the mutual header, as well as parameters that aren't participating in the recursion. It is followed by a list of <code>with</code> defs that give the body of the definitions. In actual use, <code>with</code> has an unfortunate status as not quite a def; it means that you have to learn a different syntax for defs and you can't use other commands in the block</p>",
        "id": 255342313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891609
    },
    {
        "content": "<p>Keep in mind, when proposing to change this, that this is literally what lean 4 changed away from</p>",
        "id": 255342419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255342313\">said</a>:</p>\n<blockquote>\n<p>as well as parameters that aren't participating in the recursion.</p>\n</blockquote>\n<p>I can definitely see why this would be annoying</p>",
        "id": 255342442,
        "sender_full_name": "Mac",
        "timestamp": 1632891686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Also, fyi, I did use Lean 3 myself. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>  I don't remember having a problem with <code>mutual</code> there.</p>",
        "id": 255342524,
        "sender_full_name": "Mac",
        "timestamp": 1632891728
    },
    {
        "content": "<p>Lean 4 also does the parameter thing differently when you call a function recursively, even without <code>mutual</code> - you need to repeat parameters in the function call</p>",
        "id": 255342547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891749
    },
    {
        "content": "<p>the lean 3 way is DRY but also confusing</p>",
        "id": 255342565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Yeah I am quite with that. That always tripped me up in Lean 3.</p>",
        "id": 255342571,
        "sender_full_name": "Mac",
        "timestamp": 1632891779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255342565\">said</a>:</p>\n<blockquote>\n<p>the lean 3 way is DRY but also confusing</p>\n</blockquote>\n<p>There is also the fact that it just wouldn't work with partial defs at all.</p>",
        "id": 255342606,
        "sender_full_name": "Mac",
        "timestamp": 1632891819
    },
    {
        "content": "<p>how so?</p>",
        "id": 255342619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891833
    },
    {
        "content": "<p>A partial def has no delineation between recursive and non-recursive parameters so the idea wouldn't really apply there, right?</p>",
        "id": 255342694,
        "sender_full_name": "Mac",
        "timestamp": 1632891886
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 255342695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891887
    },
    {
        "content": "<p>How does <code>meta</code> know that I don't want to recur on both arguments?</p>",
        "id": 255342721,
        "sender_full_name": "Mac",
        "timestamp": 1632891924
    },
    {
        "content": "<p>because only one is right of the colon</p>",
        "id": 255342736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891942
    },
    {
        "content": "<p>that's how the rule goes in lean 3</p>",
        "id": 255342788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632891965
    },
    {
        "content": "<p>Yeah, it ties pattern matching with recursion, which I think is the bigger problem there.</p>",
        "id": 255342800,
        "sender_full_name": "Mac",
        "timestamp": 1632891981
    },
    {
        "content": "<p>you don't have to do any actual pattern matching though</p>",
        "id": 255342861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632892074
    },
    {
        "content": "<p>Yes but it ties the pattern-matching syntax with recursion, which is weird. And it would make writing most <code>partial</code> functions (which tend to be structure in normal CS style) very weird.</p>",
        "id": 255342943,
        "sender_full_name": "Mac",
        "timestamp": 1632892128
    },
    {
        "content": "<p>As the boilerplate of <code>partial def foo : a -&gt; b -&gt; c | a, b =&gt;</code> would be  quite common.</p>",
        "id": 255342977,
        "sender_full_name": "Mac",
        "timestamp": 1632892177
    },
    {
        "content": "<p>Furthermore, <code>def</code> alternates in Lean 4 are equivalent to an internal <code>match</code> (which also makes me quite happy), this style of delineating recursion wouldn't even be logical anymore in Lean 4.</p>",
        "id": 255343063,
        "sender_full_name": "Mac",
        "timestamp": 1632892242
    },
    {
        "content": "<p>My point being that the parameter part of old <code>mutual</code> is much more than just DRY it also encapsulates/demands more information than one might wish to provide (and, as you said, breaks consistency).</p>",
        "id": 255343203,
        "sender_full_name": "Mac",
        "timestamp": 1632892370
    },
    {
        "content": "<p>On the other hand <code>partial</code> is a modifier, and some modifiers already only work in certain circumstances, so there is much less consistency to break (if any).</p>",
        "id": 255343236,
        "sender_full_name": "Mac",
        "timestamp": 1632892408
    },
    {
        "content": "<p>Note that you can still have \"parameters\" in lean 4 style recursion, by using <code>variable</code>. I haven't decided whether this is a good thing or inconsistent yet</p>",
        "id": 255343334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632892483
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo'</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo'</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 255343438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632892577
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Personally, if I were writing a style guide, I would ban explicit binders in <code>variable</code>, as it makes the parameters one needs to specify of  a <code>def</code> (and there order) hard to figure out.</p>",
        "id": 255343446,
        "sender_full_name": "Mac",
        "timestamp": 1632892586
    },
    {
        "content": "<p>Especially if the <code>def</code> is far removed from the <code>variable</code>.</p>",
        "id": 255343582,
        "sender_full_name": "Mac",
        "timestamp": 1632892717
    },
    {
        "content": "<p>looking at lean 4 itself it seems like about 1/3 of <code>variable</code> lines violate your style guide</p>",
        "id": 255343607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632892741
    },
    {
        "content": "<p>I am aware. :(</p>",
        "id": 255343619,
        "sender_full_name": "Mac",
        "timestamp": 1632892752
    },
    {
        "content": "<p>It has caused me much pain.</p>",
        "id": 255343634,
        "sender_full_name": "Mac",
        "timestamp": 1632892770
    },
    {
        "content": "<p>And in mathlib3 there are at least 1400 occurrences. :-)</p>",
        "id": 255343715,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632892835
    },
    {
        "content": "<p>My only exception to this rule would be the the binder meant to be used with dot notation (which I would demand be named <code>self</code>).</p>",
        "id": 255343729,
        "sender_full_name": "Mac",
        "timestamp": 1632892852
    },
    {
        "content": "<p>Regarding determining the parameters of a <code>def</code>, I use <code>#print</code> for that</p>",
        "id": 255343752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632892885
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> while I like Lean's interactivity, having to go right a <code>#print</code> statement while deep in a function is not fun.</p>",
        "id": 255343941,
        "sender_full_name": "Mac",
        "timestamp": 1632893057
    },
    {
        "content": "<p>And is also impossible when I am viewing Lean code in a non-interactive manner.</p>",
        "id": 255343979,
        "sender_full_name": "Mac",
        "timestamp": 1632893095
    },
    {
        "content": "<p>well, one day we will have <code>#print</code> at expression/tactic scope</p>",
        "id": 255343989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893105
    },
    {
        "content": "<p>Honestly, I would much prefer to see it at an editor level through a command.</p>",
        "id": 255344016,
        "sender_full_name": "Mac",
        "timestamp": 1632893135
    },
    {
        "content": "<p>hover already fills that niche to a great extent</p>",
        "id": 255344029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893157
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> not when there are elaboration errors in your code. :(</p>",
        "id": 255344079,
        "sender_full_name": "Mac",
        "timestamp": 1632893178
    },
    {
        "content": "<p>which is quite common when writing a function.</p>",
        "id": 255344100,
        "sender_full_name": "Mac",
        "timestamp": 1632893206
    },
    {
        "content": "<p>and  even more common when said error is the thing you are trying to fix by verifying types/defs.  XD</p>",
        "id": 255344128,
        "sender_full_name": "Mac",
        "timestamp": 1632893243
    },
    {
        "content": "<p>usually if lean has enough understanding to give you a type error at a function application, it will be able to give you a hover on the function</p>",
        "id": 255344195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893293
    },
    {
        "content": "<p>yeah, but such types are generally less than useful as they are some intermediate output of the inference engine (i.e., with metavariables and dependent types) and thus unreadable to my unexpert eyes.</p>",
        "id": 255344305,
        "sender_full_name": "Mac",
        "timestamp": 1632893402
    },
    {
        "content": "<p>also, if the problem is syntactic hovers may not even exist.</p>",
        "id": 255344344,
        "sender_full_name": "Mac",
        "timestamp": 1632893424
    },
    {
        "content": "<p>when I hover on a constant name, the output looks like the original type of the constant, before unification</p>",
        "id": 255344465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893531
    },
    {
        "content": "<p>although I would <em>really</em> like hovering on the name of a definition to also work and act just like hovering on a use of that definition</p>",
        "id": 255344506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893587
    },
    {
        "content": "<p>that would solve your parameters issue pretty well</p>",
        "id": 255344512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893596
    },
    {
        "content": "<p>Oh, you mean the actual function itself, in that case, yeah, but that is rarely my problem.</p>",
        "id": 255344519,
        "sender_full_name": "Mac",
        "timestamp": 1632893602
    },
    {
        "content": "<p>as in, if you are looking at some <code>def foo</code> that picks up some unknown set of variables above, you can hover on <code>foo</code> to find out the actual type</p>",
        "id": 255344591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255344512\">said</a>:</p>\n<blockquote>\n<p>that would solve your parameters issue pretty well</p>\n</blockquote>\n<p>I think you greatly underestimate how much Lean code I read on GitHub.</p>",
        "id": 255344594,
        "sender_full_name": "Mac",
        "timestamp": 1632893658
    },
    {
        "content": "<p>Also, I have been having major problems getting Lean to properly find definitions when browsing its source at all.</p>",
        "id": 255344611,
        "sender_full_name": "Mac",
        "timestamp": 1632893688
    },
    {
        "content": "<p>I gave up on reading proof assistants from raw code long ago</p>",
        "id": 255344612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893688
    },
    {
        "content": "<p>Most of my go-to-defs find nothing.</p>",
        "id": 255344619,
        "sender_full_name": "Mac",
        "timestamp": 1632893699
    },
    {
        "content": "<p>can you <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 255344655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893738
    },
    {
        "content": "<p>Note that this is only when browsing the cloned repo, not in the distribution acquired through <code>elan</code>.</p>",
        "id": 255344660,
        "sender_full_name": "Mac",
        "timestamp": 1632893741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> How does one <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> an interactivity issue?</p>",
        "id": 255344715,
        "sender_full_name": "Mac",
        "timestamp": 1632893763
    },
    {
        "content": "<p>there are interactive tests</p>",
        "id": 255344729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893778
    },
    {
        "content": "<p>I suspect this may be due to the fact I often update the code without rebuilding it. Since rebuilding still takes a good 15-30mins on my machine.</p>",
        "id": 255344743,
        "sender_full_name": "Mac",
        "timestamp": 1632893789
    },
    {
        "content": "<p>but the usual way to do it here is to set up something reproducible and describe what you are doing and what you see</p>",
        "id": 255344762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632893812
    },
    {
        "content": "<p>Okay, just to demonstrate how this works for me (and how I don't understand interactivity <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>):</p>\n<ul>\n<li>I open up my local copy of the <code>lean4</code> repo in VSCode</li>\n<li>I open up <code>src/Lean/Parser.lean</code></li>\n<li>Wait for elaboration to finish</li>\n<li>Hover over <code>Parenthesizer</code> in <code>ident.parenthesizer</code></li>\n<li>Right-click 'Go to Definition'</li>\n<li>Get \"no definition found for 'Parenthesize'\"</li>\n</ul>",
        "id": 255345029,
        "sender_full_name": "Mac",
        "timestamp": 1632894040
    },
    {
        "content": "<p>That works for me (go-to-definition takes me to <code>Parenthesizer</code>); I have vscode, just updated to master, never built, vscode-lean4 v0.0.33</p>",
        "id": 255345337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632894356
    },
    {
        "content": "<p>Does it work if you have an older build with the proper settings for <code>elan</code>? That is my case.</p>",
        "id": 255345414,
        "sender_full_name": "Mac",
        "timestamp": 1632894403
    },
    {
        "content": "<p>I have my <code>elan</code> set up in the folder as described here: <a href=\"https://leanprover.github.io/lean4/doc/dev/index.html#dev-setup-using-elan\">https://leanprover.github.io/lean4/doc/dev/index.html#dev-setup-using-elan</a></p>",
        "id": 255345487,
        "sender_full_name": "Mac",
        "timestamp": 1632894476
    },
    {
        "content": "<p>I just ran <code>elan update leanprover/lean4:nightly</code>, still works</p>",
        "id": 255345538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632894494
    },
    {
        "content": "<p>I meant having overrides set for the  repo root and <code>src</code> dirs</p>",
        "id": 255345575,
        "sender_full_name": "Mac",
        "timestamp": 1632894527
    },
    {
        "content": "<p>I have elan set up to use nightly, not master</p>",
        "id": 255345584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632894536
    },
    {
        "content": "<p>The dev setup for <code>lean4</code> is suppose to look like the following (as described <a href=\"https://leanprover.github.io/lean4/doc/dev/index.html#dev-setup-using-elan\">here</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"c1\"># in the Lean rootdir</span>\nelan toolchain link lean4 build/release/stage1\nelan toolchain link lean4-stage0 build/release/stage0\n<span class=\"c1\"># make `lean` etc. point to stage1 in the rootdir and subdirs</span>\nelan override <span class=\"nb\">set</span> lean4\n<span class=\"nb\">cd</span> src\n<span class=\"c1\"># make `lean` etc. point to stage0 anywhere inside `src`</span>\nelan override <span class=\"nb\">set</span> lean4-stage0\n</code></pre></div>",
        "id": 255345604,
        "sender_full_name": "Mac",
        "timestamp": 1632894567
    },
    {
        "content": "<p>I haven't actually built lean 4, the stage 0 stuff scares me off</p>",
        "id": 255345712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632894630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255343446\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> Personally, if I were writing a style guide, I would ban explicit binders in <code>variable</code>, as it makes the parameters one needs to specify of  a <code>def</code> (and there order) hard to figure out.</p>\n</blockquote>\n<p>I think there are many places where it explicit binders in <code>variables</code> can be reasonably defended.</p>\n<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">base_class1</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">base_class2</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">base_class3</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mixin1</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mixin2</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mixin3</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_1</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_2</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_3</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_4</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"c1\">-- make `X` explicit (but don't repeat all the typeclass assumptions, DRY)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cool_construction</span> <span class=\"o\">[</span><span class=\"n\">mixin4</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foobar</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">somestuff</span> <span class=\"n\">involving</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">API_lemma_4</span> <span class=\"k\">from</span> <span class=\"n\">above.</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"c1\">-- from now on `X` can be implicit again</span>\n</code></pre></div>",
        "id": 255345720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632894636
    },
    {
        "content": "<p>This pattern is pretty common in mathlib, I think.</p>",
        "id": 255345745,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632894664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  wouldn't the following just be better? (if it was supported)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">base_class1</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">base_class2</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">base_class3</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mixin1</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mixin2</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mixin3</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_1</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_2</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_3</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">API_lemma_4</span> <span class=\"o\">:</span> <span class=\"n\">blabla</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- modify the binder in the def for just this def</span>\n<span class=\"kd\">def</span> <span class=\"n\">cool_construction</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mixin4</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">foobar</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">somestuff</span> <span class=\"n\">involving</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">API_lemma_4</span> <span class=\"k\">from</span> <span class=\"n\">above.</span>\n</code></pre></div>",
        "id": 255345825,
        "sender_full_name": "Mac",
        "timestamp": 1632894723
    },
    {
        "content": "<p>If that were supported, that would be quite useful. But somehow it has to work together with introducing fresh variables that can typically shadow names that were introduced by <code>variables</code> before. I don't have a good sense for how that would work. (Because I don't know anything about language design at all.)</p>\n<p>And nevertheless. Sometimes you want to make <code>X</code> explicit for 8 declarations in a row, so you put those in a <code>section</code> and add <code>variables (X)</code> to that section.</p>",
        "id": 255346015,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632894881
    },
    {
        "content": "<p>Note that there are also very reasonable situations where you want to make write <code>variables (R A B M N)</code> and make 5 variables explicit for the next 7 declarations.</p>",
        "id": 255346058,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632894927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255346015\">said</a>:</p>\n<blockquote>\n<p>hat can typically shadow names that were introduced by <code>variables</code> before.</p>\n</blockquote>\n<p>I know that is how it currently but I think being able to shadow a binder from <code>variable</code> is just more confusing. I view the idea behind <code>variable</code> being that, within, this section <code>x</code> is <code>X</code>. If that is not the case, I don't really feel like the <code>def</code> should be in the  same section.</p>",
        "id": 255346190,
        "sender_full_name": "Mac",
        "timestamp": 1632895036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255346058\">said</a>:</p>\n<blockquote>\n<p>write <code>variables (R A B M N)</code> and make 5 variables explicit for the next 7 declarations.</p>\n</blockquote>\n<p>Where? Having  multiple functions with the same 5 explicit variables (and 5 explicit arguments in the first place) is a bit concerning. Generally, if a function is taking that many explicit parameters, you should probably be passing a struct with said fields instead.</p>\n<p>Though I guess one reasonable exception / use case I can imagine would be explicit binders with defaults that are meant to be used only by named argument syntax.  In such cases, the order is unimportant and you can still use the function without specifying them (so shares more in common with an inferred binder than with other explicit binders) . However, unfortunately, since <code>variable</code> as its arguments at the start this is usually not possible.</p>\n<p>Even if it were, though, I don't wouldn't the fact that you can't tell from the definition which arguments are to be specify to it and which it infers or otherwise inherits from the surrounding scope. But I would be less opinionated on such cases.</p>",
        "id": 255346436,
        "sender_full_name": "Mac",
        "timestamp": 1632895214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>, for context, there are many examples in mathlib where we change many variables binders at once, e.g. <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/lie/tensor_product.lean#L77\">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/lie/tensor_product.lean#L77</a></p>",
        "id": 255346866,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632895540
    },
    {
        "content": "<p>(That one appears to be a record, but there are lots where we change 3 or 4 at a time.)</p>",
        "id": 255346988,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632895620
    },
    {
        "content": "<p>The expression <code>lift R L M N P f (m ⊗ₜ n)</code> just hurts me.</p>",
        "id": 255347032,
        "sender_full_name": "Mac",
        "timestamp": 1632895663
    },
    {
        "content": "<p>However, I suspect this has more to do with the nature of mathlib. I suspect that you rarely actually do apply those arguments explicitly and instead apply them through notation.</p>",
        "id": 255347199,
        "sender_full_name": "Mac",
        "timestamp": 1632895791
    },
    {
        "content": "<p>Three modules, a ring, a lie algebra, a linear map, and two vectors! Just maths. :-)</p>",
        "id": 255347289,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1632895830
    },
    {
        "content": "<blockquote>\n<p>you should probably be passing a struct with said fields instead.</p>\n</blockquote>\n<p>but without eta for records, this can cause defeq issues down the road, rigth? (just one objection)<br>\nAlso, this might be nice while setting up the API for that particular theory, but when applying it, users would constantly have to bundled up random types into a record, instead of just passing them directly to the functions.<br>\nIn 50% of the applications, unification can figure out the types, so you just write an <code>_</code>. But for those other 50%, we're really happy that the argument has explicit binding.</p>",
        "id": 255347298,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632895835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255347199\">said</a>:</p>\n<blockquote>\n<p>However, I suspect this has more to do with the nature of mathlib. I suspect that you rarely actually do apply those arguments explicitly and instead apply them through notation.</p>\n</blockquote>\n<p>I'm not so sure. Things like <code>lift R L M N P f</code> or very similar things are certainly not an uncommon thing in mathlib</p>",
        "id": 255347366,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632895905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/Segfault.20due.20to.20mutual.20recursion.3F/near/255347298\">said</a>:</p>\n<blockquote>\n<p>In 50% of the applications, unification can figure out the types, so you just write an <code>_</code>. But for those other 50%, we're really happy that the argument has explicit binding.</p>\n</blockquote>\n<p>In that case, wouldn't those arguments work better as implicit arguments (that are some times specified by name)? Since Lean 3 lacked named arguments, maybe that is why such formulations were so popular?</p>",
        "id": 255347452,
        "sender_full_name": "Mac",
        "timestamp": 1632895951
    },
    {
        "content": "<p>I agree that this is now a new feature that is quite exciting. And we'll have to do experiments to find out what the right balance is in using it.</p>",
        "id": 255347508,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632895992
    },
    {
        "content": "<p><code>_</code> is really short, so it makes \"a bit too much explicit variables\" really cheap.</p>",
        "id": 255347538,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632896020
    },
    {
        "content": "<p>If something is implicit, and 50% of the time you have to write <code>(base_ring := R)</code>, this will quickly make me wish that <code>R</code> was explicit.</p>",
        "id": 255347598,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632896060
    },
    {
        "content": "<p>But certainly, named variables provide a new potential!</p>",
        "id": 255347645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632896102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Also, I think my rules are more geared towards CS than theorem proving. In theorem proving you are likely to have <strong>a lot</strong> of parameters, whereas in CS, you tend to have relatively few.</p>",
        "id": 255347781,
        "sender_full_name": "Mac",
        "timestamp": 1632896195
    },
    {
        "content": "<p>Sure, I guess we can different variations in style guide for different areas</p>",
        "id": 255347823,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632896234
    },
    {
        "content": "<p>For instance, there are many places <code>variable</code> is used for <code>def</code>s that have one or two parameters, and thus it makes it hard to distinguish them from <code>def</code>s with none (and the same would be true in end-user code).</p>",
        "id": 255347910,
        "sender_full_name": "Mac",
        "timestamp": 1632896297
    },
    {
        "content": "<p>Just for the record: here is how you say \"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> be a manifold with corners\" in mathlib-speak:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uι</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uE</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uH</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uM</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 255347967,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1632896347
    },
    {
        "content": "<p>This is why I feel such explicit binders are not really explicit binders in theorem proving. They are things that on a paper proof would be implicit, but are made explicit mostly due to the limitations / requirements of the formalization.</p>",
        "id": 255348085,
        "sender_full_name": "Mac",
        "timestamp": 1632896435
    },
    {
        "content": "<p>Thus it makes much more since for them to be tossed in a <code>variable</code> header (as that is how it would appear in the paper proof).</p>",
        "id": 255348150,
        "sender_full_name": "Mac",
        "timestamp": 1632896473
    },
    {
        "content": "<p>In CS, on the other hand, the explicit binders are what you are expecting to see in the compiled functions signature. Thus, I think it is reasonable to expect to see them in signature of the <code>def</code> being compiled. The implicit / synthetic binders, however, are abstract fluff that is (usually) compiled away and therefore not part of the signature. Thus, it makes sense to stick them in some <code>variable</code> header (as they have to do with the abstraction that section is dealing with).</p>",
        "id": 255348502,
        "sender_full_name": "Mac",
        "timestamp": 1632896748
    }
]
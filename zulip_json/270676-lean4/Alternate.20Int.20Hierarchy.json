[
    {
        "content": "<p><strong>I am not sure whether or not this belongs here or in a different channel.</strong> However, I am writing it in Lean 4 so I am sticking it here. If it should go elsewhere, feel free to move it. </p>\n<p>I was exploring alternate definitions of <code>Nat</code>/<code>Int</code> and was curious if anyone saw any immediate flaws with this definition of numbers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">AltInt</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">PNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">PNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">PNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Option</span> <span class=\"n\">PNat</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Dipole</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Dipole</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Dipole</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NzInt</span> <span class=\"o\">:=</span> <span class=\"n\">Dipole</span> <span class=\"n\">PNat</span>\n<span class=\"kd\">def</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"n\">Option</span> <span class=\"n\">NzInt</span>\n</code></pre></div>\n<p>In particular, I am curious as to why Lean 4 proper doesn't go the <code>Int := zero | pos PNat | neg PNat</code> route for integers since that seems a lot simpler tan the <code>Int := ofNat Nat | negSucc Nat</code> that is currently used.</p>\n<p>It also allows for the following definition of natural (truncating) division (which I think is correct -- haven't proven it yet though) that seems much simpler than what is currently used in core (for one, it uses structural rather than well-founded recursion):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- using the defs above</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[matchPattern]</span> <span class=\"kd\">def</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"kd\">@[matchPattern]</span> <span class=\"kd\">def</span> <span class=\"n\">nonzero</span> <span class=\"o\">:</span> <span class=\"n\">PNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">some</span>\n<span class=\"kd\">@[matchPattern]</span> <span class=\"kd\">def</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">PNat.one</span>\n\n<span class=\"kd\">@[matchPattern]</span>\n<span class=\"kd\">def</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">one</span>\n<span class=\"bp\">|</span> <span class=\"n\">nonzero</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nonzero</span> <span class=\"o\">(</span><span class=\"n\">PNat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">PNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">succSubDivTrunc</span> <span class=\"o\">:</span>  <span class=\"n\">PNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">PNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">PNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.one</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.zero</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">succSubDivTrunc</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succSubDivTrunc</span> <span class=\"n\">m</span> <span class=\"n\">r</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">divTrunc</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">PNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">succSubDivTrunc</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">PNat</span>\n</code></pre></div>\n<p><strong>Any comments, insights, etc.?</strong> They would be much appreciated.</p>",
        "id": 240773164,
        "sender_full_name": "Mac",
        "timestamp": 1622407497
    },
    {
        "content": "<p>I'm surprised that you say a construction with three constructors is \"a lot simpler\" than a construction with two constructors. How are you going to prove associativity of addition using the three-constructor definition -- you have 27 cases to deal with I guess.</p>",
        "id": 240773505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622408010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy/near/240773505\">said</a>:</p>\n<blockquote>\n<p>I'm surprised that you say a construction with three constructors is \"a lot simpler\" than a construction with two constructors. How are you going to prove associativity of addition using the three-constructor definition -- you have 27 cases to deal with I guess.</p>\n</blockquote>\n<p>The constructors are nested though. So you prove associativity for the levels separately, greatly reducing the number of cases. You can then use the inner proofs in the proofs of the outer cases.</p>",
        "id": 240773636,
        "sender_full_name": "Mac",
        "timestamp": 1622408195
    },
    {
        "content": "<p>For example, for <code>Nat</code>, you can show that <code>a + b + nonzero c = nonzero (a + b + c) </code> and then use the associative property for <code>PNat</code> add to prove associativity for <code>Nat</code>.</p>",
        "id": 240773864,
        "sender_full_name": "Mac",
        "timestamp": 1622408543
    },
    {
        "content": "<p>Then why even define <code>PNat</code> (for the definition of <code>Int</code>), when it is clearly isomorphic to <code>Nat</code>?</p>",
        "id": 240774158,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622408962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy/near/240774158\">said</a>:</p>\n<blockquote>\n<p>Then why even define <code>PNat</code> (for the definition of <code>Int</code>), when it is clearly isomorphic to <code>Nat</code>?</p>\n</blockquote>\n<p>Because it is in many cases semantically different?  For example, the <code>divTrunc</code> definition wouldn't work for <code>Nat</code>. Sure I could pretend that<code>Nat</code>'s <code>zero</code> meant <code>one</code>, but that conceptual disconnect seems undesirable. Mathlib (version 3 at least) also defines a <code>pnat</code> (though that definition is propositional), so a desire for the conceptual distinction seems reasonable.</p>",
        "id": 240774426,
        "sender_full_name": "Mac",
        "timestamp": 1622409360
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 240774719,
        "sender_full_name": "David Renshaw",
        "timestamp": 1622409775
    },
    {
        "content": "<p>I was trying to do something similar ​as well as I found it more elegant</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">int</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">int</span>\n<span class=\"bp\">|</span> <span class=\"n\">pos_succ</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg_succ</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">int</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">int</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">`pos_succ (Nat.zero)` is the representation of +1</span>\n<span class=\"cm\">`neg_succ (Nat.zero)` is the representation for -1</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">int.incr</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"bp\">​</span><span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n <span class=\"bp\">​|</span> <span class=\"n\">int.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pos_succ</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero</span><span class=\"o\">)</span>\n <span class=\"bp\">​|</span> <span class=\"n\">pos_succ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pos_succ</span> <span class=\"o\">(</span><span class=\"n\">a.succ</span><span class=\"o\">)</span>\n <span class=\"bp\">​|</span> <span class=\"n\">neg_succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n   <span class=\"bp\">​</span><span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n   <span class=\"bp\">​|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">int.zero</span>\n   <span class=\"bp\">​|</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">neg_succ</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#reduce</span> <span class=\"o\">(</span><span class=\"n\">neg_succ</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">incr.incr.incr.incr.incr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">int.decr</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"bp\">​</span><span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n <span class=\"bp\">​|</span> <span class=\"n\">int.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">neg_succ</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero</span><span class=\"o\">)</span>\n <span class=\"bp\">​|</span> <span class=\"n\">neg_succ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">neg_succ</span> <span class=\"o\">(</span><span class=\"n\">a.succ</span><span class=\"o\">)</span>\n <span class=\"bp\">​|</span> <span class=\"n\">pos_succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n   <span class=\"bp\">​</span><span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n   <span class=\"bp\">​|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">int.zero</span>\n   <span class=\"bp\">​|</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pos_succ</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#reduce</span> <span class=\"o\">(</span><span class=\"n\">pos_succ</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decr.decr.decr.decr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add_int_Nat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n <span class=\"bp\">​</span><span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n <span class=\"bp\">​|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n <span class=\"bp\">​|</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add_int_Nat</span> <span class=\"n\">a.incr</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub_int_Nat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n     <span class=\"bp\">​</span><span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n     <span class=\"bp\">​|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n     <span class=\"bp\">​|</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub_int_Nat</span> <span class=\"n\">a.decr</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int</span> <span class=\"o\">:=</span>\n <span class=\"bp\">​</span><span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n <span class=\"bp\">​|</span> <span class=\"n\">int.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span>\n <span class=\"bp\">​|</span> <span class=\"n\">pos_succ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add_int_Nat</span> <span class=\"n\">b</span> <span class=\"n\">a.succ</span>\n <span class=\"bp\">​|</span> <span class=\"n\">neg_succ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub_int_Nat</span> <span class=\"n\">b</span> <span class=\"n\">a.succ</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">pos_succ</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg_succ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"c1\">-- pos_succ 2</span>\n</code></pre></div>\n<p>And I am indeed struggling to prove associativity</p>",
        "id": 244318985,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1624988375
    },
    {
        "content": "<p>One approach is to, regardless of the specific definition of <code>int</code>, start by defining its eliminator based on an <code>equiv</code>, and prove it satisfies the correct equations. After that, there will be no more case analyses. Now you can define <code>add</code> and <code>mul</code>.</p>",
        "id": 244323624,
        "sender_full_name": "Reid Barton",
        "timestamp": 1624990279
    },
    {
        "content": "<p>You also need to prove <code>int.incr</code> and <code>int.decr</code> form an <code>equiv</code> first.</p>",
        "id": 244323783,
        "sender_full_name": "Reid Barton",
        "timestamp": 1624990344
    },
    {
        "content": "<p>I'm still at a pretty basic level... I get that <code>incr</code> and <code>decr</code> can form an <code>equiv</code>, but can you unpack the part about defining an eliminator based on an equiv a bit more?</p>",
        "id": 244326497,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1624991461
    },
    {
        "content": "<p>There is no need for a new type, you can do this type of matching on <code>Int</code> itself!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[matchPattern]</span> <span class=\"n\">abbrev</span> <span class=\"n\">Int.posSucc</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ofNat</span> <span class=\"n\">n.succ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Int.incr</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">posSucc</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">posSucc</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">posSucc</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">negSucc</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">negSucc</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">negSucc</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>And so on...</p>",
        "id": 244326663,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1624991524
    },
    {
        "content": "<p>My <em>guess</em> is that Reid is suggesting that given a type X, a term <code>z : X</code> and an equiv X ~= X you can get a map from <code>int</code> to X -- and furthermore this classifies int up to unique isomorphism as an initial object.</p>",
        "id": 244327755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624992032
    },
    {
        "content": "<p>Yes that's right. Something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.iterate\">docs#nat.iterate</a> but with an <code>equiv</code> as the input.<br>\nThe key point is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> is an equiv, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><msup><mi>e</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e(e^n(x)) = e^{n+1}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> holds not just for positive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> (by definition) but also for negative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>--this uses the equations of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span>--and likewise <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><msup><mi>e</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e^{-1}(e^n(x)) = e^{n-1}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> also for positive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</p>",
        "id": 244328591,
        "sender_full_name": "Reid Barton",
        "timestamp": 1624992427
    },
    {
        "content": "<p>Then you can combine this with an induction principle like \"if P(0) and P(n) =&gt; P(n+1) and P(n) =&gt; P(n-1) then P(n) holds for all n\" and never worry again about whether numbers are positive or negative.</p>",
        "id": 244328679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1624992477
    },
    {
        "content": "<p>The difficulty with giving a direct by-cases definition of <code>add</code> and running with it is that you will know by definition that (say) <code>a + (b + 1) = (a + b) + 1</code> when <code>b</code> is positive, but not when it's negative. So you end up with cases everywhere, and you will have to use the fact that <code>succ</code> and <code>pred</code> cancel manually.</p>",
        "id": 244328932,
        "sender_full_name": "Reid Barton",
        "timestamp": 1624992586
    },
    {
        "content": "<p>I have to go for now but I can try to write up something later if it remains unclear.</p>",
        "id": 244329022,
        "sender_full_name": "Reid Barton",
        "timestamp": 1624992615
    },
    {
        "content": "<p>If it helps, here's a little API for int.iterate which we wrote at Imperial as part of a group theory project: <a href=\"https://github.com/ImperialCollegeLondon/group-theory-game/blob/152ec4a92ad67b6174a3d240c63fa56a6df6017e/src/int/iterate.lean\">https://github.com/ImperialCollegeLondon/group-theory-game/blob/152ec4a92ad67b6174a3d240c63fa56a6df6017e/src/int/iterate.lean</a></p>",
        "id": 244329082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624992651
    },
    {
        "content": "<p>Right, this sort of thing is what I had in mind but you might need to organize some things a bit differently if you don't have <code>int.add</code> yet.</p>",
        "id": 244329814,
        "sender_full_name": "Reid Barton",
        "timestamp": 1624992966
    },
    {
        "content": "<p>Is this similar to well founded recursion by ordering the integers like 0, -1, 1, -2, 2 etc ?</p>",
        "id": 244332498,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1624994098
    },
    {
        "content": "<p>A similar trick to the one I mentioned above works for simulating the inductive definition of <code>Int</code> in terms of positive integers as @Mac originally intended. The additional cost is a weird definition of positive integers as follows.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Pos</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Pos</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.zero</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">Pos</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Pos.one</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Pos</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.succ</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Pos</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">Nat.add</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">Pos</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Pos.add</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Pos</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.add</span> <span class=\"o\">(</span><span class=\"n\">Nat.mul</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat.add</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"n\">Pos</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Pos.mul</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Pos</span>\n</code></pre></div>\n<p>Then this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[matchPattern]</span> <span class=\"n\">abbrev</span> <span class=\"n\">Int.ofPos</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Int.ofNat</span> <span class=\"n\">n.succ</span>\n<span class=\"kd\">@[matchPattern]</span> <span class=\"n\">abbrev</span> <span class=\"n\">Int.negOfPos</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Int.negSucc</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Int.decr</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">ofPos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ofPos</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">ofPos</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">negOfPos</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">negOfPos</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">negOfPos</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In other words, we can always pretend <code>Int</code> is defined as @Mac wants</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Int</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">ofPos</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">negOfPos</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n</code></pre></div>\n<p>or as @Brandon wants</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Int</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">posSucc</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">negSucc</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n</code></pre></div>\n<p>even though the real definition of <code>Int</code> is actually</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Int</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">ofNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">negSucc</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n</code></pre></div>",
        "id": 244332583,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1624994133
    },
    {
        "content": "<p>That's an interesting trick, François</p>",
        "id": 244337093,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1624996192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/270676-lean4/topic/Alternate.20Int.20Hierarchy/near/244332583\">said</a>:</p>\n<blockquote>\n<p>In other words, we can always pretend <code>Int</code> is defined as @Mac wants</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Int</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">ofPos</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n<span class=\"bp\">|</span> <span class=\"n\">negOfPos</span> <span class=\"o\">:</span> <span class=\"n\">Pos</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This <em>is</em> a neat trick! :) </p>\n<p>However, it largely defeats the purpose of the original definition. The point of the original definition is to all for the conditions of nonzero/positive/negative to be defined structurally at type level rather than via an attendant proof. </p>\n<p>That is, with my alternate definition, you would no longer need conditions like <code>h : a /= 0</code> or <code>h : a &gt; 0</code> you could just pass a <code>NzInt</code> or <code>PNat</code> and be guaranteed that by the type. You can, of course, simulate this by creating a new bundle type that bundles a <code>Nat</code>/<code>Int</code> but that has annoying implications when in proofs and pattern matches as the type is now much more structurally complex and a lot of thing snow have to be proved rather than just holding structurally. </p>\n<p>The  use of the <code>Option</code> (or an equivalent <code>Zeroid  a := zero | nonzero a</code> type) provides similar structural benefits to proofs/definitions and allows for easy generalization among multiple possibly zero types (i.e., <code>Nat</code>, <code>Int</code>, <code>Rat</code>, etc.). While a zero monoid also does the latter, <code>Zeroid</code> does it structurally, which is useful in many cases.</p>",
        "id": 244352647,
        "sender_full_name": "Mac",
        "timestamp": 1625003442
    }
]
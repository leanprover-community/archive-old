[
    {
        "content": "<p>As discussed over in the doc-gen4 topic I added the <code>delabConst</code> modifications to my fork here <a href=\"https://github.com/hargonix/lean4/tree/const-delab\">https://github.com/hargonix/lean4/tree/const-delab</a> and it works great for regular function applications like <code>IO Nat</code>. However things like <code>Nat = Nat</code> don't tag the <code>=</code> properly with information, although it does in fact get visited, as evident by a <code>dbg_trace</code> in the <code>delabConst</code> function. <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> suspected this has to do with the unexpander generated for mixfix notation generated over here <a href=\"https://github.com/hargoniX/lean4/blob/const-delab/src/Lean/Elab/Notation.lean#L46-L66\">https://github.com/hargoniX/lean4/blob/const-delab/src/Lean/Elab/Notation.lean#L46-L66</a> not carrying the information along so I changed this (according to his suggestions) to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkSimpleDelab</span> <span class=\"o\">(</span><span class=\"n\">attrKind</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pat</span> <span class=\"n\">qrhs</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OptionT</span> <span class=\"n\">MacroM</span> <span class=\"n\">Syntax</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">qrhs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">[(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">[])]</span> <span class=\"bp\">←</span> <span class=\"n\">Macro.resolveGlobalName</span> <span class=\"n\">c.getId</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">args.all</span> <span class=\"o\">(</span><span class=\"n\">Syntax.isIdent</span> <span class=\"bp\">∘</span> <span class=\"n\">getAntiquotTerm</span><span class=\"o\">)</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">args.allDiff</span>\n    <span class=\"c1\">-- replace head constant with (unused) antiquotation so we're not dependent on the exact pretty printing of the head</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">@[$attrKind:attrKind appUnexpander $(mkIdent c):ident]</span>\n      <span class=\"n\">aux_def</span> <span class=\"n\">unexpand</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span>\n       <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$$</span><span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withRef</span> <span class=\"n\">tk</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"o\">)</span>\n       <span class=\"bp\">|</span> <span class=\"n\">_</span>                     <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">())</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span>        <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">[(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">[])]</span> <span class=\"bp\">←</span> <span class=\"n\">Macro.resolveGlobalName</span> <span class=\"n\">c.getId</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">@[$attrKind:attrKind appUnexpander $(mkIdent c):ident]</span>\n      <span class=\"n\">aux_def</span> <span class=\"n\">unexpand</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span>\n       <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$$</span><span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withRef</span> <span class=\"n\">tk</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"o\">)</span>\n       <span class=\"bp\">|</span> <span class=\"n\">_</span>              <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">())</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>                  <span class=\"bp\">=&gt;</span> <span class=\"n\">failure</span>\n</code></pre></div>\n<p>for me locally and updated stage0, however the <code>Format</code> output still insists that the <code>=</code> is merely an untagged text so the information from <code>delabConst</code> is still going missing like this...so now I don't know where to continue again, would someone happen to have an idea?</p>",
        "id": 265673582,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640085271
    },
    {
        "content": "<p>Ah, this is because the unexpander monad completely discards syntax references. :-/</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- unexpanders should not need to introduce new names</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MonadQuotation</span> <span class=\"n\">UnexpandM</span> <span class=\"n\">where</span>\n  <span class=\"n\">getRef</span>              <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">Syntax.missing</span>\n  <span class=\"n\">withRef</span>             <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span>\n  <span class=\"n\">getCurrMacroScope</span>   <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"mi\">0</span>\n  <span class=\"n\">getMainModule</span>       <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"bp\">`</span><span class=\"n\">_fakeMod</span>\n  <span class=\"n\">withFreshMacroScope</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n</code></pre></div>",
        "id": 265684930,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640093523
    },
    {
        "content": "<p>Put an <code>Unhygenic.run do</code> before the <code>withRef</code> and it should work. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 265685127,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640093661
    },
    {
        "content": "<p>Hm If I just do it like that (with the corrected typo: <code>Unhygienic.run</code>) and update-stage0 + make <code>Init/Notation.lean</code> complains that <code>unknown constant 'Lean.Unhygienic.run'</code> this is not a known constant, is there some additional macro stuff I have to do when calling things from within the result of a macro? I would've expected that to just work automagically.</p>",
        "id": 265695446,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640099595
    },
    {
        "content": "<p>Arrh, <code>infix</code> is of course used before Unhygienic is defined...   We could move <code>Unhygienic</code> to Init.Prelude.</p>",
        "id": 265695815,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640099759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Any preferred solution here?</p>",
        "id": 265695868,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640099765
    },
    {
        "content": "<p>We should probably just fix UnexpandM getRef/withRef?</p>",
        "id": 265696025,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1640099849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Function.20application.20delaboration/near/265696025\">said</a>:</p>\n<blockquote>\n<p>We should probably just fix UnexpandM getRef/withRef?</p>\n</blockquote>\n<p>So basically I just turn it into a <code>ReaderT Syntax Id</code>....or rather since the <code>Id</code> Monad isn't defined here yet into a <code>EStateM Syntax Syntax</code> (or alternatively pull <code>Id</code> into Prelude as well?) and adapt the <code>ref</code> funcitons accordingly?</p>",
        "id": 265702458,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640102830
    },
    {
        "content": "<p>No, it should be <code>EStateM Unit Syntax</code></p>",
        "id": 265705472,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1640104332
    },
    {
        "content": "<p>Alright, I made the changes I think are required over here <a href=\"https://github.com/hargoniX/lean4/commit/e123ea251b7e6d393980141805d0a8282007a466\">https://github.com/hargoniX/lean4/commit/e123ea251b7e6d393980141805d0a8282007a466</a> but I can still not see the <code>=</code> being tagged properly in my <code>Format</code> output :/</p>",
        "id": 265718300,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640110968
    },
    {
        "content": "<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">withRef</span>             <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">ref</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bind</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">val</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">EStateM.Result.ok</span> <span class=\"n\">val</span> <span class=\"n\">ref</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><code>withRef</code> is supposed to be a monad combinator.  <code>withRef stx k</code> sets the reference to <code>stx</code> while <code>k</code> is running, and then reverts to the original afterwards.  This implementation sets the reference to <code>stx</code> after <code>k</code> has already been executed.</p>",
        "id": 265718869,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640111293
    },
    {
        "content": "<p>Alright, I changed it over to...more or less literally what you said now <a href=\"https://github.com/hargoniX/lean4/commit/1214d5eff07e42a344e5fcf2f40c626477a68896#diff-52ef0c67eea613acf6c0b6284063fd7112cdd40750de38365c214abaef246db4R2266-R2271\">https://github.com/hargoniX/lean4/commit/1214d5eff07e42a344e5fcf2f40c626477a68896#diff-52ef0c67eea613acf6c0b6284063fd7112cdd40750de38365c214abaef246db4R2266-R2271</a> but there was still no change in sight so either I mistinterpreted you quite a lot or something else is still missing.</p>\n<p>I also tried to <code>dbg_trace</code> inside the delaborators to get a better grasp what's going on but as before since this is in the <code>Init</code> files <code>dbg_trace</code>  does not work here either :(</p>",
        "id": 265732270,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640119528
    },
    {
        "content": "<p>Your branch works for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span> <span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"k\">in</span>\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">TermElabM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">mkNumeral</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">infos</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.PrettyPrinter.delabCore</span> <span class=\"bp\">`</span><span class=\"n\">foo</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"mi\">42</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">infos.toList.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"c1\">-- adds synthetic position 64 to =, and info is available</span>\n</code></pre></div>",
        "id": 265734768,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640121159
    },
    {
        "content": "<p>Oh it does indeed show up in the <code>delabCore</code> Syntax output for me as well, but if I look at the format part:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">TermElabM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">mkNumeral</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">infos</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.PrettyPrinter.delabCore</span> <span class=\"bp\">`</span><span class=\"n\">foo</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"mi\">42</span><span class=\"o\">))</span>\n  <span class=\"k\">let</span> <span class=\"n\">fmt</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.formatTerm</span> <span class=\"n\">stx</span>\n  <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">fmt</span><span class=\"o\">,</span> <span class=\"n\">infos.toList.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p><code>fmt</code> will still mark the <code>=</code> as just a regular <code>Std.format.text</code> without a tag regarding the <code>info</code> so apparently <code>formatTerm</code> is still missing out on what's happening?</p>",
        "id": 265736657,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640122354
    },
    {
        "content": "<p>In the <code>stx</code> object I am seeing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Lean.Syntax.node</span>\n   <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n   <span class=\"bp\">`«</span><span class=\"n\">term_</span><span class=\"bp\">=</span><span class=\"n\">_</span><span class=\"bp\">»</span>\n   <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.node</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">17</span> <span class=\"mi\">17</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">numLit</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.none</span><span class=\"o\">)</span> <span class=\"s2\">\"8\"</span><span class=\"o\">],</span>\n     <span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.none</span><span class=\"o\">)</span> <span class=\"s2\">\" = \"</span><span class=\"o\">,</span>\n     <span class=\"n\">Lean.Syntax.node</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">5</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">numLit</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.none</span><span class=\"o\">)</span> <span class=\"s2\">\"42\"</span><span class=\"o\">]]</span>\n</code></pre></div>\n<p>It doesn't seem like there's a synthetic position on the <code>=</code>.</p>",
        "id": 265784634,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640166306
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Lean.Syntax.node</span>\n   <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n   <span class=\"bp\">`«</span><span class=\"n\">term_</span><span class=\"bp\">=</span><span class=\"n\">_</span><span class=\"bp\">»</span>\n   <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.node</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">17</span> <span class=\"mi\">17</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">numLit</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.none</span><span class=\"o\">)</span> <span class=\"s2\">\"8\"</span><span class=\"o\">],</span>\n     <span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">64</span> <span class=\"mi\">64</span><span class=\"o\">)</span> <span class=\"s2\">\" = \"</span><span class=\"o\">,</span>\n     <span class=\"n\">Lean.Syntax.node</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">5</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">numLit</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.none</span><span class=\"o\">)</span> <span class=\"s2\">\"42\"</span><span class=\"o\">]],</span>\n</code></pre></div>\n<p>This is the one I'm seeing</p>",
        "id": 265784674,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640166340
    },
    {
        "content": "<p>Note that this stx object is being generated with my compiler fork from above.</p>",
        "id": 265784770,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640166374
    },
    {
        "content": "<p>Yep I know, but maybe I do need the stage0 update! On your fork you're still not seeing the tag in the <code>fmt</code>?</p>",
        "id": 265784795,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640166396
    },
    {
        "content": "<p>Exactly, this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">TermElabM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">mkNumeral</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">infos</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.PrettyPrinter.delabCore</span> <span class=\"bp\">`</span><span class=\"n\">foo</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"mi\">42</span><span class=\"o\">))</span>\n  <span class=\"k\">let</span> <span class=\"n\">fmt</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.formatTerm</span> <span class=\"n\">stx</span>\n  <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">fmt</span><span class=\"o\">,</span> <span class=\"n\">infos.toList.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"c1\">-- adds synthetic position 64 to =, and info is available</span>\n</code></pre></div>\n<p>Outputs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Lean.Syntax.node</span>\n   <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n   <span class=\"bp\">`«</span><span class=\"n\">term_</span><span class=\"bp\">=</span><span class=\"n\">_</span><span class=\"bp\">»</span>\n   <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.node</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">17</span> <span class=\"mi\">17</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">numLit</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.none</span><span class=\"o\">)</span> <span class=\"s2\">\"8\"</span><span class=\"o\">],</span>\n     <span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">64</span> <span class=\"mi\">64</span><span class=\"o\">)</span> <span class=\"s2\">\" = \"</span><span class=\"o\">,</span>\n     <span class=\"n\">Lean.Syntax.node</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.synthetic</span> <span class=\"mi\">5</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">numLit</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"o\">(</span><span class=\"n\">Lean.SourceInfo.none</span><span class=\"o\">)</span> <span class=\"s2\">\"42\"</span><span class=\"o\">]],</span>\n <span class=\"n\">Std.Format.group</span>\n   <span class=\"o\">(</span><span class=\"n\">Std.Format.group</span>\n     <span class=\"o\">(</span><span class=\"n\">Std.Format.nest</span>\n       <span class=\"mi\">2</span>\n       <span class=\"o\">(</span><span class=\"n\">Std.Format.tag</span>\n         <span class=\"mi\">1</span>\n         <span class=\"o\">(</span><span class=\"n\">Std.Format.append</span>\n           <span class=\"o\">(</span><span class=\"n\">Std.Format.group</span>\n             <span class=\"o\">(</span><span class=\"n\">Std.Format.nest</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">Std.Format.tag</span> <span class=\"mi\">17</span> <span class=\"o\">(</span><span class=\"n\">Std.Format.text</span> <span class=\"s2\">\"8\"</span><span class=\"o\">)))</span>\n             <span class=\"o\">(</span><span class=\"n\">Std.Format.FlattenBehavior.fill</span><span class=\"o\">))</span>\n           <span class=\"o\">(</span><span class=\"n\">Std.Format.append</span>\n             <span class=\"o\">(</span><span class=\"n\">Std.Format.text</span> <span class=\"s2\">\" =\"</span><span class=\"o\">)</span>\n             <span class=\"o\">(</span><span class=\"n\">Std.Format.append</span>\n               <span class=\"o\">(</span><span class=\"n\">Std.Format.line</span><span class=\"o\">)</span>\n               <span class=\"o\">(</span><span class=\"n\">Std.Format.group</span>\n                 <span class=\"o\">(</span><span class=\"n\">Std.Format.nest</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">Std.Format.tag</span> <span class=\"mi\">5</span> <span class=\"o\">(</span><span class=\"n\">Std.Format.text</span> <span class=\"s2\">\"42\"</span><span class=\"o\">)))</span>\n                 <span class=\"o\">(</span><span class=\"n\">Std.Format.FlattenBehavior.fill</span><span class=\"o\">)))))))</span>\n     <span class=\"o\">(</span><span class=\"n\">Std.Format.FlattenBehavior.fill</span><span class=\"o\">))</span>\n   <span class=\"o\">(</span><span class=\"n\">Std.Format.FlattenBehavior.fill</span><span class=\"o\">),</span>\n <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">17</span><span class=\"o\">,</span> <span class=\"mi\">64</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 265784870,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640166443
    },
    {
        "content": "<p>Ah, it's because it's an atom and we only add tags in the formatter for nodes.</p>",
        "id": 265787960,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640168507
    },
    {
        "content": "<p>What change would make sense in this context then? Changing the delaborator so it produces a node here or changing the formatter so it acts on atoms as well? (Or something completely different)</p>",
        "id": 265788424,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640168876
    },
    {
        "content": "<blockquote>\n<p>Ah, it's because it's an atom and we only add tags in the formatter for nodes.</p>\n</blockquote>\n<p>That's not the whole story.  We only add tags for <em>category parsers</em>.  That is, <code>term</code> gets a tag, but <code>ident</code> or <code>\" = \"</code> don't.</p>",
        "id": 265788871,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640169158
    },
    {
        "content": "<p><code>ident</code>s do, actually -- <code>formatterForKindUnsafe</code> is called! It seems it's just atoms that don't.</p>",
        "id": 265789734,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640169738
    },
    {
        "content": "<p>That's only true if the <code>ident</code> is parsed through <code>term</code>.  For <code>ident</code>s that directly occur, the tag is not emitted.  For example the binder <code>x</code> in <code>∀ x, x = x</code> gets a (very wrong!) synthetic position in the syntax tree, but not a tag in the format object:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span> <span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span>\n\n<span class=\"n\">deriving</span> <span class=\"kd\">instance</span> <span class=\"n\">Repr</span> <span class=\"n\">for</span> <span class=\"n\">Std.Format.FlattenBehavior</span>\n<span class=\"n\">deriving</span> <span class=\"kd\">instance</span> <span class=\"n\">Repr</span> <span class=\"n\">for</span> <span class=\"n\">Std.Format</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">TermElabM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">mkForallFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkEq</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">infos</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.PrettyPrinter.delabCore</span> <span class=\"bp\">`</span><span class=\"n\">foo</span> <span class=\"o\">[]</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"n\">fmt</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.formatTerm</span> <span class=\"n\">stx</span>\n  <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">fmt</span><span class=\"o\">,</span> <span class=\"n\">infos.toList.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 265790425,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640170318
    },
    {
        "content": "<p>Oh dear, so that synthetic position is a bug in the delaborator, and then there's still the issue with the formatter missing tags.</p>",
        "id": 265790671,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640170479
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> you could make the formatter add the missing tags by using <code>withMaybeTag</code> <a href=\"https://github.com/leanprover/lean4/blob/546bb8f053a95180abf6e7ab509a4b3f23b61155/src/Lean/Parser.lean#L101\">here</a>, for example to make sure they are added for <code>symbol</code>s (so e.g. <code> = </code>), the following might do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">|</span> <span class=\"n\">ParserDescr.symbol</span> <span class=\"n\">tk</span>                           <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">Syntax.MonadTraverser.getCur</span>\n      <span class=\"n\">withMaybeTag</span> <span class=\"o\">(</span><span class=\"n\">getExprPos</span><span class=\"bp\">?</span> <span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">symbol.formatter</span> <span class=\"n\">tk</span>\n</code></pre></div>\n<p>However I am not sure that we <em>do</em> want these tags. In source code hovers <code>8 = 42</code> is highlighted as a whole <code>Prop</code>, and the numerals are also hoverable, but the equality sign itself is not. It seems weird to add that, so we may not want to have it in the delaborator either.</p>\n<p>In particular when we do add it, it is no longer possible to hover over the top-level expression since now every subspan is tagged: <code>8</code>, <code> = </code>, and <code>42</code>.</p>",
        "id": 265800665,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640177393
    },
    {
        "content": "<p>Point in support: mathlib docs make symbols clickable. Point against: when viewed interactively the top-level expression will expand to, for example, <code>Eq.{1} a b</code> and then one can click on <code>Eq.{1}</code>, so no information is lost.</p>",
        "id": 265801146,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640177680
    },
    {
        "content": "<p>For doc-gen4 this is exactly what I actually want it to be like so I can linkify the type of a constant (In the environment sense) properly and e..g likn to <code>Eq</code> if you click the <code>=</code>. The alternative would be to link the entire span (which is basically what I'm doing rn) but that also links stuff such as variables etc. that should just not be linked to at all.</p>\n<p>If I understood him correctly, the original idea of Gabriel was to just filter the stuff I add now out in the LSP related parts later on so both things could coexist (which I am not 100% sure how to do either since after all they just look like normal tags right?).</p>",
        "id": 265801210,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640177725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Function.20application.20delaboration/near/265801146\">said</a>:</p>\n<blockquote>\n<p>Point in support: mathlib docs make symbols clickable. Point against: when viewed interactively the top-level expression will expand to, for example, <code>Eq.{1} a b</code> and then one can click on <code>Eq.{1}</code>, so no information is lost.</p>\n</blockquote>\n<p>Yes this top level expression is exactly what im observing in doc-gen4 right now, however for example for stuff such as custom mixfix notation I have no way of really knowing which parts of the syntax inside of the tagged span actually is from the mixfix notation and which parts are not right? So how would I know what to highlight there? I could of course just put the expression there like for example for the syntax: <code>Γ ⊢ e : τ</code> I could (in the web UI) instead show <code>Typing Γ e τ</code> with <code>Typing</code> linking to the function etc. but that way I have to throw the syntax away. And the alternative I had in mind was that the compiler tags both the turnstyle and the colon here as syntax that points to the <code>Typing</code> function so I could link it that way.</p>",
        "id": 265801742,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640178080
    },
    {
        "content": "<p>Maybe we could also have an option/switch that enables/disables these specific tags and is default set to false? So <code>doc-gen</code> just calls <code>format</code> with this enabled and the rest stays as is?</p>",
        "id": 265801973,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640178272
    },
    {
        "content": "<blockquote>\n<p>So <span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> you could make the formatter add the missing tags by using <code>withMaybeTag</code> <a href=\"https://github.com/leanprover/lean4/blob/546bb8f053a95180abf6e7ab509a4b3f23b61155/src/Lean/Parser.lean#L101\">here</a>, for example to make sure they are added for <code>symbol</code>s (so e.g. <code> = </code>), the following might do:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">|</span> <span class=\"n\">ParserDescr.symbol</span> <span class=\"n\">tk</span>                           <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">Syntax.MonadTraverser.getCur</span>\n      <span class=\"n\">withMaybeTag</span> <span class=\"o\">(</span><span class=\"n\">getExprPos</span><span class=\"bp\">?</span> <span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">symbol.formatter</span> <span class=\"n\">tk</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The <code>withMaybeTag</code> is the right direction, but it needs to be added at <code>symbolNoAntiquot.formatter</code>, then it will also work for non-ParserDescr parsers.</p>",
        "id": 265802001,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1640178289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Function.20application.20delaboration/near/265801973\">said</a>:</p>\n<blockquote>\n<p>Maybe we could also have an option/switch that enables/disables these specific tags and is default set to false? So <code>doc-gen</code> just calls <code>format</code> with this enabled and the rest stays as is?</p>\n</blockquote>\n<p>This sounds exactly like what I was just going to propose :) So you raise a good point that there are some conflicting requirements. Namely, we wish to use the pretty-printer infrastructure for doc-gen <em>and</em> for widgets because it would be extremely complicated to maintain separate systems, but we sometimes want different information present depending on the target. I think the formatter should ideally be deterministic (i.e.e always tag all the taggable nodes), but we can control the delaborator with <code>pp</code> options. So there could be something like <code>pp.tagSymbols</code> which tells the delaborator to add the info when producing symbol <code>Syntax</code>, or not.</p>",
        "id": 265803194,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1640179062
    },
    {
        "content": "<p>That definitely does sound reasonable, everyone okay with this variant?</p>",
        "id": 265809538,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640182637
    },
    {
        "content": "<p>PR is here: <a href=\"https://github.com/leanprover/lean4/pull/911\">https://github.com/leanprover/lean4/pull/911</a>, tested against both the examples in the chat as well as with my doc-gen4 prototype.</p>",
        "id": 265956406,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640296339
    },
    {
        "content": "<p>Aaand test failure :/ let's see, fixed \\o/</p>",
        "id": 265957048,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1640296890
    }
]
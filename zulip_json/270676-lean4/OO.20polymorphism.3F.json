[
    {
        "content": "<p>Is there no equivalent to object oriented polymorphism in Lean?  This doesn't compile:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">printPoint</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"n\">printPoint</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>Saying :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">printPoint</span> <span class=\"n\">p</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">p</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Point3D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>But p \"is a\" Point since Point3D extends Point...</p>",
        "id": 297479031,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662494913
    },
    {
        "content": "<p>you could use <code>Point3D.toPoint</code></p>",
        "id": 297479154,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662494964
    },
    {
        "content": "<p>Or use typeclasses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Point</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">printPoint</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Point</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{Point.x p}, {Point.y p}\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Point3D.x</span>\n  <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">Point3D.y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"n\">printPoint</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 297479612,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662495123
    },
    {
        "content": "<p>I wounded if there is (or should be) an automatic type class, where (say)<code>Point.IsExtention T</code> means that <code>T</code> is <code>Point</code> or an extension of <code>Point</code>.  That would provide “object oriented polymorphism”.</p>",
        "id": 297480181,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662495325
    },
    {
        "content": "<p>…but that is probably overkill when a simple type class would suffice.</p>",
        "id": 297481430,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662495828
    },
    {
        "content": "<p>Ok, but that's a lot more code and complexity.  Now how do I add Point4D where the 4D point can be used everywhere the 3D point can and everywhere the 2D point can?  Is there a typeclass-instance explosion required here?</p>",
        "id": 297481691,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662495958
    },
    {
        "content": "<p>One of the major benefits of OO polymorphism is when a subtype can travel through the system and be discovered later by runtime type check, but your instance converting Point3D to Point throws that away, that result can never be \"cast\" back to a Point3D...</p>",
        "id": 297481910,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662496051
    },
    {
        "content": "<p>Dot notation will insert projections automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Point.printPoint</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"n\">p.printPoint</span>\n</code></pre></div>",
        "id": 297482329,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662496236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/OO.20polymorphism.3F/near/297482329\">said</a>:</p>\n<blockquote>\n<p>Dot notation will insert projections automatically</p>\n</blockquote>\n<p>Nice! I didn't know about this.</p>",
        "id": 297482400,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662496272
    },
    {
        "content": "<p>(That feature's been backported to Lean 3, too)</p>",
        "id": 297482432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662496293
    },
    {
        "content": "<p>I don't think anyone will miss the <code>e.to_ring_hom.to_add_monoid_hom.ker</code> nonsense.</p>",
        "id": 297482542,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662496334
    },
    {
        "content": "<p>Yes, I'm already addicted to this change in Lean 3.</p>",
        "id": 297483816,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1662496874
    },
    {
        "content": "<p>Note however that the infoview still shows the long version.</p>",
        "id": 297483845,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1662496884
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span>  When you say \"OO polymorphism\", do you mean <a href=\"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)\">\"inheritance\"</a>?  First Lean doesn't have inheritance.  (Edit: Although in this particular case of <code>structure</code>s, apparently Lean is smart enough to project to the parent structure as Kyle's answer shows).  If it had full inheritance it would have to account for <a href=\"https://docs.scala-lang.org/tour/variances.html\">variances</a>.  (For example if you gave <code>def foo : Point -&gt; Point := id</code> a <code>Point3D</code>, would it return a <code>Point3D</code> or a <code>Point</code>?  If you say it should return <code>Point</code>, it would no longer be injective which is a provable property of <code>foo</code>.  And if you say a <code>Point3D</code>, what about where the output doesn't depend on the input like<code>def bar (p : Point) : Point := {0, 0}</code>?)</p>",
        "id": 297486371,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662498047
    },
    {
        "content": "<p>I was a Scala programmer for a while, and Scala is interesting because it is a functional language with both inheritance (including co/contra-variance) and type classes.  So you can have <code>List</code> inherit from <code>Seq</code> (which is the parent of a number of sequence data structures), but also could have a typeclass <code>HasSeq</code> which full-fills the same role.  The advantage of the latter is that you can declare that other objects which didn't extend from <code>Seq</code> to begin with behave like a <code>Seq</code> and should count in the <code>Seq</code> API.  Here is your example using that typeclass pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">HasPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span><span class=\"o\">:</span>  <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Point</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasPoint</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"o\">:=</span> <span class=\"n\">Point3D.toPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasPoint</span> <span class=\"o\">(</span><span class=\"n\">Float</span> <span class=\"bp\">×</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">b</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">printPoint</span> <span class=\"o\">[</span><span class=\"n\">HasPoint</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">HasPoint.toPoint</span> <span class=\"n\">p</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">printPoint</span> <span class=\"n\">p</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"n\">printPoint</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 297486439,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662498076
    },
    {
        "content": "<p>Notice if I used this pattern for my examples <code>foo</code> and <code>bar</code> above I would have to explicitly state the return type, avoiding any contradictions and ambiguity.</p>",
        "id": 297487030,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662498340
    },
    {
        "content": "<p>Yes it is covariance and contravariance I'm looking for and I would understand if the real answer is \"lean doesn't do it because it is too hard to prove correctness\".  But when I add point4d in your example I get an error?  And notice the explosion I was talking about... most of this would never have to be written in a C# program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span><span class=\"o\">:</span>  <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Point</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPoint3D</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint3D</span><span class=\"o\">:</span>  <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Point3D</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point4D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsPoint</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"o\">:=</span> <span class=\"n\">Point3D.toPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsPoint3D</span> <span class=\"n\">Point4D</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint3D</span> <span class=\"o\">:=</span> <span class=\"n\">Point4D.toPoint3D</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsPoint</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"o\">:=</span> <span class=\"n\">Point4D.toPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsPoint</span> <span class=\"o\">(</span><span class=\"n\">Float</span> <span class=\"bp\">×</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">b</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsPoint3D</span> <span class=\"o\">(</span><span class=\"n\">Float</span> <span class=\"bp\">×</span> <span class=\"n\">Float</span> <span class=\"bp\">×</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint3D</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">printPoints</span> <span class=\"o\">[</span><span class=\"n\">IsPoint</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">for</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">p</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">IsPoint.toPoint</span> <span class=\"n\">a</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">print3DPoints</span> <span class=\"o\">[</span><span class=\"n\">IsPoint3D</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">for</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">p</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">IsPoint3D.toPoint3D</span> <span class=\"n\">a</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}, {p.z}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point4D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"n\">printPoints</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"n\">print3DPoints</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">main</span>\n</code></pre></div>",
        "id": 297489773,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662499690
    },
    {
        "content": "<p>Most of the explosion is boilerplate, and if this use case was common enough it could be handled automatically with my proposal here:<br>\n<span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/270676-lean4/topic/OO.20polymorphism.3F/near/297480181\">said</a>:</p>\n<blockquote>\n<p>I wonder if there is (or should be) an automatic type class, where (say)<code>Point.IsExtention T</code> means that <code>T</code> is <code>Point</code> or an extension of <code>Point</code>.  That would provide “object oriented polymorphism”.</p>\n</blockquote>",
        "id": 297490354,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662499979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"434989\">Chris Lovett</span> <a href=\"#narrow/stream/270676-lean4/topic/OO.20polymorphism.3F/near/297489773\">said</a>:</p>\n<blockquote>\n<p>Yes it is covariance and contravariance I'm looking for and I would understand if the real answer is \"lean doesn't do it because it is too hard to prove correctness\".</p>\n</blockquote>\n<p>I would go further and say that it would significantly change the type theory, maybe at the kernel level even.  I'm not sure if anyone has worked on DTT with inheritance, and it could be easy to introduce inconsistencies.  Even Scala 2 is known to be inconsistent (in a type theoretic sense which isn't a big deal for most users) and that lead to a big push to formally verify the Dotty type theory used in Scala 3.</p>",
        "id": 297493157,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662501410
    },
    {
        "content": "<p>Also, I think Kyle's answer (which shouldn't get lost in this conversation) covers 90% of any cases (including yours) where one would want inheritance in the simple setting where the output type doesn't use <code>Point</code> (and the input is an extension of <code>Point</code>).  I just checked and this notation prevents all the issues I expressed above by just failing to compile for them. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Point.xx</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span> <span class=\"n\">p.x</span>\n<span class=\"kd\">def</span> <span class=\"n\">Point.foo</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"kd\">def</span> <span class=\"n\">Point.bar</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span><span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">p3d</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n<span class=\"k\">#eval</span> <span class=\"n\">p3d.xx</span>\n<span class=\"k\">#eval</span> <span class=\"n\">p3d.foo</span>  <span class=\"c1\">-- fails</span>\n<span class=\"k\">#eval</span> <span class=\"n\">p3d.bar</span>  <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 297493323,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662501506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"434989\">Chris Lovett</span> <a href=\"#narrow/stream/270676-lean4/topic/OO.20polymorphism.3F/near/297489773\">said</a>:</p>\n<blockquote>\n<p>Yes it is covariance and contravariance I'm looking for and I would understand if the real answer is \"lean doesn't do it because it is too hard to prove correctness\". </p>\n</blockquote>\n<p>Is this a Lean-specific thing, or a functional programming thing? How would one handle such paradigms in, say, haskell?</p>",
        "id": 297493587,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662501655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> One answer is that the concept of variance is there even if it is not explicitly in the language.  (For example here is a <a href=\"https://www.fpcomplete.com/blog/2016/11/covariance-contravariance/\">discussion about variance and type classes in Haskell</a>.) But my understanding is if your language has inheritance and is  are statically typed, then you need to support it in the language explicitly one way or another.  I don't know Haskell well, but I I assume like Lean it doesn't have inheritance.</p>",
        "id": 297494159,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662501962
    },
    {
        "content": "<p>Another useful variation on this theme for oo-style programming are contravariance in Arrays and Lists (containers in general), being able to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">x</span><span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n<span class=\"k\">let</span>  <span class=\"n\">q</span>  <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n<span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Which lean also disallows.  I remember Eric Meijer did a lot of work on the soundness of co and contravariance in C# when he was working on the LINQ features and I know he's a huge Haskel fan, so I wonder how much formal type theory he wrote to prove its correctness?  I remember seeing pages of type theory proofs, but I don't know where they were kept or published...</p>",
        "id": 297498672,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662504479
    },
    {
        "content": "<p>I would expect that would it make Lean much less capable of inferring your types, or would/could lead to overgeneralized upper/lower type bounds.   I've spent a fair bit of time with Scala and came away really disliking the type system - it seemed to have suffered from a lot of the \"worst of both worlds\". <br>\nWorth remembering that Haskell's type system is nowhere near as powerful as Lean's; and in almost all cases when you want to use \"inheritance\" my experience is that one would be better off using type classes, projections or just plain old inductive (sum) types.</p>",
        "id": 297505651,
        "sender_full_name": "Tom",
        "timestamp": 1662509054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> in addition to using dot notation (which adds a coercion automatically), you can define your own coercions like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Point.printPoint</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}\"</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n  <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n  <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Point3D</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Point3D.toPoint</span>\n\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point4D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">p4</span> <span class=\"o\">:</span> <span class=\"n\">Point4D</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n  <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n  <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n  <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Point4D</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Point4D.toPoint3D</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">p3.printPoint</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Point.printPoint</span> <span class=\"n\">p3</span>\n<span class=\"k\">#eval</span> <span class=\"n\">p4.printPoint</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Point.printPoint</span> <span class=\"n\">p4</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pps</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">p3</span><span class=\"o\">,</span> <span class=\"n\">p4</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 297514072,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662517439
    },
    {
        "content": "<p>I was playing the other day with this notation</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" &lt;: \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Coe</span>\n</code></pre></div>\n<p>so I could write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myFunction</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"bp\">&lt;</span><span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>But that might bee too much :)</p>",
        "id": 297514562,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662518024
    },
    {
        "content": "<p>I guess one can also mimic functor co/contravariance like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">covariantCoercion</span> <span class=\"o\">[</span><span class=\"n\">Coe</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Functor.map</span> <span class=\"n\">Coe.coe</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">p3s</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">p3</span><span class=\"o\">,</span> <span class=\"n\">p3</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">p4s</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">p4</span><span class=\"o\">,</span> <span class=\"n\">p4</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pps2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"n\">p3s</span>\n<span class=\"kd\">def</span> <span class=\"n\">pps3</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"n\">p4s</span>\n\n<span class=\"bp\">...</span> <span class=\"n\">similar</span> <span class=\"n\">for</span> <span class=\"n\">contravariance</span>\n</code></pre></div>",
        "id": 297515570,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662519346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"434989\">Chris Lovett</span> <a href=\"#narrow/stream/270676-lean4/topic/OO.20polymorphism.3F/near/297481691\">said</a>:</p>\n<blockquote>\n<p>Ok, but that's a lot more code and complexity.  Now how do I add Point4D where the 4D point can be used everywhere the 3D point can and everywhere the 2D point can?  Is there a typeclass-instance explosion required here?</p>\n</blockquote>\n<p>More boilerplate isn't really an argument against this modeling technique, because that can be automated away if it is a sufficiently important use case. I think the semantics OO inheritance is captured fairly directly via a typeclass like <code>ToPoint</code>; it's just a question of how to make the syntax around it sufficiently clean to be useful.</p>",
        "id": 297515654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662519477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> Here's a working version of your example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ToPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Point</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToPoint</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ToPoint3D</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint3D</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Point3D</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToPoint3D</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint3D</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToPoint3D</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ToPoint</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ToPoint3D.toPoint3D</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPoint</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point4D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ToPoint4D</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint4D</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Point4D</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToPoint4D</span> <span class=\"n\">Point4D</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint4D</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToPoint4D</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ToPoint3D</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPoint3D</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ToPoint4D.toPoint4D</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPoint3D</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToPoint</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">α</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">ToPoint.toPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToPoint3D</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">α</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">ToPoint3D.toPoint3D</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToPoint4D</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">α</span> <span class=\"n\">Point4D</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">ToPoint4D.toPoint4D</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">printPoints</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">p</span> <span class=\"k\">do</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">print3DPoints</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Point3D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">p</span> <span class=\"k\">do</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p.x}, {p.y}, {p.z}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point4D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">}</span>\n  <span class=\"n\">printPoints</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"n\">print3DPoints</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 297516151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662520063
    },
    {
        "content": "<p>I would generally want to stay away from implicit conversions (<code>Coe</code>) for this sort of thing though. That's what leads to type inference issues in the presence of all the other polymorphism</p>",
        "id": 297516230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662520135
    },
    {
        "content": "<p>All of the classes and instances are very easily automatable as a macro, it just uses the shape of the <code>extends</code> on the structure. But my rust-based sensibilities tell me that the whole thing is probably a bad idea and it's not a good way to structure your program, so I would probably try to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> your problem if you have a specific reason to investigate this.</p>",
        "id": 297516412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662520358
    },
    {
        "content": "<p>Yeah, Rust is a very prominent example of a general trend away from inheritance towards composition, from object oriented to functional. It's also interesting to note that while Rust does not have coercions, it does have a very general typeclass/trait-based system for \"redirecting\" dot notation.</p>",
        "id": 297537133,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1662536566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"434989\">Chris Lovett</span> <a href=\"#narrow/stream/270676-lean4/topic/OO.20polymorphism.3F/near/297498672\">said</a>:</p>\n<blockquote>\n<p>Another useful variation on this theme for oo-style programming are contravariance in Arrays and Lists (containers in general)</p>\n</blockquote>\n<p>Note that array variance is famously <a href=\"https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29#Covariant_arrays_in_Java_and_C#\">broken</a> in both C# and Java</p>",
        "id": 297538020,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1662536997
    },
    {
        "content": "<p>Even some of us OO people don't think inheritance is a particularly nice thing :P</p>",
        "id": 297561755,
        "sender_full_name": "Julian Berman",
        "timestamp": 1662547020
    },
    {
        "content": "<p>Re: dot notation inserting projections automatically, I noticed the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Point3D.printPoint</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr p}\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">printPoint</span>\n<span class=\"c1\">-- ERROR: invalid field notation, function 'Point3D.printPoint' does not have argument with type (Point3D ...) that can be used, it must be explicit or implicit with an unique name</span>\n</code></pre></div>\n<p>I guess in theory there could be a coercion here too? I.e. look for a argument of the same (structure) type but in case it fails look for Point (following the <code>extends</code> relation)?</p>",
        "id": 297578026,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1662553381
    },
    {
        "content": "<p>Along the same lines (also briefly touched upon in an earlier Zulip thread): could this same coercion happen (automatically) on a regular, non-dot notation call? For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Point</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">printPoint</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr p}\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">printPoint</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span><span class=\"o\">}</span>\n<span class=\"c1\">--  application type mismatch</span>\n<span class=\"c1\">--   printPoint { toPoint := { x := 1.0, y := 2.0 }, z := 3.0 }</span>\n<span class=\"c1\">-- argument</span>\n<span class=\"c1\">--   { toPoint := { x := 1.0, y := 2.0 }, z := 3.0 }</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   Point3D : Type</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   Point : Type</span>\n</code></pre></div>\n<p>I can't judge how useful these would be in practice, so just thinking out loud here.</p>",
        "id": 297578047,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1662553388
    },
    {
        "content": "<p>Why would you call the definition <code>Point3D.printPoint</code> if it takes a <code>Point</code>?</p>",
        "id": 297578623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662553594
    },
    {
        "content": "<p>The dot-notation smarts are for determining what namespaces to look in when the receiver at the application site has a different type from the function we want to call. It doesn't try to resolve inconsistencies between the definition and its own namespace, since you can easily fix that by just putting it in the right namespace</p>",
        "id": 297579054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662553769
    },
    {
        "content": "<p>The idea is that printPoint may take either a Point3D or Point without enforcing in what namespace it is declared.</p>\n<p>But maybe that is the intention of the asymmetry? I.e. dot notation works \"down\" from an extended structure (from Point to Point3D, in this case) but not \"up\"?</p>",
        "id": 297579849,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1662554024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"434989\">Chris Lovett</span> <a href=\"#narrow/stream/270676-lean4/topic/OO.20polymorphism.3F/near/297481910\">said</a>:</p>\n<blockquote>\n<p>One of the major benefits of OO polymorphism is when a subtype can travel through the system and be discovered later by runtime type check, but your instance converting Point3D to Point throws that away, that result can never be \"cast\" back to a Point3D...</p>\n</blockquote>\n<p>This can't happen in Lean without additional modeling since the type of a term is the complete interface for the term. If two <code>Point</code>s are indistinguishable as <code>Point</code>s, then they are equal -- it's impossible to know whether or not one of them was \"really\" a <code>Point3D</code>.</p>\n<p>That doesn't mean it can't be done, but it takes some boilerplate to get terms to remember what they really are. I've put together a mockup where you know ahead of time all the types that you want to participate in this subtyping scheme, and then (borrowing Common Lisp terminology) each of these types has an associated structure of \"slots\" along with casts that let you project these slots structures onto supertype slots structures. There's probably a way to make the types participating in subtyping more extensible, but at least with this version since you have a complete picture of your type system you can prove things about it.</p>\n<p>The code is below, but for an example, here's a run-time cast:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Obj.get_w</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point2D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">o.can_cast</span> <span class=\"n\">Point4D</span> <span class=\"k\">then</span>\n    <span class=\"o\">(</span><span class=\"n\">o.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get.w</span>\n  <span class=\"k\">else</span>\n    <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Here's creating a <code>Point4D</code> object, casting it to a <code>Point2D</code>, then applying this function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">Slots_Point4D</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point4D</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">p.cast_up.get_w</span> <span class=\"c1\">-- N.B. p.cast_up is an `Obj Point2D` here</span>\n<span class=\"c1\">-- 4.000000</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Geo_Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Geo_Type</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point4D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Square2D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">width</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.Slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Square2D</span>\n\n<span class=\"sd\">/-- Get casting function to first type from second type -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.cast</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">t'.Slots</span> <span class=\"bp\">→</span> <span class=\"n\">t.Slots</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point2D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point2D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point3D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span><span class=\"o\">,</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point2D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span><span class=\"o\">,</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"sd\">/-- Whether the second type is a subtype of the first. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">t.cast</span> <span class=\"n\">t'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Geo_Type.supertype.trans</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t'</span> <span class=\"n\">t''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">t''</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t</span>\n  <span class=\"n\">all_goals</span>\n    <span class=\"n\">cases</span> <span class=\"n\">t'</span>\n    <span class=\"n\">all_goals</span>\n      <span class=\"n\">cases</span> <span class=\"n\">t''</span>\n      <span class=\"n\">all_goals</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n        <span class=\"n\">try</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n        <span class=\"n\">try</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Option.get</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x.isSome</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isSome</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/-- Get the cast function from a proof that `t'` is a subtype of `t`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.supertype.cast</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t'.Slots</span> <span class=\"bp\">→</span> <span class=\"n\">t.Slots</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Geo_Type.cast</span> <span class=\"n\">t</span> <span class=\"n\">t'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">supertype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Objects of subtype t -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Obj</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span>\n  <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">ty</span>\n  <span class=\"n\">slots</span> <span class=\"o\">:</span> <span class=\"n\">ty.Slots</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point2D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point2D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point3D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point3D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point4D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point4D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point4D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Square2D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Square2D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Square2D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Extract the slots from an `Obj`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Obj.get</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t.Slots</span> <span class=\"o\">:=</span> <span class=\"n\">Geo_Type.supertype.cast</span> <span class=\"n\">o.sub</span> <span class=\"n\">o.slots</span>\n\n<span class=\"sd\">/-- Cast up, which can be done statically. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Obj.cast_up</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t'</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"n\">o.ty</span>\n  <span class=\"n\">sub</span> <span class=\"o\">:=</span> <span class=\"n\">Geo_Type.supertype.trans</span> <span class=\"n\">h</span> <span class=\"n\">o.sub</span>\n  <span class=\"n\">slots</span> <span class=\"o\">:=</span> <span class=\"n\">o.slots</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Obj.can_cast</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t'</span> <span class=\"n\">o.ty</span>\n\n<span class=\"sd\">/-- Cast up or down using run-time information. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Obj.cast</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">o.can_cast</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t'</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"n\">o.ty</span>\n  <span class=\"n\">sub</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n  <span class=\"n\">slots</span> <span class=\"o\">:=</span> <span class=\"n\">o.slots</span>\n\n<span class=\"sd\">/-- Example using a run-time cast. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Obj.get_w</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point2D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">o.can_cast</span> <span class=\"n\">Point4D</span> <span class=\"k\">then</span>\n    <span class=\"o\">(</span><span class=\"n\">o.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get.w</span>\n  <span class=\"k\">else</span>\n    <span class=\"mi\">0</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Slots_Point2D</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point2D</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get_w</span>\n<span class=\"c1\">-- 0.000000</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">Slots_Point4D</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point4D</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">p.cast_up.get_w</span>\n<span class=\"c1\">-- 4.000000</span>\n</code></pre></div>\n</div></div>",
        "id": 297629381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662569318
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, that's impressive.  Now I wonder if such a system could be made extensible where one Lean package can add a new subtype.  I think that would be hard given the <code>Geo_Type, Geo_Type.Slots and Geo_Type.cast</code> are all fixed in one lean package at compile time.  So perhaps lean has no \"extensibility by subtyping\", only by pre-decided extension hooks, for example, I could add some extension point to my structure as a \"bag of properties\" and then a 3rd party module can add properties if they want to extend things, my new properties will travel through the system, and when it comes back to me I can find the property I added and part on.  Type classes provide a different kind of extensibility since I can add an my own instances (like ToString or Coe), but my understanding is that my new instances cannot influence what previously compiled code is going to do at runtime, it can only influence how my package is going to be compiled, where my new code can pick up my new instances?</p>",
        "id": 297693906,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662597581
    },
    {
        "content": "<p>I don't understand your description but I'm fairly sure there is nothing <em>impossible</em> in this space - some combination of types and typeclasses will do what you want. What is a \"bag of properties\"? Is that a bunch of functions or a data type?</p>",
        "id": 297694713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662598327
    },
    {
        "content": "<blockquote>\n<p>but my understanding is that my new instances cannot influence what previously compiled code is going to do at runtime, it can only influence how my package is going to be compiled, where my new code can pick up my new instances?</p>\n</blockquote>\n<p>If old code takes a typeclass argument, then new code can pass a typeclass instance for that argument to make the old code do new tricks. That's fundamentally the same technique (dynamic dispatch) used to make subclassing work in OO languages</p>",
        "id": 297694760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662598429
    },
    {
        "content": "<blockquote>\n<p>If old code takes a typeclass argument, then new code can pass a typeclass instance for that argument to make the old code do new tricks</p>\n</blockquote>\n<p>Sounds great, but type classes won't let me write a generic summation of <a href=\"http://Command.run\">Command.run</a> results that I could extend later:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--------- package I'm importing ----------------</span>\n<span class=\"kd\">class</span> <span class=\"n\">Command</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"n\">run</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sumResults</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">xs</span> <span class=\"k\">do</span>\n    <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">Command.run</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"c1\">-- failed to synthesize instance:  Command α</span>\n  <span class=\"n\">return</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">------------my module----------------</span>\n\n<span class=\"c1\">-- teach it a new trick.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Command</span> <span class=\"n\">String</span> <span class=\"n\">where</span>\n  <span class=\"n\">run</span> <span class=\"n\">arg</span> <span class=\"o\">:=</span> <span class=\"n\">arg.length</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">sumResults</span> <span class=\"o\">[</span><span class=\"s2\">\"hello\"</span><span class=\"o\">,</span> <span class=\"s2\">\"world\"</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>After defining my instance of course I can run <code>#eval Command.run \"hello\" -- 5</code> but this is not the point. I want to use type class instances to teach old compiled code some new tricks, as you say.   Do you have a better example?</p>",
        "id": 297700614,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662605146
    },
    {
        "content": "<p>That example is very easy to fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--------- package I'm importing ----------------</span>\n<span class=\"kd\">class</span> <span class=\"n\">Command</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"n\">run</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sumResults</span> <span class=\"o\">[</span><span class=\"n\">Command</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">xs</span> <span class=\"k\">do</span>\n    <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">Command.run</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">------------my module----------------</span>\n\n<span class=\"c1\">-- teach it a new trick.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Command</span> <span class=\"n\">String</span> <span class=\"n\">where</span>\n  <span class=\"n\">run</span> <span class=\"n\">arg</span> <span class=\"o\">:=</span> <span class=\"n\">arg.length</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">sumResults</span> <span class=\"o\">[</span><span class=\"s2\">\"hello\"</span><span class=\"o\">,</span> <span class=\"s2\">\"world\"</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 297704168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662609560
    },
    {
        "content": "<p>the main difference between this and OO polymorphism is that the list still has to be homogeneous when written this way</p>",
        "id": 297704232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662609609
    },
    {
        "content": "<p>There are ways to make it work in the heterogeneous scenario as well, but this has the advantage that the compiler can actually construct a specialized version of <code>sumResults</code> applied to your <code>Command String</code> instance to avoid the overhead of dynamic dispatch</p>",
        "id": 297704671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662610074
    },
    {
        "content": "<p>Ah, missed the <code>[Command α]</code>, thanks.  Ok, so yes, this is a kind of polymorphic extensibility I was looking for, thanks for your help.  It is the fully generic kind, not the \"data extends\" kind.  The structure \"extends\" keyword makes an OO person think there's something there, but there isn't really.  Moving back to my point example, I would write this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--------- package I'm importing ----------------</span>\n<span class=\"kd\">class</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sumLengths</span> <span class=\"o\">[</span><span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span>\n  <span class=\"n\">xs.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">sum</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sum</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">Vector.length</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">------------ module A with 2D points ----------------</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Point2D</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Float</span> <span class=\"bp\">×</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- teach it a new trick with 2D points.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">;</span> <span class=\"n\">Float.sqrt</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Point2D</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">sumLengths</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"c1\">-- 5.0</span>\n\n<span class=\"c1\">------ another module with 3D points -------</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Float</span> <span class=\"bp\">×</span> <span class=\"n\">Float</span> <span class=\"bp\">×</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- teach it a new trick with 3D points.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">;</span> <span class=\"n\">Float.sqrt</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">12</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">sumLengths</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"c1\">-- 17.0</span>\n</code></pre></div>\n<p>The total abstraction of the data here with <code>α</code> being a <code>Point2D</code> or <code>Point3D</code> and the \"vectorization\" lens over that data through a <code>Vector</code> interface will take some getting used to.  It's not how an OO programmer thinks... it's kind of like the type class and it's instances are manually filling in the slots of a vtable :-) It's definitely more powerful, but it just doesn't feel as simple as the OO combo of subclassing and virtual overriding:</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">Vector</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">virtual</span><span class=\"w\"> </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">get</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"nf\">sumLengths</span><span class=\"p\">(</span><span class=\"n\">IEnumerable</span><span class=\"p\">&lt;</span><span class=\"n\">Vector</span><span class=\"p\">&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">Vector2D</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">override</span><span class=\"w\"> </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">)</span><span class=\"n\">Math</span><span class=\"p\">.</span><span class=\"n\">Sqrt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">Vector3D</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Vector2D</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">override</span><span class=\"w\"> </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">)</span><span class=\"n\">Math</span><span class=\"p\">.</span><span class=\"n\">Sqrt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">Program</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"nf\">Main</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">var</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector2D</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"m\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"m\">4</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">Vector</span><span class=\"p\">.</span><span class=\"n\">sumLengths</span><span class=\"p\">(</span><span class=\"k\">new</span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">}));</span><span class=\"w\"> </span><span class=\"c1\">// 5</span>\n\n<span class=\"w\">        </span><span class=\"kt\">var</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"n\">Vector3D</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"m\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"m\">9</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">Vector</span><span class=\"p\">.</span><span class=\"n\">sumLengths</span><span class=\"p\">(</span><span class=\"k\">new</span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}));</span><span class=\"w\"> </span><span class=\"c1\">// 17</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// and the more interesting one...</span>\n<span class=\"w\">        </span><span class=\"n\">Console</span><span class=\"p\">.</span><span class=\"n\">WriteLine</span><span class=\"p\">(</span><span class=\"n\">Vector</span><span class=\"p\">.</span><span class=\"n\">sumLengths</span><span class=\"p\">(</span><span class=\"k\">new</span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">}));</span><span class=\"w\"> </span><span class=\"c1\">// 22</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But perhaps simplicity is in the eye of the beholder...</p>",
        "id": 297704868,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662610276
    },
    {
        "content": "<blockquote>\n<p>The total abstraction of the data here with α being a Point2D or Point3D and the \"vectorization\" lens over that data through a Vector interface will take some getting used to. It's not how an OO programmer thinks... it's kind of like the type class and it's instances are manually filling in the slots of a vtable :-)</p>\n</blockquote>\n<p>Yes, although if passing typeclasses is actually \"manual\" you probably aren't doing it right.</p>",
        "id": 297718259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662620407
    },
    {
        "content": "<p>Here's a transcription of your C# example into lean, including the heterogeneous list example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">DynVector</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">DynVector.inst</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">α</span> <span class=\"n\">DynVector</span> <span class=\"o\">:=</span> <span class=\"o\">⟨({</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">·</span> <span class=\"o\">})⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sumLengths</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">DynVector</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span>\n  <span class=\"n\">xs.map</span> <span class=\"o\">(</span><span class=\"n\">Vector.length</span> <span class=\"bp\">·.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"bp\">·+·</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vector2D</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Vector2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"bp\">|</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Float.sqrt</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vector3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Vector2D</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Vector3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"bp\">|</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Float.sqrt</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector2D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span> <span class=\"o\">}</span>\n  <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"n\">sumLengths</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"c1\">-- 5</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vector3D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">12</span> <span class=\"o\">}</span>\n  <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"n\">sumLengths</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">])</span> <span class=\"c1\">-- 17</span>\n\n  <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"n\">sumLengths</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">])</span> <span class=\"c1\">-- 22</span>\n</code></pre></div>",
        "id": 297718318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662620440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> could you explain this bit?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">DynVector.inst</span>\n</code></pre></div>",
        "id": 297839860,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662661060
    },
    {
        "content": "<p>When you have a structure with an instance field, it is not marked as an instance by default so you have to do that. That line is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">DynVector</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">self.α</span> <span class=\"o\">:=</span> <span class=\"n\">self.inst</span>\n</code></pre></div>",
        "id": 297840376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662661227
    },
    {
        "content": "<p>That is, whenever you access something whose type is <code>self.α</code> (like <code>self.val</code>), lean will be able to infer the necessary <code>Vector self.α</code> instance. This is needed to make the <code>sumLengths</code> definition work</p>",
        "id": 297840618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662661313
    },
    {
        "content": "<p>I don't see it mentioned here, but this <code>is_point</code> typeclass vs the <code>Point</code> structure is a lot like how we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_hom\">docs#monoid_hom</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_hom_class\">docs#monoid_hom_class</a> in Lean 3</p>",
        "id": 297841889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662661744
    },
    {
        "content": "<p>Ahh, got it!</p>",
        "id": 297842407,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662661917
    },
    {
        "content": "<p>that's pretty neat, an instance that depends on value (a type in this case but it could be any value I guess)</p>",
        "id": 297842868,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662662067
    },
    {
        "content": "<p>Interestingly, if the function <code>sumLengths</code> is written this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sumLengths</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">DynVector</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">xs.map</span> <span class=\"k\">fun</span> <span class=\"bp\">|</span> <span class=\"n\">DynVector.mk</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Vector.length</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"bp\">.+.</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>then the instance declaration is not needed. I guess <code>fun</code> + pattern matching is making the instance available somehow?</p>",
        "id": 297865520,
        "sender_full_name": "Juan Pablo Romero",
        "timestamp": 1662671373
    },
    {
        "content": "<p>yes, that pattern match puts the instance in the context as a local variable, and those are always available for typeclass search</p>",
        "id": 297969626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662729180
    },
    {
        "content": "<p>although it's interesting to me that <code>{val ..}</code> works rather than <code>{val, ..}</code>. I think that's one of those cursed juxtapositions</p>",
        "id": 297969758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662729229
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  your code looks awesome, but I'm struggling with parsing this line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">DynVector</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This <code>:=</code> syntax is not mentioned in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html\">https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html</a> nor is it mentioned in <a href=\"https://leanprover.github.io/functional_programming_in_lean/getting-to-know/structures.html\">https://leanprover.github.io/functional_programming_in_lean/getting-to-know/structures.html</a> and nor is it mentioned in <a href=\"https://leanprover.github.io/lean4/doc/struct.html\">https://leanprover.github.io/lean4/doc/struct.html</a> ?  </p>\n<p>Also, probably related, but what are the parens doing in this expression <code>⟨({ val := · })⟩</code> ?</p>\n<p>I also like this more compact syntax in the instance declaration <code>length | {x, y} =&gt; Float.sqrt (x * x + y * y)</code> instead of my more verbose version: <code>length v := let (x, y) := v; Float.sqrt (x * x + y * y)</code>.  Where is this vertical bar + curly brace pattern matching described in our documentation so I can read more about this?</p>",
        "id": 298073076,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662770330
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> That's equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">DynVector</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's some Lean 3 syntax that's still in Lean 4.</p>",
        "id": 298073891,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1662771191
    },
    {
        "content": "<p>Thanks, I wasn't aware you could also use square brackets for a field of a structure, or is that more like an attribute of the field <code> (val : α)</code> saying there is a constraint on the <code>val</code> field that there must be an instance of <code>Vector α</code> ?</p>",
        "id": 298074080,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662771372
    },
    {
        "content": "<p>And why can't I write it like this, which is how I see most of the structure examples written (like <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html\">structure Point in TPIL</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">DynVector</span>  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>What does it mean for DynVector to have a field named <code>α </code>?  Looks like it does:</p>\n<p><a href=\"/user_uploads/3121/VYQHB8Gw_DpbpyOf-o9EJ_Wa/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/VYQHB8Gw_DpbpyOf-o9EJ_Wa/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/VYQHB8Gw_DpbpyOf-o9EJ_Wa/image.png\"></a></div>",
        "id": 298074205,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1662771492
    },
    {
        "content": "<p>I assume the alpha is the type parameter.  I wonder if that works for inductives too?  It is nice since it is mostly by convention that some parameters go inside the structure as fields and others don’t, right?  So it is nice to be able to access the ones outside as well.</p>",
        "id": 298078501,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662776325
    },
    {
        "content": "<p>I guess what is implicitly going on here is that structure definitions are injective maps from their parameters to type, so the inverse map is well defined.</p>",
        "id": 298078679,
        "sender_full_name": "Jason Rute",
        "timestamp": 1662776535
    },
    {
        "content": "<p>I think Jason is talking about the <code>structure DynVector (α : Type)</code> example, not Mario's (please correct me if I'm wrong!). I think the screenshot corresponds to Mario's example, not to the code snippet immediately preceding it (but in theory it could correspond to both, as Jason points out). </p>\n<p>The reason <code>α</code> is a field and not a parameter in Mario's example is because we want a single list of type List DynVector to be able to simultaneously contain a Vector2D and a Vector3D (well, a DynVector with <code>α = Vector2D</code> and a DynVector with <code>α = Vector3D</code>). Indeed, such a list can contain elements of any type <code>α</code> as long as Lean is able to find the appropriate <code>Vector α</code> instance by typeclass search (this is represented by the square brackets, which are not an attribute). Had it been declared as <code>structure DynVector (α : Type)</code>, a concrete list value would have type List <code>(DynVector α)</code> for some <code>α</code> (that is, the <code>α</code> would be the same for all list elements).</p>",
        "id": 298079198,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1662777241
    },
    {
        "content": "<p>Ok, so let me know if I'm wrong, but it sounds like this is what is happening in this structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">DynVector</span> <span class=\"n\">where</span>\n  <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>We have a field named <code>α</code> that contains a Type so that every item in an <code>List DynVector</code> can have a different type.  Then it has another field named <code>inst</code> which is the result of doing a typeclass search for an instance of <code>Vector α</code>, for example, in the case of Vector2D, this <code>inst</code> points to the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Vector2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"bp\">|</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Float.sqrt</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This <code>inst</code> field works together with <code>attribute [instance] DynVector.inst</code> to tell Lean it has something to do with type class instancing...</p>\n<p>Then there is the actual value of type α named <code>val</code>.  So <code>DynVector</code> is sort of a dynamic <code>box</code> for any type of Vector, with runtime type info.</p>\n<p>Great, now explain to me again what this is doing exactly?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">α</span> <span class=\"n\">DynVector</span> <span class=\"o\">:=</span> <span class=\"o\">⟨({</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">·</span> <span class=\"o\">})⟩</span>\n</code></pre></div>\n<p>Is this the same as writing this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">α</span> <span class=\"n\">DynVector</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I find the second version way simpler to read.</p>",
        "id": 298502807,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663032855
    },
    {
        "content": "<p>Yup, it's using a new Lean 4 feature for writing simple lambdas. See <a href=\"https://leanprover.github.io/lean4/doc/functions.html#syntax-sugar-for-simple-lambda-expressions\">https://leanprover.github.io/lean4/doc/functions.html#syntax-sugar-for-simple-lambda-expressions</a></p>",
        "id": 298503264,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663033293
    },
    {
        "content": "<p>Thanks and can you explain the role of these 2 sets of brackets: <code>⟨( ... )⟩</code> that surround the <code>{ val := · }</code> ?</p>",
        "id": 298690340,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663119253
    },
    {
        "content": "<p>I understand <code>⟨ ... ⟩</code> is invoking a default constructor for something, perhaps a <code>DynVector</code> which the <code>Coe</code> is required to produce, ok, then what about the parens, are those required because it is using lambda sugar syntax and this is what turns the \\centerdot into lambda sugar?</p>",
        "id": 298690458,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663119386
    },
    {
        "content": "<p>Yes. The outer angle brackets are constructing a <code>Coe A DynVector</code> from <code>A -&gt; Dynvector</code>, the parentheses are being used with the <code>.</code> to produce a lambda that puts the argument at the location of the <code>.</code>, and the braces are the syntax for building structure instances by naming the fields and inferring the rest (<code>α</code> is inferred by unification and <code>inst</code> is inferred by typeclass inference).</p>",
        "id": 298691532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663120577
    },
    {
        "content": "<p>the outer brackets could also have been written as <code>{ coe := ({ val := · }) }</code></p>",
        "id": 298691562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663120624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> showed an interesting type class encoding of polymorphism with a function mapping types to types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Geo_Type.Slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Square2D</span>\n</code></pre></div>\n<p>What if I wanted <code>Geo_Type.Slots</code> to give me not just a vanilla <code>Type</code> but something that also has some type class instances as well, e.g. <code>Repr</code>? </p>\n<p>For example, I could write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point4D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Square2D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">width</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n</code></pre></div>\n<p>Now, I would like to express the fact that <code>Geo_Type.Slots</code> maps a <code>Geo_Type</code> to a <code>T</code> that has an instance <code>Repr T</code> as well.</p>\n<p>Suggestions?</p>",
        "id": 317072554,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1671588180
    },
    {
        "content": "<p>You could use a sigma type. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Geo_Type.slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">-&gt;</span> <span class=\"bp\">Σ</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">Repr</span> <span class=\"n\">T</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">Slots_Point2D</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>So you return a pair with the type and the corresponding instance</p>",
        "id": 317084500,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1671599284
    },
    {
        "content": "<p>The problem is that I don't think you can then make that instance synthesized by typeclass inference</p>",
        "id": 317084767,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1671599548
    },
    {
        "content": "<p>Alternative is to define <code>Geo_Type.Slots</code> as <code>abbrev</code> and you get the instances for <code>Slots_Point..</code></p>",
        "id": 317087761,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1671602252
    },
    {
        "content": "<p>The canonical way to do what you want would be to prove the instance <code>(T : Geo_Type) -&gt; Repr T.slots</code></p>",
        "id": 317102798,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671610153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Where can I find more about this canonical approach?</p>\n<p>I'm getting stuck...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Geo_Type.Slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Square2D</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Geo_Type.Slots.Repr</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">T.Slots</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">T</span>\n</code></pre></div>\n<p>Since <code>Geo_Type</code> is an inductive type, <code>cases T</code> splits into subgoals,  one for each subtype; e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">Point2D</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">_root_.Repr</span> <span class=\"o\">(</span><span class=\"n\">Slots</span> <span class=\"n\">Point2D</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It seems that this would require encoding the cases of the function into the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Geo_Type.Slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point2D</span>\n</code></pre></div>\n<p>I am wondering if this requires a different proof strategy or if I am missing something simple.</p>",
        "id": 317252729,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1671658338
    },
    {
        "content": "<p>You didn't provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, so here's my attempt at one.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point4D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Square2D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">width</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Geo_Type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.Slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Square2D</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Geo_Type</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Repr</span> <span class=\"n\">T.Slots</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Square2D</span>\n</code></pre></div>",
        "id": 317255123,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671659510
    },
    {
        "content": "<p>Thanks, for an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, here is an adaptation of <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> 's example using your trick.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Geo_Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Geo_Type</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point4D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point3D</span> <span class=\"n\">where</span>\n  <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Square2D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">width</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.Slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Square2D</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Geo_Type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toRepr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Repr</span> <span class=\"n\">T.Slots</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Point3D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Point4D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instReprSlots_Square2D</span>\n\n<span class=\"sd\">/-- Get casting function to first type from second type -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.cast</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">t'.Slots</span> <span class=\"bp\">→</span> <span class=\"n\">t.Slots</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point2D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point2D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point3D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point4D</span><span class=\"o\">,</span> <span class=\"n\">Point4D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point2D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Square2D</span><span class=\"o\">,</span> <span class=\"n\">Square2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"sd\">/-- Whether the second type is a subtype of the first. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">t.cast</span> <span class=\"n\">t'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Geo_Type.supertype.trans</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t'</span> <span class=\"n\">t''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">t''</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t</span>\n  <span class=\"n\">all_goals</span>\n    <span class=\"n\">cases</span> <span class=\"n\">t'</span>\n    <span class=\"n\">all_goals</span>\n      <span class=\"n\">cases</span> <span class=\"n\">t''</span>\n      <span class=\"n\">all_goals</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n        <span class=\"n\">try</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n        <span class=\"n\">try</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Option.get</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x.isSome</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Option.isSome</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/-- Get the cast function from a proof that `t'` is a subtype of `t`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.supertype.cast</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t'.Slots</span> <span class=\"bp\">→</span> <span class=\"n\">t.Slots</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Option.get</span> <span class=\"o\">(</span><span class=\"n\">Geo_Type.cast</span> <span class=\"n\">t</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/-- Objects of subtype t -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Obj</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span>\n  <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">ty</span>\n  <span class=\"n\">slots</span> <span class=\"o\">:</span> <span class=\"n\">ty.Slots</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point2D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point2D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point3D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point3D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point4D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point4D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point4D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Square2D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Square2D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Square2D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Extract the slots from an `Obj`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Obj.get</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t.Slots</span> <span class=\"o\">:=</span> <span class=\"n\">Geo_Type.supertype.cast</span> <span class=\"n\">o.sub</span> <span class=\"n\">o.slots</span>\n\n<span class=\"sd\">/-- Cast up, which can be done statically. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Obj.cast_up</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t'</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"n\">o.ty</span>\n  <span class=\"n\">sub</span> <span class=\"o\">:=</span> <span class=\"n\">Geo_Type.supertype.trans</span> <span class=\"n\">h</span> <span class=\"n\">o.sub</span>\n  <span class=\"n\">slots</span> <span class=\"o\">:=</span> <span class=\"n\">o.slots</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Obj.can_cast</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t'</span> <span class=\"n\">o.ty</span>\n\n<span class=\"sd\">/-- Cast up or down using run-time information. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Obj.cast</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">o.can_cast</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">t'</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"n\">o.ty</span>\n  <span class=\"n\">sub</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n  <span class=\"n\">slots</span> <span class=\"o\">:=</span> <span class=\"n\">o.slots</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">o</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">instReprGeo_Type.reprPrec</span> <span class=\"n\">o.ty</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">Std.Format.text</span> <span class=\"s2\">\" \"</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"o\">((</span><span class=\"n\">toRepr</span> <span class=\"n\">o.ty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reprPrec</span> <span class=\"n\">o.slots</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s2</span><span class=\"o\">:</span> <span class=\"n\">Slots_Point2D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">}</span>\n<span class=\"k\">#eval</span> <span class=\"n\">s2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">o2</span><span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point2D</span> <span class=\"o\">:=</span> <span class=\"n\">s2</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">o3</span><span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">}:</span> <span class=\"n\">Slots_Point3D</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o3</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o3.get</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o3.slots</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o3.slots.x</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o3.slots.y</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o3.slots.z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">o4</span><span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point4D</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">}:</span> <span class=\"n\">Slots_Point4D</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o4</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o4.get.w</span>\n<span class=\"c1\">-- 4.000000</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">o43</span><span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point3D</span> <span class=\"o\">:=</span> <span class=\"n\">o4.cast_up</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o43</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o43.slots.w</span>\n<span class=\"c1\">-- 4.000000</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o43.get.w</span>\n<span class=\"c1\">-- invalid field 'w', the environment does not contain 'O41.Geo_Type.Slots.w'</span>\n<span class=\"c1\">--  Obj.get o43</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--  Slots Point3D</span>\n</code></pre></div>\n<p>The interesting behavior here is in the difference between <code>o43.get.w</code> vs. <code>o43.slots.w</code>.</p>\n<p>Is there a way to write <code>Geo_Type.toRepr</code> without depending on Repr instance names?</p>",
        "id": 317261990,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1671662802
    },
    {
        "content": "<p>I would say <code>by unfold Geo_Type.Slots; apply_instance</code>, but I haven't tried it.</p>",
        "id": 317262191,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671662886
    },
    {
        "content": "<p>Hum, I get a message that <code>apply_instance</code> is an unknown tactic.</p>\n<p>I made a smaller example to focus on the problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Geo_Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Geo_Type</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Slots_Point3D</span> <span class=\"kd\">extends</span> <span class=\"n\">Slots_Point2D</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.Slots</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point2D</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Slots_Point3D</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Geo_Type</span>\n\n<span class=\"c1\">-- Q: how to avoid depending on generated instance names?</span>\n<span class=\"c1\">-- def toRepr : (T : Geo_Type) → Repr T.Slots</span>\n<span class=\"c1\">-- | Point2D =&gt; instReprSlots_Point2D</span>\n<span class=\"c1\">-- | Point3D =&gt; instReprSlots_Point3D</span>\n\n<span class=\"c1\">-- def toRepr : (T : Geo_Type) → Repr T.Slots :=</span>\n<span class=\"c1\">-- by {</span>\n<span class=\"c1\">--   unfold Slots &lt;;&gt;</span>\n<span class=\"c1\">--  apply_instance</span>\n<span class=\"c1\">--   -- unknown tactic</span>\n<span class=\"c1\">-- }</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toRepr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Repr</span> <span class=\"n\">T.Slots</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">T</span><span class=\"bp\">;</span>\n  <span class=\"n\">cases</span> <span class=\"n\">T</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Slots</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Get casting function to first type from second type -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.cast</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">t'.Slots</span> <span class=\"bp\">→</span> <span class=\"n\">t.Slots</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toSlots_Point2D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"sd\">/-- Whether the second type is a subtype of the first. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">t.cast</span> <span class=\"n\">t'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n\n<span class=\"sd\">/-- Objects of subtype t -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Obj</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span>\n  <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type.supertype</span> <span class=\"n\">t</span> <span class=\"n\">ty</span>\n  <span class=\"n\">slots</span> <span class=\"o\">:</span> <span class=\"n\">ty.Slots</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point2D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point2D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point2D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Slots_Point3D</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"n\">Point3D</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Point3D</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">Obj</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">o</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">instReprGeo_Type.reprPrec</span> <span class=\"n\">o.ty</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">Std.Format.text</span> <span class=\"s2\">\" \"</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"o\">((</span><span class=\"n\">toRepr</span> <span class=\"n\">o.ty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reprPrec</span> <span class=\"n\">o.slots</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">s2</span><span class=\"o\">:</span> <span class=\"n\">Slots_Point2D</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">}</span>\n<span class=\"k\">#eval</span> <span class=\"n\">s2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">o2</span><span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"n\">Point2D</span> <span class=\"o\">:=</span> <span class=\"n\">s2</span>\n<span class=\"k\">#eval</span> <span class=\"n\">o2</span>\n</code></pre></div>\n<p>The last <code>toRepr</code> is unfinished; the tactic state before <code>sorry</code>is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">Point2D</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Repr</span> <span class=\"n\">Slots_Point2D</span>\n<span class=\"n\">case</span> <span class=\"n\">Point3D</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Repr</span> <span class=\"n\">Slots_Point3D</span>\n</code></pre></div>\n<p>I don't understand why some tactics are available in some contexts but not others.<br>\nIs there a way to ask Lean what tactics are available ? VS Code completion gives me a bunch of options that seem to reflect my editor history more than a genuine query.</p>",
        "id": 317271067,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1671668188
    },
    {
        "content": "<p>Hum... I managed to get this to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">Slots_Point2D</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n<span class=\"kd\">instance</span> <span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">Slots_Point3D</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toRepr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Repr</span> <span class=\"n\">T.Slots</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">T</span><span class=\"bp\">;</span>\n  <span class=\"n\">cases</span> <span class=\"n\">T</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Slots</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">p2</span>\n  <span class=\"n\">apply</span> <span class=\"n\">p3</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>We could have used this for your earlier suggestion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">Slots_Point2D</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n<span class=\"kd\">instance</span> <span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">Slots_Point3D</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toRepr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Repr</span> <span class=\"n\">T.Slots</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point2D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p2</span>\n<span class=\"bp\">|</span> <span class=\"n\">Point3D</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p3</span>\n</code></pre></div>\n<p>Is there a way to inline the instance inference into the corresponding case?</p>",
        "id": 317271564,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1671668580
    },
    {
        "content": "<p>Ah... I figured it out!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">toRepr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Geo_Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Repr</span> <span class=\"n\">T.Slots</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">T</span><span class=\"bp\">;</span>\n  <span class=\"n\">cases</span> <span class=\"n\">T</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Slots</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">infer_instance</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>This kind of programming is magical!</p>",
        "id": 317272762,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1671669455
    },
    {
        "content": "<p>Ah, <code>infer_instance</code> was underused in Lean 3 and doing the same thing as <code>apply_instance</code> but as a term, so I assumed we'd kept <code>apply_instance</code> and ditched <code>infer_instance</code>. But apparently it happened the other way around.</p>",
        "id": 317307412,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671696958
    }
]
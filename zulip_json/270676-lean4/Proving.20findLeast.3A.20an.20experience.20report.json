[
    {
        "content": "<p>This originated in a question by <span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> about how to prove that this function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">findLeast</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">smallest</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">a.size</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"n\">smallest</span> <span class=\"k\">then</span>\n      <span class=\"n\">smallest</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n  <span class=\"n\">return</span> <span class=\"n\">smallest</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">findLeast</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>actually computes the least element of the array. The complete proof is here: <a href=\"https://gist.github.com/digama0/404b4a49ccf378847b7ad2c12374bae2\">https://gist.github.com/digama0/404b4a49ccf378847b7ad2c12374bae2</a></p>\n<p>My experience report: There are still huge missing pieces and a lot of things are significantly more painful compared to lean 3. (Warning: this will come off a bit harsh, but I've tried to turn the unfocused frustration into as actionable items as I could.)</p>\n<ul>\n<li>The <code>trustme</code> tactic is a hack to work around the lack of equation lemmas. It acts like <code>exact</code> except it doesn't check that the given term has the correct type; it's safe because the kernel will catch you if you do something wrong, but it lets us implement <code>delta</code> in this case, to prove <code>loop_eq</code>, which would be <code>by delta loop</code> in lean 3.<ul>\n<li>This relates to <a href=\"#narrow/stream/270676-lean4/topic/Smart.20unfolding.20produces.20ununfoldable.20terms\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Smart.20unfolding.20produces.20ununfoldable.20terms</a> . As far as I know, there is no way in lean 4 currently to prove the theorem without this \"cheating\" tactic.</li>\n</ul>\n</li>\n<li>Stating the type of <code>loop_eq</code> is a challenge. Taking the result of <code>#print loop</code> directly doesn't work for a number of type inference reasons. It seems that the delaborator still needs some more work.</li>\n<li>I originally tried to prove <code>findLeast_min</code> with a single large theorem, but local let was not as powerful as I first thought, so I eventually abandoned it and this version uses a definition <code>findLeastRec</code> for the inner let instead.<ul>\n<li>More specifically, I found that using local definitions with <code>theorem foo := ... where bar := ...</code>, the definition of <code>bar</code> is not available in <code>foo</code>, it only appears as a local hypothesis, like <code>have bar := ...</code> which is no good for a definition like <code>findLeastRec</code>.</li>\n</ul>\n</li>\n<li><code>cases</code> and the <code>match</code> tactic seem to do approximately the same thing, but they are each limited in different ways. The <code>match</code> tactic inherits from the <code>match</code> term the undesirable behavior that it does not generalize other variables in the context dependent on the one being pattern matched, unlike <code>cases</code> - for example if <code>h : x &lt; y</code> is in the context, <code>match x with | 0 =&gt; ...</code>, you lose the fact that <code>0 &lt; y</code>. On the other hand, <code>cases</code> apparently does not support nested pattern matches or the ability to use other expressions in the branches, for example matching a <code>Nat</code> as <code>0</code> and <code>n+1</code> instead of <code>zero</code> and <code>succ n</code> (and putting those terms in the goal).</li>\n<li>\n<p>Keeping the tactic proof well formed is a challenge, and sometimes the whitespace sensitivity causes surprises. I particularly miss being able to use <code>{ }</code> to create blocks; lean 4 <code>{}</code> blocks don't work well with the indentation rules.</p>\n<ul>\n<li>\n<p>More specifically:</p>\n<div class=\"codehilite\"><pre><span></span><code>have foo : type\n{ tac\n  tac }\n</code></pre></div>\n\n<p>doesn't work like it would in lean 3, the indentation level of the two tactics is different and this messes things up.</p>\n</li>\n<li>\n<p><code>have : type</code> doesn't work as a tactic without <code>from</code> or <code>by</code> afterward.</p>\n</li>\n<li><code>have := term</code> doesn't work. I use this all the time in lean 3 and <code>have _ from term</code> is not a great substitute. This is nothing that a mathlib prelude can't solve, though. (Can we just eliminate <code>from</code> here in the syntax? I'd rather it just always use <code>:=</code>.)</li>\n<li>Implicit lambdas caused a number of issues because they get eagerly applied everywhere and it's difficult to control this behavior. I ended up having to avoid them entirely in things like the induction hypothesis. We need semi-implicits, I think.</li>\n<li>I should find a more specific example here, but implicit lambda introduction was something I had to force-disable more often than use.</li>\n<li>There are lots and lots of inaccessible names, which makes quick and dirty proving much more onerous. I generally write proofs in quick and dirty mode first and then clean them up once the proof is complete, because iteration on a dirty proof is a lot faster. Lean 4 makes you be a lot more explicit in each step which makes this harder.</li>\n<li>Writing tactics and finding things is very difficult. In lean 3, even without anything imported the entire tactic framework is available in <code>init</code> and everything is in namespace <code>tactic</code>. In lean 4 there are a ton of different files and all the prominent constants like <code>CoreM</code>, <code>ElabTermM</code>, <code>elabTerm</code> are in different namespaces and require different files to be imported, and I had to go spelunking through the lean 4 source to find where anything is.</li>\n<li>There are no tactic writing docs in the lean 4 reference, almost no tactic writing examples in tests, and looking through the lean 4 source for examples is of limited utility when many of the tools used inside lean 4 are of the <code>builtin</code> variety and you the user are supposed to be using something else.</li>\n</ul>\n</li>\n</ul>",
        "id": 233923963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618027832
    },
    {
        "content": "<p>About <code>have _ := _</code> vs <code>have _, from _</code> in lean3 (sorry for semi-offtopic). When I write <code>have a = 5, from h _</code>, it is guaranteed to fail unless Lean can find <code>_</code>. With <code>have a = 5 := h _</code> it creates extra goals.</p>",
        "id": 233931245,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1618036399
    },
    {
        "content": "<p>Actually, that brings me to another point of note: <code>refine</code> in lean 4 acts basically like lean 3 <code>exact</code>, in that any <code>_</code> get red squiggles on them and the tactic does not proceed. In order to recover lean 3 <code>refine</code> you have to use <code>?_</code> instead. At the same time <code>exact</code> also does that, except it has a much worse error reporting - any error and the whole <code>exact</code> line gets highlighted. As a result, it seems like it might be better to just ditch <code>exact</code> and make it a synonym for <code>refine</code>, since it supports both modes explicitly.</p>",
        "id": 233939099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618044264
    },
    {
        "content": "<blockquote>\n<p>More specifically, I found that using local definitions with theorem foo := ... where bar := ..., the definition of bar is not available in foo, it only appears as a local hypothesis, like have bar := ... which is no good for a definition like findLeastRec.</p>\n</blockquote>\n<p>FYI</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lookAtLetDef</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lookAtWhereDef</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- type error</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"n\">where</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lookAtLetRecDef</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- type error</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 234190524,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618245423
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">lbar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">lrbar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"n\">lbar</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">lrbar</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">wbar</span> <span class=\"n\">n</span> <span class=\"n\">where</span> <span class=\"n\">wbar</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">def foo : Nat → Nat :=</span>\n<span class=\"cm\">fun (n : Nat) =&gt;</span>\n<span class=\"cm\">  (fun (wbar : Nat → Nat) =&gt;</span>\n<span class=\"cm\">      let lbar : Nat → Nat := fun (n : Nat) =&gt; n + 1;</span>\n<span class=\"cm\">      (fun (lrbar : Nat → Nat) =&gt; lbar n + lrbar n + wbar n) foo.lrbar)</span>\n<span class=\"cm\">    foo.wbar</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>So both <code>let rec</code> and <code>where</code> use auxiliary definitions, and my guess is that there is good reason to treat them as opaque while elaborating <code>foo</code>. But maybe <code>where</code> could notice when it is not recursive and be elaborated as a regular <code>let</code>.</p>",
        "id": 234192198,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618246088
    },
    {
        "content": "<p>In my case, I wanted the <code>let rec</code> to turn into an auxiliary definition, not a local constant</p>",
        "id": 234193192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618246477
    },
    {
        "content": "<blockquote>\n<p>It seems that the delaborator still needs some more work.</p>\n</blockquote>\n<p>The delaborator definitely needs more work (<a href=\"https://github.com/leanprover/lean4/issues/368\">https://github.com/leanprover/lean4/issues/368</a>) but it should be rare to need to elaborate <code>brecOn</code>s once equation lemmas are being generated.</p>",
        "id": 234193211,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618246488
    },
    {
        "content": "<p>specifically, I would like the delaborator to <em>always</em> produce a term that typechecks. For anything with a higher order matching problem it should make the <code>motive := ...</code> explicit</p>",
        "id": 234193477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618246580
    },
    {
        "content": "<p>That is indeed the stated goal in the issue I linked to above. \"round trip\" means it re-elaborates to the original term.</p>",
        "id": 234193806,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618246720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234193192\">said</a>:</p>\n<blockquote>\n<p>In my case, I wanted the <code>let rec</code> to turn into an auxiliary definition, not a local constant</p>\n</blockquote>\n<p>In your case, the function wasn't recursive.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">findLeastRec</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lo</span> <span class=\"n\">hi</span> <span class=\"n\">z</span> <span class=\"n\">j</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Std.Range.forIn.loop</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">Id</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">lo</span><span class=\"o\">:</span><span class=\"n\">hi</span><span class=\"o\">]</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"k\">then</span> <span class=\"n\">yield</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">yield</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">j</span> <span class=\"n\">b</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 234194094,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618246830
    },
    {
        "content": "<p>Oh I guess that's true. I think it was in another version of the proof</p>",
        "id": 234194243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618246883
    },
    {
        "content": "<blockquote>\n<p>In my case, I wanted the let rec to turn into an auxiliary definition, not a local constant</p>\n</blockquote>\n<p>I think the issue is that it could be mutually recursive with the top-level definition. So similar to my suggestion that <code>where</code> detect when it is not recursive, perhaps <code>letrec</code> and <code>where</code> could also detect when it is \"self-contained recursive\", i.e. safe to turn into an auxiliary definition that does not refer to the current one.</p>",
        "id": 234194684,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618247034
    },
    {
        "content": "<p>Oh, that's interesting. How commonly is that used? Maybe there should be a special indicator for that, like <code>where mutual</code> or something</p>",
        "id": 234195144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618247202
    },
    {
        "content": "<p>detecting self-contained recursive is tough because you have to first run the tactics to find out what the term is, and the data given to the tactics depends on the result of the analysis (since they would be able to see whether an auxiliary definition was created)</p>",
        "id": 234195337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618247288
    },
    {
        "content": "<p>Currently, both of these work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">mfoo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">mbar</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">mbar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"n\">mfoo</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">wbar</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">wbar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234196102,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618247613
    },
    {
        "content": "<p>I think <code>where mutual</code> is tricky because you might batch many different functions in a <code>where</code> clause. But what about function-specific prefix?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">base</span> <span class=\"k\">else</span> <span class=\"n\">wbar</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"kd\">mutual</span> <span class=\"n\">wbar</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 234196907,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618247960
    },
    {
        "content": "<p>I was thinking you would either make all of them mutual or none</p>",
        "id": 234197677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618248275
    },
    {
        "content": "<p>but your version reads well</p>",
        "id": 234197974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618248393
    },
    {
        "content": "<p>if you could put <code>def</code> or <code>let</code> or <code>have</code> on definitions in where clauses that would also let you control whether they show up as local constants, auxiliary definitions, or let bindings</p>",
        "id": 234198205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618248487
    },
    {
        "content": "<blockquote>\n<p>for example if h : x &lt; y is in the context, match x with | 0 =&gt; ..., you lose the fact that 0 &lt; y. </p>\n</blockquote>\n<p>And presumably you think it is too annoying to match on <code>h</code> explicitly as in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span>   <span class=\"n\">h2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h2</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h2</span>\n</code></pre></div>\n<p>I think it is good practice to match on the <code>h</code> explicitly, but agree it is annoying to need to put it in every branch. What about a macro:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"n\">generalizing</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n\n<span class=\"c1\">-- could turn into:</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span><span class=\"o\">,</span>  <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 234198407,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618248588
    },
    {
        "content": "<p>In <code>cases</code> , you just use <code>cases n</code> and it generalizes everything in the context that depends on <code>n</code>. I've never seen a situation where this was undesirable</p>",
        "id": 234199249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618248922
    },
    {
        "content": "<p><code>induction</code> is another matter, but <code>match</code> doesn't support induction anyway</p>",
        "id": 234199376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618248966
    },
    {
        "content": "<p>Note that <code>induction</code> will automatically add <code>generalizing h</code> whenever <code>h</code> depends on the induction variable</p>",
        "id": 234199593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618249073
    },
    {
        "content": "<p>so you actually have to use <code>clear</code> if you don't want that</p>",
        "id": 234199624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618249083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234198205\">said</a>:</p>\n<blockquote>\n<p>if you could put <code>def</code> or <code>let</code> or <code>have</code> on definitions in where clauses that would also let you control whether they show up as local constants, auxiliary definitions, or let bindings</p>\n</blockquote>\n<p>I tentatively like this proposal</p>",
        "id": 234205676,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618251397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234199624\">said</a>:</p>\n<blockquote>\n<p>so you actually have to use <code>clear</code> if you don't want that</p>\n</blockquote>\n<p>Seems like apples-to-oranges since <code>match</code> is term mode, not tactic mode. </p>\n<blockquote>\n<p>On the other hand, cases apparently does not support nested pattern matches or the ability to use other expressions in the branches, for example matching a Nat as 0 and n+1 instead of zero and succ n (and putting those terms in the goal).</p>\n</blockquote>\n<p>Can you write the syntax you would  want for <code>cases</code> and <code>induction</code>?</p>",
        "id": 234206402,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618251695
    },
    {
        "content": "<blockquote>\n<p>Writing tactics and finding things is very difficult.</p>\n</blockquote>\n<p>FYI here is the API for builtin tactics designed for interactive mode: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Notation.lean#L189-L325\">https://github.com/leanprover/lean4/blob/master/src/Init/Notation.lean#L189-L325</a></p>",
        "id": 234207501,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618252139
    },
    {
        "content": "<blockquote>\n<p>Writing tactics and finding things is very difficult.</p>\n</blockquote>\n<p>I agree, though one doesn't need to find nearly as much when there are working, illustrative examples to copy-paste-tweak. How about we start collecting a set of informative examples in mathlib-prelude?</p>",
        "id": 234207938,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618252301
    },
    {
        "content": "<p>Here's an example of a macro that took me very long to figure out. I'm sure it's still buggy. How does one use <code>lemma</code> instead of <code>theorem</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"lemma\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"s2\">\":=\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 234208506,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618252496
    },
    {
        "content": "<p>Also, there are a few tricks we can put in a doc, e.g. to find how a command (e.g. <code>namespace</code>) is elaborated, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">grep</span> <span class=\"bp\">-</span><span class=\"n\">rni</span> <span class=\"s2\">\"commandElab.*namespace\"</span> <span class=\"bp\">../../</span><span class=\"n\">lean4</span><span class=\"bp\">/</span><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">Lean</span>\n<span class=\"bp\">../../</span><span class=\"n\">lean4</span><span class=\"bp\">/</span><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">Lean</span><span class=\"bp\">/</span><span class=\"n\">Elab</span><span class=\"bp\">/</span><span class=\"n\">Command.lean</span><span class=\"o\">:</span><span class=\"mi\">376</span><span class=\"o\">:</span><span class=\"kd\">@[builtinCommandElab «namespace»]</span> <span class=\"kd\">def</span> <span class=\"n\">elabNamespace</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>or parsed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">grep</span> <span class=\"bp\">-</span><span class=\"n\">rni</span> <span class=\"s2\">\"commandParser.*namespace\"</span> <span class=\"bp\">../../</span><span class=\"n\">lean4</span><span class=\"bp\">/</span><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">Lean</span><span class=\"bp\">/</span>\n<span class=\"bp\">../../</span><span class=\"n\">lean4</span><span class=\"bp\">/</span><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">Lean</span><span class=\"bp\">/</span><span class=\"n\">Parser</span><span class=\"bp\">/</span><span class=\"n\">Command.lean</span><span class=\"o\">:</span><span class=\"mi\">67</span><span class=\"o\">:</span><span class=\"kd\">@[builtinCommandParser]</span> <span class=\"kd\">def</span> <span class=\"bp\">«</span><span class=\"kn\">namespace</span><span class=\"bp\">»</span>    <span class=\"o\">:=</span> <span class=\"n\">leading_parser</span> <span class=\"s2\">\"namespace \"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ident</span>\n</code></pre></div>",
        "id": 234208930,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618252667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234206402\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234199624\">said</a>:</p>\n<blockquote>\n<p>so you actually have to use <code>clear</code> if you don't want that</p>\n</blockquote>\n<p>Seems like apples-to-oranges since <code>match</code> is term mode, not tactic mode. </p>\n</blockquote>\n<p>My original comment was about the <code>match</code> <em>tactic</em> as compared to the <code>cases</code> tactic</p>",
        "id": 234209992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618253125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234206402\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>On the other hand, cases apparently does not support nested pattern matches or the ability to use other expressions in the branches, for example matching a Nat as 0 and n+1 instead of zero and succ n (and putting those terms in the goal).</p>\n</blockquote>\n<p>Can you write the syntax you would  want for <code>cases</code> and <code>induction</code>?</p>\n</blockquote>\n<p>here's a start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p><code>induction</code> is harder since it has the extra <code>ih</code> argument hanging off.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 234210388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618253291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234208506\">said</a>:</p>\n<blockquote>\n<p>Here's an example of a macro that took me very long to figure out. I'm sure it's still buggy. How does one use <code>lemma</code> instead of <code>theorem</code>?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"lemma\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"s2\">\":=\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The only issue I see with yours is that <code>theorem</code> is actually a bit more powerful than that: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Parser/Command.lean#L40\">https://github.com/leanprover/lean4/blob/master/src/Lean/Parser/Command.lean#L40</a> After adding a line to that file to export the <code>declVal</code> shorthand, you can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"lemma\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"n\">val</span><span class=\"o\">:</span><span class=\"n\">declVal</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"bp\">$</span><span class=\"n\">sig</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I believe this will make <code>lemma</code> and <code>theorem</code> equivalent.</p>",
        "id": 234211282,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618253688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234208506\">said</a>:</p>\n<blockquote>\n<p>Here's an example of a macro that took me very long to figure out. I'm sure it's still buggy. How does one use <code>lemma</code> instead of <code>theorem</code>?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"lemma\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"s2\">\":=\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Based on the <code>theorem</code> parser, I think you want the last bit to be <code>declVal</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"lemma\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"n\">val</span><span class=\"o\">:</span><span class=\"n\">declVal</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"bp\">$</span><span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">:</span><span class=\"n\">declVal</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, this causes the same quotation panic that I've triggered in two other threads</p>",
        "id": 234211582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618253805
    },
    {
        "content": "<p>Right, so the working one I have is weaker, but functional. I didn't file a bug report on the panic, rather tried to find a stopgap partial replacement.</p>",
        "id": 234211681,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618253863
    },
    {
        "content": "<blockquote>\n<p>After adding a line to that file to export the declVal shorthand,</p>\n</blockquote>\n<p>Oh, that sounds problematic</p>",
        "id": 234211710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618253876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234211710\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>After adding a line to that file to export the declVal shorthand, you can write:</p>\n</blockquote>\n<p>Oh, that sounds problematic</p>\n</blockquote>\n<p>I will PR it.</p>",
        "id": 234211768,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618253888
    },
    {
        "content": "<p>This actually relates to another issue I've hit on: there are a lot of <code>private</code> functions in lean 4. I had to kill these with fire in lean 3 because they really hamper reuse</p>",
        "id": 234211882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618253940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234211882\">said</a>:</p>\n<blockquote>\n<p>This actually relates to another issue I've hit on: there are a lot of <code>private</code> functions in lean 4. I had to kill these with fire in lean 3 because they really hamper reuse</p>\n</blockquote>\n<p>Can you please explain the issue?</p>",
        "id": 234212072,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618254013
    },
    {
        "content": "<p>I recently tried to get the parsed <code>PreDeclaration</code> for a theorem. In order to do so, I had to bring in 15 or so (large) private definitions, before eventually getting stuck on a private macro, which I have no idea how to duplicate</p>",
        "id": 234212082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254018
    },
    {
        "content": "<p>You can't call private functions</p>",
        "id": 234212116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254030
    },
    {
        "content": "<p>so that means if you want to adapt a function that calls a private function, you have to copy and paste it, as well as any private functions it calls and so on transitively</p>",
        "id": 234212244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254072
    },
    {
        "content": "<p>it's a huge pain</p>",
        "id": 234212251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254075
    },
    {
        "content": "<p>I think <code>private</code> should never be used. You never know when someone is going to want to use your function</p>",
        "id": 234212449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254157
    },
    {
        "content": "<p>Is this just for debugging?</p>",
        "id": 234212503,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618254174
    },
    {
        "content": "<p>Yes and no</p>",
        "id": 234212542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234212449\">said</a>:</p>\n<blockquote>\n<p>I think <code>private</code> should never be used. You never know when someone is going to want to use your function</p>\n</blockquote>\n<p>This seems pretty extreme. Encapsulation is generally considered good design.</p>",
        "id": 234212652,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618254223
    },
    {
        "content": "<p>In that particular example it was for debugging, but it's totally legitimate to want to work with <code>PreDefinition</code> or any other implementation item</p>",
        "id": 234212746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254253
    },
    {
        "content": "<p>Not in a theorem prover that is meant to be hacked on by users</p>",
        "id": 234212798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234212244\">said</a>:</p>\n<blockquote>\n<p>so that means if you want to adapt a function that calls a private function, you have to copy and paste it, as well as any private functions it calls and so on transitively</p>\n</blockquote>\n<p>Personally, I tweak lean4 and rebuild all the time for things like this. The slow recompilation speed is annoying but my own fault for not having a threadripper.</p>",
        "id": 234212803,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618254277
    },
    {
        "content": "<p>Yeah, I'm worried I'm going to need to fork lean 4</p>",
        "id": 234212835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254295
    },
    {
        "content": "<p>Ultimately I thought the idea was that we don't need to</p>",
        "id": 234212905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"230999\">Daniel Selsam</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234212652\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234212449\">said</a>:</p>\n<blockquote>\n<p>I think <code>private</code> should never be used. You never know when someone is going to want to use your function</p>\n</blockquote>\n<p>This seems pretty extreme. Encapsulation is generally considered good design.</p>\n</blockquote>\n<p>If there was a way to open a namespace and get at the private functions this would be fine. But lean is intentionally designed to be modified and I don't think there is a single component of the system that isn't \"incomplete\" in the sense that users may want to add functionality to what is already there, and work with the data structures of that file</p>",
        "id": 234213489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254539
    },
    {
        "content": "<p>Certainly in mathlib <em>every single time</em> someone thought it would be a good idea to put <code>private</code> it turned out to be a mistake. At minimum, it is difficult to prove theorems about a private function, so in the far future when someone decides to prove e.g. the parser correct, they will get stuck on any \"encapsulation\"</p>",
        "id": 234213783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234212835\">said</a>:</p>\n<blockquote>\n<p>Yeah, I'm worried I'm going to need to fork lean 4</p>\n</blockquote>\n<p>FWIW I don't think it would be so bad for there to be a lean-community:lean4 as long as the patches were small enough that it could be frequently rebased.</p>",
        "id": 234213927,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618254736
    },
    {
        "content": "<p>I can live with that if others can</p>",
        "id": 234213962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254759
    },
    {
        "content": "<p>At least then I can get the mountain of PRs I'm holding off on off my back</p>",
        "id": 234214091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618254830
    },
    {
        "content": "<p>Even if the goal is to keep the lean-community version exactly equal to the main one, it may still make sense to fork now and experiment with your suggested changes. Leo will be much more likely to consider a PR down the road if it has been stress-tested and if there is community consensus on its value.</p>",
        "id": 234214548,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618255013
    },
    {
        "content": "<p>(okay, not a mountain, a few pebbles. But I don't know how to build the mountain when I can't place the first pebble.)</p>",
        "id": 234214657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618255075
    },
    {
        "content": "<p>Can someone who knows how to do so set up a community lean 4 nightly?</p>",
        "id": 234214753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618255115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/233923963\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Keeping the tactic proof well formed is a challenge, and sometimes the whitespace sensitivity causes surprises.</li>\n</ul>\n</blockquote>\n<p>Note that you can also use braces and semicolons:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n   <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"gr\">sorry</span><span class=\"bp\">;</span>\n     <span class=\"n\">exact</span> <span class=\"gr\">sorry</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 234226274,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618259870
    },
    {
        "content": "<p>not quite:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n   <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"gr\">sorry</span><span class=\"bp\">;</span>\n     <span class=\"n\">exact</span> <span class=\"gr\">sorry</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 234227025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260160
    },
    {
        "content": "<p>Ah, it looks like all subsequent bars after the first need to have at least as much offset, even in tactic-mode-with-bars</p>",
        "id": 234227163,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618260240
    },
    {
        "content": "<p>I haven't found a whitespace insensitive version of the syntax either</p>",
        "id": 234227264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260273
    },
    {
        "content": "<p>Oh, also it seems like <code>_</code> is a tactic now? I have a macro in my test file for that</p>",
        "id": 234227472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260367
    },
    {
        "content": "<p>I used <code>refine _</code> as the expansion because that gives a red squiggle and tells you the type, but also eats a goal and allows the rest to proceed, like <code>sorry</code></p>",
        "id": 234227565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260418
    },
    {
        "content": "<p>This is also the reason why</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">type</span>\n<span class=\"o\">{</span> <span class=\"n\">tac</span>\n  <span class=\"n\">tac</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>didn't work: inside braces, you <em>must</em> use semicolons. I've written a fair chunk of tactic proofs in Lean 4, but I never noticed that one because I tend to use Lean 4's new structuring techniques (all the stuff with <code>=&gt;</code>) instead of braces.</p>",
        "id": 234227705,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618260482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234227565\">said</a>:</p>\n<blockquote>\n<p>I used <code>refine _</code> as the expansion because that gives a red squiggle and tells you the type, but also eats a goal and allows the rest to proceed, like <code>sorry</code></p>\n</blockquote>\n<p>The <code>match</code> tactic calls <code>refine</code> automatically (<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Tactic/Match.lean#L66\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Tactic/Match.lean#L66</a>) and has for 6 months according to GitHub's blame</p>",
        "id": 234227847,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618260541
    },
    {
        "content": "<p>I'm fine with using the new structuring techniques, but it's awkward around <code>have</code> because of the <code>by</code></p>",
        "id": 234227853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260544
    },
    {
        "content": "<p>I mean the <code>_</code> tactic, as in <code>by _</code></p>",
        "id": 234227892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260567
    },
    {
        "content": "<p>that did not work a few weeks ago</p>",
        "id": 234227909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260581
    },
    {
        "content": "<p>But indentation should work for that, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">t</span> <span class=\"kd\">by</span>\n  <span class=\"n\">t'1</span>\n  <span class=\"n\">t'2</span>\n<span class=\"n\">t</span>\n</code></pre></div>",
        "id": 234227920,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618260590
    },
    {
        "content": "<p>It does</p>",
        "id": 234227929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260597
    },
    {
        "content": "<p>I just want to drop the <code>by</code></p>",
        "id": 234227982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260607
    },
    {
        "content": "<p>lean 3 doesn't need it</p>",
        "id": 234228003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260621
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234227892\">said</a>:</p>\n<blockquote>\n<p>I mean the <code>_</code> tactic, as in <code>by _</code></p>\n</blockquote>\n<p><code>theorem foo : True := by _</code> gives me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">expected</span> <span class=\"sc\">'{'</span> <span class=\"n\">or</span> <span class=\"n\">tactic</span>\n<span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">unexpected</span> <span class=\"n\">command</span>\n</code></pre></div>",
        "id": 234228134,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618260677
    },
    {
        "content": "<p>Also, a common lean 3 proof style is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"kd\">lemma</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lemma2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">this</span>\n</code></pre></div>\n<p>This doesn't work in lean 4 because the <code>have</code> doesn't proceed until all the metavariables in <code>lemma</code> are filled (while the proof technique might be using <code>lemma2</code> and the <code>exact</code> to figure out the metavariables)</p>",
        "id": 234228171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> That's odd, since your badly formatted code example uses the <code>_</code> tactic twice</p>",
        "id": 234228324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260755
    },
    {
        "content": "<p>No, because the <code>match</code> tactic is transforming the syntax to call <code>refine</code></p>",
        "id": 234228353,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618260774
    },
    {
        "content": "<p>you what now?</p>",
        "id": 234228414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260808
    },
    {
        "content": "<p>how does that work?</p>",
        "id": 234228439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618260819
    },
    {
        "content": "<p>This is the link I posted a few comments above: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Tactic/Match.lean#L66-L68\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Tactic/Match.lean#L66-L68</a></p>",
        "id": 234228495,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618260844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234227920\">said</a>:</p>\n<blockquote>\n<p>But indentation should work for that, right?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">t</span> <span class=\"kd\">by</span>\n  <span class=\"n\">t'1</span>\n  <span class=\"n\">t'2</span>\n<span class=\"n\">t</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>FWIW I like the <code>by</code> here.</p>",
        "id": 234228630,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618260905
    },
    {
        "content": "<p>Does the <code>by</code> create a new tactic scope like in lean 3?</p>",
        "id": 234228863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261012
    },
    {
        "content": "<p>if so that might explain the reason why the <code>rwa</code> proof style fails</p>",
        "id": 234228928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261041
    },
    {
        "content": "<p>Thoughts on <code>=&gt;</code> as alternative / in addition to <code>by</code>?</p>",
        "id": 234229374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261213
    },
    {
        "content": "<p>and <code>:=</code> as alternative to <code>from</code> as I mentioned before</p>",
        "id": 234229487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261229
    },
    {
        "content": "<p>I'm not a fan of the many syntaxes for introducing subgoals, <code>by</code> to start, <code>=&gt;</code> after cases, match, induction, <code>;</code> after refine (actually I haven't figured out how to select refine subgoals using multiple blocks yet)</p>",
        "id": 234230403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261409
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">refine</span> <span class=\"n\">foo</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">tac1a</span>\n  <span class=\"n\">tac1b</span>\n  <span class=\"n\">done</span>\n  <span class=\"n\">tac2a</span>\n  <span class=\"n\">tac2b</span>\n  <span class=\"n\">done</span>\n  <span class=\"n\">tac3a</span>\n  <span class=\"n\">tac3b</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 234230671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261486
    },
    {
        "content": "<p>With lean 3 style blocks this would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">refine</span> <span class=\"n\">foo</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"o\">{</span> <span class=\"n\">tac1a</span>\n  <span class=\"n\">tac1b</span> <span class=\"o\">}</span>\n<span class=\"o\">{</span> <span class=\"n\">tac2a</span>\n  <span class=\"n\">tac2b</span> <span class=\"o\">}</span>\n<span class=\"o\">{</span> <span class=\"n\">tac3a</span>\n  <span class=\"n\">tac3b</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>all the lean 4 options seem to be a lot more verbose</p>",
        "id": 234230864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234227705\">said</a>:</p>\n<blockquote>\n<p>This is also the reason why</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">type</span>\n<span class=\"o\">{</span> <span class=\"n\">tac</span>\n  <span class=\"n\">tac</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>didn't work: inside braces, you <em>must</em> use semicolons.</p>\n</blockquote>\n<p>Can we make that work with whitespace sensitivity? The rule I want is that the column starts at the first token after the <code>{</code></p>",
        "id": 234231414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261693
    },
    {
        "content": "<p>They look both pretty bad to me. How about naming them and using <code>case</code>?</p>",
        "id": 234231537,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618261718
    },
    {
        "content": "<p>because they don't have names</p>",
        "id": 234231625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> This works for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"kd\">structure</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"kd\">structure</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">AB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">BC</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">∧</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">And.intro</span> <span class=\"bp\">?</span><span class=\"n\">x</span> <span class=\"bp\">?</span><span class=\"n\">y</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">BC</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">AB</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">BC</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">AB</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 234231656,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618261753
    },
    {
        "content": "<p>Yes that works, but it means I have to give up whitespace sensitive lines</p>",
        "id": 234231752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261786
    },
    {
        "content": "<p>which screws up the overall formatting if I'm using it elsewhere</p>",
        "id": 234231845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261806
    },
    {
        "content": "<p>if some tactic lines end in <code>;</code> and others don't that will read weirdly</p>",
        "id": 234231976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261837
    },
    {
        "content": "<p>This also works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">∧</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">And.intro</span> <span class=\"bp\">?</span><span class=\"n\">x</span> <span class=\"bp\">?</span><span class=\"n\">y</span>\n  <span class=\"n\">focus</span>\n    <span class=\"n\">apply</span> <span class=\"n\">BC</span>\n    <span class=\"n\">apply</span> <span class=\"n\">AB</span>\n    <span class=\"n\">assumption</span>\n  <span class=\"n\">focus</span>\n    <span class=\"n\">apply</span> <span class=\"n\">BC</span>\n    <span class=\"n\">apply</span> <span class=\"n\">AB</span>\n    <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 234232121,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618261861
    },
    {
        "content": "<p>oh that's not bad</p>",
        "id": 234232190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261872
    },
    {
        "content": "<p>And there can probably be a variant where you name the focus branches</p>",
        "id": 234232204,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618261878
    },
    {
        "content": "<p>that's the version sebastian was suggesting</p>",
        "id": 234232240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261892
    },
    {
        "content": "<p>like <code>case ?x</code> instead of <code>focus</code></p>",
        "id": 234232250,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618261895
    },
    {
        "content": "<p>but I don't want to give names to goals where the best name is an ordinal</p>",
        "id": 234232339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618261923
    },
    {
        "content": "<p>Also, can <code>?</code> work instead of <code>?_</code>? It's an extra character compared to lean 3</p>",
        "id": 234232640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262032
    },
    {
        "content": "<p>You can use <code>refine' foo _ _ _</code> :)</p>",
        "id": 234232711,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618262064
    },
    {
        "content": "<p>I am pro-names in general</p>",
        "id": 234232718,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618262070
    },
    {
        "content": "<p>I want to be able to keep the structure of lean 3 proofs for the most part</p>",
        "id": 234232752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262098
    },
    {
        "content": "<p>names should be an option</p>",
        "id": 234232781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262109
    },
    {
        "content": "<p>meaning the same lack of structure?</p>",
        "id": 234232799,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618262118
    },
    {
        "content": "<p>They are structured</p>",
        "id": 234232813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262124
    },
    {
        "content": "<p>they are block structured proofs</p>",
        "id": 234232827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262133
    },
    {
        "content": "<p>We are pretty strict about that</p>",
        "id": 234232842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262146
    },
    {
        "content": "<p>I'm not about to rewrite all lean 3 proofs for style in the middle of a giant port</p>",
        "id": 234232966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262209
    },
    {
        "content": "<p>You can write unstructured proofs in lean 3 but I'm not talking about those</p>",
        "id": 234233200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262356
    },
    {
        "content": "<p>Got it</p>",
        "id": 234233216,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618262369
    },
    {
        "content": "<p>in fact it seems like lean 4's support for unstructured proofs is pretty much the same</p>",
        "id": 234233310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262406
    },
    {
        "content": "<p>It does seem so. I thought at some point the plan was to require names and <code>case ?x</code> but I guess that was ditched.</p>",
        "id": 234233401,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618262464
    },
    {
        "content": "<p>I like the current setup: you can write names and case if you want but you don't have to</p>",
        "id": 234233471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262495
    },
    {
        "content": "<p>lean 3 also cultivated (at least) two distinct styles: mathlib's block structured proofs and NNG's unstructured proofs (plus term mode proofs, which have several different styles)</p>",
        "id": 234233601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262563
    },
    {
        "content": "<p>I can imagine having a style linter to ensure adherence to one style or another</p>",
        "id": 234233654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262607
    },
    {
        "content": "<p>but the core syntax should be multi-paradigm</p>",
        "id": 234233673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234232966\">said</a>:</p>\n<blockquote>\n<p>I'm not about to rewrite all lean 3 proofs for style in the middle of a giant port</p>\n</blockquote>\n<p>Then that should be discussed in a different topic. I don't mind if mathport implements its own tactic compatibility layer. But this topic started as an experience report on Lean 4, not porting, so it should discuss the best solutions for Lean 4 irrespective of Lean 3 solutions. Which always was our modus operandi for Lean 4.</p>",
        "id": 234233864,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618262726
    },
    {
        "content": "<p>Fair enough. I guess I'm saying that even for green field lean 4 projects I'm not sold on the <code>| =&gt;</code> stuff</p>",
        "id": 234234057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262833
    },
    {
        "content": "<p>in coq I think the equivalent is <code>- </code></p>",
        "id": 234234090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262869
    },
    {
        "content": "<p>I really want a way to not waste a line saying \"here's a goal\"</p>",
        "id": 234234202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618262925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> </p>\n<blockquote>\n<p>I've written a fair chunk of tactic proofs in Lean 4</p>\n</blockquote>\n<p>Are these on GitHub somewhere?</p>",
        "id": 234234579,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618263146
    },
    {
        "content": "<p>Not publicly, unfortunately, since they are the solutions to our course project <span aria-label=\"frowning\" class=\"emoji emoji-1f626\" role=\"img\" title=\"frowning\">:frowning:</span></p>",
        "id": 234234737,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618263231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234234090\">said</a>:</p>\n<blockquote>\n<p>in coq I think the equivalent is <code>- </code></p>\n</blockquote>\n<p>I kind of like that, I think it would be a better fit for the whitespace-sensitive syntax than braces</p>",
        "id": 234235157,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618263449
    },
    {
        "content": "<p><a href=\"https://coq.inria.fr/refman/proof-engine/ssreflect-proof-language.html#indentation-and-bullets\">Coq syntax</a></p>",
        "id": 234239640,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1618266233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/233923963\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Implicit lambdas caused a number of issues because they get eagerly applied everywhere and it's difficult to control this behavior. I ended up having to avoid them entirely in things like the induction hypothesis. We need semi-implicits, I think.<ul>\n<li>I should find a more specific example here, but implicit lambda introduction was something I had to force-disable more often than use.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>I am curious about this one. I don't see any <code>@fun</code>s in the file you posted so I am guessing it was earlier in development.</p>",
        "id": 234240307,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618266626
    },
    {
        "content": "<p>I was curious about when coq uses <code>-</code> vs <code>*</code>; It is discussed in the \"bullets\" section, and it seems like you can use any of <code>-</code>, <code>+</code> and <code>*</code> to select subgoals, where I guess the idea is that you can use different delimiters at different levels. (I assume all delimiters at a given subgoal splitting have to agree.) Personally I think it would be better to just use one of them, since users might come up with some other meaning for the other sigils</p>",
        "id": 234241231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618267273
    },
    {
        "content": "<p>I can't replicate the <code>@fun</code> issues. I think I was forgetting <code>fun {i} =&gt;</code></p>",
        "id": 234241902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618267780
    },
    {
        "content": "<p>Oh there was a bug in a tactic involving implicit lambdas, let me see if I can replicate</p>",
        "id": 234241978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618267809
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- ⊢ ∀ {i : Nat}, i &lt; 0</span>\n  <span class=\"k\">have</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"mi\">1</span>\n  <span class=\"c1\">-- i✝ this : Nat ⊢ i✝ &lt; 0</span>\n  <span class=\"n\">skip</span>\n</code></pre></div>\n<p>The same thing happens with <code>let</code> and <code>match</code></p>",
        "id": 234242559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618268225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234241231\">said</a>:</p>\n<blockquote>\n<p>I was curious about when coq uses <code>-</code> vs <code>*</code>; It is discussed in the \"bullets\" section, and it seems like you can use any of <code>-</code>, <code>+</code> and <code>*</code> to select subgoals, where I guess the idea is that you can use different delimiters at different levels. (I assume all delimiters at a given subgoal splitting have to agree.) Personally I think it would be better to just use one of them, since users might come up with some other meaning for the other sigils</p>\n</blockquote>\n<p>Yup, any bullet can be used in any nesting level as long as the same bullet is used for the same level. Also, indentation doesn't matter when using bullets -- these are all legal (though obviously only the first one is a good idea):</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Theorem</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span><span class=\"o\">).</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">split</span><span class=\"o\">;</span> <span class=\"o\">[|</span><span class=\"k\">split</span><span class=\"o\">];</span> <span class=\"o\">[|</span> <span class=\"o\">|</span><span class=\"k\">split</span><span class=\"o\">].</span> <span class=\"c\">(* split into multiple goals for demonstration*)</span>\n\n  <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">split</span><span class=\"o\">.</span>\n    <span class=\"o\">-</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n    <span class=\"o\">-</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">ex2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span><span class=\"o\">).</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">split</span><span class=\"o\">;</span> <span class=\"o\">[|</span><span class=\"k\">split</span><span class=\"o\">];</span> <span class=\"o\">[|</span> <span class=\"o\">|</span><span class=\"k\">split</span><span class=\"o\">].</span> <span class=\"c\">(* split into multiple goals for demonstration*)</span>\n\n  <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n    <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n<span class=\"o\">*</span> <span class=\"k\">split</span><span class=\"o\">.</span>\n  <span class=\"o\">-</span> <span class=\"k\">constructor</span><span class=\"o\">.</span> <span class=\"o\">-</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">ex3</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">/\\</span> <span class=\"n\">True</span><span class=\"o\">).</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">split</span><span class=\"o\">;</span> <span class=\"o\">[|</span><span class=\"k\">split</span><span class=\"o\">];</span> <span class=\"o\">[|</span> <span class=\"o\">|</span><span class=\"k\">split</span><span class=\"o\">].</span> <span class=\"c\">(* split into multiple goals for demonstration*)</span>\n\n  <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span> <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span> <span class=\"o\">*</span> <span class=\"k\">split</span><span class=\"o\">.</span> <span class=\"o\">-</span> <span class=\"k\">constructor</span><span class=\"o\">.</span> <span class=\"o\">-</span> <span class=\"k\">constructor</span><span class=\"o\">.</span> <span class=\"o\">*</span> <span class=\"k\">constructor</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>One limitation of this notation is that you can do at most three levels of nesting. But one might argue that if you need more, your proof is too complicated and you need to refactor :)</p>",
        "id": 234246837,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1618270981
    },
    {
        "content": "<p>Oh I see, it's not whitespace sensitive so the different sigils are required</p>",
        "id": 234249060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618272483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proving.20findLeast.3A.20an.20experience.20report/near/234242559\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- ⊢ ∀ {i : Nat}, i &lt; 0</span>\n  <span class=\"k\">have</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"mi\">1</span>\n  <span class=\"c1\">-- i✝ this : Nat ⊢ i✝ &lt; 0</span>\n  <span class=\"n\">skip</span>\n</code></pre></div>\n<p>The same thing happens with <code>let</code> and <code>match</code></p>\n</blockquote>\n<p>This is really weird. Here are some more examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">id</span> <span class=\"c1\">-- error: type mismatch, expected type P</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"n\">_</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">id</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"mi\">1</span>\n  <span class=\"n\">apply</span> <span class=\"n\">id</span> <span class=\"c1\">-- error: unsolved goals |- P</span>\n</code></pre></div>",
        "id": 234256598,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618278723
    },
    {
        "content": "<p>yeah, I think that first example was the issue I hit that caused me to abandon the approach</p>",
        "id": 234257028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618279105
    },
    {
        "content": "<p>I don't even understand what is happening there.</p>",
        "id": 234257046,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618279133
    },
    {
        "content": "<p>the type just felt very unstable, as if looking at it wrong causes it to get instantiated</p>",
        "id": 234257051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618279145
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> FYI <code>declVal</code> is exposed now on master so </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"lemma\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">declId</span> <span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"n\">declSig</span> <span class=\"n\">val</span><span class=\"o\">:</span><span class=\"n\">declVal</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"bp\">$</span><span class=\"n\">sig</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>should work.</p>",
        "id": 234260714,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618282518
    },
    {
        "content": "<p>I just read over the implicit-lambda code. It is surprisingly aggressive but based on relatively simple rules. Basically, any variant of the above examples will have a lambda inserted, unless it (a) doesn't involve elaborating a term with the expected type or (b) explicitly disables it. The reason the <code>apply id</code> example works is that <code>apply</code> (unlike <code>exact</code>) detects that <code>id</code> is an identifier and doesn't actually elaborate it using the expected type.</p>",
        "id": 234261791,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618283447
    },
    {
        "content": "<p>Sorry to be late to this party, but regarding the \"private\" keyword, would it help to keep their names but prefix the namespace with \"private\"? They could then be filtered by documentation and search, but determined users could still access them. The main problem would be name clashes -- users would have to use <code>private foo</code> and <code>private foo1</code> and <code>private foo2</code> in the namespace where they could just use <code>private foo</code> repeatedly before.</p>",
        "id": 234346586,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1618327195
    },
    {
        "content": "<p>The names are preserved, including namespaces: <a href=\"https://github.com/leanprover/lean4/blob/bf4b9b0ccd7688d3d4024bc06a0c7a3b207124bd/src/Lean/Modifiers.lean#L24-L27\">https://github.com/leanprover/lean4/blob/bf4b9b0ccd7688d3d4024bc06a0c7a3b207124bd/src/Lean/Modifiers.lean#L24-L27</a><br>\nA dedicated meta hacker could write a <code>tear_open_private</code> command that walks through the declarations of a specified module and creates accessible aliases of such names. But there would be no guarantee that this will keep working indefinitely, of course. For example, it is incompatible with any kind of module system where private declarations are not part of the \"signature\" .olean file to begin with (though the full .olean file should still be around to load instead). At that point private declarations would also become much more useful: you could add new ones without having to recompile (some) downstream modules.</p>",
        "id": 234349966,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618328291
    },
    {
        "content": "<p>FWIW I am skeptical that <code>private</code> is a real issue right now. For random experiments and traces, locally rebuilding Lean is fine.</p>",
        "id": 234350827,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618328625
    },
    {
        "content": "<p><code>tear_open_private</code> is called <a href=\"https://leanprover-community.github.io/mathlib_docs/commands.html#import_private\"><code>import_private</code></a> right now. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 234355239,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1618330179
    },
    {
        "content": "<p>(and if there are some <code>private</code> defs that are deemed important to expose, these can be changed on case-by-case basis)</p>",
        "id": 234355369,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1618330211
    },
    {
        "content": "<blockquote>\n<p>For example, it is incompatible with any kind of module system where private declarations are not part of the \"signature\" .olean file to begin with</p>\n</blockquote>\n<p>I don't think that is realistic.  Private definitions are part of the public interface because they are exposed during unification.  In particular, changing private definitions is a breaking change because it affects definitional equality.<br>\nOn the other hand, leaving out \"definitions\" of constants would be fair game.</p>",
        "id": 234355561,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1618330301
    },
    {
        "content": "<p>Ah, but the module system that only exists in my head would also seal (make opaque) public definitions by default... it might be mostly useful for programming and not proving, so it would most likely be opt-in and the standard <code>import</code> would keep its current lax semantics.</p>",
        "id": 234356922,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618330794
    },
    {
        "content": "<p>Using private declarations from a <code>reducible</code> or otherwise exposed declaration should ideally be a compiler error</p>",
        "id": 234357296,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618330914
    },
    {
        "content": "<p>Would type-checking also be restricted to reducible transparency?</p>",
        "id": 234357424,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1618330955
    },
    {
        "content": "<p>For imported definitions? <em>If</em> you imported them via say <code>import signature</code> <em>and</em> they don't have some other attribute that says \"transparent in signature imports but not <code>reducible</code>\", then yes.</p>",
        "id": 234357784,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618331098
    },
    {
        "content": "<p>So it's not really a change in the transparency predicate, but <code>import signature</code> importing definitions as value-less constants by default.</p>",
        "id": 234358065,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618331182
    },
    {
        "content": "<p>And then you'd just need some content-addressed build system to actually make use of that... it's as thought-out as it sounds, yes</p>",
        "id": 234358617,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1618331381
    },
    {
        "content": "<p>Ah, so things like <code>def Options := KVMap</code> would still reduce because they're not imported as signature.  It's an interesting dialect, but probably not that useful if you want to keep theorems close to your definitions.</p>",
        "id": 234358679,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1618331403
    }
]
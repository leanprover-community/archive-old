[
    {
        "content": "<p>On nightly-2021-11-06, I expected the following piece of code to type check:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"n\">where</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span>\n<span class=\"kd\">def</span> <span class=\"n\">fc</span> <span class=\"o\">[</span><span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">C.c</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">fd</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">C.c</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, <code>fd</code> does not compile with the following error message:</p>\n<div class=\"codehilite\" data-code-language=\"error\"><pre><span></span><code>  D.toC\nargument has type\n  D\nbut function has type\n  [self : D] → C\n</code></pre></div>\n<p>Is this a bug or do I misunderstand something?<br>\nWhen I replace extends by a manual instance, I still see the error.<br>\nWhen I replace Sort u by Prop, or by any type with a fixed universe, the error goes away.<br>\nThanks for suggestions...</p>",
        "id": 260524730,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636218188
    },
    {
        "content": "<p>Hi, here is perhaps a more convincing mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"n\">where</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span>\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">[</span><span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">C.f</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">D.toC.f</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">C.f</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>Oddly, b compiles but not c and I can't figure out why. I might be wrong but it looks like a bug to me. Any idea what could be wrong?</p>\n<p>To give more context I was trying to formalize Nat's with a philosophy of avoiding inductive types completely.<br>\nBut the problem is that my Nat class extends Nat_induction, and then I got stuck so I reduced my problem to the above mwe.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Zero</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n<span class=\"kn\">export</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Succ</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n<span class=\"kn\">export</span> <span class=\"n\">Succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Succ_Not_Zero</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ_not_zero</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span>\n<span class=\"kn\">export</span> <span class=\"n\">Succ_Not_Zero</span> <span class=\"o\">(</span><span class=\"n\">succ_not_zero</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Eq_Of_Succ_Eq_Succ</span> <span class=\"o\">[</span><span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">eq_of_succ_eq_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n<span class=\"kn\">export</span> <span class=\"n\">Eq_Of_Succ_Eq_Succ</span> <span class=\"o\">(</span><span class=\"n\">eq_of_succ_eq_succ</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Nat_Induction</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">nat_induction</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">P0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">zero</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span>\n<span class=\"kn\">export</span> <span class=\"n\">Nat_Induction</span> <span class=\"o\">(</span><span class=\"n\">nat_induction</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Natural</span>\n<span class=\"kd\">extends</span> <span class=\"n\">Zero</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">Succ_Not_Zero</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">Eq_Of_Succ_Eq_Succ</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">Nat_Induction</span> <span class=\"n\">N</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Natural</span> <span class=\"n\">ℕ</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pred_with_proof</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">k</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span> <span class=\"bp\">→</span> <span class=\"bp\">Σ'</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">m</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat_induction</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">False.elim</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">pred_with_proof</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>pred_with_proof  will fail to type check...</p>\n<p>Thanks in advance for any suggestions you might have ...</p>",
        "id": 261053825,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636577974
    },
    {
        "content": "<p><code>class</code>es are inductive types ;-) The difference is that they only have one constructor.</p>",
        "id": 261114105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636625421
    },
    {
        "content": "<p>I think <code>nat_induction</code> does not mean what you think it means</p>",
        "id": 261136509,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636638917
    },
    {
        "content": "<p>The class <code>Nat_Induction</code> has two universe levels, one for <code>N</code> and one for the universe level that you can eliminate into</p>",
        "id": 261137019,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636639206
    },
    {
        "content": "<p>Maybe you already realize this... but it's pretty suspect; for example how could Lean figure out that the instance <code>Natural ℕ</code> in <code>pred_with_proof</code> has to be of the level that allows elimination into the type <code>ℕ</code>? I mean we can see this because we know that <code>[Natural ℕ]</code> is intended to discharge the class assumption in the single use of <code>nat_induction</code>, but Lean doesn't think this way</p>",
        "id": 261137432,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636639404
    },
    {
        "content": "<p>The behavior in your original post still seems strange though--I don't get an error with the Lean 3 translation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span>\n<span class=\"kd\">def</span> <span class=\"n\">fc</span> <span class=\"o\">[</span><span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">C.c</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">fd</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"n\">C.c</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 261137654,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636639511
    },
    {
        "content": "<p>Classes might be implemented as inductive types under the hood, but I like to think of them as an orthogonal system separate from inductive types that lean provides.</p>\n<p>The reason I put a Sort _ in nat_induction instead of a Prop, is just because I saw that Nat.rec signature uses a Sort _. I essentially copied Nat.rec's signature. I acknowledge that my naming conventions are kind of inaccurate here and there.<br>\nI am aware that there are 2 universes in nat_induction but I didn't really understand why according to you that would be an issue. To help lean with the nat_induction call I am giving the return type : P n explicitly. Alternatively I could be explicit about P and say (P := P) </p>\n<p>If this was an issue about universes, why would b type check and not c in the below example on lean4 nightly-2021-11-10 ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"n\">where</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span>\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">[</span><span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">C.f</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">D.toC.f</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">C.f</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>All the universes revolving around c also revolve around b as I understand it.</p>\n<p>I'll translate my longer code to lean3 to get clearer ideas when I find some time.<br>\nThank you for your comments.</p>",
        "id": 261162612,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636651740
    },
    {
        "content": "<p>What I mean is the <em>class</em> <code>Nat_Induction</code> itself (and hence also the class <code>Natural</code>) has two universe parameters, and Lean won't guess which universe level instantiation of <code>Natural</code> you want to provide when you write <code>variable {ℕ} [Natural ℕ]</code>.</p>",
        "id": 261166363,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636653682
    },
    {
        "content": "<p>I'm guessing what you want/expect is for <code>nat_induction</code> to be quantified over <em>all</em> universes like <code>Nat.rec</code> is, but it's not.</p>",
        "id": 261166503,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636653748
    },
    {
        "content": "<p>In this example with <code>a b c</code>, it's clear that you mean <code>def a [C.{1}] := C.f Nat</code>, <code>def b [D.{1}] := ...</code>, <code>def c [D.{1}] := ...</code>, but I'm not sure why Lean figures that out in some cases but not others.</p>",
        "id": 261166765,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636653907
    },
    {
        "content": "<p>Actually we have (or used to have?) a similar issue in the category theory library, where it's hard to predict when you need to include universe variables, but maybe it was fixed?</p>",
        "id": 261167549,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636654370
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403214\">@Michael Jam</span> the error in your original post is likely a bug with Lean. Since <code>D</code> is a class, its auto-generated <code>self</code> parameters for fields are tagged as synthetic (i.e.,  using<code>[self : D]</code> for the binder). This results in the signature of <code>D.toC</code> being <code>[self : D] -&gt; C</code> (with no explicit parameter). The automatic structure to parent conversion, however , is mistaking trying to insert an invalid <code>D.toC d</code> argument. In code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fd</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">C.c</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (mistakenly) elaborates to roughly</span>\n<span class=\"kd\">def</span> <span class=\"n\">fd</span> <span class=\"o\">[</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">C.c</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:=</span> <span class=\"n\">D.toC</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 261176041,
        "sender_full_name": "Mac",
        "timestamp": 1636659297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  I see what you mean now. Thanks for clarifying. </p>\n<p>Is there a way to quantify a universe variable in a class method? Or is there a reason its not possible?  I tried to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">nat_induction.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>in the class definition but it gives me some \"invalid field\" error.<br>\nThe v universe seems to always get attached to the class itself which isn't what I want.</p>",
        "id": 261366626,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636818445
    },
    {
        "content": "<p>Since the universe of the class must be at least as large as those of the class fields, you would need an ordinal as the universe level (as well as being able to quantify over universe levels at that position in the first place), which Lean does not support.</p>",
        "id": 261367098,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1636819116
    },
    {
        "content": "<p>I see ... So inductive types are in a way more expressive than type classes because they define some functions with universe quantifications</p>",
        "id": 261367434,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636819474
    },
    {
        "content": "<p>I might ask a stupid question but, why does a class need to have a type? Couldn't it be a type-less set of requirements?</p>",
        "id": 261367536,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636819603
    },
    {
        "content": "<p>In Lean's type theory, everything needs to have a type. There might well be other set-ups where you can avoid this I guess.</p>",
        "id": 261367993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636820250
    },
    {
        "content": "<p>Interestingly, Coq's modules are not first-class values and thus do not have a type and <em>can</em> quantify like this even without ordinal universes. But one consequence of that is that they need special kernel support.</p>",
        "id": 261368228,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1636820581
    },
    {
        "content": "<p>You could get rid of the classes by just passing everything directly, but you still can't abstract over universe-polymorphic values.</p>",
        "id": 261368298,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636820677
    },
    {
        "content": "<p>You <em>could</em> statically \"abstract\" over universe polymorphic values though using a macro that produce a version of the class for each universe (like C++'s templates), but that isn't exactly in the spirit of Lean's type theory. That is, it would (in general) be better (and easier) to adapt one's approach to Lean's style, than try and force it to do what one wants.</p>",
        "id": 261368379,
        "sender_full_name": "Mac",
        "timestamp": 1636820821
    },
    {
        "content": "<p>Is there like a good example or situation showing why it's useful for a typeclass to have a type? I don't really have one in mind, that's why I was just wondering...</p>",
        "id": 261368516,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636821049
    },
    {
        "content": "<p>It makes the kernel smaller, because you don't need special kernel support for them.</p>",
        "id": 261368777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636821435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"403214\">Michael Jam</span> <a href=\"#narrow/stream/270676-lean4/topic/weird.20class.20error/near/261368516\">said</a>:</p>\n<blockquote>\n<p>Is there like a good example or situation showing why it's useful for a typeclass to have a type? I don't really have one in mind, that's why I was just wondering...</p>\n</blockquote>\n<p>How exactly are your proposing for them to not have a type?</p>",
        "id": 261368843,
        "sender_full_name": "Mac",
        "timestamp": 1636821508
    },
    {
        "content": "<p>What you are saying really is \"why do we use Lean's type theory instead of another type theory?\" Other programs use other type theories.</p>",
        "id": 261368874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636821559
    },
    {
        "content": "<p>OK so its mostly a reason of implementation. I guess as you were saying it's because they are implemented as inductive types under the hood, so all the inductive type machinery can be reused.</p>",
        "id": 261368884,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636821575
    },
    {
        "content": "<p>Note that type classes in Lean 4 (if not in <code>Prop</code>) are data that can be passed around to functions and are thus compiled. Types in Lean provide info to the compiler as to the representation of the object in memory. Without a type for the class, Lean would have no way of knowing how to compile them.</p>",
        "id": 261368938,
        "sender_full_name": "Mac",
        "timestamp": 1636821616
    },
    {
        "content": "<p>I mean, type classes in Haskell do not have a type either. It's not unimaginable, just very unlikely to change.</p>",
        "id": 261368964,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1636821677
    },
    {
        "content": "<p>Is the typeclass system part of Lean's type theory itself? isn't it external?</p>",
        "id": 261368967,
        "sender_full_name": "Michael Jam",
        "timestamp": 1636821685
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> ah, yes they do?</p>",
        "id": 261368968,
        "sender_full_name": "Mac",
        "timestamp": 1636821690
    },
    {
        "content": "<p>type classes in GHC are functions of the kind <code>Constraint</code></p>",
        "id": 261368971,
        "sender_full_name": "Mac",
        "timestamp": 1636821710
    },
    {
        "content": "<p>I take the +1 from a GHC dev to say that constraints really are not types in any reasonable sense</p>",
        "id": 261369038,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1636821767
    },
    {
        "content": "<p>Well, mainly GHC is not Haskell.</p>",
        "id": 261369043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636821780
    },
    {
        "content": "<p><code>Eq a</code> isn't a type.</p>",
        "id": 261369051,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636821789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> what do you mean by that?</p>",
        "id": 261369060,
        "sender_full_name": "Mac",
        "timestamp": 1636821831
    },
    {
        "content": "<p>The point that I think you're making is that there are sensible languages which don't treat classes and types as the same, and consequently have special-purpose mechanisms for passing instances (<code>Eq a =&gt;</code>), or constructing values (<code>instance Eq a</code>), etc.</p>",
        "id": 261369114,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636821889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  But Lean does have special purpose mechanisms for type classes and does treat them differently. For example, you can't use a synthetic binder for a non-class object.</p>",
        "id": 261369204,
        "sender_full_name": "Mac",
        "timestamp": 1636821990
    },
    {
        "content": "<p>I don't see a significant difference in the way that GHC and Lean conceptual think of type classes (at a type theory level). They, however, do have different ideas of how type classes should be used (GHC's single instance resolution vs Lean's tabled multi-instance resolution).</p>",
        "id": 261369282,
        "sender_full_name": "Mac",
        "timestamp": 1636822096
    },
    {
        "content": "<p>This doesn't seem like a good-faith discussion to me, so I'm going to drop it.</p>",
        "id": 261369299,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636822144
    },
    {
        "content": "<p>Huh? I am entirely confused. It appears that I have come off badly, but I am not really sure why. However, I do apologize if that is the case.</p>",
        "id": 261369392,
        "sender_full_name": "Mac",
        "timestamp": 1636822279
    },
    {
        "content": "<p>Maybe there was a language issue about what it means to be (or to have) a type. In any case, I don't think the discussion was useful. The point is just that it's perfectly sensible to separate the world of values and types from the world of instances and classes. For example, Haskell (as defined by the language standard) works this way. Lean doesn't do this, and that is unlikely to change.</p>",
        "id": 261370502,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636823731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403214\">@Michael Jam</span> For you <code>pred_with_proof</code> example, on an old version of Lean 4 (<code>lean4:nightly-2021-06-02</code>) I don't see any errors. (Maybe there are no errors because of a bug that's long been corrected.)</p>",
        "id": 261378515,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636835288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"403214\">Michael Jam</span> <a href=\"#narrow/stream/270676-lean4/topic/weird.20class.20error/near/261367434\">said</a>:</p>\n<blockquote>\n<p>I see ... So inductive types are in a way more expressive than type classes because they define some functions with universe quantifications</p>\n</blockquote>\n<p>I think this is only in the sense that every universe quantification has to come first in a type.  For class members, there's an implicit class instance argument, and since universe quantification has to come before that argument, the class has to be dependent on that universe level.</p>\n<p>There's nothing really special with universe quantifications that inductive types can do, I think.  All this means is that you have to give instances that quantify over the universe variables (i.e., there's a separate <code>Nat_induction</code> class for every single substitution of universe variables), but you're liable to run into typeclass inference issues since it's easy to get into situations where Lean's going to fail to find instances. It won't fill in universe metavariables for you without some reason to.</p>",
        "id": 261378656,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636835510
    },
    {
        "content": "<p>I guess (very) the awkward thing is that your proofs have to take <code>Nat_induction</code> instances for every universe variable that a proof depends on, rather than just a single instance, if you want to use classes for something like this.</p>",
        "id": 261379144,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636836244
    },
    {
        "content": "<p>That's a limitation of the type system, though -- you can't make a function that takes a universe-polymorphic function as an argument.</p>",
        "id": 261379184,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636836347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403214\">@Michael Jam</span> For what it's worth, a reason you don't need recursors using the typeclass system is that if you had one, it's possible to prove that your type is isomorphic to some inductive type, so you can instead have a typeclass that holds a proof of equivalence.  The recursor then becomes a theorem, and that theorem is able to quantify over universe variables.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Equiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">inv_fun</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">inv_fun</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Zero</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n<span class=\"kn\">export</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Succ</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n<span class=\"kn\">export</span> <span class=\"n\">Succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Nat_Induction</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">from_nat</span> <span class=\"o\">:</span> <span class=\"n\">Equiv</span> <span class=\"n\">Nat</span> <span class=\"n\">N</span>\n  <span class=\"n\">zero_eq</span> <span class=\"o\">:</span> <span class=\"n\">from_nat.to_fun</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">zero</span>\n  <span class=\"n\">succ_eq</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">from_nat.to_fun</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">from_nat.to_fun</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nat_induction</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nat_Induction</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"c1\">-- prove this by induction on Nat_Induction.from_nat.inv_fun n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">succ_not_zero</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nat_Induction</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n   <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_of_succ_eq_succ</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Succ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nat_Induction</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 261386221,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636846134
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403214\">@Michael Jam</span> and <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>, did you open a bug report for the erroneous explicit argument? I'm asking because I keep running into a somewhat similar issue and I'm wondering whether it is the same bug or not. Here is an MWE (though probably not completely minimal):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"o\">[</span><span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">e.c</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">E</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>On the last line, with <code>lean4:nightly-2021-11-12</code> I get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">instC</span> <span class=\"n\">a</span>\n<span class=\"n\">argument</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">E</span> <span class=\"n\">a</span>\n<span class=\"n\">but</span> <span class=\"n\">function</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">[</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">a</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 261569020,
        "sender_full_name": "Sebastian Reichelt",
        "timestamp": 1637015207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198266\">@Sebastian Reichelt</span> no, I did not. And yeah, that looks like it is probably the same error.</p>",
        "id": 261569700,
        "sender_full_name": "Mac",
        "timestamp": 1637015550
    },
    {
        "content": "<p>Thank you. I've reported it as <a href=\"https://github.com/leanprover/lean4/issues/796\">https://github.com/leanprover/lean4/issues/796</a> now.</p>",
        "id": 261574698,
        "sender_full_name": "Sebastian Reichelt",
        "timestamp": 1637018048
    }
]
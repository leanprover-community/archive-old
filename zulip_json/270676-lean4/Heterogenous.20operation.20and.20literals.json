[
    {
        "content": "<p>I'm having hard time using heterogenous operations together with number literals. For example writing <code>2*x</code> always gives me an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">HMul</span> <span class=\"n\">X</span> <span class=\"n\">X</span> <span class=\"bp\">?</span><span class=\"n\">m.1180</span>\n <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">OfNat</span> <span class=\"n\">X</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>i.e. Lean tries to use homogenous operation and cast <code>2</code> to <code>X</code>. What I have to do it to manually specify the type of two,<code>(2:ℝ)*x</code>.</p>\n<p>Here is variant of this problem with addition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Idx</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">USize</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">i.1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i.toUSize</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">USize</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"c1\">-- this works</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span>  <span class=\"c1\">-- this does not work</span>\n</code></pre></div>",
        "id": 281441307,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651845123
    },
    {
        "content": "<p>I don't know how to tell Lean to automatically look for an instance of an heterogeneous operation when using <code>+</code>.<br>\nBut this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Idx</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">USize</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">i.1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i.toUSize</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">USize</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"c1\">-- this works</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span>  <span class=\"c1\">-- this does not work</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mySum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">n</span> <span class=\"s2\">\" ⊹ \"</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mySum</span> <span class=\"n\">n</span> <span class=\"n\">s</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">⊹</span> <span class=\"mi\">5</span> <span class=\"c1\">-- this works</span>\n</code></pre></div>",
        "id": 281443021,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651845932
    },
    {
        "content": "<p>Haha cute <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span>  but no, I really want to use normal <code>+</code> sign.</p>",
        "id": 281443250,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651846032
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>: isn't it a bit weird though? I mean, using <code>+</code> to simbolize a sum of things with different types</p>",
        "id": 281443976,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651846343
    },
    {
        "content": "<p>Yeah in this instance you are probably right. But with scalar multiplication I really want to write <code>2*x</code> for <code>x : X</code> where <code>X</code> is a vector space.</p>",
        "id": 281444892,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651846769
    },
    {
        "content": "<p>I would take a look at how it's done in mathlib, but I'm skeptical that the common multiplication symbol <code>*</code> is used in these cases.</p>\n<p>(not too related!) I remember Julian Berman posted a link to an amazing post where Andrej Bauer explained the layers of inferences needed for a computer to understand what we mean when we (informally) multiply a scalar number and a vector</p>\n<p><del>@<strong>Julian Berman</strong> sorry to ping, but do you still have that link? I want to read it again</del> <a href=\"https://mathoverflow.net/a/376973\">Found it</a>!</p>",
        "id": 281446223,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651847314
    },
    {
        "content": "<p>Mathlib4 does not have definition of modules/group_action yet. It has rings and there</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>    <span class=\"c1\">-- 4 has type A</span>\n<span class=\"k\">#check</span> <span class=\"o\">((</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>   <span class=\"c1\">-- output: ↑4 * a : A    i.e. (4:Nat) get cast to A and then multiply</span>\n</code></pre></div>\n<p>Also mathlib4 does not seem to even define <code>HAdd Nat A A</code>.</p>\n<p>Mathlib3 uses <code>•</code> as it does not have heterogenous operations.</p>",
        "id": 281453628,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651850095
    },
    {
        "content": "<p>I've been using HMul for something that's essentially a vector space, and it seemed like there was no way around the fact that you have to specify the types of numeric literals when used as scalars.</p>",
        "id": 281454866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651850693
    },
    {
        "content": "<p>Is there a special elaboration rule that when you have <code>2 * x</code> it will try to use the type of <code>x</code> to synthesize an <code>OfNat</code> instance for the <code>2</code>? I know that there's a default instance to get an <code>HMul</code> from a <code>Mul</code>, but that doesn't seem to be what's applying here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[defaultInstance]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">hMul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Mul.mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 281455595,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651851025
    },
    {
        "content": "<p>I was playing around with <code>defaultInstance</code> and was unable to get anything out of it.</p>",
        "id": 281455705,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651851080
    },
    {
        "content": "<p>I do not understand elaboration at all, so I can't answer that.</p>",
        "id": 281455758,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651851105
    },
    {
        "content": "<p>For example this hack works i.e. define a new type for each natural number, <code>NatLit n</code>, and notation <code># n</code> creates a value of that type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">NatLit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">val</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">NatLit</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">m.toUSize</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"#\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">NatLit.val</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"bp\">#</span><span class=\"mi\">5</span>\n</code></pre></div>",
        "id": 281456178,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651851282
    },
    {
        "content": "<p>If you want that to feel less like a hack, you could think about <code>NatLit</code> as being a type of rank-0 arrays (using J terminology), and then you could require that broadcasting rules should only apply to actual arrays.</p>",
        "id": 281456963,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651851615
    },
    {
        "content": "<p>Oh, I didn't read what <code>Idx</code> actually was. Never mind. I somehow thought it was a length-n array of indices.</p>",
        "id": 281457079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651851676
    },
    {
        "content": "<p>Yeah if you are working with arrays you can do something like that. Or when I want to multiply <code>ℝ -&gt; ℝ</code> by <code>2</code> I can cast <code>2</code> to <code>fun _ =&gt; (2:ℝ)</code>. But when working with a generic vector space <code>X</code> I can't meaningfully assign type <code>X</code> to <code>2</code>.</p>",
        "id": 281457666,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651851942
    },
    {
        "content": "<p>Hijacking all numerical literals with macro like this does not work either:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span><span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Lean.Parser.numLit</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">NatLit.val</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Full code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Idx</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">USize</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">i.1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">USize</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span> <span class=\"c1\">--</span>\n\n<span class=\"c1\">---</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NatLit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">val</span>\n<span class=\"n\">macro</span><span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Lean.Parser.numLit</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">NatLit.val</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">NatLit</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">i.toUSize</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">NatLit</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">USize</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i.toUSize</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">---</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">NatLit</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">m.toUSize</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"c1\">---</span>\n\n<span class=\"k\">#check</span> <span class=\"mi\">5</span>                <span class=\"c1\">-- of type NatLit 5</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span>     <span class=\"c1\">-- still works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"c1\">-- does not work</span>\n</code></pre></div>",
        "id": 281460946,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651853542
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Idx</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">USize</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">i.1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i.toUSize</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">USize</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"bp\">$</span><span class=\"n\">s'</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">))</span>\n\n<span class=\"k\">#check</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"c1\">-- this works</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span>  <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>That works</p>",
        "id": 281465240,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651855877
    },
    {
        "content": "<p>It is not general enough, it breaks on:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"mi\">6</span>\n<span class=\"k\">#eval</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span>\n</code></pre></div>",
        "id": 281465453,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651855986
    },
    {
        "content": "<p>I was trying an elaboration like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mySum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">s</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab.Term</span> <span class=\"n\">Meta</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" + \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">a</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">b</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">ta</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"n\">tb</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">b</span>\n  <span class=\"c1\">-- check `ta` and `tb`. if they match the specific types then</span>\n  <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">mySum</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- otherwise, do the regular sum</span>\n  <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">HAdd</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But I couldn't make it work with ease. Someone else might be able to help you on that direction</p>",
        "id": 281465865,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651856184
    },
    {
        "content": "<p>Thanks Arthur! I managed to get it working</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Elab</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Idx</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">USize</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">i.1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i.toUSize</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">USize</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span> <span class=\"c1\">--</span>\n\n<span class=\"c1\">---</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NatLit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">val</span>\n<span class=\"kd\">def</span> <span class=\"n\">natLit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NatLit</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">NatLit.val</span>\n\n<span class=\"c1\">---</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hadd</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">NatLit</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">m.toUSize</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab.Term</span> <span class=\"n\">Meta</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" + \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">Lean.Parser.numLit</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">b.toNat</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">a</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">b</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">ta</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"n\">tb</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">b</span>\n  <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">HAdd.hAdd</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">natLit</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkNatLit</span> <span class=\"n\">n</span><span class=\"o\">])]</span> <span class=\"c1\">--(← mkAppM ``natLit #[b])]</span>\n\n\n<span class=\"k\">#eval</span> <span class=\"mi\">10</span> <span class=\"bp\">+</span> <span class=\"mi\">12</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Idx</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 281468085,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651857260
    },
    {
        "content": "<p>That's even simpler. No need for <code>inferType</code></p>",
        "id": 281468749,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1651857593
    },
    {
        "content": "<p>This is an interesting thread and it exposes limitations in the current elaboration method we use for arithmetic expressions. It is great to see you find a workaround. Note that it is important to set the right precedence otherwise it will affect the standard <code>+</code> notation. The <code>NatLit</code> trick is not needed for this particular example, but I can see it adds extra flexibility.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Elab</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Idx</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">USize</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"n\">i.1</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i.toUSize</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAdd</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">USize</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">i.1</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span> <span class=\"c1\">--</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab.Term</span> <span class=\"n\">Meta</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" + \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">b.toNat</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">a</span> <span class=\"n\">none</span>\n  <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">HAdd.hAdd</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.toUSize</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkNatLit</span> <span class=\"n\">n</span><span class=\"o\">])]</span>\n</code></pre></div>",
        "id": 281479334,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651862881
    },
    {
        "content": "<p>I want now to focus on the standard arithmetic elaboration function and gather ideas on how to improve it. <br>\nNote that we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binop</span><span class=\"bp\">%</span> <span class=\"n\">HAdd.hAdd</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binop</span><span class=\"bp\">%</span> <span class=\"n\">HSub.hSub</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binop</span><span class=\"bp\">%</span> <span class=\"n\">HMul.hMul</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binop</span><span class=\"bp\">%</span> <span class=\"n\">HDiv.hDiv</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>binop%</code> is an auxiliary notation that comes with its own elaboration function which is implemented in the file <code>src/Lean/Elab/Extra.lean</code>. This elaboration function builds a tree, analysis it, and then injects coercions where needed. The <code>analyze</code> function tries to find a \"maximal type\" using an order <code>A &lt; B</code> if there is a coercion from <code>A</code> to <code>B</code>. It also tracks whether there are uncomparable types. Moreover, terms that have unknown types (i.e., the type is a metavariable) are ignored when computing the maximal type. When applying the coercions, the unknown types will become the maximal type due to unification. For example, given <code>(x : _) (y : Int) (z : Nat)</code>, the term <code>z + y + 2 + x</code> is elaborated as  <code>Inf.ofNat z + y + 2 + x</code>, note that the <code>2</code> and <code>x</code> are elaborated as <code>Int</code>. The current approach passes a collection of tests mixing <code>Nat</code>, <code>Int</code>, <code>Rat</code> terms, and addresses counterintuitive behavior found in Lean 3. For example, Lean 3 fails to elaborate <code>z + y + 2 + x</code>.<br>\nThat being said, a side-effect of this approach is that the numeric literals will always have the type of the maximal type which is bad for <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>'s example. A simple solution is to add a mechanism for marking types where numeric literals are skipped during the second step (coercion application). If we do that, then, we can mark the instance <code>HAdd (Idx n) USize (Idx n)</code> with priority higher than the instance <code>HAdd α α α</code>, and it should work.</p>",
        "id": 281481762,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651864190
    },
    {
        "content": "<p>The drawback of the simple solution above is the extra complexity and more confusion.</p>",
        "id": 281482086,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651864380
    },
    {
        "content": "<p>For <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>'s example, it is sufficient to check whether the maximal type implements the homogenous instance <code>Add</code>, but it will not be sufficient for the vector space example <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> mentioned above.</p>",
        "id": 281482908,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651864886
    },
    {
        "content": "<p>This is a bigger can of worms than I thought.</p>\n<p>Using the maximal type might cause an  invisible performance issue. When you have an array <code>x</code> and write <code>x + 1</code>, you do not want to initialize a new array full of ones and add it to <code>x</code>. Even worse if you have component wise multiplication. Writing <code>2*x</code> might silently create an array full of twos and do component wise multiplication.</p>\n<p>The answer to this might be: do not to define the coercion from the array's value type to an array. However, if you want to use the fact that arrays of some comm ring form an algebra you probably get such coercion(not sure if mathlib does that). At least you get <code>0</code> and <code>1</code> defined. So what should <code>x + 2*1</code> do?</p>",
        "id": 281527528,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651911549
    },
    {
        "content": "<p>Well it should do scalar multiplication and then broadcasted addition.</p>",
        "id": 281527621,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651911701
    },
    {
        "content": "<p>From this example I feel that the heuristic should be more like: \"use the minimal type for which you can do the heterogenous operation\". </p>\n<p>Not sure if this would be good or bad  for expressions mixing Nat, Int, Rat, Real ...</p>",
        "id": 281527781,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651911854
    },
    {
        "content": "<p>Just to comment that in mathlib3 we use different symbols for homogeneous multiplication <code>* : A -&gt; A -&gt; A</code> and heterogeneous multiplication <code>• : A -&gt; B -&gt; B</code> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_scalar.smul\">docs#has_scalar.smul</a> , and it's the latter which we use for a field acting on a vector space</p>",
        "id": 281528294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651912618
    },
    {
        "content": "<p>Right, I forgot that mathlib3 uses different notation for these and mathlib4 does not yet have group action defined.</p>\n<p>If I understand it correctly, in Lean 3 it was not possible to use the same symbol. I'm curious what people think about using the same symbol for multiplication and scalar multiplication.</p>",
        "id": 281536671,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651924404
    },
    {
        "content": "<p>I think I came up with a bunch of cases where it would behave really badly with respect to instance diamond, but I dont remember them just yet</p>",
        "id": 281536754,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651924485
    },
    {
        "content": "<p>My opinion is that <code>HMul</code> is more likely to cause headaches due to instance search compared to the cost of having to use different symbols here and getting good type inference</p>",
        "id": 281536843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651924581
    },
    {
        "content": "<p>Here's the case I was thinking of (in lean3 I'm afraid):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hmul</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">hmul</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- hmul transfers elementwise on the right argument</span>\n<span class=\"kd\">instance</span> <span class=\"n\">pi.right</span>\n  <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">HMul</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hmul</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)⟩</span>\n\n<span class=\"c1\">-- hmul transfers elementwise on the left argument</span>\n<span class=\"kd\">instance</span> <span class=\"n\">pi.left</span>\n  <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hmul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">uh_oh</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">HMul</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">pi.left</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">pi.right</span>  <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oh_no</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">HMul</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">pi.left</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">pi.right</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">hmul</span><span class=\"o\">],</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- `hmul (a i) (b j) = hmul (a j) (b i)`, which is not going to be true</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 281537177,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651924960
    },
    {
        "content": "<p>Note that <code>pi.right</code> is basically <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar\">docs#pi.has_scalar</a></p>",
        "id": 281537348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651925211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> </p>\n<blockquote>\n<p>The answer to this might be: do not to define the coercion from the array's value type to an array.</p>\n</blockquote>\n<p>Yes, if you have scalar multiplication for arrays, defining a coercion from values to arrays is going to create problems. For example, your <code>2*x</code> example would be ambiguous. That being said, I am not concerned about this example because as far as I remember, I have never used a system where there is a coercion from values to arrays.<br>\nI am more interested in getting <code>2*x</code> to work without adding a type ascription on the 2 when we have an instance for scalar multiplication.</p>\n<blockquote>\n<p>However, if you want to use the fact that arrays of some comm ring form an algebra you probably get such coercion(not sure if mathlib does that). At least you get 0 and 1 defined. </p>\n</blockquote>\n<p>I think this is a not super common scenario, and we can work around it by having a definition that \"arrays of some comm ring form an algebra\", but not mark it as an instance, or have it as scoped instance. </p>\n<blockquote>\n<p>From this example I feel that the heuristic should be more like: \"use the minimal type for which you can do the heterogenous operation\".</p>\n</blockquote>\n<p>I am happy you are trying to help, but we cannot afford to spend time trying suggestions that do not come with any evidence that they would work. </p>\n<p>Don't take me wrong, we want to improve the current approach and make it better, and we will be grateful for any help we can get.  It is very helpful to collect examples that we think should work but don't. Then, using the collected examples to test a new approach before suggesting them is even more useful.</p>",
        "id": 281542075,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651932077
    },
    {
        "content": "<blockquote>\n<p>If I understand it correctly, in Lean 3 it was not possible to use the same symbol. I'm curious what people think about using the same symbol for multiplication and scalar multiplication.</p>\n</blockquote>\n<p>Independently of what Mathlib decides to do, we are committed to supporting that in Lean. This can be done in many modern programming languages.</p>",
        "id": 281542156,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651932210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals/near/281527528\">said</a>:</p>\n<blockquote>\n<p>However, if you want to use the fact that arrays of some comm ring form an algebra you probably get such coercion(not sure if mathlib does that). At least you get <code>0</code> and <code>1</code> defined. So what should <code>x + 2*1</code> do?</p>\n</blockquote>\n<p>In lean3 + mathlib, if <code>x : fin n -&gt; R</code>, then <code>x + 2*1</code> is defeq to <code>(fun i, x i + 2 * 1)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I don't know what the VM representation of that form of \"array\" is though.</p>",
        "id": 281543551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651934234
    },
    {
        "content": "<p>I recently noticed this unexpected behavior with chains of default instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HOp</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">hOp</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">LOp</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">lOp</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Op</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">@[defaultInstance]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">inst1</span> <span class=\"o\">[</span><span class=\"n\">LOp</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HOp</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">LOp.lOp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">inst2</span> <span class=\"o\">[</span><span class=\"n\">Op</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LOp</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Op.op</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">75</span> <span class=\"s2\">\" ⋆ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HOp.hOp</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Test</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LOp</span> <span class=\"n\">Nat</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">⋆</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- TC works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">⋆</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- TC works</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">defaultInstance</span><span class=\"o\">]</span> <span class=\"n\">inst2</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">⋆</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- TC works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">⋆</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- TC fails</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Test</span>\n</code></pre></div>\n<p>It seems odd that adding a default instance should cause a working TC resolution to fail. If that did not happen, it would help with the issue in this thread.  I don't know if this is intended behavior.</p>",
        "id": 281546948,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1651938976
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> Yes, this is a current limitation of the default instance mechanism. When Lean finds an applicable default instance, it does not backtrack if the generated subproblems cannot be solved. I am currently trying to fix this issue.</p>",
        "id": 281548621,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651940953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals/near/281537177\">said</a>:</p>\n<blockquote>\n<p>Here's the case I was thinking of (in lean3 I'm afraid):<br>\n...</p>\n</blockquote>\n<p>This is exactly the edge case I ran into when playing with broadcasting. When you have an operation between square matrix and a vector, you do not know if you should treat it as a column or row vector.</p>",
        "id": 281549309,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1651942006
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> Lean now backtracks while trying to apply default instances. Your example now works with the following commit<br>\n<a href=\"https://github.com/leanprover/lean4/commit/38baeaf373a19e57130dd7b003a2aaa67b527e6a\">https://github.com/leanprover/lean4/commit/38baeaf373a19e57130dd7b003a2aaa67b527e6a</a></p>",
        "id": 281549838,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651942805
    },
    {
        "content": "<blockquote>\n<p>This is exactly the edge case I ran into when playing with broadcasting. When you have an operation between square matrix and a vector, you do not know if you should treat it as a column or row vector.</p>\n</blockquote>\n<p>In maths you would be able to figure this out by looking at whether you're writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>∗</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">M*v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> (column) or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">v*M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> (row).</p>",
        "id": 281550105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651943114
    },
    {
        "content": "<p>Improved the <code>binop%</code> elaboration function. The following examples should work now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[defaultInstance]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hMul</span> <span class=\"n\">a</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"n\">as.map</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">as.zip</span> <span class=\"n\">bs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#eval</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f9</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">as</span> <span class=\"bp\">*</span> <span class=\"n\">bs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f10</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">as</span> <span class=\"bp\">*</span> <span class=\"n\">bs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f11</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">as</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">bs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f12</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">as.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">bs</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">bs</span>\n</code></pre></div>\n<p>The commit has comments explaining the changes to <code>binop%</code><br>\n<a href=\"https://github.com/leanprover/lean4/commit/af5e13e5345359a93f24c3831feec97d4619dbf0\">https://github.com/leanprover/lean4/commit/af5e13e5345359a93f24c3831feec97d4619dbf0</a></p>",
        "id": 281551649,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651945049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>:</p>\n<blockquote>\n<p>In maths you would be able to figure this out by looking at whether you're writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>∗</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">M*v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> (column) or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">v*M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> (row).</p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> is talking about elementwise products (like <code>*</code> in numpy) not contraction (matrix) products like the mathematicians usually care about.</p>",
        "id": 281558274,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651954109
    },
    {
        "content": "<p>The problem doesn't appear with numpy \"broadcasting\" because 2D arrays are first-class objects rather than arrays of arrays</p>",
        "id": 281558386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651954264
    },
    {
        "content": "<p>(I kind of hate numpy broadcasting for precisely that reason... this summer I plan to experiment with other APIs to find a more predictable syntax for a numpy-esque library, if anyone wants to share suggestions <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>)</p>",
        "id": 281794397,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1652172434
    },
    {
        "content": "<p>(as an active numpy maintainer in a past life, I'd be very interested in seeing what you come up with!)</p>",
        "id": 281795324,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652172920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/270676-lean4/topic/Heterogenous.20operation.20and.20literals/near/281549309\">said</a>:</p>\n<blockquote>\n<p>This is exactly the edge case I ran into when playing with broadcasting. When you have an operation between square matrix and a vector, you do not know if you should treat it as a column or row vector.</p>\n</blockquote>\n<p>The J-style rule for broadcasting is that if you (hadamard) multiply a matrix and a vector, you end up doing the hadamard product of the vector with each row of the matrix. That's because the matrix is rank-2 (say with dimensions [a,b]) and the vector is rank-1 (say with dimensions [b]), so the vector gets lifted to a rank-2 array with dimensions [a,b] -- new dimensions are always added to the left.  If the matrix were square and you wanted the other behavior, you'd have to lift the vector yourself.</p>\n<p>The \"vector of\" functor is a monad, and one way to interpret this is that broadcasting is that you repeatedly apply <code>pure</code> to one of the arguments to add dimensions to the left to make the arguments compatible, if possible. You can insert a dimension anywhere in an array using <code>pure</code>, <code>fmap pure</code>, <code>fmap (fmap pure)</code>, and so on, if you want to get other behavior.</p>",
        "id": 281846836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652198690
    },
    {
        "content": "<blockquote>\n<p>The J-style rule for broadcasting is that if you (hadamard) multiply a matrix and a vector, you end up doing the hadamard product of the vector with each row of the matrix. </p>\n</blockquote>\n<p>Yes, this is the numpy rule too. The problem is that you end up in a mess when you're working with a matrix over some generic type <code>A</code>, and then someone sets <code>A</code> to the type of 1D arrays</p>",
        "id": 281847876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652199091
    },
    {
        "content": "<p>If you create a specific \"nd container\" object (like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/holor\">docs#holor</a>?) to represent your matrices / vectors etc then that problem goes away</p>",
        "id": 281848000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652199136
    },
    {
        "content": "<p>Interestingly, while still a problem, it's less of a problem for Lean than Python: if you resolve all the broadcasting inside a function's definition, it won't suddenly change behavior just because you pass in an array -- typeclasses don't respect referential transparency. In Python (and in J), broadcasting is resolved at runtime.</p>\n<p>As far as I know, there are two basic solutions to this. The first is what you mention, a special multidimensional array type that guarantees that the dimensions are completely legible. The second is what J does, which is having a way to \"box\" a value so it won't participate in broadcasting anymore. The multidimensional array type records the span of all the indices itself, where the box records the divider between spans of indices.</p>",
        "id": 281851464,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652200589
    },
    {
        "content": "<p>To answer whether to add dimensions to the left or right you decide between these two opposing requirements:</p>\n<ol>\n<li>If you have a scalar <code>r</code> and a function <code>f</code> both depending on a parameter <code>i : R</code> You want <code>(r * f) i = r i * f i</code> to hold even when <code>f</code>'s type is <code>R -&gt; R -&gt; S</code>.</li>\n<li>If you have a function <code>f</code> depending on a parameter <code>i : R</code>  and function <code>g</code> not depending on it. You want <code>(f * g) i = f i * g</code></li>\n</ol>\n<p>I think 1. is adding dimension to the right and 2. is adding dimension to the left. Maybe it is the other way around, I always get confused.</p>\n<p>Also I ended up with the \"boxing\" approach. You can define type synonym and provide different TC instances to modify default behavior.</p>",
        "id": 281917347,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1652243375
    },
    {
        "content": "<p>However, I had some type class issues so I abandoned my \"clever\" array indexing and thus didn't discover all the gotchas in my approach. I should revise it and start using it again and see if it holds up.</p>",
        "id": 281918081,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1652244307
    }
]
[
    {
        "content": "<p>The Goldbach conjecture is that every even number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">n\\geq4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> is the sum of two primes. It's still an open question. Computationally-inclined number theorists sometimes write computer programs to check it for all even <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">n\\leq X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> grows slowly over time as computers get better. How big can we make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> in Lean?</p>\n<p><a href=\"https://www.ams.org/journals/mcom/1993-61-204/S0025-5718-1993-1185250-6/S0025-5718-1993-1185250-6.pdf\">Here</a> is an example of a paper from 1993 by Sinisalo about numerically verifying the Goldbach conjecture up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>11</mn></msup></mrow><annotation encoding=\"application/x-tex\">4\\times10^{11}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">11</span></span></span></span></span></span></span></span></span></span></span></span> (using non-formal techniques, as do all the papers I cite below). It's published in Math Comp, which was at that time the top journal for computational mathematics, so one can imagine that it was state of the art at the time. It doesn't do anything fancy involving zero estimates for the Riemann zeta functions (some other papers in this area do); it just does a brute force variant of Eratosthenes' sieve. The details of the algorithm are in <a href=\"https://www.researchgate.net/publication/241887101_Checking_the_Goldbach_conjecture_on_a_vector_computer\">this earlier paper</a> of Granville et al, where if you can HANDLE THE FORTRAN CODE they explain the very simple method (my understanding, at least, is that this is the algorithm Sinisalo used as well). It seems that in 1988 (Granville et al) they could get up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding=\"application/x-tex\">X=2\\times10^{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span></span></span></span>, in 1993 (Sinisalo) they had got as far as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>11</mn></msup></mrow><annotation encoding=\"application/x-tex\">4\\times 10^{11}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">11</span></span></span></span></span></span></span></span></span></span></span></span>, and the most recent paper I can find is by Oliviera e Silva, Herzog and Pardi <a href=\"https://www.semanticscholar.org/paper/Empirical-verification-of-the-even-Goldbach-and-of-Silva-Herzog/0bcebfe7cd9889039a36c73cf0a21609cb8867e2\">here</a> which push the calculations up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">4\\times10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span> and again they are using very simple algorithms (they also give a history of the computational aspect of the problem at the beginning, and they explain their simple algorithms in the paper, but it's just Eratosthenes + some extra thought to make it computationally more efficient).</p>\n<p>Obviously computers are many times faster now than they were in 1993 (at the time of Sinisalo's paper), however formal proofs as opposed to Fortran proofs slow things down again. I was wondering how far one could get in Lean 4, using GMP if necessary (I would also be interested in whether GMP speeds things up or whether for numbers of this size it's of no use). It would be a pretty simple job to knock off a very naive algorithm to start verifying Goldbach, and if anyone gets the bug and wants to start setting formalisation records then these more advanced algorithms which seem to be giving state of the art results are really still extremely elementary in nature as you can see from their description in the linked papers. I have no idea what the record is for formalised computational Goldbach.</p>\n<p>Why am I interested? Well,  the ternary Goldbach conjecture is the weaker statement that every odd natural &gt;= 7 is the sum of three primes, and a proof was announced a few years ago by Helfgott. Helfgott's proof is in two completely different parts; he uses abstract techniques from analytic number theory to prove the results for odd numbers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>31</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\geq 8\\times 10^{31}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">31</span></span></span></span></span></span></span></span></span></span></span></span> and then (with Platt -- see <a href=\"https://arxiv.org/abs/1305.3062\">here</a> does a brute force computer search to check the cases less than this bound. The proof of the abstract analytic number theory part of the argument is 300 pages long so is unlikely to be formalised any time soon, however the basic techniques used in it by Helfgott (the circle method etc) are used a lot in this area, and are being formalised by mathematicians in <a href=\"https://b-mehta.github.io/unit-fractions/\">this Lean project here</a>, so it led me to idly speculate about how feasible it would be to formalise the various parts of the proof of the ternary conjecture and in particular the computational part. For the computational part Helfgott uses the Oliviera e Silva, Herzog and Pardi result, which reduces the claim that ternary Goldbach is true up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>31</mn></msup></mrow><annotation encoding=\"application/x-tex\">8\\times 10^{31}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">31</span></span></span></span></span></span></span></span></span></span></span></span> to the claim that there are no two consecutive primes in this range which are distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\geq 4\\times 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span> apart, and this is what he proves using a (unformalised) computer proof. I would imagine that formalised methods right now can't get close to Helfgott's unformalised bound but it seems to me that if the state of the art is being achieved with these essentially elementary arguments then it might make a good computational project for someone interested in seeing how far Lean 4 can get; certainly no maths library will be needed, for example.</p>",
        "id": 270963940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644233022
    },
    {
        "content": "<p>This is very interesting. I guess a formal proof can simply be an enumeration, with even numbers listed as sums of pairs of primes and a proof of the equality.</p>",
        "id": 270966280,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1644234508
    },
    {
        "content": "<p>Exactly. But I have no feeling at all as to the complexity of doing this to a non-trivial bound in a formal setting. I know that they computed the <a href=\"https://arxiv.org/abs/1709.01743\">first million digits of pi in Coq</a> although <a href=\"https://en.wikipedia.org/wiki/Chronology_of_computation_of_%CF%80#2009%E2%80%93present\">the non-formal people are up to about 10^13 digits by now</a>.</p>",
        "id": 270966458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644234640
    },
    {
        "content": "<p>A very nice feature of lean 4 compiled code is that proofs are eliminated at runtime after checking correctness while compiling. So there is hope the overhead is small.</p>",
        "id": 270967582,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1644235256
    },
    {
        "content": "<p>If Lean 4 uses GMP, then the implementation of GMP (in C, I guess) is part of the TCB, right?</p>",
        "id": 270970652,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237056
    },
    {
        "content": "<p>Or is there a verified reimplementation?</p>",
        "id": 270970678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237073
    },
    {
        "content": "<p>there are plans for a verified (or at least homegrown and not GPL) reimplementation, but indeed that's the current state of things</p>",
        "id": 270970758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237126
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">4 \\cdot 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span> is around <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mi mathvariant=\"normal\">/</mi><mn>4.5</mn></mrow><annotation encoding=\"application/x-tex\">2^{64}/4.5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">64</span></span></span></span></span></span></span></span></span><span class=\"mord\">/4.5</span></span></span></span>; so I don't think GMP will be relevant to that part (and maybe this is why they stopped at that particular value).</p>",
        "id": 270971060,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644237324
    },
    {
        "content": "<p>Aha, because if you off-load the bignum computations and the primality checks to a non-verified GMP, then there is little value in doing the project in Lean, methinks.</p>",
        "id": 270971105,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237349
    },
    {
        "content": "<p>the part of GMP in the lean TCB only includes <code>+ - * / %</code> on nat and int, not primality</p>",
        "id": 270971225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237408
    },
    {
        "content": "<p>of course you can use FFI + implementedBy + reduceBool to add arbitrary C code to the TCB if you want</p>",
        "id": 270971337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237477
    },
    {
        "content": "<p>so for instance you could link to those GMP primality routines and add them to lean</p>",
        "id": 270971436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237512
    },
    {
        "content": "<p>Might also be interesting to do this verified Goldbach in MM0</p>",
        "id": 270971468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237532
    },
    {
        "content": "<p>lol, it's always on my mind... I'm thinking to wait until I have verified computational reflection before tackling these kinds of problems though</p>",
        "id": 270971543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237589
    },
    {
        "content": "<p>Maybe it might be better to start a little simpler, for example calculating the number of primes &lt;= 100000 in lean 4 compared to (pick your favorite other language)</p>",
        "id": 270971926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237769
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png\">image.png</a> Here's a proof that the number of primes less than 100000 is 9592 in Lean 3</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png\"></a></div>",
        "id": 298437314,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663006727
    },
    {
        "content": "<p>And kernel typechecking time?</p>",
        "id": 298440104,
        "sender_full_name": "Reid Barton",
        "timestamp": 1663007719
    },
    {
        "content": "<p>How can I measure this?</p>",
        "id": 298440371,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663007815
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png\">image.png</a> Here's all the other things the profiler tells me (on this run it says execution was around 4.5s)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png\"></a></div>",
        "id": 298440605,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663007899
    },
    {
        "content": "<p>But you didn't do this by explicitly computing all the primes less than 10^5, right?</p>",
        "id": 298492923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663024404
    },
    {
        "content": "<p>BTW if anyone has questions for Helfgott I'm at a conference with him this week</p>",
        "id": 298493015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663024471
    },
    {
        "content": "<p>I didn't, but I did also separately compute all the primes less than 2 * 10^5</p>",
        "id": 298494399,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663025596
    },
    {
        "content": "<p>I've also managed to check Goldbach (again in Lean 3) up to 2*10^5. In particular the statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">goldbach_kevin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"mi\">200000</span><span class=\"o\">,</span> <span class=\"mi\">4</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p.prime</span> <span class=\"bp\">∧</span> <span class=\"n\">q.prime</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>is sorry-free</p>",
        "id": 298494440,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663025638
    },
    {
        "content": "<p>This looks like fun learning experience.  I tried super simple Eratosthenes Sieve in Lean 4 but it runs out of stack space pretty quick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">EratosthenesSieveSimple</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">EratosthenesSieveSimple</span> <span class=\"o\">(</span><span class=\"n\">xs.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">%</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>So I used a StateM monad to allow some tail recursion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">EratosthenesSieve</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StateM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n    <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"n\">EratosthenesSieve</span> <span class=\"o\">(</span><span class=\"n\">xs'.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">%</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The compiled version of this can find the first 1 million primes in about 93 seconds on my AMD Ryzen 9 CPU. It found 78498 primes. I can then save this to a new lean source file containing <code>def primes := [2, 3, 5, 7, ...]</code> but when I try and compile this simple array the Lean compiler times out, which is odd:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">.\\.\\.\\</span><span class=\"n\">Primes1Million.lean</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">14</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">deterministic</span><span class=\"o\">)</span> <span class=\"n\">timeout</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"n\">isDefEq'</span><span class=\"o\">,</span> <span class=\"n\">maximum</span> <span class=\"n\">number</span> <span class=\"n\">of</span> <span class=\"n\">heartbeats</span> <span class=\"o\">(</span><span class=\"mi\">200000</span><span class=\"o\">)</span> <span class=\"n\">has</span> <span class=\"n\">b</span>                                             <span class=\"n\">een</span> <span class=\"n\">reached</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"bp\">'</span><span class=\"kd\">set_option</span> <span class=\"n\">maxHeartbeats</span> <span class=\"bp\">&lt;</span><span class=\"n\">num</span><span class=\"bp\">&gt;'</span> <span class=\"n\">to</span> <span class=\"n\">set</span> <span class=\"n\">the</span> <span class=\"n\">limit</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I was thinking of saving this file as a cheat so we could use it to implement a more efficient <code>Nat.prime</code> function, e.g. use it to build a HashMap of all the numbers with a true false saying whether they are primes or not so <code>p.prime</code> becomes an O(1) lookup....</p>",
        "id": 299241049,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663362148
    },
    {
        "content": "<p>how long is your list <code>def primes := [2, 3, 5, 7, ...]</code>?</p>",
        "id": 299243023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663363230
    },
    {
        "content": "<p>Here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"make_list\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkArray</span> <span class=\"mi\">5000</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">))),</span><span class=\"bp\">*</span><span class=\"o\">])</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">make_list</span>\n</code></pre></div>\n<p>While I expect there to be problems eventually, 5000 seems unusually low for them to show up here. I think there are some issues in the scheme used for compiling list literals using nested <code>let</code> bindings.</p>",
        "id": 299243906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663363743
    },
    {
        "content": "<p>It seems like there is some quadratic behavior here with it spending a huge amount of time in <code>elimMVarDeps</code> traversing the term to ensure no metavariables contain references to the newly introduced let bindings produced by the <code>[xs,* | tail]</code> notation</p>",
        "id": 299246244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663364973
    },
    {
        "content": "<p>This is really unnecessary, this notation should just be an <code>elab</code> and produce a term directly instead of macro expanding to a pile of lets that have to be elaborated</p>",
        "id": 299246353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663365019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> FYI, that's not the true sieve of Eratosthenes (though it's the one you see as a functional programming example, and <a href=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\">there's a paper about this</a>).</p>\n<p>Here's a simple implementation of the true one -- note that it doesn't have any modulo operators nor any checking that a given number is not divisible by <em>all</em> of the primes found so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">primes</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">buf</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">mkArray</span> <span class=\"n\">n</span> <span class=\"n\">True</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">buf</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"k\">then</span>\n      <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">res.push</span> <span class=\"n\">i</span>\n      <span class=\"n\">for</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n        <span class=\"n\">buf</span> <span class=\"o\">:=</span> <span class=\"n\">buf.set</span><span class=\"bp\">!</span> <span class=\"n\">j</span> <span class=\"n\">False</span>\n  <span class=\"n\">return</span> <span class=\"n\">res</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">primes</span> <span class=\"mi\">1000000</span>\n  <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"k\">do</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p}\"</span>\n</code></pre></div>\n<p>Compiled, I get</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>$ time ./build/bin/primes\n...  78498 lines omitted ...\n./build/bin/primes  0.11s user 0.17s system 86% cpu 0.323 total\n</code></pre></div>\n<p>93 seconds seemed excessive for the primes less than a million!</p>",
        "id": 299250681,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663367446
    },
    {
        "content": "<p>Ok, building on your nice fast primes function we can find the sum of 2 primes for every even <code>i &gt;= 4</code> with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">NatMap</span> <span class=\"o\">:=</span> <span class=\"n\">HashMap</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">goldback</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">primes</span> <span class=\"o\">:=</span> <span class=\"n\">primes</span> <span class=\"n\">n</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">HashMap.empty</span>\n  <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">primes</span> <span class=\"k\">do</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">map.insert</span> <span class=\"n\">p</span> <span class=\"n\">p</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">found</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n    <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">primes</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"bp\">&gt;</span> <span class=\"n\">i</span> <span class=\"k\">then</span>\n        <span class=\"n\">break</span>\n      <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">p</span>\n        <span class=\"k\">if</span> <span class=\"n\">map.contains</span> <span class=\"n\">q</span> <span class=\"k\">then</span>\n          <span class=\"n\">found</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n          <span class=\"n\">break</span>\n    <span class=\"k\">if</span> <span class=\"n\">not</span> <span class=\"n\">found</span> <span class=\"k\">then</span>\n      <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{i} disproves goldback conjecture\"</span>\n      <span class=\"n\">break</span>\n</code></pre></div>\n<p>and the compiled version can prove a pair <code>p + q</code> exists for all 5,761,455 primes found under 100 million in 9 seconds which is not bad.</p>",
        "id": 299263849,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663379441
    },
    {
        "content": "<p>The performance seems quite linear (it increases by a factor of 10 each time I increase <code>n</code> by a factor of 10) but of course this solution will not scale too far before running out of memory, we'd need a more compact collection for checking whether <code>q</code> is a prime number... or a SQLite database partitioned across a bunch of terabyte drives or something... but then of course all that will slow things down....</p>",
        "id": 299264131,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663379730
    },
    {
        "content": "<p>I could fit 1 billion in memory which it did in 101 seconds... but I only have a piddly little 32GB RAM so 10 billion is where I run out.  I need one of those machine learning boxes with a terabyte of RAM :-)</p>",
        "id": 299265513,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663381304
    },
    {
        "content": "<p>For the sieve, you could start by using a bit-vector instead of a hashmap, which will reduce your space overhead significantly.<br>\nThen, you can also halve the memory used by only storing the odd numbers, since any prime must be odd. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 299492042,
        "sender_full_name": "Tom",
        "timestamp": 1663554064
    },
    {
        "content": "<p>There are also some sparse bitvector data structures which would allow you to take advantage of the fact that your bitvector will be mostly empty because of <a href=\"https://en.wikipedia.org/wiki/Prime_number_theorem\">https://en.wikipedia.org/wiki/Prime_number_theorem</a>.</p>",
        "id": 299492425,
        "sender_full_name": "Tom",
        "timestamp": 1663554489
    },
    {
        "content": "<p>I think these approaches do a different thing to what I did - evaluating whether such a counterexample exists doesn't give you a Lean 4 <em>proof</em> that none exist. Certainly for Lean 3 it's a lot faster to evaluate/run instead of proving, and I expect similar for Lean 4</p>",
        "id": 303348534,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665452937
    },
    {
        "content": "<p>What's GMP and TCB?</p>",
        "id": 305066519,
        "sender_full_name": "joaogui1 (he/him)",
        "timestamp": 1666229367
    },
    {
        "content": "<p>GMP is the <a href=\"https://en.wikipedia.org/wiki/GNU_Multiple_Precision_Arithmetic_Library\">GNU MultiPrecision Library</a> it's a C library for doing integer arithmetic on numbers that are too big to fit into typical computer registers. TCB stands for \"trusted computing base\" - it means the set of all software we use when doing formally verification that we assume is bug-free.</p>",
        "id": 305067134,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1666229991
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 305109481,
        "sender_full_name": "joaogui1 (he/him)",
        "timestamp": 1666257595
    }
]
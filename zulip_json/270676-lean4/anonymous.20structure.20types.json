[
    {
        "content": "<p>Is it possible do define anonymous structure type syntax with the current system?<br>\nFor example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Any</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Struct</span> <span class=\"bp\">|</span> <span class=\"n\">MyCons</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n<span class=\"c1\">-- And</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"n\">MyCons</span> <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Which is closer to Haskell syntax.</p>",
        "id": 278143133,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1649327137
    },
    {
        "content": "<p>You can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Any</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Struct</span> <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 278156921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649334952
    },
    {
        "content": "<p>I don't see why we should support multiple syntaxes for the same thing, beyond what lean already supports vis-a-vis moving arguments across the colon and <code>structure</code> / <code>inductive</code></p>",
        "id": 278157026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649334992
    },
    {
        "content": "<p>Here are other alternatives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Any</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"n\">val</span>  <span class=\"o\">:</span> <span class=\"n\">type</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Struct</span> <span class=\"n\">where</span>\n   <span class=\"n\">myCons</span> <span class=\"o\">::</span> <span class=\"c1\">-- You can give your own name to the structure constructor</span>\n     <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n     <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"c1\">-- We don't need to provide `type`</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">myCons</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"c1\">-- The namespace at `.myCons` is inferred by Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f₃</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Struct.myCons</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Struct'</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">myCons</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- You cannot use the structure instance notation with inductive datatypes</span>\n<span class=\"c1\">-- even if they have only one constructor</span>\n<span class=\"c1\">-- def f₄ : Struct' -&gt; Any</span>\n<span class=\"c1\">--  | { a, b } =&gt; { val := a }</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f₅</span> <span class=\"o\">:</span> <span class=\"n\">Struct'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">myCons</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f₆</span> <span class=\"o\">:</span> <span class=\"n\">Struct'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Struct'.myCons</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 278166033,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649339216
    },
    {
        "content": "<p>Why doesn't this work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Struct</span> <span class=\"n\">where</span>\n   <span class=\"n\">myCons</span> <span class=\"o\">::</span>\n     <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n     <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n  <span class=\"n\">myOtherCons</span> <span class=\"o\">::</span>\n     <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n     <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n</code></pre></div>\n<p>Would be really nice to do this. Rust and Haskell supports it.</p>",
        "id": 278269067,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1649405032
    },
    {
        "content": "<p>The point of a structure is that is has exactly one constructor, and this is true in Rust and Haskell as well. Basically all the special syntax for structures is dependent on this property. I assume you you are referring to <em>struct-like enums</em> in Rust; I'm not sure what you're referring to in Haskell. It's always a good idea to make these things explicit in a proposal, and in particular to mention actual advantages and use cases.</p>",
        "id": 278269778,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649405455
    },
    {
        "content": "<p>Yes. I'm thinking of the struct like enums in rust (I guess haskell only has them for single constructors). So my suggestion would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">EnumStruct</span> <span class=\"bp\">|</span> <span class=\"n\">myCons</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"bp\">|</span> <span class=\"n\">myOtherCons</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"kn\">open</span>\n<span class=\"kd\">def</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">EnumStruct</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span>\n <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">myCons</span> <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">myOtherCons</span> <span class=\"o\">{</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>But another use of anonymous structure types could be to pattern match select a class of structures that has some particular fields</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">SA</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">SB</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span>\n\n<span class=\"c1\">-- Which would implicitly define a class something like this</span>\n<span class=\"c1\">-- Which is a Lens I guess</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasField</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">getField</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span>\n  <span class=\"n\">putField</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasField</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"n\">SA</span> <span class=\"o\">:=</span> <span class=\"c1\">-- SA.a ...</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasField</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"n\">SB</span> <span class=\"o\">:=</span> <span class=\"c1\">-- SB.a ...</span>\n\n<span class=\"c1\">-- which can then be used as a normal structure type</span>\n<span class=\"kd\">def</span> <span class=\"n\">act</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">s.a</span>\n</code></pre></div>\n<p>This could be a part of adding  Lenses and optics if that is something you are looking into.</p>",
        "id": 278272709,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1649407097
    },
    {
        "content": "<p>I'm not sure if <code>HasField</code> makes sense in Lean. We don't have global field names like in Haskell.</p>",
        "id": 278272937,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649407233
    },
    {
        "content": "<p>And Lean is a completely nominal language like Rust and Haskell, I really don't think there will be any structural typing</p>",
        "id": 278273134,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649407330
    },
    {
        "content": "<p>What do you think about adding lenses?</p>",
        "id": 278273195,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1649407368
    },
    {
        "content": "<p>I think adding lenses / optics would be even more powerful. If one could have some short hand syntax for indicating that a particular lens instance would be present  <code>s : { a : A } </code> would mean <code>{S : Type u} [Lens S A] (s : S)</code></p>",
        "id": 278273681,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1649407642
    },
    {
        "content": "<p>I don't think it's likely that this will end up in Lean itself, but of course extensibility is the whole point of Lean 4! We currently lack some kind of \"binder macros\" for doing something like that, but it's a topic that has come up before.</p>",
        "id": 278274209,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649407937
    },
    {
        "content": "<p>I've done some preliminary work to add lenses in lean. Although I'm not sure type classes is the correct tool. Lenses have to be first class</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lens</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">Para</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Lens'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">Lens</span> <span class=\"n\">s</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>I've based this on Agda which has a lot of good lens libraries.<br>\nThis is particularly useful when doing more practical software engineering. Probably not so useful for pure math except perhaps category theory (but they would probably define their own syntax anyway)?</p>",
        "id": 278274539,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1649408129
    }
]
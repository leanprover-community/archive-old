[
    {
        "content": "<p>I'm trying to whnf an expression in an elaborator and then return the normalized expression.  However the whnf exposes the <code>.rec</code> recursor, which is a problem because the result can then no longer be compiled.  Simplified MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"whnf%\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">whnf</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">expectedType</span><span class=\"o\">)</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"mi\">42</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">whnf</span><span class=\"bp\">%</span> <span class=\"n\">x.getD</span> <span class=\"mi\">0</span>\n<span class=\"c1\">-- code generator does not support recursor 'Option.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n</code></pre></div>\n<p>Is there an obvious flag that I need to set here?  (Potentially related to <a href=\"https://github.com/leanprover/lean4/issues/445\">https://github.com/leanprover/lean4/issues/445</a>)</p>",
        "id": 249734584,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1629213801
    },
    {
        "content": "<p>I fear the immediate answer is that you're the first one trying this and there is no such flag currently</p>",
        "id": 249740904,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1629216478
    },
    {
        "content": "<p>We have variants of <code>whnf</code>. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[specialize]</span> <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">whnfHeadPred</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>Here is another one (at <code>DiscrTree.lean</code>) that may be useful as a reference if you want to implement your own variants.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">whnfUntilBadKey</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n</code></pre></div>\n<p>That being said, your <code>whnf%</code> is not going to do what you want when <code>elabTerm</code> returns a term containing metavariables (corresponding to elaboration tasks that have been postponed).</p>",
        "id": 249743042,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1629217417
    },
    {
        "content": "<blockquote>\n<p>We have variants of whnf.</p>\n</blockquote>\n<p>That works, thank you.  IIRC you added smart unfolding a couple years back so that the internals of the equation compiler don't leak, so I was really surprised to get a recursor out of whnf.  In Lean 3, whnf didn't reduce this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">do</span>\n  <span class=\"n\">to_expr</span> <span class=\"bp\">```</span><span class=\"o\">(</span><span class=\"n\">x.get_or_else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">whnf</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span>\n<span class=\"c1\">-- x.get_or_else 0</span>\n</code></pre></div>",
        "id": 249754995,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1629223151
    },
    {
        "content": "<p>I will change the behavior of <code>unfoldDefinition?</code> for the auxiliary <code>match_&lt;idx&gt;</code> definitions created by the elaborator when \"smart unfolding\" is enabled. They will not be unfolded if the result cannot be reduced.<br>\nThen, <code>whnf</code> will produce the following expression in your example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>It is different than the one produce by Lean 3 because </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Option.getD</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span>   <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>is macro expanded into </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Option.getD</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span>   <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>If we define <code>get_or_else</code> using a <code>match .. with</code> in Lean 3, we would get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">option.get_or_else._match_1</span> <span class=\"mi\">0</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 249767671,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1629228813
    }
]
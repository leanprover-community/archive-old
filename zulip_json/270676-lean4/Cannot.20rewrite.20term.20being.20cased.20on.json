[
    {
        "content": "<p>I've been trying for a while to step through a match expression in a proof, but the rewrite that should be succeeding is not.</p>\n<p>Here, I'm trying to rewrite the <code>LazyList.force F</code> to <code>none</code> with <code>h'</code>, so that I can step through the match. <code>rw [h']</code> fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">rewrite'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">type</span> <span class=\"n\">correct</span>\n<span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.3819</span>\n<span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span>\n<span class=\"n\">F_len</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span>\n<span class=\"n\">R_len</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">...</span>\n<span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n<span class=\"bp\">...</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">LBQueue.balance</span> <span class=\"n\">F'</span> <span class=\"o\">(</span><span class=\"n\">F_len</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">R_len</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.length</span> <span class=\"n\">F'</span> <span class=\"bp\">=</span> <span class=\"n\">F_len</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">LazyList.length</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"n\">R_len</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">none</span>\n</code></pre></div>\n<p>Full code is <a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Queue/LazyBankerQueue.lean\">here</a><br>\n(sorry for the not-MWE, I can't figure out how to get this issue to appear elsewhere <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span>)</p>",
        "id": 273286474,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1645824231
    },
    {
        "content": "<p>I can spend some more time trying to find an MWE if the issue is too unintelligible like this</p>",
        "id": 273286670,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1645824353
    },
    {
        "content": "<p>Try <code>cases h'</code>? In lean 3 this would probably make progress, as would <code>subst h'</code>.</p>",
        "id": 273300455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645832551
    },
    {
        "content": "<p>I believe <code>split</code> should work in this case. (Lean 4 <code>split</code> is like <code>split_ifs</code> from lean 3 but it also works on matches)</p>",
        "id": 273332258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645871327
    },
    {
        "content": "<p>Ah, <code>cases h'</code> seems to reveal the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">dependent</span> <span class=\"n\">elimination</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">solve</span> <span class=\"n\">equation</span>\n  <span class=\"n\">none</span> <span class=\"bp\">=</span>\n    <span class=\"n\">Acc.rec</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x₁</span> <span class=\"n\">ac₁</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"n\">PSigma.casesOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>Seems like maybe same issue as <a href=\"#narrow/stream/270676-lean4/topic/Nightly.20broke.20well-founded.20proof\">this topic</a></p>",
        "id": 273368323,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1645916601
    },
    {
        "content": "<p>Huh, so even after the other topic was resolved, this is still having trouble. Weirdly if I just case on <code>F.force</code> again (and eliminate one case via contradiction) it works... I just can't directly rewrite into the match, nor split on it</p>",
        "id": 274085934,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646374715
    },
    {
        "content": "<p>(Doing <code>cases h'</code> still gives the same dependent elimination failure)</p>",
        "id": 274085948,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646374741
    },
    {
        "content": "<p>can you make a MWE?</p>",
        "id": 274086422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646375121
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">LazyList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Thunk</span> <span class=\"o\">(</span><span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LazyList</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">force</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">force</span> <span class=\"n\">as.get</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>        <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">as</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LazyList</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">deq</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">Q.force</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">deq_correct</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">deq</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">Q.force</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h'</span><span class=\"o\">:</span><span class=\"n\">Q.force</span>\n    <span class=\"n\">case</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">deq</span><span class=\"o\">]</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 274087009,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646375630
    },
    {
        "content": "<p>I think (?) this shows the right behavior</p>",
        "id": 274087056,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646375646
    },
    {
        "content": "<p>And this works perfectly fine in replacement of the <code>cases h'</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">h''</span><span class=\"o\">:</span><span class=\"n\">Q.force</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n<span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h''</span>\n  <span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 274087170,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646375797
    },
    {
        "content": "<p>wait, no, doing that causes a really strange error at the top level declaration deq_correct ???</p>",
        "id": 274087221,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646375880
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">deq.match_1</span> <span class=\"n\">Q</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">function</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n      <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n        <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n          <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">none</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 274087271,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646375898
    },
    {
        "content": "<p>Ideally we would want to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">deq_correct</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">deq</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">Q.force</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">deq</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Q.force</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">deq_correct</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">deq</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">Q.force</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">deq</span><span class=\"o\">]</span>\n  <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Both <code>cases Q.force</code> and <code>split</code> fail when trying to generalize <code>Q.force</code>. Auxiliary declarations (<code>deq.match_1</code> and <code>deq.proof_1</code>) created by Lean are preventing <code>generalize</code> from creating a type correct term. <code>deq.match_1</code> is an auxiliary declaration used to represent the <code>match</code> expression in <code>deq</code>, and <code>deq.proof_1</code> is used by Lean when \"hiding\" all proof terms nested in a definition. We can work around these issues by unfolding these definitions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">deq_correct</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">deq</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">Q.force</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">deq</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">deq.match_1</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">deq.proof_1</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Q.force</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>We will try to improve <code>generalize</code> and how we encode <code>match</code> expressions to avoid these workarounds in the future.</p>",
        "id": 274154336,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1646411753
    },
    {
        "content": "<p>Trying to apply this workaround in more complicated situations I'm a bit lost again... Here's an MWE that's closer to my actual application:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">LazyList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Thunk</span> <span class=\"o\">(</span><span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LazyList</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">force</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">force</span> <span class=\"n\">as.get</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>        <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">as</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>        <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">_</span> <span class=\"n\">as</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">length</span> <span class=\"n\">as</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">length</span> <span class=\"n\">as.get</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">F_force_some_len_minus_one</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"n\">L'</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"n\">L.force</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">L'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">L'.length</span> <span class=\"bp\">=</span> <span class=\"n\">L.length</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LazyList</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">LazyBatchQueue</span> <span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span>\n  <span class=\"n\">F_len</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">h_lens</span> <span class=\"o\">:</span> <span class=\"n\">F.length</span> <span class=\"bp\">=</span> <span class=\"n\">F_len</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">deq</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyBatchQueue</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyBatchQueue</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">Q.F.force</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"o\">⟨</span><span class=\"n\">F'</span><span class=\"o\">,</span> <span class=\"n\">Q.F_len</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n        <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LazyList.F_force_some_len_minus_one</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Q.h_lens</span><span class=\"o\">]⟩)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">deq_correct</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyBatchQueue</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">deq</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">Q.F.force</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">deq</span><span class=\"o\">]</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">deq.match_1</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">deq.proof_1</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">deq.proof_2</span>\n    <span class=\"k\">match</span> <span class=\"n\">h'</span><span class=\"o\">:</span><span class=\"n\">Q.F.force</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>The biggest difference from the last is that now we are carrying around a proof term with the queue structure (so perhaps that's causing other proof-erasing definitions to be generated?).</p>\n<p>The same proof as before (which I think should in principle still work) fails with a reference to <code>deq.proof_2</code>, so I tried unfolding that also, but now it generates a type incorrect term because it is generalizing <code>Q.F.force</code> within the proof term from the implementation of <code>deq</code>...</p>\n<p>Is there a consistent way to apply this workaround? I can also just leave <code>sorry</code>s until the behavior improves, since it isn't urgent.</p>",
        "id": 274323635,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646594858
    },
    {
        "content": "<p>My old standby for solving this situation in lean 3 still works in lean 4: Write the generalization motive explicitly. It's not pretty but it works when you have messy dependencies</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">deq_correct</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyBatchQueue</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">deq</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">Q.F.force</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">deq</span><span class=\"o\">]</span>\n    <span class=\"k\">suffices</span> <span class=\"bp\">∀</span> <span class=\"n\">o</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">deq.match_1</span> <span class=\"n\">Q</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">o</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">intros</span> <span class=\"n\">o</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases</span> <span class=\"n\">o</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274325641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646597385
    },
    {
        "content": "<p>Oh boy, okay -- let me try to parse what that's doing</p>",
        "id": 274325952,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646597810
    },
    {
        "content": "<p>the basic idea is that we are simultaneously generalizing <code>Q.F.force</code>and <code>rfl : Q.F.force = Q.F.force</code> because the <code>rfl</code> proof is what prevents us from generalizing <code>Q.F.force</code>. These two are passed as arguments to <code>deq.match_1</code>, which already states the generalized type of <code>h : Q.F.force = o</code>, so if we introduce them at the same time then we don't get any \"motive is not type correct\" issues</p>",
        "id": 274326114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646598058
    },
    {
        "content": "<p>(It helps to set <code>set_option pp.match false</code> to see what the actual match application looks like)</p>",
        "id": 274326130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646598091
    },
    {
        "content": "<p>Sorry for dragging up an old thread — I’m back to trying to figure this out.</p>",
        "id": 277546023,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1648926369
    },
    {
        "content": "<p>Where are the <code>proof_i</code> terms used in the match encoding? Even with <code>pp.match</code> off and <code>pp.all</code> on they don’t appear anywhere — is it only occurring in the proof of the relevant proposition?</p>",
        "id": 277546156,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1648926528
    },
    {
        "content": "<p>(Trying to understand why those need to be unfolded/what it’s doing when I unfold those)</p>",
        "id": 277546184,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1648926559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> We discussed this issue in the dev channel. To provide a better experience for users, we have to change how we encode <code>match</code> expressions. This is on our TODO list, but it will not happen in the next two months. We have a tutorial at the end of May, and fixing things and adding missing features for it is our current priority. Here are the notes from the dev channel if you are interested.</p>\n<hr>\n<p>A user wrote the following function.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">deq</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">Q.force</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span>         <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>The following auxiliary definition is created</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">deq.match_1</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- Parameters</span>\n  <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"c1\">-- Motive</span>\n  <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_2</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"c1\">-- Discriminants aka major premises</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"c1\">-- Alternatives aka minor premises</span>\n  <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">none</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"c1\">-- Result type</span>\n  <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>If the goal contains the term <code>deq.match_1 Q &lt;some-motive&gt; (LazyList.force Q) ...</code>, we cannot generalize <code>LazyList.force Q</code>.<br>\nThe auxiliary definition above follows the structure of kernel recursors where the motive does not depend on the major premises (aka discriminants), but it prevents us from generalizing effectively. We could work karound this particular issue by using a different encoding where the motive depends on the discriminants</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">def</span> <span class=\"n\">deq.match</span>\n    <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">d₁</span> <span class=\"bp\">=</span> <span class=\"n\">d₁</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">d₁</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d₁</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">none</span> <span class=\"bp\">=</span> <span class=\"n\">d₁</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">none</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">d₁</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₁</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>BTW, I hit similar problems a few times whenever we have <code>match h:t ...</code> where <code>t</code> is not a variable. This kind of <code>match</code> creates a term that cannot be generalized by tactics such as <code>cases</code> and <code>split</code>. The issue also affects any <code>match</code> where the user manually provides a complex <code>motive</code> by hand + discriminants that are not variables. This second scenario is rare since very few people are willing to write complex motives by hand. The problem with <code>match h:t ...</code> is that it makes it super easy for users to create a nontrivial motive. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><br>\nThis issue is bothering me <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Here is another encoding that fixes the problem, but does not change the order: parameter, motive, discriminants, alternatives.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">deq.match</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">))</span>\n              <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)))</span>\n              <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n              <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">d</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"n\">h</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">h₁</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>It removes <code>rfl</code> as a discriminant. In retrospect, it is a bit pointless to take an argument that is always set with <code>rfl</code>.<br>\nThis fix also avoids the workaround <code>unfold deq.proof_1</code>.<br>\nWe would need some extra annotation to make sure we can delaborate this kind of match, but the result will be better.<br>\nFor example, the <code>deq</code> function </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">deq</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">Q.force</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>is currently delaborated as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">deq.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"n\">Q</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">LazyList.force</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>The output is correct, but it exposes our encoding for <code>h:</code>.</p>",
        "id": 277546473,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648926918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>, in case you decide it's worth your attention:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"bp\">=&gt;</span> <span class=\"n\">True.intro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">trace_state</span>\n    <span class=\"n\">exact</span> <span class=\"n\">True.intro</span>\n</code></pre></div>\n<p><code>h</code> has type:</p>\n<p>. <code>nightly-2022-04-29</code>: <code>h : n✝ = n + 1</code><br>\n. <code>nightly-2022-04-30</code>: <code>h : n✝ = Nat.succ n</code></p>",
        "id": 280728296,
        "sender_full_name": "Evgeniy Kuznetsov",
        "timestamp": 1651313348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407798\">@Evgeniy Kuznetsov</span> Thanks for the reporting the discrepancy. I changed how the <code>h :</code> is encoded in to address the issue in this thread and <a href=\"#narrow/stream/270676-lean4/topic/hypothesis.20can't.20be.20used/near/280252919\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/hypothesis.20can't.20be.20used/near/280252919</a><br>\nIn the new encoding, <code>h : &lt;discriminant&gt; = &lt;pattern&gt;</code>. The issues in these threads are not fully resolved, I still have to write a new <code>split</code> tactic that takes into account the new encoding, and add support in <code>simp</code> too.<br>\nIn your example, the discrepancy is on the <code>&lt;pattern&gt;</code> of <code>h : &lt;discriminant&gt; = &lt;pattern&gt;</code>, because <code>x+1</code> is a pseudo-pattern, and only becomes a \"real\" pattern after we reduce it to <code>Nat.succ x</code>. The new behavior seems reasonable to me.<br>\nI have also noticed discrepancies on the <code>&lt;discriminant&gt;</code>. In the new encoding, it is exactly the discriminant we typed, and in the previous encoding, the <code>&lt;discriminant&gt;</code> would be \"refined\" by previous patterns. <br>\nWe want to make sure we have the final encoding before we make the first official Lean 4 release this summer.</p>",
        "id": 280744725,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651337007
    },
    {
        "content": "<p>Note that you can still simulate previous encoding by manually providing the \"motive\" for the <code>match</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span> <span class=\"bp\">→</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span>     <span class=\"bp\">=&gt;</span> <span class=\"n\">True.intro</span>\n  <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">trace_state</span> <span class=\"c1\">-- h : n = y + 1</span>\n    <span class=\"n\">exact</span> <span class=\"n\">True.intro</span>\n</code></pre></div>",
        "id": 280745011,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651337408
    },
    {
        "content": "<p>BTW, I will be tweaking with the new encoding in the next few days. So, we may have a few more discrepancies.</p>",
        "id": 280745646,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1651338260
    },
    {
        "content": "<p>Thank you for a comprehensive answer! Just wanted to make sure this is the expected behavior.</p>",
        "id": 280745982,
        "sender_full_name": "Evgeniy Kuznetsov",
        "timestamp": 1651338762
    }
]
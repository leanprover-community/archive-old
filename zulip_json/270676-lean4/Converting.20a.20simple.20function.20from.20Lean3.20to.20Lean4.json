[
    {
        "content": "<p>Apologies in advance: this is a beginner's question as well as a Lean4 question.</p>\n<p>I am trying to convert a simple function from Lean3 to Lean4.</p>\n<p>Here is the original Lean3 function (from <a href=\"https://github.com/blanchette/logical_verification_2020/tree/master/lean\">https://github.com/blanchette/logical_verification_2020/tree/master/lean</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">drop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>       <span class=\"n\">xs</span>        <span class=\"o\">:=</span> <span class=\"n\">xs</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">[]</span>        <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">drop</span> <span class=\"n\">m</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>To convert to Lean4, I replaced <code>list</code> with <code>List</code> and also added an explicit <code>match</code> (because Lean4 doesn't seem to like <code>|</code> on multiple arguments unless I am missing something):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">drop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span>       <span class=\"n\">xs</span><span class=\"o\">)</span>         <span class=\"bp\">=&gt;</span> <span class=\"n\">xs</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span>   <span class=\"o\">[])</span>         <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">drop</span> <span class=\"n\">m</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>But Lean4 doesn't like this because it cannot prove that it terminates: </p>\n<blockquote>\n<p>fail to show termination for drop with errors: argument <a href=\"https://github.com/leanprover-community/mathlib/pull/2\">#2</a> was not used for structural recursion  failed to eliminate recursive application drop m xs</p>\n</blockquote>\n<p>Can someone please explain what is going on? Thanks in advance.</p>",
        "id": 279083409,
        "sender_full_name": "Richard Evans",
        "timestamp": 1650031901
    },
    {
        "content": "<p>So first things first you can actually write it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">drop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span>       <span class=\"n\">xs</span>        <span class=\"bp\">=&gt;</span> <span class=\"n\">xs</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">[]</span>        <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">drop</span> <span class=\"n\">m</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>secondly, the termination checker does solve this just fine for me.</p>",
        "id": 279083591,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1650032036
    },
    {
        "content": "<p>You're not matching on the second argument but on a pair built using the second argument, which \"hides\" the structural recursion. If you match on the two values rather than a pair, it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">drop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">as</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span>       <span class=\"n\">xs</span>         <span class=\"bp\">=&gt;</span> <span class=\"n\">xs</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span>   <span class=\"o\">[]</span>         <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">drop</span> <span class=\"n\">m</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>You can also drop the match, as Henrik just showed.</p>",
        "id": 279083668,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1650032064
    },
    {
        "content": "<p>That's great. Thank you!</p>",
        "id": 279083703,
        "sender_full_name": "Richard Evans",
        "timestamp": 1650032107
    }
]
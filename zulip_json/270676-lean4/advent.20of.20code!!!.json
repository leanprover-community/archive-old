[
    {
        "content": "<p>hey... would you like to do this year's advent of code in lean 4? <a href=\"https://adventofcode.com\">https://adventofcode.com</a></p>",
        "id": 263415524,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638439790
    },
    {
        "content": "<p>I would imagine that at some point the (at the moment) rather rudimentary stdlib might hit its limits but the first few days should definitely be doable.</p>",
        "id": 263416685,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1638440488
    },
    {
        "content": "<p>obviously the goal is to build the standard library in the process :)</p>",
        "id": 263418390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638441525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/263415524\">said</a>:</p>\n<blockquote>\n<p>hey... would you like to do this year's advent of code in lean 4? <a href=\"https://adventofcode.com\">https://adventofcode.com</a></p>\n</blockquote>\n<p>I've been trying to keep up with it: <a href=\"https://github.com/alcides/AoC2021Lean4\">https://github.com/alcides/AoC2021Lean4</a></p>\n<p>I couldn't find the IO documented, so I've looked at the solutions of last year: <a href=\"https://github.com/rwbarton/advent-of-lean-4\">https://github.com/rwbarton/advent-of-lean-4</a></p>\n<p>I wonder whether the lean4 would be open for PRs regarding the documentation, and if there were any general guidelines regarding expecting quality.</p>",
        "id": 263425680,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1638445961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284775\">@Alcides Fonseca</span>  ah yeah lean4 documentation is like... pretty bare bones at the moment, i assume this is because the devs are still pretty busy developing lean4 itself <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>\n<p>but i think this guide is pretty helpful lol <a href=\"https://agentultra.github.io/lean-4-hackers/\">https://agentultra.github.io/lean-4-hackers/</a></p>",
        "id": 263427139,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638446893
    },
    {
        "content": "<p>They are in principle open for docs and little tutorials over here: <a href=\"https://github.com/leanprover/lean4/tree/master/doc\">https://github.com/leanprover/lean4/tree/master/doc</a> as noted here <a href=\"https://github.com/leanprover/lean4/blob/master/CONTRIBUTING.md#documentation\">https://github.com/leanprover/lean4/blob/master/CONTRIBUTING.md#documentation</a></p>",
        "id": 263427144,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1638446897
    },
    {
        "content": "<p>My approach for if I want to know something about Lean 4 at the moment is to just look how the stdlib/compiler does stuff by reading the source code really, I've found most of it to be quite understandable.</p>",
        "id": 263427189,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1638446944
    },
    {
        "content": "<p>Here is a little snippet of code I wrote a while back that makes working with File I/O a little easier. It may be of use inn tasks like these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.HashSet</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Std</span> <span class=\"n\">System</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">forEachLine</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IO.FS.Handle</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">h.getLine</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ForInStep.done</span> <span class=\"n\">a</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">a</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ForInStep.yield</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">loop</span> <span class=\"n\">a</span>\n  <span class=\"n\">loop</span> <span class=\"n\">init</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ForIn</span> <span class=\"n\">IO</span> <span class=\"n\">IO.FS.Handle</span> <span class=\"n\">String</span> <span class=\"n\">where</span>\n  <span class=\"n\">forIn</span> <span class=\"o\">:=</span> <span class=\"n\">forEachLine</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ForIn</span> <span class=\"n\">IO</span> <span class=\"n\">FilePath</span> <span class=\"n\">String</span> <span class=\"n\">where</span>\n  <span class=\"n\">forIn</span> <span class=\"n\">path</span> <span class=\"n\">init</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"bp\">←</span> <span class=\"n\">IO.FS.Handle.mk</span> <span class=\"n\">path</span> <span class=\"n\">IO.FS.Mode.read</span> <span class=\"n\">false</span>\n    <span class=\"n\">forEachLine</span> <span class=\"n\">h</span> <span class=\"n\">init</span> <span class=\"n\">f</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Print the common lines between two files. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">comm</span> <span class=\"o\">(</span><span class=\"n\">file1</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">file2</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">PUnit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">lines</span> <span class=\"o\">:=</span> <span class=\"n\">HashSet.empty</span>\n  <span class=\"n\">for</span> <span class=\"n\">line</span> <span class=\"k\">in</span> <span class=\"n\">file1</span> <span class=\"k\">do</span>\n    <span class=\"n\">lines</span> <span class=\"o\">:=</span> <span class=\"n\">lines.insert</span> <span class=\"n\">line</span>\n  <span class=\"n\">for</span> <span class=\"n\">line</span> <span class=\"k\">in</span> <span class=\"n\">file2</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">lines.contains</span> <span class=\"n\">line</span> <span class=\"k\">then</span>\n      <span class=\"n\">IO.print</span> <span class=\"n\">line</span>\n</code></pre></div>",
        "id": 263437637,
        "sender_full_name": "Mac",
        "timestamp": 1638452261
    },
    {
        "content": "<p>With the two <code>ForIn</code> instances you can just use <code>for ... in</code> to iterate over the lines in a file! :)</p>",
        "id": 263437717,
        "sender_full_name": "Mac",
        "timestamp": 1638452290
    },
    {
        "content": "<p>In general I'm a big fan of adding more <code>ForIn</code> instances, but these seem really misleading.</p>",
        "id": 263437969,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638452408
    },
    {
        "content": "<p>I would have expected them to iterate over the path components, if anything.</p>",
        "id": 263437999,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638452417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> yeah, the <code>FilePath</code> one is probably excessive. The <code>Handle</code> one seems good though.</p>",
        "id": 263438059,
        "sender_full_name": "Mac",
        "timestamp": 1638452444
    },
    {
        "content": "<p>I'd at least put a wrapper around it, like <code>def Lines := IO Handle</code> and <code>def linesOf : FilePath -&gt; Lines</code> etc.</p>",
        "id": 263438183,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1638452509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I mostly was just copying Python which also has <code>for ... in</code> iterate over the lines of a handle.</p>",
        "id": 263438282,
        "sender_full_name": "Mac",
        "timestamp": 1638452557
    },
    {
        "content": "<p>Obviously it should be a <code>for</code> elaborator that adapts semantics depending on whether you name the loop variable <code>line</code>, <code>word</code>, or <code>char</code></p>",
        "id": 263438546,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638452702
    },
    {
        "content": "<p>Following, <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>'s idea, here is a snippet that uses a distinct <code>def</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lines</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">linesOf</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Lines</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ForIn</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">Lines</span> <span class=\"n\">IO.FS.Handle</span><span class=\"o\">)</span> <span class=\"n\">String</span> <span class=\"n\">where</span>\n  <span class=\"n\">forIn</span> <span class=\"o\">:=</span> <span class=\"n\">forEachLine</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ForIn</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">Lines</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"n\">String</span> <span class=\"n\">where</span>\n  <span class=\"n\">forIn</span> <span class=\"n\">path</span> <span class=\"n\">init</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"bp\">←</span> <span class=\"n\">IO.FS.Handle.mk</span> <span class=\"n\">path</span> <span class=\"n\">IO.FS.Mode.read</span> <span class=\"n\">false</span>\n    <span class=\"n\">forEachLine</span> <span class=\"n\">h</span> <span class=\"n\">init</span> <span class=\"n\">f</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Print the common lines between two files. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">comm</span> <span class=\"o\">(</span><span class=\"n\">file1</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">file2</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">PUnit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">lines</span> <span class=\"o\">:=</span> <span class=\"n\">HashSet.empty</span>\n  <span class=\"n\">for</span> <span class=\"n\">line</span> <span class=\"k\">in</span> <span class=\"n\">linesOf</span> <span class=\"n\">file1</span> <span class=\"k\">do</span>\n    <span class=\"n\">lines</span> <span class=\"o\">:=</span> <span class=\"n\">lines.insert</span> <span class=\"n\">line</span>\n  <span class=\"n\">for</span> <span class=\"n\">line</span> <span class=\"k\">in</span> <span class=\"n\">linesOf</span> <span class=\"n\">file2</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">lines.contains</span> <span class=\"n\">line</span> <span class=\"k\">then</span>\n      <span class=\"n\">IO.print</span> <span class=\"n\">line</span>\n</code></pre></div>",
        "id": 263438637,
        "sender_full_name": "Mac",
        "timestamp": 1638452752
    },
    {
        "content": "<p>Not much difference to <code>IO.FS.lines</code> left then except for streaming?</p>",
        "id": 263438945,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638452884
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> exactly, the main point is streaming.</p>",
        "id": 263439047,
        "sender_full_name": "Mac",
        "timestamp": 1638452940
    },
    {
        "content": "<p>Which should not be relevant for AoC I'd hope, or else I'd pity their servers <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 263439153,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638453001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Fair enough. It is also more declarative, which is nice. :)</p>",
        "id": 263439265,
        "sender_full_name": "Mac",
        "timestamp": 1638453053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> also, this does not trim newlines (which <code>IO.FS.lines</code> does, but Python's <code>for ... in</code> does not).</p>",
        "id": 263440063,
        "sender_full_name": "Mac",
        "timestamp": 1638453417
    },
    {
        "content": "<p>I would not be surprised if stdlibs of various languages can be split 50/50 on this question</p>",
        "id": 263440482,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638453602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/263418390\">said</a>:</p>\n<blockquote>\n<p>obviously the goal is to build the standard library in the process :)</p>\n</blockquote>\n<p>hullo, I'm doing AOC in Lean 4 :)<br>\nI just updated my old vector library for use in day <a href=\"https://github.com/leanprover-community/mathlib/issues/3\">#3</a>, is that something that should get added to the stdlib or is it something that would be good as a standalone library?</p>",
        "id": 263537442,
        "sender_full_name": "Calvin Lee",
        "timestamp": 1638509127
    },
    {
        "content": "<p>not knowing anything about it, I would say sure, PRs to mathlib4 to add tools for dealing with lean 4 stuff are welcome</p>",
        "id": 263537594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638509310
    },
    {
        "content": "<p>you may or may not want to hold off, since you might find something else to add for day 4. Either way is fine</p>",
        "id": 263537728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638509457
    },
    {
        "content": "<p>most projects of any appreciable size accrue a \"<code>for_mathlib</code>\" file containing stuff that really ought to be upstreamed to the relevant library because it's not project specific</p>",
        "id": 263537798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638509538
    },
    {
        "content": "<p>I'm not using mathlib right now because I didn't think mathlib4 was very complete and I'm mostly just programming<br>\nI thought some standalone libraries for \"outside of mathlib programming\" might be nice in general</p>",
        "id": 263538224,
        "sender_full_name": "Calvin Lee",
        "timestamp": 1638510010
    },
    {
        "content": "<p>It's not very complete. The point is for you to change that :)</p>",
        "id": 263539092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638511130
    },
    {
        "content": "<p>as for mathlib vs stdlib, that question will work itself out eventually, and my suggestion is just to treat mathlib4 as a programming library for now. I don't see any reason not to depend on it for your AOC stuff</p>",
        "id": 263539276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638511281
    },
    {
        "content": "<p>the important thing is to actually start building those libraries and dumping them somewhere; rearranging files and splitting projects is comparatively easy</p>",
        "id": 263539347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638511362
    },
    {
        "content": "<p>I had the same feeling as <span class=\"user-mention\" data-user-id=\"382349\">@Calvin Lee</span>. I was hoping for a count method in Lists (even if it required decidable_eq or similar). I believe it should life in the lean4 stdlib, but I believe many smallish PRs would not be welcome at this point. I'll try to make a list and commit them to mathlib4 or to another specific repo for archival purposes.</p>",
        "id": 263568680,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1638532595
    },
    {
        "content": "<p>There was recently a thread about stdlib here: <a href=\"#narrow/stream/270676-lean4/topic/Absolute.20value.20for.20Float/near/262585765\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Absolute.20value.20for.20Float/near/262585765</a></p>\n<p>It boils down to the fact that what Lean 4 calls Std is basically the minimum set of Lean utilities required to compile the compiler and LSP server and not actually a standard library in the regular sense...and after some discussion we more or less agreed to stuff everything into mathlib4 now and maybe have some separate std lib extension library later on.</p>",
        "id": 263568886,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1638532735
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/263537594\">said</a>:</p>\n<blockquote>\n<p>not knowing anything about it, I would say sure, PRs to mathlib4 to add tools for dealing with lean 4 stuff are welcome</p>\n</blockquote>\n<p>What is the plan for <code>mathlib4</code> to grow? Forking and PRing or acquiring writing access to non-protected branches?</p>",
        "id": 263576437,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1638536855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/263568886\">said</a>:</p>\n<blockquote>\n<p>after some discussion we more or less agreed to stuff everything into mathlib4 now and maybe have some separate std lib extension library later on.</p>\n</blockquote>\n<p><em>We</em> did? XD</p>",
        "id": 263579962,
        "sender_full_name": "Mac",
        "timestamp": 1638538467
    },
    {
        "content": "<p>More or less :P</p>",
        "id": 263586951,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1638541709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> PRs should be fine, we don't have a heavy CI setup like mathlib</p>",
        "id": 263614239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638553815
    },
    {
        "content": "<p>I was goaded into finally participating in AoC by friends. My solution for today takes 134s in the interpreter... or 4s when compiled <span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span> .</p>",
        "id": 264126854,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638953618
    },
    {
        "content": "<p>It would be lovely to see people working together on the problems in Lean, but is this sort of thing frowned upon? If so, it would be lovely to see some discussion afterwards about how different people found the questions</p>",
        "id": 264127238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1638953832
    },
    {
        "content": "<p>Last year it was just Reid saying \"I did it, here's the repo\"</p>",
        "id": 264127293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1638953879
    },
    {
        "content": "<p>Usually in AoC everyone works for themselves and afterwards there is some discussion about how people did it. E.g. someone on reddit posted a mini paper on yesterday: <a href=\"https://www.reddit.com/r/adventofcode/comments/rawxad/2021_day_7_part_2_i_wrote_a_paper_on_todays/\">https://www.reddit.com/r/adventofcode/comments/rawxad/2021_day_7_part_2_i_wrote_a_paper_on_todays/</a></p>",
        "id": 264127411,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1638953934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/264127238\">said</a>:</p>\n<blockquote>\n<p>It would be lovely to see people working together on the problems in Lean, but is this sort of thing frowned upon? If so, it would be lovely to see some discussion afterwards about how different people found the questions</p>\n</blockquote>\n<p>not frowned upon at all, feel free to do this if you like</p>",
        "id": 264128225,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1638954380
    },
    {
        "content": "<p>I just finished day 8, and using <code>#eval ...</code> inside the lean file with no compilation gets me the right answer in about 2 seconds.<br>\nI don't know if I had the most efficient approach. this was a fun puzzle :)</p>\n<p>My code is here (<em>spoiler ahead, obviously</em>)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p><a href=\"https://github.com/adamtopaz/lean4_advent_2021/blob/master/day8/part2.lean\">https://github.com/adamtopaz/lean4_advent_2021/blob/master/day8/part2.lean</a></p>\n</div></div>",
        "id": 264163988,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638974468
    },
    {
        "content": "<p>In my defense, I tried for the simplest possible solution :) . It's 23 lines.</p>",
        "id": 264164162,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1638974559
    },
    {
        "content": "<p>Yeah, mine is a bit longer :)</p>",
        "id": 264164195,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1638974575
    },
    {
        "content": "<p>Maybe next year the site could add an <code>Advent of Code</code> stream. Then if the code is indexed by search engines it might give Lean more visibility in the programming world.</p>",
        "id": 264164463,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1638974695
    },
    {
        "content": "<p>I don’t know if anyone has solved part 2 of today’s challenge (day 15). It is a standard pathfinding algorithm, but with a largish size. I’ve found lean to be really slow (even using a tail recursive function). My solution took around 10 minutes on my mbp, but I was expecting it to be solved in one minute, based on other languages.</p>\n<p>I guess my slowdown could be due to using arrays (has a sorting method included, unlike lists). Anyone else having the same issue?</p>\n<p><a href=\"https://github.com/alcides/AoC2021Lean4/blob/master/15/b.lean\">https://github.com/alcides/AoC2021Lean4/blob/master/15/b.lean</a></p>",
        "id": 265049050,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639591113
    },
    {
        "content": "<p>Is it actually tail recursive?</p>",
        "id": 265049201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639591175
    },
    {
        "content": "<p>1) You're using insertionSort, this could be a bit slow.</p>",
        "id": 265049514,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639591254
    },
    {
        "content": "<p>failure of TCO and accidental sharing are the first things I would check for</p>",
        "id": 265049538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639591263
    },
    {
        "content": "<p>2) Array sorting is apparently pretty slow if you run the code in the interpreter.  You might need to compile it, see this other discussion: <a href=\"#narrow/stream/270676-lean4/topic/include.20lean.2Eh/near/264881145\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/include.20lean.2Eh/near/264881145</a></p>",
        "id": 265049931,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639591415
    },
    {
        "content": "<p>I would expect arrays to be faster than lists, not slower, unless you have a lot of sharing</p>",
        "id": 265049958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639591430
    },
    {
        "content": "<p>(My bad Dijkstra takes 4s interpreted, 0.4s compiled for part 2)</p>",
        "id": 265050463,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639591637
    },
    {
        "content": "<p>Your  string parsing (especially <code>parseMatrix</code>) is also doing way to much conversion between Lists and Arrays (<code>toList</code> and <code>toArray</code> are both O(n) operations).</p>",
        "id": 265050787,
        "sender_full_name": "Mac",
        "timestamp": 1639591755
    },
    {
        "content": "<p>Everything in there should ideally just be <code>Array</code>s</p>",
        "id": 265051044,
        "sender_full_name": "Mac",
        "timestamp": 1639591874
    },
    {
        "content": "<p>that's probably not the bottleneck though, since it only happens once. Now that I see this is Dijkstra, that <code>insertionSort</code> looks like the culprit since it's doing an O(n^2) operation where it should be O(log n)</p>",
        "id": 265051103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639591902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> The script is converting an <code>Array</code> of lines (of a very large file) to a <code>List</code>. Then for each <code>String</code> line, it is converting it to a <code>List</code>(allocating a list node for each character of the line) and then to an <code>Array</code>. Then it is converting the entire result back to an <code>Array</code>. That is a lot of heavy duty memory  allocations. While <code>insertionSort</code> is a problem, I would not be surprised if the bottleneck is nonetheless the memory conversion.</p>",
        "id": 265051919,
        "sender_full_name": "Mac",
        "timestamp": 1639592223
    },
    {
        "content": "<p>It does happen in the first phase of the program, so it should not be hard to benchmark that part</p>",
        "id": 265051996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639592258
    },
    {
        "content": "<p>I agree that there are a lot of unnecessary conversions there</p>",
        "id": 265052021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639592275
    },
    {
        "content": "<p>The issue is that the <code>insertionSort</code> sorts the entire priority queue on every iteration, meaning that the overall complexity is somewhere around O(n^3) or O(n^4) for an n * n grid graph</p>",
        "id": 265052179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639592336
    },
    {
        "content": "<p>I am aware of that bottleneck in the parsing. But I have been doing the same thing every day, and it has not been an issue. The reason for that is that I am trying to spend less time writing code (I have other tasks to do), and unfortunately List and Array do not have the same utility methods, so I end up doing the conversion every now and then. But I'm sure that is not the issue, but rather Dijksgtra (i didn't mention it, because I didn't want to spoiler anyone :-)</p>",
        "id": 265052318,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639592394
    },
    {
        "content": "<p>If you can't be bothered to write the code yourself, you could instead put an issue on mathlib4 for any missing utility theorems so that we can at least record the problem and maybe get around to it later</p>",
        "id": 265052578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639592490
    },
    {
        "content": "<p>I tried to use the binary insert instead of sorting, but it didn't work correct (probably misuse, or I didn't understand what the function was supposed to do).</p>\n<p>I know that I should have implemented an ordered insert on the array, but I wanted to take this opportunity to use the current stdlib and identify what I need from it. That is one example.</p>",
        "id": 265052587,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639592494
    },
    {
        "content": "<p>Finally a use case for spoiler tags <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 265052652,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639592522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/265052578\">said</a>:</p>\n<blockquote>\n<p>If you can't be bothered to write the code yourself, you could instead put an issue on mathlib4 for any missing utility theorems so that we can at least record the problem and maybe get around to it later</p>\n</blockquote>\n<p>That is the point of this exercice. I am writing down all the missing functions I feel I need, and I hope to contribute them early next year.</p>",
        "id": 265052710,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639592535
    },
    {
        "content": "<p>I would also like to prove some things about these programs, or write them in a more type-safe approach (I am using a lot of ! methods). But I'll leave that for after the challenge.+</p>",
        "id": 265052909,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639592624
    },
    {
        "content": "<p>It's usually pretty easy to know what to prove once you have the functions, provided the function isn't written in a way that precludes proof (i.e. <code>partial</code>)</p>",
        "id": 265053051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639592680
    },
    {
        "content": "<p>I'm not sure what your input is, maybe the distribution makes this reasonable, but the <code>wrap9</code> function has a really bad asymptotic complexity</p>",
        "id": 265053588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639592901
    },
    {
        "content": "<p>The highest input for that function will be 19. That is now the source of the slowdown. I agree with you that it should be the insertionSort.</p>",
        "id": 265054063,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639593082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Do you know why <code>Array.back</code> and <code>Array.pop</code> have the interface that they do? It seems like it would work better with the reference counting to have them combined into one function. And I'm always afraid of the <code>pop</code> causing a copy if the <code>back</code> call floats after it somehow.</p>",
        "id": 265054233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639593151
    },
    {
        "content": "<p>Allocating a pair for the return value wouldn't exactly be ideal either, no? I know the floating story is not completely clear yet, but ideally we should guarantee that this never happens imo.</p>",
        "id": 265054508,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639593259
    },
    {
        "content": "<p>I think we're all counting on return value unboxing. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 265054562,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639593292
    },
    {
        "content": "<p>Eventually :)</p>",
        "id": 265054587,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639593305
    },
    {
        "content": "<p>Is there any hope of LLVM doing this already?</p>",
        "id": 265054610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639593317
    },
    {
        "content": "<p>An alternative interface that doesn't rely on pair unboxing is <code>IORef (Array A) -&gt; IO A</code></p>",
        "id": 265054694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639593361
    },
    {
        "content": "<p>More seriously, the same problem is also there with tons of other functions and other types like string.  Bundling back/pop only fixes a single instance.</p>",
        "id": 265054805,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1639593400
    },
    {
        "content": "<p>you mean back/pop on string?</p>",
        "id": 265054884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639593439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/265054610\">said</a>:</p>\n<blockquote>\n<p>Is there any hope of LLVM doing this already?</p>\n</blockquote>\n<p>Last time I looked, LLVM doesn't know anything about annihilating (custom) malloc-free pairs</p>",
        "id": 265054929,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639593459
    },
    {
        "content": "<p>maybe if it inlines the custom code... generating LLVM directly would probably help here</p>",
        "id": 265055047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639593504
    },
    {
        "content": "<p>We definitely don't want to inline the allocator any more than we already do</p>",
        "id": 265055129,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639593546
    },
    {
        "content": "<p>Are <code>lean_object</code>s ever stack allocated?</p>",
        "id": 265055281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639593608
    },
    {
        "content": "<p>These transient pairs would work well with escape analysis</p>",
        "id": 265055386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639593657
    },
    {
        "content": "<p>Not right now, no</p>",
        "id": 265055415,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1639593666
    },
    {
        "content": "<p>By the way, what is a recommended way to write small unit tests for lean? I started to compile a collection of extra methods that I was missing from scala, haskell, etc. but I am not sure how to add small tests to them:<br>\n<a href=\"https://github.com/tjhunter/advent_of_code_lean4_2021/blob/main/MyAdvent/AdventStd.lean\">https://github.com/tjhunter/advent_of_code_lean4_2021/blob/main/MyAdvent/AdventStd.lean</a></p>\n<p>The most interesting can be sent as a PR if there is interest for it. (also, any advice on the code is welcome!)</p>",
        "id": 265300275,
        "sender_full_name": "Tim Hunter",
        "timestamp": 1639750490
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"460889\">@Tim Hunter</span> the common approach is just to write a test file with <code>#eval</code> statements that test the code and then run <code>lean</code> on the file to verify that it does not error.</p>",
        "id": 265365403,
        "sender_full_name": "Mac",
        "timestamp": 1639777855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/advent.20of.20code!!!/near/265365403\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"460889\">Tim Hunter</span> the common approach is just to write a test file with <code>#eval</code> statements that test the code and then run <code>lean</code> on the file to verify that it does not error.</p>\n</blockquote>\n<p>I've been using eval for small utilities. However, because some functions have to be tested with large-ish inputs (like today's puzzle), I end up just making a lot of changes to the main function. But I agree some little DSL might be useful.</p>",
        "id": 265473451,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639909820
    },
    {
        "content": "<p>Btw, regarding today's puzzle, I only managed to run it when compiled. The interpreted version was too slow to be practical. I wonder if this could be useful for performance (regression) testing?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Link to my solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p><a href=\"https://github.com/alcides/AoC2021Lean4/blob/master/19/a.lean\">https://github.com/alcides/AoC2021Lean4/blob/master/19/a.lean</a></p>\n<p>I know there are a few alternatives to reduce complexity:\n* using sets/hashmaps to reduce the time iterating arrays.\n* someone commented a fingerprint approach using triangles.</p>\n<p>But I do not have infinite amount of time to play with this, so the first solution that works is fine.</p>\n<p>It took &lt;30s in the compiled version, but more than 1 hour in the interpreted version. It is still halfway right now.</p>\n</div></div>",
        "id": 265474377,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1639911468
    }
]
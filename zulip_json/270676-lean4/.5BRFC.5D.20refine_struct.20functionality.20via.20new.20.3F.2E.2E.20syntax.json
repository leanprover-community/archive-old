[
    {
        "content": "<p>It seems like I don't have permission to move the topic out of the mathlib4 stream (the <strong>Move topic</strong> option doesn't show up upon clicking the ellipsis next to the topic in the sidebar); anyone who does have permission to move this topic to #lean4 is welcome to do so :) (I changed the name, at least!)</p>",
        "id": 307871928,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1667527718
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax\">#mathlib4 &gt; [RFC] refine_struct functionality via new ?.. syntax</a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span>.</p>",
        "id": 307892478,
        "sender_full_name": "Notification Bot",
        "timestamp": 1667544075
    },
    {
        "content": "<p>Okay, I've implemented this functionality! :) I've done it by modifying a copy of <code>StructInst.lean</code> in such a way that it can easily be slotted in wherever is deemed best: as a modification of/replacement for <code>StructInst.lean</code> in Lean 4, or as an auxiliary file in std4 or mathlib4. The syntax it's implemented with can also be easily modified. (If it turns out that it doesn't belong anywhere, it was at least a great learning experience!)</p>\n<p>With the current implementation, you can use e.g. <code>{ x := 0, ?.. }</code> to fill in all non-default fields with holes named by the missing field. There's also functionality to fill in <em>all</em> unspecified fields with goals (instead of using default values); to prefix each goal with a specified name; and to avoid conflicting goal names introduced by multiple occurrences of <code>{ ?.. }</code>.</p>\n<p>There are still some design choices to be made (syntax, default behavior, implementation details—the current implementation chooses certain options arbitrarily just to get it working), and while I have some opinions about some of them (see above!), I'll happily defer to whatever people choose!</p>\n<p>But first things first:</p>\n<ol>\n<li>\n<p>Where should this functionality go? Should it be part of Lean 4, std4, or mathlib4?</p>\n</li>\n<li>\n<p>What's the procedure for making these choices? Consensus on a github issue, the call of a core dev, etc...? And are there next steps that I should take here re: opening an issue somewhere, continuing to post in this thread, etc.? (This depends on 1, of course! If Lean 4, I can follow the contribution guidelines.)</p>\n</li>\n</ol>",
        "id": 309258874,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668199719
    },
    {
        "content": "<p>I think the general answer to these questions is: put it in mathlib4 first. We'll take anything (* some conditions apply), and then when the maintainers of std4 and/or lean4 want to \"promote\" something up the chain they can pull it out of mathlib4.</p>\n<p>The bandwidth for reviewing material for std4 and lean4 is much narrower, so aiming for mathlib4 first optimises the time of those reviewers, and also gives a chance for some battle-testing. :-)</p>",
        "id": 309423088,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1668322993
    },
    {
        "content": "<p>Ok, sounds good! I'll make a new branch and get it running there. :) (Also, I <em>thought</em> it would work easily in core, but I couldn't quite get it to build—bested by something parser-related in the built-in macros. So putting it in mathlib4 is good! <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>)</p>",
        "id": 310520391,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668641237
    },
    {
        "content": "<p>So, there are some design and implementation choices to be made before I think this should be accepted and considered \"done\" in mathlib! I'll post those choices here, but the current \"working\" version is available on the branch <code>thorimur/refine_struct-via-StructInst</code> <a href=\"https://github.com/leanprover-community/mathlib4/blob/thorimur/refine_struct-via-StructInst/Mathlib/Lean/Elab/StructInstWithHoles.lean\">here</a>. (It's only the linting that fails currently.)</p>\n<p>I'm not entirely sure how these decisions get made—if we try reach consensus among people who are interested, and/or what person or group has the final call. (Is it you, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  ? 👀) Either way, if you have an opinion, please react with thumbs up/down (or a number emoji like <span aria-label=\"two\" class=\"emoji emoji-0032-20e3\" role=\"img\" title=\"two\">:two:</span>, if relevant)! Or, use a <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> to indicate the current implementation is OK. (Or reply for further discussion!)</p>\n<p>I bold the actual questions at the top of each choice to be made. The rest is just me giving any context or thoughts I have.</p>",
        "id": 310715134,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725759
    },
    {
        "content": "<p>(Apologies—barrage of messages incoming.)</p>",
        "id": 310715196,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725770
    },
    {
        "content": "<h1>Design choices</h1>\n<h2><em>Current implementation</em></h2>\n<p>The current implementation uses four pieces of syntax to toggle the named quality of the goals independently from the default synthesis behavior. All of these are tentative, pending the following choices. Those are</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: right;\"></th>\n<th style=\"text-align: center;\">use defaults</th>\n<th style=\"text-align: center;\">no defaults</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: right;\">named, synthetic</td>\n<td style=\"text-align: center;\"><code>?..</code></td>\n<td style=\"text-align: center;\"><code>?..!</code></td>\n</tr>\n<tr>\n<td style=\"text-align: right;\">unnamed, natural</td>\n<td style=\"text-align: center;\"><code>...</code></td>\n<td style=\"text-align: center;\"><code>..!</code></td>\n</tr>\n</tbody>\n</table>\n<p>Currently <code>...</code> is just to demonstrate functionality/provide a possible stand=in for <code>..</code> if migrated to core. <code>!</code> is also likely to change to something more descriptive.</p>\n<p>In the named case, hole names can be prefixed with a custom name via <code>?..x</code> and <code>?..!x</code>. This is also a design choice to make.</p>",
        "id": 310715244,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725800
    },
    {
        "content": "<h2>Choice 1: default value synthesis</h2>",
        "id": 310715316,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725839
    },
    {
        "content": "<h3>(a) Standard behavior</h3>\n<p><strong>Should <code>?..</code> synthesize defaults or not?</strong></p>\n<p>Currently, <code>..</code> syntax in structures produces natural holes for all fields. As far as I can tell this is used quite frequently in pattern matching on structures, so I'm not sure we would want to change this behavior.</p>\n<p>Mario raised the point that adding a new field to a structure along with a default value for that field shouldn't be a breaking change in the standard case.</p>\n<p>I'm new to Lean, so I'm not sure how one typically uses default values in mathematical structures, and whether it would be useful to by default have <code>refine { ?.. }</code> fill in all the data it can, or whether we want to be able to create goals for all fields. Mario also mentioned that typically we'd want to write data explicitly and use tactics only for proofs, e.g. <code>refine { x := 0, ?.. }</code>, which is another point to consider in favor of <code>?..</code> synthesizing defaults.</p>",
        "id": 310715334,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725846
    },
    {
        "content": "<h3>(b) Accessible default-synthesis behaviors</h3>\n<p><strong>Should it be possible to create natural, unnamed holes while also synthesizing defaults?</strong> I personally can't see a use for this behavior; can someone think of one? If not, a possible syntax design is</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: right;\"></th>\n<th style=\"text-align: center;\">use defaults</th>\n<th style=\"text-align: center;\">no defaults</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: right;\">named, synthetic</td>\n<td style=\"text-align: center;\"><code>?..</code></td>\n<td style=\"text-align: center;\"><code>?..!</code></td>\n</tr>\n<tr>\n<td style=\"text-align: right;\">unnamed, natural</td>\n<td style=\"text-align: center;\">×</td>\n<td style=\"text-align: center;\"><code>..</code></td>\n</tr>\n</tbody>\n</table>\n<p>where we rely on the built-in syntax for \"no defaults\". (Replace <code>?..!</code> with the outcome for <strong>Choice 1.c</strong> below.)</p>\n<p><strong>Con:</strong> As is, this breaks the metaphor a little bit. <code>?..</code> is meant to be \"the version of <code>..</code> that we expect to interact with\". But maybe it's alright—after all, if we have to interact with something, it might make sense that Lean takes care of it as much as it can for us beforehand, in this case by filling the goals it can with default values.</p>\n<p>Also, these might switch depending on the outcome of <strong>Choice 1.a</strong>. In that case, the metaphor wouldn't be broken at all.</p>",
        "id": 310715350,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725853
    },
    {
        "content": "<h3>(c) Default-synthesis syntax</h3>\n<p><strong>What should the syntax for avoiding default synthesis be? <code>!</code>, <code>noDefaults</code>, something else, or nothing?</strong> (Or, if standard behavior is swapped according to <strong>Choice 1.a</strong>, what should the syntax for <em>synthesizing</em> defaults be?)</p>\n<p>This implementation uses <code>?..!</code>, and while that is <em>sort of</em> concordant with the use of <code>!</code> in Lean in general—we're telling the hole <code>?..</code> to \"work harder\" and fill more fields!—it's a bit of a weak metaphor. We could instead do something like <code>?.. noDefaults</code>, or any other token. Suggestions welcome!</p>\n<p>Another option is to disallow this functionality entirely, and force the user to write in each <code>x := ?x</code> by hand for fields <code>x</code> with a default value. I don't like this; the option to make it easier is right there! Plus, these goals wouldn't have the nice metadata created by <code>?..!</code>, which means they wouldn't automatically avoid name conflicts and wouldn't be able to pass info (like the field in question) on to other tactics.</p>",
        "id": 310715456,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725893
    },
    {
        "content": "<h2>Choice 2: Goal names</h2>",
        "id": 310715486,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725911
    },
    {
        "content": "<h3>(a) Prefix syntax</h3>\n<p><strong>What syntax should be used to specify a prefix name?</strong> Currently it's possibly to prefix the field name with some <code>a</code> via e.g. <code>?..a</code>. So, if <code>?..</code> produced a goal named <code>foo</code>, <code>?..x</code> would produce a goal named <code>x.foo</code>. The three options I can see are</p>\n<ol>\n<li><code>?x..</code></li>\n<li><code>?..x</code> (current)</li>\n<li><code>x@?..</code></li>\n</ol>\n<p>I personally like <code>?x..</code>—it parallels <code>?x</code>, and puts <code>x</code> in a position that feels more prefix-y (as opposed to at the end). (It's only not what I implemented because I ran into some parsing issues, so it remains to be seen if these can be overcome.)</p>\n<p><code>x@?..</code> parallels the naming of patterns, but is a bit cluttered, and is really being used for a different thing. Still, it might be nice.</p>",
        "id": 310715496,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725916
    },
    {
        "content": "<h3>(b) Default goal names</h3>\n<p><strong>Should names by default be prefixed with the name of the structure?</strong> Currently I don't do this—my feeling is that it can be cluttering to have something like <code>semigroup.mul</code> instead of just <code>mul</code>, so I just use <code>mul</code>. But I thought I'd put this choice out there, since it's easy to change in the code.</p>",
        "id": 310715511,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725926
    },
    {
        "content": "<h1>Implementation questions</h1>",
        "id": 310715527,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725935
    },
    {
        "content": "<h2>Choice 3: metadata</h2>\n<p><strong>How should metadata be stored for each goal?</strong> Currently, the metadata necessary to avoid naming conflicts and to allow access to the structure  information is stored as metadata on the goal's type. Metadata can only be stored on an <code>Expr</code>, and as a <code>KVMap</code> (as far as I know), so this is both fragile (since the type can change as tactics are applied, and the metadata lost) and limited (since <code>KVMap</code>s can only store limited kinds of values). I'm open to more robust implementations. As far as I know the options might be</p>\n<ol>\n<li>store metadata on the type (current)</li>\n<li>use an environment extension (?)</li>\n<li>give the metavariables local instances (???)</li>\n</ol>\n<p>I don't know how either 2 or 3 would work; I'm not very familiar with environment extensions, and I'm not sure how 3 would be done \"manually\" for each metavariable or how it would be used.</p>",
        "id": 310715534,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725941
    },
    {
        "content": "<h2>Choice 4: Which defaults to avoid synthesizing when avoiding default synthesis?</h2>\n<p>Currently, if the binder of a type is <code>.instImplicit</code>, we try to synthesize an instance. <strong>Should this be done even when we don't want to synthesize default values per se?</strong></p>",
        "id": 310715568,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1668725952
    },
    {
        "content": "<p>Sorry for the ignorant question <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span>, but what happened to this? We've started porting files where <code>refine_struct</code> is being used, and it would be nice to have in mathlib asap.</p>",
        "id": 312976435,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1669776273
    },
    {
        "content": "<p>It's <em>basically</em> ready and working on the branch <code>thorimur/refine_struct-via-StructInst</code> in mathlib4, up to the design choices above! (We started discussing it inadvertently <a href=\"#narrow/stream/287929-mathlib4/topic/Linting.20standards.20for.20mathlib/near/311109890\">here</a>, and I suppose I really should have included an update on this thread as well...)</p>",
        "id": 312977915,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669777463
    },
    {
        "content": "<p>what is mathport supposed to do with the new tactic, since my understanding is that it's not a direct translation?</p>",
        "id": 312978041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669777572
    },
    {
        "content": "<p>So (I think—not totally sure of the internals of mathport) we'd align <code>refine_struct</code> with <code>refine</code>, and translate <code>..</code> (when it occurs in a structure instance following <code>refine_struct</code>) into <code>?..</code>. Or, into <code>?..!</code> (or whatever syntax we preferred for \"fill with synthetic goals, and don't synthesize defaults\")—this would preserve the behavior exactly</p>",
        "id": 312978126,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669777666
    },
    {
        "content": "<p>Did we establish that <code>..</code> / <code>refine'</code> isn't going to work?</p>",
        "id": 312978192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669777716
    },
    {
        "content": "<p>that is to say, the choices about <code>?..</code> vs <code>..</code> aren't really related to the main reason people use <code>refine_struct</code> instead of <code>refine</code> on a struct, which is that it labels the subgoals</p>",
        "id": 312978490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669777964
    },
    {
        "content": "<p><code>..</code> / <code>refine'</code> would work for any instances that don't get followed by tactics which refer to the name of the goal explicitly or via <code>pi_instance_derive_field</code>, which also refers to named goals.</p>",
        "id": 312978504,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669777979
    },
    {
        "content": "<p>can <code>..</code> name the goals?</p>",
        "id": 312978532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669778010
    },
    {
        "content": "<p>What do you mean? I've implemented it such that <code>?..</code> labels the subgoals</p>",
        "id": 312978539,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669778014
    },
    {
        "content": "<p><code>..</code> <em>could</em> technically name the subgoals, but as I understand it <code>..</code> is also used quite a bit in pattern-matching by basically expanding something like <code>{ x := 0, .. }</code> to a structure instance with <code>_</code>'s in every spot. (is this correct?) That means we'd want those to be natural and solved by unification, while the named ones should be synthetic opaque, I think. (Though this also rests on my assumption that you can't pattern match with synthetic opaque goals, and I'm not 100% sure if that's true.)</p>\n<p>Also, one thing about <code>?..</code> is that (under the current syntax choices) it also synthesizes defaults. If pattern-matching on things like <code>{ x := 0,  .. }</code> works how I think it does, then synthesizing defaults with <code>..</code> would prevent some patterns from matching.</p>\n<p>Naming subgoals also currently involves putting metadata on the resulting goals so that future tactics like <code>have_field</code> and <code>pi_instance_derive_field</code> can refer to it, which I don't think we'd want <code>..</code> to be doing all the time in patterns. (<em>However</em>, <code>have_field</code> isn't used and <code>pi_instance</code> could be rewritten to obviate the need for metadata, so.)</p>",
        "id": 312978908,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669778354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/312978908\">said</a>:</p>\n<blockquote>\n<p><code>..</code> <em>could</em> technically name the subgoals, but as I understand it <code>..</code> is also used quite a bit in pattern-matching on subgoals by basically expanding to a structure instance with <code>_</code>. (is this correct?) That means we'd want those to be natural, while the named ones should be synthetic opaque, I think.</p>\n</blockquote>\n<p>Natural mvars can be named too</p>",
        "id": 312979036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669778469
    },
    {
        "content": "<p>Right, but metavariables meant to be used as goals shouldn't be natural, right?</p>",
        "id": 312979188,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669778602
    },
    {
        "content": "<p>I don't think that the full proposal is going to land as is. The dev team just doesn't have the bandwidth for it, and it doesn't seem to have much popular support or even discussion of the proposal beyond me and you</p>",
        "id": 312979257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669778648
    },
    {
        "content": "<p>So I think a better target is a MVP that does what we need for mathlib and doesn't make too many other changes</p>",
        "id": 312979280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669778688
    },
    {
        "content": "<p>Right, that's why currently it's going to mathlib!</p>",
        "id": 312979282,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669778691
    },
    {
        "content": "<p>I anticipate issues with two competing structure syntaxes, this is bad for the parser</p>",
        "id": 312979328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669778749
    },
    {
        "content": "<p>How so? This one only occurs in cases that explicitly include <code>?..</code> or <code>?..!</code> (no optionality)</p>",
        "id": 312979400,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669778790
    },
    {
        "content": "<p>Would it work if it wasn't in the <code>term</code> category and was just a special bit of syntax accepted by <code>refine_struct</code>?</p>",
        "id": 312979466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669778870
    },
    {
        "content": "<p>It's a backtracking issue even if it is distinct from the existing syntax</p>",
        "id": 312979534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669778922
    },
    {
        "content": "<p>I mean, I guess if you want an MVP I could insist that the parser just demands <code>refine_struct</code> in front of the current structure-with-<code>?..</code> syntax, and then at the end it feeds the instance it got back as syntax to <code>refine</code></p>",
        "id": 312979557,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669778952
    },
    {
        "content": "<p>oh, is backtracking on syntax very expensive? <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 312979574,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669778977
    },
    {
        "content": "<p>We define a lot of structures. :-)</p>",
        "id": 312979695,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1669779024
    },
    {
        "content": "<p>Ah...would the mathlib syntax get checked first? oof, yeah...</p>",
        "id": 312979723,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779068
    },
    {
        "content": "<p>At least until recently parsing <code>def x := [[[[[[[[[[[[[[[[[[[[</code> was exponential in the number of <code>[</code> because of parser backtracking among the various syntaxes that start with <code>[</code></p>",
        "id": 312979731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779080
    },
    {
        "content": "<p>I see...so it would only really be efficient enough if subsumed into core, and if there isn't bandwidth/support for it there...</p>",
        "id": 312979831,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779199
    },
    {
        "content": "<p>right, the correct way to handle this efficiently is with a <code>\"..\" &lt;|&gt; \"?..\"</code> at the end of the structure parser instead of having two carbon copy parsers that differ only in the last bit</p>",
        "id": 312979900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779251
    },
    {
        "content": "<p>I think a lighter change that would do what we need and might not even break the world is to make <code>..</code> introduce named synthetic mvars</p>",
        "id": 312979951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779321
    },
    {
        "content": "<p>yeah, that's what I was trying for when trying to see if I could get it into core! I ran into problems only really with the built-in macro in <code>StructInst</code>...it has a bit that goes <code>$[..%$ell]?</code>, and it didn't seem to want to use something like <code>$[$ell:variadicHole]?</code> with <code>variadicHole</code> a parser in <code>Term</code>, I'm guessing due to when various things become available for what.</p>",
        "id": 312980051,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779400
    },
    {
        "content": "<blockquote>\n<p>I think a lighter change that would do what we need and might not even break the world is to make .. introduce named synthetic mvars</p>\n</blockquote>\n<p>Ok, I can try this. I worry about the synthetic vs. synthetic opaque distinction though. It seemed to run into problems when they were just synthetic</p>",
        "id": 312980095,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779446
    },
    {
        "content": "<p>Does it work in pattern position?</p>",
        "id": 312980102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779461
    },
    {
        "content": "<p>i.e. does <code>match x with | { a := ?a } =&gt; ...</code> work</p>",
        "id": 312980162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779484
    },
    {
        "content": "<p>Is <code>?a</code> always synthetic opaque?</p>",
        "id": 312980176,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779501
    },
    {
        "content": "<p>yes, but expressions are handled specially in pattern position</p>",
        "id": 312980189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779521
    },
    {
        "content": "<p>Hmm okay! Let me check if <code>?..</code> works in pattern position on my branch</p>",
        "id": 312980227,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779540
    },
    {
        "content": "<p>Oh weird, <code>?a</code> in pattern position acts the same as <code>a</code></p>",
        "id": 312980364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779631
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">let</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.mk</span> <span class=\"mi\">0</span><span class=\"bp\">;</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 312980414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779697
    },
    {
        "content": "<p>hmmm! on my branch</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo'</span> <span class=\"n\">where</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">Foo'</span> <span class=\"o\">}</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"o\">{</span> <span class=\"bp\">?..</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>yields \"invalid pattern\" (but <code>..</code> works)</p>",
        "id": 312980492,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779769
    },
    {
        "content": "<p>is <code>{ ?.. }</code> an <code>elab</code> or <code>macro</code>?</p>",
        "id": 312980590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669779848
    },
    {
        "content": "<p><code>elab</code></p>",
        "id": 312980594,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779857
    },
    {
        "content": "<p>Since it's based off of the term elab <code>StructInst</code>, but just applied in different syntactic circumstances</p>",
        "id": 312980609,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669779884
    },
    {
        "content": "<p>Looks like <a href=\"https://github.com/leanprover/lean4/blob/3e45060dd52c13ee4904da1ccf6279df154f1a8a/src/Lean/Elab/PatternVar.lean#L181-L184\">the set of patterns is non-extensible</a></p>",
        "id": 312980809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669780047
    },
    {
        "content": "<p>Oh, ok! So we might only be able to tell if creating named synthetic opaque goals works in patterns in this case by actually modifying <code>..</code>'s behavior in core. I could try that tomorrow</p>",
        "id": 312981050,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669780224
    },
    {
        "content": "<p>(Well, or by reading the right code, I guess!)</p>",
        "id": 312981087,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669780240
    },
    {
        "content": "<p>The code I posted above shows what happens when you use synthetic opaques in a pattern</p>",
        "id": 312981692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669780675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/312980364\">said</a>:</p>\n<blockquote>\n<p>Oh weird, <code>?a</code> in pattern position acts the same as <code>a</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">let</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.mk</span> <span class=\"mi\">0</span><span class=\"bp\">;</span> <span class=\"n\">a</span>\n</code></pre></div>\n</blockquote>",
        "id": 312981755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669780698
    },
    {
        "content": "<p>Oh, sorry, I misread—I thought you had said <code>?a</code> syntax was handled differently in patterns, but you had said that the expressions were handled differently, my bad</p>",
        "id": 312981841,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669780743
    },
    {
        "content": "<p>So is this...desirable? Is it okay to have those names floating around</p>",
        "id": 312982014,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669780857
    },
    {
        "content": "<p>I think the main possibility for breakage is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(⟨</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"o\">)⟩)</span>\n<span class=\"k\">#check</span> <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Foo.mk</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Foo.mk</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">a</span>\n              <span class=\"c1\">-- ^^^ invalid pattern, variable 'a' occurred more than once</span>\n</code></pre></div>",
        "id": 312982140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669780934
    },
    {
        "content": "<p>oh oops, I did it wrong</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(⟨</span><span class=\"bp\">?$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"o\">)⟩)</span>\n<span class=\"k\">#check</span> <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Foo.mk</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Foo.mk</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">a</span> <span class=\"c1\">-- ok, `a` refers to the second occurrence</span>\n</code></pre></div>",
        "id": 312982252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669781027
    },
    {
        "content": "<p>that is, <code>?a</code> acts kind of like <code>a</code>, but if there are multiple occurrences they will shadow instead of causing the multiple declaration error</p>",
        "id": 312982350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669781084
    },
    {
        "content": "<p>My implementation does aggressively avoid naming conflict when creating the metavariable names by checking the metavariable context, but relies on metadata on the metavariables to do so—overhead I imagine we'd want to avoid when we don't plan on using it? Or is that cheap? (Do metavar contexts work the same way in patterns?)</p>",
        "id": 312982418,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669781142
    },
    {
        "content": "<p>performing extra checks here is probably not a performance concern, but adding more state to the mvar context is almost certainly a non-starter</p>",
        "id": 312982512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669781201
    },
    {
        "content": "<p>adding more state—does that happen by checking it? just want to make sure it's clear that the metadata is on the field metavariables as mdata on the type, not, like, as extra metavariables in the context or something</p>",
        "id": 312982761,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669781370
    },
    {
        "content": "<p>(though, this is something I wanted to check in review or something: <em>should</em> it be there as mdata on the type? would local instances (which I don't understand, at least insofar as how metavariables acquire/use them in their local instance field) be feasible and/or more robust? (All I know about local instances is that metavariables have a field for them.))</p>",
        "id": 312982952,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669781469
    },
    {
        "content": "<p>Actually, looking at the code I linked earlier, it directly traverses the syntax of that closed class of expressions in order to find the set of bound variables. Therefore <code>{ .. }</code> does <em>not</em> act the same as <code>{x := _}</code> or <code>{x := ?a}</code> because the latter actually has an <code>?a</code> in the syntax. So my projection is that if you made <code>{ .. }</code> make synthetic mvars it would not change anything about the set of accessible variables and the <code>let ?a := 1; a</code> example wouldn't work if <code>?a</code> was generated by a <code>{ .. }</code> pattern match</p>",
        "id": 312983111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669781595
    },
    {
        "content": "<p>Nice!</p>",
        "id": 312983162,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669781634
    },
    {
        "content": "<p>(I think—assuming the goal is for its pattern behavior to not change.)</p>",
        "id": 312983235,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669781663
    },
    {
        "content": "<p>yes, I think we want that</p>",
        "id": 312983253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669781672
    },
    {
        "content": "<p>99% of uses of <code>..</code> in lean core are in patterns, so if the behavior there is unchanged then you have a good chance of not breaking it</p>",
        "id": 312983331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669781716
    },
    {
        "content": "<p>fwiw I do still think that having <code>..</code> name metavariables is super unintuitive from a usage perspective for exactly that reason...because you expect <code>..</code> to be discarded or taken care of like <code>_</code>, whereas <code>?</code>-ish things are things you're going to care about later. but I've said my piece, so ultimately I'll do whatever is decided</p>",
        "id": 312983615,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669781889
    },
    {
        "content": "<p>By the way, <code>apply</code> also names its subgoals using named natural metavariables</p>",
        "id": 312984172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669782289
    },
    {
        "content": "<p>hmm, true. but that does seem inconsistent with the behavior of <code>refine</code>, which is the context I'm basing this line of thought off of...</p>",
        "id": 312984685,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669782628
    },
    {
        "content": "<p>also does apply attempt to fill in those <code>_</code>s?</p>",
        "id": 312984717,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669782663
    },
    {
        "content": "<p>but, in any case! I've written enough about my reasoning for <code>?</code> at the top of this topic, lol. so, if we <em>do</em> have <code>..</code> make named metavariables, should there still be metadata on the metavariables? If not, three things would happen:</p>\n<ul>\n<li>I would rewrite how name conflicts are resolved</li>\n<li><code>have_field</code> would not be ported (never actually used in mathlib besides in <code>pi_instance</code>, but might be used by people outside of mathlib, idk)</li>\n<li>either <code>pi_instance_derive_field</code> would need to explicitly take in the name of the field as an argument, <em>or</em> it would have to be subsumed into <code>piInstance</code> in the way talked about over at the thread I started about porting <code>pi_instance</code> (which would be the cleaner (and easier) approach imo)</li>\n</ul>\n<p>does all that sound good? or should we keep the metadata?</p>",
        "id": 312985099,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669782973
    },
    {
        "content": "<p>also, in this case, what about synthesizing all defaults that are possible to synthesize? that functionality is implemented—would we just not use it, or would we want special syntax for it?</p>",
        "id": 312986040,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669783732
    },
    {
        "content": "<p>I think we need to do that for compatibility with the old lean 4 behavior</p>",
        "id": 312986657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669784216
    },
    {
        "content": "<p>which one? (keep/abandon metadata or abandon a way to access default synthesis?)</p>",
        "id": 312986991,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669784434
    },
    {
        "content": "<p>keep default synthesis</p>",
        "id": 312990592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669787097
    },
    {
        "content": "<p>oh, ok, neat. what syntax should be used? I'm guessing it needs to be different than <code>..</code> otherwise patterns using it will only match those that have the default values for the fields, right? (or no?) (currently <code>..</code> does not synthesize any defaults)</p>",
        "id": 312991071,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669787487
    },
    {
        "content": "<p>/poll Generally, what syntax should create named goals for fields in structure syntax (esp. in the context of <code>refine</code>)?<br>\n<code>?..</code> for named goals,  <code>..</code> for patterns (unnamed goals)<br>\n<code>..</code> for everything (both named goals and patterns)</p>",
        "id": 313385470,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1669931705
    },
    {
        "content": "<p>I think you're not getting many responses because many people (including me) are fine with either option and don't have a strong opinion.</p>",
        "id": 313469200,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1669977225
    },
    {
        "content": "<p>I guess that should be an option then?</p>",
        "id": 313469486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669977319
    },
    {
        "content": "<p>I gave this issue some thought last night and I think we haven't been considering one of the more important aspects of synthetic opaque vs natural metavars which is that opaque mvars can't be solved by unification. So the question becomes: should the holes in a structure be fillable by unification? To demonstrate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span> <span class=\"c1\">-- fail</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">}</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">?..</span> <span class=\"o\">}</span> <span class=\"c1\">-- fail?</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">}</span> <span class=\"c1\">-- fail?</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">?..</span> <span class=\"o\">}</span> <span class=\"c1\">-- fail?</span>\n</code></pre></div>\n<p>From this perspective, I think it is clear that we <em>do</em> want the variables in the <code>..</code>/<code>?..</code> to be fillable by unification and not become subgoals, which means that really we should be using <code>..</code> and (named) natural mvars. That means using <code>refine'</code>, but I think this is justifiable because in <code>refine</code> with <code>?a</code> holes the whole point is that you are explicitly labeling the subgoals and can syntactically see how many there are. In the case of <code>?..</code> you can't do that, you know that there is some number of them but that's kind of useless information.</p>\n<p>To summarize, I think we should just make structure instances name the holes corresponding to the natural mvars being generated, similar to what <code>apply</code> does (which BTW uses natural mvars for the same reason - we don't know in advance how many goals there will be and we don't want unification to be blocked from closing off subgoals).</p>",
        "id": 313471335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669977923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span></p>",
        "id": 313471490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669977974
    },
    {
        "content": "<p>Mario, is this orthogonal to the poll, or are they related?</p>",
        "id": 313522298,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1669994465
    },
    {
        "content": "<p>It indirectly suggests the \"<code>..</code> for everything\" option. The poll talks about \"named goals\", but goal naming is unrelated to the use of <code>?_</code> vs <code>_</code> style goals, which is the main argument for using <code>?..</code> \"by analogy\". The argument above is that we want <code>refine_struct</code> instances to produce <code>_</code> goals, not <code>?_</code> goals, in which case it would make more sense to use <code>..</code> to denote them.</p>",
        "id": 313524840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669995117
    },
    {
        "content": "<p>hmm, I disagree, but…for basically the same reasons you’ve given! I think in the case that you <em>do</em> want things solved by unification, you <em>should</em> indeed use blanks, and therefore should use <code>..</code>. but goals that get pushed out by <code>refine</code> to be solved by the user are specifically <em>not</em> the ones given by blanks! so if you want goals that the <em>user</em> should get out of <code>refine</code>, they should be synthetic opaque. If you want something synthesized by unification in the course of a proof, you can always use <code>y := _</code>, and it’s then clear that Lean is taking care of it, not the user.</p>\n<p>I’m not sure whether it makes sense to require <code>refine'</code> every time the user wants to refine a structure. It is true that you can’t see explicitly how many goals you get from <code>?..</code>, only <em>that</em> there are labeled goals, but the goals <em>are</em> being labeled, just like with <code>?a</code> (and unlike <code>_</code>), <em>in the context of using <code>refine</code></em>. making the behavior <code>apply</code>-like would separate the process of refining structures off from the general activity of <code>refine</code>-ing, which, maybe we want, maybe we don’t. I tend to think that given how many structures the ordinary user is often interacting with, it would be good to give them a way of refining them in the ordinary course of a proof without resorting to different techniques.</p>\n<p>so I suppose it’s really a matter of deciding what we consider the important feature of <code>?</code> is in this context, weighed against the relegation the feature of refining structures to <code>refine'</code> and being unable to do it in the course of an ordinary use of <code>refine</code>.</p>",
        "id": 313570380,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670008183
    },
    {
        "content": "<p>(Aside: perhaps unexpectedly...in the current implementation... <code>example : Foo x := { eq := rfl, ?.. }</code> succeeds <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span> I'm not sure when the unification actually occurs here, since I do think this is unexpected behavior, and your expectation that it should leave a goal <code>?y</code> is correct. Let me look at the code.)</p>",
        "id": 313571772,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670008637
    },
    {
        "content": "<blockquote>\n<p>only that there are labeled goals, but the goals are being labeled, just like with ?a (and unlike _), in the context of using refine.</p>\n</blockquote>\n<p>Again, labeling goals is completely independent of the synthetic opaque thing</p>",
        "id": 313572331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670008812
    },
    {
        "content": "<p><code>refine'</code> is for when you aren't being precise about the subgoals being generated by a term, just \"anything that hasn't been solved yet\", and that's also what this <code>..</code> is doing</p>",
        "id": 313572463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670008874
    },
    {
        "content": "<p>if you use synthetic opaques when you shouldn't you will get very confusing error messages like \"can't unify <code>37 : Nat</code> with <code>?m.1234 : Nat</code>\" which make no sense</p>",
        "id": 313572683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670008949
    },
    {
        "content": "<blockquote>\n<p>and being unable to do it in the course of an ordinary use of refine.</p>\n</blockquote>\n<p>You can use <code>refine</code> to refine a structure, you just have to say all the fields you are going to refine and give them names (or not, and let them pick up the default names).</p>",
        "id": 313573147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670009136
    },
    {
        "content": "<blockquote>\n<p>Again, labeling goals is completely independent of the synthetic opaque thing</p>\n</blockquote>\n<p>Internally, yes, but I'd argue that \"whether goals are labeled\" is an important feature of how a user <em>thinks</em> about the difference between using <code>refine</code> and <code>refine'</code> (if they even are familiar with <code>refine'</code>), since (afaik) named natural metavariables cannot be created by the user via syntax. Here, <code>?..</code> is something that the user is intentionally creating, not simply a way to hope lean figures it out and then deal with what's left, so to speak. (up to defaults, of course, but imo that's more a question of how high-priority we perceive <code>?..</code> to be when it fills in fields with goals.) That's the perspective I'm viewing this from.</p>\n<blockquote>\n<p>You can use refine to refine a structure, you just have to say all the fields you are going to refine and give them names (or not, and let them pick up the default names).</p>\n</blockquote>\n<p>Yes, but you could do that anyway :) Ultimately, the whole point of this is making proofs easier to write, isn't it?</p>",
        "id": 313574402,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670009610
    },
    {
        "content": "<p>If using <code>?..</code> causes partial definitions to fail, that's not very nice since that's the whole point of the tactic. We certainly wouldn't be able to roll it out as a replacement for <code>refine_struct</code></p>",
        "id": 313574863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670009772
    },
    {
        "content": "<p>FYI, <code>refine'</code> is not a deprecated tactic, although the name leaves something to be desired. Besides backward compatibility, it is useful for automation-heavy proofs that just want to discharge all the subgoals by similar methods. The majority of <code>refine_struct</code> uses are in proofs of this form - note that it is extremely common to have <code>refine_struct</code> followed by <code>&lt;;&gt;</code> instead of an enumeration of cases</p>",
        "id": 313575379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670009981
    },
    {
        "content": "<p>Just to make sure I'm on the same page, which partial definitions failing are you talking about? Ones where a field could be synthesized by unification, but isn't?</p>",
        "id": 313579195,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670011390
    },
    {
        "content": "<p>stuff like this one from above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">?..</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 313579367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670011446
    },
    {
        "content": "<p>If I provided no fields at all, I would have gotten two goals. If I provide the <code>eq</code> field then I don't get one goal, I get a type error</p>",
        "id": 313579501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670011502
    },
    {
        "content": "<p>not nice</p>",
        "id": 313579508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670011504
    },
    {
        "content": "<p>It's even more weird when <code>eq</code> has an auto param which fills in the <code>rfl</code></p>",
        "id": 313579807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670011595
    },
    {
        "content": "<p>Ah, yes. It should never give a type error in that case.</p>",
        "id": 313579853,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670011614
    },
    {
        "content": "<p>but you need to use natural mvars to get that behavior</p>",
        "id": 313579935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670011649
    },
    {
        "content": "<p>Well...currently it doesn't give an error, but does fill it in as <code>x</code> unexpectedly <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> This might be because internally, it starts with natural metavariables, then assigns them later—investigating rn. In any case it's a great test case! :)</p>",
        "id": 313580332,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670011795
    },
    {
        "content": "<p>btw in Lean 3 this error happens in this case. (did I transcribe this correctly? note that I added an extra field in an attempt to have there be a goal, since I'm not sure why this error happens.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">}</span>\n<span class=\"c1\">-- match failed state: no goals</span>\n</code></pre></div>",
        "id": 313581460,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670012246
    },
    {
        "content": "<p>assign them later you say? then I'm sure you will also enjoy this test case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"n\">foo</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">?..</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">?..</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 313581487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670012267
    },
    {
        "content": "<p>Ooo, interesting! Yes, that behaves incorrectly, I believe—it gives a single case <code>y</code>. What does <code>opaque</code> do?</p>",
        "id": 313582272,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670012591
    },
    {
        "content": "<p>it's supposed to give a single case</p>",
        "id": 313582317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670012612
    },
    {
        "content": "<p>ah! great then! lol</p>",
        "id": 313582344,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670012623
    },
    {
        "content": "<p>but that's also what happens if you use <code>..</code></p>",
        "id": 313582386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670012640
    },
    {
        "content": "<p><code>opaque</code> is just a definition that you can't unfold</p>",
        "id": 313582455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670012655
    },
    {
        "content": "<p>if it was defined to be <code>trivial</code> then lean would just unfold it instead of forcing the structs to match</p>",
        "id": 313582595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670012702
    },
    {
        "content": "<p>Aaanyway, this is not going in a productive direction. We're trying to replace <code>refine_struct</code> here, and AFAICT that means fixing structure instances to name the goals and nothing more. I don't want to get in extensive discussions about alternative tactics that are implemented prior to having any demand or examples of real world use. Mixing these two things is blocking us from being able to check this one off the list.</p>",
        "id": 313583322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670012982
    },
    {
        "content": "<p>Hmm, I see what I'm doing as just a translation of <code>refine_struct</code> from Lean 3 notation to Lean 4 notation, instead of being an implementation of alternative tactics and the like. Not sure what you mean about it not going in a productive direction—haven't we showed that my current implementation at least doesn't fail in the ways you're expecting it to?</p>",
        "id": 313585498,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670013809
    },
    {
        "content": "<p>Btw, I sort of figured out the reason <code>?..</code> doesn't create a goal in the <code>eq := rfl</code> case. It's because of how something like <code>rfl</code> affects <em>any</em> omitted field, and occurs before the default synthesis loop even starts, and therefore before fields are even checked for whether or not they're missing (which happens at the end of the loop). Check this out, which works fine in lean 4 even though <code>y</code> is omitted and doesn't have a default value:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foorfl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foorfl</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 313585505,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670013811
    },
    {
        "content": "<p>So, although it's a bit of a gotcha, <code>?..</code> not producing a goal in this case is consistent with it having \"low precedence\" among the ways the structure instance <em>itself</em> would synthesize values, because <code>?..</code> makes goals out of any fields the structure instance considers to be <em>missing</em> when it's all finished (and since no \"fields missing\" error happens in the above, we wouldn't expect any goals to arise when inserting <code>?..</code>).</p>",
        "id": 313587379,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670014497
    },
    {
        "content": "<p>Here's something else worth noting about lean's existing behavior: for the same reasons, it prefers unification pre-default synthesis to default values. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foorfld</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foorfld</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 313587708,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670014622
    },
    {
        "content": "<p>Ok, I finally checked, and there's a more serious problem to just using <code>..</code>: as I was worried about, having it synthesize defaults breaks patterns. I think the code that we were looking at <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  in <code>PatternVar.lean</code> was only for collecting variable names—but the syntax on the lhs of a pattern case is then still elaborated as usual before being matched. I think this happens e.g. <a href=\"https://github.com/leanprover/lean4/blob/e16880607800ed68a6e2c2a2aebf60d1b75227c9/src/Lean/Elab/Match.lean#L339\">here</a>.</p>\n<p>I minimally changed a fresh copy of <code>StructInst.lean</code> so that <code>..</code> synthesized defaults instead of inserting a syntactic hole. This means marking the field as default, then returning from the default loop instead of reporting fields missing and throwing an error—each field value starts out as a natural metavariable, so this just leaves any that didn't get assigned to a default value as such. You can see it/try it out as <a href=\"https://github.com/leanprover/lean4/compare/master...thorimur:lean4:master\">the only commit on the master branch of my lean4 fork that's ahead of master</a>.</p>\n<p>Anyway, this builds, but upon linking the new toolchains etc., the following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"o\">}</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">{</span> <span class=\"bp\">..</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">_</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">test</span> <span class=\"c1\">-- false</span>\n</code></pre></div>\n<p>(You can see by how it doesn't count this as redundant that something is up, but <code>test</code> confirms that it's behaving how we think it does.)</p>\n<p>So...do we stick with <code>..</code> and just don't synthesize defaults, or use new syntax (whether <code>?..</code> or something else)?</p>",
        "id": 313607603,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670023775
    },
    {
        "content": "<p>You can just check <code>inPattern</code> and not synthesize defaults in patterns</p>",
        "id": 313607774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670023827
    },
    {
        "content": "<p>From within <code>StructInst.lean</code>? Oh, ok...</p>",
        "id": 313607860,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670023881
    },
    {
        "content": "<p>Ok, let's get this bike shedded! :) Last call for <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/313385470\">the poll on <code>?..</code>/<code>..</code> syntax</a>. (Deadline of, say...tomorrowish?) Voting for the \"either's fine\" option is also useful so that we can see that people have seen it!</p>\n<p>Brief list of things to consider:</p>\n<p>In favor of <code>?..</code>:</p>\n<ul>\n<li>legibility for the average user: currently <code>?</code> is present after <code>refine</code> in lean 4 iff a goal is created, e.g. <code>?x</code>, and <code>?..</code> preserves this fact, hopefully making the fact that it creates goals more legible. (otherwise <code>..</code> is the only \"unmarked\" source of goals in <code>refine</code>) (whether it accomplishes this is up for debate though!) (<a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/307835631\">this message</a> is a...<em>slightly</em> longer version of my case for it!)<ul>\n<li>flipside of this: keeps the usage of <code>..</code> consistent (it's not being used for multiple things)</li>\n</ul>\n</li>\n<li>the implementation for this is already figured out in mathlib, doesn't require me to rewrite (BIG caveat: not in core yet, because I don't know anything about wrangling stage0. I'm assured it could be figured out but ofc would take bandwidth)</li>\n<li>allows goals to be synthetic opaque in <code>refine</code> as goals usually are in that context—not sure if we want this, see above (after poll) for discussion</li>\n</ul>\n<p>(note: if you were at the meeting, voting for <code>?..</code> doesn't necessarily entail <em>also</em> including extra things like <code>?..!</code> etc., which were just placeholders to show possible functionality! <code>?..</code> could be the only new syntax introduced.)</p>\n<p>In favor of just <code>..</code>:</p>\n<ul>\n<li>doesn't require change to existing syntax (easier for me alone to incorporate into core, doesn't take up bandwidth)</li>\n<li>doesn't add more symbols/sigils (staves off ASCII soup in all forms)</li>\n<li>if goals are natural, then the syntax is consistent (caveat: this would mean people would have to use <code>refine'</code> instead of <code>refine</code> to access the functionality of <code>refine_struct</code>)</li>\n</ul>",
        "id": 313609901,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670025065
    },
    {
        "content": "<p>I voted for <code>..</code>, mostly just on the basis of avoiding ASCII art. :-) I do like the <code>?</code>-iff-new-goals point, and the saving-you-work point, in favour of <code>?..</code>!</p>",
        "id": 313610534,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670025489
    },
    {
        "content": "<p>Just to see how difficult it would be, I'm extending that toy example above to get the \"just <code>..</code>\" version working in core so we have both options. (spoiler: maybe not that difficult! Looks like I can use the same process and just guard things with a <code>(← read).inPattern</code> check, because my original changes were pretty minimally invasive to begin with.)</p>",
        "id": 313625064,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670036020
    },
    {
        "content": "<p>Independently, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , where did we land re: synthetic opaque v. natural? is there still any reason to be concerned about synthetic opaque goals preventing unification? Every potentially problematic case that's been mentioned so far hasn't actually wound up being  problematic, right? (I haven't seen the type error we're looking to avoid ever happen so far, but maybe we just haven't found the right test case?) (also, looks like <code>refine'</code> plays nice with synthetic opaque goals too, so it doesn't break any existing use of <code>refine'</code> in lean 4).</p>\n<p>If possible I'd love to be able to offer people the ability to use <code>refine</code> instead of <code>refine'</code> to easily refine structures (might also be worth adding to the <code>refine</code> docstring?), so I'm a little reluctant to force the goals to be natural...!</p>",
        "id": 313625425,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670036359
    },
    {
        "content": "<p>As I said a while ago, I don't have the energy to continue this conversation. Please set this aside for now or find someone else to discuss this with.</p>",
        "id": 313626147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670037048
    },
    {
        "content": "<p>No problem, understandable! :)</p>\n<p>For anyone else reading, this isn’t the syntax discussion—this is the orthogonal question of whether the goals created (in either case) should be synthetic opaque or natural.</p>\n<p>It was suggested earlier in this thread (<a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/313471335\">here</a> and then the discussion really starts <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/313574863\">here</a>) that there would be actual problems (e.g. unsavory type errors) if the metavariables produced were synthetic opaque, but so far the examples given didn’t wind up producing the errors they were expected to.</p>\n<p>However, I’m wondering if there are other cases which <em>do</em> produce the problems mentioned, since it seemed plausible. So this is an open request for test cases which might break because of synthetic opaqueness (or an explanation if I’m mistaken and the given examples already behave incorrectly).</p>",
        "id": 313627198,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670038137
    },
    {
        "content": "<p>My suggestion: implement whatever thing keeps feature parity with Lean 3 to the best of your knowledge. I think there's at least one open PR which needs this on which you can test. If we have to fix things later, so be it. We can also add extra features later if need be.</p>",
        "id": 313628732,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1670039748
    },
    {
        "content": "<p>Sounds good :) I’ll try to find that PR!</p>",
        "id": 313629800,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670040639
    },
    {
        "content": "<p>Alright, I couldn't find that PR to test on (if anyone knows it, feel free to link me to it!)—but it's so easy to change from <code>.syntheticOpaque</code> to <code>.natural</code> that I think this thing finally might be juuuuust about ready for review, and it can be figured out there. (The tests used so far all work fine with <code>.syntheticOpaque</code>.) <em>But:</em></p>",
        "id": 314166393,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670299423
    },
    {
        "content": "<p>There is one thing I wasn't sure how to translate into lean 4 from lean 3—this test:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">pi.has_one</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"bp\">..</span> <span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n<span class=\"k\">#print</span> <span class=\"n\">pi.has_one</span>\n</code></pre></div>\n<p>I'm not totally sure what's going on here, even though it's discussed <a href=\"#narrow/stream/113488-general/topic/Need.20help.20with.20class.20instance.20resolution\">here</a>. (The actual test in lean 3 is written with <code>run_cmd</code> instead of <code>#print</code>, and I'm even less sure of how to translate that.)</p>\n<p>Since there's no <code>HasOne</code> in lean 4 core which makes things work for that <code>1</code>, I'm not sure what I should use, or what might demonstrate the (lack of) unseemly <code>eq.mpr</code>s (or whatever the lean 4 equivalent is).</p>\n<p>My best-attempt translation seemed to be free of them, but it involved writing out <code>have inst : ((x : α) → _root_.HasOne (β x)) := by infer_instance; exact fun x =&gt; (inst x).one</code> in the proof, and I'm not confident that a lack of weird things there implies a lack of weird things in the case where we use something equivalent to <code>fun _ =&gt; 1</code>. What would an equivalent version of this test be?</p>",
        "id": 314166488,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670299505
    },
    {
        "content": "<p><code>has_one</code> is <code>One</code> in lean 4. (Pro-tip: to find out how something is translated if it's not a trivial naming convention change, try grepping for <code>#align has_one</code> in mathlib4.)</p>",
        "id": 314167407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670300214
    },
    {
        "content": "<p>Oh, you mean in core. For tests, you can just provide a suitably stubbed out version of the mathlib typeclass. The file that declares <code>Zero</code> and <code>One</code> is very short</p>",
        "id": 314167456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670300284
    },
    {
        "content": "<p>The purpose of this test is to ensure that <code>refine_struct</code> doesn't introduce anything other than a <a href=\"http://Foo.mk\">Foo.mk</a> application</p>",
        "id": 314167818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670300578
    },
    {
        "content": "<p>it doesn't really matter if the <code>fun _ =&gt; 1</code> is replaced by something else, this is just the simplest example of a struct literal you can write in lean 3</p>",
        "id": 314167852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670300620
    },
    {
        "content": "<p>you can use <code>Inhabited</code> or something else in lean 4</p>",
        "id": 314167861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670300630
    },
    {
        "content": "<p>Ok, thanks! I think I mostly follow, but I'm still not <em>totally</em> sure of what the right way to do this is. Here's my best guess? (Or is <code>Inhabited</code> special, and it really should be a stubbed-out thing?)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">pi.Inhabited</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"bp\">..</span> <span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n<span class=\"k\">#print</span> <span class=\"n\">pi.Inhabited</span>\n</code></pre></div>",
        "id": 314168479,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670301217
    },
    {
        "content": "<p>Well, if that is a good translation, it looks like there is indeed only <code>@Inhabited.mk</code> in the function body. :)</p>",
        "id": 314169087,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670301868
    },
    {
        "content": "<p>I assume there is also <code>default</code>? What does it look like specifically</p>",
        "id": 314169121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670301918
    },
    {
        "content": "<p>yes, sorry, I meant as the head of the expression! here's the full output of the <code>#print</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pi.Inhabited</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Inhabited.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"bp\">→</span> <span class=\"n\">Inhabited.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Inhabited.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">@</span><span class=\"n\">Inhabited.mk.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">@</span><span class=\"n\">Inhabited.default.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 314169248,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670302061
    },
    {
        "content": "<p>yeah, that looks like a success. Just put that in the expected.out file</p>",
        "id": 314169452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670302264
    },
    {
        "content": "<p>The PR mentioned above that wants to use <code>refine_struct</code> has been merged. If you search for <code>refine_struct</code> in mathlib4 you'll find two porting notes, in <code>Mathlib.Order.Basic</code> and in <code>Mathlib.Order.BooleanAlgebra</code>, which show how the proof used to look in mathlib3.</p>",
        "id": 314174049,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1670305565
    },
    {
        "content": "<p>Ah, thank you!</p>",
        "id": 314178451,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670308983
    },
    {
        "content": "<p>I looked at the <code>BooleanAlgebra</code> one, and found something strange:</p>",
        "id": 314178478,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670309003
    },
    {
        "content": "<p>On the nightly (none of my modifications), this happens: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">PUnit.booleanAlgebra</span> <span class=\"o\">:</span> <span class=\"n\">BooleanAlgebra</span> <span class=\"n\">PUnit</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">PUnit.biheytingAlgebra</span> <span class=\"k\">with</span>\n    <span class=\"n\">le_sup_inf</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">x</span>  <span class=\"c1\">-- [error when printing message: unknown goal _uniq.80720]</span>\n    <span class=\"n\">inf_compl_le_bot</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">y</span>\n    <span class=\"n\">top_le_sup_compl</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">z</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 314178594,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670309083
    },
    {
        "content": "<p>(Note that using <code>refine'</code> and <code>_</code> doesn't change this.) It seems to be percolating up from <code>withGoalCtx</code>, but how the metavariable appears, I'm not sure. It's not visible directly in the tactic state.</p>",
        "id": 314179045,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670309409
    },
    {
        "content": "<p>(Should this be moved to a different thread, since it's technically not something to do with my port of <code>refine_struct</code>? Although I suppose it would help to know these kinds of things wouldn't be encountered!)</p>",
        "id": 314179129,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670309497
    },
    {
        "content": "<p>Anyway! It looks like I have things finished for the <code>..</code> version. :)</p>",
        "id": 314185702,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670313383
    },
    {
        "content": "<p>The poll did wind up with <code>?..</code> having a slight edge 4-2(-1), but I imagine the following are relevant:</p>\n<ul>\n<li>my vote for <code>?..</code> probably shouldn't count for much, given my newness</li>\n<li>Jireh (who's one of the 4 votes for <code>?..</code>) also voted for either's fine</li>\n<li><code>..</code> is basically ready for review, whereas <code>?..</code> is only ready up to stage 0 wrangling, which I would need someone to help me with.</li>\n</ul>\n<p>So, given the relative ambivalence, and in the interest of not blocking other things...I guess <code>..</code> syntax it is, at least for now, I suppose? Sound good? :)</p>",
        "id": 314185712,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670313389
    },
    {
        "content": "<p>If so, how does this work? The contribution guidelines say I ought to make a detailed issue on github. (Then that I should wait for one of the core developers to give me a go-ahead, after which they'll work with me to make sure the PR gets merged. I'm guessing there's also...review, at some stage, too? Again, totally new to contributing to a project like this! <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>)</p>\n<p>Should I open that detailed issue on the lean4 repo, or are there any more things to address here on zulip? (Or should something else happen instead?)</p>",
        "id": 314185717,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670313393
    },
    {
        "content": "<p>How would you describe the candidate change to core? Assume that none of the devs have been following along, so you need to give a simple example which does not talk about <code>refine_struct</code>, and demonstrate how the behavior is changed (and why it's a good thing, if the example itself doesn't make that obvious).</p>",
        "id": 314235586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670332875
    },
    {
        "content": "<p>How's this?</p>",
        "id": 314327636,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670361177
    },
    {
        "content": "<p>This is a modification to the structure instance elaborator which causes <code>..</code> in structure instances to create named goals for all omitted fields that cannot be synthesized via default values. This aids in interactive proofs that use <code>refine</code>. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">}</span><span class=\"bp\">;</span> <span class=\"n\">case</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>The goal <code>?y</code> for the field <code>y</code> is created in the course of elaborating the structure instance, enabling one to write <code>case y =&gt; ...</code>.</p>\n<p>Default field values that are autoparams are tried, and, if they fail, are replaced with a named goal.</p>\n<p>The resulting goals are equipped with metadata that enables later tactics to recover information about the field and structure from which they originated (such as the field projections). This enables certain automations.</p>\n<p>Name conflicts among multiple simultaneously-occurring structure instances with overlapping field names are resolved by appending indices to the goals that are unique to each structure instance (e.g. <code>?y</code>, <code>?y_1</code>).</p>\n<p>This modification only applies to structure instance syntax that is encountered outside of a pattern. Inside a pattern, the pre-existing behavior for <code>..</code> is maintained, which simply fills all omitted fields with natural holes at the syntax level.</p>\n<p>Note that existing uses of <code>refine'</code> that use <code>{ .. }</code> are not broken.</p>",
        "id": 314327665,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670361188
    },
    {
        "content": "<p>(I figure I can give more technical details and context, like a link to the zulip discussion, afterwards in the conversation on the issue, right? Or should that be in the main body?)</p>",
        "id": 314328104,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670361377
    },
    {
        "content": "<p>That sounds like 4 features in one. Can they be done separately?</p>",
        "id": 314333430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670363623
    },
    {
        "content": "<p>How much of lean core and/or tests are broken by this? How big is the diff?</p>",
        "id": 314333661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670363722
    },
    {
        "content": "<p>more specifically, I see the following separate features:</p>\n<ul>\n<li><code>..</code> names the generated holes</li>\n<li>autoparams (and opt params?) are tried</li>\n<li>name conflict resolution (is this a requirement for the tactic not to fail?)</li>\n<li>Goals are equipped with metadata (what metadata, how is this encoded?)</li>\n</ul>",
        "id": 314334205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670363941
    },
    {
        "content": "<p>No tests are (newly) broken in core (besides the interactive hover test, because I updated the structure instance docstring :) ).</p>\n<p>Are multiple PRs for small things better? If so there might be some things I'd split—e.g. I update <code>exprToSyntax</code> to take an optional type argument instead of needing to infer the type every time.</p>\n<p>Let me see how large the diff is and if the features can be separated...</p>",
        "id": 314337238,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670365141
    },
    {
        "content": "<p>(Btw, it's just on <a href=\"https://github.com/leanprover/lean4/compare/master...thorimur:lean4:master\">the master branch of my fork</a> if you'd like to look at it)</p>",
        "id": 314337391,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670365201
    },
    {
        "content": "<p>Ok, the diff is large because I added docstrings for all of the functions in <code>StructInst.lean</code> as well as a module doc with an overview of the code and some small things I think should be addressed in review (before review?)</p>",
        "id": 314337595,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670365275
    },
    {
        "content": "<p><strong>name conflicts</strong>: So, I'd personally think of resolving the name conflicts as part of just the task of naming the holes, but I guess I could just name the holes \"badly\" (without conflict resolution) first. It wouldn't be a huge change but it would be a change and take time. Plus this depends on the metadata as written, so it would come after that feature.</p>",
        "id": 314338315,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670365567
    },
    {
        "content": "<p><strong>autoparams</strong>: autoparams being tried can be easily split off, since <code>StructInst.lean</code> takes care of autoparams separately anyway, so it's kind of in its own neck of the woods.</p>",
        "id": 314338461,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670365629
    },
    {
        "content": "<p>However, optparams are handled in the default loop, and I don't even touch that process (I intervene afterwards. Even in the mathlib implementation that let you turn off default synthesis, I just guarded the default loop by an appropriate check). Defaults will get synthesized by themselves anyway.</p>",
        "id": 314338706,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670365741
    },
    {
        "content": "<p><strong>name conflicts again</strong>: Oh, wait, re: name conflict: I don't think it's a requirement not to fail. I use a <code>userName</code> argument to a <code>mkFreshExprMVar</code> call, not syntax—does that ensure different mvar ids are created?</p>",
        "id": 314339018,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670365842
    },
    {
        "content": "<p><strong>Metadata</strong>: The metadata implementation is the thing I'm least confident in proposing, tbh. it puts <code>KVMap</code> <code>mdata</code> on the type expression of each metavariable. I worry that that's not robust, and I don't know how local instances work, but I notice that each metavariable has a field for them, and I wonder if they would be more robust...</p>",
        "id": 314339500,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670366029
    },
    {
        "content": "<p>In any case, they currently store a boolean check that this hole did come from <code>..</code> syntax, the original syntax ref of the structure instance, the structure name, the field name, and the index (for name conflict resolution). (The mathlib implementation also stored the user-specified name used to prefix the goals if one was provided.)</p>",
        "id": 314339932,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670366190
    },
    {
        "content": "<p>Not sure if metadata is attached at a premium and less metadata = better. If so I could remove the boolean check (and check another way) and the syntax ref.</p>",
        "id": 314340199,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670366284
    },
    {
        "content": "<p><strong>dsimp</strong>: If all details should be in the issue body (and not in subsequent messages that I'd send), there's technically another feature here: it <code>dsimp</code>s the types of the named goals. This is to maintain parity with <code>refine_struct</code>. Otherwise, goals like <code>{ a := 1 }.a = { a := 1 }.a</code> might be produced (instead of <code>1 = 1</code>). <code>dsimp</code> is how <code>refine_struct</code> solves this problem, so I figured that's what I ought to do—however, it does require importing <code>Lean.Meta.Tactic.Simp.Main</code>, and I'm not sure if this is frowned upon. There might be more surgical ways to approach this.</p>\n<p>(Note: it only actually <em>uses</em> <code>dsimp</code> when creating the types of the metavariables created by <code>..</code> in this case. It doesn't <code>dsimp</code> anything else.)</p>",
        "id": 314340772,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670366551
    },
    {
        "content": "<p>Ok, that's it! (Also, wait, were you asking these questions now in this thread, or were you implying that I ought to answer them in the issue body (or both)? I assumed the former)</p>",
        "id": 314341400,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670366835
    },
    {
        "content": "<p>(In any case, <em>all</em> of these features are required to maintain parity with the unstated motivation of absorbing the functionality of <code>refine_struct</code>.)</p>",
        "id": 314341586,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670366904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314337595\">said</a>:</p>\n<blockquote>\n<p>Ok, the diff is large because I added docstrings for all of the functions in <code>StructInst.lean</code></p>\n</blockquote>\n<p>That is a separate PR</p>\n<blockquote>\n<p>as well as a module doc with an overview of the code and some small things I think should be addressed in review (before review?)</p>\n</blockquote>\n<p>Is this a module doc for StructInst.lean itself or for your PR version? It doesn't make any sense to be the latter, you shouldn't put review comments in the code itself</p>",
        "id": 314348317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670369989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314339018\">said</a>:</p>\n<blockquote>\n<p><strong>name conflicts again</strong>: Oh, wait, re: name conflict: I don't think it's a requirement not to fail. I use a <code>userName</code> argument to a <code>mkFreshExprMVar</code> call, not syntax—does that ensure different mvar ids are created? EDIT: just checked, it still produces multiple cases even if they're all named <code>foo</code>. However, addressing these cases individually with <code>case</code> is, of course, a bit difficult, which is part of the point of naming goals...so I'm not sure whether to split it off.</p>\n</blockquote>\n<p>The point here is to make all the pieces as small and easy to review as possible. One giant PR has a large chance of just being rejected and not really looked at.</p>",
        "id": 314348719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670370208
    },
    {
        "content": "<p>I see! Ok, I can definitely try to make that the case. :)</p>",
        "id": 314348943,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670370339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314339932\">said</a>:</p>\n<blockquote>\n<p>In any case, they currently store a boolean check that this hole did come from <code>..</code> syntax, the original syntax ref of the structure instance, the structure name, the field name, and the index (for name conflict resolution). (The mathlib implementation also stored the user-specified name used to prefix the goals if one was provided.)</p>\n</blockquote>\n<p>That does indeed sound quite excessive. Everything in the expr can potentially get serialized into oleans, so unless there is a strong guarantee that it will not persist past elaboration I would try to keep annotations light</p>",
        "id": 314348947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670370343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314340772\">said</a>:</p>\n<blockquote>\n<p><strong>dsimp</strong>: If all details should be in the issue body (and not in subsequent messages that I'd send), there's technically another feature here: it <code>dsimp</code>s the types of the named goals. This is to maintain parity with <code>refine_struct</code>. Otherwise, goals like <code>{ a := 1 }.a = { a := 1 }.a</code> might be produced (instead of <code>1 = 1</code>). <code>dsimp</code> is how <code>refine_struct</code> solves this problem, so I figured that's what I ought to do—however, it does require importing <code>Lean.Meta.Tactic.Simp.Main</code>, and I'm not sure if this is frowned upon. There might be more surgical ways to approach this.</p>\n</blockquote>\n<p>This requires a redesign. You should probably just bring it up as an issue, perhaps suggesting the dsimp approach, and let the devs come up with their own solution.</p>",
        "id": 314349164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670370443
    },
    {
        "content": "<blockquote>\n<p>Is this a module doc for StructInst.lean itself or for your PR version? It doesn't make any sense to be the latter, you shouldn't put review comments in the code itself</p>\n</blockquote>\n<p>It's a module doc that essentially explains how the code in the file works (it doesn't privilege explaining my additions or refer to them as additions). Not sure if that's something people want to be there. Then there's a separate little section I use for review question, which I expect to be removed before it was merged/PR'd—I was just using that section as a place to put them.</p>",
        "id": 314349644,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670370669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/.5BRFC.5D.20refine_struct.20functionality.20via.20new.20.3F.2E.2E.20syntax/near/314337238\">said</a>:</p>\n<blockquote>\n<p>Are multiple PRs for small things better? If so there might be some things I'd split—e.g. I update <code>exprToSyntax</code> to take an optional type argument instead of needing to infer the type every time.</p>\n</blockquote>\n<p>For your first PR, definitely you should start small. You should build your credibility before going for any major changes.</p>",
        "id": 314349699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670370705
    },
    {
        "content": "<p>Ok, sounds great. Thanks so much for explaining all this to me. :)</p>",
        "id": 314349810,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670370735
    },
    {
        "content": "<p>The docs PR sounds like a good place to start, the devs are always very welcoming to those</p>",
        "id": 314349901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670370795
    },
    {
        "content": "<p>Ok, great! So for the specifics of how to do this, do I, say:</p>\n<ul>\n<li>open an issue</li>\n<li>wait for a core dev to approve of it in the abstract</li>\n<li>then make the PR (etc.)?<br>\nor do I make the PR along with the issue? Just a little unsure of the relationship between issues and PR's in this context.</li>\n</ul>",
        "id": 314350160,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670370934
    },
    {
        "content": "<p>Oh, and: do these each need separate [RFC] threads here on zulip? I'd hope this one suffices, but I'm happy to make more if it's desired.</p>",
        "id": 314350264,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670370977
    },
    {
        "content": "<p>I think this thread has suffered from a signal to noise issue, there is too much stuff for a busy person to read through. Summarize!</p>",
        "id": 314350422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670371070
    },
    {
        "content": "<p>By the way (looking at your master branch), I don't think it's necessary to even mention that the goals are named in the doc comment on structure instances. The first bullet point about <code>..</code> seems sufficient, although it should indicate that it's not a pattern-exclusive syntax (by contrast to rust, for example, from which we got the syntax) but works in <code>refine</code> too.</p>",
        "id": 314350818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670371237
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">eType</span> <span class=\"o\">:=</span> <span class=\"n\">type.getD</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>this will not do what you want</p>",
        "id": 314351174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670371386
    },
    {
        "content": "<p>ah, ok. why not?</p>",
        "id": 314351230,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670371429
    },
    {
        "content": "<p>it macro expands to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span>\n<span class=\"k\">let</span> <span class=\"n\">eType</span> <span class=\"o\">:=</span> <span class=\"n\">type.getD</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 314352776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670372170
    },
    {
        "content": "<p>I thought <code>getD</code> being <code>@[macro_inline]</code> meant it only evaluated <code>(← inferType e)</code> if <code>type</code> is <code>none</code>? Does that guarantee not apply in monadic code?</p>",
        "id": 314353456,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670372415
    },
    {
        "content": "<p>ah, my nemesis...the inability to lift <code>&lt;-</code> across a binder</p>",
        "id": 314353957,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670372589
    },
    {
        "content": "<p>better?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">eType</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">type</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">t</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span>\n</code></pre></div>",
        "id": 314354227,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670372706
    },
    {
        "content": "<p><code>@[macro_inline]</code> isn't literally a macro, it operates at an early phase of the compiler, not during elaboration / macro expansion</p>",
        "id": 314354770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670372909
    },
    {
        "content": "<p><code>do</code> notation is a macro however, so it runs first and does the aforementioned transformation</p>",
        "id": 314354815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670372936
    },
    {
        "content": "<p>ah, makes sense that <code>do</code> would expand first then!</p>",
        "id": 314354822,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670372939
    },
    {
        "content": "<p>not to mention that you couldn't do <code>getD</code> first anyway, it wouldn't be type correct</p>",
        "id": 314354866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670372965
    },
    {
        "content": "<p>note that  you had to insert a <code>pure</code> that isn't present in the definition of <code>getD</code> to write the replacement code</p>",
        "id": 314354894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670372985
    },
    {
        "content": "<p>(or, golfed: <code>let eType ← (type.map pure).getD (inferType e)</code>. but the former is more readable...)</p>",
        "id": 314354900,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670372989
    },
    {
        "content": "<p>Right, makes sense! This is my first outing with monads—still getting used to some aspects of them. :)</p>",
        "id": 314355063,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670373031
    },
    {
        "content": "<p>we could have a <code>getDM</code> however which builds this laziness into the type signature</p>",
        "id": 314355161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670373079
    },
    {
        "content": "<p>Let me see if I can write that as an exercise!</p>",
        "id": 314355216,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670373112
    },
    {
        "content": "<p>Ok, I think this works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[macro_inline]</span> <span class=\"kd\">def</span> <span class=\"n\">Option.getDM</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span>   <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n</code></pre></div>",
        "id": 314356031,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670373568
    },
    {
        "content": "<p>Anyway! Got a bit sidetracked there. So. Are these next steps for me correct?</p>\n<ol>\n<li>make a zulip thread for each individual PR I plan to offer, starting with docstrings for structInst, then maybe a couple smaller PR's, then the rest</li>\n<li>at the same time, make an RFC github issue on the lean4 repo for the first feature (and link to the appropriate zulip thread)</li>\n<li>after a core dev says to, make a PR</li>\n<li>repeat steps 2 and 3 with the remaining features</li>\n</ol>",
        "id": 314357505,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670374514
    },
    {
        "content": "<p>I think (1) is already done. For the smaller things you don't need (2) either and can skip to step (3). For the main feature I think an RFC issue on lean 4 repo is appropriate. You aren't likely to get more attention from core devs by posting here unless you ping them directly (and you shouldn't do that unless you have trimmed down the required reading to a manageable level).</p>",
        "id": 314363626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670378576
    },
    {
        "content": "<p>Ok, I'll just directly make a PR to lean4 adding the docstrings in <code>StructInst.lean</code> then! :)</p>",
        "id": 314367103,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670381168
    },
    {
        "content": "<p>Hmm. I made the docs pull request, but it didn't pass all tests. Strangely, the only one it didn't pass was something completely unrelated to structures (<code>calcInType</code>), and in only the Linux release:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"mi\">826</span><span class=\"bp\">/</span><span class=\"mi\">1645</span> <span class=\"n\">Test</span>  <span class=\"bp\">#</span><span class=\"mi\">827</span><span class=\"o\">:</span> <span class=\"n\">leanruntest_calcInType.lean</span> <span class=\"bp\">...............................***</span><span class=\"n\">Failed</span>    <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">36</span> <span class=\"n\">sec</span>\n<span class=\"bp\">../../</span><span class=\"n\">common.sh</span><span class=\"o\">:</span> <span class=\"n\">line</span> <span class=\"mi\">28</span><span class=\"o\">:</span> <span class=\"mi\">37016</span> <span class=\"n\">Segmentation</span> <span class=\"n\">fault</span>      <span class=\"o\">(</span><span class=\"n\">core</span> <span class=\"n\">dumped</span><span class=\"o\">)</span> <span class=\"n\">LEAN_BACKTRACE</span><span class=\"bp\">=</span><span class=\"mi\">0</span> <span class=\"s2\">\"$@\"</span> <span class=\"mi\">2</span><span class=\"bp\">&gt;&amp;</span><span class=\"mi\">1</span>\n     <span class=\"mi\">37017</span> <span class=\"n\">Done</span>                    <span class=\"bp\">|</span> <span class=\"n\">perl</span> <span class=\"bp\">-</span><span class=\"n\">pe</span> <span class=\"bp\">'</span><span class=\"n\">s</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"bp\">\\?</span><span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"n\">w</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"bp\">\\</span><span class=\"n\">w</span><span class=\"bp\">+</span><span class=\"o\">))</span><span class=\"bp\">\\.</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">-</span><span class=\"mi\">9</span><span class=\"o\">]</span><span class=\"bp\">+/\\</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">g'</span> <span class=\"bp\">&gt;</span> <span class=\"s2\">\"$f.produced.out\"</span>\n<span class=\"n\">Unexpected</span> <span class=\"n\">return</span> <span class=\"n\">code</span> <span class=\"mi\">139</span> <span class=\"n\">executing</span> <span class=\"bp\">'</span><span class=\"n\">lean</span> <span class=\"bp\">-</span><span class=\"n\">j</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span><span class=\"n\">Dlinter.all</span><span class=\"bp\">=</span><span class=\"n\">false</span> <span class=\"n\">calcInType.lean'</span><span class=\"bp\">;</span> <span class=\"n\">expected</span> <span class=\"mi\">0</span><span class=\"bp\">.</span> <span class=\"n\">Output</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>Is this something I should be worried about? It produces an X next to the pull request, saying that it's unable to be merged. (My fork is up to date with master, and other PR's are passing all checks.)</p>",
        "id": 314749335,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670526165
    },
    {
        "content": "<p>This is a recent issue caused by an update to the github runners that is currently causing random segfaults on linux. It is not related to your PR and hopefully it will be fixed soon if it isn't already</p>",
        "id": 314772104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1670533723
    },
    {
        "content": "<p>Great! As expected, then, I added a commit, and it happened to pass the checks :)</p>",
        "id": 314774098,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1670534477
    }
]
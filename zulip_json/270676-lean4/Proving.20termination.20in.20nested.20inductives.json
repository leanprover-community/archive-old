[
    {
        "content": "<p>I'm working on taking inspiration from some Coq code and implementing something similar in Lean. And I hit some trouble proving termination for something that coq seems to have no trouble at all.  </p>\n<p>The context is, that I've got an n-ary tree to work with. Here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">nelist</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nelist</span> <span class=\"n\">A</span>\n<span class=\"o\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nelist</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nelist</span> <span class=\"n\">A</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Section</span> <span class=\"n\">f</span><span class=\"o\">.</span>\n<span class=\"kn\">Variable</span> <span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">.</span>\n<span class=\"kn\">Variable</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">.</span>\n<span class=\"kn\">Variable</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">.</span>\n<span class=\"kn\">Variable</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">-&gt;</span> <span class=\"n\">B</span> <span class=\"o\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">.</span>\n<span class=\"kn\">Fixpoint</span> <span class=\"n\">foldMap</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">nelist</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"n\">nil</span> <span class=\"o\">_</span> <span class=\"n\">x</span> <span class=\"o\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n    <span class=\"o\">|</span> <span class=\"n\">cons</span> <span class=\"o\">_</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"o\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">foldMap</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"k\">end</span><span class=\"o\">.</span>\n<span class=\"kn\">End</span> <span class=\"n\">f</span><span class=\"o\">.</span>\n\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">tree</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">nelist</span> <span class=\"n\">tree</span> <span class=\"o\">-&gt;</span> <span class=\"n\">tree</span>\n  <span class=\"o\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">tree</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Fixpoint</span> <span class=\"n\">count</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">tree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"n\">node</span> <span class=\"n\">xs</span> <span class=\"o\">=&gt;</span> <span class=\"n\">foldMap</span> <span class=\"o\">_</span> <span class=\"o\">_</span> <span class=\"n\">count</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">xs</span>\n    <span class=\"o\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"k\">end</span><span class=\"o\">.</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">nelist</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">nelist</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">nelist</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">nelist</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foldMap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nelist</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">nelist.nil</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">nelist.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">foldMap</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">tree</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">nelist</span> <span class=\"n\">tree</span> <span class=\"bp\">→</span> <span class=\"n\">tree</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">tree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">count</span> <span class=\"o\">:</span> <span class=\"n\">tree</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">tree.node</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foldMap</span> <span class=\"n\">count</span> <span class=\"n\">Nat.add</span> <span class=\"n\">xs</span>\n<span class=\"bp\">|</span> <span class=\"n\">tree.leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>and when I try using well-founded recursion I just get an <code>unexpected occurrence of recursive application</code>.</p>\n<p>Any idea how to prove these nicely?</p>",
        "id": 271587751,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1644591372
    },
    {
        "content": "<p>The generic solution is to equip <code>foldMap</code>'s fold function with a proof that the passed element is part of the given list, from which you can derive that its <code>sizeOf</code> size is smaller. The simpler solution is to specialize <code>foldMap</code> to <code>count</code>, yielding mutually recursive definitions. I pushed an example of the latter a few days ago <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/mut_ind_wf.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/mut_ind_wf.lean</a></p>",
        "id": 271590224,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1644592428
    },
    {
        "content": "<blockquote>\n<p>And I hit some trouble proving termination for something that coq seems to have no trouble at all.</p>\n</blockquote>\n<p>Recall that Lean does not have a termination checker in the kernel. <br>\nIn Lean, we have to justifiy the termination using structural or well founded recursion.<br>\nThis kind of example is quite verbose right now because of missing features:</p>\n<ul>\n<li><code>lineararith</code> is missing</li>\n<li>Heuristics for guessing good well founded relations is missing</li>\n<li>Better support for combinators such as map and fold is missing.</li>\n</ul>",
        "id": 271591082,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1644592801
    },
    {
        "content": "<p>yeah I see that: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">assumption'</span> <span class=\"n\">failed</span><span class=\"o\">,</span>\n<span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nelist</span> <span class=\"n\">tree</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">sizeOf</span> <span class=\"n\">xs</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">xs</span>\n</code></pre></div>",
        "id": 271591955,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1644593158
    },
    {
        "content": "<p>in fact all of the proofs would go away with a bit of linear arithmetic.</p>",
        "id": 271592042,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1644593187
    },
    {
        "content": "<p>We are working on that as we described in our last dev meeting that included you  <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 271592260,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1644593299
    },
    {
        "content": "<p>I know, I know. ;-) I'm working on the other feature and am kinda forced to prove termination. FWIW, the <code>termination_by</code> experience doesn't even compare to Lean 3 in how convenient and much less confusing it is.</p>",
        "id": 271592561,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1644593443
    },
    {
        "content": "<p>working on this I found something I don't understand. It looks  like a bug to me, but maybe I'm misusing it somehow.</p>\n<p>The general idea is to define a definitional reduction to reify objects. And <code>rfl</code> need help in a way that makes absolutely no sense to me. calling <code>#reduce</code> behaves as I'd hope, but <code>rfl</code> needs what looks to me like an unnecessary <code>simp</code> step just to unfold the definition. I even tried marking the <code>def</code> as <code>@[reducible]</code>, but I don't think it should be needed to begin with.</p>\n<p>Here's the most hatchety job I could do, deleting most of the code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">arrow</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">arrow</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Symbol</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">arity</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">arrow</span> <span class=\"n\">α</span> <span class=\"n\">arity</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NonEmptyList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">NonEmptyList</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"![\"</span> <span class=\"n\">term</span> <span class=\"s2\">\", \"</span> <span class=\"n\">sepBy</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"o\">,</span> <span class=\"s2\">\", \"</span><span class=\"o\">)</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"![\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NonEmptyList.ofList</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">NonEmptyList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">NonEmptyList.nil</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">NonEmptyList.cons</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">ofList</span> <span class=\"n\">b</span> <span class=\"n\">bs</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">elem</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">NonEmptyList.ofList</span> <span class=\"bp\">$</span><span class=\"n\">elem</span> <span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">elems</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">elem</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">NonEmptyList.nil</span> <span class=\"bp\">$</span><span class=\"n\">elem</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"s2\">\" !:: \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">NonEmptyList.cons</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NonEmptyList.get</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">NonEmptyList</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">],</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">!</span><span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">as.get</span><span class=\"bp\">!</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">!</span><span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Context</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">symbols</span> <span class=\"o\">:</span> <span class=\"n\">NonEmptyList</span> <span class=\"bp\">$</span> <span class=\"n\">Symbol</span> <span class=\"n\">α</span>\n  <span class=\"n\">arbitrary</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Expr</span>\n<span class=\"bp\">|</span> <span class=\"n\">Sym</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ctx</span> <span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">Expr.Sym</span> <span class=\"n\">idx</span> <span class=\"n\">args</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"n\">ctx.symbols.get</span><span class=\"bp\">!</span> <span class=\"n\">idx</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">args</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">idx</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">args</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_succ_of_le</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Nat.le_add_left</span>\n  <span class=\"n\">reduceSym</span> <span class=\"n\">sym</span> <span class=\"n\">args</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">reduceSym</span> <span class=\"o\">:</span> <span class=\"n\">Symbol</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_succ_of_le</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.le_add_right</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">as</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_succ_of_le</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.le_add_left</span>\n    <span class=\"n\">reduceSym</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">ctx</span> <span class=\"n\">a</span><span class=\"o\">)⟩</span> <span class=\"n\">as</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ctx.arbitrary</span>\n\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">eval</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">e</span>\n  <span class=\"n\">reduceSym</span> <span class=\"n\">_</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">xs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myCtx</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">symbols</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span>\n    <span class=\"o\">{</span> <span class=\"n\">arity</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">arity</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">arity</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n    <span class=\"o\">]</span>\n  <span class=\"n\">arbitrary</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">myCtx</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Expr.Sym</span> <span class=\"mi\">0</span> <span class=\"o\">[])</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--simp [myCtx]</span>\n  <span class=\"c1\">--simp [NonEmptyList.get!]</span>\n  <span class=\"c1\">--simp [NonEmptyList.ofList]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eval</span><span class=\"o\">]</span> <span class=\"c1\">-- !!!!!!! commenting this out breaks. The previous simps are just there to prettify the goal</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">myCtx</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symbols.get</span><span class=\"bp\">!</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">constant</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">constant</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">myCtx</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Expr.Sym</span> <span class=\"mi\">0</span> <span class=\"o\">[])</span> <span class=\"c1\">-- !!!!!!! this here happily reduces to x</span>\n</code></pre></div>",
        "id": 271679514,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1644657551
    },
    {
        "content": "<p>Likely the same issue as in <a href=\"#narrow/stream/270676-lean4/topic/mathport.3Awhnf-power\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mathport.3Awhnf-power</a> - the (elaborator) unifier is very conservative about unfolding well-founded recursion</p>",
        "id": 271681170,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1644660211
    },
    {
        "content": "<p>ok... so how can I make progress then? The functions I'm defining are unlikely going to work as pure structural recursion. And if well-founded recursion is not unfolded automatically, how can I produce a proof automatically? The idea is to take variables from a local ctx and pass them into these objects, let lean perform a computation to verify the objects are equal modulo AAC. Then, in the end we can reify the proof into the terms the user wanted.</p>\n<p>In fact, when I tried a <code>simp [eval]</code> on the actual definition it fails, claiming the motive is not type correct.</p>",
        "id": 271681422,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1644660641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"235513\">@Daniel Fabian</span> I am assuming you are trying to \"proof by reflection\", correct?<br>\nIf yes, then you should not use well-found recursion anyway since they are very expensive to reduce in the kernel.<br>\nAnother reason is that, as Sebastian pointed out, the elaborator unifier is conservative about them.</p>\n<blockquote>\n<p>ok... so how can I make progress then? </p>\n</blockquote>\n<p>If the goal is proof by reflection, you can always use structural recursion + Nat fuel argument, and then set the argument with a big enough value.</p>",
        "id": 271691338,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1644676005
    },
    {
        "content": "<p>yes, correct on all accounts. We can basically make a fake structural with enough fuel. Just need to give a upper bound on the steps. I noticed it when looking at the existing sample code. I still do want to use n-ary trees, though. They should make other things easier.</p>",
        "id": 271697195,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1644684323
    }
]
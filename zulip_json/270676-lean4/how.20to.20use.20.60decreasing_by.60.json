[
    {
        "content": "<p>When using <code>decreasing_by</code>, the default tactics seem to get disabled. Is there an idiomatic way to keep it enabled and just specify and finishing tactic? Or is there a way to invoke (part of) the default tactic?</p>",
        "id": 272747104,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1645488787
    },
    {
        "content": "<p>The default tactic has a name, you can just call it</p>",
        "id": 272775059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645520177
    },
    {
        "content": "<p><code>decreasing_tactic</code></p>",
        "id": 272775463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645520407
    },
    {
        "content": "<p>Unfortunately it just fails if the current heuristics are not sufficient, so it's not really possible to \"enhance\" it. But you can always just copy and override it; for example, this one crudely takes care of many inequations generated by \"almost-structural recursion\" while we're waiting for <code>linarith</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_tactic</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n   <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">invImage</span><span class=\"o\">,</span> <span class=\"n\">InvImage</span><span class=\"o\">,</span> <span class=\"n\">Prod.lex</span><span class=\"o\">,</span> <span class=\"n\">sizeOfWFRel</span><span class=\"o\">,</span> <span class=\"n\">measure</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_wfRel</span><span class=\"o\">,</span> <span class=\"n\">WellFoundedRelation.rel</span><span class=\"o\">]</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.left</span><span class=\"o\">)</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.left</span><span class=\"o\">)</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">Nat.succ_add</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_succ</span><span class=\"o\">]</span>\n    <span class=\"n\">try</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_succ_of_le</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.le_step</span>\n    <span class=\"n\">first</span>\n    <span class=\"bp\">|</span> <span class=\"n\">repeat</span> <span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.le_add_left</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.le_add_right_of_le</span>\n    <span class=\"bp\">|</span> <span class=\"n\">assumption</span>\n    <span class=\"n\">all_goals</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.le_refl</span>\n<span class=\"o\">))</span>\n</code></pre></div>",
        "id": 272776524,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1645521036
    },
    {
        "content": "<p>Yeah, I think what you really want for those sizeof bounds is to be able to prove <code>a &lt; b</code> where <code>a</code> and <code>b</code> are sums such that every element of <code>a + 1</code> is in <code>b</code></p>",
        "id": 272776735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645521166
    },
    {
        "content": "<p>Do you think that such a tactic should go in core? I can see how to write it</p>",
        "id": 272776863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645521248
    },
    {
        "content": "<p>Would that be preferable to linarith in some way? Leo is already working on the latter.</p>",
        "id": 272778130,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1645522072
    },
    {
        "content": "<p>it's likely to be significantly faster</p>",
        "id": 272778847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645522467
    },
    {
        "content": "<p>good to know that leo is writing linarith though</p>",
        "id": 272778875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645522492
    },
    {
        "content": "<p>also 100% of the autogenerated well founded subgoals that I have seen are either in that grammar (after unfolding a bunch of definitions) or linarith would not have helped anyway</p>",
        "id": 272779080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645522616
    },
    {
        "content": "<p>Thanks! That should do nicely for now</p>",
        "id": 272887990,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1645577141
    }
]
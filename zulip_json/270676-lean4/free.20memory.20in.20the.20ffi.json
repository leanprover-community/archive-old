[
    {
        "content": "<p>Hi !<br>\nI tried to use the FFI to import functions coded in C, I spent some time there and now I can create functions, constructors / destructors but I have a problem, I can't to free the memory I allocated in these functions (initially I wanted to redo my own vector class which uses <code>std::vector</code> and <code>forall x:Fin n, a</code> as model, instead of <code>List a</code> ), I looked at the code and found that it is this function that frees the memory:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"n\">lean_free_object</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">switch</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lean_ptr_tag</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">LeanArray</span><span class=\"p\">:</span><span class=\"w\">       </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">lean_dealloc</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">lean_array_byte_size</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">LeanScalarArray</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">lean_dealloc</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">lean_sarray_byte_size</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">LeanString</span><span class=\"p\">:</span><span class=\"w\">      </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">lean_dealloc</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">lean_string_byte_size</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">LeanMPZ</span><span class=\"p\">:</span><span class=\"w\">         </span><span class=\"n\">to_mpz</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">m_value</span><span class=\"p\">.</span><span class=\"o\">~</span><span class=\"n\">mpz</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">lean_free_small_object</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">default</span><span class=\"o\">:</span><span class=\"w\">              </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">lean_free_small_object</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>it is therefore possible to free memory that matches on existing types but without the possibility of adding cases or redirecting the pointer to lean_free_small_object to a new function, which is problematic for managing external libraries that depend on their own allocators. Do you think this can be fixed in a next version of lean? One solution I've thought of is to have something like LeanCustom and one can reinterpret cast <code>o</code> to a struct that contains a pointer to its free memory function, but there may be a other solutions</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cp\">#define LeanCustom 4242</span>\n\n<span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">DeallocFun</span><span class=\"p\">)(</span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">lean_object</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">DeallocFun</span><span class=\"w\"> </span><span class=\"n\">custom_free</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">lean_custom</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"n\">lean_free_object</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">o</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* same at the original */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">LeanCustom</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">lean_custom</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">custom</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lean_custom</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">o</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">custom</span><span class=\"o\">-&gt;</span><span class=\"n\">custom_free</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">default</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"cm\">/* same at the oringinal */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 320359134,
        "sender_full_name": "Remy Citerin",
        "timestamp": 1673311441
    },
    {
        "content": "<p>When you register external classes, you also can register handlers for freeing your external objects.</p>\n<p>Example: <a href=\"https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c\">https://github.com/JamesGallicchio/LeanColls/blob/main/bindings/leancolls_array.c</a></p>",
        "id": 320364809,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673315254
    },
    {
        "content": "<p>(that's my reimplementation of arrays... <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>)</p>",
        "id": 320364917,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673315321
    },
    {
        "content": "<p>oh I didn't see that, thanks for the help!</p>",
        "id": 320368078,
        "sender_full_name": "Remy Citerin",
        "timestamp": 1673317822
    },
    {
        "content": "<p>FFI stuff is very minimally documented, so if you have questions don't hesitate to ask -- I spent way too much time trying to dig through lean.h for answers instead of bugging people on Zulip like I should have!</p>\n<p>This thread is also a good general source of answers on FFI stuff: <a href=\"#narrow/stream/270676-lean4/topic/C.20FFI.20usage\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/C.20FFI.20usage</a></p>",
        "id": 320368527,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673318272
    },
    {
        "content": "<p>I just went to see the code and I hadn't seen that LeanExternal existed <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> (it is in <code>runtime/object.cpp</code> and not <code>lean.h</code>), and <code>lean_del_core </code> check if the tag is <code>LeanExternal</code> before calling <code>lean_free_object</code> and does something similar by looking for the function pointer in the class definition <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 320368751,
        "sender_full_name": "Remy Citerin",
        "timestamp": 1673318503
    }
]
[
    {
        "content": "<p>Is there a more efficient way to perform a <code>(t : IO (Task a)) -&gt; IO a</code> conversion than <code>t &gt;&gt;= IO.wait</code>? As, unless I am mistaken, that spawns a thread and then has the main thread wait on it and is thus much less efficient than just executing the task in the main thread.</p>",
        "id": 249932825,
        "sender_full_name": "Mac",
        "timestamp": 1629338234
    },
    {
        "content": "<p>isn't the existence of a <code>Task a</code> already committing to the task existing on its own thread?</p>",
        "id": 249932895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338320
    },
    {
        "content": "<p>that is, <code>Task a</code> is the type of potentially already-started computations returning a value of type <code>a</code></p>",
        "id": 249932937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338387
    },
    {
        "content": "<p>if you want a task that has not yet been started you can use the type <code>IO a</code> instead of <code>Task a</code>. <code>IO (IO a) -&gt; IO a</code> can be done without fork join</p>",
        "id": 249933063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338470
    },
    {
        "content": "<p>I am actually not sure about this. The docs for <code>IO.asTask</code> sounds like what you said could be possible. However, I would think that <code>IO (Task a)</code> would spawn a Task when the monad is unpacked (ex, via bind), not immediately. Having a <code>Task a</code> around outside a monad definitely does mean what you said, though.</p>",
        "id": 249933154,
        "sender_full_name": "Mac",
        "timestamp": 1629338528
    },
    {
        "content": "<p>well, in an <code>IO (Task a)</code> we don't actually know if the task has been started or not. It might as well be <code>pure t</code> where <code>t : Task a</code> is currently running on another thread</p>",
        "id": 249933215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338605
    },
    {
        "content": "<p>in any case, the only thing we can do with such a value is run it (on some thread) to get a <code>Task a</code> of unknown provenance</p>",
        "id": 249933294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249933215\">said</a>:</p>\n<blockquote>\n<p>well, in an <code>IO (Task a)</code> we don't actually know if the task has been started or not. It might as well be <code>pure t</code> where <code>t : Task a</code> is currently running on another thread</p>\n</blockquote>\n<p>I am not sure how legal what you are saying is. As the <code>IO (Task a)</code>  generated by <code>pure t</code> is a very different kind of task than the one generated by <code>IO.asTask</code>.</p>",
        "id": 249933349,
        "sender_full_name": "Mac",
        "timestamp": 1629338758
    },
    {
        "content": "<p>That said, in the internals of <code>Task</code> one can presumably say what state the task is in and where it is running, so <code>IO.wait</code> can probably avoid the overhead if it sees the task is already complete</p>",
        "id": 249933405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249933349\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249933215\">said</a>:</p>\n<blockquote>\n<p>well, in an <code>IO (Task a)</code> we don't actually know if the task has been started or not. It might as well be <code>pure t</code> where <code>t : Task a</code> is currently running on another thread</p>\n</blockquote>\n<p>I am not sure how legal what you are saying is. As the <code>IO (Task a)</code>  generated by <code>pure t</code> is a very different kind of task than the one generated by <code>IO.asTask</code>.</p>\n</blockquote>\n<p>That's true, but my point is they have the same type, so any function accepting one has to be prepared to deal with the other</p>",
        "id": 249933443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338852
    },
    {
        "content": "<p>true, but all these functions are <code>constant</code> so they aren't really listening to the type system. My point is that there could be an <code>IO.join</code> that inspects the task internals and notices it has yet to be started and instead just invokes the closure rather than spawning the task. (For already spawned tasks it just waits on them.)</p>",
        "id": 249933544,
        "sender_full_name": "Mac",
        "timestamp": 1629338959
    },
    {
        "content": "<p>are you sure it isn't already doing that?</p>",
        "id": 249933555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629338989
    },
    {
        "content": "<p>There isn't a function that I know of that could do this.</p>",
        "id": 249933614,
        "sender_full_name": "Mac",
        "timestamp": 1629339018
    },
    {
        "content": "<p>I mean <code>IO.wait</code> could just do that</p>",
        "id": 249933621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339030
    },
    {
        "content": "<p>In <code>IO.wait</code> the object is a pure <code>Task a</code> so it  is definitely already spawned.</p>",
        "id": 249933630,
        "sender_full_name": "Mac",
        "timestamp": 1629339042
    },
    {
        "content": "<p>If <code>Task</code>s are definitely already started, then I don't think there is any type that represents both not started and started tasks, so the type signature will determine already whether it needs to be on another thread or not</p>",
        "id": 249933736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339194
    },
    {
        "content": "<p>After looking at the internals, since an IO object is just a closure and invoking the closure starts the task. Since there is no way inspect into the closure / inform it to not spawn the task, I guess this is, in fact, impossible.</p>",
        "id": 249933805,
        "sender_full_name": "Mac",
        "timestamp": 1629339274
    },
    {
        "content": "<p>right, a <code>IO (Task a)</code> is just a function that returns an already spawned task, there isn't any point to intercept it</p>",
        "id": 249933829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339321
    },
    {
        "content": "<p>:(</p>",
        "id": 249933842,
        "sender_full_name": "Mac",
        "timestamp": 1629339341
    },
    {
        "content": "<p>What's the motivation? Why would you not know whether the task is started or not?</p>",
        "id": 249933906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249933829\">said</a>:</p>\n<blockquote>\n<p>right, a <code>IO (Task a)</code> is just a function that returns an already spawned task, there isn't any point to intercept it</p>\n</blockquote>\n<p>Not that it does necessarily return an <em>already spawned</em> task. The function itself be the thing the spawns the task (as it is in <code>IO.asTask</code>'s case).</p>",
        "id": 249933917,
        "sender_full_name": "Mac",
        "timestamp": 1629339404
    },
    {
        "content": "<p>sure, but it can do that at any point in the function and you aren't instrumenting the code</p>",
        "id": 249933931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339442
    },
    {
        "content": "<p>by the time the function returns, the task is started. Before the function is called, it may or may not be started (it doesn't even really exist as a thing yet)</p>",
        "id": 249933935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339471
    },
    {
        "content": "<p>so this isn't a type that does what you want</p>",
        "id": 249933980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249933906\">said</a>:</p>\n<blockquote>\n<p>What's the motivation? Why would you not know whether the task is started or not?</p>\n</blockquote>\n<p>In Lake, build tasks are IO actions that may be run asynchronously, thus I have to choose between representing them as <code>IO a</code> or <code>IO (IOTask a)</code>.</p>",
        "id": 249933987,
        "sender_full_name": "Mac",
        "timestamp": 1629339506
    },
    {
        "content": "<p>The former is inefficient in the case of asynchronous tasks, the later is inefficient in the case of synchronous tasks.</p>",
        "id": 249933999,
        "sender_full_name": "Mac",
        "timestamp": 1629339538
    },
    {
        "content": "<p>How about <code>IO (IO a)</code> then? The idea is you execute in the outer IO if you want it to run immediately and in the inner IO if you want to allow it to be scheduled flexibly</p>",
        "id": 249934021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339582
    },
    {
        "content": "<p>this assumes that build tasks can decide for themselves which category they want to be in</p>",
        "id": 249934074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339610
    },
    {
        "content": "<p>How does that help?</p>",
        "id": 249934080,
        "sender_full_name": "Mac",
        "timestamp": 1629339615
    },
    {
        "content": "<p>More accurately, how are you proposing to represent them as <code>IO (IO a)</code>?</p>",
        "id": 249934086,
        "sender_full_name": "Mac",
        "timestamp": 1629339637
    },
    {
        "content": "<p>I don't understand the question. Build tasks have that type, they return whatever type <code>a</code> is behind two layers of IO, and you use <code>do ... pure (pure a)</code> for sync actions and <code>pure (do ... pure a)</code> for async actions</p>",
        "id": 249934170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339755
    },
    {
        "content": "<p>and then the harness runs all the outer IOs to get a <code>List (IO a)</code> or whatever the data structure is and puts them in a thread pool or what have you</p>",
        "id": 249934203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339822
    },
    {
        "content": "<p>Ah, this may be the key:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249934074\">said</a>:</p>\n<blockquote>\n<p>this assumes that build tasks can decide for themselves which category they want to be in</p>\n</blockquote>\n<p>Its exactly the opposite, the build manager is determining whether they are sync or async.</p>",
        "id": 249934261,
        "sender_full_name": "Mac",
        "timestamp": 1629339859
    },
    {
        "content": "<p>Here the build manager gets to decide how to schedule the async parts, and the outer IO is for mandatory sync actions</p>",
        "id": 249934278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339898
    },
    {
        "content": "<p>for a fully synchronous build manager you would just run both layers immediately</p>",
        "id": 249934295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629339923
    },
    {
        "content": "<p>and an async build manager could go through the list and call <code>IO.asTask</code> on each one to get a list of tasks</p>",
        "id": 249934366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340001
    },
    {
        "content": "<p>or do that up to <code>numThreads</code> times and manage the parallelism</p>",
        "id": 249934386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340037
    },
    {
        "content": "<p>I honestly am very confused about what you are describing.</p>",
        "id": 249934388,
        "sender_full_name": "Mac",
        "timestamp": 1629340041
    },
    {
        "content": "<p>Currently, each build target has some task <code>IO PUnit</code> that builds the artifact. I can make this asynchronous by running <code>IO.asTask</code> to get an <code>IO (IOTask PUnit)</code> or I can just run this synchronously by using the monad itself. I fail to see how this can be usefully made into an <code>IO (IO PUnit)</code> action.</p>",
        "id": 249934544,
        "sender_full_name": "Mac",
        "timestamp": 1629340216
    },
    {
        "content": "<p>That corresponds to the inner IO in my version. The outer IO is for things that have to be run on load time; if this is not necessary then <code>IO Unit</code> should suffice</p>",
        "id": 249934592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340298
    },
    {
        "content": "<p>However, I will note that your suggestion of using <code>m (m a)</code> (ex. <code>IO (IO a))</code>) for asynchronous actions is what Haskell does, so if there was an efficient way of mirroring that in Lean, I would be all ears.</p>",
        "id": 249934594,
        "sender_full_name": "Mac",
        "timestamp": 1629340302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249934592\">said</a>:</p>\n<blockquote>\n<p>That corresponds to the inner IO in my version. The outer IO is for things that have to be run on load time; if this is not necessary then <code>IO Unit</code> should suffice</p>\n</blockquote>\n<p>So how is that different from what I am doing?</p>",
        "id": 249934686,
        "sender_full_name": "Mac",
        "timestamp": 1629340382
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">buildTask1</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"I always run immediately\"</span>\n  <span class=\"n\">pure</span> <span class=\"k\">do</span>\n    <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"s2\">\"I run when this task is scheduled\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">buildTask2</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">())</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">buildManager</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- run sync actions</span>\n  <span class=\"k\">let</span> <span class=\"n\">ios</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">[</span><span class=\"n\">buildTask1</span><span class=\"o\">,</span> <span class=\"n\">buildTask2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">mapM</span> <span class=\"n\">id</span>\n  <span class=\"c1\">-- split off the first task, because we want to run it on the main thread</span>\n  <span class=\"k\">let</span> <span class=\"n\">io1</span> <span class=\"o\">::</span> <span class=\"n\">ios</span> <span class=\"bp\">←</span> <span class=\"n\">ios</span> <span class=\"bp\">|</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"\"</span>\n  <span class=\"c1\">-- start async actions in parallel</span>\n  <span class=\"k\">let</span> <span class=\"n\">tasks</span> <span class=\"bp\">←</span> <span class=\"n\">ios.mapM</span> <span class=\"n\">IO.asTask</span>\n  <span class=\"c1\">-- Run the first task on the main thread</span>\n  <span class=\"k\">let</span> <span class=\"n\">result1</span> <span class=\"bp\">←</span> <span class=\"n\">io1</span>\n  <span class=\"c1\">-- block on the async tasks</span>\n  <span class=\"k\">let</span> <span class=\"n\">results</span> <span class=\"bp\">←</span> <span class=\"n\">tasks.mapM</span> <span class=\"n\">IO.wait</span>\n  <span class=\"c1\">-- do something with results</span>\n</code></pre></div>",
        "id": 249934809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340534
    },
    {
        "content": "<p>Again, in Lake there is no 'I always run immediately', there is only 'I run when the task is scheduled' in build tasks.</p>",
        "id": 249934888,
        "sender_full_name": "Mac",
        "timestamp": 1629340622
    },
    {
        "content": "<p>which just reduces this example to what I already have.</p>",
        "id": 249934894,
        "sender_full_name": "Mac",
        "timestamp": 1629340636
    },
    {
        "content": "<p>Without the outer IO, the only difference is that the first line is just <code>let ios : List (IO Unit) := [buildTask1, buildTask2]</code></p>",
        "id": 249934895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340636
    },
    {
        "content": "<p>you still have flexibility in when to schedule things</p>",
        "id": 249934899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340652
    },
    {
        "content": "<p>I'm not sure how you want to determine what to run where though</p>",
        "id": 249934956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340696
    },
    {
        "content": "<p>The problem is that a build task A may or may not wish to build other things and it may want to do so asynchronously. If it does,  it is now left with a <code>IOTask</code> instead of an <code>IO</code>, so it has to wait on it to covert into an <code>IO</code>. However, a build task B may then choose to to ran A asynchronously as well, which means I end up be with a dead thread (as it reduces to essentially `IO.asTask (IO.wait t)).</p>",
        "id": 249934970,
        "sender_full_name": "Mac",
        "timestamp": 1629340718
    },
    {
        "content": "<p>Do you want task B to call task A directly, or ask the build manager to do it?</p>",
        "id": 249934998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340799
    },
    {
        "content": "<p>task B calls A directly (in the current implementation)</p>",
        "id": 249935048,
        "sender_full_name": "Mac",
        "timestamp": 1629340814
    },
    {
        "content": "<p>So is the asynchrony because task B has something else to do while A runs?</p>",
        "id": 249935070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340856
    },
    {
        "content": "<p>yes, task <em>A</em> or <em>B</em> may depending on 10 different tasks, so it wants to build them all asynchronously.</p>",
        "id": 249935087,
        "sender_full_name": "Mac",
        "timestamp": 1629340887
    },
    {
        "content": "<p>because if it's just creating the task and waiting on it immediately then that's obviously useless</p>",
        "id": 249935090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340888
    },
    {
        "content": "<p>okay, so it can just do that then, right? It just starts all the tasks, and waits on all the results</p>",
        "id": 249935153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629340927
    },
    {
        "content": "<p>Yes, but A already does that, so B is now waiting on A's thread which is waiting on its own dependency's threads.</p>",
        "id": 249935192,
        "sender_full_name": "Mac",
        "timestamp": 1629340993
    },
    {
        "content": "<p>shouldn't B be waiting on A?</p>",
        "id": 249935198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341014
    },
    {
        "content": "<p>yep, typo -- fixed.</p>",
        "id": 249935202,
        "sender_full_name": "Mac",
        "timestamp": 1629341023
    },
    {
        "content": "<p>okay so where's the problem? If B wants to run A on its own thread it can do so</p>",
        "id": 249935280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341070
    },
    {
        "content": "<p>But that's the problem since A is a collection of asynchronous tasks, spawning it on new thread is silly.</p>",
        "id": 249935300,
        "sender_full_name": "Mac",
        "timestamp": 1629341107
    },
    {
        "content": "<p>So then B can not run it async</p>",
        "id": 249935316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341131
    },
    {
        "content": "<p>And therein lies the problem, how is B to know which to do?</p>",
        "id": 249935322,
        "sender_full_name": "Mac",
        "timestamp": 1629341153
    },
    {
        "content": "<p>how is anything to know which to do?</p>",
        "id": 249935374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341174
    },
    {
        "content": "<p>Exactly, hence my problem.</p>",
        "id": 249935388,
        "sender_full_name": "Mac",
        "timestamp": 1629341191
    },
    {
        "content": "<p>what's the ideal decision procedure here</p>",
        "id": 249935395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341198
    },
    {
        "content": "<p>it's certainly harder from B's myopic point of view, but even from a global view I'm not sure what you want to do about it</p>",
        "id": 249935414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341236
    },
    {
        "content": "<p>What B would like to do is, if A is a collection of async tasks, add them to the async queue. Otherwise, run it as a new thread (and add it to the queue).</p>",
        "id": 249935431,
        "sender_full_name": "Mac",
        "timestamp": 1629341260
    },
    {
        "content": "<p>if you want to be able to make global decisions here, though, you should probably have B not call A directly and use the build manager as middle man</p>",
        "id": 249935439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341271
    },
    {
        "content": "<p>I don't really want a global decision here. This mostly a decision on the intersection point.</p>",
        "id": 249935503,
        "sender_full_name": "Mac",
        "timestamp": 1629341315
    },
    {
        "content": "<p>Can A have some metadata saying \"I am a collection of async tasks\"? Then the library can provide a function which is \"run async if this is a sync action, and run sync if this is a collection of async actions\"</p>",
        "id": 249935510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341329
    },
    {
        "content": "<p>you can make the setting of that flag less error prone by having a special constructor for \"aggregate tasks\"</p>",
        "id": 249935624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341425
    },
    {
        "content": "<p>Yeah, I was probably being a little to narrow minded. I could just use a new monad that is either an <code>IO</code> or an <code>IO (IOTask a)</code>. I was just trying to get away with just using <code>IO</code>.</p>",
        "id": 249935629,
        "sender_full_name": "Mac",
        "timestamp": 1629341441
    },
    {
        "content": "<p>well, in my version it's still just an <code>IO a</code>, or rather <code>(IO a) x Bool</code></p>",
        "id": 249935659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341484
    },
    {
        "content": "<p>I don't think <code>IO (IOTask a)</code> is helpful, that's for already started tasks so it is more appropriate as the return type of library functions</p>",
        "id": 249935719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341534
    },
    {
        "content": "<p><code>IO (IOTask a)</code> is an <code>IOTask</code> spawner -- it is not for already started tasks.</p>",
        "id": 249935762,
        "sender_full_name": "Mac",
        "timestamp": 1629341601
    },
    {
        "content": "<p>Though you can of course inject an already existing task with <code>pure</code>.</p>",
        "id": 249935783,
        "sender_full_name": "Mac",
        "timestamp": 1629341632
    },
    {
        "content": "<p>well yes, but when would a build task ever want to have a type like that?</p>",
        "id": 249935787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341635
    },
    {
        "content": "<p>when it can just return the result</p>",
        "id": 249935834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341650
    },
    {
        "content": "<p>unless you are interested in the inner/outer IO approach from before</p>",
        "id": 249935846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341668
    },
    {
        "content": "<p>If the task is just a collection  of asynchronous tasks (or a collection + a post-completion action)?</p>",
        "id": 249935861,
        "sender_full_name": "Mac",
        "timestamp": 1629341693
    },
    {
        "content": "<p>I should probably be using <code>IO Unit</code>/<code>IOTask PUnit</code> more to make it clearer that <code>a</code> is not a result in this system.</p>",
        "id": 249935911,
        "sender_full_name": "Mac",
        "timestamp": 1629341761
    },
    {
        "content": "<p>A collection of asynchronous tasks could have type <code>List (IO a)</code>, i.e. literally a collection</p>",
        "id": 249935965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341775
    },
    {
        "content": "<p>I was wondering about that; this is a lot harder if you want to be type parametric</p>",
        "id": 249935975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341795
    },
    {
        "content": "<p>so the monad might be <code>Sum (IO a) (List (IO a))</code></p>",
        "id": 249936013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341844
    },
    {
        "content": "<p>well, there are some decisions to be made about when a task becomes a collection and vice versa</p>",
        "id": 249936053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249935965\">said</a>:</p>\n<blockquote>\n<p>A collection of asynchronous tasks could have type <code>List (IO a)</code>, i.e. literally a collection</p>\n</blockquote>\n<p>I assume you mean <code>Array (IOTask a)</code>. That is fine if it just a collection. However, if it is a collection and then an action, then it is not.</p>",
        "id": 249936084,
        "sender_full_name": "Mac",
        "timestamp": 1629341891
    },
    {
        "content": "<p>not <code>IOTask</code>, <code>IO</code></p>",
        "id": 249936089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341903
    },
    {
        "content": "<p>That would be a collection of synchronous actions, not asynchronous tasks.</p>",
        "id": 249936098,
        "sender_full_name": "Mac",
        "timestamp": 1629341920
    },
    {
        "content": "<p>It is a collection of not-yet-started tasks</p>",
        "id": 249936105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341935
    },
    {
        "content": "<p>you use <code>IO.asTask</code> to start them</p>",
        "id": 249936120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629341948
    },
    {
        "content": "<p>In this case they are already started though.</p>",
        "id": 249936131,
        "sender_full_name": "Mac",
        "timestamp": 1629341962
    },
    {
        "content": "<p>The advantage of waiting to start the tasks until you have the complete collection is that you get more parallelism</p>",
        "id": 249936310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629342083
    },
    {
        "content": "<p>A build target <code>A </code>often comes with the a list of additional targets <code>Bs</code> as dependencies. Each as a <code>task</code> field that, when run, will materialize the target. The build target <code>A</code>'s <code>task</code> will run these tasks and (after they are finished) perform its own build.</p>",
        "id": 249936347,
        "sender_full_name": "Mac",
        "timestamp": 1629342123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249936310\">said</a>:</p>\n<blockquote>\n<p>The advantage of waiting to start the tasks until you have the complete collection is that you get more parallelism</p>\n</blockquote>\n<p>You often can't do this because the task itself might determine which tasks to run.</p>",
        "id": 249936428,
        "sender_full_name": "Mac",
        "timestamp": 1629342200
    },
    {
        "content": "<p>In building a Lean module, for example, we learn which tasks to run by reading the imports and we only want to run the task once for the same import. Thus we determine which module tasks are built while building.</p>",
        "id": 249936536,
        "sender_full_name": "Mac",
        "timestamp": 1629342298
    },
    {
        "content": "<p>With the <code>Sum (IO Unit) (List (IO Unit))</code>monad, there are two ways to implement <code>A.task</code>. If it has a lot of additional work to do, then it chooses the first variant: it has to implement an <code>IO Unit</code>, which runs <code>runMany Bs</code> for the list of tasks <code>Bs</code>, gets the results, and does what it needs to do. If it has nothing to do besides aggregating the <code>Bs</code>, then it calls <code>collect Bs</code> which produces the <code>List (IO Unit)</code> variant by concatenating all the subtasks in the Bs</p>",
        "id": 249936636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629342394
    },
    {
        "content": "<p>The most common cases for build tasks, imo, are the following: </p>\n<ul>\n<li>Do nothing, the file is an input</li>\n<li>Build something (ideally synchronously) and then perform an action (ex. building a <code>.o</code> file)</li>\n<li>Build many things (ideally asynchronously) and then perform an action (ex. building a static/shared library)</li>\n<li>Do something heavily complex (i.e., intermingle building and determining which things to build)</li>\n</ul>",
        "id": 249936785,
        "sender_full_name": "Mac",
        "timestamp": 1629342587
    },
    {
        "content": "<p>In all of those examples, you already know whether you are async or sync</p>",
        "id": 249937000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629342805
    },
    {
        "content": "<p>and <code>IO Unit</code> already handles those cases</p>",
        "id": 249937011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629342823
    },
    {
        "content": "<p>Yes the task itself knows whether it wants to be synchronous or asynchronous. However, it does not know whether its dependents do.</p>",
        "id": 249937068,
        "sender_full_name": "Mac",
        "timestamp": 1629342854
    },
    {
        "content": "<p>it knows whether it wants to run its direct children on the same thread or not</p>",
        "id": 249937079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629342887
    },
    {
        "content": "<p>Yes, but it doesn't know whether its direct children are run on the same thread or not.</p>",
        "id": 249937121,
        "sender_full_name": "Mac",
        "timestamp": 1629342936
    },
    {
        "content": "<p>Options 1 and 2 are synchronous build tasks, options 3 and 4 are asynchronous tasks.</p>",
        "id": 249937126,
        "sender_full_name": "Mac",
        "timestamp": 1629342947
    },
    {
        "content": "<p>if it is responsible for starting the children then it can do so</p>",
        "id": 249937131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629342952
    },
    {
        "content": "<p>It is only necessarily responsible for finishing its dependents, not starting them.</p>",
        "id": 249937191,
        "sender_full_name": "Mac",
        "timestamp": 1629342989
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">doNothing</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">buildSyncThen</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">buildAsyncThen</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"bp\">←</span> <span class=\"n\">as.mapM</span> <span class=\"n\">IO.asTask</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">as.mapM</span> <span class=\"n\">IO.wait</span>\n  <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">doSomethingElse</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">as</span> <span class=\"bp\">←</span> <span class=\"n\">f</span>\n  <span class=\"n\">buildAsyncThen</span> <span class=\"n\">as</span> <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 249937278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343098
    },
    {
        "content": "<p>Your <code>buildAsyncThen</code> is very inefficient if spawned asynchronously. It spawns a thread that does nothing but wait until it is dependents are finished.</p>",
        "id": 249937345,
        "sender_full_name": "Mac",
        "timestamp": 1629343203
    },
    {
        "content": "<p>That's what the collection thing was about</p>",
        "id": 249937386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343231
    },
    {
        "content": "<p>if you keep metadata on the tasks to be able to say which ones are \"heavy\" and which are \"light\" then you can avoid spawning threads for light tasks</p>",
        "id": 249937405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343271
    },
    {
        "content": "<p>if <code>b</code> is heavy then <code>buildAsyncThen</code> might not be so useless</p>",
        "id": 249937429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343314
    },
    {
        "content": "<p>It still is, because before it does b it is just a thread that is sitting around doing nothing.</p>",
        "id": 249937485,
        "sender_full_name": "Mac",
        "timestamp": 1629343361
    },
    {
        "content": "<p>really, I think you need a green threads implementation</p>",
        "id": 249937501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343395
    },
    {
        "content": "<p>In fact, isn't <code>Task</code> doing that already?</p>",
        "id": 249937517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343431
    },
    {
        "content": "<p>I'm not sure that these are actually system threads</p>",
        "id": 249937521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343439
    },
    {
        "content": "<p>For example, consider: <code>buildAsyncThen [buildAsyncThen [...] a1, ...., buildAsyncThen [...] a10] b</code>. The outer <code>buildAsyncThen</code> spawns 10 threads that wait for the inner tasks to complete and if those tasks are complex they may be sitting around for a while eating up the thread pool doing nothing.</p>",
        "id": 249937586,
        "sender_full_name": "Mac",
        "timestamp": 1629343486
    },
    {
        "content": "<p>In that case you might want something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BuildTask</span> <span class=\"n\">where</span>\n  <span class=\"n\">deps</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span>\n  <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span>\n</code></pre></div>\n<p>then <code>buildAsyncThen</code> is a combinator that combines the deps</p>",
        "id": 249937631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343560
    },
    {
        "content": "<p>These are the reasons <code>IO.mapTask</code>/<code>IO.mapTasks</code>/<code>IO.bindTask</code> exist, specifically  to avoid creating such threads.</p>",
        "id": 249937678,
        "sender_full_name": "Mac",
        "timestamp": 1629343586
    },
    {
        "content": "<p>See Sebastian's comment on my previous IO Task question: <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20IO.20Tasks/near/248579994\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.E2.9C.94.20IO.20Tasks/near/248579994</a></p>",
        "id": 249937699,
        "sender_full_name": "Mac",
        "timestamp": 1629343633
    },
    {
        "content": "<p>Also see Wojciech's comment below that where he explains that consuming the thread pool can actually lead to deadlock (and no tasks completing).</p>",
        "id": 249937762,
        "sender_full_name": "Mac",
        "timestamp": 1629343697
    },
    {
        "content": "<p>Thus, things that lead to <code>IO.asTask (IO.wait task *&gt; something)</code> have to be avoid like the plague.</p>",
        "id": 249937792,
        "sender_full_name": "Mac",
        "timestamp": 1629343782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249937631\">said</a>:</p>\n<blockquote>\n<p>In that case you might want something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BuildTask</span> <span class=\"n\">where</span>\n  <span class=\"n\">deps</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Unit</span><span class=\"o\">)</span>\n  <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span>\n</code></pre></div>\n<p>then <code>buildAsyncThen</code> is a combinator that combines the deps</p>\n</blockquote>\n<p>This can't be done for the reason I already described. There are build tasks that don't know their dependencies until <code>main</code> is run.</p>",
        "id": 249937897,
        "sender_full_name": "Mac",
        "timestamp": 1629343831
    },
    {
        "content": "<p>It would be great if there was a version of <code>IO.asTask</code> that yielded a <code>TaskBuilder</code> which you can use to construct a dependency graph with map/bind before starting it</p>",
        "id": 249937911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249937897\">said</a>:</p>\n<blockquote>\n<p>This can't be done for the reason I already described. There are build tasks that don't know their dependencies until <code>main</code> is run.</p>\n</blockquote>\n<p>For tasks like that you would just have empty deps</p>",
        "id": 249938001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343981
    },
    {
        "content": "<p>they would just start their deps directly inside <code>main</code></p>",
        "id": 249938012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629343997
    },
    {
        "content": "<p>the deps represent dependencies known in advance, which can be used to aggregate the leaves in your nested <code>buildAsyncThen</code> example</p>",
        "id": 249938031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629344033
    },
    {
        "content": "<p>So then what is the point of the deps then?</p>",
        "id": 249938078,
        "sender_full_name": "Mac",
        "timestamp": 1629344050
    },
    {
        "content": "<p>for dependencies that need to be computed first, there is nothing for it but to run the action and tie up a thread</p>",
        "id": 249938086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629344065
    },
    {
        "content": "<p>Sorry, I wrote that before I read your last response.</p>",
        "id": 249938091,
        "sender_full_name": "Mac",
        "timestamp": 1629344081
    },
    {
        "content": "<p>The problem with the Lean build system is that all the simple tasks depend on the big complex task that can't be represented as an IO.</p>",
        "id": 249938101,
        "sender_full_name": "Mac",
        "timestamp": 1629344110
    },
    {
        "content": "<p>what can't be represented as IO?</p>",
        "id": 249938111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629344127
    },
    {
        "content": "<p>The package build.</p>",
        "id": 249938118,
        "sender_full_name": "Mac",
        "timestamp": 1629344144
    },
    {
        "content": "<p>why?</p>",
        "id": 249938174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629344187
    },
    {
        "content": "<p>Building o files, the static lib, and the exe are simple tasks but they don't know what files to build until the package build has been computed and launched.</p>",
        "id": 249938179,
        "sender_full_name": "Mac",
        "timestamp": 1629344206
    },
    {
        "content": "<p>The package build returns a <code>NameMap</code> of modules to their associated active build target / task which the rest (i.e., the o files, static lib, and exe) use to know what to build and what to depend on.</p>",
        "id": 249938263,
        "sender_full_name": "Mac",
        "timestamp": 1629344306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/Another.20IO.20Task.20question/near/249933544\">said</a>:</p>\n<blockquote>\n<p>My point is that there could be an <code>IO.join</code> that inspects the task internals and notices it has yet to be started and instead just invokes the closure rather than spawning the task. (For already spawned tasks it just waits on them.)</p>\n</blockquote>\n<p>I didn't read the whole thread, but I just wanted to say this proposal here is a terrible idea because it executes the task with a nondeterministic (and potentially very small) stack size.</p>",
        "id": 249960051,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1629364026
    }
]
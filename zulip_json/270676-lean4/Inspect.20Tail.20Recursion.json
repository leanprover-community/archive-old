[
    {
        "content": "<p>Is there a quick way to check if Lean has recognized that a function is tail recursive? (Besides running it on large examples and trying to crash Lean)</p>",
        "id": 235851689,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619188867
    },
    {
        "content": "<p>I did this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir.result</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tail_recursive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tail_recursive</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">not_tail_recursive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not_tail_recursive</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>The <code>trace.compiler.ir.result</code> printout is pretty close to the lowest level that is still lean IR, but it's still fairly functional so the tail recursion is not explicit. But if you compile to C using </p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>lean --c<span class=\"o\">=</span><span class=\"s2\">\"test.c\"</span> test.lean\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"nf\">l_tail__recursive</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"nl\">_start</span><span class=\"p\">:</span>\n<span class=\"p\">{</span>\n<span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_2</span><span class=\"p\">;</span> <span class=\"kt\">uint8_t</span> <span class=\"n\">x_3</span><span class=\"p\">;</span>\n<span class=\"n\">x_2</span> <span class=\"o\">=</span> <span class=\"n\">lean_unsigned_to_nat</span><span class=\"p\">(</span><span class=\"mi\">0u</span><span class=\"p\">);</span>\n<span class=\"n\">x_3</span> <span class=\"o\">=</span> <span class=\"n\">lean_nat_dec_eq</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">,</span> <span class=\"n\">x_2</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x_3</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_4</span><span class=\"p\">;</span> <span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_5</span><span class=\"p\">;</span>\n<span class=\"n\">x_4</span> <span class=\"o\">=</span> <span class=\"n\">lean_unsigned_to_nat</span><span class=\"p\">(</span><span class=\"mi\">1u</span><span class=\"p\">);</span>\n<span class=\"n\">x_5</span> <span class=\"o\">=</span> <span class=\"n\">lean_nat_sub</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">,</span> <span class=\"n\">x_4</span><span class=\"p\">);</span>\n<span class=\"n\">lean_dec</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">);</span>\n<span class=\"n\">x_1</span> <span class=\"o\">=</span> <span class=\"n\">x_5</span><span class=\"p\">;</span>\n<span class=\"k\">goto</span> <span class=\"n\">_start</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">else</span>\n<span class=\"p\">{</span>\n<span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_7</span><span class=\"p\">;</span>\n<span class=\"n\">lean_dec</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">);</span>\n<span class=\"n\">x_7</span> <span class=\"o\">=</span> <span class=\"n\">lean_unsigned_to_nat</span><span class=\"p\">(</span><span class=\"mi\">0u</span><span class=\"p\">);</span>\n<span class=\"k\">return</span> <span class=\"n\">x_7</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"nf\">l_not__tail__recursive</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"nl\">_start</span><span class=\"p\">:</span>\n<span class=\"p\">{</span>\n<span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_2</span><span class=\"p\">;</span> <span class=\"kt\">uint8_t</span> <span class=\"n\">x_3</span><span class=\"p\">;</span>\n<span class=\"n\">x_2</span> <span class=\"o\">=</span> <span class=\"n\">lean_unsigned_to_nat</span><span class=\"p\">(</span><span class=\"mi\">0u</span><span class=\"p\">);</span>\n<span class=\"n\">x_3</span> <span class=\"o\">=</span> <span class=\"n\">lean_nat_dec_eq</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">,</span> <span class=\"n\">x_2</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x_3</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_4</span><span class=\"p\">;</span> <span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_5</span><span class=\"p\">;</span> <span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_6</span><span class=\"p\">;</span> <span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_7</span><span class=\"p\">;</span>\n<span class=\"n\">x_4</span> <span class=\"o\">=</span> <span class=\"n\">lean_unsigned_to_nat</span><span class=\"p\">(</span><span class=\"mi\">1u</span><span class=\"p\">);</span>\n<span class=\"n\">x_5</span> <span class=\"o\">=</span> <span class=\"n\">lean_nat_sub</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">,</span> <span class=\"n\">x_4</span><span class=\"p\">);</span>\n<span class=\"n\">x_6</span> <span class=\"o\">=</span> <span class=\"n\">l_not__tail__recursive</span><span class=\"p\">(</span><span class=\"n\">x_5</span><span class=\"p\">);</span>\n<span class=\"n\">lean_dec</span><span class=\"p\">(</span><span class=\"n\">x_5</span><span class=\"p\">);</span>\n<span class=\"n\">x_7</span> <span class=\"o\">=</span> <span class=\"n\">lean_nat_add</span><span class=\"p\">(</span><span class=\"n\">x_6</span><span class=\"p\">,</span> <span class=\"n\">x_4</span><span class=\"p\">);</span>\n<span class=\"n\">lean_dec</span><span class=\"p\">(</span><span class=\"n\">x_6</span><span class=\"p\">);</span>\n<span class=\"k\">return</span> <span class=\"n\">x_7</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">else</span>\n<span class=\"p\">{</span>\n<span class=\"n\">lean_object</span><span class=\"o\">*</span> <span class=\"n\">x_8</span><span class=\"p\">;</span>\n<span class=\"n\">x_8</span> <span class=\"o\">=</span> <span class=\"n\">lean_unsigned_to_nat</span><span class=\"p\">(</span><span class=\"mi\">0u</span><span class=\"p\">);</span>\n<span class=\"k\">return</span> <span class=\"n\">x_8</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>you can see that the <code>l_tail__recursive</code> function contains a <code>goto _start</code> while <code>l_not__tail__recursive</code> contains a recursive call</p>",
        "id": 235853515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619189581
    },
    {
        "content": "<p>wow, this is great</p>",
        "id": 235854013,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619189774
    },
    {
        "content": "<p>What do I need to do to view the result of the ir option once I set it to true</p>",
        "id": 235855333,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619190128
    },
    {
        "content": "<p>on vscode it pops up in the output panel; in the console it prints to stdout</p>",
        "id": 235855661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619190187
    },
    {
        "content": "<p>I'm finding it on emacs lsp::stderr</p>",
        "id": 235856261,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619190323
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">result</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">tail_recursive.match_1._rarg</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.decEq</span> <span class=\"n\">x_1</span> <span class=\"n\">x_4</span><span class=\"bp\">;</span>\n  <span class=\"n\">case</span> <span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"n\">of</span>\n  <span class=\"n\">Bool.false</span> <span class=\"bp\">→</span>\n    <span class=\"n\">dec</span> <span class=\"n\">x_2</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_6</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_7</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sub</span> <span class=\"n\">x_1</span> <span class=\"n\">x_6</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_8</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">app</span> <span class=\"n\">x_3</span> <span class=\"n\">x_7</span><span class=\"bp\">;</span>\n    <span class=\"n\">ret</span> <span class=\"n\">x_8</span>\n  <span class=\"n\">Bool.true</span> <span class=\"bp\">→</span>\n    <span class=\"n\">dec</span> <span class=\"n\">x_3</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_9</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">ctor_0</span><span class=\"o\">[</span><span class=\"n\">PUnit.unit</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_10</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">app</span> <span class=\"n\">x_2</span> <span class=\"n\">x_9</span><span class=\"bp\">;</span>\n    <span class=\"n\">ret</span> <span class=\"n\">x_10</span>\n<span class=\"kd\">def</span> <span class=\"n\">tail_recursive.match_1</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"bp\">◾</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">pap</span> <span class=\"n\">tail_recursive.match_1._rarg._boxed</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_2</span>\n<span class=\"kd\">def</span> <span class=\"n\">tail_recursive.match_1._rarg._boxed</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">tail_recursive.match_1._rarg</span> <span class=\"n\">x_1</span> <span class=\"n\">x_2</span> <span class=\"n\">x_3</span><span class=\"bp\">;</span>\n  <span class=\"n\">dec</span> <span class=\"n\">x_1</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_4</span>\n<span class=\"o\">[</span><span class=\"n\">result</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">tail_recursive</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.decEq</span> <span class=\"n\">x_1</span> <span class=\"n\">x_2</span><span class=\"bp\">;</span>\n  <span class=\"n\">case</span> <span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"n\">of</span>\n  <span class=\"n\">Bool.false</span> <span class=\"bp\">→</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sub</span> <span class=\"n\">x_1</span> <span class=\"n\">x_4</span><span class=\"bp\">;</span>\n    <span class=\"n\">dec</span> <span class=\"n\">x_1</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_6</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">tail_recursive</span> <span class=\"n\">x_5</span><span class=\"bp\">;</span>\n    <span class=\"n\">ret</span> <span class=\"n\">x_6</span>\n  <span class=\"n\">Bool.true</span> <span class=\"bp\">→</span>\n    <span class=\"n\">dec</span> <span class=\"n\">x_1</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">x_7</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"bp\">;</span>\n    <span class=\"n\">ret</span> <span class=\"n\">x_7</span>\n</code></pre></div>\n<p>is the ir result</p>",
        "id": 235858362,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619190815
    },
    {
        "content": "<p>the \"def tail_recursive\" part makes sense to me though it does not show tail recursion. What is the purpose of the other \"match\" functions here?</p>",
        "id": 235859133,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619190948
    },
    {
        "content": "<p><code>tail_recursive.match_1</code> was generated by the equation compiler, and the compiler just compiled that definition too</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">tail_recursive.match_1.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">Nat.casesOn</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"n\">Unit.unit</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 235860849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619191598
    },
    {
        "content": "<p>the auxiliaries <code>tail_recursive.match_1._rarg._boxed</code> and <code>tail_recursive.match_1._rarg</code> were made by the compiler, but <code>match_1</code> already existed</p>",
        "id": 235860975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619191653
    },
    {
        "content": "<p>Is the compiled version of <code>tail_recursive.match_1</code> optimized away or does it still exist in the fully compiled code?</p>",
        "id": 235864296,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1619192974
    },
    {
        "content": "<p>I believe the compiler will not use the definition of <code>tail_recursive</code> that lean sees but will directly compile an equation compiler definition to a general recursion</p>",
        "id": 235864730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619193129
    },
    {
        "content": "<p>In fact, right now the compiler doesn't know how to compile functions written directly by recursors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">tail_recursive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.recOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih</span><span class=\"o\">)</span>\n<span class=\"c1\">-- code generator does not support recursor 'Nat.recOn' yet, consider using 'match ... with' and/or structural recursion</span>\n</code></pre></div>\n<p>So the equation compiler metadata is actually essential, at least for the present</p>",
        "id": 235865292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619193363
    },
    {
        "content": "<p><code>#check tail_recursive.match_1</code> succeeds, but <code>#check tail_recursive.match_1._rarg</code> doesn't. So the generated functions are not one-to-one with the ir functions.</p>",
        "id": 235865813,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619193589
    },
    {
        "content": "<p>Oh that's what you mean by \"match_1\" already existed.</p>",
        "id": 235866111,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619193678
    },
    {
        "content": "<p>The <code>Unit -&gt; motive 0</code> part of match_1 is strange to me. Why is it not just <code>motive 0</code> in the type signature?</p>",
        "id": 235866728,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619193899
    },
    {
        "content": "<p>Is the point of match_1 to create a lower level representation of your definition by removing match statements?</p>",
        "id": 235867675,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619194311
    },
    {
        "content": "<p>There are definitions that are generated by the equation compiler, like <code>tail_recursive.match_1</code>, and definitions that are generated by the (lean-to-C) compiler, like <code>tail_recursive.match_1._rarg</code>.</p>\n<ul>\n<li>The first class of definitions are produced by macros, tactics, and constructs like <code>match</code>. They appear in the environment, are checked by the kernel, and are in that sense \"real\" definitions.</li>\n<li>The second class of definitions are created in the course of lowering code for generating machine code. Things like lifted lambda bodies will show up here as separate definitions because ultimately they will need to be separate functions in C. These are never touched by the kernel and are not added to the environment, although I don't think there is any fundamental reason why they couldn't be added; it's just not necessary. They are also not regular lean definitions - the IR syntax is not a term of type <code>expr</code>, even though it has a syntax that looks a lot like lean. (For example <code>case x : u8 of ...</code> is not a thing in lean, but it is in the IR.)</li>\n</ul>",
        "id": 235868672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619194767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228135\">Scott Viteri</span> <a href=\"#narrow/stream/270676-lean4/topic/Inspect.20Tail.20Recursion/near/235866728\">said</a>:</p>\n<blockquote>\n<p>The <code>Unit -&gt; motive 0</code> part of match_1 is strange to me. Why is it not just <code>motive 0</code> in the type signature?</p>\n</blockquote>\n<p>If I had to guess, I think this is to ensure that evaluating <code>tail_recursive.match_1 (x+1) (fun _ =&gt; e1) (fun n =&gt; e2 n)</code> does not require evaluating <code>e1</code>. This is handled by the evaluation semantics of <code>Nat.casesOn</code> directly, but for functions wrapping <code>casesOn</code> you get the default eager evaluation semantics, so it is important to introduce a thunk on any cases for constructors with no arguments, so that the case for that constructor is not unnecessarily evaluated.</p>",
        "id": 235869593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619195179
    },
    {
        "content": "<p>This makes sense, thank you. Will match statements always turn into casesOn? Why not recOn?</p>",
        "id": 235881083,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619199890
    },
    {
        "content": "<p>hmm it also does support not rec directly </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">tail_recursive''</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>though casesOn uses rec under the hood.</p>",
        "id": 235890973,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619203907
    },
    {
        "content": "<p>Explained here: <a href=\"#narrow/stream/270676-lean4/topic/type.20mismatch.20error\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/type.20mismatch.20error</a></p>",
        "id": 235894457,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1619205467
    }
]
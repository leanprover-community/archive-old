[
    {
        "content": "<p>Weird test case, but here's an MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Node</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Node2</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">FingerTree</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"o\">{</span><span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">Deep</span> <span class=\"o\">{</span><span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FingerTree.snoc</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testAll</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">FingerTree.Empty</span>\n\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[:</span><span class=\"mi\">100</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">FingerTree.snoc</span> <span class=\"n\">q</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>I have a type for finger trees (much more complicated than here) which are indexed by a <code>Type u</code> (and therefore needs to live in <code>Type (u+1)</code>). Thought this would be fine. But now I can't use it in test cases I'm writing! (this works fine if it's in Type u instead)</p>",
        "id": 273711165,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646169158
    },
    {
        "content": "<p>It also works fine if the last line isn't in a <code>for</code>, so I think something must be up with the signature of <code>forIn</code></p>",
        "id": 273711376,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646169262
    },
    {
        "content": "<p>I can probably (?) rewrite this to be indexed by <code>Nat</code> instead of the type itself, to avoid the increase in universe level, but this definition is much more elegant so I'd like to keep it if possible</p>",
        "id": 273711509,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646169347
    },
    {
        "content": "<p>Some remarks:</p>\n<ul>\n<li><code>IO</code> is <strong>not</strong> universe polymorphic, and has type <code>Type -&gt; Type</code></li>\n<li><code>for ... in ... do</code> notation uses an auxiliary type class <code>ForIn</code>, and this type class forces the elements being updated to be in the universe taken by the monad. <code>testAll</code> function is equivalent to</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">testAll</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">FingerTree.Empty</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">col</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">stop</span> <span class=\"o\">:=</span> <span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">step</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Std.Range</span><span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"bp\">←</span> <span class=\"n\">forIn</span> <span class=\"n\">col</span> <span class=\"n\">q</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">ForInStep.yield</span> <span class=\"o\">(</span><span class=\"n\">FingerTree.snoc</span> <span class=\"n\">q</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"n\">pure</span> <span class=\"n\">PUnit.unit</span>\n</code></pre></div>\n<ul>\n<li>The same example will work with a universe polymorphic monad, but a slightly more complicated example will not without universe lifts which are a pain to use. </li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">testAll'</span> <span class=\"o\">:</span> <span class=\"n\">Id</span> <span class=\"n\">PUnit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">FingerTree.Empty</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[:</span><span class=\"mi\">100</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">FingerTree.snoc</span> <span class=\"n\">q</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>The following fails</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">testAll'</span> <span class=\"o\">:</span> <span class=\"n\">Id</span> <span class=\"n\">PUnit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">FingerTree.Empty</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[:</span><span class=\"mi\">100</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">FingerTree.snoc</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"c1\">-- q : FingerTree Nat is in Type 1</span>\n    <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">i</span>  <span class=\"c1\">-- s : Nat is in Type</span>\n</code></pre></div>\n<ul>\n<li>The universe bump at <code>FingerTree</code> is quite annoying. If I remember correctly Coq has an extension that allows us to avoid the bump.</li>\n</ul>",
        "id": 273743070,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1646187338
    },
    {
        "content": "<p>Hm. Okay. So the goal should really be to get <code>FingerTree</code> within the same universe as its input</p>\n<p>I did redefine it a bit to index the family on height <code>Nat</code> instead of the node type, which compiles, but is super annoying to work with. As you said in Coq the definition just works:<br>\n<a href=\"https://github.com/coq-contribs/finger-tree/blob/master/DependentFingerTree.v#L154\">https://github.com/coq-contribs/finger-tree/blob/master/DependentFingerTree.v#L154</a></p>\n<p>I'll look around for some documentation of Coq's universe constraint generation</p>",
        "id": 273751853,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646193671
    },
    {
        "content": "<p>It should be possible to make the nat indexed finger tree work mostly painlessly with the right setup. What does your version look like?</p>",
        "id": 273752113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646193880
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">NodeTree</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Node</span> <span class=\"o\">(</span><span class=\"n\">NodeTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">FingerTree</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">Single</span> <span class=\"o\">:</span> <span class=\"n\">NodeTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">Deep</span> <span class=\"o\">:</span> <span class=\"n\">Digit</span> <span class=\"o\">(</span><span class=\"n\">NodeTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Digit</span> <span class=\"o\">(</span><span class=\"n\">NodeTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>It's .. fine? I guess? Since unification gives us essentially the same type signatures</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">NodeTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>can unify to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 273752660,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646194237
    },
    {
        "content": "<p>You might also consider using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">NodeTree</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">NodeTree</span> <span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>which might work better for defeq</p>",
        "id": 273753353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646194897
    },
    {
        "content": "<p>Hrm, I think <code>Node (NodeTree ...)</code> is working better because I can peel off the nodes one layer at a time pretty easily. But now I'm having issue trying to get Lean simplifying <code>NodeTree τ 0</code> to <code>τ</code> consistently without explicit casts <span aria-label=\"concerned\" class=\"emoji emoji-1f615\" role=\"img\" title=\"concerned\">:concerned:</span></p>",
        "id": 273755335,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646196552
    },
    {
        "content": "<p>I'll see how far I can take this though</p>",
        "id": 273755351,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646196586
    },
    {
        "content": "<p>What is your application? Maybe there is another approach altogether that doesn't involve these type changing shenanigans</p>",
        "id": 273757131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646198070
    },
    {
        "content": "<p>For finger trees, I would go with a slightly less strongly typed version for the base operations, and enforce the structural constraints separately:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Node</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_1</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_2</span> <span class=\"o\">:</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_3</span> <span class=\"o\">:</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Digit</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_1</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Digit</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_2</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Digit</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_3</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Digit</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_4</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Digit</span> <span class=\"n\">τ</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">FingerTree</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">single</span> <span class=\"o\">:</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span>\n<span class=\"bp\">|</span> <span class=\"n\">deep</span> <span class=\"o\">:</span> <span class=\"n\">Digit</span> <span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Digit</span> <span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Node.isRegular</span> <span class=\"o\">:</span> <span class=\"n\">Node</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">Node._1</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n<span class=\"bp\">|</span> <span class=\"n\">Node._2</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">b.isRegular</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">Node._3</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">b.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">c.isRegular</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Digit.isRegular</span> <span class=\"o\">:</span> <span class=\"n\">Digit</span> <span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">Digit._1</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">Digit._2</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">b.isRegular</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">Digit._3</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">b.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">c.isRegular</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">Digit._4</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">b.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">c.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">d.isRegular</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FingerTree.isRegular</span> <span class=\"o\">:</span> <span class=\"n\">FingerTree</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">FingerTree.empty</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n<span class=\"bp\">|</span> <span class=\"n\">FingerTree.single</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">FingerTree.deep</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.isRegular</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">m.isRegular</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">b.isRegular</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 273758440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646199360
    },
    {
        "content": "<p>Goal is to implement fast vectors :) the version indexed by tau is quite elegant IMO, so I'm trying to preserve that as much as possible. The nat-indexed trees have been okay so far, no major issues yet.</p>\n<p>I suspect externally enforcing the constraints would be a pain, because you'd end up with lots of unreachable branches. But if I can't get the nat indexed version to work I'll try that out</p>",
        "id": 273836879,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646239511
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> I think if you want fast vectors you should build on <code>Array</code>, not trees</p>",
        "id": 273856282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646246449
    },
    {
        "content": "<blockquote>\n<p>I suspect externally enforcing the constraints would be a pain, because you'd end up with lots of unreachable branches. But if I can't get the nat indexed version to work I'll try that out</p>\n</blockquote>\n<p>If you have the regularity condition as a hypothesis, you can prove the unreachable branches are unreachable (and the equation compiler will often allow you to omit these branches)</p>",
        "id": 273856518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646246534
    },
    {
        "content": "<p>Do you know if that means the compiler compiler will emit code that skips the branches at runtime?</p>",
        "id": 273856885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646246695
    },
    {
        "content": "<p>But if you can write the code without the regularity condition as a hypothesis and just prove that the straightforward implementation preserves the regularity conditions, I think that would be even better</p>",
        "id": 273856900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646246703
    },
    {
        "content": "<p>If it's a two-way branch vs three I don't think there is any difference</p>",
        "id": 273857059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646246763
    },
    {
        "content": "<p>It's probably just wishful thinking on my part that <code>false.rec</code> compiles to C UB which is useful for optimization. More likely it's all a runtime unreachable check</p>",
        "id": 273857194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646246821
    },
    {
        "content": "<p>Generated Lean code is pretty defensive</p>",
        "id": 273857267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646246851
    },
    {
        "content": "<p>I wish there was a mode to allow lean to actually trust its dynamic semantics and proofs</p>",
        "id": 273857400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646246898
    },
    {
        "content": "<p>Although, it is possible to refactor an if statement with an unreachable branch into a have statement, which is zero-cost and leaves no branch</p>",
        "id": 273857655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646247005
    },
    {
        "content": "<p>Apparently False.rec is UB already:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir.result</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"mi\">10</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">100</span> <span class=\"k\">then</span>\n    <span class=\"n\">nomatch</span> <span class=\"k\">show</span> <span class=\"n\">False</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">else</span>\n    <span class=\"mi\">42</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span> <span class=\"mi\">3</span> <span class=\"c1\">-- returns 42 although 10 * 3 &lt; 100</span>\n</code></pre></div>",
        "id": 273858250,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1646247254
    },
    {
        "content": "<p>I recall fantasizing early in lean 4 about autogenerated functions <code>T.discr : T -&gt; Nat</code> and <code>T.get_0_1 : (t : T) -&gt; t.discr = 0 -&gt; A</code> (the first projection of the first variant of the inductive type <code>T</code>) which would compile to the good things, which you could use to implement more efficient and flexible variations on <code>match</code></p>",
        "id": 273858613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646247381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> It's certainly UB according to the lean compiler (it uses <code>csimp</code> lemmas and other things that rely on the general soundness of lean code), but I don't think it transmits that UB to the C code. My guess is that the optimization you are observing happens in lean (well, the IR trace indicates as much)</p>",
        "id": 273859113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646247578
    },
    {
        "content": "<p>Oh right, this optimization certainly happens on the Lean side.  Unreachable instructions that are not optimized away are compiled to panics.</p>",
        "id": 273860532,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1646248052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273856518\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I suspect externally enforcing the constraints would be a pain, because you'd end up with lots of unreachable branches. But if I can't get the nat indexed version to work I'll try that out</p>\n</blockquote>\n<p>If you have the regularity condition as a hypothesis, you can prove the unreachable branches are unreachable (and the equation compiler will often allow you to omit these branches)</p>\n</blockquote>\n<p>Is the lean4 equation compiler better in that regard than the lean 3 one? I remember having difficulty getting lean 3 to do it automatically on a different project. Might be user error though <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 273861996,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646248694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273856282\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> I think if you want fast vectors you should build on <code>Array</code>, not trees</p>\n</blockquote>\n<p>Yeah, heavily depends on the use case. For persistent use, trees will vastly outperform arrays, and for very large vectors it can be beneficial to not have a contiguous memory allocation and instead have some fragmentation. I'm aiming to replicate Scala's vector implementation, which is a wide radix-balanced finger tree or something (whatever that means). So these finger trees are just a step towards replicating that</p>",
        "id": 273862346,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646248855
    },
    {
        "content": "<p>Here are some examples of the equation compiler being helpful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_A</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">Foo.A</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">is_A</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">Foo.A</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"n\">Foo.A</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">Foo.B</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">Foo.C</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 273862427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646248896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273862346\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273856282\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> I think if you want fast vectors you should build on <code>Array</code>, not trees</p>\n</blockquote>\n<p>Yeah, heavily depends on the use case. For persistent use, trees will vastly outperform arrays, and for very large vectors it can be beneficial to not have a contiguous memory allocation and instead have some fragmentation. I'm aiming to replicate Scala's vector implementation, which is a wide radix-balanced finger tree or something (whatever that means). So these finger trees are just a step towards replicating that</p>\n</blockquote>\n<p>Naturally. Did you mean <em>persistent</em> vectors? One of the reasons FP languages rely so much on persistent data structures is that they do imperative ones badly, but I think lean is fairly good at native support for imperative data structures, and imperative data structures usually outperform persistent ones when persistence isn't a requirement</p>",
        "id": 273862854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646249064
    },
    {
        "content": "<p>In fact, I wonder whether <code>Array A</code> would be a better choice than <code>Digit A</code> in the finger tree implementation</p>",
        "id": 273863086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646249155
    },
    {
        "content": "<p>Totally agreed, I'm pretty impressed overall with lean 4 handling imperative code. Hoping to get some benchmarks today RE: how much faster Array is than this finger tree for ephemeral use</p>",
        "id": 273863327,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646249262
    },
    {
        "content": "<p>Personally, I would look to Rust to find data structures that match lean's requirements</p>",
        "id": 273863330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646249265
    },
    {
        "content": "<p>like, maybe B-trees are where it's at</p>",
        "id": 273863431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646249307
    },
    {
        "content": "<p>As an aside, is there a reason Array models a <code>List A</code> instead of <code>Vector A n</code>? Non-resizable native arrays would be super nice for some of my stuff :/</p>",
        "id": 273863529,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646249365
    },
    {
        "content": "<p>like I totally would use array if i could say <code>Array A 4</code> instead of <code>Digit A</code></p>",
        "id": 273863563,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646249383
    },
    {
        "content": "<p>That's the way it was in lean 3, and I don't have the whole story for what happened in lean 4. it's possible that the extra index causes bad code generation, but it's definitely annoying when <code>n</code> is supposed to be fixed or known externally</p>",
        "id": 273863914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646249487
    },
    {
        "content": "<p>Although I'm not sure that fixed length arrays would be a suitable substitute for <code>Digit A</code> since it can have length 1-4</p>",
        "id": 273864015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646249531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273863431\">said</a>:</p>\n<blockquote>\n<p>like, maybe B-trees are where it's at</p>\n</blockquote>\n<p>Agreed. I think long term the right approach is to have two collection hierarchies, one for persistent structures and one for ephemeral structures. But I kinda wish there were some way to enforce linear usage of ephemeral structures like you can in Rust.</p>\n<p>With the current status quo if you use an array persistently you just get hit with bad performance without any indication why...</p>",
        "id": 273864033,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646249542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273864015\">said</a>:</p>\n<blockquote>\n<p>Although I'm not sure that fixed length arrays would be a suitable substitute for <code>Digit A</code> since it can have length 1-4</p>\n</blockquote>\n<p>Fair point -- I assume Lean's arrays store their length, which I think means <code>Digit A</code> is faster &amp; more compact? Unclear</p>",
        "id": 273864192,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646249628
    },
    {
        "content": "<p>Lemme finish up this FingerTree implementation and then get some quick benchmarks of its performance against Array</p>",
        "id": 273864523,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646249766
    },
    {
        "content": "<blockquote>\n<p>With the current status quo if you use an array persistently you just get hit with bad performance without any indication why...</p>\n</blockquote>\n<p>You can use <code>dbgTraceIfShared</code> to detect non-persistent use</p>",
        "id": 273865634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646250242
    },
    {
        "content": "<p>I wonder if you can panic in a <code>dbgTraceIfShared</code> message</p>",
        "id": 273865733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646250297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> regarding finger trees in general, are you familiar with Claessen's <a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/koen-claessen/finger-trees.pdf\">paper</a>? It explains them quite nicely. I implemented it the other day <a href=\"https://github.com/Vtec234/lean4-bits/blob/0d9340285b208553e0e0b31acfb2c9097ff4546a/fingerTree.lean\">here</a>. The code is untested and unverified, thus possibly buggy. In case it is of any use to you, though, feel free to use any of it. (It does have the annoying universe bump.)</p>",
        "id": 273896552,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1646264346
    },
    {
        "content": "<p>Oh, that's awesome! The paper is really nice too, I think I'll go back and delete Digit 4 now that it's unnecessary <span aria-label=\"confetti\" class=\"emoji emoji-1f38a\" role=\"img\" title=\"confetti\">:confetti:</span></p>",
        "id": 273900933,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646266702
    },
    {
        "content": "<p>Preliminary speed results:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>           <span class=\"bp\">|</span> <span class=\"n\">Ephemeral</span>  <span class=\"bp\">|</span> <span class=\"n\">Persistent</span>\n<span class=\"n\">FingerTree</span> <span class=\"bp\">|</span> <span class=\"mi\">604</span>        <span class=\"bp\">|</span> <span class=\"mi\">1</span>\n<span class=\"n\">Array</span>      <span class=\"bp\">|</span> <span class=\"mi\">127</span>        <span class=\"bp\">|</span> <span class=\"mi\">39</span>\n</code></pre></div>\n<p>so around 5x as slow in the ephemeral case (which just pushes many elements and then pops them in order). I'm actually surprised it's not slower, given that these are not very wide trees. A much wider tree should narrow that gap quite a lot</p>",
        "id": 273905553,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646269345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273865733\">said</a>:</p>\n<blockquote>\n<p>I wonder if you can panic in a <code>dbgTraceIfShared</code> message</p>\n</blockquote>\n<p>implemented arrays with fixed length which panic if used persistently :p</p>",
        "id": 277842212,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649146795
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 277842522,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649146989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273858250\">said</a>:</p>\n<blockquote>\n<p>Apparently False.rec is UB already:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir.result</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"mi\">10</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">100</span> <span class=\"k\">then</span>\n    <span class=\"n\">nomatch</span> <span class=\"k\">show</span> <span class=\"n\">False</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">else</span>\n    <span class=\"mi\">42</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span> <span class=\"mi\">3</span> <span class=\"c1\">-- returns 42 although 10 * 3 &lt; 100</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I missed this thread. The Lean compiler interprets <code>False.rec</code> as unreachable code. I think this is a quite reasonable interpretation and enables useful optimizations. As you probably noticed, the compiler eliminates any <code>case</code> statement if all but one alternative is reachable. This is exactly what is happening here. The key problem here is that you are essentially saying \"trust me this is unreachable\", but this is not true. In my point of view, this is an incorrect use of <code>sorry</code>.</p>",
        "id": 277960642,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649203846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277842212\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/273865733\">said</a>:</p>\n<blockquote>\n<p>I wonder if you can panic in a <code>dbgTraceIfShared</code> message</p>\n</blockquote>\n<p>implemented arrays with fixed length which panic if used persistently :p</p>\n</blockquote>\n<p>We know that <code>dbgTraceIfShared</code> is far from ideal for debugging code that is accidentally performing nondestructive updates. We want to have better support for this in the future, but we do not want to modify the Lean kernel since this feature is only relevant to users that want to use Lean as a programming language. Our current plan is to modify the type checker in <code>Meta</code> that is outside the kernel. It would support annotations similar to the ones in Idris 2 (<a href=\"https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html\">https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html</a>). Unfortunately, this will not happen this year unless we get help from volunteers.</p>",
        "id": 277961983,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649205184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277960642\">said</a>:</p>\n<blockquote>\n<p>The Lean compiler interprets <code>False.rec</code> as unreachable code. I think this is a quite reasonable interpretation and enables useful optimizations. As you probably noticed, the compiler eliminates any <code>case</code> statement if all but one alternative is reachable. This is exactly what is happening here. The key problem here is that you are essentially saying \"trust me this is unreachable\", but this is not true. In my point of view, this is an incorrect use of <code>sorry</code>.</p>\n</blockquote>\n<p>By the way, in case my earlier comments didn't make it clear, I think there is no problem at all treating <code>False.rec</code> as undefined behavior to execute and optimizing in accordance with this. This is a very useful effect of having proofs in the source language. I was lamenting above that it doesn't lower to <em>C</em> undefined behavior, meaning that although you get lean-level optimizations you don't get any LLVM optimizations from the existence of a proof of false in the function (because the proofs are erased and any unoptimized unreachable branches are compiled to a runtime panic, which LLVM has to treat as having defined behavior).</p>",
        "id": 277966099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649209469
    },
    {
        "content": "<p>One way to assist with this would be to lower some <code>have</code> statements to <code>llvm.assume</code> or whatever produces that effect in C</p>",
        "id": 277966314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649209713
    },
    {
        "content": "<p>Thanks for clarifying, but I was confused by Gabriel's comment that <code>False.rec</code> is UB (undefined behavior) in Lean when its behavior is well defined (it is unreachable code). I think you two are using UB as \"the compiler is free to do whatever it wants\", correct?</p>",
        "id": 277967217,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649210647
    },
    {
        "content": "<p>yes</p>",
        "id": 277967434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649210936
    },
    {
        "content": "<p>this is UB as in C</p>",
        "id": 277967447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649210948
    },
    {
        "content": "<p>Even though <code>False.rec</code> has a specific implementation which prints a message and so on,  it is undefined behavior to call, which means that the program might not print that message even if you call it. This is what licenses optimizations like the 1-branch match example</p>",
        "id": 277967560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649211085
    },
    {
        "content": "<p>I view it a bit differently. <code>False.rec</code> is unreachable. The message is there only for users that are using <code>sorry</code> for stuff that is not really true. In the ideal (<code>sorry</code> free) world, it would be impossible to reach a <code>False.rec</code> at runtime.</p>",
        "id": 277967864,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649211440
    },
    {
        "content": "<p>If \"unreachable\" means \"the compiler knows it cannot be reached\", then that's what we would normally call undefined behavior. For example, <code>if i &lt; arr.size then arr[i] else panic</code> is a bounds checked array access, but <code>if i &lt; arr.size then arr[i] else unreachable</code> is not bounds checked (because the compiler will optimize the branch away)</p>",
        "id": 277968025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649211630
    },
    {
        "content": "<p>since the lean compiler will (in some cases) compile the second to the first (which is a valid lowering), it removes the undefined behavior before it gets to C, which means that LLVM won't get a chance to optimize that branch away (because it would not be legal to do so)</p>",
        "id": 277968112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649211757
    },
    {
        "content": "<p>Are you referring to the <code>Array.get!</code> implementation? The <code>else</code> branch there is definitely reachable.</p>",
        "id": 277968301,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649212006
    },
    {
        "content": "<p>In those two examples it doesn't matter which <code>arr[i]</code> we're talking about because inside the if it's definitely in bounds</p>",
        "id": 277968384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649212092
    },
    {
        "content": "<p>but if I had to make a parallel, the first one is <code>Array.get!</code> and the second one is <code>Array.get</code></p>",
        "id": 277968398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649212122
    },
    {
        "content": "<p>(<code>Array.get</code> isn't written like that because the <code>else unreachable</code> is superfluous, but you could rewrite it into such a form and my point is that <em>the compiler</em> is permitted to rewrite it back to eliminate the if statement)</p>",
        "id": 277968492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649212254
    },
    {
        "content": "<p>Not sure what you are suggesting anymore. Are you suggesting we change the implementation of <code>Array.get!</code>? If yes, to what?</p>",
        "id": 277968494,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649212256
    },
    {
        "content": "<p>No, both of the functions are fine. I'm talking about codegenning <code>unreachable</code> to something like <code>*NULL</code> which is known to C to be undefined behavior</p>",
        "id": 277968513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649212312
    },
    {
        "content": "<p>and possibly also removing bounds checks from <code>lean_array_fget</code> since they shouldn't be needed</p>",
        "id": 277968569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649212364
    },
    {
        "content": "<p>actually scratch that last part, looks like the bounds check is already under a debug flag</p>",
        "id": 277968592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649212417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277968569\">said</a>:</p>\n<blockquote>\n<p>and possibly also removing bounds checks from <code>lean_array_fget</code> since they shouldn't be needed</p>\n</blockquote>\n<p>It does not have any.</p>",
        "id": 277968596,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649212435
    },
    {
        "content": "<p>for example, I think that if you match on a three variant inductive where one of the variants is a <code>nomatch</code>, the lean compiler will still emit a three-way branch with an explicit <code>unreachable</code> in one branch, and then LLVM won't be able to reduce it to just a two-way branch even though it knows how to do so</p>",
        "id": 277968839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649212723
    },
    {
        "content": "<p>Yes, this seems useful in practice. <br>\nBTW, would be useful for users if we distinguish <code>False.rec</code> applications that are <code>sorry</code> (and user axioms) free from the ones that are not?</p>",
        "id": 277969175,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649213133
    },
    {
        "content": "<p>heh, how would we be able to demonstrate what UB looks like in that case? :)</p>",
        "id": 277969342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649213315
    },
    {
        "content": "<p>Probably it would be better to just have it be a global compiler option</p>",
        "id": 277969350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649213335
    },
    {
        "content": "<p>in debug, it should be a <code>panic</code> and in release it should be <code>unreachable</code>, and with a <code>set_option</code> you can pick how you want this function to compile</p>",
        "id": 277969383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649213390
    },
    {
        "content": "<ul>\n<li><code>False.rec</code> applications that are <code>sorry</code> free are treated as \"unreachable\" code in the Lean and LLVM compiler passes.</li>\n<li><code>False.rec</code> applications that contain <code>sorry</code> or depend on user axioms are treated as <code>panic \"unreachable\"</code> in all compiler passes. Extra: allow users to reduce this case to the first one using a compiler option.</li>\n</ul>",
        "id": 277969388,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649213397
    },
    {
        "content": "<p>it's hard to say what to do about user axioms. It wouldn't be nice to pessimize their code, they might have a good reason to, say, assume the correctness of their external register allocator or something, but it is also not nice if you actually hit UB because you will probably get a weird crash</p>",
        "id": 277969493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649213496
    },
    {
        "content": "<p>BTW, we currently don't have a solution for different code generation modes (debug, release, etc). We want to support that in the future, but we are not there yet.</p>",
        "id": 277969609,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649213638
    },
    {
        "content": "<p>Personally I think it's fine to treat it as UB even if it uses <code>sorry</code>; you don't want <code>sorry</code> MWE-ification to cause nonlocal changes to the compilation of a function</p>",
        "id": 277969646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649213644
    },
    {
        "content": "<p>How do you feel about the <code>panic</code>?</p>",
        "id": 277969769,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649213847
    },
    {
        "content": "<p>even if you don't have release/debug modes, you could still have a <code>set_option</code> to control this; I'm not sure what the default should be but I'm leaning toward <code>panic</code> by default</p>",
        "id": 277969838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649213889
    },
    {
        "content": "<p>I think people are more likely to not know what they are doing and stumble on it by accident (or on purpose) compared to folks who really want to eliminate bounds checks, and the panic message is good discoverability</p>",
        "id": 277969868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649213941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20a.20Type.201.20in.20forIn/near/277961983\">said</a>:</p>\n<blockquote>\n<p>Our current plan is to modify the type checker in <code>Meta</code> that is outside the kernel. It would support annotations similar to the ones in Idris 2 (<a href=\"https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html\">https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html</a>). Unfortunately, this will not happen this year unless we get help from volunteers.</p>\n</blockquote>\n<p>By this, do you mean essentially embedding a linear language in Lean via metaprogramming? Or would this be a linter that operates outside/separate from the compiler's typechecker?</p>",
        "id": 278056282,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649265172
    },
    {
        "content": "<p>(In either case, I'd be quite willing to help where I can, but I'll need to learn a lot before then...)</p>",
        "id": 278057073,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649265586
    },
    {
        "content": "<p>I just so happen to have been looking into linear types as well since this week so I'd definitely be in for that as well (with the same remark on learning of course^^)</p>",
        "id": 278057174,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1649265625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> </p>\n<blockquote>\n<p>By this, do you mean essentially embedding a linear language in Lean via metaprogramming? Or would this be a linter that operates <br>\noutside/separate from the compiler's typechecker?</p>\n</blockquote>\n<p>The goal was to encode the Idris2-like annotations in our <code>Expr</code> objects. It is not clear right not now what the best encoding is. We could try to use <code>Expr.mdata</code>, identity-like functions (i.e., the same approach we use for <code>optParam</code>), etc. Then, write a new <code>Meta.check</code> that also checks the new annotations. Just having this checker would be a big improvement. Then, when we move the rest of the compiler code to Lean, we make sure we don't lose the annotations in the compiler passes, and may even eventually emit code that does not need to check whether the RC = 1 or not before performing destructive updates.</p>",
        "id": 278108114,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1649295419
    },
    {
        "content": "<p>I have a question regarding the Idris 2 approach though. in this section <a href=\"https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html#erasure\">https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html#erasure</a> the author details how the compiler knows what to erase and what not to erase, in particular that all not explicitly denoted variables have multiplicity 0 by default (which makes sense of of course) but right now the Lean approach is to just automatically generate a regular implicit argument already so it would be a breaking change if done like Idris 2 right? The correct  way to go in Lean would probably be to be liberal about multiplicity bindings and instead bind with unrestricted multiplicity per default correct?</p>",
        "id": 278132458,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1649320486
    },
    {
        "content": "<p>FYI, <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> is planning to investigate the uniqueness typing part for his master thesis under my supervision. It's not clear to me yet whether this should also entail erasure, I'll leave that for Marc to find out!</p>",
        "id": 278152076,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649332566
    },
    {
        "content": "<p>Ah, we probably better leave it to Marc then^^</p>",
        "id": 278161206,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1649336890
    },
    {
        "content": "<p>(Personally, I'd be a big fan of some sort of inference mechanism that looks at the usage of the variable and automatically assigns the smallest possible multiplicity; so that parameters which only appear in types can be erased, etc.)</p>",
        "id": 278205338,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1649355464
    },
    {
        "content": "<p>That's just dead code/parameter elimination, which Lean already does. Multiplicity annotations are for when you cannot infer (and/or want to guarantee) this behavior, especially with higher-order functions.</p>",
        "id": 278215838,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1649360301
    }
]
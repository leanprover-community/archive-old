[
    {
        "content": "<p>Hey, I'm not sure if there's already a thread for discussing this, but I wanted to start talking about what we envision as the best experience for dependency management in Lean4.</p>\n<p>Some questions:</p>\n<ul>\n<li>Do we need to ensure all dependencies are on the same Lean version? If so, how do we ensure these dependencies are on the same Lean version, when each dependency may only have releases for a subset of all Lean versions?</li>\n<li>What should the expectation be for library authors in terms of releasing updates for new lean versions?</li>\n<li>Should we find ways to support targeting multiple Lean versions? This is a feature in other build management systems which can be useful for ensuring we can line up all dependencies' lean versions</li>\n</ul>",
        "id": 299834610,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663702663
    },
    {
        "content": "<p>I do think multiple target is a very feasible solution here, particularly because of the metaprogramming facilities. It'd be cool if in your Lakefile you gave the list of target lean versions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">target</span> <span class=\"bp\">...</span> <span class=\"o\">{</span>\n  <span class=\"bp\">...</span>\n  <span class=\"n\">leanVersions</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">2022</span><span class=\"bp\">-</span><span class=\"mi\">09</span><span class=\"bp\">-</span><span class=\"mi\">15</span><span class=\"o\">,</span>  <span class=\"mi\">2022</span><span class=\"bp\">-</span><span class=\"mi\">09</span><span class=\"bp\">-</span><span class=\"mi\">20</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>and then there was a <code>leanVersion</code> flag somewhere so you could have conditional declarations depending on the version</p>",
        "id": 300064187,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663810945
    },
    {
        "content": "<p>This would definitely not be easy to support tooling-wise (the language server would probably just run on one version for the purposes of development), but I think at least having Lake support it would be feasible?</p>",
        "id": 300064229,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663810996
    },
    {
        "content": "<blockquote>\n<p>What should the expectation be for library authors in terms of releasing updates for new lean versions?</p>\n</blockquote>\n<p>For lean4-cli, I try to ensure that the library is updated on the same day it was broken on, and I only release updates for nightlies where the library had to be patched. If I was depending on something other than Lean 4 (I don't), I'd probably also try to ensure the same thing if a library update broke my library in-between the last nightly update of my library and now.</p>",
        "id": 300205268,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1663866223
    },
    {
        "content": "<p>Do you have some system in place to know when nightly breaks the library? (a daily CI job or something?)</p>",
        "id": 300217089,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663870098
    },
    {
        "content": "<p>Yup, it PMs me on Zulip: <a href=\"https://github.com/mhuisi/lean4-cli/blob/main/.github/workflows/check_nightly.yml\">https://github.com/mhuisi/lean4-cli/blob/main/.github/workflows/check_nightly.yml</a></p>",
        "id": 300220613,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1663871484
    },
    {
        "content": "<p>Ahh, it builds the nightly on a separate branch. Seems like it works well at the current pace of Lean updates :D</p>",
        "id": 300224611,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663872837
    },
    {
        "content": "<p>This also suggests one potential expectation for libraries, which is that the newest git version should successfully build on the newest git versions of all its dependencies and the latest nightly version of lean:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>&lt;update toolchain to latest nightly&gt;\nlake update\nlake build <span class=\"c1\"># should return 0</span>\n</code></pre></div>\n<p>But of course that also expects libraries to update as frequently as daily, which seems impractical (particularly for libraries with many dependencies).</p>",
        "id": 300225060,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663872968
    },
    {
        "content": "<p>I'm getting the sense that Lake will need some way to pull revisions from git that aren't the latest, which I think would require either embedding that information in lakefiles somehow, or having an external crates.io-esque package registry that maintains a mapping of lean versions to package revisions</p>",
        "id": 300226069,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1663873304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/300224611\">said</a>:</p>\n<blockquote>\n<p>Ahh, it builds the nightly on a separate branch. Seems like it works well at the current pace of Lean updates :D</p>\n</blockquote>\n<p>The separate branch is mostly so that folks can track the lean4-cli version that works with the most recent nightly in their lakefile without having to edit it (if they want to), similar to how <code>leanprover/lean4:nightly</code> refers to the most recent Lean 4 nightly. Meanwhile, <code>main</code> tracks the most recent milestone / full release for Lean 4.</p>",
        "id": 300227939,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1663873928
    },
    {
        "content": "<p>Does it only push to the branch if the build succeeds? I guess that makes sense</p>",
        "id": 300596503,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664066897
    },
    {
        "content": "<p>If the build fails, it notifies me on Zulip, I fix it, and then I push a new version for the new nightly.</p>",
        "id": 300668204,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1664122943
    },
    {
        "content": "<p>Based on what we've discussed so far, I think when updating dependencies we want to ask the question,</p>\n<blockquote>\n<p>What is the newest revision of &lt;dependency&gt; that builds successfully on &lt;lean version&gt;?</p>\n</blockquote>\n<p>Marc's been successful at keeping lean4-cli up to date, so that the newest git revision is always the answer to that question. But for less frequently updating repositories, it would be good to have some way to query for this.</p>\n<p>Maybe <a href=\"https://xubaiw.github.io/reservoir-index/\">Reservoir</a> can be modified to have HTTP GET endpoints to query this information?</p>",
        "id": 300701890,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1664150633
    },
    {
        "content": "<p>another thought to add to the perfect world dependency management: automated AST refactoring for breaking changes.</p>\n<p>if you make a breaking change in your library, you can add some meta code somewhere that tells lake how to automatically refactor user code around that breaking change. fearless refactors galore!</p>",
        "id": 306378375,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1666849558
    },
    {
        "content": "<p>(Then when users run <code>lake update</code> or whatever, all the update scripts for those versions are executed on the project's code)</p>",
        "id": 306378493,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1666849627
    },
    {
        "content": "<p>I think I'd like to work on ^ soon. I've come to the conclusion that the perfect world would be Lean libraries where CI automatically PRs updates so that we can have a very quick turnaround updating long chains of library dependencies.</p>\n<p>LMK if you'd want to collaborate on this! (also looking for good name ideas, something to do with lakes/water bodies would be great)</p>",
        "id": 318918850,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672619302
    },
    {
        "content": "<p>One thing I've been wondering is: what if Lake becomes more restrictive?</p>\n<p>For example, it could forbid stating direct dependencies if they're already present as transitive dependencies. As a more precise example, I wouldn't be allowed to require <code>Std</code> on my lakefile if I'm already requiring <code>Mathlib</code>, since <code>Mathlib</code> already requires <code>Std</code>. Then, two or more dependencies can coexist iff there's no conflict on their manifests (different versions for some package).</p>\n<p>This is the most sane behavior I can think of that doesn't use semantic versioning.</p>",
        "id": 321998689,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674031648
    },
    {
        "content": "<p>Maybe. I'm not sure how we'd avoid constantly having conflicts in minor versions. Rust cargo can handle packaging with <em>multiple different versions</em> of a library in the same code base, but I suspect that would require support from the compiler or something.</p>",
        "id": 321999945,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674032061
    },
    {
        "content": "<p>Cargo infra is on another level because they can do much more with a dedicated platform for hosting packages. So they can use semantic versioning and allow version intervals</p>",
        "id": 322000544,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674032303
    },
    {
        "content": "<p>(.. Perhaps we can do the same? :P The idea has been floated, and Isabelle and Coq both have their own centralized package platform!)</p>",
        "id": 322001335,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674032641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/321999945\">said</a>:</p>\n<blockquote>\n<p>Maybe. I'm not sure how we'd avoid constantly having conflicts in minor versions.</p>\n</blockquote>\n<p>The issue is that the conflicts already exist and pass silently until we get a failure when building. It can become highly unpredictable, because you don't know which version of a transitive dependency you may download, if two dependencies require different versions of the same package. You're lucky when the version that is downloaded is compatible with all packages that require it.</p>\n<p>Right now, filling out requirements and calling <code>lake build</code> is pretty much a prayer</p>",
        "id": 322001931,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674032852
    },
    {
        "content": "<p>Idea: <code>lake update</code> would have the restrictive behavior I mentioned above and <code>lake update!</code> would allow room for luck, if you're eager</p>",
        "id": 322003834,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674033525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/321998689\">said</a>:</p>\n<blockquote>\n<p>One thing I've been wondering is: what if Lake becomes more restrictive?</p>\n<p>For example, it could forbid stating direct dependencies if they're already present as transitive dependencies. As a more precise example, I wouldn't be allowed to require <code>Std</code> on my lakefile if I'm already requiring <code>Mathlib</code>, since <code>Mathlib</code> already requires <code>Std</code>. Then, two or more dependencies can coexist iff there's no conflict on their manifests (different versions for some package).</p>\n<p>This is the most sane behavior I can think of that doesn't use semantic versioning.</p>\n</blockquote>\n<p>I don't see how that will help. Basically every package will have an std4 dependency, so as soon as you want to combine two of these packages you're back to square one.</p>",
        "id": 322004491,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674033725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/322001335\">said</a>:</p>\n<blockquote>\n<p>(.. Perhaps we can do the same? :P The idea has been floated, and Isabelle and Coq both have their own centralized package platform!)</p>\n</blockquote>\n<p>I suspect this solution won't be seriously considered until the next stable release of Lean 4, but I could be wrong!</p>",
        "id": 322004522,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674033735
    },
    {
        "content": "<p>I suspect that without semver we're kinda stuck. We need some way of determining compatibility across version intervals, or else it will always be too brittle.</p>",
        "id": 322005274,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674033961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I think knowing the exact source of incompatibility is already of great help</p>",
        "id": 322005322,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674033967
    },
    {
        "content": "<p>In the dependently typed world semantic versioning will be basically trivial, i.e., all changes are breaking</p>",
        "id": 322005394,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674033988
    },
    {
        "content": "<p>I think you cannot expect to really gain anything from it, and you would have to use a more conventional method, e.g., releases every N months</p>",
        "id": 322005494,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/322005394\">said</a>:</p>\n<blockquote>\n<p>In the dependently typed world semantic versioning will be basically trivial, i.e., all changes are breaking</p>\n</blockquote>\n<p>I disagree. While that might be true for mathlib, many other packages do behave well wrt major, minor and patch versioning</p>",
        "id": 322005732,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674034102
    },
    {
        "content": "<p>Either that or you make a much more fine-grained analysis of what is actually used, but I'm not convinced this is worthwhile</p>",
        "id": 322005779,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034117
    },
    {
        "content": "<p>The only obvious breaking change is a bump on the Lean toolchain. Every other change can be versioned carefully and precisely</p>",
        "id": 322005923,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674034173
    },
    {
        "content": "<p>I also suspect that we can have solid tooling for handling breaking changes, i.e. with some amount of automation to patch downstream breaks... but that's at best an active area of research and at worst impossible :)</p>",
        "id": 322006323,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674034293
    },
    {
        "content": "<p>Well Lean exposes the whole environment via tactics, so any change could break something.</p>",
        "id": 322006782,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034436
    },
    {
        "content": "<p>More seriously, Lean doesn't really offer much in the way of implementation hiding.</p>",
        "id": 322006945,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034485
    },
    {
        "content": "<p>IMO semantic versioning is a poor approach which is mainly justified by the fact that, in an untyped language, anything else is even worse.</p>",
        "id": 322007238,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034566
    },
    {
        "content": "<p>At some point sooner or later you're going to reinvent package distributions (e.g., Stackage).</p>",
        "id": 322007426,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/322005779\">said</a>:</p>\n<blockquote>\n<p>Either that or you make a much more fine-grained analysis of what is actually used, but I'm not convinced this is worthwhile</p>\n</blockquote>\n<p>I think you would have a different perspective if you were managing a non-trivial graph of libs that aren't focused on theorem proving. Yes, adding a new simp lemma can be a breaking change. But we very rarely use those</p>",
        "id": 322007437,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674034635
    },
    {
        "content": "<p>I mean, I guess we could ditch semver and just express compatibility in terms of git commit ranges. Seems slightly less user-friendly, but definitely an expression of the \"every change is a breaking change\" reality</p>",
        "id": 322007511,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674034657
    },
    {
        "content": "<p>I have far more experience in this than I would like in the Haskell world</p>",
        "id": 322007539,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034665
    },
    {
        "content": "<p>how do haskell packages manage noncompatibility?</p>",
        "id": 322007739,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674034721
    },
    {
        "content": "<p>People who want to get stuff done use Stackage, while people who like to argue about stuff use version ranges</p>",
        "id": 322007937,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034785
    },
    {
        "content": "<p>That's obviously just my opinion, but seriously I have seen huge amounts of time wasted on these questions.</p>",
        "id": 322008111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674034839
    },
    {
        "content": "<p>I don't think it's time wasted though. I think it's time wasted when you're fighting against incompatibilities that are too hard to track</p>",
        "id": 322008891,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674035084
    },
    {
        "content": "<p>It seems the idea with Stackage is to have someone do the work of tracking down incompatibilities once, instead of everyone having to work it out on their own?</p>",
        "id": 322009007,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674035128
    },
    {
        "content": "<p>That's why everyone should just agree to be on e.g. the March 2023 version of everything, until June</p>",
        "id": 322009045,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674035144
    },
    {
        "content": "<p>If you need to be on the bleeding edge of one of your external dependencies, you might need to fork things for a bit to make everything compatible. I think the lakefile is already expressive enough to support that.</p>",
        "id": 322009281,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674035218
    },
    {
        "content": "<p>I can't see that working for a community that's large enough</p>",
        "id": 322009776,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674035380
    },
    {
        "content": "<p>Because a breaking change would trigger a wave of fixes and everyone would have to be extremely agile to provide the next version so other people can fix the next packages in the dependency graph</p>",
        "id": 322011185,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674035875
    },
    {
        "content": "<p>If it's on a cycle of a month or three months or something, it probably gives most packages sufficient time to update. But that's a pretty slow cycle.</p>",
        "id": 322011846,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674036104
    },
    {
        "content": "<p>The package distribution maintainers can also just fix things in the package distribution version (that's how OS distributions work).</p>",
        "id": 322011987,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674036145
    },
    {
        "content": "<p>What are the breaking changes in Lean 4? I know:</p>\n<ul>\n<li>Changes in the toolchain</li>\n<li>Changes in type signatures</li>\n<li>Changes on declaration names</li>\n<li>Changes on file placements </li>\n<li>Changes on <code>simp</code> theorems</li>\n<li>Changes on instances</li>\n</ul>",
        "id": 322012053,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674036171
    },
    {
        "content": "<p>And all definitions</p>",
        "id": 322012328,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674036253
    },
    {
        "content": "<p>Unless you hide stuff behind <code>opaque</code>/<code>implementedBy</code>, I guess</p>",
        "id": 322012397,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674036276
    },
    {
        "content": "<p>also changes in comments and line lengths, since positions of declarations are in the environment</p>",
        "id": 322012683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036366
    },
    {
        "content": "<p>in fact, changes to documentation regularly break lean tests, so that's not even a straw man</p>",
        "id": 322012746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036395
    },
    {
        "content": "<p>Right so in practice you need to work \"modulo something\", but you might not be able to get people to agree on what that \"something\" is ...</p>",
        "id": 322012804,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674036414
    },
    {
        "content": "<p>Why is that a breaking change? Why would a change in documentation break something?</p>",
        "id": 322012955,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674036457
    },
    {
        "content": "<p>I mean, I know it's enough to invalidate the use of the olean file, but not the source, right?</p>",
        "id": 322013112,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674036501
    },
    {
        "content": "<p>technically, in the sense \"there exists a lean program that would break\", basically everything is a breaking change</p>",
        "id": 322013135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036508
    },
    {
        "content": "<p>you can read declaration locations out of the environment, that's how the server's go-to-def works</p>",
        "id": 322013241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036543
    },
    {
        "content": "<p>you can also read the contents of docstrings, and there are lean tests that do so</p>",
        "id": 322013316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036570
    },
    {
        "content": "<p>I wouldn't be surprised if source file hashes are in the environment too</p>",
        "id": 322013510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036632
    },
    {
        "content": "<p>Is it converging to a state where people have to manage their own separate forks for pretty much everything?</p>",
        "id": 322013684,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674036693
    },
    {
        "content": "<p>That said, \"is a breaking change\" != \"breaks a majority of packages\"... We don't have enough experience yet with the ecosystem to know how much breakage to expect every time you update a dependency.</p>",
        "id": 322013690,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674036696
    },
    {
        "content": "<p>IIRC Rust has a good discussion about what \"breaking change\" means somewhere which in particular does not define it as \"every observable behavior of the code\" which is what my example amounts to</p>",
        "id": 322013927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036769
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/1105-api-evolution.html\">https://rust-lang.github.io/rfcs/1105-api-evolution.html</a></p>",
        "id": 322014113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036830
    },
    {
        "content": "<p>\"every observable <em>compiletime</em> behavior\" :)</p>",
        "id": 322014115,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674036831
    },
    {
        "content": "<p>Probably the correct reaction is that those tests are broken, but then it's still an empirical fact that they exist.<br>\nSo the conclusion is that if you define \"breaking change\" in a reasonable way, you don't actually have whatever guarantee you think you are getting from semver, even in practice and not just in theory.</p>",
        "id": 322014126,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674036834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/322014115\">said</a>:</p>\n<blockquote>\n<p>\"every observable <em>compiletime</em> behavior\" :)</p>\n</blockquote>\n<p>Unfortunately, since lean is a dependent type theory most behaviors visible at runtime are also visible at compiletime (and even more so because in addition to a DTT it also has a comprehensive whitebox API to the elaborator itself)</p>",
        "id": 322014442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674036934
    },
    {
        "content": "<p>Tests, especially the kinds we use, are a bad example of a legitimate downstream user of a package</p>",
        "id": 322014443,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674036934
    },
    {
        "content": "<p>although, arguably changes in runtime behavior are also semver-breaking</p>",
        "id": 322014887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674037074
    },
    {
        "content": "<p>There is a big overlap of this discussion and improving compile times by build short-circuiting. If we don't import definition bodies by default, and track docstrings and source locations outside of the environment in a server-exclusive part (not sure if we have cross-module <code>inherit_doc</code>s...), we're in a much better position to define \"<em>reasonably</em> breaking change\".</p>",
        "id": 322015460,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674037251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Perfect.20world.22.20dependency.20management/near/322012683\">said</a>:</p>\n<blockquote>\n<p>also changes in comments and line lengths, since positions of declarations are in the environment</p>\n</blockquote>\n<p>Is there an alternative solution? Why isn't there a separate process that analyzes comments etc?</p>",
        "id": 322015548,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674037289
    },
    {
        "content": "<p>it is convenient to have that information available for metaprogramming, I think it would be a regression to remove it</p>",
        "id": 322015736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674037345
    },
    {
        "content": "<p>I still don't see how changing a comment can break a client user</p>",
        "id": 322016341,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674037540
    },
    {
        "content": "<p>And heck, if that's the case, it's a pretty serious design decision</p>",
        "id": 322016652,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674037629
    },
    {
        "content": "<p>Concretely, suppose that the client imports dependency <code>EvilPackage</code> that imports your library. <code>EvilPackage</code> has an <code>#eval guard ((docString ``YourLibrary.foo).length = 37)</code> in it, so when you change the doc string <code>EvilPackage</code> and the client build break</p>",
        "id": 322016772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674037666
    },
    {
        "content": "<p>Lean has a very open metaprogramming model, you can do almost anything. I think we need to own that instead of trying to erect walls to mostly stop stuff from leaking</p>",
        "id": 322017031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674037739
    },
    {
        "content": "<p>In particular, I think that <code>EvilPackage</code> should be regarded as a bad citizen in this scenario, and <code>YourLibrary</code> made a non-breaking change</p>",
        "id": 322017179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674037789
    },
    {
        "content": "<p>Right, so in order to own such freedom we need appropriate warning tools</p>",
        "id": 322017338,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674037826
    },
    {
        "content": "<p>I think that comes down to having guidelines along the lines of \"don't make your program's compilation depend on the bodies of opaque declarations, or the positions or docstrings of declarations\"</p>",
        "id": 322017490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674037891
    },
    {
        "content": "<p>That's one thing, but I am also motivated to revamp my initial idea. I think Lake should warn the user when:</p>\n<ul>\n<li>Requiring a package that's already required by another dependency</li>\n<li>Requiring two or more packages with incompatible dependencies in their manifests</li>\n</ul>",
        "id": 322018123,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674038086
    },
    {
        "content": "<p>I think requiring no diamonds is too strict, but requiring a package twice with different commits sounds like a great cause for warning</p>",
        "id": 322018347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038150
    },
    {
        "content": "<p>It's just a warning, not a block</p>",
        "id": 322018683,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674038246
    },
    {
        "content": "<p>even saying that diamonds are a warning is too strict because warnings should ideally be actionable and there are normal situations which inevitably lead to diamonds</p>",
        "id": 322018895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038317
    },
    {
        "content": "<p>The example that Sebastian gave is one of them, suppose you have A and B that both depend on Std and then C depends on A and B (and hence Std transitively, twice)</p>",
        "id": 322019074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038365
    },
    {
        "content": "<p>Maybe it should be an \"info\"</p>",
        "id": 322019075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1674038365
    },
    {
        "content": "<p>If both packages are using the same version of Std then it isn't even a bad situation and no errors are expected</p>",
        "id": 322019278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038405
    },
    {
        "content": "<p>Diamonds are fine as long as they have matching manifests. That's why I said \"incompatible manifests\"</p>",
        "id": 322019342,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674038428
    },
    {
        "content": "<p>it only becomes a potential problem when lake decides to deliberately compile a dependency with a different commit than the manifest says</p>",
        "id": 322019484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038456
    },
    {
        "content": "<p>and in that case you could give a warning along with the compile error</p>",
        "id": 322019561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038482
    },
    {
        "content": "<p>or a warning even if there is no error, perhaps</p>",
        "id": 322019603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038496
    },
    {
        "content": "<p>But that's flaky. A warning would be welcome</p>",
        "id": 322019773,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674038530
    },
    {
        "content": "<p>There are several very slow moving packages that don't break over long periods though, and it is possibly too much to ask them to update all the time when they are very compatible</p>",
        "id": 322019828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038552
    },
    {
        "content": "<p>If they are slow then they will be at the same commit on multiple packages that import them</p>",
        "id": 322020183,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674038650
    },
    {
        "content": "<p>And no warning would be raised</p>",
        "id": 322020222,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674038663
    },
    {
        "content": "<p>The burden isn't on the back of slow and compatible packages. It's on the back of whoever ensembles packages with potentially incompatible dependencies</p>",
        "id": 322020461,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674038746
    },
    {
        "content": "<p>yes, but for example <code>Unicode</code> (which is slow moving) might import <code>Std</code> (which is relatively fast moving but backward compatible) and a downstream dependency like <code>Mathlib</code> (which is fast moving) also wants bleeding edge <code>Std</code>, in addition to an old but compatible version of <code>Unicode</code> that imports an old version of <code>Std</code></p>",
        "id": 322020487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038758
    },
    {
        "content": "<p>in this case it works best to just ignore the version of <code>Std</code> that <code>Unicode</code> is recommending, because it works on latest <code>Std</code> as well, but the only way to reflect this with perfect matching at all times would be to frequently bump <code>Unicode</code> with the only change being a <code>Std</code> bump</p>",
        "id": 322020791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674038867
    },
    {
        "content": "<p>You say \"best\" because you know beforehand that those are backward compatible</p>",
        "id": 322021399,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674039021
    },
    {
        "content": "<p>yes</p>",
        "id": 322021424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674039029
    },
    {
        "content": "<p>the question is how to reflect this sensibly</p>",
        "id": 322021452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674039037
    },
    {
        "content": "<p>Alright, warnings on build errors look like a reasonable step. Or a <code>lake check</code> that would warn the user about any of those sources of danger, including diamonds</p>",
        "id": 322022116,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674039210
    },
    {
        "content": "<p>A proposal for improvement over status quo:<br>\n(1) Some centralized record akin to Stackage, which tracks the set of packages that compile on each nightly Lean release<br>\n(2) Lake support for updating your project to the latest nightly stack on which all your dependencies compile<br>\n(3) Something akin to Marc Huisinga's auto-update bot that tries to build a package on each nightly-whatever stack (once all its dependencies successfully build on the stack), so that stable packages require almost no manual work to keep updated.</p>",
        "id": 322024659,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674039954
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 322024671,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1674039957
    },
    {
        "content": "<p>(zulip race condition! <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span>)</p>",
        "id": 322025002,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1674040032
    }
]
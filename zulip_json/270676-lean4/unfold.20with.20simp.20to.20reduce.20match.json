[
    {
        "content": "<p>I'm having trouble designing definitions that unfold at the correct time with <code>simp</code>. My current understanding is that it unfolds definitions marked with <code>@[simp]</code> or mentioned explicitly; and I feel like I'm really missing the match-simplifying logic of Coq. I have some functions manipulating trees, and I keep running situations like these:</p>\n<ul>\n<li>With <code>@[simp]</code> on the function, everything gets expanded even when the argument is symbolic, which renders the goal unreadable and makes it hard to use high-level lemmas.</li>\n<li>Without it, anytime the function is used to compute with some known or partially-known argument it needs to be named manually in <code>simp [function...]</code>, including its sometimes internal subfunctions, which is extremely cumbersome.</li>\n<li>This also happens with Lean definitions, so instead of unfolding my function I end up unfolding it, plus subfunctions, plus <code>List.foldr</code>, plus <code>bind</code> to expose the monad-specific bind, ...</li>\n</ul>\n<p>I've played around with a simp extension to make this easier, but to fully resolve calls to my functions with known arguments it still unfolds generic definitions like <code>bind</code> and <code>pure</code>, which feels really bad.</p>\n<p>Coq's <code>simpl</code> unfolds definitions when it exposes a reducible <code>match</code> and unfolds typeclass operators when the instance is resolved, which would solve my current problem. Is there a way to approach this behavior? Was it a particular design choice to not do this with <code>simp</code>? How does the Lean library usually handle the dual symbolic/computational use of its functions?</p>",
        "id": 277412948,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1648817792
    },
    {
        "content": "<p>Note that <code>simpl</code> and <code>simp</code> are very different beasts. In Coq, <code>simpl</code> is used to reduce terms, and it preserves definitional equality.<br>\n<code>simp</code> is inspired by Isabelle's <code>simp</code>, and it is essentially a rewriting engine. The resulting term is not necessarily definitionally equal to the input term, and <code>simp</code> produces a proof that the input/output is equal.<br>\nThat being said, I have been annoyed by the same behaviors you have described. We can add a flag to <code>simp</code>. It can't be the default behavior because it would create problems for the Mathlib porting efforts. It is worth discussing with other users whether the behavior above is desirable, and can be one day the default one.</p>",
        "id": 277414242,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648818328
    },
    {
        "content": "<p>Thank you for clarifying, this explains why <code>simp</code> can often be used instead of <code>rw</code> (which is really convenient IMO). A flag or even a different reduction-oriented tactic would be fine I think, without risking to break existing code.</p>\n<p>I fear Lean's internals are still too obscure for me to attempt to write it, but I'm happy to give it a try if someone could point me in the general direction.</p>",
        "id": 277415754,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1648819040
    },
    {
        "content": "<p>I think it makes sense to have a tactic dedicated to do careful unfolding, with a nice default behavior and a lot of options. This is useful but very different from what we expect from <code>simp</code> coming from Lean 3.</p>",
        "id": 277416945,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1648819541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> Thanks for offering. I think this feature is not a good match for new contributors. There are many details, and complications generated by Lean's simpler kernel. For example, even structurally recursive definitions are encoded using recursors in Lean. </p>\n<p>I am impressed by your messages. If you are interested in contributing to the code base, please tell us the what kind of coding you like, and we can try to find a match.</p>",
        "id": 277421409,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648821275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I see, thanks. I'll keep the hack for now and watch for possible updates. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>For context, I'm working on a research project modeling language semantics using Lean for a couple of months. I'm completely new to it so I'm not sure I can be of much help within this period, but since I'm getting help and everyone's time here it feels only right to try and contribute in return, eg. by solving my own problems.</p>\n<p>Now that I think about it, maybe I can contribute to some documentation in the longer run. I understand the tutorials and manual for Lean 4 are still incomplete, with more experience I could probably help out there?</p>",
        "id": 277424210,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1648822425
    },
    {
        "content": "<p>I will echo what has been said above: this would be a useful tactic, but it's not <code>simp</code>. It sounds similar to the <code>cbv</code> tactic (also in Coq), something that does definitional reduction using smart unfolding lemmas. In lean 3 you can kind of get a similar effect using <code>simp!</code> (which uses all equation lemmas as simp lemmas), and over time the <code>norm_num</code> tactic has turned into that kind of evaluator (although it performs less well on the pure type theory stuff like reducing recursors and lambdas)</p>",
        "id": 277425424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648822939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> Thanks for sharing.</p>\n<blockquote>\n<p>Now that I think about it, maybe I can contribute to some documentation in the longer run. I understand the tutorials and manual for Lean 4 are still incomplete, with more experience I could probably help out there?</p>\n</blockquote>\n<p>Yes, help with the documentation is welcome :)</p>",
        "id": 277425841,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648823106
    },
    {
        "content": "<p>It would probably work fairly well to build this tactic on top of the <code>simp</code> backend though, even if it's a different frontend. It just needs to mix bits of <code>whnf</code> with <code>simp</code>-traversal (and it should not be restricted to defeq reductions because too many functions are well-founded-recursive and would not reduce well by defeq)</p>",
        "id": 277425900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648823132
    }
]
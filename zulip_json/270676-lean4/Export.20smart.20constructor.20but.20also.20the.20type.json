[
    {
        "content": "<p>In <code>X.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">structure</span> <span class=\"n\">Name</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isIdChar</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x.isAlphanum</span> <span class=\"bp\">||</span> <span class=\"s2\">\"_.+-*/</span><span class=\"se\">\\\\</span><span class=\"s2\">^~=&lt;&gt;!?@#$%&amp;|:'`\"</span><span class=\"bp\">.</span><span class=\"n\">data.elem</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkName</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">xs'</span> <span class=\"o\">:=</span> <span class=\"n\">xs.data</span>\n  <span class=\"k\">if</span> <span class=\"n\">xs'.length</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"bp\">.</span><span class=\"n\">none</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">if</span> <span class=\"n\">List.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">isIdChar</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"n\">true</span> <span class=\"n\">xs.data</span> <span class=\"k\">then</span>\n      <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">{}</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">.</span><span class=\"n\">none</span>\n</code></pre></div>\n<p>in <code>Main.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">X</span>\n<span class=\"kn\">open</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sameName</span> <span class=\"o\">(</span><span class=\"n\">_n₁</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_n₂</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"s2\">\"Україна\"</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n</code></pre></div>\n<p>This fails because  Main can't refer to type Name. However, if I drop <code>private</code>, then I can construct an \"invalid\" type <code>Name \"Україна\"</code>.</p>\n<p>How would you approach this tradeoff?</p>",
        "id": 298828483,
        "sender_full_name": "cognivore",
        "timestamp": 1663180735
    },
    {
        "content": "<p>You can use a <code>private</code> constructor.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Name</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"kn\">private</span> <span class=\"n\">mk</span> <span class=\"o\">::</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n</code></pre></div>\n<p>You may also tag <code>val</code> as <code>private</code> if you want. <br>\nBTW, I just pushed a fix for the <code>{ .. }</code> since it was not checking whether the constructor was private or not.<br>\nIt is also important to keep in mind that meta-programming can be used to access <code>private</code> names.</p>",
        "id": 298834043,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663182627
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/commit/ef9127487ad9ed4ffc5dea4694f24a5a7fa820c4\">https://github.com/leanprover/lean4/commit/ef9127487ad9ed4ffc5dea4694f24a5a7fa820c4</a></p>",
        "id": 298834161,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663182669
    },
    {
        "content": "<p>So is the idea private fields/constructors should not be accessible unless you manually write a <code>Expr.const `_private.. ..</code>?  There are so many ways around it that I always thought of <code>private</code> as more of a namespacing thing (like <code>protected</code>), and we certainly use it that way in core (to hide auxiliary definitions from the global namespace).</p>\n<p>Around the private constructor:</p>\n<ul>\n<li><code>⟨..⟩</code></li>\n<li><code>{..}</code> (you've already fixed that one)</li>\n<li><code>by constructor</code></li>\n</ul>\n<p>Around the private projections:</p>\n<ul>\n<li><code>let ⟨val⟩ := x; val</code></li>\n<li><code>by cases val; assumption</code></li>\n</ul>",
        "id": 298837074,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663183702
    },
    {
        "content": "<blockquote>\n<p>So is the idea private fields/constructors should not be accessible unless you manually write a Expr.const `_private.. ..?  </p>\n</blockquote>\n<p>Yes, the goal is to support scenarios like the one <span class=\"user-mention\" data-user-id=\"507516\">@cognivore</span> described.</p>\n<blockquote>\n<p>There are so many ways around it that I always thought of private as more of a namespacing thing (like protected), and we certainly use it that way in core (to hide auxiliary definitions from the global namespace).</p>\n</blockquote>\n<p>I will fix them. I thought I had fixed <code>{..}</code> in the past, and I was surprised when it did not work this morning.</p>\n<blockquote>\n<p>Around the private constructor: ⟨..⟩</p>\n</blockquote>\n<p>This is one it is easy to fix.</p>\n<blockquote>\n<p>by constructor</p>\n</blockquote>\n<p>Not sure about this one. The scenarios I had in mind are for people using Lean as a programming language. If people start using the tactic framework for coding we may want to support this one too. </p>\n<p>Similar for projections.</p>",
        "id": 298852286,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663189818
    },
    {
        "content": "<p>Just to add on what Gabriel said: Although we can maybe patch some holes in being able to peer through <code>private</code>, I think you should not ever expect it to become as air tight as privacy in ML or Rust because the kernel / defeq can see through privacy. You should use <code>opaque</code> if you want to block this, but be aware that <code>opaque</code> is not scope-sensitive, so you have to wrap everything behind the privacy barrier in a structure which is then passed to <code>opaque</code>. See for example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FloatSpec#src\">src4#FloatSpec</a>.</p>\n<p>For this particular pattern (using <code>private</code> to uphold invariants), there is a superior solution which is simply to put the invariants in the type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isIdChar</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x.isAlphanum</span> <span class=\"bp\">||</span> <span class=\"s2\">\"_.+-*/</span><span class=\"se\">\\\\</span><span class=\"s2\">^~=&lt;&gt;!?@#$%&amp;|:'`\"</span><span class=\"bp\">.</span><span class=\"n\">data.elem</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Name</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"kn\">private</span> <span class=\"n\">mk</span> <span class=\"o\">::</span>\n  <span class=\"n\">length_ne_zero</span> <span class=\"o\">:</span> <span class=\"n\">x.length</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n  <span class=\"n\">all_isIdChar</span> <span class=\"o\">:</span> <span class=\"n\">x.data.all</span> <span class=\"n\">isIdChar</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkName</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">xs'</span> <span class=\"o\">:=</span> <span class=\"n\">xs.data</span>\n  <span class=\"k\">if</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">xs'.length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">none</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">if</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">xs.data.all</span> <span class=\"n\">isIdChar</span> <span class=\"k\">then</span>\n      <span class=\"n\">some</span> <span class=\"o\">{</span> <span class=\"n\">length_ne_zero</span> <span class=\"o\">:=</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">all_isIdChar</span> <span class=\"o\">:=</span> <span class=\"n\">h₂</span> <span class=\"o\">}</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">none</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">X</span>\n<span class=\"kn\">open</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sameName</span> <span class=\"o\">(</span><span class=\"n\">_n₁</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_n₂</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"s2\">\"Україна\"</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span> <span class=\"c1\">-- fail</span>\n</code></pre></div>\n<p>That way, even if the user manages to get past the privacy barrier using tricks, they still have to prove the same invariants that your smart constructor did. In fact, with this pattern it's probably not even necessary to hide the constructor - users are allowed to construct the thing directly as long as they prove the invariants, and the smart constructor is available if they don't want to.</p>",
        "id": 298892748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663208994
    }
]
[
    {
        "content": "<p>On the PA SE I asked <a href=\"https://proofassistants.stackexchange.com/questions/1115/how-usable-is-lean-for-constructive-mathematics\">How usable is Lean for constructive mathematics?</a>.  <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> pointed out that as long as one doesn't use the <code>Classical</code> namespace then one won't get LEM or AC?  This isn't actually true in Lean 3 (e.g. in the order library there is <code>lt_or_eq_of_le</code>), and it is even less true in Lean 3 community (<code>by_cases</code> tactic is always available).  Will there be a clear separation of classical reasoning in Lean 4?  (I'm not saying their should be, I'm just curious.)  Also, what about the other axioms, <code>quot.sound</code> and <code>propext</code>?  Will it be easy to avoid them in Lean 4?</p>",
        "id": 276048391,
        "sender_full_name": "Jason Rute",
        "timestamp": 1647868512
    },
    {
        "content": "<p>To be clear, I'm referring to base Lean 4, not Mathlib 4, which I assume will remain unashamedly classical.</p>",
        "id": 276048512,
        "sender_full_name": "Jason Rute",
        "timestamp": 1647868572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> <br>\nThe bare-bones system can be used for constructive mathematics. That being said, a lot of the proof automation we are building is using axioms such as <code>propext</code>. For example, <code>simp</code> uses it all over the place. Similarly, the builtin <code>by_cases</code> in Lean 4 uses <code>em</code> and doesn't even bother checking whether the proposition is decidable. Moreover, any theorem in core Lean that uses these theorems will depend on these axioms. So, the short answer is \"no, we are not trying to compartmentalize axioms\".<br>\nIn previous versions of Lean, we spent a lot of time trying to avoid these axioms and providing special constructions for special cases, but I think it was not worth it. <br>\nAre you interested in constructive mathematics, or just curious?</p>",
        "id": 276050273,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647869395
    },
    {
        "content": "<p>I personally am more curious than anything else at this point.  I think others might be more interested, but they can speak for themselves.  I totally understand the need to make tradeoffs, and I was just looking for some clarity on what these tradeoffs currently are.  Thanks!</p>",
        "id": 276050951,
        "sender_full_name": "Jason Rute",
        "timestamp": 1647869742
    },
    {
        "content": "<p>We didn't take this decision lightly. It would be great if we had infinite resources, and we could support the minority that cares about constructive mathematics. In my point of view, the vast majority of the CS community don't care about constructivism, same for the math community. Sometimes, I see mathematicians assuming that most CS people care about constructivism, this is not true at all. Most don't even know constructivism exists. Moreover, verifying software is already super hard, I don't think it is worth making it even harder by trying to produce a constructive proof. Imagine someone verified a TLS protocol implementation is correct, would you really care whether the proof is constructive or not? <br>\nNote that the power of Lean comes from its community and Mathlib. Mathlib is already much bigger than the Lean implementation, in a few years, it will be many orders of magnitude bigger. I think it will not be feasible to refactor the whole thing to make it friendly for constructive users. I don't like to send users away, but if a user is interested in constructive mathematics, we should explicitly say they should consider using a different system (e.g., Agda or Coq).</p>",
        "id": 276053180,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647870709
    },
    {
        "content": "<p>I'm interested in synthesizing programs in Lean. I'm experimenting in using tactic mode to rewrite specification to computable programs. So far, I have never run into a problem with non-computability. </p>\n<p>What would a better support for constructivism in Lean actually mean? What kind stuff would that allow that is currently not possible?</p>\n<p>The only thing I'm aware of is the problem with stuff like <code>recursor 'Even.casesOn' can only eliminate into Prop</code> but then I can just define <code>Even n</code> to by in <code>Type</code> instead of <code>Prop</code> and problem solved. Maybe the problem is with <code>Eq</code> as you can't change that to be in <code>Type</code>.</p>",
        "id": 276062809,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1647874650
    },
    {
        "content": "<blockquote>\n<p>I'm interested in synthesizing programs in Lean. I'm experimenting in using tactic mode to rewrite specification to computable programs. So far, I have never run into a problem with non-computability.</p>\n</blockquote>\n<p>This is not a problem. Tactics that use classical principles produce terms of type <code>Prop</code> which are erased anyway during code generation.</p>\n<blockquote>\n<p>What would a better support for constructivism in Lean actually mean?</p>\n</blockquote>\n<p>In previous versions of Lean, we spent time writing proof automation that would avoid using axioms such as <code>propext</code> and <code>Quot.sound</code>. For example, the proof for function extensionality in Lean depends on the <code>Quot.sound</code> axiom, and we use <code>funext</code> to go inside quantifiers in <code>simp</code> and <code>conv</code>. </p>\n<p>TPIL has a chapter about these axioms <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html\">https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html</a></p>",
        "id": 276120295,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647900384
    },
    {
        "content": "<p>I am probably someone who conflates computer scientists with constructivists -- I should be more careful. I suspect that the computer scientists I've met in the last few years are not a representative sample.</p>",
        "id": 276155328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647937378
    },
    {
        "content": "<p>This also can be addressed gradually down the road, no? There's nothing stopping future users of Lean with too much time on their hands from slowly pushing LEM out of parts of mathlib.</p>",
        "id": 276226922,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647970767
    },
    {
        "content": "<p>This is already done to some extent. For example <code>ring int</code> used to need LEM and doesn't on more recent versions. But the tooling for preventing regressions is lacking at the moment, because most contributors don't pay attention to LEM usage (and we don't want them to have to either)</p>",
        "id": 276286718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648008994
    },
    {
        "content": "<p>Call me a skeptic but I suspect that it will be impossible to remove much LEM. The issue is not just that lots of maths in mathlib simply doesn't work without LEM and in many of the cases where it can be done it's already done that way anyway; the issue is that without LEM one definition can become two or three independent definitions and changing a definition which is super convenient for defeqs to one which is constructively stronger but more inconvenient to use is not going to be a PR which will look appealing (\"a definition is changed to something which is classically the same and now we have to add 100 new lines of code\")</p>",
        "id": 276295286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648019417
    },
    {
        "content": "<p>We had this with valuations once. One of the axioms for a valuation on a ring is v(a+b)&lt;=max (v(a),v(b)) and when Kenny wrote the code he wrote the constructive version \"v(a+b)&lt;=v(a) or v(a+b)&lt;=v(b)\" because he didn't want to take a max on an arbitrary linear order because max is defined via a case split. It drove us nuts trying to use this though so we just changed it to the max version and any attempt to change it back would involve just making a bunch of code worse</p>",
        "id": 276295563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648019687
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I don't think anyone is really concerned about removing LEM from theorems. Classical theories are just that: classical theories. It's a take it or leave it thing. Some people are interested in intuitionistic and constructive theories, all of these people are aware that they can't use classical theories willy nilly. The issue which is of concern is whether _tactics_ can introduce LEM surreptitiously. <code>by_cases</code> does that, so people who care about avoiding LEM should be aware that they need to avoid this tactic. It's the only place where <code>mkEM</code> is used in Lean 4, so I would assume it's the only one so far.</p>",
        "id": 276306344,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1648027659
    },
    {
        "content": "<p>In lean 3 there was even a tactic which billed itself as intuitionistic but would occasionally accidentally use classical axioms. It was either called itauto or ifinish. It caused so much confusion at some point that I think we might have removed it.</p>",
        "id": 276311891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648030833
    },
    {
        "content": "<p>Avoiding certain tactics sounds like a slippery slope to me. In mathlib I should think we would reserve the right to rewrite tactics so that they magically became nonconstructive but were somehow better (eg faster) as a consequence.</p>",
        "id": 276312177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648030988
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Mathlib should stay classical. I think everybody here is fine with that. Maybe some people think mathlib should be everything for everybody but that doesn't make sense. Most things for most folks is more than enough a goal for one library!</p>",
        "id": 276325480,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1648038572
    },
    {
        "content": "<p>For the select few that do care about this (mainly PL researchers) does it seem feasible to have some sort of lint rule that ensures all definitions in a file don't rely on classical? I haven't looked into how much support the compiler has for tracking axiom usage...</p>",
        "id": 276695682,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1648255341
    },
    {
        "content": "<p>You can use <code>#print axioms Classical.em</code> to print out axioms for a symbol. I don't know if there is a linter for checking axioms, but should be possible to implement.</p>",
        "id": 276697287,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1648257485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Compartmentalization.20of.20axioms.20in.20Lean.204/near/276695682\">said</a>:</p>\n<blockquote>\n<p>For the select few that do care about this (mainly PL researchers) does it seem feasible to have some sort of lint rule that ensures all definitions in a file don't rely on classical?</p>\n<p>I haven't looked into how much support the compiler has for tracking axiom usage.</p>\n</blockquote>\n<p>Note that almost everything that was proved using <code>simp</code> depends on <code>propext</code>. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">List.length_append</span>\n</code></pre></div>",
        "id": 276698330,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648258948
    },
    {
        "content": "<p>The underlying <code>simp</code> algorithm doesn't really need this though, and we might want to relax it to support relations other than <code>Eq</code> and <code>HEq</code>, in which case most of those <code>propext</code> applications will go away</p>",
        "id": 276707306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648272845
    },
    {
        "content": "<p>(that is, I think there are good reasons to pursue extending <code>simp</code> to support congruence through other relations which has nothing to do with axiom use, but will incidentally fix this <code>propext</code> behavior)</p>",
        "id": 276707330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648272917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <br>\nYes, we know. This is exactly the approach we used in Lean 3 ;)<br>\nHowever, it imposes additional bookkeeping in <code>simp</code>, extra effort from users (they have to keep proving congruence lemmas for such as <code>and_congr</code>, <code>or_congr</code>), etc. We did all that in Lean 3, and it was barely useful. I don't recall seeing people simplifying terms using different relations in Mathlib. If I remember correctly, Mathlib contains <code>[congr]</code> rules for the list permutation relation, but I think I was the one that added them for fun and testing <code>simp</code>, and they can be avoided.</p>\n<p>Moreover, we use <code>funext</code> to go inside binders, and <code>funext</code> depends on <code>Quot.sound</code>. One could use <code>Setoid</code>s to avoid the <code>Quot.sound</code> dependency, but I don't think it is worth the trouble.</p>",
        "id": 276725092,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648299760
    },
    {
        "content": "<p>My general impression was that the support for relations other than equality in simp and rw was incomplete or deficient in some way, and so it may not have gotten much use in mathlib for that reason (although that impression might have been mistaken). It's true that with quotient types and propext we don't really have a huge need to care about relations other than eq, although especially for non-symmetric relations we had to hack something together in its place (<code>mono</code>)</p>",
        "id": 276725257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648299989
    },
    {
        "content": "<p>I am curious about this claimed deficiency. In Lean 3, <code>simp</code> is rewriting with <code>&lt;-&gt;</code> all the time. So, the support should work. <br>\nRegarding <code>rw</code>, let's not include it on this thread. It is a different piece of automation used to apply <code>Eq.rec</code>.</p>",
        "id": 276725451,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648300285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Compartmentalization.20of.20axioms.20in.20Lean.204/near/276695682\">said</a>:</p>\n<blockquote>\n<p>For the select few that do care about this (mainly PL researchers) does it seem feasible to have some sort of lint rule that ensures all definitions in a file don't rely on classical?</p>\n<p>I haven't looked into how much support the compiler has for tracking axiom usage.</p>\n</blockquote>\n<p>Yes, I have seen PL researchers (working on type theory) claiming to be constructivists and saying axioms like <code>propext</code> and <code>Quot.sound</code> are a \"sin\". Most of them seem to be leaning towards cubical systems. Even if we compartmentalize axioms in Lean, I think Lean will not be an attractive system for them. I think this is fine, and they can use a system such as Cubical Agda.</p>",
        "id": 276725679,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648300583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/270676-lean4/topic/Compartmentalization.20of.20axioms.20in.20Lean.204/near/276725451\">said</a>:</p>\n<blockquote>\n<p>I am curious about this claimed deficiency. In Lean 3, <code>simp</code> is rewriting with <code>&lt;-&gt;</code> all the time. So, the support should work. </p>\n</blockquote>\n<p>Something we're not sure how to do in mathlib is use <code>simp</code> to rewrite relations such as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/int.modeq\">docs#int.modeq</a>. There have been a few discussions about it, and the best ideas we've had seem to involve writing custom tactics. (As far as my own understanding goes, the only <code>simp</code> feature I know about that applies to general relations is <code>lift_eq</code>, to prove reflexive relations by trying to prove an equality instead.)</p>",
        "id": 276734663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648313305
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> The Lean 3 simplifier is parametrized by a relation. Example: <a href=\"https://github.com/leanprover/lean/blob/master/src/library/tactic/simplify.cpp#L220\">https://github.com/leanprover/lean/blob/master/src/library/tactic/simplify.cpp#L220</a></p>",
        "id": 276741357,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648322461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> This is surely showing my ignorance about congruence lemmas, but when I saw the following error I assumed it wasn't designed to work this way. (I specialized it to mod-5 just to be sure it didn't have to do with additional arguments for relations.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.int.modeq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mod5</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">≡</span> <span class=\"n\">y</span> <span class=\"o\">[</span><span class=\"n\">ZMOD</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">≡₅</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">mod5</span>\n\n<span class=\"kd\">@[refl]</span> <span class=\"kd\">theorem</span> <span class=\"n\">mod5.refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≡₅</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">rfl</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">@[symm]</span> <span class=\"kd\">theorem</span> <span class=\"n\">mod5.symm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≡₅</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≡₅</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">eq.symm</span>\n\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">theorem</span> <span class=\"n\">mod5.trans</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≡₅</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≡₅</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≡₅</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">eq.trans</span>\n\n<span class=\"kd\">@[congr]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mod5.add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≡₅</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≡₅</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">≡₅</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">int.modeq.add</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">invalid congruence lemma, 'mod5.add' the left-hand-side of the congruence resulting type must be</span>\n<span class=\"cm\">of the form (has_add.add x_1 ... x_n), where each x_i is a distinct variable or a sort</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>(I'm looking through the logic <code>simp_lemmas.cpp</code> to try to understand how this works better.)</p>",
        "id": 276742030,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648323408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> See this <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/list/perm.lean#L189-L190\">https://github.com/leanprover-community/mathlib/blob/master/src/data/list/perm.lean#L189-L190</a></p>",
        "id": 276742129,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648323559
    },
    {
        "content": "<p>That gave me a hint for what's going on, but I still don't completely understand the problem. This is a workaround:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zadd</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">@[congr]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mod5.add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≡₅</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≡₅</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">zadd</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">≡₅</span> <span class=\"n\">zadd</span> <span class=\"n\">b</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">int.modeq.add</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n</code></pre></div>",
        "id": 276742273,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648323791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> Based on my understanding of the source code, my guess is that <code>int.has_add</code> is not allowed in the LHS since it's not a variable.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mod5.add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">),</span>\n  <span class=\"n\">mod5</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">mod5</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">mod5</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_add.add</span> <span class=\"n\">int</span> <span class=\"n\">int.has_add</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_add.add</span> <span class=\"n\">int</span> <span class=\"n\">int.has_add</span> <span class=\"n\">b</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It can't be a variable, though, since this theorem depends on a specific additive structure.</p>",
        "id": 276742698,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648324361
    },
    {
        "content": "<p>Is it safe to extend the list of allowed non-variable objects to include instances (or maybe if it's an argument that's identical on the LHS and RHS)? <a href=\"https://github.com/leanprover-community/lean/blob/master/src/library/tactic/simp_lemmas.cpp#L997\">https://github.com/leanprover-community/lean/blob/master/src/library/tactic/simp_lemmas.cpp#L997</a></p>",
        "id": 276742790,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648324496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I am sorry, but I don't have cycles to invest in the old Lean 3 code. If supporting relations such as <code>≡₅</code> would make a big difference to users, I am happy to help with it after the Mathlib porting has been completed.</p>",
        "id": 276743436,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648325382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> That's fine -- I'll probably look into it since rewriting for ZMOD has been an issue a number of us have faced for teaching.</p>",
        "id": 276743502,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648325445
    },
    {
        "content": "<p>The fix I used with ZMOD in my class was to quotient out and then just rewrite equality</p>",
        "id": 276748175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648332014
    },
    {
        "content": "<p>How about just avoiding unnecessary use of AC/LEM in the core library? In the internal language of a topos (with sufficient universes) all the other rules and axioms of Lean are valid. This would make it possible to use the core Lean system for various sorts of synthetic reasoning involving anticlassical postulates (e.g., synthetic differential geometry).</p>\n<p>I agree that mathlib should remain classical for the reasons Kevin mentioned (classical notions do not map in a one-to-one fashion to constructive notions). But at least at the moment, it looks like it would be quite easy to eliminate uses of AC from the core library. The only uses I saw are that LEM is used to decide (in)equalities on <code>Nat</code> and maybe <code>Int</code>, arising from <code>by_cases</code>. The simplest thing to do would be to add <code>by_cases_dec</code> (using <code>Decidable.em</code>) and use it where appropriate.</p>\n<p>I guess the main question is: going forward, as the core library (potentially?) expands, is it reasonable to assume that PRs removing unnecessary uses of AC would be accepted?</p>",
        "id": 283068484,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653053100
    },
    {
        "content": "<p>Mathlib should definitely remain classical if it wishes to remain relevant to Fields Medalists :-) What goes on in core is of course none of my business, they can do what they like in there as long as I can still use it to do classical maths.</p>",
        "id": 283158849,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653117134
    },
    {
        "content": "<p>I mean, Voevodsky was a Fields medalist and he created the HoTT/UF library--are we only counting living ones?<br>\nI agree with your general point, but I think you could find a better way to express it.</p>",
        "id": 283178196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653145771
    },
    {
        "content": "<p>The classical interest in this particular set of axioms comes from externalization--a constructive theorem about abelian groups is also a classical theorem about sheaves of abelian groups on the etale site of a scheme or whatever.</p>",
        "id": 283178432,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653146066
    },
    {
        "content": "<p>You're right Reid, my post is not at all well expressed. Sorry. Probably a much more sensible thing to say would be \"remain relevant to people like me\"!</p>\n<p>Here's a maths question coming from this though. Say I have a constructive proof in mathlib about mathlib's abelian groups. Can one now write some kind of tactic which spits out the corresponding theorem about mathlib's sheaves of abelian groups?</p>",
        "id": 283183658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653153376
    },
    {
        "content": "<p>I think that this is painting an unnecessarily adversarial picture of intuitionizing lean / mathlib. It's perfectly possible to remove unneeded axioms from (proof irrelevant!) theorems without having the slightest impact on classical math or mathematicians</p>",
        "id": 283184764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653154843
    },
    {
        "content": "<p>And regarding Reid's question, it's not my decision but I would certainly say \"absolutely, yes\" to PRs removing unnecessary uses of AC (indeed I've filed a couple of these to lean 3 core myself), provided they do not make the classical mathematics situation more cumbersome (including breaking useful defeqs). For other things like intuitionistic concepts fractured from classically equivalent things, they should just be new theories and classical mathematicians should feel free to ignore them</p>",
        "id": 283184849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653155005
    },
    {
        "content": "<p>I think everyone is aware that classical mathematics is an important use case of mathlib and no one has ever suggested that it would be okay to make sacrifices in this use case for the sake of intuitionizing. But it's not like it's a zero sum game</p>",
        "id": 283184922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653155123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Compartmentalization.20of.20axioms.20in.20Lean.204/near/283183658\">said</a>:</p>\n<blockquote>\n<p>Here's a maths question coming from this though. Say I have a constructive proof in mathlib about mathlib's abelian groups. Can one now write some kind of tactic which spits out the corresponding theorem about mathlib's sheaves of abelian groups?</p>\n</blockquote>\n<p>In principle yes (assuming mathlib's definition of a group hasn't diverged from the constructively correct one). In practice, it would probably take a lot of design and engineering work to make it useful.</p>",
        "id": 283248978,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653249630
    },
    {
        "content": "<blockquote>\n<p>I guess the main question is: going forward, as the core library (potentially?) expands, is it reasonable to assume that PRs removing unnecessary uses of AC would be accepted?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Thanks for raising this issue. Is the use case you described a hypothetical one? \"Hypothetical\" here means \"perhaps one day someone will benefit from this modification\". I agree with you that it is currently easier to eliminate unnecessary uses of AC/LEM than removing uses of <code>propext</code> and <code>Quot.sound</code>. I feel it is only worth doing this kind of change if we have real applications right now that will benefit from it. I spent a lot of time in the past adding code for special cases that have never been used in practice, and I am trying to avoid this kind of waste. Even if the PRs are simple, they still need to be reviewed, and future automation will also have to make sure AC/LEM is only used when needed to make sure we provide a coherent system to users.</p>",
        "id": 283367641,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1653335048
    },
    {
        "content": "<p>I like to think of this something like rust's <a href=\"https://doc.rust-lang.org/rustc/platform-support.html\">target tiers</a>, which make it a bit easier to formalize what level of support is provided:</p>\n<ul>\n<li>Tier 1: guaranteed to work, has official support</li>\n<li>Tier 2: guaranteed to build, but no automatic testing so bugs might happen</li>\n<li>Tier 3: The codebase nominally supports it, but support is primarily handled by interested external users</li>\n</ul>\n<p>I would classify intuitionistic logic support in lean as tier 3: devs won't actively try to remove support but they also won't try to keep things working (i.e. automated regression testing for AC use), and of course support is not on any roadmap. I think the big question is whether unsolicited PRs that adjust support for tier 3 things are rejected, given that there is not really any testing to ensure that the changes work; I would be inclined to be generous with such PRs as long as they don't impact any of the tier 1 goals.</p>",
        "id": 283680549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653350476
    },
    {
        "content": "<p>I find classifying support into levels like this makes it easier as a dev to be at peace with not working on certain things that seem good on their face but might not fit with current priorities.</p>",
        "id": 283680946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653350783
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think the tier system is a great suggestion. However, right now I don't see \"intuitionistic logic support\" as tier 3. It was in the past, but it has now a \"not supported\" status. I think intuitionistic logic is beautiful, but we have finite resources. We have to focus on the applications we have right now, and none of them rely on intuitionistic logic. I asked Reid in my previous comment whether the use case he described is hypothetical or not. If there is an application that would benefit from this kind of change, let's invest time, otherwise, let's postpone it. PRs are not free, we need to review them, and make sure we can maintain the code later. We are currently overwhelmed by the tier 1 to-do list.</p>",
        "id": 283682044,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1653351831
    },
    {
        "content": "<p>Tier 3 is a pretty low bar, I'm surprised you object to that. In rust that basically equates to hobbyist systems that no one even knows how to find examples of</p>",
        "id": 283682171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653351923
    },
    {
        "content": "<p>you can be sure no one is spending any cycles on supporting them</p>",
        "id": 283682243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653351963
    },
    {
        "content": "<p>that is, tier 3 is explicitly defined to get around the \"I don't have time to support that\" objection because it does not demand any actual dev time commitment</p>",
        "id": 283682365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653352081
    },
    {
        "content": "<p>but maybe things are different if the pool of reviewers is too small so that taking PRs is already too much work</p>",
        "id": 283682458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653352125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> We still have to review the PR and make sure it does not break tier 1 features, or get in the way of features we do want to implement in the future.</p>",
        "id": 283682608,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1653352236
    },
    {
        "content": "<p>True. I don't really want to push for this right now, but I thought I would suggest it as a mental framework (and a warning that I might one day attempt to make one of those intuitionistic PRs - probably not any time in the near to mid term though)</p>",
        "id": 283682738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653352335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> If you have extra time to invest in extra PRs, please invest in the ones that will help the Mathlib port. They will have a much bigger impact. After we manage to put things in a stable state and Mathlib is ported to Lean 4, we will have the flexibility to handle lower priority PRs such as \"intuitionistic logic support\" PRs.</p>",
        "id": 283683034,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1653352561
    },
    {
        "content": "<p>Yep yep, those are way higher on my todo list. An intuitionization PR would probably come up in conjunction with a project to formalize something without AC for some reason, and that's not even on my radar ATM but it is something I have worked on in the past so I can't discount it completely. (Right now my number 1 priority is finishing my thesis so PRs of any kind have taken a back seat.)</p>",
        "id": 283683202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653352672
    },
    {
        "content": "<p>This is probably a naive question as I have no background in logic but is there a way to embed constructive/intuitionistic logic into the classical logic of Lean? I read something about constructive logic being equivalent to an infinitely valued logic, so i wonder if that could be embedded somehow. I have no preference for constructive logic per se but I am interested in smooth infinitesimal analysis/synthetic differential geometry, which denies double negation/LEM.</p>",
        "id": 288287854,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1656792687
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243102\">@Brandon Brown</span> Lean's kernel is actually constructive/intuitionistic. Classical logic is only achieved through additional axioms. The caveat, though, is that many of the tactics in the Lean core make liberal uses of classical axioms even when not strictly necessary. Thus, proper intuitionistic support in Lean would be achieved through the refinement of such tactics to aim for intuitionistic solutions rather than classical ones.</p>",
        "id": 288296256,
        "sender_full_name": "Mac",
        "timestamp": 1656806045
    },
    {
        "content": "<p>Some good examples of tactics and definitions which are unnecessarily classical would be <code>split</code> (which uses choice when often not necessary) and many simp lemmas (e.g., for <code>Bool</code>) which use equal <code>=</code> and <code>propext</code> when the biconditional <code>&lt;-&gt;</code> would be sufficient.</p>",
        "id": 288296323,
        "sender_full_name": "Mac",
        "timestamp": 1656806176
    },
    {
        "content": "<p>Right, I suppose it would be nice if the tactics didn't use LEM by default, but I also understand that the vast majority of Lean code is going to be classical so from an efficiency perspective it makes sense, that's why I was wondering if if it is possible to embed a constructive logic inside a classical universe so you don't have to rewrite tactics, so the onus would be on the constructivists to put in more upfront work.</p>",
        "id": 288298703,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1656809899
    },
    {
        "content": "<p>On a related note: it would be nice to have some way to say you don't want to use a certain axiom, which would raise an error when using a tactic/theorem that depends on this forbidden axiom. Besides the intuitionism discussion, this can also help track down unexpected dependencies on <code>sorryAx</code>.</p>",
        "id": 288326111,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1656852682
    }
]
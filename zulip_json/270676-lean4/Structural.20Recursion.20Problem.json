[
    {
        "content": "<p>In the following, I feel like <code>Lineage.container</code> should be structurally recursive. Apparently it isn't though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">ID</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- A `Reactor` contains \"things\" identified by an `ID`. It also contains other `Reactor`s, thereby giving us a tree structure of reactors.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Reactor</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span>\n    <span class=\"o\">(</span><span class=\"n\">things</span> <span class=\"o\">:</span> <span class=\"n\">ID</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">nested</span> <span class=\"o\">:</span> <span class=\"n\">ID</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Reactor</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Structure projections.</span>\n<span class=\"kd\">def</span> <span class=\"n\">Reactor.things</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"bp\">→</span> <span class=\"n\">ID</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span>     <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t</span>\n<span class=\"kd\">def</span> <span class=\"n\">Reactor.nested</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"bp\">→</span> <span class=\"n\">ID</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Reactor</span> <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- A `Lineage` is supposed to express a \"path\" within a reactor tree.</span>\n<span class=\"c1\">-- E.g. a `Lineage rtr i` captures a path from the root reactor `rtr` to some thing identified by ID `i`.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Lineage</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span> <span class=\"bp\">→</span> <span class=\"n\">ID</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">thing</span> <span class=\"o\">{</span><span class=\"n\">rtr</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">rtr.things</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nested</span> <span class=\"o\">{</span><span class=\"n\">rtr'</span> <span class=\"n\">i'</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Lineage</span> <span class=\"n\">rtr'</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">rtr.nested</span> <span class=\"n\">i'</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span>\n\n<span class=\"c1\">-- The `Lineage.container` function is supposed to return the reactor (along with its ID) that is the immediate parent of the thing reached by the lineage.</span>\n<span class=\"c1\">-- We therefore need to check \"two steps deep\":</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lineage.container</span> <span class=\"o\">{</span><span class=\"n\">rtr</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">ID</span> <span class=\"bp\">×</span> <span class=\"n\">Reactor</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- If the lineage is still two or more \"nestings\" deep, perform a recursive call on the nested lineage.</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nested</span> <span class=\"n\">l</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nested</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.container</span>\n  <span class=\"c1\">-- If the lineage is nested only one layer deep, the nested lineage (`: Lineage rtr' i`) contains the thing identified by `i`.</span>\n  <span class=\"c1\">-- Therefore `rtr'` is the container, which in the context of `rtr` is identified by `i'`.</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">nested</span> <span class=\"n\">rtr'</span> <span class=\"n\">i'</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- If the lineage is not nested at all, we know that the root reactor `rtr` is the container, and we return no ID.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">rtr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>On <code>Lineage.container</code>, Lean says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fail</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">termination</span> <span class=\"n\">for</span>\n  <span class=\"n\">Lineage.container</span>\n<span class=\"k\">with</span> <span class=\"n\">errors</span>\n<span class=\"n\">argument</span> <span class=\"bp\">#</span><span class=\"mi\">3</span> <span class=\"n\">was</span> <span class=\"n\">not</span> <span class=\"n\">used</span> <span class=\"n\">for</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n  <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">eliminate</span> <span class=\"n\">recursive</span> <span class=\"n\">application</span>\n    <span class=\"n\">container</span> <span class=\"n\">l</span>\n\n<span class=\"n\">structural</span> <span class=\"n\">recursion</span> <span class=\"n\">cannot</span> <span class=\"n\">be</span> <span class=\"n\">used</span>\n\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n</code></pre></div>\n<p>The formalization of <code>Lineage</code> has been giving me headaches in a couple of places now.<br>\nWould it be wise to change how it's formalized? If so, how?</p>",
        "id": 284238723,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653757981
    },
    {
        "content": "<p>This is related to <a href=\"https://github.com/leanprover/lean4/issues/501\">https://github.com/leanprover/lean4/issues/501</a> (in the sense that <code>@</code> does more than introduce an abbreviation for the subpattern)</p>",
        "id": 284238983,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653758339
    },
    {
        "content": "<p>The <code>@</code> annotation has a lot of side effects.</p>",
        "id": 284239092,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653758473
    },
    {
        "content": "<p>It works if you remove the <code>@</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- The `Lineage.container` function is supposed to return the reactor (along with its ID) that is the immediate parent of the thing reached by the lineage.</span>\n<span class=\"c1\">-- We therefore need to check \"two steps deep\":</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lineage.container</span> <span class=\"o\">{</span><span class=\"n\">rtr</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">ID</span> <span class=\"bp\">×</span> <span class=\"n\">Reactor</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- If the lineage is still two or more \"nestings\" deep, perform a recursive call on the nested lineage.</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nested</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nested</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">container</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nested</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- If the lineage is nested only one layer deep, the nested lineage (`: Lineage rtr' i`) contains the thing identified by `i`.</span>\n  <span class=\"c1\">-- Therefore `rtr'` is the container, which in the context of `rtr` is identified by `i'`.</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">nested</span> <span class=\"n\">rtr'</span> <span class=\"n\">i'</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- If the lineage is not nested at all, we know that the root reactor `rtr` is the container, and we return no ID.</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">rtr</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 284239106,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653758493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Thanks, that did the job!<br>\nI still have the following problem though, even after changing the definition of <code>Lineage.container</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lineage.container</span> <span class=\"o\">{</span><span class=\"n\">rtr</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">ID</span> <span class=\"bp\">×</span> <span class=\"n\">Reactor</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nested</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nested</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Lineage.nested</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">container</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">nested</span> <span class=\"n\">rtr'</span> <span class=\"n\">i'</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">rtr</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">rtr</span> <span class=\"o\">:</span> <span class=\"n\">Reactor</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">rtr.things</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Lineage.thing</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">container</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">rtr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Lineage.container</span><span class=\"o\">]</span> <span class=\"c1\">-- failed to generate equality theorems for `match` expression `Lineage.container.match_1`</span>\n                           <span class=\"c1\">-- ...</span>\n</code></pre></div>\n<p>I'm not sure if this is related to this topic, or if it's something completely different though.</p>",
        "id": 284244688,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653766177
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> You can avoid the failure by avoiding the overlap between the first and second cases.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">Lineage.container''</span> <span class=\"o\">:</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">ID</span> <span class=\"bp\">×</span> <span class=\"n\">Reactor</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nested</span> <span class=\"o\">(</span><span class=\"n\">nested</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Lineage.nested</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">container''</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nested</span> <span class=\"o\">(</span><span class=\"n\">rtr</span> <span class=\"o\">:=</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">i'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">thing</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">rtr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>We will try to improve the tactic used to prove the equations theorems, and make sure it can prove that the particular case in the error message is \"unreachable\".<br>\nYou can use <code>l@</code> notation if you provide additional annotations</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">Lineage.container</span> <span class=\"o\">:</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">ID</span> <span class=\"bp\">×</span> <span class=\"n\">Reactor</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nested</span> <span class=\"n\">l</span><span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">:(</span><span class=\"n\">nested</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.container</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nested</span> <span class=\"o\">(</span><span class=\"n\">rtr</span> <span class=\"o\">:=</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">i'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">thing</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">rtr</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">r</span>\n<span class=\"n\">decreasing_by</span> <span class=\"n\">simp_wf</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">simp_arith</span>\n</code></pre></div>\n<p>The <code>h:</code> at <code>l@h:(nested ..)</code> is instructing Lean to add a hypothesis <code>h : l = nested ..</code>.  I provided a custom <code>decreasing_by</code> to make sure this hypothesis is used. We will improve the default <code>decreasing</code> tactic.</p>",
        "id": 284248830,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1653772547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> I pushed the two improvements described above. You can now write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">Lineage.container</span> <span class=\"o\">:</span> <span class=\"n\">Lineage</span> <span class=\"n\">rtr</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">ID</span> <span class=\"bp\">×</span> <span class=\"n\">Reactor</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nested</span> <span class=\"n\">l</span><span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">:(</span><span class=\"n\">nested</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.container</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">nested</span> <span class=\"n\">rtr'</span> <span class=\"n\">i'</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">rtr'</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">rtr</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 284253601,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1653780445
    },
    {
        "content": "<p>The <code>h:</code> annotation may look a bit weird because it looks like a dead variable, but it is used in the termination proof.</p>",
        "id": 284253628,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1653780506
    },
    {
        "content": "<p>It's now in <a href=\"https://github.com/leanprover/lean4-nightly/releases/tag/nightly-2022-05-29\">nightly-2022-05-29</a>. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span><br>\nThanks so much Leo!</p>",
        "id": 284272437,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1653811886
    }
]
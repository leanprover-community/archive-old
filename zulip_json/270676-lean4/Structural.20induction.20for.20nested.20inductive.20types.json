[
    {
        "content": "<p>Is there a way to express structurally inductive functions without manually using <code>rec</code>?<br>\nIn the following example, Lean is unable to show termination for <code>not</code> and <code>size</code>. I'm not sure what else I could potentially write instead of <code>map</code> and <code>foldr</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.not</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">leaf</span> <span class=\"bp\">!</span><span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">not</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.size</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">size</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>My current workaround for this is fairly verbose as it has to deal with the fact that <code>rec</code> is noncomputable by default.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Tree</span>\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">{</span><span class=\"n\">motive₁</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">motive₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">motive₁</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">motive₂</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">motive₁</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"n\">l</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">motive₂</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">motive₁</span> <span class=\"n\">head</span> <span class=\"bp\">→</span> <span class=\"n\">motive₂</span> <span class=\"n\">tail</span> <span class=\"bp\">→</span> <span class=\"n\">motive₂</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">))</span>\n\n<span class=\"kd\">mutual</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">rec'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">motive₁</span> <span class=\"n\">t</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">leaf</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">rec_1'</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">rec_1'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">motive₂</span> <span class=\"n\">l</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span> <span class=\"o\">(</span><span class=\"n\">rec'</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rec_1'</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">mutual</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">rec_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">rec</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">rec'</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">t</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">rec'</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">rec'</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rec_1_</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">rec_1_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">rec_1</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">rec_1'</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">l</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">rec_1'</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">rec_1'</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">congr</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rec_</span> <span class=\"n\">head</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">rec_1_</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[csimp]</span>\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">rec_eq_rec'</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">rec</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">rec'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">funext</span> <span class=\"n\">motive₁</span> <span class=\"n\">motive₂</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">t</span>\n  <span class=\"n\">apply</span> <span class=\"n\">rec_</span>\n\n<span class=\"kd\">@[csimp]</span>\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">rec_1_eq_rec_1'</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">rec_1</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">rec_1'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">funext</span> <span class=\"n\">motive₁</span> <span class=\"n\">motive₂</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">t</span>\n  <span class=\"n\">apply</span> <span class=\"n\">rec_1_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Tree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.not</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span> <span class=\"o\">:=</span> <span class=\"n\">rec</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">leaf</span> <span class=\"bp\">!</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">node</span><span class=\"o\">)</span>\n  <span class=\"o\">[]</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.size</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rec</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"mi\">0</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 311498853,
        "sender_full_name": "Parth Shastri",
        "timestamp": 1669076791
    },
    {
        "content": "<p>Use well-founded recursion (<code>terminating_by</code> and <code>decreasing_by</code>; I think there should be docs in the manual). Lean doesn't do structural recursion for nested inductive types.</p>",
        "id": 311554368,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1669110376
    },
    {
        "content": "<p>For anyone else that runs into this, the solution is to copy the definitions of <code>map</code> and <code>foldr</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Tree.not</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">leaf</span> <span class=\"bp\">!</span><span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">map_not</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">map_not</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">t</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not</span> <span class=\"n\">t</span> <span class=\"o\">::</span> <span class=\"n\">map_not</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.size</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foldr_size</span> <span class=\"n\">l</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">foldr_size</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n    <span class=\"bp\">|</span> <span class=\"n\">t</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">size</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">foldr_size</span> <span class=\"n\">l</span>\n</code></pre></div>",
        "id": 312966536,
        "sender_full_name": "Parth Shastri",
        "timestamp": 1669768752
    },
    {
        "content": "<p>Just to be clear, copying the List stuff is exactly what Lean is doing to compile the nested inductive in the first place :P but it would be nice if Lean had a computable, autogenerated rec for nested inductives for exactly this reason</p>",
        "id": 312967794,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1669769593
    },
    {
        "content": "<p>(I assume this is one of the things on the dev list for after the new code generator is done)</p>",
        "id": 312967897,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1669769651
    },
    {
        "content": "<p>What surface-level recursion syntax is accepted is basically completely orthogonal to what it's compiled down to. The above code follows the structure of the underlying mutual inductive types, but it's still compiled down to well-founded recursion as there is no elaboration support for mutual structural recursion either. So whether there is a computable recursor does not directly impact what Lean accepts.</p>",
        "id": 313011721,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1669798353
    },
    {
        "content": "<p>A different solution to mutual recursion is to use dependently typed versions of <code>map</code> etc. that come with a proof that the element is part of the list, which can be used to prove well-founded recursion automatically. One idea for making the initial code just work is to have the WF elaborator do such function substitutions automatically.</p>",
        "id": 313012683,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1669798792
    }
]